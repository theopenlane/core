package events

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/rs/zerolog/log"

	"github.com/theopenlane/core/pkg/enums"
	"github.com/theopenlane/core/pkg/events/soiree"
	"github.com/theopenlane/core/pkg/sleuth/scan"
)

const TopicVulnerabilityScan = "vulnerability.scan"

// VulnerabilityScanEvent triggers a vulnerability scan for a domain.
type VulnerabilityScanEvent struct {
	ScanID string
	Domain string
	OrgID  string
}

// RegisterVulnerabilityScanListener registers the asynchronous vulnerability scan listener.
func RegisterVulnerabilityScanListener(pool *soiree.EventPool) error {
	if pool == nil {
		return fmt.Errorf("nil event pool")
	}

	_, err := pool.On(TopicVulnerabilityScan, handleVulnerabilityScan)
	return err
}

const defaultTaskThreshold = 7.0

func handleVulnerabilityScan(evt soiree.Event) error {
	payload, ok := evt.Payload().(VulnerabilityScanEvent)
	if !ok {
		log.Error().Msg("invalid vulnerability scan payload")
		return nil
	}

	sc := evt.Client().(*ScanClient)
	//	client := sc.Client
	ctx := evt.Context()

	report, err := requestVulnerabilityScan(ctx, sc, payload.Domain)
	status := enums.ScanStatusCompleted
	if err != nil {
		log.Error().Err(err).Msg("vulnerability scan failed")
		status = enums.ScanStatusFailed
	}

	log.Info().Interface("status", status).Msg("vulnerability scan status")
	log.Info().Interface("report", report).Msg("vulnerability scan report")

	return nil
}

func requestVulnerabilityScan(ctx context.Context, sc *ScanClient, domain string) (scan.VulnerabilityReport, error) {
	if sc.ScannerEndpoint == "" {
		return scan.ScanVulnerabilities(ctx, domain)
	}

	var report scan.VulnerabilityReport
	body, _ := json.Marshal(map[string]string{"domain": domain})
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, sc.ScannerEndpoint+"/scan/vulnerability", bytes.NewReader(body))
	if err != nil {
		return report, err
	}

	req.Header.Set("Content-Type", "application/json")
	resp, err := sc.HTTPClient.Do(req)
	if err != nil {
		return report, err
	}

	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return report, fmt.Errorf("scanner response %s", resp.Status)
	}

	err = json.NewDecoder(resp.Body).Decode(&report)
	return report, err
}
