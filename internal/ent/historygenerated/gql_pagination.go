//go:build !enthistorycodegen

// Code generated by ent, DO NOT EDIT.

package historygenerated

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/theopenlane/core/internal/ent/historygenerated/actionplanhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/assessmenthistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/assessmentresponsehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/assethistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/campaignhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/campaigntargethistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/contacthistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/controlhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/controlimplementationhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/controlobjectivehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/customdomainhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/directoryaccounthistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/directorygrouphistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/directorymembershiphistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/discussionhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/dnsverificationhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/documentdatahistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/emailbrandinghistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/emailtemplatehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/entityhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/entitytypehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/evidencehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/filehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/findingcontrolhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/findinghistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/grouphistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/groupmembershiphistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/groupsettinghistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/hushhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/identityholderhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/integrationhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/internalpolicyhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/jobtemplatehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/mappabledomainhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/mappedcontrolhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/narrativehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/notehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/notificationpreferencehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/notificationtemplatehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/organizationhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/organizationsettinghistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/orgmembershiphistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/orgsubscriptionhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/platformhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/procedurehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/programhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/programmembershiphistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/remediationhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/reviewhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/riskhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/scanhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/scheduledjobhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/standardhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/subcontrolhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/subprocessorhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/systemdetailhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/taskhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/templatehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcentercompliancehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcenterdochistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcenterentityhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcenterfaqhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcenterhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcenterndarequesthistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcentersettinghistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcentersubprocessorhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcenterwatermarkconfighistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/userhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/usersettinghistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/vulnerabilityhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/workflowassignmenthistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/workflowassignmenttargethistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/workflowdefinitionhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/workfloweventhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/workflowinstancehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/workflowobjectrefhistory"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types
type (
	Cursor         = entgql.Cursor[string]
	PageInfo       = entgql.PageInfo[string]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

// paginateLimit calculates the limit for pagination based on the first and last arguments.
// and returns the limit multiplied by 10.
// This is to ensure we overfetch the data to get the number of requested results.
func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first * 10
	} else if last != nil {
		limit = *last * 10
	}
	return limit
}

// ActionPlanHistoryEdge is the edge representation of ActionPlanHistory.
type ActionPlanHistoryEdge struct {
	Node   *ActionPlanHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// ActionPlanHistoryConnection is the connection containing edges to ActionPlanHistory.
type ActionPlanHistoryConnection struct {
	Edges      []*ActionPlanHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *ActionPlanHistoryConnection) build(nodes []*ActionPlanHistory, pager *actionplanhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ActionPlanHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ActionPlanHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ActionPlanHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ActionPlanHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ActionPlanHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ActionPlanHistoryPaginateOption enables pagination customization.
type ActionPlanHistoryPaginateOption func(*actionplanhistoryPager) error

// WithActionPlanHistoryOrder configures pagination ordering.
func WithActionPlanHistoryOrder(order *ActionPlanHistoryOrder) ActionPlanHistoryPaginateOption {
	if order == nil {
		order = DefaultActionPlanHistoryOrder
	}
	o := *order
	return func(pager *actionplanhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultActionPlanHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithActionPlanHistoryFilter configures pagination filter.
func WithActionPlanHistoryFilter(filter func(*ActionPlanHistoryQuery) (*ActionPlanHistoryQuery, error)) ActionPlanHistoryPaginateOption {
	return func(pager *actionplanhistoryPager) error {
		if filter == nil {
			return errors.New("ActionPlanHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type actionplanhistoryPager struct {
	reverse bool
	order   *ActionPlanHistoryOrder
	filter  func(*ActionPlanHistoryQuery) (*ActionPlanHistoryQuery, error)
}

func newActionPlanHistoryPager(opts []ActionPlanHistoryPaginateOption, reverse bool) (*actionplanhistoryPager, error) {
	pager := &actionplanhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultActionPlanHistoryOrder
	}
	return pager, nil
}

func (p *actionplanhistoryPager) applyFilter(query *ActionPlanHistoryQuery) (*ActionPlanHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *actionplanhistoryPager) toCursor(_m *ActionPlanHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *actionplanhistoryPager) applyCursors(query *ActionPlanHistoryQuery, after, before *Cursor) (*ActionPlanHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultActionPlanHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *actionplanhistoryPager) applyOrder(query *ActionPlanHistoryQuery) *ActionPlanHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultActionPlanHistoryOrder.Field {
		query = query.Order(DefaultActionPlanHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *actionplanhistoryPager) orderExpr(query *ActionPlanHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultActionPlanHistoryOrder.Field {
			b.Comma().Ident(DefaultActionPlanHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ActionPlanHistory.
func (_m *ActionPlanHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ActionPlanHistoryPaginateOption,
) (*ActionPlanHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newActionPlanHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ActionPlanHistoryConnection{Edges: []*ActionPlanHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ActionPlanHistoryOrderFieldHistoryTime orders ActionPlanHistory by history_time.
	ActionPlanHistoryOrderFieldHistoryTime = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: actionplanhistory.FieldHistoryTime,
		toTerm: actionplanhistory.ByHistoryTime,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ActionPlanHistoryOrderFieldCreatedAt orders ActionPlanHistory by created_at.
	ActionPlanHistoryOrderFieldCreatedAt = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: actionplanhistory.FieldCreatedAt,
		toTerm: actionplanhistory.ByCreatedAt,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ActionPlanHistoryOrderFieldUpdatedAt orders ActionPlanHistory by updated_at.
	ActionPlanHistoryOrderFieldUpdatedAt = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: actionplanhistory.FieldUpdatedAt,
		toTerm: actionplanhistory.ByUpdatedAt,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ActionPlanHistoryOrderFieldRevision orders ActionPlanHistory by revision.
	ActionPlanHistoryOrderFieldRevision = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: actionplanhistory.FieldRevision,
		toTerm: actionplanhistory.ByRevision,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// ActionPlanHistoryOrderFieldName orders ActionPlanHistory by name.
	ActionPlanHistoryOrderFieldName = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: actionplanhistory.FieldName,
		toTerm: actionplanhistory.ByName,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ActionPlanHistoryOrderFieldStatus orders ActionPlanHistory by status.
	ActionPlanHistoryOrderFieldStatus = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: actionplanhistory.FieldStatus,
		toTerm: actionplanhistory.ByStatus,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ActionPlanHistoryOrderFieldReviewDue orders ActionPlanHistory by review_due.
	ActionPlanHistoryOrderFieldReviewDue = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.ReviewDue, nil
		},
		column: actionplanhistory.FieldReviewDue,
		toTerm: actionplanhistory.ByReviewDue,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewDue,
			}
		},
	}
	// ActionPlanHistoryOrderFieldReviewFrequency orders ActionPlanHistory by review_frequency.
	ActionPlanHistoryOrderFieldReviewFrequency = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.ReviewFrequency, nil
		},
		column: actionplanhistory.FieldReviewFrequency,
		toTerm: actionplanhistory.ByReviewFrequency,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewFrequency,
			}
		},
	}
	// ActionPlanHistoryOrderFieldTitle orders ActionPlanHistory by title.
	ActionPlanHistoryOrderFieldTitle = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: actionplanhistory.FieldTitle,
		toTerm: actionplanhistory.ByTitle,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ActionPlanHistoryOrderFieldDueDate orders ActionPlanHistory by due_date.
	ActionPlanHistoryOrderFieldDueDate = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.DueDate, nil
		},
		column: actionplanhistory.FieldDueDate,
		toTerm: actionplanhistory.ByDueDate,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DueDate,
			}
		},
	}
	// ActionPlanHistoryOrderFieldPriority orders ActionPlanHistory by priority.
	ActionPlanHistoryOrderFieldPriority = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.Priority, nil
		},
		column: actionplanhistory.FieldPriority,
		toTerm: actionplanhistory.ByPriority,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Priority,
			}
		},
	}
	// ActionPlanHistoryOrderFieldSource orders ActionPlanHistory by source.
	ActionPlanHistoryOrderFieldSource = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.Source, nil
		},
		column: actionplanhistory.FieldSource,
		toTerm: actionplanhistory.BySource,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ActionPlanHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ActionPlanHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ActionPlanHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ActionPlanHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ActionPlanHistoryOrderFieldRevision.column:
		str = "revision"
	case ActionPlanHistoryOrderFieldName.column:
		str = "name"
	case ActionPlanHistoryOrderFieldStatus.column:
		str = "STATUS"
	case ActionPlanHistoryOrderFieldReviewDue.column:
		str = "review_due"
	case ActionPlanHistoryOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	case ActionPlanHistoryOrderFieldTitle.column:
		str = "title"
	case ActionPlanHistoryOrderFieldDueDate.column:
		str = "due_date"
	case ActionPlanHistoryOrderFieldPriority.column:
		str = "PRIORITY"
	case ActionPlanHistoryOrderFieldSource.column:
		str = "source"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ActionPlanHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ActionPlanHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ActionPlanHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ActionPlanHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ActionPlanHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ActionPlanHistoryOrderFieldUpdatedAt
	case "revision":
		*f = *ActionPlanHistoryOrderFieldRevision
	case "name":
		*f = *ActionPlanHistoryOrderFieldName
	case "STATUS":
		*f = *ActionPlanHistoryOrderFieldStatus
	case "review_due":
		*f = *ActionPlanHistoryOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *ActionPlanHistoryOrderFieldReviewFrequency
	case "title":
		*f = *ActionPlanHistoryOrderFieldTitle
	case "due_date":
		*f = *ActionPlanHistoryOrderFieldDueDate
	case "PRIORITY":
		*f = *ActionPlanHistoryOrderFieldPriority
	case "source":
		*f = *ActionPlanHistoryOrderFieldSource
	default:
		return fmt.Errorf("%s is not a valid ActionPlanHistoryOrderField", str)
	}
	return nil
}

// ActionPlanHistoryOrderField defines the ordering field of ActionPlanHistory.
type ActionPlanHistoryOrderField struct {
	// Value extracts the ordering value from the given ActionPlanHistory.
	Value    func(*ActionPlanHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) actionplanhistory.OrderOption
	toCursor func(*ActionPlanHistory) Cursor
}

// ActionPlanHistoryOrder defines the ordering of ActionPlanHistory.
type ActionPlanHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *ActionPlanHistoryOrderField `json:"field"`
}

// DefaultActionPlanHistoryOrder is the default ordering of ActionPlanHistory.
var DefaultActionPlanHistoryOrder = &ActionPlanHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: actionplanhistory.FieldID,
		toTerm: actionplanhistory.ByID,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ActionPlanHistory into ActionPlanHistoryEdge.
func (_m *ActionPlanHistory) ToEdge(order *ActionPlanHistoryOrder) *ActionPlanHistoryEdge {
	if order == nil {
		order = DefaultActionPlanHistoryOrder
	}
	return &ActionPlanHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// AssessmentHistoryEdge is the edge representation of AssessmentHistory.
type AssessmentHistoryEdge struct {
	Node   *AssessmentHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// AssessmentHistoryConnection is the connection containing edges to AssessmentHistory.
type AssessmentHistoryConnection struct {
	Edges      []*AssessmentHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *AssessmentHistoryConnection) build(nodes []*AssessmentHistory, pager *assessmenthistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *AssessmentHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AssessmentHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AssessmentHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssessmentHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssessmentHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssessmentHistoryPaginateOption enables pagination customization.
type AssessmentHistoryPaginateOption func(*assessmenthistoryPager) error

// WithAssessmentHistoryOrder configures pagination ordering.
func WithAssessmentHistoryOrder(order *AssessmentHistoryOrder) AssessmentHistoryPaginateOption {
	if order == nil {
		order = DefaultAssessmentHistoryOrder
	}
	o := *order
	return func(pager *assessmenthistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAssessmentHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAssessmentHistoryFilter configures pagination filter.
func WithAssessmentHistoryFilter(filter func(*AssessmentHistoryQuery) (*AssessmentHistoryQuery, error)) AssessmentHistoryPaginateOption {
	return func(pager *assessmenthistoryPager) error {
		if filter == nil {
			return errors.New("AssessmentHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assessmenthistoryPager struct {
	reverse bool
	order   *AssessmentHistoryOrder
	filter  func(*AssessmentHistoryQuery) (*AssessmentHistoryQuery, error)
}

func newAssessmentHistoryPager(opts []AssessmentHistoryPaginateOption, reverse bool) (*assessmenthistoryPager, error) {
	pager := &assessmenthistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAssessmentHistoryOrder
	}
	return pager, nil
}

func (p *assessmenthistoryPager) applyFilter(query *AssessmentHistoryQuery) (*AssessmentHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assessmenthistoryPager) toCursor(_m *AssessmentHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *assessmenthistoryPager) applyCursors(query *AssessmentHistoryQuery, after, before *Cursor) (*AssessmentHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAssessmentHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *assessmenthistoryPager) applyOrder(query *AssessmentHistoryQuery) *AssessmentHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAssessmentHistoryOrder.Field {
		query = query.Order(DefaultAssessmentHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *assessmenthistoryPager) orderExpr(query *AssessmentHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAssessmentHistoryOrder.Field {
			b.Comma().Ident(DefaultAssessmentHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AssessmentHistory.
func (_m *AssessmentHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssessmentHistoryPaginateOption,
) (*AssessmentHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssessmentHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &AssessmentHistoryConnection{Edges: []*AssessmentHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssessmentHistoryOrderFieldHistoryTime orders AssessmentHistory by history_time.
	AssessmentHistoryOrderFieldHistoryTime = &AssessmentHistoryOrderField{
		Value: func(_m *AssessmentHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: assessmenthistory.FieldHistoryTime,
		toTerm: assessmenthistory.ByHistoryTime,
		toCursor: func(_m *AssessmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// AssessmentHistoryOrderFieldCreatedAt orders AssessmentHistory by created_at.
	AssessmentHistoryOrderFieldCreatedAt = &AssessmentHistoryOrderField{
		Value: func(_m *AssessmentHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: assessmenthistory.FieldCreatedAt,
		toTerm: assessmenthistory.ByCreatedAt,
		toCursor: func(_m *AssessmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// AssessmentHistoryOrderFieldUpdatedAt orders AssessmentHistory by updated_at.
	AssessmentHistoryOrderFieldUpdatedAt = &AssessmentHistoryOrderField{
		Value: func(_m *AssessmentHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: assessmenthistory.FieldUpdatedAt,
		toTerm: assessmenthistory.ByUpdatedAt,
		toCursor: func(_m *AssessmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// AssessmentHistoryOrderFieldName orders AssessmentHistory by name.
	AssessmentHistoryOrderFieldName = &AssessmentHistoryOrderField{
		Value: func(_m *AssessmentHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: assessmenthistory.FieldName,
		toTerm: assessmenthistory.ByName,
		toCursor: func(_m *AssessmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// AssessmentHistoryOrderFieldAssessmentType orders AssessmentHistory by assessment_type.
	AssessmentHistoryOrderFieldAssessmentType = &AssessmentHistoryOrderField{
		Value: func(_m *AssessmentHistory) (ent.Value, error) {
			return _m.AssessmentType, nil
		},
		column: assessmenthistory.FieldAssessmentType,
		toTerm: assessmenthistory.ByAssessmentType,
		toCursor: func(_m *AssessmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.AssessmentType,
			}
		},
	}
	// AssessmentHistoryOrderFieldResponseDueDuration orders AssessmentHistory by response_due_duration.
	AssessmentHistoryOrderFieldResponseDueDuration = &AssessmentHistoryOrderField{
		Value: func(_m *AssessmentHistory) (ent.Value, error) {
			return _m.ResponseDueDuration, nil
		},
		column: assessmenthistory.FieldResponseDueDuration,
		toTerm: assessmenthistory.ByResponseDueDuration,
		toCursor: func(_m *AssessmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ResponseDueDuration,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssessmentHistoryOrderField) String() string {
	var str string
	switch f.column {
	case AssessmentHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case AssessmentHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case AssessmentHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssessmentHistoryOrderFieldName.column:
		str = "name"
	case AssessmentHistoryOrderFieldAssessmentType.column:
		str = "assessment_type"
	case AssessmentHistoryOrderFieldResponseDueDuration.column:
		str = "response_due_duration"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssessmentHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssessmentHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssessmentHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *AssessmentHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *AssessmentHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *AssessmentHistoryOrderFieldUpdatedAt
	case "name":
		*f = *AssessmentHistoryOrderFieldName
	case "assessment_type":
		*f = *AssessmentHistoryOrderFieldAssessmentType
	case "response_due_duration":
		*f = *AssessmentHistoryOrderFieldResponseDueDuration
	default:
		return fmt.Errorf("%s is not a valid AssessmentHistoryOrderField", str)
	}
	return nil
}

// AssessmentHistoryOrderField defines the ordering field of AssessmentHistory.
type AssessmentHistoryOrderField struct {
	// Value extracts the ordering value from the given AssessmentHistory.
	Value    func(*AssessmentHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) assessmenthistory.OrderOption
	toCursor func(*AssessmentHistory) Cursor
}

// AssessmentHistoryOrder defines the ordering of AssessmentHistory.
type AssessmentHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *AssessmentHistoryOrderField `json:"field"`
}

// DefaultAssessmentHistoryOrder is the default ordering of AssessmentHistory.
var DefaultAssessmentHistoryOrder = &AssessmentHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssessmentHistoryOrderField{
		Value: func(_m *AssessmentHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: assessmenthistory.FieldID,
		toTerm: assessmenthistory.ByID,
		toCursor: func(_m *AssessmentHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts AssessmentHistory into AssessmentHistoryEdge.
func (_m *AssessmentHistory) ToEdge(order *AssessmentHistoryOrder) *AssessmentHistoryEdge {
	if order == nil {
		order = DefaultAssessmentHistoryOrder
	}
	return &AssessmentHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// AssessmentResponseHistoryEdge is the edge representation of AssessmentResponseHistory.
type AssessmentResponseHistoryEdge struct {
	Node   *AssessmentResponseHistory `json:"node"`
	Cursor Cursor                     `json:"cursor"`
}

// AssessmentResponseHistoryConnection is the connection containing edges to AssessmentResponseHistory.
type AssessmentResponseHistoryConnection struct {
	Edges      []*AssessmentResponseHistoryEdge `json:"edges"`
	PageInfo   PageInfo                         `json:"pageInfo"`
	TotalCount int                              `json:"totalCount"`
}

func (c *AssessmentResponseHistoryConnection) build(nodes []*AssessmentResponseHistory, pager *assessmentresponsehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *AssessmentResponseHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AssessmentResponseHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AssessmentResponseHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssessmentResponseHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssessmentResponseHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssessmentResponseHistoryPaginateOption enables pagination customization.
type AssessmentResponseHistoryPaginateOption func(*assessmentresponsehistoryPager) error

// WithAssessmentResponseHistoryOrder configures pagination ordering.
func WithAssessmentResponseHistoryOrder(order *AssessmentResponseHistoryOrder) AssessmentResponseHistoryPaginateOption {
	if order == nil {
		order = DefaultAssessmentResponseHistoryOrder
	}
	o := *order
	return func(pager *assessmentresponsehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAssessmentResponseHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAssessmentResponseHistoryFilter configures pagination filter.
func WithAssessmentResponseHistoryFilter(filter func(*AssessmentResponseHistoryQuery) (*AssessmentResponseHistoryQuery, error)) AssessmentResponseHistoryPaginateOption {
	return func(pager *assessmentresponsehistoryPager) error {
		if filter == nil {
			return errors.New("AssessmentResponseHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assessmentresponsehistoryPager struct {
	reverse bool
	order   *AssessmentResponseHistoryOrder
	filter  func(*AssessmentResponseHistoryQuery) (*AssessmentResponseHistoryQuery, error)
}

func newAssessmentResponseHistoryPager(opts []AssessmentResponseHistoryPaginateOption, reverse bool) (*assessmentresponsehistoryPager, error) {
	pager := &assessmentresponsehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAssessmentResponseHistoryOrder
	}
	return pager, nil
}

func (p *assessmentresponsehistoryPager) applyFilter(query *AssessmentResponseHistoryQuery) (*AssessmentResponseHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assessmentresponsehistoryPager) toCursor(_m *AssessmentResponseHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *assessmentresponsehistoryPager) applyCursors(query *AssessmentResponseHistoryQuery, after, before *Cursor) (*AssessmentResponseHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAssessmentResponseHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *assessmentresponsehistoryPager) applyOrder(query *AssessmentResponseHistoryQuery) *AssessmentResponseHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAssessmentResponseHistoryOrder.Field {
		query = query.Order(DefaultAssessmentResponseHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *assessmentresponsehistoryPager) orderExpr(query *AssessmentResponseHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAssessmentResponseHistoryOrder.Field {
			b.Comma().Ident(DefaultAssessmentResponseHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AssessmentResponseHistory.
func (_m *AssessmentResponseHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssessmentResponseHistoryPaginateOption,
) (*AssessmentResponseHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssessmentResponseHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &AssessmentResponseHistoryConnection{Edges: []*AssessmentResponseHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssessmentResponseHistoryOrderFieldHistoryTime orders AssessmentResponseHistory by history_time.
	AssessmentResponseHistoryOrderFieldHistoryTime = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: assessmentresponsehistory.FieldHistoryTime,
		toTerm: assessmentresponsehistory.ByHistoryTime,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldCreatedAt orders AssessmentResponseHistory by created_at.
	AssessmentResponseHistoryOrderFieldCreatedAt = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: assessmentresponsehistory.FieldCreatedAt,
		toTerm: assessmentresponsehistory.ByCreatedAt,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldUpdatedAt orders AssessmentResponseHistory by updated_at.
	AssessmentResponseHistoryOrderFieldUpdatedAt = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: assessmentresponsehistory.FieldUpdatedAt,
		toTerm: assessmentresponsehistory.ByUpdatedAt,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldEmail orders AssessmentResponseHistory by email.
	AssessmentResponseHistoryOrderFieldEmail = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.Email, nil
		},
		column: assessmentresponsehistory.FieldEmail,
		toTerm: assessmentresponsehistory.ByEmail,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldSendAttempts orders AssessmentResponseHistory by send_attempts.
	AssessmentResponseHistoryOrderFieldSendAttempts = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.SendAttempts, nil
		},
		column: assessmentresponsehistory.FieldSendAttempts,
		toTerm: assessmentresponsehistory.BySendAttempts,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SendAttempts,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldEmailDeliveredAt orders AssessmentResponseHistory by email_delivered_at.
	AssessmentResponseHistoryOrderFieldEmailDeliveredAt = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.EmailDeliveredAt, nil
		},
		column: assessmentresponsehistory.FieldEmailDeliveredAt,
		toTerm: assessmentresponsehistory.ByEmailDeliveredAt,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.EmailDeliveredAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldEmailOpenedAt orders AssessmentResponseHistory by email_opened_at.
	AssessmentResponseHistoryOrderFieldEmailOpenedAt = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.EmailOpenedAt, nil
		},
		column: assessmentresponsehistory.FieldEmailOpenedAt,
		toTerm: assessmentresponsehistory.ByEmailOpenedAt,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.EmailOpenedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldEmailClickedAt orders AssessmentResponseHistory by email_clicked_at.
	AssessmentResponseHistoryOrderFieldEmailClickedAt = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.EmailClickedAt, nil
		},
		column: assessmentresponsehistory.FieldEmailClickedAt,
		toTerm: assessmentresponsehistory.ByEmailClickedAt,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.EmailClickedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldEmailOpenCount orders AssessmentResponseHistory by email_open_count.
	AssessmentResponseHistoryOrderFieldEmailOpenCount = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.EmailOpenCount, nil
		},
		column: assessmentresponsehistory.FieldEmailOpenCount,
		toTerm: assessmentresponsehistory.ByEmailOpenCount,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.EmailOpenCount,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldEmailClickCount orders AssessmentResponseHistory by email_click_count.
	AssessmentResponseHistoryOrderFieldEmailClickCount = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.EmailClickCount, nil
		},
		column: assessmentresponsehistory.FieldEmailClickCount,
		toTerm: assessmentresponsehistory.ByEmailClickCount,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.EmailClickCount,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldLastEmailEventAt orders AssessmentResponseHistory by last_email_event_at.
	AssessmentResponseHistoryOrderFieldLastEmailEventAt = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.LastEmailEventAt, nil
		},
		column: assessmentresponsehistory.FieldLastEmailEventAt,
		toTerm: assessmentresponsehistory.ByLastEmailEventAt,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastEmailEventAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldStatus orders AssessmentResponseHistory by status.
	AssessmentResponseHistoryOrderFieldStatus = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: assessmentresponsehistory.FieldStatus,
		toTerm: assessmentresponsehistory.ByStatus,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldAssignedAt orders AssessmentResponseHistory by assigned_at.
	AssessmentResponseHistoryOrderFieldAssignedAt = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.AssignedAt, nil
		},
		column: assessmentresponsehistory.FieldAssignedAt,
		toTerm: assessmentresponsehistory.ByAssignedAt,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.AssignedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldStartedAt orders AssessmentResponseHistory by started_at.
	AssessmentResponseHistoryOrderFieldStartedAt = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.StartedAt, nil
		},
		column: assessmentresponsehistory.FieldStartedAt,
		toTerm: assessmentresponsehistory.ByStartedAt,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StartedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldCompletedAt orders AssessmentResponseHistory by completed_at.
	AssessmentResponseHistoryOrderFieldCompletedAt = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.CompletedAt, nil
		},
		column: assessmentresponsehistory.FieldCompletedAt,
		toTerm: assessmentresponsehistory.ByCompletedAt,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CompletedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldDueDate orders AssessmentResponseHistory by due_date.
	AssessmentResponseHistoryOrderFieldDueDate = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.DueDate, nil
		},
		column: assessmentresponsehistory.FieldDueDate,
		toTerm: assessmentresponsehistory.ByDueDate,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DueDate,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldIsDraft orders AssessmentResponseHistory by is_draft.
	AssessmentResponseHistoryOrderFieldIsDraft = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.IsDraft, nil
		},
		column: assessmentresponsehistory.FieldIsDraft,
		toTerm: assessmentresponsehistory.ByIsDraft,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.IsDraft,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssessmentResponseHistoryOrderField) String() string {
	var str string
	switch f.column {
	case AssessmentResponseHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case AssessmentResponseHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case AssessmentResponseHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssessmentResponseHistoryOrderFieldEmail.column:
		str = "email"
	case AssessmentResponseHistoryOrderFieldSendAttempts.column:
		str = "send_attempts"
	case AssessmentResponseHistoryOrderFieldEmailDeliveredAt.column:
		str = "email_delivered_at"
	case AssessmentResponseHistoryOrderFieldEmailOpenedAt.column:
		str = "email_opened_at"
	case AssessmentResponseHistoryOrderFieldEmailClickedAt.column:
		str = "email_clicked_at"
	case AssessmentResponseHistoryOrderFieldEmailOpenCount.column:
		str = "email_open_count"
	case AssessmentResponseHistoryOrderFieldEmailClickCount.column:
		str = "email_click_count"
	case AssessmentResponseHistoryOrderFieldLastEmailEventAt.column:
		str = "last_email_event_at"
	case AssessmentResponseHistoryOrderFieldStatus.column:
		str = "status"
	case AssessmentResponseHistoryOrderFieldAssignedAt.column:
		str = "assigned_at"
	case AssessmentResponseHistoryOrderFieldStartedAt.column:
		str = "started_at"
	case AssessmentResponseHistoryOrderFieldCompletedAt.column:
		str = "completed_at"
	case AssessmentResponseHistoryOrderFieldDueDate.column:
		str = "due_date"
	case AssessmentResponseHistoryOrderFieldIsDraft.column:
		str = "is_draft"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssessmentResponseHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssessmentResponseHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssessmentResponseHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *AssessmentResponseHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *AssessmentResponseHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *AssessmentResponseHistoryOrderFieldUpdatedAt
	case "email":
		*f = *AssessmentResponseHistoryOrderFieldEmail
	case "send_attempts":
		*f = *AssessmentResponseHistoryOrderFieldSendAttempts
	case "email_delivered_at":
		*f = *AssessmentResponseHistoryOrderFieldEmailDeliveredAt
	case "email_opened_at":
		*f = *AssessmentResponseHistoryOrderFieldEmailOpenedAt
	case "email_clicked_at":
		*f = *AssessmentResponseHistoryOrderFieldEmailClickedAt
	case "email_open_count":
		*f = *AssessmentResponseHistoryOrderFieldEmailOpenCount
	case "email_click_count":
		*f = *AssessmentResponseHistoryOrderFieldEmailClickCount
	case "last_email_event_at":
		*f = *AssessmentResponseHistoryOrderFieldLastEmailEventAt
	case "status":
		*f = *AssessmentResponseHistoryOrderFieldStatus
	case "assigned_at":
		*f = *AssessmentResponseHistoryOrderFieldAssignedAt
	case "started_at":
		*f = *AssessmentResponseHistoryOrderFieldStartedAt
	case "completed_at":
		*f = *AssessmentResponseHistoryOrderFieldCompletedAt
	case "due_date":
		*f = *AssessmentResponseHistoryOrderFieldDueDate
	case "is_draft":
		*f = *AssessmentResponseHistoryOrderFieldIsDraft
	default:
		return fmt.Errorf("%s is not a valid AssessmentResponseHistoryOrderField", str)
	}
	return nil
}

// AssessmentResponseHistoryOrderField defines the ordering field of AssessmentResponseHistory.
type AssessmentResponseHistoryOrderField struct {
	// Value extracts the ordering value from the given AssessmentResponseHistory.
	Value    func(*AssessmentResponseHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) assessmentresponsehistory.OrderOption
	toCursor func(*AssessmentResponseHistory) Cursor
}

// AssessmentResponseHistoryOrder defines the ordering of AssessmentResponseHistory.
type AssessmentResponseHistoryOrder struct {
	Direction OrderDirection                       `json:"direction"`
	Field     *AssessmentResponseHistoryOrderField `json:"field"`
}

// DefaultAssessmentResponseHistoryOrder is the default ordering of AssessmentResponseHistory.
var DefaultAssessmentResponseHistoryOrder = &AssessmentResponseHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: assessmentresponsehistory.FieldID,
		toTerm: assessmentresponsehistory.ByID,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts AssessmentResponseHistory into AssessmentResponseHistoryEdge.
func (_m *AssessmentResponseHistory) ToEdge(order *AssessmentResponseHistoryOrder) *AssessmentResponseHistoryEdge {
	if order == nil {
		order = DefaultAssessmentResponseHistoryOrder
	}
	return &AssessmentResponseHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// AssetHistoryEdge is the edge representation of AssetHistory.
type AssetHistoryEdge struct {
	Node   *AssetHistory `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// AssetHistoryConnection is the connection containing edges to AssetHistory.
type AssetHistoryConnection struct {
	Edges      []*AssetHistoryEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *AssetHistoryConnection) build(nodes []*AssetHistory, pager *assethistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *AssetHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AssetHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AssetHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssetHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssetHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssetHistoryPaginateOption enables pagination customization.
type AssetHistoryPaginateOption func(*assethistoryPager) error

// WithAssetHistoryOrder configures pagination ordering.
func WithAssetHistoryOrder(order *AssetHistoryOrder) AssetHistoryPaginateOption {
	if order == nil {
		order = DefaultAssetHistoryOrder
	}
	o := *order
	return func(pager *assethistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAssetHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAssetHistoryFilter configures pagination filter.
func WithAssetHistoryFilter(filter func(*AssetHistoryQuery) (*AssetHistoryQuery, error)) AssetHistoryPaginateOption {
	return func(pager *assethistoryPager) error {
		if filter == nil {
			return errors.New("AssetHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assethistoryPager struct {
	reverse bool
	order   *AssetHistoryOrder
	filter  func(*AssetHistoryQuery) (*AssetHistoryQuery, error)
}

func newAssetHistoryPager(opts []AssetHistoryPaginateOption, reverse bool) (*assethistoryPager, error) {
	pager := &assethistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAssetHistoryOrder
	}
	return pager, nil
}

func (p *assethistoryPager) applyFilter(query *AssetHistoryQuery) (*AssetHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assethistoryPager) toCursor(_m *AssetHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *assethistoryPager) applyCursors(query *AssetHistoryQuery, after, before *Cursor) (*AssetHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAssetHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *assethistoryPager) applyOrder(query *AssetHistoryQuery) *AssetHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAssetHistoryOrder.Field {
		query = query.Order(DefaultAssetHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *assethistoryPager) orderExpr(query *AssetHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAssetHistoryOrder.Field {
			b.Comma().Ident(DefaultAssetHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AssetHistory.
func (_m *AssetHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssetHistoryPaginateOption,
) (*AssetHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssetHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &AssetHistoryConnection{Edges: []*AssetHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssetHistoryOrderFieldHistoryTime orders AssetHistory by history_time.
	AssetHistoryOrderFieldHistoryTime = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: assethistory.FieldHistoryTime,
		toTerm: assethistory.ByHistoryTime,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// AssetHistoryOrderFieldCreatedAt orders AssetHistory by created_at.
	AssetHistoryOrderFieldCreatedAt = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: assethistory.FieldCreatedAt,
		toTerm: assethistory.ByCreatedAt,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// AssetHistoryOrderFieldUpdatedAt orders AssetHistory by updated_at.
	AssetHistoryOrderFieldUpdatedAt = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: assethistory.FieldUpdatedAt,
		toTerm: assethistory.ByUpdatedAt,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// AssetHistoryOrderFieldInternalOwner orders AssetHistory by internal_owner.
	AssetHistoryOrderFieldInternalOwner = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.InternalOwner, nil
		},
		column: assethistory.FieldInternalOwner,
		toTerm: assethistory.ByInternalOwner,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.InternalOwner,
			}
		},
	}
	// AssetHistoryOrderFieldAssetType orders AssetHistory by asset_type.
	AssetHistoryOrderFieldAssetType = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.AssetType, nil
		},
		column: assethistory.FieldAssetType,
		toTerm: assethistory.ByAssetType,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.AssetType,
			}
		},
	}
	// AssetHistoryOrderFieldName orders AssetHistory by name.
	AssetHistoryOrderFieldName = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: assethistory.FieldName,
		toTerm: assethistory.ByName,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// AssetHistoryOrderFieldDisplayName orders AssetHistory by display_name.
	AssetHistoryOrderFieldDisplayName = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: assethistory.FieldDisplayName,
		toTerm: assethistory.ByDisplayName,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
	// AssetHistoryOrderFieldPhysicalLocation orders AssetHistory by physical_location.
	AssetHistoryOrderFieldPhysicalLocation = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.PhysicalLocation, nil
		},
		column: assethistory.FieldPhysicalLocation,
		toTerm: assethistory.ByPhysicalLocation,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.PhysicalLocation,
			}
		},
	}
	// AssetHistoryOrderFieldRegion orders AssetHistory by region.
	AssetHistoryOrderFieldRegion = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.Region, nil
		},
		column: assethistory.FieldRegion,
		toTerm: assethistory.ByRegion,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Region,
			}
		},
	}
	// AssetHistoryOrderFieldContainsPii orders AssetHistory by contains_pii.
	AssetHistoryOrderFieldContainsPii = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.ContainsPii, nil
		},
		column: assethistory.FieldContainsPii,
		toTerm: assethistory.ByContainsPii,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ContainsPii,
			}
		},
	}
	// AssetHistoryOrderFieldSourceType orders AssetHistory by source_type.
	AssetHistoryOrderFieldSourceType = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.SourceType, nil
		},
		column: assethistory.FieldSourceType,
		toTerm: assethistory.BySourceType,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SourceType,
			}
		},
	}
	// AssetHistoryOrderFieldSourceIdentifier orders AssetHistory by source_identifier.
	AssetHistoryOrderFieldSourceIdentifier = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.SourceIdentifier, nil
		},
		column: assethistory.FieldSourceIdentifier,
		toTerm: assethistory.BySourceIdentifier,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SourceIdentifier,
			}
		},
	}
	// AssetHistoryOrderFieldCostCenter orders AssetHistory by cost_center.
	AssetHistoryOrderFieldCostCenter = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.CostCenter, nil
		},
		column: assethistory.FieldCostCenter,
		toTerm: assethistory.ByCostCenter,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CostCenter,
			}
		},
	}
	// AssetHistoryOrderFieldEstimatedMonthlyCost orders AssetHistory by estimated_monthly_cost.
	AssetHistoryOrderFieldEstimatedMonthlyCost = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.EstimatedMonthlyCost, nil
		},
		column: assethistory.FieldEstimatedMonthlyCost,
		toTerm: assethistory.ByEstimatedMonthlyCost,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.EstimatedMonthlyCost,
			}
		},
	}
	// AssetHistoryOrderFieldPurchaseDate orders AssetHistory by purchase_date.
	AssetHistoryOrderFieldPurchaseDate = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.PurchaseDate == nil {
				return nil, nil
			}
			return _m.PurchaseDate, nil
		},
		column: assethistory.FieldPurchaseDate,
		toTerm: func(opts ...sql.OrderTermOption) assethistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return assethistory.ByPurchaseDate(opts...)
		},
		toCursor: func(_m *AssetHistory) Cursor {
			if _m.PurchaseDate == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.PurchaseDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssetHistoryOrderField) String() string {
	var str string
	switch f.column {
	case AssetHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case AssetHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case AssetHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssetHistoryOrderFieldInternalOwner.column:
		str = "internal_owner"
	case AssetHistoryOrderFieldAssetType.column:
		str = "ASSET_TYPE"
	case AssetHistoryOrderFieldName.column:
		str = "name"
	case AssetHistoryOrderFieldDisplayName.column:
		str = "display_name"
	case AssetHistoryOrderFieldPhysicalLocation.column:
		str = "physical_location"
	case AssetHistoryOrderFieldRegion.column:
		str = "region"
	case AssetHistoryOrderFieldContainsPii.column:
		str = "contains_pii"
	case AssetHistoryOrderFieldSourceType.column:
		str = "SOURCE_TYPE"
	case AssetHistoryOrderFieldSourceIdentifier.column:
		str = "source_identifier"
	case AssetHistoryOrderFieldCostCenter.column:
		str = "cost_center"
	case AssetHistoryOrderFieldEstimatedMonthlyCost.column:
		str = "estimated_monthly_cost"
	case AssetHistoryOrderFieldPurchaseDate.column:
		str = "purchase_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssetHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssetHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssetHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *AssetHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *AssetHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *AssetHistoryOrderFieldUpdatedAt
	case "internal_owner":
		*f = *AssetHistoryOrderFieldInternalOwner
	case "ASSET_TYPE":
		*f = *AssetHistoryOrderFieldAssetType
	case "name":
		*f = *AssetHistoryOrderFieldName
	case "display_name":
		*f = *AssetHistoryOrderFieldDisplayName
	case "physical_location":
		*f = *AssetHistoryOrderFieldPhysicalLocation
	case "region":
		*f = *AssetHistoryOrderFieldRegion
	case "contains_pii":
		*f = *AssetHistoryOrderFieldContainsPii
	case "SOURCE_TYPE":
		*f = *AssetHistoryOrderFieldSourceType
	case "source_identifier":
		*f = *AssetHistoryOrderFieldSourceIdentifier
	case "cost_center":
		*f = *AssetHistoryOrderFieldCostCenter
	case "estimated_monthly_cost":
		*f = *AssetHistoryOrderFieldEstimatedMonthlyCost
	case "purchase_date":
		*f = *AssetHistoryOrderFieldPurchaseDate
	default:
		return fmt.Errorf("%s is not a valid AssetHistoryOrderField", str)
	}
	return nil
}

// AssetHistoryOrderField defines the ordering field of AssetHistory.
type AssetHistoryOrderField struct {
	// Value extracts the ordering value from the given AssetHistory.
	Value    func(*AssetHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) assethistory.OrderOption
	toCursor func(*AssetHistory) Cursor
}

// AssetHistoryOrder defines the ordering of AssetHistory.
type AssetHistoryOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *AssetHistoryOrderField `json:"field"`
}

// DefaultAssetHistoryOrder is the default ordering of AssetHistory.
var DefaultAssetHistoryOrder = &AssetHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: assethistory.FieldID,
		toTerm: assethistory.ByID,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts AssetHistory into AssetHistoryEdge.
func (_m *AssetHistory) ToEdge(order *AssetHistoryOrder) *AssetHistoryEdge {
	if order == nil {
		order = DefaultAssetHistoryOrder
	}
	return &AssetHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// CampaignHistoryEdge is the edge representation of CampaignHistory.
type CampaignHistoryEdge struct {
	Node   *CampaignHistory `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// CampaignHistoryConnection is the connection containing edges to CampaignHistory.
type CampaignHistoryConnection struct {
	Edges      []*CampaignHistoryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *CampaignHistoryConnection) build(nodes []*CampaignHistory, pager *campaignhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *CampaignHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CampaignHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CampaignHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*CampaignHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CampaignHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CampaignHistoryPaginateOption enables pagination customization.
type CampaignHistoryPaginateOption func(*campaignhistoryPager) error

// WithCampaignHistoryOrder configures pagination ordering.
func WithCampaignHistoryOrder(order *CampaignHistoryOrder) CampaignHistoryPaginateOption {
	if order == nil {
		order = DefaultCampaignHistoryOrder
	}
	o := *order
	return func(pager *campaignhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCampaignHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCampaignHistoryFilter configures pagination filter.
func WithCampaignHistoryFilter(filter func(*CampaignHistoryQuery) (*CampaignHistoryQuery, error)) CampaignHistoryPaginateOption {
	return func(pager *campaignhistoryPager) error {
		if filter == nil {
			return errors.New("CampaignHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type campaignhistoryPager struct {
	reverse bool
	order   *CampaignHistoryOrder
	filter  func(*CampaignHistoryQuery) (*CampaignHistoryQuery, error)
}

func newCampaignHistoryPager(opts []CampaignHistoryPaginateOption, reverse bool) (*campaignhistoryPager, error) {
	pager := &campaignhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCampaignHistoryOrder
	}
	return pager, nil
}

func (p *campaignhistoryPager) applyFilter(query *CampaignHistoryQuery) (*CampaignHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *campaignhistoryPager) toCursor(_m *CampaignHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *campaignhistoryPager) applyCursors(query *CampaignHistoryQuery, after, before *Cursor) (*CampaignHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCampaignHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *campaignhistoryPager) applyOrder(query *CampaignHistoryQuery) *CampaignHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCampaignHistoryOrder.Field {
		query = query.Order(DefaultCampaignHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *campaignhistoryPager) orderExpr(query *CampaignHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCampaignHistoryOrder.Field {
			b.Comma().Ident(DefaultCampaignHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CampaignHistory.
func (_m *CampaignHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CampaignHistoryPaginateOption,
) (*CampaignHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCampaignHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &CampaignHistoryConnection{Edges: []*CampaignHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CampaignHistoryOrderFieldHistoryTime orders CampaignHistory by history_time.
	CampaignHistoryOrderFieldHistoryTime = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: campaignhistory.FieldHistoryTime,
		toTerm: campaignhistory.ByHistoryTime,
		toCursor: func(_m *CampaignHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// CampaignHistoryOrderFieldCreatedAt orders CampaignHistory by created_at.
	CampaignHistoryOrderFieldCreatedAt = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: campaignhistory.FieldCreatedAt,
		toTerm: campaignhistory.ByCreatedAt,
		toCursor: func(_m *CampaignHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// CampaignHistoryOrderFieldUpdatedAt orders CampaignHistory by updated_at.
	CampaignHistoryOrderFieldUpdatedAt = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: campaignhistory.FieldUpdatedAt,
		toTerm: campaignhistory.ByUpdatedAt,
		toCursor: func(_m *CampaignHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// CampaignHistoryOrderFieldInternalOwner orders CampaignHistory by internal_owner.
	CampaignHistoryOrderFieldInternalOwner = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			return _m.InternalOwner, nil
		},
		column: campaignhistory.FieldInternalOwner,
		toTerm: campaignhistory.ByInternalOwner,
		toCursor: func(_m *CampaignHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.InternalOwner,
			}
		},
	}
	// CampaignHistoryOrderFieldName orders CampaignHistory by name.
	CampaignHistoryOrderFieldName = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: campaignhistory.FieldName,
		toTerm: campaignhistory.ByName,
		toCursor: func(_m *CampaignHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// CampaignHistoryOrderFieldCampaignType orders CampaignHistory by campaign_type.
	CampaignHistoryOrderFieldCampaignType = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			return _m.CampaignType, nil
		},
		column: campaignhistory.FieldCampaignType,
		toTerm: campaignhistory.ByCampaignType,
		toCursor: func(_m *CampaignHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CampaignType,
			}
		},
	}
	// CampaignHistoryOrderFieldStatus orders CampaignHistory by status.
	CampaignHistoryOrderFieldStatus = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: campaignhistory.FieldStatus,
		toTerm: campaignhistory.ByStatus,
		toCursor: func(_m *CampaignHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// CampaignHistoryOrderFieldIsActive orders CampaignHistory by is_active.
	CampaignHistoryOrderFieldIsActive = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			return _m.IsActive, nil
		},
		column: campaignhistory.FieldIsActive,
		toTerm: campaignhistory.ByIsActive,
		toCursor: func(_m *CampaignHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.IsActive,
			}
		},
	}
	// CampaignHistoryOrderFieldScheduledAt orders CampaignHistory by scheduled_at.
	CampaignHistoryOrderFieldScheduledAt = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ScheduledAt == nil {
				return nil, nil
			}
			return _m.ScheduledAt, nil
		},
		column: campaignhistory.FieldScheduledAt,
		toTerm: func(opts ...sql.OrderTermOption) campaignhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return campaignhistory.ByScheduledAt(opts...)
		},
		toCursor: func(_m *CampaignHistory) Cursor {
			if _m.ScheduledAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ScheduledAt,
			}
		},
	}
	// CampaignHistoryOrderFieldLaunchedAt orders CampaignHistory by launched_at.
	CampaignHistoryOrderFieldLaunchedAt = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LaunchedAt == nil {
				return nil, nil
			}
			return _m.LaunchedAt, nil
		},
		column: campaignhistory.FieldLaunchedAt,
		toTerm: func(opts ...sql.OrderTermOption) campaignhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return campaignhistory.ByLaunchedAt(opts...)
		},
		toCursor: func(_m *CampaignHistory) Cursor {
			if _m.LaunchedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LaunchedAt,
			}
		},
	}
	// CampaignHistoryOrderFieldCompletedAt orders CampaignHistory by completed_at.
	CampaignHistoryOrderFieldCompletedAt = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.CompletedAt == nil {
				return nil, nil
			}
			return _m.CompletedAt, nil
		},
		column: campaignhistory.FieldCompletedAt,
		toTerm: func(opts ...sql.OrderTermOption) campaignhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return campaignhistory.ByCompletedAt(opts...)
		},
		toCursor: func(_m *CampaignHistory) Cursor {
			if _m.CompletedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.CompletedAt,
			}
		},
	}
	// CampaignHistoryOrderFieldDueDate orders CampaignHistory by due_date.
	CampaignHistoryOrderFieldDueDate = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.DueDate == nil {
				return nil, nil
			}
			return _m.DueDate, nil
		},
		column: campaignhistory.FieldDueDate,
		toTerm: func(opts ...sql.OrderTermOption) campaignhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return campaignhistory.ByDueDate(opts...)
		},
		toCursor: func(_m *CampaignHistory) Cursor {
			if _m.DueDate == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.DueDate,
			}
		},
	}
	// CampaignHistoryOrderFieldIsRecurring orders CampaignHistory by is_recurring.
	CampaignHistoryOrderFieldIsRecurring = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			return _m.IsRecurring, nil
		},
		column: campaignhistory.FieldIsRecurring,
		toTerm: campaignhistory.ByIsRecurring,
		toCursor: func(_m *CampaignHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.IsRecurring,
			}
		},
	}
	// CampaignHistoryOrderFieldRecurrenceFrequency orders CampaignHistory by recurrence_frequency.
	CampaignHistoryOrderFieldRecurrenceFrequency = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			return _m.RecurrenceFrequency, nil
		},
		column: campaignhistory.FieldRecurrenceFrequency,
		toTerm: campaignhistory.ByRecurrenceFrequency,
		toCursor: func(_m *CampaignHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RecurrenceFrequency,
			}
		},
	}
	// CampaignHistoryOrderFieldRecurrenceInterval orders CampaignHistory by recurrence_interval.
	CampaignHistoryOrderFieldRecurrenceInterval = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			return _m.RecurrenceInterval, nil
		},
		column: campaignhistory.FieldRecurrenceInterval,
		toTerm: campaignhistory.ByRecurrenceInterval,
		toCursor: func(_m *CampaignHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RecurrenceInterval,
			}
		},
	}
	// CampaignHistoryOrderFieldRecurrenceTimezone orders CampaignHistory by recurrence_timezone.
	CampaignHistoryOrderFieldRecurrenceTimezone = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			return _m.RecurrenceTimezone, nil
		},
		column: campaignhistory.FieldRecurrenceTimezone,
		toTerm: campaignhistory.ByRecurrenceTimezone,
		toCursor: func(_m *CampaignHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RecurrenceTimezone,
			}
		},
	}
	// CampaignHistoryOrderFieldLastRunAt orders CampaignHistory by last_run_at.
	CampaignHistoryOrderFieldLastRunAt = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastRunAt == nil {
				return nil, nil
			}
			return _m.LastRunAt, nil
		},
		column: campaignhistory.FieldLastRunAt,
		toTerm: func(opts ...sql.OrderTermOption) campaignhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return campaignhistory.ByLastRunAt(opts...)
		},
		toCursor: func(_m *CampaignHistory) Cursor {
			if _m.LastRunAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastRunAt,
			}
		},
	}
	// CampaignHistoryOrderFieldNextRunAt orders CampaignHistory by next_run_at.
	CampaignHistoryOrderFieldNextRunAt = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.NextRunAt == nil {
				return nil, nil
			}
			return _m.NextRunAt, nil
		},
		column: campaignhistory.FieldNextRunAt,
		toTerm: func(opts ...sql.OrderTermOption) campaignhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return campaignhistory.ByNextRunAt(opts...)
		},
		toCursor: func(_m *CampaignHistory) Cursor {
			if _m.NextRunAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.NextRunAt,
			}
		},
	}
	// CampaignHistoryOrderFieldRecurrenceEndAt orders CampaignHistory by recurrence_end_at.
	CampaignHistoryOrderFieldRecurrenceEndAt = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.RecurrenceEndAt == nil {
				return nil, nil
			}
			return _m.RecurrenceEndAt, nil
		},
		column: campaignhistory.FieldRecurrenceEndAt,
		toTerm: func(opts ...sql.OrderTermOption) campaignhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return campaignhistory.ByRecurrenceEndAt(opts...)
		},
		toCursor: func(_m *CampaignHistory) Cursor {
			if _m.RecurrenceEndAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.RecurrenceEndAt,
			}
		},
	}
	// CampaignHistoryOrderFieldRecipientCount orders CampaignHistory by recipient_count.
	CampaignHistoryOrderFieldRecipientCount = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			return _m.RecipientCount, nil
		},
		column: campaignhistory.FieldRecipientCount,
		toTerm: campaignhistory.ByRecipientCount,
		toCursor: func(_m *CampaignHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RecipientCount,
			}
		},
	}
	// CampaignHistoryOrderFieldResendCount orders CampaignHistory by resend_count.
	CampaignHistoryOrderFieldResendCount = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			return _m.ResendCount, nil
		},
		column: campaignhistory.FieldResendCount,
		toTerm: campaignhistory.ByResendCount,
		toCursor: func(_m *CampaignHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ResendCount,
			}
		},
	}
	// CampaignHistoryOrderFieldLastResentAt orders CampaignHistory by last_resent_at.
	CampaignHistoryOrderFieldLastResentAt = &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastResentAt == nil {
				return nil, nil
			}
			return _m.LastResentAt, nil
		},
		column: campaignhistory.FieldLastResentAt,
		toTerm: func(opts ...sql.OrderTermOption) campaignhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return campaignhistory.ByLastResentAt(opts...)
		},
		toCursor: func(_m *CampaignHistory) Cursor {
			if _m.LastResentAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastResentAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CampaignHistoryOrderField) String() string {
	var str string
	switch f.column {
	case CampaignHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case CampaignHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case CampaignHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case CampaignHistoryOrderFieldInternalOwner.column:
		str = "internal_owner"
	case CampaignHistoryOrderFieldName.column:
		str = "name"
	case CampaignHistoryOrderFieldCampaignType.column:
		str = "CAMPAIGN_TYPE"
	case CampaignHistoryOrderFieldStatus.column:
		str = "STATUS"
	case CampaignHistoryOrderFieldIsActive.column:
		str = "is_active"
	case CampaignHistoryOrderFieldScheduledAt.column:
		str = "scheduled_at"
	case CampaignHistoryOrderFieldLaunchedAt.column:
		str = "launched_at"
	case CampaignHistoryOrderFieldCompletedAt.column:
		str = "completed_at"
	case CampaignHistoryOrderFieldDueDate.column:
		str = "due_date"
	case CampaignHistoryOrderFieldIsRecurring.column:
		str = "is_recurring"
	case CampaignHistoryOrderFieldRecurrenceFrequency.column:
		str = "recurrence_frequency"
	case CampaignHistoryOrderFieldRecurrenceInterval.column:
		str = "recurrence_interval"
	case CampaignHistoryOrderFieldRecurrenceTimezone.column:
		str = "recurrence_timezone"
	case CampaignHistoryOrderFieldLastRunAt.column:
		str = "last_run_at"
	case CampaignHistoryOrderFieldNextRunAt.column:
		str = "next_run_at"
	case CampaignHistoryOrderFieldRecurrenceEndAt.column:
		str = "recurrence_end_at"
	case CampaignHistoryOrderFieldRecipientCount.column:
		str = "recipient_count"
	case CampaignHistoryOrderFieldResendCount.column:
		str = "resend_count"
	case CampaignHistoryOrderFieldLastResentAt.column:
		str = "last_resent_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CampaignHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CampaignHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CampaignHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *CampaignHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *CampaignHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *CampaignHistoryOrderFieldUpdatedAt
	case "internal_owner":
		*f = *CampaignHistoryOrderFieldInternalOwner
	case "name":
		*f = *CampaignHistoryOrderFieldName
	case "CAMPAIGN_TYPE":
		*f = *CampaignHistoryOrderFieldCampaignType
	case "STATUS":
		*f = *CampaignHistoryOrderFieldStatus
	case "is_active":
		*f = *CampaignHistoryOrderFieldIsActive
	case "scheduled_at":
		*f = *CampaignHistoryOrderFieldScheduledAt
	case "launched_at":
		*f = *CampaignHistoryOrderFieldLaunchedAt
	case "completed_at":
		*f = *CampaignHistoryOrderFieldCompletedAt
	case "due_date":
		*f = *CampaignHistoryOrderFieldDueDate
	case "is_recurring":
		*f = *CampaignHistoryOrderFieldIsRecurring
	case "recurrence_frequency":
		*f = *CampaignHistoryOrderFieldRecurrenceFrequency
	case "recurrence_interval":
		*f = *CampaignHistoryOrderFieldRecurrenceInterval
	case "recurrence_timezone":
		*f = *CampaignHistoryOrderFieldRecurrenceTimezone
	case "last_run_at":
		*f = *CampaignHistoryOrderFieldLastRunAt
	case "next_run_at":
		*f = *CampaignHistoryOrderFieldNextRunAt
	case "recurrence_end_at":
		*f = *CampaignHistoryOrderFieldRecurrenceEndAt
	case "recipient_count":
		*f = *CampaignHistoryOrderFieldRecipientCount
	case "resend_count":
		*f = *CampaignHistoryOrderFieldResendCount
	case "last_resent_at":
		*f = *CampaignHistoryOrderFieldLastResentAt
	default:
		return fmt.Errorf("%s is not a valid CampaignHistoryOrderField", str)
	}
	return nil
}

// CampaignHistoryOrderField defines the ordering field of CampaignHistory.
type CampaignHistoryOrderField struct {
	// Value extracts the ordering value from the given CampaignHistory.
	Value    func(*CampaignHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) campaignhistory.OrderOption
	toCursor func(*CampaignHistory) Cursor
}

// CampaignHistoryOrder defines the ordering of CampaignHistory.
type CampaignHistoryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *CampaignHistoryOrderField `json:"field"`
}

// DefaultCampaignHistoryOrder is the default ordering of CampaignHistory.
var DefaultCampaignHistoryOrder = &CampaignHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CampaignHistoryOrderField{
		Value: func(_m *CampaignHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: campaignhistory.FieldID,
		toTerm: campaignhistory.ByID,
		toCursor: func(_m *CampaignHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts CampaignHistory into CampaignHistoryEdge.
func (_m *CampaignHistory) ToEdge(order *CampaignHistoryOrder) *CampaignHistoryEdge {
	if order == nil {
		order = DefaultCampaignHistoryOrder
	}
	return &CampaignHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// CampaignTargetHistoryEdge is the edge representation of CampaignTargetHistory.
type CampaignTargetHistoryEdge struct {
	Node   *CampaignTargetHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// CampaignTargetHistoryConnection is the connection containing edges to CampaignTargetHistory.
type CampaignTargetHistoryConnection struct {
	Edges      []*CampaignTargetHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *CampaignTargetHistoryConnection) build(nodes []*CampaignTargetHistory, pager *campaigntargethistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *CampaignTargetHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CampaignTargetHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CampaignTargetHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*CampaignTargetHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CampaignTargetHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CampaignTargetHistoryPaginateOption enables pagination customization.
type CampaignTargetHistoryPaginateOption func(*campaigntargethistoryPager) error

// WithCampaignTargetHistoryOrder configures pagination ordering.
func WithCampaignTargetHistoryOrder(order *CampaignTargetHistoryOrder) CampaignTargetHistoryPaginateOption {
	if order == nil {
		order = DefaultCampaignTargetHistoryOrder
	}
	o := *order
	return func(pager *campaigntargethistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCampaignTargetHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCampaignTargetHistoryFilter configures pagination filter.
func WithCampaignTargetHistoryFilter(filter func(*CampaignTargetHistoryQuery) (*CampaignTargetHistoryQuery, error)) CampaignTargetHistoryPaginateOption {
	return func(pager *campaigntargethistoryPager) error {
		if filter == nil {
			return errors.New("CampaignTargetHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type campaigntargethistoryPager struct {
	reverse bool
	order   *CampaignTargetHistoryOrder
	filter  func(*CampaignTargetHistoryQuery) (*CampaignTargetHistoryQuery, error)
}

func newCampaignTargetHistoryPager(opts []CampaignTargetHistoryPaginateOption, reverse bool) (*campaigntargethistoryPager, error) {
	pager := &campaigntargethistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCampaignTargetHistoryOrder
	}
	return pager, nil
}

func (p *campaigntargethistoryPager) applyFilter(query *CampaignTargetHistoryQuery) (*CampaignTargetHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *campaigntargethistoryPager) toCursor(_m *CampaignTargetHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *campaigntargethistoryPager) applyCursors(query *CampaignTargetHistoryQuery, after, before *Cursor) (*CampaignTargetHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCampaignTargetHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *campaigntargethistoryPager) applyOrder(query *CampaignTargetHistoryQuery) *CampaignTargetHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCampaignTargetHistoryOrder.Field {
		query = query.Order(DefaultCampaignTargetHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *campaigntargethistoryPager) orderExpr(query *CampaignTargetHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCampaignTargetHistoryOrder.Field {
			b.Comma().Ident(DefaultCampaignTargetHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CampaignTargetHistory.
func (_m *CampaignTargetHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CampaignTargetHistoryPaginateOption,
) (*CampaignTargetHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCampaignTargetHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &CampaignTargetHistoryConnection{Edges: []*CampaignTargetHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CampaignTargetHistoryOrderFieldHistoryTime orders CampaignTargetHistory by history_time.
	CampaignTargetHistoryOrderFieldHistoryTime = &CampaignTargetHistoryOrderField{
		Value: func(_m *CampaignTargetHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: campaigntargethistory.FieldHistoryTime,
		toTerm: campaigntargethistory.ByHistoryTime,
		toCursor: func(_m *CampaignTargetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// CampaignTargetHistoryOrderFieldCreatedAt orders CampaignTargetHistory by created_at.
	CampaignTargetHistoryOrderFieldCreatedAt = &CampaignTargetHistoryOrderField{
		Value: func(_m *CampaignTargetHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: campaigntargethistory.FieldCreatedAt,
		toTerm: campaigntargethistory.ByCreatedAt,
		toCursor: func(_m *CampaignTargetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// CampaignTargetHistoryOrderFieldUpdatedAt orders CampaignTargetHistory by updated_at.
	CampaignTargetHistoryOrderFieldUpdatedAt = &CampaignTargetHistoryOrderField{
		Value: func(_m *CampaignTargetHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: campaigntargethistory.FieldUpdatedAt,
		toTerm: campaigntargethistory.ByUpdatedAt,
		toCursor: func(_m *CampaignTargetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// CampaignTargetHistoryOrderFieldEmail orders CampaignTargetHistory by email.
	CampaignTargetHistoryOrderFieldEmail = &CampaignTargetHistoryOrderField{
		Value: func(_m *CampaignTargetHistory) (ent.Value, error) {
			return _m.Email, nil
		},
		column: campaigntargethistory.FieldEmail,
		toTerm: campaigntargethistory.ByEmail,
		toCursor: func(_m *CampaignTargetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// CampaignTargetHistoryOrderFieldFullName orders CampaignTargetHistory by full_name.
	CampaignTargetHistoryOrderFieldFullName = &CampaignTargetHistoryOrderField{
		Value: func(_m *CampaignTargetHistory) (ent.Value, error) {
			return _m.FullName, nil
		},
		column: campaigntargethistory.FieldFullName,
		toTerm: campaigntargethistory.ByFullName,
		toCursor: func(_m *CampaignTargetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FullName,
			}
		},
	}
	// CampaignTargetHistoryOrderFieldStatus orders CampaignTargetHistory by status.
	CampaignTargetHistoryOrderFieldStatus = &CampaignTargetHistoryOrderField{
		Value: func(_m *CampaignTargetHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: campaigntargethistory.FieldStatus,
		toTerm: campaigntargethistory.ByStatus,
		toCursor: func(_m *CampaignTargetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// CampaignTargetHistoryOrderFieldSentAt orders CampaignTargetHistory by sent_at.
	CampaignTargetHistoryOrderFieldSentAt = &CampaignTargetHistoryOrderField{
		Value: func(_m *CampaignTargetHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.SentAt == nil {
				return nil, nil
			}
			return _m.SentAt, nil
		},
		column: campaigntargethistory.FieldSentAt,
		toTerm: func(opts ...sql.OrderTermOption) campaigntargethistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return campaigntargethistory.BySentAt(opts...)
		},
		toCursor: func(_m *CampaignTargetHistory) Cursor {
			if _m.SentAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.SentAt,
			}
		},
	}
	// CampaignTargetHistoryOrderFieldCompletedAt orders CampaignTargetHistory by completed_at.
	CampaignTargetHistoryOrderFieldCompletedAt = &CampaignTargetHistoryOrderField{
		Value: func(_m *CampaignTargetHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.CompletedAt == nil {
				return nil, nil
			}
			return _m.CompletedAt, nil
		},
		column: campaigntargethistory.FieldCompletedAt,
		toTerm: func(opts ...sql.OrderTermOption) campaigntargethistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return campaigntargethistory.ByCompletedAt(opts...)
		},
		toCursor: func(_m *CampaignTargetHistory) Cursor {
			if _m.CompletedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.CompletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CampaignTargetHistoryOrderField) String() string {
	var str string
	switch f.column {
	case CampaignTargetHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case CampaignTargetHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case CampaignTargetHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case CampaignTargetHistoryOrderFieldEmail.column:
		str = "email"
	case CampaignTargetHistoryOrderFieldFullName.column:
		str = "full_name"
	case CampaignTargetHistoryOrderFieldStatus.column:
		str = "STATUS"
	case CampaignTargetHistoryOrderFieldSentAt.column:
		str = "sent_at"
	case CampaignTargetHistoryOrderFieldCompletedAt.column:
		str = "completed_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CampaignTargetHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CampaignTargetHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CampaignTargetHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *CampaignTargetHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *CampaignTargetHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *CampaignTargetHistoryOrderFieldUpdatedAt
	case "email":
		*f = *CampaignTargetHistoryOrderFieldEmail
	case "full_name":
		*f = *CampaignTargetHistoryOrderFieldFullName
	case "STATUS":
		*f = *CampaignTargetHistoryOrderFieldStatus
	case "sent_at":
		*f = *CampaignTargetHistoryOrderFieldSentAt
	case "completed_at":
		*f = *CampaignTargetHistoryOrderFieldCompletedAt
	default:
		return fmt.Errorf("%s is not a valid CampaignTargetHistoryOrderField", str)
	}
	return nil
}

// CampaignTargetHistoryOrderField defines the ordering field of CampaignTargetHistory.
type CampaignTargetHistoryOrderField struct {
	// Value extracts the ordering value from the given CampaignTargetHistory.
	Value    func(*CampaignTargetHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) campaigntargethistory.OrderOption
	toCursor func(*CampaignTargetHistory) Cursor
}

// CampaignTargetHistoryOrder defines the ordering of CampaignTargetHistory.
type CampaignTargetHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *CampaignTargetHistoryOrderField `json:"field"`
}

// DefaultCampaignTargetHistoryOrder is the default ordering of CampaignTargetHistory.
var DefaultCampaignTargetHistoryOrder = &CampaignTargetHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CampaignTargetHistoryOrderField{
		Value: func(_m *CampaignTargetHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: campaigntargethistory.FieldID,
		toTerm: campaigntargethistory.ByID,
		toCursor: func(_m *CampaignTargetHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts CampaignTargetHistory into CampaignTargetHistoryEdge.
func (_m *CampaignTargetHistory) ToEdge(order *CampaignTargetHistoryOrder) *CampaignTargetHistoryEdge {
	if order == nil {
		order = DefaultCampaignTargetHistoryOrder
	}
	return &CampaignTargetHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ContactHistoryEdge is the edge representation of ContactHistory.
type ContactHistoryEdge struct {
	Node   *ContactHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ContactHistoryConnection is the connection containing edges to ContactHistory.
type ContactHistoryConnection struct {
	Edges      []*ContactHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ContactHistoryConnection) build(nodes []*ContactHistory, pager *contacthistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ContactHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ContactHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ContactHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ContactHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ContactHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ContactHistoryPaginateOption enables pagination customization.
type ContactHistoryPaginateOption func(*contacthistoryPager) error

// WithContactHistoryOrder configures pagination ordering.
func WithContactHistoryOrder(order *ContactHistoryOrder) ContactHistoryPaginateOption {
	if order == nil {
		order = DefaultContactHistoryOrder
	}
	o := *order
	return func(pager *contacthistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultContactHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithContactHistoryFilter configures pagination filter.
func WithContactHistoryFilter(filter func(*ContactHistoryQuery) (*ContactHistoryQuery, error)) ContactHistoryPaginateOption {
	return func(pager *contacthistoryPager) error {
		if filter == nil {
			return errors.New("ContactHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type contacthistoryPager struct {
	reverse bool
	order   *ContactHistoryOrder
	filter  func(*ContactHistoryQuery) (*ContactHistoryQuery, error)
}

func newContactHistoryPager(opts []ContactHistoryPaginateOption, reverse bool) (*contacthistoryPager, error) {
	pager := &contacthistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultContactHistoryOrder
	}
	return pager, nil
}

func (p *contacthistoryPager) applyFilter(query *ContactHistoryQuery) (*ContactHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *contacthistoryPager) toCursor(_m *ContactHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *contacthistoryPager) applyCursors(query *ContactHistoryQuery, after, before *Cursor) (*ContactHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultContactHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *contacthistoryPager) applyOrder(query *ContactHistoryQuery) *ContactHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultContactHistoryOrder.Field {
		query = query.Order(DefaultContactHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *contacthistoryPager) orderExpr(query *ContactHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultContactHistoryOrder.Field {
			b.Comma().Ident(DefaultContactHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ContactHistory.
func (_m *ContactHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ContactHistoryPaginateOption,
) (*ContactHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newContactHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ContactHistoryConnection{Edges: []*ContactHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ContactHistoryOrderFieldHistoryTime orders ContactHistory by history_time.
	ContactHistoryOrderFieldHistoryTime = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: contacthistory.FieldHistoryTime,
		toTerm: contacthistory.ByHistoryTime,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ContactHistoryOrderFieldCreatedAt orders ContactHistory by created_at.
	ContactHistoryOrderFieldCreatedAt = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: contacthistory.FieldCreatedAt,
		toTerm: contacthistory.ByCreatedAt,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ContactHistoryOrderFieldUpdatedAt orders ContactHistory by updated_at.
	ContactHistoryOrderFieldUpdatedAt = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: contacthistory.FieldUpdatedAt,
		toTerm: contacthistory.ByUpdatedAt,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ContactHistoryOrderFieldFullName orders ContactHistory by full_name.
	ContactHistoryOrderFieldFullName = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.FullName, nil
		},
		column: contacthistory.FieldFullName,
		toTerm: contacthistory.ByFullName,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FullName,
			}
		},
	}
	// ContactHistoryOrderFieldTitle orders ContactHistory by title.
	ContactHistoryOrderFieldTitle = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: contacthistory.FieldTitle,
		toTerm: contacthistory.ByTitle,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ContactHistoryOrderFieldCompany orders ContactHistory by company.
	ContactHistoryOrderFieldCompany = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.Company, nil
		},
		column: contacthistory.FieldCompany,
		toTerm: contacthistory.ByCompany,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Company,
			}
		},
	}
	// ContactHistoryOrderFieldEmail orders ContactHistory by email.
	ContactHistoryOrderFieldEmail = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.Email, nil
		},
		column: contacthistory.FieldEmail,
		toTerm: contacthistory.ByEmail,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// ContactHistoryOrderFieldStatus orders ContactHistory by status.
	ContactHistoryOrderFieldStatus = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: contacthistory.FieldStatus,
		toTerm: contacthistory.ByStatus,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ContactHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ContactHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ContactHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ContactHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ContactHistoryOrderFieldFullName.column:
		str = "full_name"
	case ContactHistoryOrderFieldTitle.column:
		str = "title"
	case ContactHistoryOrderFieldCompany.column:
		str = "company"
	case ContactHistoryOrderFieldEmail.column:
		str = "email"
	case ContactHistoryOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ContactHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ContactHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ContactHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ContactHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ContactHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ContactHistoryOrderFieldUpdatedAt
	case "full_name":
		*f = *ContactHistoryOrderFieldFullName
	case "title":
		*f = *ContactHistoryOrderFieldTitle
	case "company":
		*f = *ContactHistoryOrderFieldCompany
	case "email":
		*f = *ContactHistoryOrderFieldEmail
	case "STATUS":
		*f = *ContactHistoryOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ContactHistoryOrderField", str)
	}
	return nil
}

// ContactHistoryOrderField defines the ordering field of ContactHistory.
type ContactHistoryOrderField struct {
	// Value extracts the ordering value from the given ContactHistory.
	Value    func(*ContactHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) contacthistory.OrderOption
	toCursor func(*ContactHistory) Cursor
}

// ContactHistoryOrder defines the ordering of ContactHistory.
type ContactHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ContactHistoryOrderField `json:"field"`
}

// DefaultContactHistoryOrder is the default ordering of ContactHistory.
var DefaultContactHistoryOrder = &ContactHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: contacthistory.FieldID,
		toTerm: contacthistory.ByID,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ContactHistory into ContactHistoryEdge.
func (_m *ContactHistory) ToEdge(order *ContactHistoryOrder) *ContactHistoryEdge {
	if order == nil {
		order = DefaultContactHistoryOrder
	}
	return &ContactHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ControlHistoryEdge is the edge representation of ControlHistory.
type ControlHistoryEdge struct {
	Node   *ControlHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ControlHistoryConnection is the connection containing edges to ControlHistory.
type ControlHistoryConnection struct {
	Edges      []*ControlHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ControlHistoryConnection) build(nodes []*ControlHistory, pager *controlhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlHistoryPaginateOption enables pagination customization.
type ControlHistoryPaginateOption func(*controlhistoryPager) error

// WithControlHistoryOrder configures pagination ordering.
func WithControlHistoryOrder(order *ControlHistoryOrder) ControlHistoryPaginateOption {
	if order == nil {
		order = DefaultControlHistoryOrder
	}
	o := *order
	return func(pager *controlhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultControlHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithControlHistoryFilter configures pagination filter.
func WithControlHistoryFilter(filter func(*ControlHistoryQuery) (*ControlHistoryQuery, error)) ControlHistoryPaginateOption {
	return func(pager *controlhistoryPager) error {
		if filter == nil {
			return errors.New("ControlHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlhistoryPager struct {
	reverse bool
	order   *ControlHistoryOrder
	filter  func(*ControlHistoryQuery) (*ControlHistoryQuery, error)
}

func newControlHistoryPager(opts []ControlHistoryPaginateOption, reverse bool) (*controlhistoryPager, error) {
	pager := &controlhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultControlHistoryOrder
	}
	return pager, nil
}

func (p *controlhistoryPager) applyFilter(query *ControlHistoryQuery) (*ControlHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlhistoryPager) toCursor(_m *ControlHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *controlhistoryPager) applyCursors(query *ControlHistoryQuery, after, before *Cursor) (*ControlHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultControlHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *controlhistoryPager) applyOrder(query *ControlHistoryQuery) *ControlHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultControlHistoryOrder.Field {
		query = query.Order(DefaultControlHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *controlhistoryPager) orderExpr(query *ControlHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultControlHistoryOrder.Field {
			b.Comma().Ident(DefaultControlHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlHistory.
func (_m *ControlHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlHistoryPaginateOption,
) (*ControlHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ControlHistoryConnection{Edges: []*ControlHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlHistoryOrderFieldHistoryTime orders ControlHistory by history_time.
	ControlHistoryOrderFieldHistoryTime = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: controlhistory.FieldHistoryTime,
		toTerm: controlhistory.ByHistoryTime,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ControlHistoryOrderFieldCreatedAt orders ControlHistory by created_at.
	ControlHistoryOrderFieldCreatedAt = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: controlhistory.FieldCreatedAt,
		toTerm: controlhistory.ByCreatedAt,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ControlHistoryOrderFieldUpdatedAt orders ControlHistory by updated_at.
	ControlHistoryOrderFieldUpdatedAt = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: controlhistory.FieldUpdatedAt,
		toTerm: controlhistory.ByUpdatedAt,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ControlHistoryOrderFieldTitle orders ControlHistory by title.
	ControlHistoryOrderFieldTitle = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: controlhistory.FieldTitle,
		toTerm: controlhistory.ByTitle,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ControlHistoryOrderFieldStatus orders ControlHistory by status.
	ControlHistoryOrderFieldStatus = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: controlhistory.FieldStatus,
		toTerm: controlhistory.ByStatus,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ControlHistoryOrderFieldSource orders ControlHistory by source.
	ControlHistoryOrderFieldSource = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.Source, nil
		},
		column: controlhistory.FieldSource,
		toTerm: controlhistory.BySource,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
	// ControlHistoryOrderFieldReferenceFramework orders ControlHistory by reference_framework.
	ControlHistoryOrderFieldReferenceFramework = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ReferenceFramework == nil {
				return nil, nil
			}
			return _m.ReferenceFramework, nil
		},
		column: controlhistory.FieldReferenceFramework,
		toTerm: func(opts ...sql.OrderTermOption) controlhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return controlhistory.ByReferenceFramework(opts...)
		},
		toCursor: func(_m *ControlHistory) Cursor {
			if _m.ReferenceFramework == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReferenceFramework,
			}
		},
	}
	// ControlHistoryOrderFieldCategory orders ControlHistory by category.
	ControlHistoryOrderFieldCategory = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.Category, nil
		},
		column: controlhistory.FieldCategory,
		toTerm: controlhistory.ByCategory,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// ControlHistoryOrderFieldSubcategory orders ControlHistory by subcategory.
	ControlHistoryOrderFieldSubcategory = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.Subcategory, nil
		},
		column: controlhistory.FieldSubcategory,
		toTerm: controlhistory.BySubcategory,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Subcategory,
			}
		},
	}
	// ControlHistoryOrderFieldRefCode orders ControlHistory by ref_code.
	ControlHistoryOrderFieldRefCode = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.RefCode, nil
		},
		column: controlhistory.FieldRefCode,
		toTerm: controlhistory.ByRefCode,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RefCode,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ControlHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ControlHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlHistoryOrderFieldTitle.column:
		str = "title"
	case ControlHistoryOrderFieldStatus.column:
		str = "STATUS"
	case ControlHistoryOrderFieldSource.column:
		str = "SOURCE"
	case ControlHistoryOrderFieldReferenceFramework.column:
		str = "REFERENCE_FRAMEWORK"
	case ControlHistoryOrderFieldCategory.column:
		str = "category"
	case ControlHistoryOrderFieldSubcategory.column:
		str = "subcategory"
	case ControlHistoryOrderFieldRefCode.column:
		str = "ref_code"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ControlHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ControlHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlHistoryOrderFieldUpdatedAt
	case "title":
		*f = *ControlHistoryOrderFieldTitle
	case "STATUS":
		*f = *ControlHistoryOrderFieldStatus
	case "SOURCE":
		*f = *ControlHistoryOrderFieldSource
	case "REFERENCE_FRAMEWORK":
		*f = *ControlHistoryOrderFieldReferenceFramework
	case "category":
		*f = *ControlHistoryOrderFieldCategory
	case "subcategory":
		*f = *ControlHistoryOrderFieldSubcategory
	case "ref_code":
		*f = *ControlHistoryOrderFieldRefCode
	default:
		return fmt.Errorf("%s is not a valid ControlHistoryOrderField", str)
	}
	return nil
}

// ControlHistoryOrderField defines the ordering field of ControlHistory.
type ControlHistoryOrderField struct {
	// Value extracts the ordering value from the given ControlHistory.
	Value    func(*ControlHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlhistory.OrderOption
	toCursor func(*ControlHistory) Cursor
}

// ControlHistoryOrder defines the ordering of ControlHistory.
type ControlHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ControlHistoryOrderField `json:"field"`
}

// DefaultControlHistoryOrder is the default ordering of ControlHistory.
var DefaultControlHistoryOrder = &ControlHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: controlhistory.FieldID,
		toTerm: controlhistory.ByID,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ControlHistory into ControlHistoryEdge.
func (_m *ControlHistory) ToEdge(order *ControlHistoryOrder) *ControlHistoryEdge {
	if order == nil {
		order = DefaultControlHistoryOrder
	}
	return &ControlHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ControlImplementationHistoryEdge is the edge representation of ControlImplementationHistory.
type ControlImplementationHistoryEdge struct {
	Node   *ControlImplementationHistory `json:"node"`
	Cursor Cursor                        `json:"cursor"`
}

// ControlImplementationHistoryConnection is the connection containing edges to ControlImplementationHistory.
type ControlImplementationHistoryConnection struct {
	Edges      []*ControlImplementationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                            `json:"pageInfo"`
	TotalCount int                                 `json:"totalCount"`
}

func (c *ControlImplementationHistoryConnection) build(nodes []*ControlImplementationHistory, pager *controlimplementationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlImplementationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlImplementationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlImplementationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlImplementationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlImplementationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlImplementationHistoryPaginateOption enables pagination customization.
type ControlImplementationHistoryPaginateOption func(*controlimplementationhistoryPager) error

// WithControlImplementationHistoryOrder configures pagination ordering.
func WithControlImplementationHistoryOrder(order *ControlImplementationHistoryOrder) ControlImplementationHistoryPaginateOption {
	if order == nil {
		order = DefaultControlImplementationHistoryOrder
	}
	o := *order
	return func(pager *controlimplementationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultControlImplementationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithControlImplementationHistoryFilter configures pagination filter.
func WithControlImplementationHistoryFilter(filter func(*ControlImplementationHistoryQuery) (*ControlImplementationHistoryQuery, error)) ControlImplementationHistoryPaginateOption {
	return func(pager *controlimplementationhistoryPager) error {
		if filter == nil {
			return errors.New("ControlImplementationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlimplementationhistoryPager struct {
	reverse bool
	order   *ControlImplementationHistoryOrder
	filter  func(*ControlImplementationHistoryQuery) (*ControlImplementationHistoryQuery, error)
}

func newControlImplementationHistoryPager(opts []ControlImplementationHistoryPaginateOption, reverse bool) (*controlimplementationhistoryPager, error) {
	pager := &controlimplementationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultControlImplementationHistoryOrder
	}
	return pager, nil
}

func (p *controlimplementationhistoryPager) applyFilter(query *ControlImplementationHistoryQuery) (*ControlImplementationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlimplementationhistoryPager) toCursor(_m *ControlImplementationHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *controlimplementationhistoryPager) applyCursors(query *ControlImplementationHistoryQuery, after, before *Cursor) (*ControlImplementationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultControlImplementationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *controlimplementationhistoryPager) applyOrder(query *ControlImplementationHistoryQuery) *ControlImplementationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultControlImplementationHistoryOrder.Field {
		query = query.Order(DefaultControlImplementationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *controlimplementationhistoryPager) orderExpr(query *ControlImplementationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultControlImplementationHistoryOrder.Field {
			b.Comma().Ident(DefaultControlImplementationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlImplementationHistory.
func (_m *ControlImplementationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlImplementationHistoryPaginateOption,
) (*ControlImplementationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlImplementationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ControlImplementationHistoryConnection{Edges: []*ControlImplementationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlImplementationHistoryOrderFieldHistoryTime orders ControlImplementationHistory by history_time.
	ControlImplementationHistoryOrderFieldHistoryTime = &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: controlimplementationhistory.FieldHistoryTime,
		toTerm: controlimplementationhistory.ByHistoryTime,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldCreatedAt orders ControlImplementationHistory by created_at.
	ControlImplementationHistoryOrderFieldCreatedAt = &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: controlimplementationhistory.FieldCreatedAt,
		toTerm: controlimplementationhistory.ByCreatedAt,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldUpdatedAt orders ControlImplementationHistory by updated_at.
	ControlImplementationHistoryOrderFieldUpdatedAt = &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: controlimplementationhistory.FieldUpdatedAt,
		toTerm: controlimplementationhistory.ByUpdatedAt,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldStatus orders ControlImplementationHistory by status.
	ControlImplementationHistoryOrderFieldStatus = &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: controlimplementationhistory.FieldStatus,
		toTerm: controlimplementationhistory.ByStatus,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldImplementationDate orders ControlImplementationHistory by implementation_date.
	ControlImplementationHistoryOrderFieldImplementationDate = &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.ImplementationDate, nil
		},
		column: controlimplementationhistory.FieldImplementationDate,
		toTerm: controlimplementationhistory.ByImplementationDate,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ImplementationDate,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldVerified orders ControlImplementationHistory by verified.
	ControlImplementationHistoryOrderFieldVerified = &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.Verified, nil
		},
		column: controlimplementationhistory.FieldVerified,
		toTerm: controlimplementationhistory.ByVerified,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Verified,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldVerificationDate orders ControlImplementationHistory by verification_date.
	ControlImplementationHistoryOrderFieldVerificationDate = &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.VerificationDate, nil
		},
		column: controlimplementationhistory.FieldVerificationDate,
		toTerm: controlimplementationhistory.ByVerificationDate,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.VerificationDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlImplementationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ControlImplementationHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ControlImplementationHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlImplementationHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlImplementationHistoryOrderFieldStatus.column:
		str = "STATUS"
	case ControlImplementationHistoryOrderFieldImplementationDate.column:
		str = "implementation_date"
	case ControlImplementationHistoryOrderFieldVerified.column:
		str = "verified"
	case ControlImplementationHistoryOrderFieldVerificationDate.column:
		str = "verification_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlImplementationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlImplementationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlImplementationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ControlImplementationHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ControlImplementationHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlImplementationHistoryOrderFieldUpdatedAt
	case "STATUS":
		*f = *ControlImplementationHistoryOrderFieldStatus
	case "implementation_date":
		*f = *ControlImplementationHistoryOrderFieldImplementationDate
	case "verified":
		*f = *ControlImplementationHistoryOrderFieldVerified
	case "verification_date":
		*f = *ControlImplementationHistoryOrderFieldVerificationDate
	default:
		return fmt.Errorf("%s is not a valid ControlImplementationHistoryOrderField", str)
	}
	return nil
}

// ControlImplementationHistoryOrderField defines the ordering field of ControlImplementationHistory.
type ControlImplementationHistoryOrderField struct {
	// Value extracts the ordering value from the given ControlImplementationHistory.
	Value    func(*ControlImplementationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlimplementationhistory.OrderOption
	toCursor func(*ControlImplementationHistory) Cursor
}

// ControlImplementationHistoryOrder defines the ordering of ControlImplementationHistory.
type ControlImplementationHistoryOrder struct {
	Direction OrderDirection                          `json:"direction"`
	Field     *ControlImplementationHistoryOrderField `json:"field"`
}

// DefaultControlImplementationHistoryOrder is the default ordering of ControlImplementationHistory.
var DefaultControlImplementationHistoryOrder = &ControlImplementationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: controlimplementationhistory.FieldID,
		toTerm: controlimplementationhistory.ByID,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ControlImplementationHistory into ControlImplementationHistoryEdge.
func (_m *ControlImplementationHistory) ToEdge(order *ControlImplementationHistoryOrder) *ControlImplementationHistoryEdge {
	if order == nil {
		order = DefaultControlImplementationHistoryOrder
	}
	return &ControlImplementationHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ControlObjectiveHistoryEdge is the edge representation of ControlObjectiveHistory.
type ControlObjectiveHistoryEdge struct {
	Node   *ControlObjectiveHistory `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// ControlObjectiveHistoryConnection is the connection containing edges to ControlObjectiveHistory.
type ControlObjectiveHistoryConnection struct {
	Edges      []*ControlObjectiveHistoryEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *ControlObjectiveHistoryConnection) build(nodes []*ControlObjectiveHistory, pager *controlobjectivehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlObjectiveHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlObjectiveHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlObjectiveHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlObjectiveHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlObjectiveHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlObjectiveHistoryPaginateOption enables pagination customization.
type ControlObjectiveHistoryPaginateOption func(*controlobjectivehistoryPager) error

// WithControlObjectiveHistoryOrder configures pagination ordering.
func WithControlObjectiveHistoryOrder(order *ControlObjectiveHistoryOrder) ControlObjectiveHistoryPaginateOption {
	if order == nil {
		order = DefaultControlObjectiveHistoryOrder
	}
	o := *order
	return func(pager *controlobjectivehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultControlObjectiveHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithControlObjectiveHistoryFilter configures pagination filter.
func WithControlObjectiveHistoryFilter(filter func(*ControlObjectiveHistoryQuery) (*ControlObjectiveHistoryQuery, error)) ControlObjectiveHistoryPaginateOption {
	return func(pager *controlobjectivehistoryPager) error {
		if filter == nil {
			return errors.New("ControlObjectiveHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlobjectivehistoryPager struct {
	reverse bool
	order   *ControlObjectiveHistoryOrder
	filter  func(*ControlObjectiveHistoryQuery) (*ControlObjectiveHistoryQuery, error)
}

func newControlObjectiveHistoryPager(opts []ControlObjectiveHistoryPaginateOption, reverse bool) (*controlobjectivehistoryPager, error) {
	pager := &controlobjectivehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultControlObjectiveHistoryOrder
	}
	return pager, nil
}

func (p *controlobjectivehistoryPager) applyFilter(query *ControlObjectiveHistoryQuery) (*ControlObjectiveHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlobjectivehistoryPager) toCursor(_m *ControlObjectiveHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *controlobjectivehistoryPager) applyCursors(query *ControlObjectiveHistoryQuery, after, before *Cursor) (*ControlObjectiveHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultControlObjectiveHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *controlobjectivehistoryPager) applyOrder(query *ControlObjectiveHistoryQuery) *ControlObjectiveHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultControlObjectiveHistoryOrder.Field {
		query = query.Order(DefaultControlObjectiveHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *controlobjectivehistoryPager) orderExpr(query *ControlObjectiveHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultControlObjectiveHistoryOrder.Field {
			b.Comma().Ident(DefaultControlObjectiveHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlObjectiveHistory.
func (_m *ControlObjectiveHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlObjectiveHistoryPaginateOption,
) (*ControlObjectiveHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlObjectiveHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ControlObjectiveHistoryConnection{Edges: []*ControlObjectiveHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlObjectiveHistoryOrderFieldHistoryTime orders ControlObjectiveHistory by history_time.
	ControlObjectiveHistoryOrderFieldHistoryTime = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: controlobjectivehistory.FieldHistoryTime,
		toTerm: controlobjectivehistory.ByHistoryTime,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldCreatedAt orders ControlObjectiveHistory by created_at.
	ControlObjectiveHistoryOrderFieldCreatedAt = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: controlobjectivehistory.FieldCreatedAt,
		toTerm: controlobjectivehistory.ByCreatedAt,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldUpdatedAt orders ControlObjectiveHistory by updated_at.
	ControlObjectiveHistoryOrderFieldUpdatedAt = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: controlobjectivehistory.FieldUpdatedAt,
		toTerm: controlobjectivehistory.ByUpdatedAt,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldRevision orders ControlObjectiveHistory by revision.
	ControlObjectiveHistoryOrderFieldRevision = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: controlobjectivehistory.FieldRevision,
		toTerm: controlobjectivehistory.ByRevision,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldName orders ControlObjectiveHistory by name.
	ControlObjectiveHistoryOrderFieldName = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: controlobjectivehistory.FieldName,
		toTerm: controlobjectivehistory.ByName,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldStatus orders ControlObjectiveHistory by status.
	ControlObjectiveHistoryOrderFieldStatus = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: controlobjectivehistory.FieldStatus,
		toTerm: controlobjectivehistory.ByStatus,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldSource orders ControlObjectiveHistory by source.
	ControlObjectiveHistoryOrderFieldSource = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.Source, nil
		},
		column: controlobjectivehistory.FieldSource,
		toTerm: controlobjectivehistory.BySource,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldControlObjectiveType orders ControlObjectiveHistory by control_objective_type.
	ControlObjectiveHistoryOrderFieldControlObjectiveType = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.ControlObjectiveType, nil
		},
		column: controlobjectivehistory.FieldControlObjectiveType,
		toTerm: controlobjectivehistory.ByControlObjectiveType,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ControlObjectiveType,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldCategory orders ControlObjectiveHistory by category.
	ControlObjectiveHistoryOrderFieldCategory = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.Category, nil
		},
		column: controlobjectivehistory.FieldCategory,
		toTerm: controlobjectivehistory.ByCategory,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldSubcategory orders ControlObjectiveHistory by subcategory.
	ControlObjectiveHistoryOrderFieldSubcategory = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.Subcategory, nil
		},
		column: controlobjectivehistory.FieldSubcategory,
		toTerm: controlobjectivehistory.BySubcategory,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Subcategory,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlObjectiveHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ControlObjectiveHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ControlObjectiveHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlObjectiveHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlObjectiveHistoryOrderFieldRevision.column:
		str = "revision"
	case ControlObjectiveHistoryOrderFieldName.column:
		str = "name"
	case ControlObjectiveHistoryOrderFieldStatus.column:
		str = "status"
	case ControlObjectiveHistoryOrderFieldSource.column:
		str = "SOURCE"
	case ControlObjectiveHistoryOrderFieldControlObjectiveType.column:
		str = "control_objective_type"
	case ControlObjectiveHistoryOrderFieldCategory.column:
		str = "category"
	case ControlObjectiveHistoryOrderFieldSubcategory.column:
		str = "subcategory"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlObjectiveHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlObjectiveHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlObjectiveHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ControlObjectiveHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ControlObjectiveHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlObjectiveHistoryOrderFieldUpdatedAt
	case "revision":
		*f = *ControlObjectiveHistoryOrderFieldRevision
	case "name":
		*f = *ControlObjectiveHistoryOrderFieldName
	case "status":
		*f = *ControlObjectiveHistoryOrderFieldStatus
	case "SOURCE":
		*f = *ControlObjectiveHistoryOrderFieldSource
	case "control_objective_type":
		*f = *ControlObjectiveHistoryOrderFieldControlObjectiveType
	case "category":
		*f = *ControlObjectiveHistoryOrderFieldCategory
	case "subcategory":
		*f = *ControlObjectiveHistoryOrderFieldSubcategory
	default:
		return fmt.Errorf("%s is not a valid ControlObjectiveHistoryOrderField", str)
	}
	return nil
}

// ControlObjectiveHistoryOrderField defines the ordering field of ControlObjectiveHistory.
type ControlObjectiveHistoryOrderField struct {
	// Value extracts the ordering value from the given ControlObjectiveHistory.
	Value    func(*ControlObjectiveHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlobjectivehistory.OrderOption
	toCursor func(*ControlObjectiveHistory) Cursor
}

// ControlObjectiveHistoryOrder defines the ordering of ControlObjectiveHistory.
type ControlObjectiveHistoryOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *ControlObjectiveHistoryOrderField `json:"field"`
}

// DefaultControlObjectiveHistoryOrder is the default ordering of ControlObjectiveHistory.
var DefaultControlObjectiveHistoryOrder = &ControlObjectiveHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: controlobjectivehistory.FieldID,
		toTerm: controlobjectivehistory.ByID,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ControlObjectiveHistory into ControlObjectiveHistoryEdge.
func (_m *ControlObjectiveHistory) ToEdge(order *ControlObjectiveHistoryOrder) *ControlObjectiveHistoryEdge {
	if order == nil {
		order = DefaultControlObjectiveHistoryOrder
	}
	return &ControlObjectiveHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// CustomDomainHistoryEdge is the edge representation of CustomDomainHistory.
type CustomDomainHistoryEdge struct {
	Node   *CustomDomainHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// CustomDomainHistoryConnection is the connection containing edges to CustomDomainHistory.
type CustomDomainHistoryConnection struct {
	Edges      []*CustomDomainHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *CustomDomainHistoryConnection) build(nodes []*CustomDomainHistory, pager *customdomainhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *CustomDomainHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CustomDomainHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CustomDomainHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*CustomDomainHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CustomDomainHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CustomDomainHistoryPaginateOption enables pagination customization.
type CustomDomainHistoryPaginateOption func(*customdomainhistoryPager) error

// WithCustomDomainHistoryOrder configures pagination ordering.
func WithCustomDomainHistoryOrder(order *CustomDomainHistoryOrder) CustomDomainHistoryPaginateOption {
	if order == nil {
		order = DefaultCustomDomainHistoryOrder
	}
	o := *order
	return func(pager *customdomainhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCustomDomainHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCustomDomainHistoryFilter configures pagination filter.
func WithCustomDomainHistoryFilter(filter func(*CustomDomainHistoryQuery) (*CustomDomainHistoryQuery, error)) CustomDomainHistoryPaginateOption {
	return func(pager *customdomainhistoryPager) error {
		if filter == nil {
			return errors.New("CustomDomainHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type customdomainhistoryPager struct {
	reverse bool
	order   *CustomDomainHistoryOrder
	filter  func(*CustomDomainHistoryQuery) (*CustomDomainHistoryQuery, error)
}

func newCustomDomainHistoryPager(opts []CustomDomainHistoryPaginateOption, reverse bool) (*customdomainhistoryPager, error) {
	pager := &customdomainhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCustomDomainHistoryOrder
	}
	return pager, nil
}

func (p *customdomainhistoryPager) applyFilter(query *CustomDomainHistoryQuery) (*CustomDomainHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *customdomainhistoryPager) toCursor(_m *CustomDomainHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *customdomainhistoryPager) applyCursors(query *CustomDomainHistoryQuery, after, before *Cursor) (*CustomDomainHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCustomDomainHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *customdomainhistoryPager) applyOrder(query *CustomDomainHistoryQuery) *CustomDomainHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCustomDomainHistoryOrder.Field {
		query = query.Order(DefaultCustomDomainHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *customdomainhistoryPager) orderExpr(query *CustomDomainHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCustomDomainHistoryOrder.Field {
			b.Comma().Ident(DefaultCustomDomainHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CustomDomainHistory.
func (_m *CustomDomainHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CustomDomainHistoryPaginateOption,
) (*CustomDomainHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCustomDomainHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &CustomDomainHistoryConnection{Edges: []*CustomDomainHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CustomDomainHistoryOrderFieldHistoryTime orders CustomDomainHistory by history_time.
	CustomDomainHistoryOrderFieldHistoryTime = &CustomDomainHistoryOrderField{
		Value: func(_m *CustomDomainHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: customdomainhistory.FieldHistoryTime,
		toTerm: customdomainhistory.ByHistoryTime,
		toCursor: func(_m *CustomDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// CustomDomainHistoryOrderFieldCreatedAt orders CustomDomainHistory by created_at.
	CustomDomainHistoryOrderFieldCreatedAt = &CustomDomainHistoryOrderField{
		Value: func(_m *CustomDomainHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: customdomainhistory.FieldCreatedAt,
		toTerm: customdomainhistory.ByCreatedAt,
		toCursor: func(_m *CustomDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// CustomDomainHistoryOrderFieldUpdatedAt orders CustomDomainHistory by updated_at.
	CustomDomainHistoryOrderFieldUpdatedAt = &CustomDomainHistoryOrderField{
		Value: func(_m *CustomDomainHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: customdomainhistory.FieldUpdatedAt,
		toTerm: customdomainhistory.ByUpdatedAt,
		toCursor: func(_m *CustomDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// CustomDomainHistoryOrderFieldCnameRecord orders CustomDomainHistory by cname_record.
	CustomDomainHistoryOrderFieldCnameRecord = &CustomDomainHistoryOrderField{
		Value: func(_m *CustomDomainHistory) (ent.Value, error) {
			return _m.CnameRecord, nil
		},
		column: customdomainhistory.FieldCnameRecord,
		toTerm: customdomainhistory.ByCnameRecord,
		toCursor: func(_m *CustomDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CnameRecord,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CustomDomainHistoryOrderField) String() string {
	var str string
	switch f.column {
	case CustomDomainHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case CustomDomainHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case CustomDomainHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case CustomDomainHistoryOrderFieldCnameRecord.column:
		str = "cname_record"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CustomDomainHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CustomDomainHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CustomDomainHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *CustomDomainHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *CustomDomainHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *CustomDomainHistoryOrderFieldUpdatedAt
	case "cname_record":
		*f = *CustomDomainHistoryOrderFieldCnameRecord
	default:
		return fmt.Errorf("%s is not a valid CustomDomainHistoryOrderField", str)
	}
	return nil
}

// CustomDomainHistoryOrderField defines the ordering field of CustomDomainHistory.
type CustomDomainHistoryOrderField struct {
	// Value extracts the ordering value from the given CustomDomainHistory.
	Value    func(*CustomDomainHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) customdomainhistory.OrderOption
	toCursor func(*CustomDomainHistory) Cursor
}

// CustomDomainHistoryOrder defines the ordering of CustomDomainHistory.
type CustomDomainHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *CustomDomainHistoryOrderField `json:"field"`
}

// DefaultCustomDomainHistoryOrder is the default ordering of CustomDomainHistory.
var DefaultCustomDomainHistoryOrder = &CustomDomainHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CustomDomainHistoryOrderField{
		Value: func(_m *CustomDomainHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: customdomainhistory.FieldID,
		toTerm: customdomainhistory.ByID,
		toCursor: func(_m *CustomDomainHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts CustomDomainHistory into CustomDomainHistoryEdge.
func (_m *CustomDomainHistory) ToEdge(order *CustomDomainHistoryOrder) *CustomDomainHistoryEdge {
	if order == nil {
		order = DefaultCustomDomainHistoryOrder
	}
	return &CustomDomainHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DNSVerificationHistoryEdge is the edge representation of DNSVerificationHistory.
type DNSVerificationHistoryEdge struct {
	Node   *DNSVerificationHistory `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// DNSVerificationHistoryConnection is the connection containing edges to DNSVerificationHistory.
type DNSVerificationHistoryConnection struct {
	Edges      []*DNSVerificationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *DNSVerificationHistoryConnection) build(nodes []*DNSVerificationHistory, pager *dnsverificationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DNSVerificationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DNSVerificationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DNSVerificationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*DNSVerificationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DNSVerificationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DNSVerificationHistoryPaginateOption enables pagination customization.
type DNSVerificationHistoryPaginateOption func(*dnsverificationhistoryPager) error

// WithDNSVerificationHistoryOrder configures pagination ordering.
func WithDNSVerificationHistoryOrder(order *DNSVerificationHistoryOrder) DNSVerificationHistoryPaginateOption {
	if order == nil {
		order = DefaultDNSVerificationHistoryOrder
	}
	o := *order
	return func(pager *dnsverificationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDNSVerificationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDNSVerificationHistoryFilter configures pagination filter.
func WithDNSVerificationHistoryFilter(filter func(*DNSVerificationHistoryQuery) (*DNSVerificationHistoryQuery, error)) DNSVerificationHistoryPaginateOption {
	return func(pager *dnsverificationhistoryPager) error {
		if filter == nil {
			return errors.New("DNSVerificationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dnsverificationhistoryPager struct {
	reverse bool
	order   *DNSVerificationHistoryOrder
	filter  func(*DNSVerificationHistoryQuery) (*DNSVerificationHistoryQuery, error)
}

func newDNSVerificationHistoryPager(opts []DNSVerificationHistoryPaginateOption, reverse bool) (*dnsverificationhistoryPager, error) {
	pager := &dnsverificationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDNSVerificationHistoryOrder
	}
	return pager, nil
}

func (p *dnsverificationhistoryPager) applyFilter(query *DNSVerificationHistoryQuery) (*DNSVerificationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dnsverificationhistoryPager) toCursor(_m *DNSVerificationHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *dnsverificationhistoryPager) applyCursors(query *DNSVerificationHistoryQuery, after, before *Cursor) (*DNSVerificationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDNSVerificationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *dnsverificationhistoryPager) applyOrder(query *DNSVerificationHistoryQuery) *DNSVerificationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDNSVerificationHistoryOrder.Field {
		query = query.Order(DefaultDNSVerificationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *dnsverificationhistoryPager) orderExpr(query *DNSVerificationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDNSVerificationHistoryOrder.Field {
			b.Comma().Ident(DefaultDNSVerificationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DNSVerificationHistory.
func (_m *DNSVerificationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DNSVerificationHistoryPaginateOption,
) (*DNSVerificationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDNSVerificationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DNSVerificationHistoryConnection{Edges: []*DNSVerificationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DNSVerificationHistoryOrderFieldHistoryTime orders DNSVerificationHistory by history_time.
	DNSVerificationHistoryOrderFieldHistoryTime = &DNSVerificationHistoryOrderField{
		Value: func(_m *DNSVerificationHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: dnsverificationhistory.FieldHistoryTime,
		toTerm: dnsverificationhistory.ByHistoryTime,
		toCursor: func(_m *DNSVerificationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// DNSVerificationHistoryOrderFieldCreatedAt orders DNSVerificationHistory by created_at.
	DNSVerificationHistoryOrderFieldCreatedAt = &DNSVerificationHistoryOrderField{
		Value: func(_m *DNSVerificationHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: dnsverificationhistory.FieldCreatedAt,
		toTerm: dnsverificationhistory.ByCreatedAt,
		toCursor: func(_m *DNSVerificationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DNSVerificationHistoryOrderFieldUpdatedAt orders DNSVerificationHistory by updated_at.
	DNSVerificationHistoryOrderFieldUpdatedAt = &DNSVerificationHistoryOrderField{
		Value: func(_m *DNSVerificationHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: dnsverificationhistory.FieldUpdatedAt,
		toTerm: dnsverificationhistory.ByUpdatedAt,
		toCursor: func(_m *DNSVerificationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DNSVerificationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case DNSVerificationHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case DNSVerificationHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case DNSVerificationHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DNSVerificationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DNSVerificationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DNSVerificationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *DNSVerificationHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *DNSVerificationHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *DNSVerificationHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DNSVerificationHistoryOrderField", str)
	}
	return nil
}

// DNSVerificationHistoryOrderField defines the ordering field of DNSVerificationHistory.
type DNSVerificationHistoryOrderField struct {
	// Value extracts the ordering value from the given DNSVerificationHistory.
	Value    func(*DNSVerificationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dnsverificationhistory.OrderOption
	toCursor func(*DNSVerificationHistory) Cursor
}

// DNSVerificationHistoryOrder defines the ordering of DNSVerificationHistory.
type DNSVerificationHistoryOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *DNSVerificationHistoryOrderField `json:"field"`
}

// DefaultDNSVerificationHistoryOrder is the default ordering of DNSVerificationHistory.
var DefaultDNSVerificationHistoryOrder = &DNSVerificationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DNSVerificationHistoryOrderField{
		Value: func(_m *DNSVerificationHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: dnsverificationhistory.FieldID,
		toTerm: dnsverificationhistory.ByID,
		toCursor: func(_m *DNSVerificationHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DNSVerificationHistory into DNSVerificationHistoryEdge.
func (_m *DNSVerificationHistory) ToEdge(order *DNSVerificationHistoryOrder) *DNSVerificationHistoryEdge {
	if order == nil {
		order = DefaultDNSVerificationHistoryOrder
	}
	return &DNSVerificationHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DirectoryAccountHistoryEdge is the edge representation of DirectoryAccountHistory.
type DirectoryAccountHistoryEdge struct {
	Node   *DirectoryAccountHistory `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// DirectoryAccountHistoryConnection is the connection containing edges to DirectoryAccountHistory.
type DirectoryAccountHistoryConnection struct {
	Edges      []*DirectoryAccountHistoryEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *DirectoryAccountHistoryConnection) build(nodes []*DirectoryAccountHistory, pager *directoryaccounthistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DirectoryAccountHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DirectoryAccountHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DirectoryAccountHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*DirectoryAccountHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DirectoryAccountHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DirectoryAccountHistoryPaginateOption enables pagination customization.
type DirectoryAccountHistoryPaginateOption func(*directoryaccounthistoryPager) error

// WithDirectoryAccountHistoryOrder configures pagination ordering.
func WithDirectoryAccountHistoryOrder(order *DirectoryAccountHistoryOrder) DirectoryAccountHistoryPaginateOption {
	if order == nil {
		order = DefaultDirectoryAccountHistoryOrder
	}
	o := *order
	return func(pager *directoryaccounthistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDirectoryAccountHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDirectoryAccountHistoryFilter configures pagination filter.
func WithDirectoryAccountHistoryFilter(filter func(*DirectoryAccountHistoryQuery) (*DirectoryAccountHistoryQuery, error)) DirectoryAccountHistoryPaginateOption {
	return func(pager *directoryaccounthistoryPager) error {
		if filter == nil {
			return errors.New("DirectoryAccountHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type directoryaccounthistoryPager struct {
	reverse bool
	order   *DirectoryAccountHistoryOrder
	filter  func(*DirectoryAccountHistoryQuery) (*DirectoryAccountHistoryQuery, error)
}

func newDirectoryAccountHistoryPager(opts []DirectoryAccountHistoryPaginateOption, reverse bool) (*directoryaccounthistoryPager, error) {
	pager := &directoryaccounthistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDirectoryAccountHistoryOrder
	}
	return pager, nil
}

func (p *directoryaccounthistoryPager) applyFilter(query *DirectoryAccountHistoryQuery) (*DirectoryAccountHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *directoryaccounthistoryPager) toCursor(_m *DirectoryAccountHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *directoryaccounthistoryPager) applyCursors(query *DirectoryAccountHistoryQuery, after, before *Cursor) (*DirectoryAccountHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDirectoryAccountHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *directoryaccounthistoryPager) applyOrder(query *DirectoryAccountHistoryQuery) *DirectoryAccountHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDirectoryAccountHistoryOrder.Field {
		query = query.Order(DefaultDirectoryAccountHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *directoryaccounthistoryPager) orderExpr(query *DirectoryAccountHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDirectoryAccountHistoryOrder.Field {
			b.Comma().Ident(DefaultDirectoryAccountHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DirectoryAccountHistory.
func (_m *DirectoryAccountHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DirectoryAccountHistoryPaginateOption,
) (*DirectoryAccountHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDirectoryAccountHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DirectoryAccountHistoryConnection{Edges: []*DirectoryAccountHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DirectoryAccountHistoryOrderFieldHistoryTime orders DirectoryAccountHistory by history_time.
	DirectoryAccountHistoryOrderFieldHistoryTime = &DirectoryAccountHistoryOrderField{
		Value: func(_m *DirectoryAccountHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: directoryaccounthistory.FieldHistoryTime,
		toTerm: directoryaccounthistory.ByHistoryTime,
		toCursor: func(_m *DirectoryAccountHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// DirectoryAccountHistoryOrderFieldCreatedAt orders DirectoryAccountHistory by created_at.
	DirectoryAccountHistoryOrderFieldCreatedAt = &DirectoryAccountHistoryOrderField{
		Value: func(_m *DirectoryAccountHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: directoryaccounthistory.FieldCreatedAt,
		toTerm: directoryaccounthistory.ByCreatedAt,
		toCursor: func(_m *DirectoryAccountHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DirectoryAccountHistoryOrderFieldUpdatedAt orders DirectoryAccountHistory by updated_at.
	DirectoryAccountHistoryOrderFieldUpdatedAt = &DirectoryAccountHistoryOrderField{
		Value: func(_m *DirectoryAccountHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: directoryaccounthistory.FieldUpdatedAt,
		toTerm: directoryaccounthistory.ByUpdatedAt,
		toCursor: func(_m *DirectoryAccountHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// DirectoryAccountHistoryOrderFieldDirectoryName orders DirectoryAccountHistory by directory_name.
	DirectoryAccountHistoryOrderFieldDirectoryName = &DirectoryAccountHistoryOrderField{
		Value: func(_m *DirectoryAccountHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.DirectoryName == nil {
				return nil, nil
			}
			return _m.DirectoryName, nil
		},
		column: directoryaccounthistory.FieldDirectoryName,
		toTerm: func(opts ...sql.OrderTermOption) directoryaccounthistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return directoryaccounthistory.ByDirectoryName(opts...)
		},
		toCursor: func(_m *DirectoryAccountHistory) Cursor {
			if _m.DirectoryName == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.DirectoryName,
			}
		},
	}
	// DirectoryAccountHistoryOrderFieldExternalID orders DirectoryAccountHistory by external_id.
	DirectoryAccountHistoryOrderFieldExternalID = &DirectoryAccountHistoryOrderField{
		Value: func(_m *DirectoryAccountHistory) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: directoryaccounthistory.FieldExternalID,
		toTerm: directoryaccounthistory.ByExternalID,
		toCursor: func(_m *DirectoryAccountHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// DirectoryAccountHistoryOrderFieldCanonicalEmail orders DirectoryAccountHistory by canonical_email.
	DirectoryAccountHistoryOrderFieldCanonicalEmail = &DirectoryAccountHistoryOrderField{
		Value: func(_m *DirectoryAccountHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.CanonicalEmail == nil {
				return nil, nil
			}
			return _m.CanonicalEmail, nil
		},
		column: directoryaccounthistory.FieldCanonicalEmail,
		toTerm: func(opts ...sql.OrderTermOption) directoryaccounthistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return directoryaccounthistory.ByCanonicalEmail(opts...)
		},
		toCursor: func(_m *DirectoryAccountHistory) Cursor {
			if _m.CanonicalEmail == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.CanonicalEmail,
			}
		},
	}
	// DirectoryAccountHistoryOrderFieldDisplayName orders DirectoryAccountHistory by display_name.
	DirectoryAccountHistoryOrderFieldDisplayName = &DirectoryAccountHistoryOrderField{
		Value: func(_m *DirectoryAccountHistory) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: directoryaccounthistory.FieldDisplayName,
		toTerm: directoryaccounthistory.ByDisplayName,
		toCursor: func(_m *DirectoryAccountHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DirectoryAccountHistoryOrderField) String() string {
	var str string
	switch f.column {
	case DirectoryAccountHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case DirectoryAccountHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case DirectoryAccountHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case DirectoryAccountHistoryOrderFieldDirectoryName.column:
		str = "directory_name"
	case DirectoryAccountHistoryOrderFieldExternalID.column:
		str = "external_id"
	case DirectoryAccountHistoryOrderFieldCanonicalEmail.column:
		str = "canonical_email"
	case DirectoryAccountHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DirectoryAccountHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DirectoryAccountHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DirectoryAccountHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *DirectoryAccountHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *DirectoryAccountHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *DirectoryAccountHistoryOrderFieldUpdatedAt
	case "directory_name":
		*f = *DirectoryAccountHistoryOrderFieldDirectoryName
	case "external_id":
		*f = *DirectoryAccountHistoryOrderFieldExternalID
	case "canonical_email":
		*f = *DirectoryAccountHistoryOrderFieldCanonicalEmail
	case "display_name":
		*f = *DirectoryAccountHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid DirectoryAccountHistoryOrderField", str)
	}
	return nil
}

// DirectoryAccountHistoryOrderField defines the ordering field of DirectoryAccountHistory.
type DirectoryAccountHistoryOrderField struct {
	// Value extracts the ordering value from the given DirectoryAccountHistory.
	Value    func(*DirectoryAccountHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) directoryaccounthistory.OrderOption
	toCursor func(*DirectoryAccountHistory) Cursor
}

// DirectoryAccountHistoryOrder defines the ordering of DirectoryAccountHistory.
type DirectoryAccountHistoryOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *DirectoryAccountHistoryOrderField `json:"field"`
}

// DefaultDirectoryAccountHistoryOrder is the default ordering of DirectoryAccountHistory.
var DefaultDirectoryAccountHistoryOrder = &DirectoryAccountHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DirectoryAccountHistoryOrderField{
		Value: func(_m *DirectoryAccountHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: directoryaccounthistory.FieldID,
		toTerm: directoryaccounthistory.ByID,
		toCursor: func(_m *DirectoryAccountHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DirectoryAccountHistory into DirectoryAccountHistoryEdge.
func (_m *DirectoryAccountHistory) ToEdge(order *DirectoryAccountHistoryOrder) *DirectoryAccountHistoryEdge {
	if order == nil {
		order = DefaultDirectoryAccountHistoryOrder
	}
	return &DirectoryAccountHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DirectoryGroupHistoryEdge is the edge representation of DirectoryGroupHistory.
type DirectoryGroupHistoryEdge struct {
	Node   *DirectoryGroupHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// DirectoryGroupHistoryConnection is the connection containing edges to DirectoryGroupHistory.
type DirectoryGroupHistoryConnection struct {
	Edges      []*DirectoryGroupHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *DirectoryGroupHistoryConnection) build(nodes []*DirectoryGroupHistory, pager *directorygrouphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DirectoryGroupHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DirectoryGroupHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DirectoryGroupHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*DirectoryGroupHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DirectoryGroupHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DirectoryGroupHistoryPaginateOption enables pagination customization.
type DirectoryGroupHistoryPaginateOption func(*directorygrouphistoryPager) error

// WithDirectoryGroupHistoryOrder configures pagination ordering.
func WithDirectoryGroupHistoryOrder(order *DirectoryGroupHistoryOrder) DirectoryGroupHistoryPaginateOption {
	if order == nil {
		order = DefaultDirectoryGroupHistoryOrder
	}
	o := *order
	return func(pager *directorygrouphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDirectoryGroupHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDirectoryGroupHistoryFilter configures pagination filter.
func WithDirectoryGroupHistoryFilter(filter func(*DirectoryGroupHistoryQuery) (*DirectoryGroupHistoryQuery, error)) DirectoryGroupHistoryPaginateOption {
	return func(pager *directorygrouphistoryPager) error {
		if filter == nil {
			return errors.New("DirectoryGroupHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type directorygrouphistoryPager struct {
	reverse bool
	order   *DirectoryGroupHistoryOrder
	filter  func(*DirectoryGroupHistoryQuery) (*DirectoryGroupHistoryQuery, error)
}

func newDirectoryGroupHistoryPager(opts []DirectoryGroupHistoryPaginateOption, reverse bool) (*directorygrouphistoryPager, error) {
	pager := &directorygrouphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDirectoryGroupHistoryOrder
	}
	return pager, nil
}

func (p *directorygrouphistoryPager) applyFilter(query *DirectoryGroupHistoryQuery) (*DirectoryGroupHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *directorygrouphistoryPager) toCursor(_m *DirectoryGroupHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *directorygrouphistoryPager) applyCursors(query *DirectoryGroupHistoryQuery, after, before *Cursor) (*DirectoryGroupHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDirectoryGroupHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *directorygrouphistoryPager) applyOrder(query *DirectoryGroupHistoryQuery) *DirectoryGroupHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDirectoryGroupHistoryOrder.Field {
		query = query.Order(DefaultDirectoryGroupHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *directorygrouphistoryPager) orderExpr(query *DirectoryGroupHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDirectoryGroupHistoryOrder.Field {
			b.Comma().Ident(DefaultDirectoryGroupHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DirectoryGroupHistory.
func (_m *DirectoryGroupHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DirectoryGroupHistoryPaginateOption,
) (*DirectoryGroupHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDirectoryGroupHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DirectoryGroupHistoryConnection{Edges: []*DirectoryGroupHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DirectoryGroupHistoryOrderFieldHistoryTime orders DirectoryGroupHistory by history_time.
	DirectoryGroupHistoryOrderFieldHistoryTime = &DirectoryGroupHistoryOrderField{
		Value: func(_m *DirectoryGroupHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: directorygrouphistory.FieldHistoryTime,
		toTerm: directorygrouphistory.ByHistoryTime,
		toCursor: func(_m *DirectoryGroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// DirectoryGroupHistoryOrderFieldCreatedAt orders DirectoryGroupHistory by created_at.
	DirectoryGroupHistoryOrderFieldCreatedAt = &DirectoryGroupHistoryOrderField{
		Value: func(_m *DirectoryGroupHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: directorygrouphistory.FieldCreatedAt,
		toTerm: directorygrouphistory.ByCreatedAt,
		toCursor: func(_m *DirectoryGroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DirectoryGroupHistoryOrderFieldUpdatedAt orders DirectoryGroupHistory by updated_at.
	DirectoryGroupHistoryOrderFieldUpdatedAt = &DirectoryGroupHistoryOrderField{
		Value: func(_m *DirectoryGroupHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: directorygrouphistory.FieldUpdatedAt,
		toTerm: directorygrouphistory.ByUpdatedAt,
		toCursor: func(_m *DirectoryGroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// DirectoryGroupHistoryOrderFieldExternalID orders DirectoryGroupHistory by external_id.
	DirectoryGroupHistoryOrderFieldExternalID = &DirectoryGroupHistoryOrderField{
		Value: func(_m *DirectoryGroupHistory) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: directorygrouphistory.FieldExternalID,
		toTerm: directorygrouphistory.ByExternalID,
		toCursor: func(_m *DirectoryGroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// DirectoryGroupHistoryOrderFieldEmail orders DirectoryGroupHistory by email.
	DirectoryGroupHistoryOrderFieldEmail = &DirectoryGroupHistoryOrderField{
		Value: func(_m *DirectoryGroupHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.Email == nil {
				return nil, nil
			}
			return _m.Email, nil
		},
		column: directorygrouphistory.FieldEmail,
		toTerm: func(opts ...sql.OrderTermOption) directorygrouphistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return directorygrouphistory.ByEmail(opts...)
		},
		toCursor: func(_m *DirectoryGroupHistory) Cursor {
			if _m.Email == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// DirectoryGroupHistoryOrderFieldDisplayName orders DirectoryGroupHistory by display_name.
	DirectoryGroupHistoryOrderFieldDisplayName = &DirectoryGroupHistoryOrderField{
		Value: func(_m *DirectoryGroupHistory) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: directorygrouphistory.FieldDisplayName,
		toTerm: directorygrouphistory.ByDisplayName,
		toCursor: func(_m *DirectoryGroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DirectoryGroupHistoryOrderField) String() string {
	var str string
	switch f.column {
	case DirectoryGroupHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case DirectoryGroupHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case DirectoryGroupHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case DirectoryGroupHistoryOrderFieldExternalID.column:
		str = "external_id"
	case DirectoryGroupHistoryOrderFieldEmail.column:
		str = "email"
	case DirectoryGroupHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DirectoryGroupHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DirectoryGroupHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DirectoryGroupHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *DirectoryGroupHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *DirectoryGroupHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *DirectoryGroupHistoryOrderFieldUpdatedAt
	case "external_id":
		*f = *DirectoryGroupHistoryOrderFieldExternalID
	case "email":
		*f = *DirectoryGroupHistoryOrderFieldEmail
	case "display_name":
		*f = *DirectoryGroupHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid DirectoryGroupHistoryOrderField", str)
	}
	return nil
}

// DirectoryGroupHistoryOrderField defines the ordering field of DirectoryGroupHistory.
type DirectoryGroupHistoryOrderField struct {
	// Value extracts the ordering value from the given DirectoryGroupHistory.
	Value    func(*DirectoryGroupHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) directorygrouphistory.OrderOption
	toCursor func(*DirectoryGroupHistory) Cursor
}

// DirectoryGroupHistoryOrder defines the ordering of DirectoryGroupHistory.
type DirectoryGroupHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *DirectoryGroupHistoryOrderField `json:"field"`
}

// DefaultDirectoryGroupHistoryOrder is the default ordering of DirectoryGroupHistory.
var DefaultDirectoryGroupHistoryOrder = &DirectoryGroupHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DirectoryGroupHistoryOrderField{
		Value: func(_m *DirectoryGroupHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: directorygrouphistory.FieldID,
		toTerm: directorygrouphistory.ByID,
		toCursor: func(_m *DirectoryGroupHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DirectoryGroupHistory into DirectoryGroupHistoryEdge.
func (_m *DirectoryGroupHistory) ToEdge(order *DirectoryGroupHistoryOrder) *DirectoryGroupHistoryEdge {
	if order == nil {
		order = DefaultDirectoryGroupHistoryOrder
	}
	return &DirectoryGroupHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DirectoryMembershipHistoryEdge is the edge representation of DirectoryMembershipHistory.
type DirectoryMembershipHistoryEdge struct {
	Node   *DirectoryMembershipHistory `json:"node"`
	Cursor Cursor                      `json:"cursor"`
}

// DirectoryMembershipHistoryConnection is the connection containing edges to DirectoryMembershipHistory.
type DirectoryMembershipHistoryConnection struct {
	Edges      []*DirectoryMembershipHistoryEdge `json:"edges"`
	PageInfo   PageInfo                          `json:"pageInfo"`
	TotalCount int                               `json:"totalCount"`
}

func (c *DirectoryMembershipHistoryConnection) build(nodes []*DirectoryMembershipHistory, pager *directorymembershiphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DirectoryMembershipHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DirectoryMembershipHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DirectoryMembershipHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*DirectoryMembershipHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DirectoryMembershipHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DirectoryMembershipHistoryPaginateOption enables pagination customization.
type DirectoryMembershipHistoryPaginateOption func(*directorymembershiphistoryPager) error

// WithDirectoryMembershipHistoryOrder configures pagination ordering.
func WithDirectoryMembershipHistoryOrder(order *DirectoryMembershipHistoryOrder) DirectoryMembershipHistoryPaginateOption {
	if order == nil {
		order = DefaultDirectoryMembershipHistoryOrder
	}
	o := *order
	return func(pager *directorymembershiphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDirectoryMembershipHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDirectoryMembershipHistoryFilter configures pagination filter.
func WithDirectoryMembershipHistoryFilter(filter func(*DirectoryMembershipHistoryQuery) (*DirectoryMembershipHistoryQuery, error)) DirectoryMembershipHistoryPaginateOption {
	return func(pager *directorymembershiphistoryPager) error {
		if filter == nil {
			return errors.New("DirectoryMembershipHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type directorymembershiphistoryPager struct {
	reverse bool
	order   *DirectoryMembershipHistoryOrder
	filter  func(*DirectoryMembershipHistoryQuery) (*DirectoryMembershipHistoryQuery, error)
}

func newDirectoryMembershipHistoryPager(opts []DirectoryMembershipHistoryPaginateOption, reverse bool) (*directorymembershiphistoryPager, error) {
	pager := &directorymembershiphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDirectoryMembershipHistoryOrder
	}
	return pager, nil
}

func (p *directorymembershiphistoryPager) applyFilter(query *DirectoryMembershipHistoryQuery) (*DirectoryMembershipHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *directorymembershiphistoryPager) toCursor(_m *DirectoryMembershipHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *directorymembershiphistoryPager) applyCursors(query *DirectoryMembershipHistoryQuery, after, before *Cursor) (*DirectoryMembershipHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDirectoryMembershipHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *directorymembershiphistoryPager) applyOrder(query *DirectoryMembershipHistoryQuery) *DirectoryMembershipHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDirectoryMembershipHistoryOrder.Field {
		query = query.Order(DefaultDirectoryMembershipHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *directorymembershiphistoryPager) orderExpr(query *DirectoryMembershipHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDirectoryMembershipHistoryOrder.Field {
			b.Comma().Ident(DefaultDirectoryMembershipHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DirectoryMembershipHistory.
func (_m *DirectoryMembershipHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DirectoryMembershipHistoryPaginateOption,
) (*DirectoryMembershipHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDirectoryMembershipHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DirectoryMembershipHistoryConnection{Edges: []*DirectoryMembershipHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DirectoryMembershipHistoryOrderFieldHistoryTime orders DirectoryMembershipHistory by history_time.
	DirectoryMembershipHistoryOrderFieldHistoryTime = &DirectoryMembershipHistoryOrderField{
		Value: func(_m *DirectoryMembershipHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: directorymembershiphistory.FieldHistoryTime,
		toTerm: directorymembershiphistory.ByHistoryTime,
		toCursor: func(_m *DirectoryMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// DirectoryMembershipHistoryOrderFieldCreatedAt orders DirectoryMembershipHistory by created_at.
	DirectoryMembershipHistoryOrderFieldCreatedAt = &DirectoryMembershipHistoryOrderField{
		Value: func(_m *DirectoryMembershipHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: directorymembershiphistory.FieldCreatedAt,
		toTerm: directorymembershiphistory.ByCreatedAt,
		toCursor: func(_m *DirectoryMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DirectoryMembershipHistoryOrderFieldUpdatedAt orders DirectoryMembershipHistory by updated_at.
	DirectoryMembershipHistoryOrderFieldUpdatedAt = &DirectoryMembershipHistoryOrderField{
		Value: func(_m *DirectoryMembershipHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: directorymembershiphistory.FieldUpdatedAt,
		toTerm: directorymembershiphistory.ByUpdatedAt,
		toCursor: func(_m *DirectoryMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DirectoryMembershipHistoryOrderField) String() string {
	var str string
	switch f.column {
	case DirectoryMembershipHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case DirectoryMembershipHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case DirectoryMembershipHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DirectoryMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DirectoryMembershipHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DirectoryMembershipHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *DirectoryMembershipHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *DirectoryMembershipHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *DirectoryMembershipHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DirectoryMembershipHistoryOrderField", str)
	}
	return nil
}

// DirectoryMembershipHistoryOrderField defines the ordering field of DirectoryMembershipHistory.
type DirectoryMembershipHistoryOrderField struct {
	// Value extracts the ordering value from the given DirectoryMembershipHistory.
	Value    func(*DirectoryMembershipHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) directorymembershiphistory.OrderOption
	toCursor func(*DirectoryMembershipHistory) Cursor
}

// DirectoryMembershipHistoryOrder defines the ordering of DirectoryMembershipHistory.
type DirectoryMembershipHistoryOrder struct {
	Direction OrderDirection                        `json:"direction"`
	Field     *DirectoryMembershipHistoryOrderField `json:"field"`
}

// DefaultDirectoryMembershipHistoryOrder is the default ordering of DirectoryMembershipHistory.
var DefaultDirectoryMembershipHistoryOrder = &DirectoryMembershipHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DirectoryMembershipHistoryOrderField{
		Value: func(_m *DirectoryMembershipHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: directorymembershiphistory.FieldID,
		toTerm: directorymembershiphistory.ByID,
		toCursor: func(_m *DirectoryMembershipHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DirectoryMembershipHistory into DirectoryMembershipHistoryEdge.
func (_m *DirectoryMembershipHistory) ToEdge(order *DirectoryMembershipHistoryOrder) *DirectoryMembershipHistoryEdge {
	if order == nil {
		order = DefaultDirectoryMembershipHistoryOrder
	}
	return &DirectoryMembershipHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DiscussionHistoryEdge is the edge representation of DiscussionHistory.
type DiscussionHistoryEdge struct {
	Node   *DiscussionHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// DiscussionHistoryConnection is the connection containing edges to DiscussionHistory.
type DiscussionHistoryConnection struct {
	Edges      []*DiscussionHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *DiscussionHistoryConnection) build(nodes []*DiscussionHistory, pager *discussionhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DiscussionHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DiscussionHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DiscussionHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*DiscussionHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DiscussionHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DiscussionHistoryPaginateOption enables pagination customization.
type DiscussionHistoryPaginateOption func(*discussionhistoryPager) error

// WithDiscussionHistoryOrder configures pagination ordering.
func WithDiscussionHistoryOrder(order *DiscussionHistoryOrder) DiscussionHistoryPaginateOption {
	if order == nil {
		order = DefaultDiscussionHistoryOrder
	}
	o := *order
	return func(pager *discussionhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDiscussionHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDiscussionHistoryFilter configures pagination filter.
func WithDiscussionHistoryFilter(filter func(*DiscussionHistoryQuery) (*DiscussionHistoryQuery, error)) DiscussionHistoryPaginateOption {
	return func(pager *discussionhistoryPager) error {
		if filter == nil {
			return errors.New("DiscussionHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type discussionhistoryPager struct {
	reverse bool
	order   *DiscussionHistoryOrder
	filter  func(*DiscussionHistoryQuery) (*DiscussionHistoryQuery, error)
}

func newDiscussionHistoryPager(opts []DiscussionHistoryPaginateOption, reverse bool) (*discussionhistoryPager, error) {
	pager := &discussionhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDiscussionHistoryOrder
	}
	return pager, nil
}

func (p *discussionhistoryPager) applyFilter(query *DiscussionHistoryQuery) (*DiscussionHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *discussionhistoryPager) toCursor(_m *DiscussionHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *discussionhistoryPager) applyCursors(query *DiscussionHistoryQuery, after, before *Cursor) (*DiscussionHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDiscussionHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *discussionhistoryPager) applyOrder(query *DiscussionHistoryQuery) *DiscussionHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDiscussionHistoryOrder.Field {
		query = query.Order(DefaultDiscussionHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *discussionhistoryPager) orderExpr(query *DiscussionHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDiscussionHistoryOrder.Field {
			b.Comma().Ident(DefaultDiscussionHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DiscussionHistory.
func (_m *DiscussionHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DiscussionHistoryPaginateOption,
) (*DiscussionHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDiscussionHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DiscussionHistoryConnection{Edges: []*DiscussionHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DiscussionHistoryOrderFieldHistoryTime orders DiscussionHistory by history_time.
	DiscussionHistoryOrderFieldHistoryTime = &DiscussionHistoryOrderField{
		Value: func(_m *DiscussionHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: discussionhistory.FieldHistoryTime,
		toTerm: discussionhistory.ByHistoryTime,
		toCursor: func(_m *DiscussionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// DiscussionHistoryOrderFieldCreatedAt orders DiscussionHistory by created_at.
	DiscussionHistoryOrderFieldCreatedAt = &DiscussionHistoryOrderField{
		Value: func(_m *DiscussionHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: discussionhistory.FieldCreatedAt,
		toTerm: discussionhistory.ByCreatedAt,
		toCursor: func(_m *DiscussionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DiscussionHistoryOrderFieldUpdatedAt orders DiscussionHistory by updated_at.
	DiscussionHistoryOrderFieldUpdatedAt = &DiscussionHistoryOrderField{
		Value: func(_m *DiscussionHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: discussionhistory.FieldUpdatedAt,
		toTerm: discussionhistory.ByUpdatedAt,
		toCursor: func(_m *DiscussionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DiscussionHistoryOrderField) String() string {
	var str string
	switch f.column {
	case DiscussionHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case DiscussionHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case DiscussionHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DiscussionHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DiscussionHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DiscussionHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *DiscussionHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *DiscussionHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *DiscussionHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DiscussionHistoryOrderField", str)
	}
	return nil
}

// DiscussionHistoryOrderField defines the ordering field of DiscussionHistory.
type DiscussionHistoryOrderField struct {
	// Value extracts the ordering value from the given DiscussionHistory.
	Value    func(*DiscussionHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) discussionhistory.OrderOption
	toCursor func(*DiscussionHistory) Cursor
}

// DiscussionHistoryOrder defines the ordering of DiscussionHistory.
type DiscussionHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *DiscussionHistoryOrderField `json:"field"`
}

// DefaultDiscussionHistoryOrder is the default ordering of DiscussionHistory.
var DefaultDiscussionHistoryOrder = &DiscussionHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DiscussionHistoryOrderField{
		Value: func(_m *DiscussionHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: discussionhistory.FieldID,
		toTerm: discussionhistory.ByID,
		toCursor: func(_m *DiscussionHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DiscussionHistory into DiscussionHistoryEdge.
func (_m *DiscussionHistory) ToEdge(order *DiscussionHistoryOrder) *DiscussionHistoryEdge {
	if order == nil {
		order = DefaultDiscussionHistoryOrder
	}
	return &DiscussionHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DocumentDataHistoryEdge is the edge representation of DocumentDataHistory.
type DocumentDataHistoryEdge struct {
	Node   *DocumentDataHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// DocumentDataHistoryConnection is the connection containing edges to DocumentDataHistory.
type DocumentDataHistoryConnection struct {
	Edges      []*DocumentDataHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *DocumentDataHistoryConnection) build(nodes []*DocumentDataHistory, pager *documentdatahistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DocumentDataHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DocumentDataHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DocumentDataHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*DocumentDataHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DocumentDataHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DocumentDataHistoryPaginateOption enables pagination customization.
type DocumentDataHistoryPaginateOption func(*documentdatahistoryPager) error

// WithDocumentDataHistoryOrder configures pagination ordering.
func WithDocumentDataHistoryOrder(order *DocumentDataHistoryOrder) DocumentDataHistoryPaginateOption {
	if order == nil {
		order = DefaultDocumentDataHistoryOrder
	}
	o := *order
	return func(pager *documentdatahistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDocumentDataHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDocumentDataHistoryFilter configures pagination filter.
func WithDocumentDataHistoryFilter(filter func(*DocumentDataHistoryQuery) (*DocumentDataHistoryQuery, error)) DocumentDataHistoryPaginateOption {
	return func(pager *documentdatahistoryPager) error {
		if filter == nil {
			return errors.New("DocumentDataHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type documentdatahistoryPager struct {
	reverse bool
	order   *DocumentDataHistoryOrder
	filter  func(*DocumentDataHistoryQuery) (*DocumentDataHistoryQuery, error)
}

func newDocumentDataHistoryPager(opts []DocumentDataHistoryPaginateOption, reverse bool) (*documentdatahistoryPager, error) {
	pager := &documentdatahistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDocumentDataHistoryOrder
	}
	return pager, nil
}

func (p *documentdatahistoryPager) applyFilter(query *DocumentDataHistoryQuery) (*DocumentDataHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *documentdatahistoryPager) toCursor(_m *DocumentDataHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *documentdatahistoryPager) applyCursors(query *DocumentDataHistoryQuery, after, before *Cursor) (*DocumentDataHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDocumentDataHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *documentdatahistoryPager) applyOrder(query *DocumentDataHistoryQuery) *DocumentDataHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDocumentDataHistoryOrder.Field {
		query = query.Order(DefaultDocumentDataHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *documentdatahistoryPager) orderExpr(query *DocumentDataHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDocumentDataHistoryOrder.Field {
			b.Comma().Ident(DefaultDocumentDataHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DocumentDataHistory.
func (_m *DocumentDataHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DocumentDataHistoryPaginateOption,
) (*DocumentDataHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDocumentDataHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DocumentDataHistoryConnection{Edges: []*DocumentDataHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DocumentDataHistoryOrderFieldHistoryTime orders DocumentDataHistory by history_time.
	DocumentDataHistoryOrderFieldHistoryTime = &DocumentDataHistoryOrderField{
		Value: func(_m *DocumentDataHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: documentdatahistory.FieldHistoryTime,
		toTerm: documentdatahistory.ByHistoryTime,
		toCursor: func(_m *DocumentDataHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// DocumentDataHistoryOrderFieldCreatedAt orders DocumentDataHistory by created_at.
	DocumentDataHistoryOrderFieldCreatedAt = &DocumentDataHistoryOrderField{
		Value: func(_m *DocumentDataHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: documentdatahistory.FieldCreatedAt,
		toTerm: documentdatahistory.ByCreatedAt,
		toCursor: func(_m *DocumentDataHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DocumentDataHistoryOrderFieldUpdatedAt orders DocumentDataHistory by updated_at.
	DocumentDataHistoryOrderFieldUpdatedAt = &DocumentDataHistoryOrderField{
		Value: func(_m *DocumentDataHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: documentdatahistory.FieldUpdatedAt,
		toTerm: documentdatahistory.ByUpdatedAt,
		toCursor: func(_m *DocumentDataHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DocumentDataHistoryOrderField) String() string {
	var str string
	switch f.column {
	case DocumentDataHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case DocumentDataHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case DocumentDataHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DocumentDataHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DocumentDataHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DocumentDataHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *DocumentDataHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *DocumentDataHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *DocumentDataHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DocumentDataHistoryOrderField", str)
	}
	return nil
}

// DocumentDataHistoryOrderField defines the ordering field of DocumentDataHistory.
type DocumentDataHistoryOrderField struct {
	// Value extracts the ordering value from the given DocumentDataHistory.
	Value    func(*DocumentDataHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) documentdatahistory.OrderOption
	toCursor func(*DocumentDataHistory) Cursor
}

// DocumentDataHistoryOrder defines the ordering of DocumentDataHistory.
type DocumentDataHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *DocumentDataHistoryOrderField `json:"field"`
}

// DefaultDocumentDataHistoryOrder is the default ordering of DocumentDataHistory.
var DefaultDocumentDataHistoryOrder = &DocumentDataHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DocumentDataHistoryOrderField{
		Value: func(_m *DocumentDataHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: documentdatahistory.FieldID,
		toTerm: documentdatahistory.ByID,
		toCursor: func(_m *DocumentDataHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DocumentDataHistory into DocumentDataHistoryEdge.
func (_m *DocumentDataHistory) ToEdge(order *DocumentDataHistoryOrder) *DocumentDataHistoryEdge {
	if order == nil {
		order = DefaultDocumentDataHistoryOrder
	}
	return &DocumentDataHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EmailBrandingHistoryEdge is the edge representation of EmailBrandingHistory.
type EmailBrandingHistoryEdge struct {
	Node   *EmailBrandingHistory `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// EmailBrandingHistoryConnection is the connection containing edges to EmailBrandingHistory.
type EmailBrandingHistoryConnection struct {
	Edges      []*EmailBrandingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *EmailBrandingHistoryConnection) build(nodes []*EmailBrandingHistory, pager *emailbrandinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *EmailBrandingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EmailBrandingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EmailBrandingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EmailBrandingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EmailBrandingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EmailBrandingHistoryPaginateOption enables pagination customization.
type EmailBrandingHistoryPaginateOption func(*emailbrandinghistoryPager) error

// WithEmailBrandingHistoryOrder configures pagination ordering.
func WithEmailBrandingHistoryOrder(order *EmailBrandingHistoryOrder) EmailBrandingHistoryPaginateOption {
	if order == nil {
		order = DefaultEmailBrandingHistoryOrder
	}
	o := *order
	return func(pager *emailbrandinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEmailBrandingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEmailBrandingHistoryFilter configures pagination filter.
func WithEmailBrandingHistoryFilter(filter func(*EmailBrandingHistoryQuery) (*EmailBrandingHistoryQuery, error)) EmailBrandingHistoryPaginateOption {
	return func(pager *emailbrandinghistoryPager) error {
		if filter == nil {
			return errors.New("EmailBrandingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type emailbrandinghistoryPager struct {
	reverse bool
	order   *EmailBrandingHistoryOrder
	filter  func(*EmailBrandingHistoryQuery) (*EmailBrandingHistoryQuery, error)
}

func newEmailBrandingHistoryPager(opts []EmailBrandingHistoryPaginateOption, reverse bool) (*emailbrandinghistoryPager, error) {
	pager := &emailbrandinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEmailBrandingHistoryOrder
	}
	return pager, nil
}

func (p *emailbrandinghistoryPager) applyFilter(query *EmailBrandingHistoryQuery) (*EmailBrandingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *emailbrandinghistoryPager) toCursor(_m *EmailBrandingHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *emailbrandinghistoryPager) applyCursors(query *EmailBrandingHistoryQuery, after, before *Cursor) (*EmailBrandingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEmailBrandingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *emailbrandinghistoryPager) applyOrder(query *EmailBrandingHistoryQuery) *EmailBrandingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEmailBrandingHistoryOrder.Field {
		query = query.Order(DefaultEmailBrandingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *emailbrandinghistoryPager) orderExpr(query *EmailBrandingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEmailBrandingHistoryOrder.Field {
			b.Comma().Ident(DefaultEmailBrandingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EmailBrandingHistory.
func (_m *EmailBrandingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EmailBrandingHistoryPaginateOption,
) (*EmailBrandingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEmailBrandingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EmailBrandingHistoryConnection{Edges: []*EmailBrandingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EmailBrandingHistoryOrderFieldHistoryTime orders EmailBrandingHistory by history_time.
	EmailBrandingHistoryOrderFieldHistoryTime = &EmailBrandingHistoryOrderField{
		Value: func(_m *EmailBrandingHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: emailbrandinghistory.FieldHistoryTime,
		toTerm: emailbrandinghistory.ByHistoryTime,
		toCursor: func(_m *EmailBrandingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// EmailBrandingHistoryOrderFieldCreatedAt orders EmailBrandingHistory by created_at.
	EmailBrandingHistoryOrderFieldCreatedAt = &EmailBrandingHistoryOrderField{
		Value: func(_m *EmailBrandingHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: emailbrandinghistory.FieldCreatedAt,
		toTerm: emailbrandinghistory.ByCreatedAt,
		toCursor: func(_m *EmailBrandingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EmailBrandingHistoryOrderFieldUpdatedAt orders EmailBrandingHistory by updated_at.
	EmailBrandingHistoryOrderFieldUpdatedAt = &EmailBrandingHistoryOrderField{
		Value: func(_m *EmailBrandingHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: emailbrandinghistory.FieldUpdatedAt,
		toTerm: emailbrandinghistory.ByUpdatedAt,
		toCursor: func(_m *EmailBrandingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// EmailBrandingHistoryOrderFieldName orders EmailBrandingHistory by name.
	EmailBrandingHistoryOrderFieldName = &EmailBrandingHistoryOrderField{
		Value: func(_m *EmailBrandingHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: emailbrandinghistory.FieldName,
		toTerm: emailbrandinghistory.ByName,
		toCursor: func(_m *EmailBrandingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EmailBrandingHistoryOrderField) String() string {
	var str string
	switch f.column {
	case EmailBrandingHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case EmailBrandingHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case EmailBrandingHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EmailBrandingHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EmailBrandingHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EmailBrandingHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EmailBrandingHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *EmailBrandingHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *EmailBrandingHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *EmailBrandingHistoryOrderFieldUpdatedAt
	case "name":
		*f = *EmailBrandingHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid EmailBrandingHistoryOrderField", str)
	}
	return nil
}

// EmailBrandingHistoryOrderField defines the ordering field of EmailBrandingHistory.
type EmailBrandingHistoryOrderField struct {
	// Value extracts the ordering value from the given EmailBrandingHistory.
	Value    func(*EmailBrandingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) emailbrandinghistory.OrderOption
	toCursor func(*EmailBrandingHistory) Cursor
}

// EmailBrandingHistoryOrder defines the ordering of EmailBrandingHistory.
type EmailBrandingHistoryOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *EmailBrandingHistoryOrderField `json:"field"`
}

// DefaultEmailBrandingHistoryOrder is the default ordering of EmailBrandingHistory.
var DefaultEmailBrandingHistoryOrder = &EmailBrandingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EmailBrandingHistoryOrderField{
		Value: func(_m *EmailBrandingHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: emailbrandinghistory.FieldID,
		toTerm: emailbrandinghistory.ByID,
		toCursor: func(_m *EmailBrandingHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts EmailBrandingHistory into EmailBrandingHistoryEdge.
func (_m *EmailBrandingHistory) ToEdge(order *EmailBrandingHistoryOrder) *EmailBrandingHistoryEdge {
	if order == nil {
		order = DefaultEmailBrandingHistoryOrder
	}
	return &EmailBrandingHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EmailTemplateHistoryEdge is the edge representation of EmailTemplateHistory.
type EmailTemplateHistoryEdge struct {
	Node   *EmailTemplateHistory `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// EmailTemplateHistoryConnection is the connection containing edges to EmailTemplateHistory.
type EmailTemplateHistoryConnection struct {
	Edges      []*EmailTemplateHistoryEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *EmailTemplateHistoryConnection) build(nodes []*EmailTemplateHistory, pager *emailtemplatehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *EmailTemplateHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EmailTemplateHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EmailTemplateHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EmailTemplateHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EmailTemplateHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EmailTemplateHistoryPaginateOption enables pagination customization.
type EmailTemplateHistoryPaginateOption func(*emailtemplatehistoryPager) error

// WithEmailTemplateHistoryOrder configures pagination ordering.
func WithEmailTemplateHistoryOrder(order *EmailTemplateHistoryOrder) EmailTemplateHistoryPaginateOption {
	if order == nil {
		order = DefaultEmailTemplateHistoryOrder
	}
	o := *order
	return func(pager *emailtemplatehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEmailTemplateHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEmailTemplateHistoryFilter configures pagination filter.
func WithEmailTemplateHistoryFilter(filter func(*EmailTemplateHistoryQuery) (*EmailTemplateHistoryQuery, error)) EmailTemplateHistoryPaginateOption {
	return func(pager *emailtemplatehistoryPager) error {
		if filter == nil {
			return errors.New("EmailTemplateHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type emailtemplatehistoryPager struct {
	reverse bool
	order   *EmailTemplateHistoryOrder
	filter  func(*EmailTemplateHistoryQuery) (*EmailTemplateHistoryQuery, error)
}

func newEmailTemplateHistoryPager(opts []EmailTemplateHistoryPaginateOption, reverse bool) (*emailtemplatehistoryPager, error) {
	pager := &emailtemplatehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEmailTemplateHistoryOrder
	}
	return pager, nil
}

func (p *emailtemplatehistoryPager) applyFilter(query *EmailTemplateHistoryQuery) (*EmailTemplateHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *emailtemplatehistoryPager) toCursor(_m *EmailTemplateHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *emailtemplatehistoryPager) applyCursors(query *EmailTemplateHistoryQuery, after, before *Cursor) (*EmailTemplateHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEmailTemplateHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *emailtemplatehistoryPager) applyOrder(query *EmailTemplateHistoryQuery) *EmailTemplateHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEmailTemplateHistoryOrder.Field {
		query = query.Order(DefaultEmailTemplateHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *emailtemplatehistoryPager) orderExpr(query *EmailTemplateHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEmailTemplateHistoryOrder.Field {
			b.Comma().Ident(DefaultEmailTemplateHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EmailTemplateHistory.
func (_m *EmailTemplateHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EmailTemplateHistoryPaginateOption,
) (*EmailTemplateHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEmailTemplateHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EmailTemplateHistoryConnection{Edges: []*EmailTemplateHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EmailTemplateHistoryOrderFieldHistoryTime orders EmailTemplateHistory by history_time.
	EmailTemplateHistoryOrderFieldHistoryTime = &EmailTemplateHistoryOrderField{
		Value: func(_m *EmailTemplateHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: emailtemplatehistory.FieldHistoryTime,
		toTerm: emailtemplatehistory.ByHistoryTime,
		toCursor: func(_m *EmailTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// EmailTemplateHistoryOrderFieldCreatedAt orders EmailTemplateHistory by created_at.
	EmailTemplateHistoryOrderFieldCreatedAt = &EmailTemplateHistoryOrderField{
		Value: func(_m *EmailTemplateHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: emailtemplatehistory.FieldCreatedAt,
		toTerm: emailtemplatehistory.ByCreatedAt,
		toCursor: func(_m *EmailTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EmailTemplateHistoryOrderFieldUpdatedAt orders EmailTemplateHistory by updated_at.
	EmailTemplateHistoryOrderFieldUpdatedAt = &EmailTemplateHistoryOrderField{
		Value: func(_m *EmailTemplateHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: emailtemplatehistory.FieldUpdatedAt,
		toTerm: emailtemplatehistory.ByUpdatedAt,
		toCursor: func(_m *EmailTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// EmailTemplateHistoryOrderFieldKey orders EmailTemplateHistory by key.
	EmailTemplateHistoryOrderFieldKey = &EmailTemplateHistoryOrderField{
		Value: func(_m *EmailTemplateHistory) (ent.Value, error) {
			return _m.Key, nil
		},
		column: emailtemplatehistory.FieldKey,
		toTerm: emailtemplatehistory.ByKey,
		toCursor: func(_m *EmailTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Key,
			}
		},
	}
	// EmailTemplateHistoryOrderFieldName orders EmailTemplateHistory by name.
	EmailTemplateHistoryOrderFieldName = &EmailTemplateHistoryOrderField{
		Value: func(_m *EmailTemplateHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: emailtemplatehistory.FieldName,
		toTerm: emailtemplatehistory.ByName,
		toCursor: func(_m *EmailTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// EmailTemplateHistoryOrderFieldFormat orders EmailTemplateHistory by format.
	EmailTemplateHistoryOrderFieldFormat = &EmailTemplateHistoryOrderField{
		Value: func(_m *EmailTemplateHistory) (ent.Value, error) {
			return _m.Format, nil
		},
		column: emailtemplatehistory.FieldFormat,
		toTerm: emailtemplatehistory.ByFormat,
		toCursor: func(_m *EmailTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Format,
			}
		},
	}
	// EmailTemplateHistoryOrderFieldLocale orders EmailTemplateHistory by locale.
	EmailTemplateHistoryOrderFieldLocale = &EmailTemplateHistoryOrderField{
		Value: func(_m *EmailTemplateHistory) (ent.Value, error) {
			return _m.Locale, nil
		},
		column: emailtemplatehistory.FieldLocale,
		toTerm: emailtemplatehistory.ByLocale,
		toCursor: func(_m *EmailTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Locale,
			}
		},
	}
	// EmailTemplateHistoryOrderFieldActive orders EmailTemplateHistory by active.
	EmailTemplateHistoryOrderFieldActive = &EmailTemplateHistoryOrderField{
		Value: func(_m *EmailTemplateHistory) (ent.Value, error) {
			return _m.Active, nil
		},
		column: emailtemplatehistory.FieldActive,
		toTerm: emailtemplatehistory.ByActive,
		toCursor: func(_m *EmailTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Active,
			}
		},
	}
	// EmailTemplateHistoryOrderFieldVersion orders EmailTemplateHistory by version.
	EmailTemplateHistoryOrderFieldVersion = &EmailTemplateHistoryOrderField{
		Value: func(_m *EmailTemplateHistory) (ent.Value, error) {
			return _m.Version, nil
		},
		column: emailtemplatehistory.FieldVersion,
		toTerm: emailtemplatehistory.ByVersion,
		toCursor: func(_m *EmailTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Version,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EmailTemplateHistoryOrderField) String() string {
	var str string
	switch f.column {
	case EmailTemplateHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case EmailTemplateHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case EmailTemplateHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EmailTemplateHistoryOrderFieldKey.column:
		str = "KEY"
	case EmailTemplateHistoryOrderFieldName.column:
		str = "NAME"
	case EmailTemplateHistoryOrderFieldFormat.column:
		str = "FORMAT"
	case EmailTemplateHistoryOrderFieldLocale.column:
		str = "LOCALE"
	case EmailTemplateHistoryOrderFieldActive.column:
		str = "ACTIVE"
	case EmailTemplateHistoryOrderFieldVersion.column:
		str = "VERSION"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EmailTemplateHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EmailTemplateHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EmailTemplateHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *EmailTemplateHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *EmailTemplateHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *EmailTemplateHistoryOrderFieldUpdatedAt
	case "KEY":
		*f = *EmailTemplateHistoryOrderFieldKey
	case "NAME":
		*f = *EmailTemplateHistoryOrderFieldName
	case "FORMAT":
		*f = *EmailTemplateHistoryOrderFieldFormat
	case "LOCALE":
		*f = *EmailTemplateHistoryOrderFieldLocale
	case "ACTIVE":
		*f = *EmailTemplateHistoryOrderFieldActive
	case "VERSION":
		*f = *EmailTemplateHistoryOrderFieldVersion
	default:
		return fmt.Errorf("%s is not a valid EmailTemplateHistoryOrderField", str)
	}
	return nil
}

// EmailTemplateHistoryOrderField defines the ordering field of EmailTemplateHistory.
type EmailTemplateHistoryOrderField struct {
	// Value extracts the ordering value from the given EmailTemplateHistory.
	Value    func(*EmailTemplateHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) emailtemplatehistory.OrderOption
	toCursor func(*EmailTemplateHistory) Cursor
}

// EmailTemplateHistoryOrder defines the ordering of EmailTemplateHistory.
type EmailTemplateHistoryOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *EmailTemplateHistoryOrderField `json:"field"`
}

// DefaultEmailTemplateHistoryOrder is the default ordering of EmailTemplateHistory.
var DefaultEmailTemplateHistoryOrder = &EmailTemplateHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EmailTemplateHistoryOrderField{
		Value: func(_m *EmailTemplateHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: emailtemplatehistory.FieldID,
		toTerm: emailtemplatehistory.ByID,
		toCursor: func(_m *EmailTemplateHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts EmailTemplateHistory into EmailTemplateHistoryEdge.
func (_m *EmailTemplateHistory) ToEdge(order *EmailTemplateHistoryOrder) *EmailTemplateHistoryEdge {
	if order == nil {
		order = DefaultEmailTemplateHistoryOrder
	}
	return &EmailTemplateHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EntityHistoryEdge is the edge representation of EntityHistory.
type EntityHistoryEdge struct {
	Node   *EntityHistory `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// EntityHistoryConnection is the connection containing edges to EntityHistory.
type EntityHistoryConnection struct {
	Edges      []*EntityHistoryEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *EntityHistoryConnection) build(nodes []*EntityHistory, pager *entityhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *EntityHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntityHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntityHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityHistoryPaginateOption enables pagination customization.
type EntityHistoryPaginateOption func(*entityhistoryPager) error

// WithEntityHistoryOrder configures pagination ordering.
func WithEntityHistoryOrder(order *EntityHistoryOrder) EntityHistoryPaginateOption {
	if order == nil {
		order = DefaultEntityHistoryOrder
	}
	o := *order
	return func(pager *entityhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntityHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntityHistoryFilter configures pagination filter.
func WithEntityHistoryFilter(filter func(*EntityHistoryQuery) (*EntityHistoryQuery, error)) EntityHistoryPaginateOption {
	return func(pager *entityhistoryPager) error {
		if filter == nil {
			return errors.New("EntityHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entityhistoryPager struct {
	reverse bool
	order   *EntityHistoryOrder
	filter  func(*EntityHistoryQuery) (*EntityHistoryQuery, error)
}

func newEntityHistoryPager(opts []EntityHistoryPaginateOption, reverse bool) (*entityhistoryPager, error) {
	pager := &entityhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntityHistoryOrder
	}
	return pager, nil
}

func (p *entityhistoryPager) applyFilter(query *EntityHistoryQuery) (*EntityHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entityhistoryPager) toCursor(_m *EntityHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *entityhistoryPager) applyCursors(query *EntityHistoryQuery, after, before *Cursor) (*EntityHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntityHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entityhistoryPager) applyOrder(query *EntityHistoryQuery) *EntityHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntityHistoryOrder.Field {
		query = query.Order(DefaultEntityHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entityhistoryPager) orderExpr(query *EntityHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntityHistoryOrder.Field {
			b.Comma().Ident(DefaultEntityHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntityHistory.
func (_m *EntityHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityHistoryPaginateOption,
) (*EntityHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EntityHistoryConnection{Edges: []*EntityHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityHistoryOrderFieldHistoryTime orders EntityHistory by history_time.
	EntityHistoryOrderFieldHistoryTime = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: entityhistory.FieldHistoryTime,
		toTerm: entityhistory.ByHistoryTime,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// EntityHistoryOrderFieldCreatedAt orders EntityHistory by created_at.
	EntityHistoryOrderFieldCreatedAt = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: entityhistory.FieldCreatedAt,
		toTerm: entityhistory.ByCreatedAt,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EntityHistoryOrderFieldUpdatedAt orders EntityHistory by updated_at.
	EntityHistoryOrderFieldUpdatedAt = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: entityhistory.FieldUpdatedAt,
		toTerm: entityhistory.ByUpdatedAt,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// EntityHistoryOrderFieldInternalOwner orders EntityHistory by internal_owner.
	EntityHistoryOrderFieldInternalOwner = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.InternalOwner, nil
		},
		column: entityhistory.FieldInternalOwner,
		toTerm: entityhistory.ByInternalOwner,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.InternalOwner,
			}
		},
	}
	// EntityHistoryOrderFieldReviewedBy orders EntityHistory by reviewed_by.
	EntityHistoryOrderFieldReviewedBy = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.ReviewedBy, nil
		},
		column: entityhistory.FieldReviewedBy,
		toTerm: entityhistory.ByReviewedBy,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewedBy,
			}
		},
	}
	// EntityHistoryOrderFieldLastReviewedAt orders EntityHistory by last_reviewed_at.
	EntityHistoryOrderFieldLastReviewedAt = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastReviewedAt == nil {
				return nil, nil
			}
			return _m.LastReviewedAt, nil
		},
		column: entityhistory.FieldLastReviewedAt,
		toTerm: func(opts ...sql.OrderTermOption) entityhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return entityhistory.ByLastReviewedAt(opts...)
		},
		toCursor: func(_m *EntityHistory) Cursor {
			if _m.LastReviewedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastReviewedAt,
			}
		},
	}
	// EntityHistoryOrderFieldName orders EntityHistory by name.
	EntityHistoryOrderFieldName = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: entityhistory.FieldName,
		toTerm: entityhistory.ByName,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// EntityHistoryOrderFieldDisplayName orders EntityHistory by display_name.
	EntityHistoryOrderFieldDisplayName = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: entityhistory.FieldDisplayName,
		toTerm: entityhistory.ByDisplayName,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
	// EntityHistoryOrderFieldStatus orders EntityHistory by status.
	EntityHistoryOrderFieldStatus = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: entityhistory.FieldStatus,
		toTerm: entityhistory.ByStatus,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// EntityHistoryOrderFieldApprovedForUse orders EntityHistory by approved_for_use.
	EntityHistoryOrderFieldApprovedForUse = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.ApprovedForUse, nil
		},
		column: entityhistory.FieldApprovedForUse,
		toTerm: entityhistory.ByApprovedForUse,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ApprovedForUse,
			}
		},
	}
	// EntityHistoryOrderFieldHasSoc2 orders EntityHistory by has_soc2.
	EntityHistoryOrderFieldHasSoc2 = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.HasSoc2, nil
		},
		column: entityhistory.FieldHasSoc2,
		toTerm: entityhistory.ByHasSoc2,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HasSoc2,
			}
		},
	}
	// EntityHistoryOrderFieldSoc2PeriodEnd orders EntityHistory by soc2_period_end.
	EntityHistoryOrderFieldSoc2PeriodEnd = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.Soc2PeriodEnd == nil {
				return nil, nil
			}
			return _m.Soc2PeriodEnd, nil
		},
		column: entityhistory.FieldSoc2PeriodEnd,
		toTerm: func(opts ...sql.OrderTermOption) entityhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return entityhistory.BySoc2PeriodEnd(opts...)
		},
		toCursor: func(_m *EntityHistory) Cursor {
			if _m.Soc2PeriodEnd == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.Soc2PeriodEnd,
			}
		},
	}
	// EntityHistoryOrderFieldContractStartDate orders EntityHistory by contract_start_date.
	EntityHistoryOrderFieldContractStartDate = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ContractStartDate == nil {
				return nil, nil
			}
			return _m.ContractStartDate, nil
		},
		column: entityhistory.FieldContractStartDate,
		toTerm: func(opts ...sql.OrderTermOption) entityhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return entityhistory.ByContractStartDate(opts...)
		},
		toCursor: func(_m *EntityHistory) Cursor {
			if _m.ContractStartDate == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ContractStartDate,
			}
		},
	}
	// EntityHistoryOrderFieldContractEndDate orders EntityHistory by contract_end_date.
	EntityHistoryOrderFieldContractEndDate = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ContractEndDate == nil {
				return nil, nil
			}
			return _m.ContractEndDate, nil
		},
		column: entityhistory.FieldContractEndDate,
		toTerm: func(opts ...sql.OrderTermOption) entityhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return entityhistory.ByContractEndDate(opts...)
		},
		toCursor: func(_m *EntityHistory) Cursor {
			if _m.ContractEndDate == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ContractEndDate,
			}
		},
	}
	// EntityHistoryOrderFieldAutoRenews orders EntityHistory by auto_renews.
	EntityHistoryOrderFieldAutoRenews = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.AutoRenews, nil
		},
		column: entityhistory.FieldAutoRenews,
		toTerm: entityhistory.ByAutoRenews,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.AutoRenews,
			}
		},
	}
	// EntityHistoryOrderFieldTerminationNoticeDays orders EntityHistory by termination_notice_days.
	EntityHistoryOrderFieldTerminationNoticeDays = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.TerminationNoticeDays, nil
		},
		column: entityhistory.FieldTerminationNoticeDays,
		toTerm: entityhistory.ByTerminationNoticeDays,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.TerminationNoticeDays,
			}
		},
	}
	// EntityHistoryOrderFieldAnnualSpend orders EntityHistory by annual_spend.
	EntityHistoryOrderFieldAnnualSpend = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.AnnualSpend, nil
		},
		column: entityhistory.FieldAnnualSpend,
		toTerm: entityhistory.ByAnnualSpend,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.AnnualSpend,
			}
		},
	}
	// EntityHistoryOrderFieldSpendCurrency orders EntityHistory by spend_currency.
	EntityHistoryOrderFieldSpendCurrency = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.SpendCurrency, nil
		},
		column: entityhistory.FieldSpendCurrency,
		toTerm: entityhistory.BySpendCurrency,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SpendCurrency,
			}
		},
	}
	// EntityHistoryOrderFieldBillingModel orders EntityHistory by billing_model.
	EntityHistoryOrderFieldBillingModel = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.BillingModel, nil
		},
		column: entityhistory.FieldBillingModel,
		toTerm: entityhistory.ByBillingModel,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.BillingModel,
			}
		},
	}
	// EntityHistoryOrderFieldRenewalRisk orders EntityHistory by renewal_risk.
	EntityHistoryOrderFieldRenewalRisk = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.RenewalRisk, nil
		},
		column: entityhistory.FieldRenewalRisk,
		toTerm: entityhistory.ByRenewalRisk,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RenewalRisk,
			}
		},
	}
	// EntityHistoryOrderFieldSSOEnforced orders EntityHistory by sso_enforced.
	EntityHistoryOrderFieldSSOEnforced = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.SSOEnforced, nil
		},
		column: entityhistory.FieldSSOEnforced,
		toTerm: entityhistory.BySSOEnforced,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SSOEnforced,
			}
		},
	}
	// EntityHistoryOrderFieldMfaSupported orders EntityHistory by mfa_supported.
	EntityHistoryOrderFieldMfaSupported = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.MfaSupported, nil
		},
		column: entityhistory.FieldMfaSupported,
		toTerm: entityhistory.ByMfaSupported,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.MfaSupported,
			}
		},
	}
	// EntityHistoryOrderFieldMfaEnforced orders EntityHistory by mfa_enforced.
	EntityHistoryOrderFieldMfaEnforced = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.MfaEnforced, nil
		},
		column: entityhistory.FieldMfaEnforced,
		toTerm: entityhistory.ByMfaEnforced,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.MfaEnforced,
			}
		},
	}
	// EntityHistoryOrderFieldStatusPageURL orders EntityHistory by status_page_url.
	EntityHistoryOrderFieldStatusPageURL = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.StatusPageURL, nil
		},
		column: entityhistory.FieldStatusPageURL,
		toTerm: entityhistory.ByStatusPageURL,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StatusPageURL,
			}
		},
	}
	// EntityHistoryOrderFieldRiskRating orders EntityHistory by risk_rating.
	EntityHistoryOrderFieldRiskRating = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.RiskRating, nil
		},
		column: entityhistory.FieldRiskRating,
		toTerm: entityhistory.ByRiskRating,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RiskRating,
			}
		},
	}
	// EntityHistoryOrderFieldRiskScore orders EntityHistory by risk_score.
	EntityHistoryOrderFieldRiskScore = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.RiskScore, nil
		},
		column: entityhistory.FieldRiskScore,
		toTerm: entityhistory.ByRiskScore,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RiskScore,
			}
		},
	}
	// EntityHistoryOrderFieldTier orders EntityHistory by tier.
	EntityHistoryOrderFieldTier = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.Tier, nil
		},
		column: entityhistory.FieldTier,
		toTerm: entityhistory.ByTier,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Tier,
			}
		},
	}
	// EntityHistoryOrderFieldReviewFrequency orders EntityHistory by review_frequency.
	EntityHistoryOrderFieldReviewFrequency = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.ReviewFrequency, nil
		},
		column: entityhistory.FieldReviewFrequency,
		toTerm: entityhistory.ByReviewFrequency,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewFrequency,
			}
		},
	}
	// EntityHistoryOrderFieldNextReviewAt orders EntityHistory by next_review_at.
	EntityHistoryOrderFieldNextReviewAt = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.NextReviewAt == nil {
				return nil, nil
			}
			return _m.NextReviewAt, nil
		},
		column: entityhistory.FieldNextReviewAt,
		toTerm: func(opts ...sql.OrderTermOption) entityhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return entityhistory.ByNextReviewAt(opts...)
		},
		toCursor: func(_m *EntityHistory) Cursor {
			if _m.NextReviewAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.NextReviewAt,
			}
		},
	}
	// EntityHistoryOrderFieldContractRenewalAt orders EntityHistory by contract_renewal_at.
	EntityHistoryOrderFieldContractRenewalAt = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ContractRenewalAt == nil {
				return nil, nil
			}
			return _m.ContractRenewalAt, nil
		},
		column: entityhistory.FieldContractRenewalAt,
		toTerm: func(opts ...sql.OrderTermOption) entityhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return entityhistory.ByContractRenewalAt(opts...)
		},
		toCursor: func(_m *EntityHistory) Cursor {
			if _m.ContractRenewalAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ContractRenewalAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityHistoryOrderField) String() string {
	var str string
	switch f.column {
	case EntityHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case EntityHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case EntityHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EntityHistoryOrderFieldInternalOwner.column:
		str = "internal_owner"
	case EntityHistoryOrderFieldReviewedBy.column:
		str = "reviewed_by"
	case EntityHistoryOrderFieldLastReviewedAt.column:
		str = "last_reviewed_at"
	case EntityHistoryOrderFieldName.column:
		str = "name"
	case EntityHistoryOrderFieldDisplayName.column:
		str = "display_name"
	case EntityHistoryOrderFieldStatus.column:
		str = "status"
	case EntityHistoryOrderFieldApprovedForUse.column:
		str = "approved_for_use"
	case EntityHistoryOrderFieldHasSoc2.column:
		str = "has_soc2"
	case EntityHistoryOrderFieldSoc2PeriodEnd.column:
		str = "soc2_period_end"
	case EntityHistoryOrderFieldContractStartDate.column:
		str = "contract_start_date"
	case EntityHistoryOrderFieldContractEndDate.column:
		str = "contract_end_date"
	case EntityHistoryOrderFieldAutoRenews.column:
		str = "auto_renews"
	case EntityHistoryOrderFieldTerminationNoticeDays.column:
		str = "termination_notice_days"
	case EntityHistoryOrderFieldAnnualSpend.column:
		str = "annual_spend"
	case EntityHistoryOrderFieldSpendCurrency.column:
		str = "spend_currency"
	case EntityHistoryOrderFieldBillingModel.column:
		str = "billing_model"
	case EntityHistoryOrderFieldRenewalRisk.column:
		str = "renewal_risk"
	case EntityHistoryOrderFieldSSOEnforced.column:
		str = "sso_enforced"
	case EntityHistoryOrderFieldMfaSupported.column:
		str = "mfa_supported"
	case EntityHistoryOrderFieldMfaEnforced.column:
		str = "mfa_enforced"
	case EntityHistoryOrderFieldStatusPageURL.column:
		str = "status_page_url"
	case EntityHistoryOrderFieldRiskRating.column:
		str = "risk_rating"
	case EntityHistoryOrderFieldRiskScore.column:
		str = "risk_score"
	case EntityHistoryOrderFieldTier.column:
		str = "tier"
	case EntityHistoryOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	case EntityHistoryOrderFieldNextReviewAt.column:
		str = "next_review_at"
	case EntityHistoryOrderFieldContractRenewalAt.column:
		str = "contract_renewal_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *EntityHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *EntityHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *EntityHistoryOrderFieldUpdatedAt
	case "internal_owner":
		*f = *EntityHistoryOrderFieldInternalOwner
	case "reviewed_by":
		*f = *EntityHistoryOrderFieldReviewedBy
	case "last_reviewed_at":
		*f = *EntityHistoryOrderFieldLastReviewedAt
	case "name":
		*f = *EntityHistoryOrderFieldName
	case "display_name":
		*f = *EntityHistoryOrderFieldDisplayName
	case "status":
		*f = *EntityHistoryOrderFieldStatus
	case "approved_for_use":
		*f = *EntityHistoryOrderFieldApprovedForUse
	case "has_soc2":
		*f = *EntityHistoryOrderFieldHasSoc2
	case "soc2_period_end":
		*f = *EntityHistoryOrderFieldSoc2PeriodEnd
	case "contract_start_date":
		*f = *EntityHistoryOrderFieldContractStartDate
	case "contract_end_date":
		*f = *EntityHistoryOrderFieldContractEndDate
	case "auto_renews":
		*f = *EntityHistoryOrderFieldAutoRenews
	case "termination_notice_days":
		*f = *EntityHistoryOrderFieldTerminationNoticeDays
	case "annual_spend":
		*f = *EntityHistoryOrderFieldAnnualSpend
	case "spend_currency":
		*f = *EntityHistoryOrderFieldSpendCurrency
	case "billing_model":
		*f = *EntityHistoryOrderFieldBillingModel
	case "renewal_risk":
		*f = *EntityHistoryOrderFieldRenewalRisk
	case "sso_enforced":
		*f = *EntityHistoryOrderFieldSSOEnforced
	case "mfa_supported":
		*f = *EntityHistoryOrderFieldMfaSupported
	case "mfa_enforced":
		*f = *EntityHistoryOrderFieldMfaEnforced
	case "status_page_url":
		*f = *EntityHistoryOrderFieldStatusPageURL
	case "risk_rating":
		*f = *EntityHistoryOrderFieldRiskRating
	case "risk_score":
		*f = *EntityHistoryOrderFieldRiskScore
	case "tier":
		*f = *EntityHistoryOrderFieldTier
	case "REVIEW_FREQUENCY":
		*f = *EntityHistoryOrderFieldReviewFrequency
	case "next_review_at":
		*f = *EntityHistoryOrderFieldNextReviewAt
	case "contract_renewal_at":
		*f = *EntityHistoryOrderFieldContractRenewalAt
	default:
		return fmt.Errorf("%s is not a valid EntityHistoryOrderField", str)
	}
	return nil
}

// EntityHistoryOrderField defines the ordering field of EntityHistory.
type EntityHistoryOrderField struct {
	// Value extracts the ordering value from the given EntityHistory.
	Value    func(*EntityHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entityhistory.OrderOption
	toCursor func(*EntityHistory) Cursor
}

// EntityHistoryOrder defines the ordering of EntityHistory.
type EntityHistoryOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *EntityHistoryOrderField `json:"field"`
}

// DefaultEntityHistoryOrder is the default ordering of EntityHistory.
var DefaultEntityHistoryOrder = &EntityHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: entityhistory.FieldID,
		toTerm: entityhistory.ByID,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts EntityHistory into EntityHistoryEdge.
func (_m *EntityHistory) ToEdge(order *EntityHistoryOrder) *EntityHistoryEdge {
	if order == nil {
		order = DefaultEntityHistoryOrder
	}
	return &EntityHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EntityTypeHistoryEdge is the edge representation of EntityTypeHistory.
type EntityTypeHistoryEdge struct {
	Node   *EntityTypeHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// EntityTypeHistoryConnection is the connection containing edges to EntityTypeHistory.
type EntityTypeHistoryConnection struct {
	Edges      []*EntityTypeHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *EntityTypeHistoryConnection) build(nodes []*EntityTypeHistory, pager *entitytypehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *EntityTypeHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntityTypeHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntityTypeHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityTypeHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityTypeHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityTypeHistoryPaginateOption enables pagination customization.
type EntityTypeHistoryPaginateOption func(*entitytypehistoryPager) error

// WithEntityTypeHistoryOrder configures pagination ordering.
func WithEntityTypeHistoryOrder(order *EntityTypeHistoryOrder) EntityTypeHistoryPaginateOption {
	if order == nil {
		order = DefaultEntityTypeHistoryOrder
	}
	o := *order
	return func(pager *entitytypehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntityTypeHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntityTypeHistoryFilter configures pagination filter.
func WithEntityTypeHistoryFilter(filter func(*EntityTypeHistoryQuery) (*EntityTypeHistoryQuery, error)) EntityTypeHistoryPaginateOption {
	return func(pager *entitytypehistoryPager) error {
		if filter == nil {
			return errors.New("EntityTypeHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entitytypehistoryPager struct {
	reverse bool
	order   *EntityTypeHistoryOrder
	filter  func(*EntityTypeHistoryQuery) (*EntityTypeHistoryQuery, error)
}

func newEntityTypeHistoryPager(opts []EntityTypeHistoryPaginateOption, reverse bool) (*entitytypehistoryPager, error) {
	pager := &entitytypehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntityTypeHistoryOrder
	}
	return pager, nil
}

func (p *entitytypehistoryPager) applyFilter(query *EntityTypeHistoryQuery) (*EntityTypeHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entitytypehistoryPager) toCursor(_m *EntityTypeHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *entitytypehistoryPager) applyCursors(query *EntityTypeHistoryQuery, after, before *Cursor) (*EntityTypeHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntityTypeHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entitytypehistoryPager) applyOrder(query *EntityTypeHistoryQuery) *EntityTypeHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntityTypeHistoryOrder.Field {
		query = query.Order(DefaultEntityTypeHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entitytypehistoryPager) orderExpr(query *EntityTypeHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntityTypeHistoryOrder.Field {
			b.Comma().Ident(DefaultEntityTypeHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntityTypeHistory.
func (_m *EntityTypeHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityTypeHistoryPaginateOption,
) (*EntityTypeHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityTypeHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EntityTypeHistoryConnection{Edges: []*EntityTypeHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityTypeHistoryOrderFieldHistoryTime orders EntityTypeHistory by history_time.
	EntityTypeHistoryOrderFieldHistoryTime = &EntityTypeHistoryOrderField{
		Value: func(_m *EntityTypeHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: entitytypehistory.FieldHistoryTime,
		toTerm: entitytypehistory.ByHistoryTime,
		toCursor: func(_m *EntityTypeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// EntityTypeHistoryOrderFieldCreatedAt orders EntityTypeHistory by created_at.
	EntityTypeHistoryOrderFieldCreatedAt = &EntityTypeHistoryOrderField{
		Value: func(_m *EntityTypeHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: entitytypehistory.FieldCreatedAt,
		toTerm: entitytypehistory.ByCreatedAt,
		toCursor: func(_m *EntityTypeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EntityTypeHistoryOrderFieldUpdatedAt orders EntityTypeHistory by updated_at.
	EntityTypeHistoryOrderFieldUpdatedAt = &EntityTypeHistoryOrderField{
		Value: func(_m *EntityTypeHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: entitytypehistory.FieldUpdatedAt,
		toTerm: entitytypehistory.ByUpdatedAt,
		toCursor: func(_m *EntityTypeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// EntityTypeHistoryOrderFieldName orders EntityTypeHistory by name.
	EntityTypeHistoryOrderFieldName = &EntityTypeHistoryOrderField{
		Value: func(_m *EntityTypeHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: entitytypehistory.FieldName,
		toTerm: entitytypehistory.ByName,
		toCursor: func(_m *EntityTypeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityTypeHistoryOrderField) String() string {
	var str string
	switch f.column {
	case EntityTypeHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case EntityTypeHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case EntityTypeHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EntityTypeHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityTypeHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityTypeHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityTypeHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *EntityTypeHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *EntityTypeHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *EntityTypeHistoryOrderFieldUpdatedAt
	case "name":
		*f = *EntityTypeHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid EntityTypeHistoryOrderField", str)
	}
	return nil
}

// EntityTypeHistoryOrderField defines the ordering field of EntityTypeHistory.
type EntityTypeHistoryOrderField struct {
	// Value extracts the ordering value from the given EntityTypeHistory.
	Value    func(*EntityTypeHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entitytypehistory.OrderOption
	toCursor func(*EntityTypeHistory) Cursor
}

// EntityTypeHistoryOrder defines the ordering of EntityTypeHistory.
type EntityTypeHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *EntityTypeHistoryOrderField `json:"field"`
}

// DefaultEntityTypeHistoryOrder is the default ordering of EntityTypeHistory.
var DefaultEntityTypeHistoryOrder = &EntityTypeHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityTypeHistoryOrderField{
		Value: func(_m *EntityTypeHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: entitytypehistory.FieldID,
		toTerm: entitytypehistory.ByID,
		toCursor: func(_m *EntityTypeHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts EntityTypeHistory into EntityTypeHistoryEdge.
func (_m *EntityTypeHistory) ToEdge(order *EntityTypeHistoryOrder) *EntityTypeHistoryEdge {
	if order == nil {
		order = DefaultEntityTypeHistoryOrder
	}
	return &EntityTypeHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EvidenceHistoryEdge is the edge representation of EvidenceHistory.
type EvidenceHistoryEdge struct {
	Node   *EvidenceHistory `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// EvidenceHistoryConnection is the connection containing edges to EvidenceHistory.
type EvidenceHistoryConnection struct {
	Edges      []*EvidenceHistoryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *EvidenceHistoryConnection) build(nodes []*EvidenceHistory, pager *evidencehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *EvidenceHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EvidenceHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EvidenceHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EvidenceHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EvidenceHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EvidenceHistoryPaginateOption enables pagination customization.
type EvidenceHistoryPaginateOption func(*evidencehistoryPager) error

// WithEvidenceHistoryOrder configures pagination ordering.
func WithEvidenceHistoryOrder(order *EvidenceHistoryOrder) EvidenceHistoryPaginateOption {
	if order == nil {
		order = DefaultEvidenceHistoryOrder
	}
	o := *order
	return func(pager *evidencehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEvidenceHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEvidenceHistoryFilter configures pagination filter.
func WithEvidenceHistoryFilter(filter func(*EvidenceHistoryQuery) (*EvidenceHistoryQuery, error)) EvidenceHistoryPaginateOption {
	return func(pager *evidencehistoryPager) error {
		if filter == nil {
			return errors.New("EvidenceHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type evidencehistoryPager struct {
	reverse bool
	order   *EvidenceHistoryOrder
	filter  func(*EvidenceHistoryQuery) (*EvidenceHistoryQuery, error)
}

func newEvidenceHistoryPager(opts []EvidenceHistoryPaginateOption, reverse bool) (*evidencehistoryPager, error) {
	pager := &evidencehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEvidenceHistoryOrder
	}
	return pager, nil
}

func (p *evidencehistoryPager) applyFilter(query *EvidenceHistoryQuery) (*EvidenceHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *evidencehistoryPager) toCursor(_m *EvidenceHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *evidencehistoryPager) applyCursors(query *EvidenceHistoryQuery, after, before *Cursor) (*EvidenceHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEvidenceHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *evidencehistoryPager) applyOrder(query *EvidenceHistoryQuery) *EvidenceHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEvidenceHistoryOrder.Field {
		query = query.Order(DefaultEvidenceHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *evidencehistoryPager) orderExpr(query *EvidenceHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEvidenceHistoryOrder.Field {
			b.Comma().Ident(DefaultEvidenceHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EvidenceHistory.
func (_m *EvidenceHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EvidenceHistoryPaginateOption,
) (*EvidenceHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEvidenceHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EvidenceHistoryConnection{Edges: []*EvidenceHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EvidenceHistoryOrderFieldHistoryTime orders EvidenceHistory by history_time.
	EvidenceHistoryOrderFieldHistoryTime = &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: evidencehistory.FieldHistoryTime,
		toTerm: evidencehistory.ByHistoryTime,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// EvidenceHistoryOrderFieldCreatedAt orders EvidenceHistory by created_at.
	EvidenceHistoryOrderFieldCreatedAt = &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: evidencehistory.FieldCreatedAt,
		toTerm: evidencehistory.ByCreatedAt,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EvidenceHistoryOrderFieldUpdatedAt orders EvidenceHistory by updated_at.
	EvidenceHistoryOrderFieldUpdatedAt = &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: evidencehistory.FieldUpdatedAt,
		toTerm: evidencehistory.ByUpdatedAt,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// EvidenceHistoryOrderFieldName orders EvidenceHistory by name.
	EvidenceHistoryOrderFieldName = &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: evidencehistory.FieldName,
		toTerm: evidencehistory.ByName,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// EvidenceHistoryOrderFieldCreationDate orders EvidenceHistory by creation_date.
	EvidenceHistoryOrderFieldCreationDate = &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.CreationDate, nil
		},
		column: evidencehistory.FieldCreationDate,
		toTerm: evidencehistory.ByCreationDate,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreationDate,
			}
		},
	}
	// EvidenceHistoryOrderFieldRenewalDate orders EvidenceHistory by renewal_date.
	EvidenceHistoryOrderFieldRenewalDate = &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.RenewalDate, nil
		},
		column: evidencehistory.FieldRenewalDate,
		toTerm: evidencehistory.ByRenewalDate,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RenewalDate,
			}
		},
	}
	// EvidenceHistoryOrderFieldStatus orders EvidenceHistory by status.
	EvidenceHistoryOrderFieldStatus = &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: evidencehistory.FieldStatus,
		toTerm: evidencehistory.ByStatus,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EvidenceHistoryOrderField) String() string {
	var str string
	switch f.column {
	case EvidenceHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case EvidenceHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case EvidenceHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EvidenceHistoryOrderFieldName.column:
		str = "name"
	case EvidenceHistoryOrderFieldCreationDate.column:
		str = "creation_date"
	case EvidenceHistoryOrderFieldRenewalDate.column:
		str = "renewal_date"
	case EvidenceHistoryOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EvidenceHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EvidenceHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EvidenceHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *EvidenceHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *EvidenceHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *EvidenceHistoryOrderFieldUpdatedAt
	case "name":
		*f = *EvidenceHistoryOrderFieldName
	case "creation_date":
		*f = *EvidenceHistoryOrderFieldCreationDate
	case "renewal_date":
		*f = *EvidenceHistoryOrderFieldRenewalDate
	case "STATUS":
		*f = *EvidenceHistoryOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid EvidenceHistoryOrderField", str)
	}
	return nil
}

// EvidenceHistoryOrderField defines the ordering field of EvidenceHistory.
type EvidenceHistoryOrderField struct {
	// Value extracts the ordering value from the given EvidenceHistory.
	Value    func(*EvidenceHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) evidencehistory.OrderOption
	toCursor func(*EvidenceHistory) Cursor
}

// EvidenceHistoryOrder defines the ordering of EvidenceHistory.
type EvidenceHistoryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *EvidenceHistoryOrderField `json:"field"`
}

// DefaultEvidenceHistoryOrder is the default ordering of EvidenceHistory.
var DefaultEvidenceHistoryOrder = &EvidenceHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: evidencehistory.FieldID,
		toTerm: evidencehistory.ByID,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts EvidenceHistory into EvidenceHistoryEdge.
func (_m *EvidenceHistory) ToEdge(order *EvidenceHistoryOrder) *EvidenceHistoryEdge {
	if order == nil {
		order = DefaultEvidenceHistoryOrder
	}
	return &EvidenceHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// FileHistoryEdge is the edge representation of FileHistory.
type FileHistoryEdge struct {
	Node   *FileHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// FileHistoryConnection is the connection containing edges to FileHistory.
type FileHistoryConnection struct {
	Edges      []*FileHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *FileHistoryConnection) build(nodes []*FileHistory, pager *filehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *FileHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FileHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FileHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FileHistoryPaginateOption enables pagination customization.
type FileHistoryPaginateOption func(*filehistoryPager) error

// WithFileHistoryOrder configures pagination ordering.
func WithFileHistoryOrder(order *FileHistoryOrder) FileHistoryPaginateOption {
	if order == nil {
		order = DefaultFileHistoryOrder
	}
	o := *order
	return func(pager *filehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileHistoryFilter configures pagination filter.
func WithFileHistoryFilter(filter func(*FileHistoryQuery) (*FileHistoryQuery, error)) FileHistoryPaginateOption {
	return func(pager *filehistoryPager) error {
		if filter == nil {
			return errors.New("FileHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filehistoryPager struct {
	reverse bool
	order   *FileHistoryOrder
	filter  func(*FileHistoryQuery) (*FileHistoryQuery, error)
}

func newFileHistoryPager(opts []FileHistoryPaginateOption, reverse bool) (*filehistoryPager, error) {
	pager := &filehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileHistoryOrder
	}
	return pager, nil
}

func (p *filehistoryPager) applyFilter(query *FileHistoryQuery) (*FileHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filehistoryPager) toCursor(_m *FileHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *filehistoryPager) applyCursors(query *FileHistoryQuery, after, before *Cursor) (*FileHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFileHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *filehistoryPager) applyOrder(query *FileHistoryQuery) *FileHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFileHistoryOrder.Field {
		query = query.Order(DefaultFileHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *filehistoryPager) orderExpr(query *FileHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileHistoryOrder.Field {
			b.Comma().Ident(DefaultFileHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FileHistory.
func (_m *FileHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FileHistoryPaginateOption,
) (*FileHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFileHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &FileHistoryConnection{Edges: []*FileHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FileHistoryOrderFieldHistoryTime orders FileHistory by history_time.
	FileHistoryOrderFieldHistoryTime = &FileHistoryOrderField{
		Value: func(_m *FileHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: filehistory.FieldHistoryTime,
		toTerm: filehistory.ByHistoryTime,
		toCursor: func(_m *FileHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// FileHistoryOrderFieldCreatedAt orders FileHistory by created_at.
	FileHistoryOrderFieldCreatedAt = &FileHistoryOrderField{
		Value: func(_m *FileHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: filehistory.FieldCreatedAt,
		toTerm: filehistory.ByCreatedAt,
		toCursor: func(_m *FileHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// FileHistoryOrderFieldUpdatedAt orders FileHistory by updated_at.
	FileHistoryOrderFieldUpdatedAt = &FileHistoryOrderField{
		Value: func(_m *FileHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: filehistory.FieldUpdatedAt,
		toTerm: filehistory.ByUpdatedAt,
		toCursor: func(_m *FileHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// FileHistoryOrderFieldLastAccessedAt orders FileHistory by last_accessed_at.
	FileHistoryOrderFieldLastAccessedAt = &FileHistoryOrderField{
		Value: func(_m *FileHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastAccessedAt == nil {
				return nil, nil
			}
			return _m.LastAccessedAt, nil
		},
		column: filehistory.FieldLastAccessedAt,
		toTerm: func(opts ...sql.OrderTermOption) filehistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return filehistory.ByLastAccessedAt(opts...)
		},
		toCursor: func(_m *FileHistory) Cursor {
			if _m.LastAccessedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastAccessedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FileHistoryOrderField) String() string {
	var str string
	switch f.column {
	case FileHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case FileHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case FileHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case FileHistoryOrderFieldLastAccessedAt.column:
		str = "last_accessed_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FileHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FileHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FileHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *FileHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *FileHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *FileHistoryOrderFieldUpdatedAt
	case "last_accessed_at":
		*f = *FileHistoryOrderFieldLastAccessedAt
	default:
		return fmt.Errorf("%s is not a valid FileHistoryOrderField", str)
	}
	return nil
}

// FileHistoryOrderField defines the ordering field of FileHistory.
type FileHistoryOrderField struct {
	// Value extracts the ordering value from the given FileHistory.
	Value    func(*FileHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) filehistory.OrderOption
	toCursor func(*FileHistory) Cursor
}

// FileHistoryOrder defines the ordering of FileHistory.
type FileHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *FileHistoryOrderField `json:"field"`
}

// DefaultFileHistoryOrder is the default ordering of FileHistory.
var DefaultFileHistoryOrder = &FileHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileHistoryOrderField{
		Value: func(_m *FileHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: filehistory.FieldID,
		toTerm: filehistory.ByID,
		toCursor: func(_m *FileHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts FileHistory into FileHistoryEdge.
func (_m *FileHistory) ToEdge(order *FileHistoryOrder) *FileHistoryEdge {
	if order == nil {
		order = DefaultFileHistoryOrder
	}
	return &FileHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// FindingControlHistoryEdge is the edge representation of FindingControlHistory.
type FindingControlHistoryEdge struct {
	Node   *FindingControlHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// FindingControlHistoryConnection is the connection containing edges to FindingControlHistory.
type FindingControlHistoryConnection struct {
	Edges      []*FindingControlHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *FindingControlHistoryConnection) build(nodes []*FindingControlHistory, pager *findingcontrolhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *FindingControlHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FindingControlHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FindingControlHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*FindingControlHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FindingControlHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FindingControlHistoryPaginateOption enables pagination customization.
type FindingControlHistoryPaginateOption func(*findingcontrolhistoryPager) error

// WithFindingControlHistoryOrder configures pagination ordering.
func WithFindingControlHistoryOrder(order *FindingControlHistoryOrder) FindingControlHistoryPaginateOption {
	if order == nil {
		order = DefaultFindingControlHistoryOrder
	}
	o := *order
	return func(pager *findingcontrolhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFindingControlHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFindingControlHistoryFilter configures pagination filter.
func WithFindingControlHistoryFilter(filter func(*FindingControlHistoryQuery) (*FindingControlHistoryQuery, error)) FindingControlHistoryPaginateOption {
	return func(pager *findingcontrolhistoryPager) error {
		if filter == nil {
			return errors.New("FindingControlHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type findingcontrolhistoryPager struct {
	reverse bool
	order   *FindingControlHistoryOrder
	filter  func(*FindingControlHistoryQuery) (*FindingControlHistoryQuery, error)
}

func newFindingControlHistoryPager(opts []FindingControlHistoryPaginateOption, reverse bool) (*findingcontrolhistoryPager, error) {
	pager := &findingcontrolhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFindingControlHistoryOrder
	}
	return pager, nil
}

func (p *findingcontrolhistoryPager) applyFilter(query *FindingControlHistoryQuery) (*FindingControlHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *findingcontrolhistoryPager) toCursor(_m *FindingControlHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *findingcontrolhistoryPager) applyCursors(query *FindingControlHistoryQuery, after, before *Cursor) (*FindingControlHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFindingControlHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *findingcontrolhistoryPager) applyOrder(query *FindingControlHistoryQuery) *FindingControlHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFindingControlHistoryOrder.Field {
		query = query.Order(DefaultFindingControlHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *findingcontrolhistoryPager) orderExpr(query *FindingControlHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFindingControlHistoryOrder.Field {
			b.Comma().Ident(DefaultFindingControlHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FindingControlHistory.
func (_m *FindingControlHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FindingControlHistoryPaginateOption,
) (*FindingControlHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFindingControlHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &FindingControlHistoryConnection{Edges: []*FindingControlHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FindingControlHistoryOrderFieldHistoryTime orders FindingControlHistory by history_time.
	FindingControlHistoryOrderFieldHistoryTime = &FindingControlHistoryOrderField{
		Value: func(_m *FindingControlHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: findingcontrolhistory.FieldHistoryTime,
		toTerm: findingcontrolhistory.ByHistoryTime,
		toCursor: func(_m *FindingControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// FindingControlHistoryOrderFieldCreatedAt orders FindingControlHistory by created_at.
	FindingControlHistoryOrderFieldCreatedAt = &FindingControlHistoryOrderField{
		Value: func(_m *FindingControlHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: findingcontrolhistory.FieldCreatedAt,
		toTerm: findingcontrolhistory.ByCreatedAt,
		toCursor: func(_m *FindingControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// FindingControlHistoryOrderFieldUpdatedAt orders FindingControlHistory by updated_at.
	FindingControlHistoryOrderFieldUpdatedAt = &FindingControlHistoryOrderField{
		Value: func(_m *FindingControlHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: findingcontrolhistory.FieldUpdatedAt,
		toTerm: findingcontrolhistory.ByUpdatedAt,
		toCursor: func(_m *FindingControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FindingControlHistoryOrderField) String() string {
	var str string
	switch f.column {
	case FindingControlHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case FindingControlHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case FindingControlHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FindingControlHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FindingControlHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FindingControlHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *FindingControlHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *FindingControlHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *FindingControlHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid FindingControlHistoryOrderField", str)
	}
	return nil
}

// FindingControlHistoryOrderField defines the ordering field of FindingControlHistory.
type FindingControlHistoryOrderField struct {
	// Value extracts the ordering value from the given FindingControlHistory.
	Value    func(*FindingControlHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) findingcontrolhistory.OrderOption
	toCursor func(*FindingControlHistory) Cursor
}

// FindingControlHistoryOrder defines the ordering of FindingControlHistory.
type FindingControlHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *FindingControlHistoryOrderField `json:"field"`
}

// DefaultFindingControlHistoryOrder is the default ordering of FindingControlHistory.
var DefaultFindingControlHistoryOrder = &FindingControlHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FindingControlHistoryOrderField{
		Value: func(_m *FindingControlHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: findingcontrolhistory.FieldID,
		toTerm: findingcontrolhistory.ByID,
		toCursor: func(_m *FindingControlHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts FindingControlHistory into FindingControlHistoryEdge.
func (_m *FindingControlHistory) ToEdge(order *FindingControlHistoryOrder) *FindingControlHistoryEdge {
	if order == nil {
		order = DefaultFindingControlHistoryOrder
	}
	return &FindingControlHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// FindingHistoryEdge is the edge representation of FindingHistory.
type FindingHistoryEdge struct {
	Node   *FindingHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// FindingHistoryConnection is the connection containing edges to FindingHistory.
type FindingHistoryConnection struct {
	Edges      []*FindingHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *FindingHistoryConnection) build(nodes []*FindingHistory, pager *findinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *FindingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FindingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FindingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*FindingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FindingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FindingHistoryPaginateOption enables pagination customization.
type FindingHistoryPaginateOption func(*findinghistoryPager) error

// WithFindingHistoryOrder configures pagination ordering.
func WithFindingHistoryOrder(order *FindingHistoryOrder) FindingHistoryPaginateOption {
	if order == nil {
		order = DefaultFindingHistoryOrder
	}
	o := *order
	return func(pager *findinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFindingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFindingHistoryFilter configures pagination filter.
func WithFindingHistoryFilter(filter func(*FindingHistoryQuery) (*FindingHistoryQuery, error)) FindingHistoryPaginateOption {
	return func(pager *findinghistoryPager) error {
		if filter == nil {
			return errors.New("FindingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type findinghistoryPager struct {
	reverse bool
	order   *FindingHistoryOrder
	filter  func(*FindingHistoryQuery) (*FindingHistoryQuery, error)
}

func newFindingHistoryPager(opts []FindingHistoryPaginateOption, reverse bool) (*findinghistoryPager, error) {
	pager := &findinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFindingHistoryOrder
	}
	return pager, nil
}

func (p *findinghistoryPager) applyFilter(query *FindingHistoryQuery) (*FindingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *findinghistoryPager) toCursor(_m *FindingHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *findinghistoryPager) applyCursors(query *FindingHistoryQuery, after, before *Cursor) (*FindingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFindingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *findinghistoryPager) applyOrder(query *FindingHistoryQuery) *FindingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFindingHistoryOrder.Field {
		query = query.Order(DefaultFindingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *findinghistoryPager) orderExpr(query *FindingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFindingHistoryOrder.Field {
			b.Comma().Ident(DefaultFindingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FindingHistory.
func (_m *FindingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FindingHistoryPaginateOption,
) (*FindingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFindingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &FindingHistoryConnection{Edges: []*FindingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FindingHistoryOrderFieldHistoryTime orders FindingHistory by history_time.
	FindingHistoryOrderFieldHistoryTime = &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: findinghistory.FieldHistoryTime,
		toTerm: findinghistory.ByHistoryTime,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// FindingHistoryOrderFieldCreatedAt orders FindingHistory by created_at.
	FindingHistoryOrderFieldCreatedAt = &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: findinghistory.FieldCreatedAt,
		toTerm: findinghistory.ByCreatedAt,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// FindingHistoryOrderFieldUpdatedAt orders FindingHistory by updated_at.
	FindingHistoryOrderFieldUpdatedAt = &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: findinghistory.FieldUpdatedAt,
		toTerm: findinghistory.ByUpdatedAt,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// FindingHistoryOrderFieldExternalID orders FindingHistory by external_id.
	FindingHistoryOrderFieldExternalID = &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: findinghistory.FieldExternalID,
		toTerm: findinghistory.ByExternalID,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// FindingHistoryOrderFieldExternalOwnerID orders FindingHistory by external_owner_id.
	FindingHistoryOrderFieldExternalOwnerID = &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: findinghistory.FieldExternalOwnerID,
		toTerm: findinghistory.ByExternalOwnerID,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// FindingHistoryOrderFieldCategory orders FindingHistory by category.
	FindingHistoryOrderFieldCategory = &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.Category, nil
		},
		column: findinghistory.FieldCategory,
		toTerm: findinghistory.ByCategory,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// FindingHistoryOrderFieldSeverity orders FindingHistory by severity.
	FindingHistoryOrderFieldSeverity = &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.Severity, nil
		},
		column: findinghistory.FieldSeverity,
		toTerm: findinghistory.BySeverity,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Severity,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FindingHistoryOrderField) String() string {
	var str string
	switch f.column {
	case FindingHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case FindingHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case FindingHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case FindingHistoryOrderFieldExternalID.column:
		str = "external_id"
	case FindingHistoryOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case FindingHistoryOrderFieldCategory.column:
		str = "category"
	case FindingHistoryOrderFieldSeverity.column:
		str = "severity"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FindingHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FindingHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FindingHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *FindingHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *FindingHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *FindingHistoryOrderFieldUpdatedAt
	case "external_id":
		*f = *FindingHistoryOrderFieldExternalID
	case "external_owner_id":
		*f = *FindingHistoryOrderFieldExternalOwnerID
	case "category":
		*f = *FindingHistoryOrderFieldCategory
	case "severity":
		*f = *FindingHistoryOrderFieldSeverity
	default:
		return fmt.Errorf("%s is not a valid FindingHistoryOrderField", str)
	}
	return nil
}

// FindingHistoryOrderField defines the ordering field of FindingHistory.
type FindingHistoryOrderField struct {
	// Value extracts the ordering value from the given FindingHistory.
	Value    func(*FindingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) findinghistory.OrderOption
	toCursor func(*FindingHistory) Cursor
}

// FindingHistoryOrder defines the ordering of FindingHistory.
type FindingHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *FindingHistoryOrderField `json:"field"`
}

// DefaultFindingHistoryOrder is the default ordering of FindingHistory.
var DefaultFindingHistoryOrder = &FindingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: findinghistory.FieldID,
		toTerm: findinghistory.ByID,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts FindingHistory into FindingHistoryEdge.
func (_m *FindingHistory) ToEdge(order *FindingHistoryOrder) *FindingHistoryEdge {
	if order == nil {
		order = DefaultFindingHistoryOrder
	}
	return &FindingHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// GroupHistoryEdge is the edge representation of GroupHistory.
type GroupHistoryEdge struct {
	Node   *GroupHistory `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// GroupHistoryConnection is the connection containing edges to GroupHistory.
type GroupHistoryConnection struct {
	Edges      []*GroupHistoryEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *GroupHistoryConnection) build(nodes []*GroupHistory, pager *grouphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *GroupHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupHistoryPaginateOption enables pagination customization.
type GroupHistoryPaginateOption func(*grouphistoryPager) error

// WithGroupHistoryOrder configures pagination ordering.
func WithGroupHistoryOrder(order *GroupHistoryOrder) GroupHistoryPaginateOption {
	if order == nil {
		order = DefaultGroupHistoryOrder
	}
	o := *order
	return func(pager *grouphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupHistoryFilter configures pagination filter.
func WithGroupHistoryFilter(filter func(*GroupHistoryQuery) (*GroupHistoryQuery, error)) GroupHistoryPaginateOption {
	return func(pager *grouphistoryPager) error {
		if filter == nil {
			return errors.New("GroupHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type grouphistoryPager struct {
	reverse bool
	order   *GroupHistoryOrder
	filter  func(*GroupHistoryQuery) (*GroupHistoryQuery, error)
}

func newGroupHistoryPager(opts []GroupHistoryPaginateOption, reverse bool) (*grouphistoryPager, error) {
	pager := &grouphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupHistoryOrder
	}
	return pager, nil
}

func (p *grouphistoryPager) applyFilter(query *GroupHistoryQuery) (*GroupHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *grouphistoryPager) toCursor(_m *GroupHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *grouphistoryPager) applyCursors(query *GroupHistoryQuery, after, before *Cursor) (*GroupHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *grouphistoryPager) applyOrder(query *GroupHistoryQuery) *GroupHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupHistoryOrder.Field {
		query = query.Order(DefaultGroupHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *grouphistoryPager) orderExpr(query *GroupHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupHistoryOrder.Field {
			b.Comma().Ident(DefaultGroupHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupHistory.
func (_m *GroupHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupHistoryPaginateOption,
) (*GroupHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &GroupHistoryConnection{Edges: []*GroupHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupHistoryOrderFieldHistoryTime orders GroupHistory by history_time.
	GroupHistoryOrderFieldHistoryTime = &GroupHistoryOrderField{
		Value: func(_m *GroupHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: grouphistory.FieldHistoryTime,
		toTerm: grouphistory.ByHistoryTime,
		toCursor: func(_m *GroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// GroupHistoryOrderFieldCreatedAt orders GroupHistory by created_at.
	GroupHistoryOrderFieldCreatedAt = &GroupHistoryOrderField{
		Value: func(_m *GroupHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: grouphistory.FieldCreatedAt,
		toTerm: grouphistory.ByCreatedAt,
		toCursor: func(_m *GroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// GroupHistoryOrderFieldUpdatedAt orders GroupHistory by updated_at.
	GroupHistoryOrderFieldUpdatedAt = &GroupHistoryOrderField{
		Value: func(_m *GroupHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: grouphistory.FieldUpdatedAt,
		toTerm: grouphistory.ByUpdatedAt,
		toCursor: func(_m *GroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// GroupHistoryOrderFieldName orders GroupHistory by name.
	GroupHistoryOrderFieldName = &GroupHistoryOrderField{
		Value: func(_m *GroupHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: grouphistory.FieldName,
		toTerm: grouphistory.ByName,
		toCursor: func(_m *GroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// GroupHistoryOrderFieldDisplayName orders GroupHistory by display_name.
	GroupHistoryOrderFieldDisplayName = &GroupHistoryOrderField{
		Value: func(_m *GroupHistory) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: grouphistory.FieldDisplayName,
		toTerm: grouphistory.ByDisplayName,
		toCursor: func(_m *GroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupHistoryOrderField) String() string {
	var str string
	switch f.column {
	case GroupHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case GroupHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case GroupHistoryOrderFieldName.column:
		str = "name"
	case GroupHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *GroupHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *GroupHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupHistoryOrderFieldUpdatedAt
	case "name":
		*f = *GroupHistoryOrderFieldName
	case "display_name":
		*f = *GroupHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid GroupHistoryOrderField", str)
	}
	return nil
}

// GroupHistoryOrderField defines the ordering field of GroupHistory.
type GroupHistoryOrderField struct {
	// Value extracts the ordering value from the given GroupHistory.
	Value    func(*GroupHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) grouphistory.OrderOption
	toCursor func(*GroupHistory) Cursor
}

// GroupHistoryOrder defines the ordering of GroupHistory.
type GroupHistoryOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *GroupHistoryOrderField `json:"field"`
}

// DefaultGroupHistoryOrder is the default ordering of GroupHistory.
var DefaultGroupHistoryOrder = &GroupHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupHistoryOrderField{
		Value: func(_m *GroupHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: grouphistory.FieldID,
		toTerm: grouphistory.ByID,
		toCursor: func(_m *GroupHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts GroupHistory into GroupHistoryEdge.
func (_m *GroupHistory) ToEdge(order *GroupHistoryOrder) *GroupHistoryEdge {
	if order == nil {
		order = DefaultGroupHistoryOrder
	}
	return &GroupHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// GroupMembershipHistoryEdge is the edge representation of GroupMembershipHistory.
type GroupMembershipHistoryEdge struct {
	Node   *GroupMembershipHistory `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// GroupMembershipHistoryConnection is the connection containing edges to GroupMembershipHistory.
type GroupMembershipHistoryConnection struct {
	Edges      []*GroupMembershipHistoryEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *GroupMembershipHistoryConnection) build(nodes []*GroupMembershipHistory, pager *groupmembershiphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *GroupMembershipHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupMembershipHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupMembershipHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupMembershipHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupMembershipHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupMembershipHistoryPaginateOption enables pagination customization.
type GroupMembershipHistoryPaginateOption func(*groupmembershiphistoryPager) error

// WithGroupMembershipHistoryOrder configures pagination ordering.
func WithGroupMembershipHistoryOrder(order *GroupMembershipHistoryOrder) GroupMembershipHistoryPaginateOption {
	if order == nil {
		order = DefaultGroupMembershipHistoryOrder
	}
	o := *order
	return func(pager *groupmembershiphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupMembershipHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupMembershipHistoryFilter configures pagination filter.
func WithGroupMembershipHistoryFilter(filter func(*GroupMembershipHistoryQuery) (*GroupMembershipHistoryQuery, error)) GroupMembershipHistoryPaginateOption {
	return func(pager *groupmembershiphistoryPager) error {
		if filter == nil {
			return errors.New("GroupMembershipHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupmembershiphistoryPager struct {
	reverse bool
	order   *GroupMembershipHistoryOrder
	filter  func(*GroupMembershipHistoryQuery) (*GroupMembershipHistoryQuery, error)
}

func newGroupMembershipHistoryPager(opts []GroupMembershipHistoryPaginateOption, reverse bool) (*groupmembershiphistoryPager, error) {
	pager := &groupmembershiphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupMembershipHistoryOrder
	}
	return pager, nil
}

func (p *groupmembershiphistoryPager) applyFilter(query *GroupMembershipHistoryQuery) (*GroupMembershipHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupmembershiphistoryPager) toCursor(_m *GroupMembershipHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *groupmembershiphistoryPager) applyCursors(query *GroupMembershipHistoryQuery, after, before *Cursor) (*GroupMembershipHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupMembershipHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupmembershiphistoryPager) applyOrder(query *GroupMembershipHistoryQuery) *GroupMembershipHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupMembershipHistoryOrder.Field {
		query = query.Order(DefaultGroupMembershipHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *groupmembershiphistoryPager) orderExpr(query *GroupMembershipHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupMembershipHistoryOrder.Field {
			b.Comma().Ident(DefaultGroupMembershipHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupMembershipHistory.
func (_m *GroupMembershipHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupMembershipHistoryPaginateOption,
) (*GroupMembershipHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupMembershipHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &GroupMembershipHistoryConnection{Edges: []*GroupMembershipHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupMembershipHistoryOrderFieldHistoryTime orders GroupMembershipHistory by history_time.
	GroupMembershipHistoryOrderFieldHistoryTime = &GroupMembershipHistoryOrderField{
		Value: func(_m *GroupMembershipHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: groupmembershiphistory.FieldHistoryTime,
		toTerm: groupmembershiphistory.ByHistoryTime,
		toCursor: func(_m *GroupMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// GroupMembershipHistoryOrderFieldCreatedAt orders GroupMembershipHistory by created_at.
	GroupMembershipHistoryOrderFieldCreatedAt = &GroupMembershipHistoryOrderField{
		Value: func(_m *GroupMembershipHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: groupmembershiphistory.FieldCreatedAt,
		toTerm: groupmembershiphistory.ByCreatedAt,
		toCursor: func(_m *GroupMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// GroupMembershipHistoryOrderFieldUpdatedAt orders GroupMembershipHistory by updated_at.
	GroupMembershipHistoryOrderFieldUpdatedAt = &GroupMembershipHistoryOrderField{
		Value: func(_m *GroupMembershipHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: groupmembershiphistory.FieldUpdatedAt,
		toTerm: groupmembershiphistory.ByUpdatedAt,
		toCursor: func(_m *GroupMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// GroupMembershipHistoryOrderFieldRole orders GroupMembershipHistory by role.
	GroupMembershipHistoryOrderFieldRole = &GroupMembershipHistoryOrderField{
		Value: func(_m *GroupMembershipHistory) (ent.Value, error) {
			return _m.Role, nil
		},
		column: groupmembershiphistory.FieldRole,
		toTerm: groupmembershiphistory.ByRole,
		toCursor: func(_m *GroupMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupMembershipHistoryOrderField) String() string {
	var str string
	switch f.column {
	case GroupMembershipHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case GroupMembershipHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupMembershipHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case GroupMembershipHistoryOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupMembershipHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupMembershipHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *GroupMembershipHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *GroupMembershipHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupMembershipHistoryOrderFieldUpdatedAt
	case "ROLE":
		*f = *GroupMembershipHistoryOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid GroupMembershipHistoryOrderField", str)
	}
	return nil
}

// GroupMembershipHistoryOrderField defines the ordering field of GroupMembershipHistory.
type GroupMembershipHistoryOrderField struct {
	// Value extracts the ordering value from the given GroupMembershipHistory.
	Value    func(*GroupMembershipHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupmembershiphistory.OrderOption
	toCursor func(*GroupMembershipHistory) Cursor
}

// GroupMembershipHistoryOrder defines the ordering of GroupMembershipHistory.
type GroupMembershipHistoryOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *GroupMembershipHistoryOrderField `json:"field"`
}

// DefaultGroupMembershipHistoryOrder is the default ordering of GroupMembershipHistory.
var DefaultGroupMembershipHistoryOrder = &GroupMembershipHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupMembershipHistoryOrderField{
		Value: func(_m *GroupMembershipHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: groupmembershiphistory.FieldID,
		toTerm: groupmembershiphistory.ByID,
		toCursor: func(_m *GroupMembershipHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts GroupMembershipHistory into GroupMembershipHistoryEdge.
func (_m *GroupMembershipHistory) ToEdge(order *GroupMembershipHistoryOrder) *GroupMembershipHistoryEdge {
	if order == nil {
		order = DefaultGroupMembershipHistoryOrder
	}
	return &GroupMembershipHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// GroupSettingHistoryEdge is the edge representation of GroupSettingHistory.
type GroupSettingHistoryEdge struct {
	Node   *GroupSettingHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// GroupSettingHistoryConnection is the connection containing edges to GroupSettingHistory.
type GroupSettingHistoryConnection struct {
	Edges      []*GroupSettingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *GroupSettingHistoryConnection) build(nodes []*GroupSettingHistory, pager *groupsettinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *GroupSettingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupSettingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupSettingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupSettingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupSettingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupSettingHistoryPaginateOption enables pagination customization.
type GroupSettingHistoryPaginateOption func(*groupsettinghistoryPager) error

// WithGroupSettingHistoryOrder configures pagination ordering.
func WithGroupSettingHistoryOrder(order *GroupSettingHistoryOrder) GroupSettingHistoryPaginateOption {
	if order == nil {
		order = DefaultGroupSettingHistoryOrder
	}
	o := *order
	return func(pager *groupsettinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupSettingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupSettingHistoryFilter configures pagination filter.
func WithGroupSettingHistoryFilter(filter func(*GroupSettingHistoryQuery) (*GroupSettingHistoryQuery, error)) GroupSettingHistoryPaginateOption {
	return func(pager *groupsettinghistoryPager) error {
		if filter == nil {
			return errors.New("GroupSettingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupsettinghistoryPager struct {
	reverse bool
	order   *GroupSettingHistoryOrder
	filter  func(*GroupSettingHistoryQuery) (*GroupSettingHistoryQuery, error)
}

func newGroupSettingHistoryPager(opts []GroupSettingHistoryPaginateOption, reverse bool) (*groupsettinghistoryPager, error) {
	pager := &groupsettinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupSettingHistoryOrder
	}
	return pager, nil
}

func (p *groupsettinghistoryPager) applyFilter(query *GroupSettingHistoryQuery) (*GroupSettingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupsettinghistoryPager) toCursor(_m *GroupSettingHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *groupsettinghistoryPager) applyCursors(query *GroupSettingHistoryQuery, after, before *Cursor) (*GroupSettingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupSettingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupsettinghistoryPager) applyOrder(query *GroupSettingHistoryQuery) *GroupSettingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupSettingHistoryOrder.Field {
		query = query.Order(DefaultGroupSettingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *groupsettinghistoryPager) orderExpr(query *GroupSettingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupSettingHistoryOrder.Field {
			b.Comma().Ident(DefaultGroupSettingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupSettingHistory.
func (_m *GroupSettingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupSettingHistoryPaginateOption,
) (*GroupSettingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupSettingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &GroupSettingHistoryConnection{Edges: []*GroupSettingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupSettingHistoryOrderFieldHistoryTime orders GroupSettingHistory by history_time.
	GroupSettingHistoryOrderFieldHistoryTime = &GroupSettingHistoryOrderField{
		Value: func(_m *GroupSettingHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: groupsettinghistory.FieldHistoryTime,
		toTerm: groupsettinghistory.ByHistoryTime,
		toCursor: func(_m *GroupSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// GroupSettingHistoryOrderFieldCreatedAt orders GroupSettingHistory by created_at.
	GroupSettingHistoryOrderFieldCreatedAt = &GroupSettingHistoryOrderField{
		Value: func(_m *GroupSettingHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: groupsettinghistory.FieldCreatedAt,
		toTerm: groupsettinghistory.ByCreatedAt,
		toCursor: func(_m *GroupSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// GroupSettingHistoryOrderFieldUpdatedAt orders GroupSettingHistory by updated_at.
	GroupSettingHistoryOrderFieldUpdatedAt = &GroupSettingHistoryOrderField{
		Value: func(_m *GroupSettingHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: groupsettinghistory.FieldUpdatedAt,
		toTerm: groupsettinghistory.ByUpdatedAt,
		toCursor: func(_m *GroupSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupSettingHistoryOrderField) String() string {
	var str string
	switch f.column {
	case GroupSettingHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case GroupSettingHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupSettingHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupSettingHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupSettingHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *GroupSettingHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *GroupSettingHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupSettingHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid GroupSettingHistoryOrderField", str)
	}
	return nil
}

// GroupSettingHistoryOrderField defines the ordering field of GroupSettingHistory.
type GroupSettingHistoryOrderField struct {
	// Value extracts the ordering value from the given GroupSettingHistory.
	Value    func(*GroupSettingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupsettinghistory.OrderOption
	toCursor func(*GroupSettingHistory) Cursor
}

// GroupSettingHistoryOrder defines the ordering of GroupSettingHistory.
type GroupSettingHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *GroupSettingHistoryOrderField `json:"field"`
}

// DefaultGroupSettingHistoryOrder is the default ordering of GroupSettingHistory.
var DefaultGroupSettingHistoryOrder = &GroupSettingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupSettingHistoryOrderField{
		Value: func(_m *GroupSettingHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: groupsettinghistory.FieldID,
		toTerm: groupsettinghistory.ByID,
		toCursor: func(_m *GroupSettingHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts GroupSettingHistory into GroupSettingHistoryEdge.
func (_m *GroupSettingHistory) ToEdge(order *GroupSettingHistoryOrder) *GroupSettingHistoryEdge {
	if order == nil {
		order = DefaultGroupSettingHistoryOrder
	}
	return &GroupSettingHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// HushHistoryEdge is the edge representation of HushHistory.
type HushHistoryEdge struct {
	Node   *HushHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// HushHistoryConnection is the connection containing edges to HushHistory.
type HushHistoryConnection struct {
	Edges      []*HushHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *HushHistoryConnection) build(nodes []*HushHistory, pager *hushhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *HushHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HushHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HushHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*HushHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HushHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HushHistoryPaginateOption enables pagination customization.
type HushHistoryPaginateOption func(*hushhistoryPager) error

// WithHushHistoryOrder configures pagination ordering.
func WithHushHistoryOrder(order *HushHistoryOrder) HushHistoryPaginateOption {
	if order == nil {
		order = DefaultHushHistoryOrder
	}
	o := *order
	return func(pager *hushhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHushHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHushHistoryFilter configures pagination filter.
func WithHushHistoryFilter(filter func(*HushHistoryQuery) (*HushHistoryQuery, error)) HushHistoryPaginateOption {
	return func(pager *hushhistoryPager) error {
		if filter == nil {
			return errors.New("HushHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hushhistoryPager struct {
	reverse bool
	order   *HushHistoryOrder
	filter  func(*HushHistoryQuery) (*HushHistoryQuery, error)
}

func newHushHistoryPager(opts []HushHistoryPaginateOption, reverse bool) (*hushhistoryPager, error) {
	pager := &hushhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHushHistoryOrder
	}
	return pager, nil
}

func (p *hushhistoryPager) applyFilter(query *HushHistoryQuery) (*HushHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hushhistoryPager) toCursor(_m *HushHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *hushhistoryPager) applyCursors(query *HushHistoryQuery, after, before *Cursor) (*HushHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHushHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hushhistoryPager) applyOrder(query *HushHistoryQuery) *HushHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHushHistoryOrder.Field {
		query = query.Order(DefaultHushHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *hushhistoryPager) orderExpr(query *HushHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHushHistoryOrder.Field {
			b.Comma().Ident(DefaultHushHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HushHistory.
func (_m *HushHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HushHistoryPaginateOption,
) (*HushHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHushHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &HushHistoryConnection{Edges: []*HushHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HushHistoryOrderFieldHistoryTime orders HushHistory by history_time.
	HushHistoryOrderFieldHistoryTime = &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: hushhistory.FieldHistoryTime,
		toTerm: hushhistory.ByHistoryTime,
		toCursor: func(_m *HushHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// HushHistoryOrderFieldCreatedAt orders HushHistory by created_at.
	HushHistoryOrderFieldCreatedAt = &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: hushhistory.FieldCreatedAt,
		toTerm: hushhistory.ByCreatedAt,
		toCursor: func(_m *HushHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// HushHistoryOrderFieldUpdatedAt orders HushHistory by updated_at.
	HushHistoryOrderFieldUpdatedAt = &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: hushhistory.FieldUpdatedAt,
		toTerm: hushhistory.ByUpdatedAt,
		toCursor: func(_m *HushHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// HushHistoryOrderFieldName orders HushHistory by name.
	HushHistoryOrderFieldName = &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: hushhistory.FieldName,
		toTerm: hushhistory.ByName,
		toCursor: func(_m *HushHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// HushHistoryOrderFieldKind orders HushHistory by kind.
	HushHistoryOrderFieldKind = &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			return _m.Kind, nil
		},
		column: hushhistory.FieldKind,
		toTerm: hushhistory.ByKind,
		toCursor: func(_m *HushHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Kind,
			}
		},
	}
	// HushHistoryOrderFieldLastUsedAt orders HushHistory by last_used_at.
	HushHistoryOrderFieldLastUsedAt = &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastUsedAt == nil {
				return nil, nil
			}
			return _m.LastUsedAt, nil
		},
		column: hushhistory.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) hushhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return hushhistory.ByLastUsedAt(opts...)
		},
		toCursor: func(_m *HushHistory) Cursor {
			if _m.LastUsedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastUsedAt,
			}
		},
	}
	// HushHistoryOrderFieldExpiresAt orders HushHistory by expires_at.
	HushHistoryOrderFieldExpiresAt = &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExpiresAt == nil {
				return nil, nil
			}
			return _m.ExpiresAt, nil
		},
		column: hushhistory.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) hushhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return hushhistory.ByExpiresAt(opts...)
		},
		toCursor: func(_m *HushHistory) Cursor {
			if _m.ExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExpiresAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HushHistoryOrderField) String() string {
	var str string
	switch f.column {
	case HushHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case HushHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case HushHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case HushHistoryOrderFieldName.column:
		str = "name"
	case HushHistoryOrderFieldKind.column:
		str = "kind"
	case HushHistoryOrderFieldLastUsedAt.column:
		str = "last_used_at"
	case HushHistoryOrderFieldExpiresAt.column:
		str = "expires_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HushHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HushHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HushHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *HushHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *HushHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *HushHistoryOrderFieldUpdatedAt
	case "name":
		*f = *HushHistoryOrderFieldName
	case "kind":
		*f = *HushHistoryOrderFieldKind
	case "last_used_at":
		*f = *HushHistoryOrderFieldLastUsedAt
	case "expires_at":
		*f = *HushHistoryOrderFieldExpiresAt
	default:
		return fmt.Errorf("%s is not a valid HushHistoryOrderField", str)
	}
	return nil
}

// HushHistoryOrderField defines the ordering field of HushHistory.
type HushHistoryOrderField struct {
	// Value extracts the ordering value from the given HushHistory.
	Value    func(*HushHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hushhistory.OrderOption
	toCursor func(*HushHistory) Cursor
}

// HushHistoryOrder defines the ordering of HushHistory.
type HushHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *HushHistoryOrderField `json:"field"`
}

// DefaultHushHistoryOrder is the default ordering of HushHistory.
var DefaultHushHistoryOrder = &HushHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: hushhistory.FieldID,
		toTerm: hushhistory.ByID,
		toCursor: func(_m *HushHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts HushHistory into HushHistoryEdge.
func (_m *HushHistory) ToEdge(order *HushHistoryOrder) *HushHistoryEdge {
	if order == nil {
		order = DefaultHushHistoryOrder
	}
	return &HushHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// IdentityHolderHistoryEdge is the edge representation of IdentityHolderHistory.
type IdentityHolderHistoryEdge struct {
	Node   *IdentityHolderHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// IdentityHolderHistoryConnection is the connection containing edges to IdentityHolderHistory.
type IdentityHolderHistoryConnection struct {
	Edges      []*IdentityHolderHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *IdentityHolderHistoryConnection) build(nodes []*IdentityHolderHistory, pager *identityholderhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *IdentityHolderHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *IdentityHolderHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *IdentityHolderHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*IdentityHolderHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IdentityHolderHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IdentityHolderHistoryPaginateOption enables pagination customization.
type IdentityHolderHistoryPaginateOption func(*identityholderhistoryPager) error

// WithIdentityHolderHistoryOrder configures pagination ordering.
func WithIdentityHolderHistoryOrder(order *IdentityHolderHistoryOrder) IdentityHolderHistoryPaginateOption {
	if order == nil {
		order = DefaultIdentityHolderHistoryOrder
	}
	o := *order
	return func(pager *identityholderhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultIdentityHolderHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithIdentityHolderHistoryFilter configures pagination filter.
func WithIdentityHolderHistoryFilter(filter func(*IdentityHolderHistoryQuery) (*IdentityHolderHistoryQuery, error)) IdentityHolderHistoryPaginateOption {
	return func(pager *identityholderhistoryPager) error {
		if filter == nil {
			return errors.New("IdentityHolderHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type identityholderhistoryPager struct {
	reverse bool
	order   *IdentityHolderHistoryOrder
	filter  func(*IdentityHolderHistoryQuery) (*IdentityHolderHistoryQuery, error)
}

func newIdentityHolderHistoryPager(opts []IdentityHolderHistoryPaginateOption, reverse bool) (*identityholderhistoryPager, error) {
	pager := &identityholderhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultIdentityHolderHistoryOrder
	}
	return pager, nil
}

func (p *identityholderhistoryPager) applyFilter(query *IdentityHolderHistoryQuery) (*IdentityHolderHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *identityholderhistoryPager) toCursor(_m *IdentityHolderHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *identityholderhistoryPager) applyCursors(query *IdentityHolderHistoryQuery, after, before *Cursor) (*IdentityHolderHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultIdentityHolderHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *identityholderhistoryPager) applyOrder(query *IdentityHolderHistoryQuery) *IdentityHolderHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultIdentityHolderHistoryOrder.Field {
		query = query.Order(DefaultIdentityHolderHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *identityholderhistoryPager) orderExpr(query *IdentityHolderHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultIdentityHolderHistoryOrder.Field {
			b.Comma().Ident(DefaultIdentityHolderHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to IdentityHolderHistory.
func (_m *IdentityHolderHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IdentityHolderHistoryPaginateOption,
) (*IdentityHolderHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIdentityHolderHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &IdentityHolderHistoryConnection{Edges: []*IdentityHolderHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// IdentityHolderHistoryOrderFieldHistoryTime orders IdentityHolderHistory by history_time.
	IdentityHolderHistoryOrderFieldHistoryTime = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: identityholderhistory.FieldHistoryTime,
		toTerm: identityholderhistory.ByHistoryTime,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldCreatedAt orders IdentityHolderHistory by created_at.
	IdentityHolderHistoryOrderFieldCreatedAt = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: identityholderhistory.FieldCreatedAt,
		toTerm: identityholderhistory.ByCreatedAt,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldUpdatedAt orders IdentityHolderHistory by updated_at.
	IdentityHolderHistoryOrderFieldUpdatedAt = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: identityholderhistory.FieldUpdatedAt,
		toTerm: identityholderhistory.ByUpdatedAt,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldInternalOwner orders IdentityHolderHistory by internal_owner.
	IdentityHolderHistoryOrderFieldInternalOwner = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.InternalOwner, nil
		},
		column: identityholderhistory.FieldInternalOwner,
		toTerm: identityholderhistory.ByInternalOwner,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.InternalOwner,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldFullName orders IdentityHolderHistory by full_name.
	IdentityHolderHistoryOrderFieldFullName = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.FullName, nil
		},
		column: identityholderhistory.FieldFullName,
		toTerm: identityholderhistory.ByFullName,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FullName,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldEmail orders IdentityHolderHistory by email.
	IdentityHolderHistoryOrderFieldEmail = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.Email, nil
		},
		column: identityholderhistory.FieldEmail,
		toTerm: identityholderhistory.ByEmail,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldAlternateEmail orders IdentityHolderHistory by alternate_email.
	IdentityHolderHistoryOrderFieldAlternateEmail = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.AlternateEmail, nil
		},
		column: identityholderhistory.FieldAlternateEmail,
		toTerm: identityholderhistory.ByAlternateEmail,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.AlternateEmail,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldIsOpenlaneUser orders IdentityHolderHistory by is_openlane_user.
	IdentityHolderHistoryOrderFieldIsOpenlaneUser = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.IsOpenlaneUser, nil
		},
		column: identityholderhistory.FieldIsOpenlaneUser,
		toTerm: identityholderhistory.ByIsOpenlaneUser,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.IsOpenlaneUser,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldIdentityHolderType orders IdentityHolderHistory by identity_holder_type.
	IdentityHolderHistoryOrderFieldIdentityHolderType = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.IdentityHolderType, nil
		},
		column: identityholderhistory.FieldIdentityHolderType,
		toTerm: identityholderhistory.ByIdentityHolderType,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.IdentityHolderType,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldStatus orders IdentityHolderHistory by status.
	IdentityHolderHistoryOrderFieldStatus = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: identityholderhistory.FieldStatus,
		toTerm: identityholderhistory.ByStatus,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldIsActive orders IdentityHolderHistory by is_active.
	IdentityHolderHistoryOrderFieldIsActive = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.IsActive, nil
		},
		column: identityholderhistory.FieldIsActive,
		toTerm: identityholderhistory.ByIsActive,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.IsActive,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldTitle orders IdentityHolderHistory by title.
	IdentityHolderHistoryOrderFieldTitle = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: identityholderhistory.FieldTitle,
		toTerm: identityholderhistory.ByTitle,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldDepartment orders IdentityHolderHistory by department.
	IdentityHolderHistoryOrderFieldDepartment = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.Department, nil
		},
		column: identityholderhistory.FieldDepartment,
		toTerm: identityholderhistory.ByDepartment,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Department,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldTeam orders IdentityHolderHistory by team.
	IdentityHolderHistoryOrderFieldTeam = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.Team, nil
		},
		column: identityholderhistory.FieldTeam,
		toTerm: identityholderhistory.ByTeam,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Team,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldLocation orders IdentityHolderHistory by location.
	IdentityHolderHistoryOrderFieldLocation = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.Location, nil
		},
		column: identityholderhistory.FieldLocation,
		toTerm: identityholderhistory.ByLocation,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Location,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldStartDate orders IdentityHolderHistory by start_date.
	IdentityHolderHistoryOrderFieldStartDate = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.StartDate == nil {
				return nil, nil
			}
			return _m.StartDate, nil
		},
		column: identityholderhistory.FieldStartDate,
		toTerm: func(opts ...sql.OrderTermOption) identityholderhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return identityholderhistory.ByStartDate(opts...)
		},
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			if _m.StartDate == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.StartDate,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldEndDate orders IdentityHolderHistory by end_date.
	IdentityHolderHistoryOrderFieldEndDate = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.EndDate == nil {
				return nil, nil
			}
			return _m.EndDate, nil
		},
		column: identityholderhistory.FieldEndDate,
		toTerm: func(opts ...sql.OrderTermOption) identityholderhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return identityholderhistory.ByEndDate(opts...)
		},
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			if _m.EndDate == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.EndDate,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldExternalUserID orders IdentityHolderHistory by external_user_id.
	IdentityHolderHistoryOrderFieldExternalUserID = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.ExternalUserID, nil
		},
		column: identityholderhistory.FieldExternalUserID,
		toTerm: identityholderhistory.ByExternalUserID,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalUserID,
			}
		},
	}
	// IdentityHolderHistoryOrderFieldExternalReferenceID orders IdentityHolderHistory by external_reference_id.
	IdentityHolderHistoryOrderFieldExternalReferenceID = &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.ExternalReferenceID, nil
		},
		column: identityholderhistory.FieldExternalReferenceID,
		toTerm: identityholderhistory.ByExternalReferenceID,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalReferenceID,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f IdentityHolderHistoryOrderField) String() string {
	var str string
	switch f.column {
	case IdentityHolderHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case IdentityHolderHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case IdentityHolderHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case IdentityHolderHistoryOrderFieldInternalOwner.column:
		str = "internal_owner"
	case IdentityHolderHistoryOrderFieldFullName.column:
		str = "full_name"
	case IdentityHolderHistoryOrderFieldEmail.column:
		str = "email"
	case IdentityHolderHistoryOrderFieldAlternateEmail.column:
		str = "alternate_email"
	case IdentityHolderHistoryOrderFieldIsOpenlaneUser.column:
		str = "is_openlane_user"
	case IdentityHolderHistoryOrderFieldIdentityHolderType.column:
		str = "IDENTITY_HOLDER_TYPE"
	case IdentityHolderHistoryOrderFieldStatus.column:
		str = "STATUS"
	case IdentityHolderHistoryOrderFieldIsActive.column:
		str = "is_active"
	case IdentityHolderHistoryOrderFieldTitle.column:
		str = "title"
	case IdentityHolderHistoryOrderFieldDepartment.column:
		str = "department"
	case IdentityHolderHistoryOrderFieldTeam.column:
		str = "team"
	case IdentityHolderHistoryOrderFieldLocation.column:
		str = "location"
	case IdentityHolderHistoryOrderFieldStartDate.column:
		str = "start_date"
	case IdentityHolderHistoryOrderFieldEndDate.column:
		str = "end_date"
	case IdentityHolderHistoryOrderFieldExternalUserID.column:
		str = "external_user_id"
	case IdentityHolderHistoryOrderFieldExternalReferenceID.column:
		str = "external_reference_id"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f IdentityHolderHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *IdentityHolderHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("IdentityHolderHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *IdentityHolderHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *IdentityHolderHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *IdentityHolderHistoryOrderFieldUpdatedAt
	case "internal_owner":
		*f = *IdentityHolderHistoryOrderFieldInternalOwner
	case "full_name":
		*f = *IdentityHolderHistoryOrderFieldFullName
	case "email":
		*f = *IdentityHolderHistoryOrderFieldEmail
	case "alternate_email":
		*f = *IdentityHolderHistoryOrderFieldAlternateEmail
	case "is_openlane_user":
		*f = *IdentityHolderHistoryOrderFieldIsOpenlaneUser
	case "IDENTITY_HOLDER_TYPE":
		*f = *IdentityHolderHistoryOrderFieldIdentityHolderType
	case "STATUS":
		*f = *IdentityHolderHistoryOrderFieldStatus
	case "is_active":
		*f = *IdentityHolderHistoryOrderFieldIsActive
	case "title":
		*f = *IdentityHolderHistoryOrderFieldTitle
	case "department":
		*f = *IdentityHolderHistoryOrderFieldDepartment
	case "team":
		*f = *IdentityHolderHistoryOrderFieldTeam
	case "location":
		*f = *IdentityHolderHistoryOrderFieldLocation
	case "start_date":
		*f = *IdentityHolderHistoryOrderFieldStartDate
	case "end_date":
		*f = *IdentityHolderHistoryOrderFieldEndDate
	case "external_user_id":
		*f = *IdentityHolderHistoryOrderFieldExternalUserID
	case "external_reference_id":
		*f = *IdentityHolderHistoryOrderFieldExternalReferenceID
	default:
		return fmt.Errorf("%s is not a valid IdentityHolderHistoryOrderField", str)
	}
	return nil
}

// IdentityHolderHistoryOrderField defines the ordering field of IdentityHolderHistory.
type IdentityHolderHistoryOrderField struct {
	// Value extracts the ordering value from the given IdentityHolderHistory.
	Value    func(*IdentityHolderHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) identityholderhistory.OrderOption
	toCursor func(*IdentityHolderHistory) Cursor
}

// IdentityHolderHistoryOrder defines the ordering of IdentityHolderHistory.
type IdentityHolderHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *IdentityHolderHistoryOrderField `json:"field"`
}

// DefaultIdentityHolderHistoryOrder is the default ordering of IdentityHolderHistory.
var DefaultIdentityHolderHistoryOrder = &IdentityHolderHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &IdentityHolderHistoryOrderField{
		Value: func(_m *IdentityHolderHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: identityholderhistory.FieldID,
		toTerm: identityholderhistory.ByID,
		toCursor: func(_m *IdentityHolderHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts IdentityHolderHistory into IdentityHolderHistoryEdge.
func (_m *IdentityHolderHistory) ToEdge(order *IdentityHolderHistoryOrder) *IdentityHolderHistoryEdge {
	if order == nil {
		order = DefaultIdentityHolderHistoryOrder
	}
	return &IdentityHolderHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// IntegrationHistoryEdge is the edge representation of IntegrationHistory.
type IntegrationHistoryEdge struct {
	Node   *IntegrationHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// IntegrationHistoryConnection is the connection containing edges to IntegrationHistory.
type IntegrationHistoryConnection struct {
	Edges      []*IntegrationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *IntegrationHistoryConnection) build(nodes []*IntegrationHistory, pager *integrationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *IntegrationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *IntegrationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *IntegrationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*IntegrationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IntegrationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IntegrationHistoryPaginateOption enables pagination customization.
type IntegrationHistoryPaginateOption func(*integrationhistoryPager) error

// WithIntegrationHistoryOrder configures pagination ordering.
func WithIntegrationHistoryOrder(order *IntegrationHistoryOrder) IntegrationHistoryPaginateOption {
	if order == nil {
		order = DefaultIntegrationHistoryOrder
	}
	o := *order
	return func(pager *integrationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultIntegrationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithIntegrationHistoryFilter configures pagination filter.
func WithIntegrationHistoryFilter(filter func(*IntegrationHistoryQuery) (*IntegrationHistoryQuery, error)) IntegrationHistoryPaginateOption {
	return func(pager *integrationhistoryPager) error {
		if filter == nil {
			return errors.New("IntegrationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type integrationhistoryPager struct {
	reverse bool
	order   *IntegrationHistoryOrder
	filter  func(*IntegrationHistoryQuery) (*IntegrationHistoryQuery, error)
}

func newIntegrationHistoryPager(opts []IntegrationHistoryPaginateOption, reverse bool) (*integrationhistoryPager, error) {
	pager := &integrationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultIntegrationHistoryOrder
	}
	return pager, nil
}

func (p *integrationhistoryPager) applyFilter(query *IntegrationHistoryQuery) (*IntegrationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *integrationhistoryPager) toCursor(_m *IntegrationHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *integrationhistoryPager) applyCursors(query *IntegrationHistoryQuery, after, before *Cursor) (*IntegrationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultIntegrationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *integrationhistoryPager) applyOrder(query *IntegrationHistoryQuery) *IntegrationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultIntegrationHistoryOrder.Field {
		query = query.Order(DefaultIntegrationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *integrationhistoryPager) orderExpr(query *IntegrationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultIntegrationHistoryOrder.Field {
			b.Comma().Ident(DefaultIntegrationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to IntegrationHistory.
func (_m *IntegrationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IntegrationHistoryPaginateOption,
) (*IntegrationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIntegrationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &IntegrationHistoryConnection{Edges: []*IntegrationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// IntegrationHistoryOrderFieldHistoryTime orders IntegrationHistory by history_time.
	IntegrationHistoryOrderFieldHistoryTime = &IntegrationHistoryOrderField{
		Value: func(_m *IntegrationHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: integrationhistory.FieldHistoryTime,
		toTerm: integrationhistory.ByHistoryTime,
		toCursor: func(_m *IntegrationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// IntegrationHistoryOrderFieldCreatedAt orders IntegrationHistory by created_at.
	IntegrationHistoryOrderFieldCreatedAt = &IntegrationHistoryOrderField{
		Value: func(_m *IntegrationHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: integrationhistory.FieldCreatedAt,
		toTerm: integrationhistory.ByCreatedAt,
		toCursor: func(_m *IntegrationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// IntegrationHistoryOrderFieldUpdatedAt orders IntegrationHistory by updated_at.
	IntegrationHistoryOrderFieldUpdatedAt = &IntegrationHistoryOrderField{
		Value: func(_m *IntegrationHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: integrationhistory.FieldUpdatedAt,
		toTerm: integrationhistory.ByUpdatedAt,
		toCursor: func(_m *IntegrationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// IntegrationHistoryOrderFieldName orders IntegrationHistory by name.
	IntegrationHistoryOrderFieldName = &IntegrationHistoryOrderField{
		Value: func(_m *IntegrationHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: integrationhistory.FieldName,
		toTerm: integrationhistory.ByName,
		toCursor: func(_m *IntegrationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// IntegrationHistoryOrderFieldKind orders IntegrationHistory by kind.
	IntegrationHistoryOrderFieldKind = &IntegrationHistoryOrderField{
		Value: func(_m *IntegrationHistory) (ent.Value, error) {
			return _m.Kind, nil
		},
		column: integrationhistory.FieldKind,
		toTerm: integrationhistory.ByKind,
		toCursor: func(_m *IntegrationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Kind,
			}
		},
	}
	// IntegrationHistoryOrderFieldIntegrationType orders IntegrationHistory by integration_type.
	IntegrationHistoryOrderFieldIntegrationType = &IntegrationHistoryOrderField{
		Value: func(_m *IntegrationHistory) (ent.Value, error) {
			return _m.IntegrationType, nil
		},
		column: integrationhistory.FieldIntegrationType,
		toTerm: integrationhistory.ByIntegrationType,
		toCursor: func(_m *IntegrationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.IntegrationType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f IntegrationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case IntegrationHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case IntegrationHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case IntegrationHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case IntegrationHistoryOrderFieldName.column:
		str = "name"
	case IntegrationHistoryOrderFieldKind.column:
		str = "kind"
	case IntegrationHistoryOrderFieldIntegrationType.column:
		str = "integration_type"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f IntegrationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *IntegrationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("IntegrationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *IntegrationHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *IntegrationHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *IntegrationHistoryOrderFieldUpdatedAt
	case "name":
		*f = *IntegrationHistoryOrderFieldName
	case "kind":
		*f = *IntegrationHistoryOrderFieldKind
	case "integration_type":
		*f = *IntegrationHistoryOrderFieldIntegrationType
	default:
		return fmt.Errorf("%s is not a valid IntegrationHistoryOrderField", str)
	}
	return nil
}

// IntegrationHistoryOrderField defines the ordering field of IntegrationHistory.
type IntegrationHistoryOrderField struct {
	// Value extracts the ordering value from the given IntegrationHistory.
	Value    func(*IntegrationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) integrationhistory.OrderOption
	toCursor func(*IntegrationHistory) Cursor
}

// IntegrationHistoryOrder defines the ordering of IntegrationHistory.
type IntegrationHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *IntegrationHistoryOrderField `json:"field"`
}

// DefaultIntegrationHistoryOrder is the default ordering of IntegrationHistory.
var DefaultIntegrationHistoryOrder = &IntegrationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &IntegrationHistoryOrderField{
		Value: func(_m *IntegrationHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: integrationhistory.FieldID,
		toTerm: integrationhistory.ByID,
		toCursor: func(_m *IntegrationHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts IntegrationHistory into IntegrationHistoryEdge.
func (_m *IntegrationHistory) ToEdge(order *IntegrationHistoryOrder) *IntegrationHistoryEdge {
	if order == nil {
		order = DefaultIntegrationHistoryOrder
	}
	return &IntegrationHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// InternalPolicyHistoryEdge is the edge representation of InternalPolicyHistory.
type InternalPolicyHistoryEdge struct {
	Node   *InternalPolicyHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// InternalPolicyHistoryConnection is the connection containing edges to InternalPolicyHistory.
type InternalPolicyHistoryConnection struct {
	Edges      []*InternalPolicyHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *InternalPolicyHistoryConnection) build(nodes []*InternalPolicyHistory, pager *internalpolicyhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *InternalPolicyHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *InternalPolicyHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *InternalPolicyHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*InternalPolicyHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InternalPolicyHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InternalPolicyHistoryPaginateOption enables pagination customization.
type InternalPolicyHistoryPaginateOption func(*internalpolicyhistoryPager) error

// WithInternalPolicyHistoryOrder configures pagination ordering.
func WithInternalPolicyHistoryOrder(order *InternalPolicyHistoryOrder) InternalPolicyHistoryPaginateOption {
	if order == nil {
		order = DefaultInternalPolicyHistoryOrder
	}
	o := *order
	return func(pager *internalpolicyhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultInternalPolicyHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithInternalPolicyHistoryFilter configures pagination filter.
func WithInternalPolicyHistoryFilter(filter func(*InternalPolicyHistoryQuery) (*InternalPolicyHistoryQuery, error)) InternalPolicyHistoryPaginateOption {
	return func(pager *internalpolicyhistoryPager) error {
		if filter == nil {
			return errors.New("InternalPolicyHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type internalpolicyhistoryPager struct {
	reverse bool
	order   *InternalPolicyHistoryOrder
	filter  func(*InternalPolicyHistoryQuery) (*InternalPolicyHistoryQuery, error)
}

func newInternalPolicyHistoryPager(opts []InternalPolicyHistoryPaginateOption, reverse bool) (*internalpolicyhistoryPager, error) {
	pager := &internalpolicyhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultInternalPolicyHistoryOrder
	}
	return pager, nil
}

func (p *internalpolicyhistoryPager) applyFilter(query *InternalPolicyHistoryQuery) (*InternalPolicyHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *internalpolicyhistoryPager) toCursor(_m *InternalPolicyHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *internalpolicyhistoryPager) applyCursors(query *InternalPolicyHistoryQuery, after, before *Cursor) (*InternalPolicyHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultInternalPolicyHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *internalpolicyhistoryPager) applyOrder(query *InternalPolicyHistoryQuery) *InternalPolicyHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultInternalPolicyHistoryOrder.Field {
		query = query.Order(DefaultInternalPolicyHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *internalpolicyhistoryPager) orderExpr(query *InternalPolicyHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultInternalPolicyHistoryOrder.Field {
			b.Comma().Ident(DefaultInternalPolicyHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to InternalPolicyHistory.
func (_m *InternalPolicyHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InternalPolicyHistoryPaginateOption,
) (*InternalPolicyHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInternalPolicyHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &InternalPolicyHistoryConnection{Edges: []*InternalPolicyHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// InternalPolicyHistoryOrderFieldHistoryTime orders InternalPolicyHistory by history_time.
	InternalPolicyHistoryOrderFieldHistoryTime = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: internalpolicyhistory.FieldHistoryTime,
		toTerm: internalpolicyhistory.ByHistoryTime,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldCreatedAt orders InternalPolicyHistory by created_at.
	InternalPolicyHistoryOrderFieldCreatedAt = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: internalpolicyhistory.FieldCreatedAt,
		toTerm: internalpolicyhistory.ByCreatedAt,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldUpdatedAt orders InternalPolicyHistory by updated_at.
	InternalPolicyHistoryOrderFieldUpdatedAt = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: internalpolicyhistory.FieldUpdatedAt,
		toTerm: internalpolicyhistory.ByUpdatedAt,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldRevision orders InternalPolicyHistory by revision.
	InternalPolicyHistoryOrderFieldRevision = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: internalpolicyhistory.FieldRevision,
		toTerm: internalpolicyhistory.ByRevision,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldName orders InternalPolicyHistory by name.
	InternalPolicyHistoryOrderFieldName = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: internalpolicyhistory.FieldName,
		toTerm: internalpolicyhistory.ByName,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldStatus orders InternalPolicyHistory by status.
	InternalPolicyHistoryOrderFieldStatus = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: internalpolicyhistory.FieldStatus,
		toTerm: internalpolicyhistory.ByStatus,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldReviewDue orders InternalPolicyHistory by review_due.
	InternalPolicyHistoryOrderFieldReviewDue = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.ReviewDue, nil
		},
		column: internalpolicyhistory.FieldReviewDue,
		toTerm: internalpolicyhistory.ByReviewDue,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewDue,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldReviewFrequency orders InternalPolicyHistory by review_frequency.
	InternalPolicyHistoryOrderFieldReviewFrequency = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.ReviewFrequency, nil
		},
		column: internalpolicyhistory.FieldReviewFrequency,
		toTerm: internalpolicyhistory.ByReviewFrequency,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewFrequency,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InternalPolicyHistoryOrderField) String() string {
	var str string
	switch f.column {
	case InternalPolicyHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case InternalPolicyHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case InternalPolicyHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case InternalPolicyHistoryOrderFieldRevision.column:
		str = "revision"
	case InternalPolicyHistoryOrderFieldName.column:
		str = "name"
	case InternalPolicyHistoryOrderFieldStatus.column:
		str = "STATUS"
	case InternalPolicyHistoryOrderFieldReviewDue.column:
		str = "review_due"
	case InternalPolicyHistoryOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InternalPolicyHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InternalPolicyHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InternalPolicyHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *InternalPolicyHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *InternalPolicyHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *InternalPolicyHistoryOrderFieldUpdatedAt
	case "revision":
		*f = *InternalPolicyHistoryOrderFieldRevision
	case "name":
		*f = *InternalPolicyHistoryOrderFieldName
	case "STATUS":
		*f = *InternalPolicyHistoryOrderFieldStatus
	case "review_due":
		*f = *InternalPolicyHistoryOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *InternalPolicyHistoryOrderFieldReviewFrequency
	default:
		return fmt.Errorf("%s is not a valid InternalPolicyHistoryOrderField", str)
	}
	return nil
}

// InternalPolicyHistoryOrderField defines the ordering field of InternalPolicyHistory.
type InternalPolicyHistoryOrderField struct {
	// Value extracts the ordering value from the given InternalPolicyHistory.
	Value    func(*InternalPolicyHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) internalpolicyhistory.OrderOption
	toCursor func(*InternalPolicyHistory) Cursor
}

// InternalPolicyHistoryOrder defines the ordering of InternalPolicyHistory.
type InternalPolicyHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *InternalPolicyHistoryOrderField `json:"field"`
}

// DefaultInternalPolicyHistoryOrder is the default ordering of InternalPolicyHistory.
var DefaultInternalPolicyHistoryOrder = &InternalPolicyHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: internalpolicyhistory.FieldID,
		toTerm: internalpolicyhistory.ByID,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts InternalPolicyHistory into InternalPolicyHistoryEdge.
func (_m *InternalPolicyHistory) ToEdge(order *InternalPolicyHistoryOrder) *InternalPolicyHistoryEdge {
	if order == nil {
		order = DefaultInternalPolicyHistoryOrder
	}
	return &InternalPolicyHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobTemplateHistoryEdge is the edge representation of JobTemplateHistory.
type JobTemplateHistoryEdge struct {
	Node   *JobTemplateHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// JobTemplateHistoryConnection is the connection containing edges to JobTemplateHistory.
type JobTemplateHistoryConnection struct {
	Edges      []*JobTemplateHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *JobTemplateHistoryConnection) build(nodes []*JobTemplateHistory, pager *jobtemplatehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobTemplateHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobTemplateHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobTemplateHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobTemplateHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobTemplateHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobTemplateHistoryPaginateOption enables pagination customization.
type JobTemplateHistoryPaginateOption func(*jobtemplatehistoryPager) error

// WithJobTemplateHistoryOrder configures pagination ordering.
func WithJobTemplateHistoryOrder(order *JobTemplateHistoryOrder) JobTemplateHistoryPaginateOption {
	if order == nil {
		order = DefaultJobTemplateHistoryOrder
	}
	o := *order
	return func(pager *jobtemplatehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobTemplateHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobTemplateHistoryFilter configures pagination filter.
func WithJobTemplateHistoryFilter(filter func(*JobTemplateHistoryQuery) (*JobTemplateHistoryQuery, error)) JobTemplateHistoryPaginateOption {
	return func(pager *jobtemplatehistoryPager) error {
		if filter == nil {
			return errors.New("JobTemplateHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobtemplatehistoryPager struct {
	reverse bool
	order   *JobTemplateHistoryOrder
	filter  func(*JobTemplateHistoryQuery) (*JobTemplateHistoryQuery, error)
}

func newJobTemplateHistoryPager(opts []JobTemplateHistoryPaginateOption, reverse bool) (*jobtemplatehistoryPager, error) {
	pager := &jobtemplatehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobTemplateHistoryOrder
	}
	return pager, nil
}

func (p *jobtemplatehistoryPager) applyFilter(query *JobTemplateHistoryQuery) (*JobTemplateHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobtemplatehistoryPager) toCursor(_m *JobTemplateHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *jobtemplatehistoryPager) applyCursors(query *JobTemplateHistoryQuery, after, before *Cursor) (*JobTemplateHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobTemplateHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobtemplatehistoryPager) applyOrder(query *JobTemplateHistoryQuery) *JobTemplateHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobTemplateHistoryOrder.Field {
		query = query.Order(DefaultJobTemplateHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobtemplatehistoryPager) orderExpr(query *JobTemplateHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobTemplateHistoryOrder.Field {
			b.Comma().Ident(DefaultJobTemplateHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobTemplateHistory.
func (_m *JobTemplateHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobTemplateHistoryPaginateOption,
) (*JobTemplateHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobTemplateHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobTemplateHistoryConnection{Edges: []*JobTemplateHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobTemplateHistoryOrderFieldHistoryTime orders JobTemplateHistory by history_time.
	JobTemplateHistoryOrderFieldHistoryTime = &JobTemplateHistoryOrderField{
		Value: func(_m *JobTemplateHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: jobtemplatehistory.FieldHistoryTime,
		toTerm: jobtemplatehistory.ByHistoryTime,
		toCursor: func(_m *JobTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// JobTemplateHistoryOrderFieldCreatedAt orders JobTemplateHistory by created_at.
	JobTemplateHistoryOrderFieldCreatedAt = &JobTemplateHistoryOrderField{
		Value: func(_m *JobTemplateHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: jobtemplatehistory.FieldCreatedAt,
		toTerm: jobtemplatehistory.ByCreatedAt,
		toCursor: func(_m *JobTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// JobTemplateHistoryOrderFieldUpdatedAt orders JobTemplateHistory by updated_at.
	JobTemplateHistoryOrderFieldUpdatedAt = &JobTemplateHistoryOrderField{
		Value: func(_m *JobTemplateHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: jobtemplatehistory.FieldUpdatedAt,
		toTerm: jobtemplatehistory.ByUpdatedAt,
		toCursor: func(_m *JobTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// JobTemplateHistoryOrderFieldTitle orders JobTemplateHistory by title.
	JobTemplateHistoryOrderFieldTitle = &JobTemplateHistoryOrderField{
		Value: func(_m *JobTemplateHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: jobtemplatehistory.FieldTitle,
		toTerm: jobtemplatehistory.ByTitle,
		toCursor: func(_m *JobTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// JobTemplateHistoryOrderFieldPlatform orders JobTemplateHistory by platform.
	JobTemplateHistoryOrderFieldPlatform = &JobTemplateHistoryOrderField{
		Value: func(_m *JobTemplateHistory) (ent.Value, error) {
			return _m.Platform, nil
		},
		column: jobtemplatehistory.FieldPlatform,
		toTerm: jobtemplatehistory.ByPlatform,
		toCursor: func(_m *JobTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Platform,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobTemplateHistoryOrderField) String() string {
	var str string
	switch f.column {
	case JobTemplateHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case JobTemplateHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case JobTemplateHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobTemplateHistoryOrderFieldTitle.column:
		str = "title"
	case JobTemplateHistoryOrderFieldPlatform.column:
		str = "PLATFORM"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobTemplateHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobTemplateHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobTemplateHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *JobTemplateHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *JobTemplateHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *JobTemplateHistoryOrderFieldUpdatedAt
	case "title":
		*f = *JobTemplateHistoryOrderFieldTitle
	case "PLATFORM":
		*f = *JobTemplateHistoryOrderFieldPlatform
	default:
		return fmt.Errorf("%s is not a valid JobTemplateHistoryOrderField", str)
	}
	return nil
}

// JobTemplateHistoryOrderField defines the ordering field of JobTemplateHistory.
type JobTemplateHistoryOrderField struct {
	// Value extracts the ordering value from the given JobTemplateHistory.
	Value    func(*JobTemplateHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobtemplatehistory.OrderOption
	toCursor func(*JobTemplateHistory) Cursor
}

// JobTemplateHistoryOrder defines the ordering of JobTemplateHistory.
type JobTemplateHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *JobTemplateHistoryOrderField `json:"field"`
}

// DefaultJobTemplateHistoryOrder is the default ordering of JobTemplateHistory.
var DefaultJobTemplateHistoryOrder = &JobTemplateHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobTemplateHistoryOrderField{
		Value: func(_m *JobTemplateHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobtemplatehistory.FieldID,
		toTerm: jobtemplatehistory.ByID,
		toCursor: func(_m *JobTemplateHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobTemplateHistory into JobTemplateHistoryEdge.
func (_m *JobTemplateHistory) ToEdge(order *JobTemplateHistoryOrder) *JobTemplateHistoryEdge {
	if order == nil {
		order = DefaultJobTemplateHistoryOrder
	}
	return &JobTemplateHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// MappableDomainHistoryEdge is the edge representation of MappableDomainHistory.
type MappableDomainHistoryEdge struct {
	Node   *MappableDomainHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// MappableDomainHistoryConnection is the connection containing edges to MappableDomainHistory.
type MappableDomainHistoryConnection struct {
	Edges      []*MappableDomainHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *MappableDomainHistoryConnection) build(nodes []*MappableDomainHistory, pager *mappabledomainhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *MappableDomainHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MappableDomainHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MappableDomainHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*MappableDomainHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MappableDomainHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MappableDomainHistoryPaginateOption enables pagination customization.
type MappableDomainHistoryPaginateOption func(*mappabledomainhistoryPager) error

// WithMappableDomainHistoryOrder configures pagination ordering.
func WithMappableDomainHistoryOrder(order *MappableDomainHistoryOrder) MappableDomainHistoryPaginateOption {
	if order == nil {
		order = DefaultMappableDomainHistoryOrder
	}
	o := *order
	return func(pager *mappabledomainhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMappableDomainHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMappableDomainHistoryFilter configures pagination filter.
func WithMappableDomainHistoryFilter(filter func(*MappableDomainHistoryQuery) (*MappableDomainHistoryQuery, error)) MappableDomainHistoryPaginateOption {
	return func(pager *mappabledomainhistoryPager) error {
		if filter == nil {
			return errors.New("MappableDomainHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mappabledomainhistoryPager struct {
	reverse bool
	order   *MappableDomainHistoryOrder
	filter  func(*MappableDomainHistoryQuery) (*MappableDomainHistoryQuery, error)
}

func newMappableDomainHistoryPager(opts []MappableDomainHistoryPaginateOption, reverse bool) (*mappabledomainhistoryPager, error) {
	pager := &mappabledomainhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMappableDomainHistoryOrder
	}
	return pager, nil
}

func (p *mappabledomainhistoryPager) applyFilter(query *MappableDomainHistoryQuery) (*MappableDomainHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mappabledomainhistoryPager) toCursor(_m *MappableDomainHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *mappabledomainhistoryPager) applyCursors(query *MappableDomainHistoryQuery, after, before *Cursor) (*MappableDomainHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMappableDomainHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *mappabledomainhistoryPager) applyOrder(query *MappableDomainHistoryQuery) *MappableDomainHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMappableDomainHistoryOrder.Field {
		query = query.Order(DefaultMappableDomainHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *mappabledomainhistoryPager) orderExpr(query *MappableDomainHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMappableDomainHistoryOrder.Field {
			b.Comma().Ident(DefaultMappableDomainHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to MappableDomainHistory.
func (_m *MappableDomainHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MappableDomainHistoryPaginateOption,
) (*MappableDomainHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMappableDomainHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &MappableDomainHistoryConnection{Edges: []*MappableDomainHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MappableDomainHistoryOrderFieldHistoryTime orders MappableDomainHistory by history_time.
	MappableDomainHistoryOrderFieldHistoryTime = &MappableDomainHistoryOrderField{
		Value: func(_m *MappableDomainHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: mappabledomainhistory.FieldHistoryTime,
		toTerm: mappabledomainhistory.ByHistoryTime,
		toCursor: func(_m *MappableDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// MappableDomainHistoryOrderFieldCreatedAt orders MappableDomainHistory by created_at.
	MappableDomainHistoryOrderFieldCreatedAt = &MappableDomainHistoryOrderField{
		Value: func(_m *MappableDomainHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: mappabledomainhistory.FieldCreatedAt,
		toTerm: mappabledomainhistory.ByCreatedAt,
		toCursor: func(_m *MappableDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// MappableDomainHistoryOrderFieldUpdatedAt orders MappableDomainHistory by updated_at.
	MappableDomainHistoryOrderFieldUpdatedAt = &MappableDomainHistoryOrderField{
		Value: func(_m *MappableDomainHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: mappabledomainhistory.FieldUpdatedAt,
		toTerm: mappabledomainhistory.ByUpdatedAt,
		toCursor: func(_m *MappableDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// MappableDomainHistoryOrderFieldName orders MappableDomainHistory by name.
	MappableDomainHistoryOrderFieldName = &MappableDomainHistoryOrderField{
		Value: func(_m *MappableDomainHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: mappabledomainhistory.FieldName,
		toTerm: mappabledomainhistory.ByName,
		toCursor: func(_m *MappableDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MappableDomainHistoryOrderField) String() string {
	var str string
	switch f.column {
	case MappableDomainHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case MappableDomainHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case MappableDomainHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case MappableDomainHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MappableDomainHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MappableDomainHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MappableDomainHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *MappableDomainHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *MappableDomainHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *MappableDomainHistoryOrderFieldUpdatedAt
	case "name":
		*f = *MappableDomainHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid MappableDomainHistoryOrderField", str)
	}
	return nil
}

// MappableDomainHistoryOrderField defines the ordering field of MappableDomainHistory.
type MappableDomainHistoryOrderField struct {
	// Value extracts the ordering value from the given MappableDomainHistory.
	Value    func(*MappableDomainHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) mappabledomainhistory.OrderOption
	toCursor func(*MappableDomainHistory) Cursor
}

// MappableDomainHistoryOrder defines the ordering of MappableDomainHistory.
type MappableDomainHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *MappableDomainHistoryOrderField `json:"field"`
}

// DefaultMappableDomainHistoryOrder is the default ordering of MappableDomainHistory.
var DefaultMappableDomainHistoryOrder = &MappableDomainHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MappableDomainHistoryOrderField{
		Value: func(_m *MappableDomainHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: mappabledomainhistory.FieldID,
		toTerm: mappabledomainhistory.ByID,
		toCursor: func(_m *MappableDomainHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts MappableDomainHistory into MappableDomainHistoryEdge.
func (_m *MappableDomainHistory) ToEdge(order *MappableDomainHistoryOrder) *MappableDomainHistoryEdge {
	if order == nil {
		order = DefaultMappableDomainHistoryOrder
	}
	return &MappableDomainHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// MappedControlHistoryEdge is the edge representation of MappedControlHistory.
type MappedControlHistoryEdge struct {
	Node   *MappedControlHistory `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// MappedControlHistoryConnection is the connection containing edges to MappedControlHistory.
type MappedControlHistoryConnection struct {
	Edges      []*MappedControlHistoryEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *MappedControlHistoryConnection) build(nodes []*MappedControlHistory, pager *mappedcontrolhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *MappedControlHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MappedControlHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MappedControlHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*MappedControlHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MappedControlHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MappedControlHistoryPaginateOption enables pagination customization.
type MappedControlHistoryPaginateOption func(*mappedcontrolhistoryPager) error

// WithMappedControlHistoryOrder configures pagination ordering.
func WithMappedControlHistoryOrder(order *MappedControlHistoryOrder) MappedControlHistoryPaginateOption {
	if order == nil {
		order = DefaultMappedControlHistoryOrder
	}
	o := *order
	return func(pager *mappedcontrolhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMappedControlHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMappedControlHistoryFilter configures pagination filter.
func WithMappedControlHistoryFilter(filter func(*MappedControlHistoryQuery) (*MappedControlHistoryQuery, error)) MappedControlHistoryPaginateOption {
	return func(pager *mappedcontrolhistoryPager) error {
		if filter == nil {
			return errors.New("MappedControlHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mappedcontrolhistoryPager struct {
	reverse bool
	order   *MappedControlHistoryOrder
	filter  func(*MappedControlHistoryQuery) (*MappedControlHistoryQuery, error)
}

func newMappedControlHistoryPager(opts []MappedControlHistoryPaginateOption, reverse bool) (*mappedcontrolhistoryPager, error) {
	pager := &mappedcontrolhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMappedControlHistoryOrder
	}
	return pager, nil
}

func (p *mappedcontrolhistoryPager) applyFilter(query *MappedControlHistoryQuery) (*MappedControlHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mappedcontrolhistoryPager) toCursor(_m *MappedControlHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *mappedcontrolhistoryPager) applyCursors(query *MappedControlHistoryQuery, after, before *Cursor) (*MappedControlHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMappedControlHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *mappedcontrolhistoryPager) applyOrder(query *MappedControlHistoryQuery) *MappedControlHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMappedControlHistoryOrder.Field {
		query = query.Order(DefaultMappedControlHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *mappedcontrolhistoryPager) orderExpr(query *MappedControlHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMappedControlHistoryOrder.Field {
			b.Comma().Ident(DefaultMappedControlHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to MappedControlHistory.
func (_m *MappedControlHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MappedControlHistoryPaginateOption,
) (*MappedControlHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMappedControlHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &MappedControlHistoryConnection{Edges: []*MappedControlHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MappedControlHistoryOrderFieldHistoryTime orders MappedControlHistory by history_time.
	MappedControlHistoryOrderFieldHistoryTime = &MappedControlHistoryOrderField{
		Value: func(_m *MappedControlHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: mappedcontrolhistory.FieldHistoryTime,
		toTerm: mappedcontrolhistory.ByHistoryTime,
		toCursor: func(_m *MappedControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// MappedControlHistoryOrderFieldCreatedAt orders MappedControlHistory by created_at.
	MappedControlHistoryOrderFieldCreatedAt = &MappedControlHistoryOrderField{
		Value: func(_m *MappedControlHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: mappedcontrolhistory.FieldCreatedAt,
		toTerm: mappedcontrolhistory.ByCreatedAt,
		toCursor: func(_m *MappedControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// MappedControlHistoryOrderFieldUpdatedAt orders MappedControlHistory by updated_at.
	MappedControlHistoryOrderFieldUpdatedAt = &MappedControlHistoryOrderField{
		Value: func(_m *MappedControlHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: mappedcontrolhistory.FieldUpdatedAt,
		toTerm: mappedcontrolhistory.ByUpdatedAt,
		toCursor: func(_m *MappedControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// MappedControlHistoryOrderFieldMappingType orders MappedControlHistory by mapping_type.
	MappedControlHistoryOrderFieldMappingType = &MappedControlHistoryOrderField{
		Value: func(_m *MappedControlHistory) (ent.Value, error) {
			return _m.MappingType, nil
		},
		column: mappedcontrolhistory.FieldMappingType,
		toTerm: mappedcontrolhistory.ByMappingType,
		toCursor: func(_m *MappedControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.MappingType,
			}
		},
	}
	// MappedControlHistoryOrderFieldSource orders MappedControlHistory by source.
	MappedControlHistoryOrderFieldSource = &MappedControlHistoryOrderField{
		Value: func(_m *MappedControlHistory) (ent.Value, error) {
			return _m.Source, nil
		},
		column: mappedcontrolhistory.FieldSource,
		toTerm: mappedcontrolhistory.BySource,
		toCursor: func(_m *MappedControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MappedControlHistoryOrderField) String() string {
	var str string
	switch f.column {
	case MappedControlHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case MappedControlHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case MappedControlHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case MappedControlHistoryOrderFieldMappingType.column:
		str = "MAPPING_TYPE"
	case MappedControlHistoryOrderFieldSource.column:
		str = "SOURCE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MappedControlHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MappedControlHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MappedControlHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *MappedControlHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *MappedControlHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *MappedControlHistoryOrderFieldUpdatedAt
	case "MAPPING_TYPE":
		*f = *MappedControlHistoryOrderFieldMappingType
	case "SOURCE":
		*f = *MappedControlHistoryOrderFieldSource
	default:
		return fmt.Errorf("%s is not a valid MappedControlHistoryOrderField", str)
	}
	return nil
}

// MappedControlHistoryOrderField defines the ordering field of MappedControlHistory.
type MappedControlHistoryOrderField struct {
	// Value extracts the ordering value from the given MappedControlHistory.
	Value    func(*MappedControlHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) mappedcontrolhistory.OrderOption
	toCursor func(*MappedControlHistory) Cursor
}

// MappedControlHistoryOrder defines the ordering of MappedControlHistory.
type MappedControlHistoryOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *MappedControlHistoryOrderField `json:"field"`
}

// DefaultMappedControlHistoryOrder is the default ordering of MappedControlHistory.
var DefaultMappedControlHistoryOrder = &MappedControlHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MappedControlHistoryOrderField{
		Value: func(_m *MappedControlHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: mappedcontrolhistory.FieldID,
		toTerm: mappedcontrolhistory.ByID,
		toCursor: func(_m *MappedControlHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts MappedControlHistory into MappedControlHistoryEdge.
func (_m *MappedControlHistory) ToEdge(order *MappedControlHistoryOrder) *MappedControlHistoryEdge {
	if order == nil {
		order = DefaultMappedControlHistoryOrder
	}
	return &MappedControlHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// NarrativeHistoryEdge is the edge representation of NarrativeHistory.
type NarrativeHistoryEdge struct {
	Node   *NarrativeHistory `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// NarrativeHistoryConnection is the connection containing edges to NarrativeHistory.
type NarrativeHistoryConnection struct {
	Edges      []*NarrativeHistoryEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *NarrativeHistoryConnection) build(nodes []*NarrativeHistory, pager *narrativehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *NarrativeHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *NarrativeHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *NarrativeHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*NarrativeHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NarrativeHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NarrativeHistoryPaginateOption enables pagination customization.
type NarrativeHistoryPaginateOption func(*narrativehistoryPager) error

// WithNarrativeHistoryOrder configures pagination ordering.
func WithNarrativeHistoryOrder(order *NarrativeHistoryOrder) NarrativeHistoryPaginateOption {
	if order == nil {
		order = DefaultNarrativeHistoryOrder
	}
	o := *order
	return func(pager *narrativehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNarrativeHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNarrativeHistoryFilter configures pagination filter.
func WithNarrativeHistoryFilter(filter func(*NarrativeHistoryQuery) (*NarrativeHistoryQuery, error)) NarrativeHistoryPaginateOption {
	return func(pager *narrativehistoryPager) error {
		if filter == nil {
			return errors.New("NarrativeHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type narrativehistoryPager struct {
	reverse bool
	order   *NarrativeHistoryOrder
	filter  func(*NarrativeHistoryQuery) (*NarrativeHistoryQuery, error)
}

func newNarrativeHistoryPager(opts []NarrativeHistoryPaginateOption, reverse bool) (*narrativehistoryPager, error) {
	pager := &narrativehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNarrativeHistoryOrder
	}
	return pager, nil
}

func (p *narrativehistoryPager) applyFilter(query *NarrativeHistoryQuery) (*NarrativeHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *narrativehistoryPager) toCursor(_m *NarrativeHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *narrativehistoryPager) applyCursors(query *NarrativeHistoryQuery, after, before *Cursor) (*NarrativeHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNarrativeHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *narrativehistoryPager) applyOrder(query *NarrativeHistoryQuery) *NarrativeHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNarrativeHistoryOrder.Field {
		query = query.Order(DefaultNarrativeHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *narrativehistoryPager) orderExpr(query *NarrativeHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNarrativeHistoryOrder.Field {
			b.Comma().Ident(DefaultNarrativeHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to NarrativeHistory.
func (_m *NarrativeHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NarrativeHistoryPaginateOption,
) (*NarrativeHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNarrativeHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &NarrativeHistoryConnection{Edges: []*NarrativeHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NarrativeHistoryOrderFieldHistoryTime orders NarrativeHistory by history_time.
	NarrativeHistoryOrderFieldHistoryTime = &NarrativeHistoryOrderField{
		Value: func(_m *NarrativeHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: narrativehistory.FieldHistoryTime,
		toTerm: narrativehistory.ByHistoryTime,
		toCursor: func(_m *NarrativeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// NarrativeHistoryOrderFieldCreatedAt orders NarrativeHistory by created_at.
	NarrativeHistoryOrderFieldCreatedAt = &NarrativeHistoryOrderField{
		Value: func(_m *NarrativeHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: narrativehistory.FieldCreatedAt,
		toTerm: narrativehistory.ByCreatedAt,
		toCursor: func(_m *NarrativeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// NarrativeHistoryOrderFieldUpdatedAt orders NarrativeHistory by updated_at.
	NarrativeHistoryOrderFieldUpdatedAt = &NarrativeHistoryOrderField{
		Value: func(_m *NarrativeHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: narrativehistory.FieldUpdatedAt,
		toTerm: narrativehistory.ByUpdatedAt,
		toCursor: func(_m *NarrativeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// NarrativeHistoryOrderFieldName orders NarrativeHistory by name.
	NarrativeHistoryOrderFieldName = &NarrativeHistoryOrderField{
		Value: func(_m *NarrativeHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: narrativehistory.FieldName,
		toTerm: narrativehistory.ByName,
		toCursor: func(_m *NarrativeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NarrativeHistoryOrderField) String() string {
	var str string
	switch f.column {
	case NarrativeHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case NarrativeHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case NarrativeHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case NarrativeHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NarrativeHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NarrativeHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NarrativeHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *NarrativeHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *NarrativeHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *NarrativeHistoryOrderFieldUpdatedAt
	case "name":
		*f = *NarrativeHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid NarrativeHistoryOrderField", str)
	}
	return nil
}

// NarrativeHistoryOrderField defines the ordering field of NarrativeHistory.
type NarrativeHistoryOrderField struct {
	// Value extracts the ordering value from the given NarrativeHistory.
	Value    func(*NarrativeHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) narrativehistory.OrderOption
	toCursor func(*NarrativeHistory) Cursor
}

// NarrativeHistoryOrder defines the ordering of NarrativeHistory.
type NarrativeHistoryOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *NarrativeHistoryOrderField `json:"field"`
}

// DefaultNarrativeHistoryOrder is the default ordering of NarrativeHistory.
var DefaultNarrativeHistoryOrder = &NarrativeHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NarrativeHistoryOrderField{
		Value: func(_m *NarrativeHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: narrativehistory.FieldID,
		toTerm: narrativehistory.ByID,
		toCursor: func(_m *NarrativeHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts NarrativeHistory into NarrativeHistoryEdge.
func (_m *NarrativeHistory) ToEdge(order *NarrativeHistoryOrder) *NarrativeHistoryEdge {
	if order == nil {
		order = DefaultNarrativeHistoryOrder
	}
	return &NarrativeHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// NoteHistoryEdge is the edge representation of NoteHistory.
type NoteHistoryEdge struct {
	Node   *NoteHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// NoteHistoryConnection is the connection containing edges to NoteHistory.
type NoteHistoryConnection struct {
	Edges      []*NoteHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *NoteHistoryConnection) build(nodes []*NoteHistory, pager *notehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *NoteHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *NoteHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *NoteHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*NoteHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NoteHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NoteHistoryPaginateOption enables pagination customization.
type NoteHistoryPaginateOption func(*notehistoryPager) error

// WithNoteHistoryOrder configures pagination ordering.
func WithNoteHistoryOrder(order *NoteHistoryOrder) NoteHistoryPaginateOption {
	if order == nil {
		order = DefaultNoteHistoryOrder
	}
	o := *order
	return func(pager *notehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNoteHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNoteHistoryFilter configures pagination filter.
func WithNoteHistoryFilter(filter func(*NoteHistoryQuery) (*NoteHistoryQuery, error)) NoteHistoryPaginateOption {
	return func(pager *notehistoryPager) error {
		if filter == nil {
			return errors.New("NoteHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notehistoryPager struct {
	reverse bool
	order   *NoteHistoryOrder
	filter  func(*NoteHistoryQuery) (*NoteHistoryQuery, error)
}

func newNoteHistoryPager(opts []NoteHistoryPaginateOption, reverse bool) (*notehistoryPager, error) {
	pager := &notehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNoteHistoryOrder
	}
	return pager, nil
}

func (p *notehistoryPager) applyFilter(query *NoteHistoryQuery) (*NoteHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notehistoryPager) toCursor(_m *NoteHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *notehistoryPager) applyCursors(query *NoteHistoryQuery, after, before *Cursor) (*NoteHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNoteHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *notehistoryPager) applyOrder(query *NoteHistoryQuery) *NoteHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNoteHistoryOrder.Field {
		query = query.Order(DefaultNoteHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *notehistoryPager) orderExpr(query *NoteHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNoteHistoryOrder.Field {
			b.Comma().Ident(DefaultNoteHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to NoteHistory.
func (_m *NoteHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NoteHistoryPaginateOption,
) (*NoteHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNoteHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &NoteHistoryConnection{Edges: []*NoteHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NoteHistoryOrderFieldHistoryTime orders NoteHistory by history_time.
	NoteHistoryOrderFieldHistoryTime = &NoteHistoryOrderField{
		Value: func(_m *NoteHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: notehistory.FieldHistoryTime,
		toTerm: notehistory.ByHistoryTime,
		toCursor: func(_m *NoteHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// NoteHistoryOrderFieldCreatedAt orders NoteHistory by created_at.
	NoteHistoryOrderFieldCreatedAt = &NoteHistoryOrderField{
		Value: func(_m *NoteHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: notehistory.FieldCreatedAt,
		toTerm: notehistory.ByCreatedAt,
		toCursor: func(_m *NoteHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// NoteHistoryOrderFieldUpdatedAt orders NoteHistory by updated_at.
	NoteHistoryOrderFieldUpdatedAt = &NoteHistoryOrderField{
		Value: func(_m *NoteHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: notehistory.FieldUpdatedAt,
		toTerm: notehistory.ByUpdatedAt,
		toCursor: func(_m *NoteHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NoteHistoryOrderField) String() string {
	var str string
	switch f.column {
	case NoteHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case NoteHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case NoteHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NoteHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NoteHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NoteHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *NoteHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *NoteHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *NoteHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid NoteHistoryOrderField", str)
	}
	return nil
}

// NoteHistoryOrderField defines the ordering field of NoteHistory.
type NoteHistoryOrderField struct {
	// Value extracts the ordering value from the given NoteHistory.
	Value    func(*NoteHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) notehistory.OrderOption
	toCursor func(*NoteHistory) Cursor
}

// NoteHistoryOrder defines the ordering of NoteHistory.
type NoteHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *NoteHistoryOrderField `json:"field"`
}

// DefaultNoteHistoryOrder is the default ordering of NoteHistory.
var DefaultNoteHistoryOrder = &NoteHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NoteHistoryOrderField{
		Value: func(_m *NoteHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: notehistory.FieldID,
		toTerm: notehistory.ByID,
		toCursor: func(_m *NoteHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts NoteHistory into NoteHistoryEdge.
func (_m *NoteHistory) ToEdge(order *NoteHistoryOrder) *NoteHistoryEdge {
	if order == nil {
		order = DefaultNoteHistoryOrder
	}
	return &NoteHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// NotificationPreferenceHistoryEdge is the edge representation of NotificationPreferenceHistory.
type NotificationPreferenceHistoryEdge struct {
	Node   *NotificationPreferenceHistory `json:"node"`
	Cursor Cursor                         `json:"cursor"`
}

// NotificationPreferenceHistoryConnection is the connection containing edges to NotificationPreferenceHistory.
type NotificationPreferenceHistoryConnection struct {
	Edges      []*NotificationPreferenceHistoryEdge `json:"edges"`
	PageInfo   PageInfo                             `json:"pageInfo"`
	TotalCount int                                  `json:"totalCount"`
}

func (c *NotificationPreferenceHistoryConnection) build(nodes []*NotificationPreferenceHistory, pager *notificationpreferencehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *NotificationPreferenceHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *NotificationPreferenceHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *NotificationPreferenceHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*NotificationPreferenceHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NotificationPreferenceHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NotificationPreferenceHistoryPaginateOption enables pagination customization.
type NotificationPreferenceHistoryPaginateOption func(*notificationpreferencehistoryPager) error

// WithNotificationPreferenceHistoryOrder configures pagination ordering.
func WithNotificationPreferenceHistoryOrder(order *NotificationPreferenceHistoryOrder) NotificationPreferenceHistoryPaginateOption {
	if order == nil {
		order = DefaultNotificationPreferenceHistoryOrder
	}
	o := *order
	return func(pager *notificationpreferencehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNotificationPreferenceHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNotificationPreferenceHistoryFilter configures pagination filter.
func WithNotificationPreferenceHistoryFilter(filter func(*NotificationPreferenceHistoryQuery) (*NotificationPreferenceHistoryQuery, error)) NotificationPreferenceHistoryPaginateOption {
	return func(pager *notificationpreferencehistoryPager) error {
		if filter == nil {
			return errors.New("NotificationPreferenceHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notificationpreferencehistoryPager struct {
	reverse bool
	order   *NotificationPreferenceHistoryOrder
	filter  func(*NotificationPreferenceHistoryQuery) (*NotificationPreferenceHistoryQuery, error)
}

func newNotificationPreferenceHistoryPager(opts []NotificationPreferenceHistoryPaginateOption, reverse bool) (*notificationpreferencehistoryPager, error) {
	pager := &notificationpreferencehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNotificationPreferenceHistoryOrder
	}
	return pager, nil
}

func (p *notificationpreferencehistoryPager) applyFilter(query *NotificationPreferenceHistoryQuery) (*NotificationPreferenceHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notificationpreferencehistoryPager) toCursor(_m *NotificationPreferenceHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *notificationpreferencehistoryPager) applyCursors(query *NotificationPreferenceHistoryQuery, after, before *Cursor) (*NotificationPreferenceHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNotificationPreferenceHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *notificationpreferencehistoryPager) applyOrder(query *NotificationPreferenceHistoryQuery) *NotificationPreferenceHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNotificationPreferenceHistoryOrder.Field {
		query = query.Order(DefaultNotificationPreferenceHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *notificationpreferencehistoryPager) orderExpr(query *NotificationPreferenceHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNotificationPreferenceHistoryOrder.Field {
			b.Comma().Ident(DefaultNotificationPreferenceHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to NotificationPreferenceHistory.
func (_m *NotificationPreferenceHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NotificationPreferenceHistoryPaginateOption,
) (*NotificationPreferenceHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNotificationPreferenceHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &NotificationPreferenceHistoryConnection{Edges: []*NotificationPreferenceHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NotificationPreferenceHistoryOrderFieldHistoryTime orders NotificationPreferenceHistory by history_time.
	NotificationPreferenceHistoryOrderFieldHistoryTime = &NotificationPreferenceHistoryOrderField{
		Value: func(_m *NotificationPreferenceHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: notificationpreferencehistory.FieldHistoryTime,
		toTerm: notificationpreferencehistory.ByHistoryTime,
		toCursor: func(_m *NotificationPreferenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// NotificationPreferenceHistoryOrderFieldCreatedAt orders NotificationPreferenceHistory by created_at.
	NotificationPreferenceHistoryOrderFieldCreatedAt = &NotificationPreferenceHistoryOrderField{
		Value: func(_m *NotificationPreferenceHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: notificationpreferencehistory.FieldCreatedAt,
		toTerm: notificationpreferencehistory.ByCreatedAt,
		toCursor: func(_m *NotificationPreferenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// NotificationPreferenceHistoryOrderFieldUpdatedAt orders NotificationPreferenceHistory by updated_at.
	NotificationPreferenceHistoryOrderFieldUpdatedAt = &NotificationPreferenceHistoryOrderField{
		Value: func(_m *NotificationPreferenceHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: notificationpreferencehistory.FieldUpdatedAt,
		toTerm: notificationpreferencehistory.ByUpdatedAt,
		toCursor: func(_m *NotificationPreferenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// NotificationPreferenceHistoryOrderFieldChannel orders NotificationPreferenceHistory by channel.
	NotificationPreferenceHistoryOrderFieldChannel = &NotificationPreferenceHistoryOrderField{
		Value: func(_m *NotificationPreferenceHistory) (ent.Value, error) {
			return _m.Channel, nil
		},
		column: notificationpreferencehistory.FieldChannel,
		toTerm: notificationpreferencehistory.ByChannel,
		toCursor: func(_m *NotificationPreferenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Channel,
			}
		},
	}
	// NotificationPreferenceHistoryOrderFieldStatus orders NotificationPreferenceHistory by status.
	NotificationPreferenceHistoryOrderFieldStatus = &NotificationPreferenceHistoryOrderField{
		Value: func(_m *NotificationPreferenceHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: notificationpreferencehistory.FieldStatus,
		toTerm: notificationpreferencehistory.ByStatus,
		toCursor: func(_m *NotificationPreferenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// NotificationPreferenceHistoryOrderFieldEnabled orders NotificationPreferenceHistory by enabled.
	NotificationPreferenceHistoryOrderFieldEnabled = &NotificationPreferenceHistoryOrderField{
		Value: func(_m *NotificationPreferenceHistory) (ent.Value, error) {
			return _m.Enabled, nil
		},
		column: notificationpreferencehistory.FieldEnabled,
		toTerm: notificationpreferencehistory.ByEnabled,
		toCursor: func(_m *NotificationPreferenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Enabled,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NotificationPreferenceHistoryOrderField) String() string {
	var str string
	switch f.column {
	case NotificationPreferenceHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case NotificationPreferenceHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case NotificationPreferenceHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case NotificationPreferenceHistoryOrderFieldChannel.column:
		str = "CHANNEL"
	case NotificationPreferenceHistoryOrderFieldStatus.column:
		str = "STATUS"
	case NotificationPreferenceHistoryOrderFieldEnabled.column:
		str = "ENABLED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NotificationPreferenceHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NotificationPreferenceHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NotificationPreferenceHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *NotificationPreferenceHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *NotificationPreferenceHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *NotificationPreferenceHistoryOrderFieldUpdatedAt
	case "CHANNEL":
		*f = *NotificationPreferenceHistoryOrderFieldChannel
	case "STATUS":
		*f = *NotificationPreferenceHistoryOrderFieldStatus
	case "ENABLED":
		*f = *NotificationPreferenceHistoryOrderFieldEnabled
	default:
		return fmt.Errorf("%s is not a valid NotificationPreferenceHistoryOrderField", str)
	}
	return nil
}

// NotificationPreferenceHistoryOrderField defines the ordering field of NotificationPreferenceHistory.
type NotificationPreferenceHistoryOrderField struct {
	// Value extracts the ordering value from the given NotificationPreferenceHistory.
	Value    func(*NotificationPreferenceHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) notificationpreferencehistory.OrderOption
	toCursor func(*NotificationPreferenceHistory) Cursor
}

// NotificationPreferenceHistoryOrder defines the ordering of NotificationPreferenceHistory.
type NotificationPreferenceHistoryOrder struct {
	Direction OrderDirection                           `json:"direction"`
	Field     *NotificationPreferenceHistoryOrderField `json:"field"`
}

// DefaultNotificationPreferenceHistoryOrder is the default ordering of NotificationPreferenceHistory.
var DefaultNotificationPreferenceHistoryOrder = &NotificationPreferenceHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NotificationPreferenceHistoryOrderField{
		Value: func(_m *NotificationPreferenceHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: notificationpreferencehistory.FieldID,
		toTerm: notificationpreferencehistory.ByID,
		toCursor: func(_m *NotificationPreferenceHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts NotificationPreferenceHistory into NotificationPreferenceHistoryEdge.
func (_m *NotificationPreferenceHistory) ToEdge(order *NotificationPreferenceHistoryOrder) *NotificationPreferenceHistoryEdge {
	if order == nil {
		order = DefaultNotificationPreferenceHistoryOrder
	}
	return &NotificationPreferenceHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// NotificationTemplateHistoryEdge is the edge representation of NotificationTemplateHistory.
type NotificationTemplateHistoryEdge struct {
	Node   *NotificationTemplateHistory `json:"node"`
	Cursor Cursor                       `json:"cursor"`
}

// NotificationTemplateHistoryConnection is the connection containing edges to NotificationTemplateHistory.
type NotificationTemplateHistoryConnection struct {
	Edges      []*NotificationTemplateHistoryEdge `json:"edges"`
	PageInfo   PageInfo                           `json:"pageInfo"`
	TotalCount int                                `json:"totalCount"`
}

func (c *NotificationTemplateHistoryConnection) build(nodes []*NotificationTemplateHistory, pager *notificationtemplatehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *NotificationTemplateHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *NotificationTemplateHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *NotificationTemplateHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*NotificationTemplateHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NotificationTemplateHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NotificationTemplateHistoryPaginateOption enables pagination customization.
type NotificationTemplateHistoryPaginateOption func(*notificationtemplatehistoryPager) error

// WithNotificationTemplateHistoryOrder configures pagination ordering.
func WithNotificationTemplateHistoryOrder(order *NotificationTemplateHistoryOrder) NotificationTemplateHistoryPaginateOption {
	if order == nil {
		order = DefaultNotificationTemplateHistoryOrder
	}
	o := *order
	return func(pager *notificationtemplatehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNotificationTemplateHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNotificationTemplateHistoryFilter configures pagination filter.
func WithNotificationTemplateHistoryFilter(filter func(*NotificationTemplateHistoryQuery) (*NotificationTemplateHistoryQuery, error)) NotificationTemplateHistoryPaginateOption {
	return func(pager *notificationtemplatehistoryPager) error {
		if filter == nil {
			return errors.New("NotificationTemplateHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notificationtemplatehistoryPager struct {
	reverse bool
	order   *NotificationTemplateHistoryOrder
	filter  func(*NotificationTemplateHistoryQuery) (*NotificationTemplateHistoryQuery, error)
}

func newNotificationTemplateHistoryPager(opts []NotificationTemplateHistoryPaginateOption, reverse bool) (*notificationtemplatehistoryPager, error) {
	pager := &notificationtemplatehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNotificationTemplateHistoryOrder
	}
	return pager, nil
}

func (p *notificationtemplatehistoryPager) applyFilter(query *NotificationTemplateHistoryQuery) (*NotificationTemplateHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notificationtemplatehistoryPager) toCursor(_m *NotificationTemplateHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *notificationtemplatehistoryPager) applyCursors(query *NotificationTemplateHistoryQuery, after, before *Cursor) (*NotificationTemplateHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNotificationTemplateHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *notificationtemplatehistoryPager) applyOrder(query *NotificationTemplateHistoryQuery) *NotificationTemplateHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNotificationTemplateHistoryOrder.Field {
		query = query.Order(DefaultNotificationTemplateHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *notificationtemplatehistoryPager) orderExpr(query *NotificationTemplateHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNotificationTemplateHistoryOrder.Field {
			b.Comma().Ident(DefaultNotificationTemplateHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to NotificationTemplateHistory.
func (_m *NotificationTemplateHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NotificationTemplateHistoryPaginateOption,
) (*NotificationTemplateHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNotificationTemplateHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &NotificationTemplateHistoryConnection{Edges: []*NotificationTemplateHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NotificationTemplateHistoryOrderFieldHistoryTime orders NotificationTemplateHistory by history_time.
	NotificationTemplateHistoryOrderFieldHistoryTime = &NotificationTemplateHistoryOrderField{
		Value: func(_m *NotificationTemplateHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: notificationtemplatehistory.FieldHistoryTime,
		toTerm: notificationtemplatehistory.ByHistoryTime,
		toCursor: func(_m *NotificationTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// NotificationTemplateHistoryOrderFieldCreatedAt orders NotificationTemplateHistory by created_at.
	NotificationTemplateHistoryOrderFieldCreatedAt = &NotificationTemplateHistoryOrderField{
		Value: func(_m *NotificationTemplateHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: notificationtemplatehistory.FieldCreatedAt,
		toTerm: notificationtemplatehistory.ByCreatedAt,
		toCursor: func(_m *NotificationTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// NotificationTemplateHistoryOrderFieldUpdatedAt orders NotificationTemplateHistory by updated_at.
	NotificationTemplateHistoryOrderFieldUpdatedAt = &NotificationTemplateHistoryOrderField{
		Value: func(_m *NotificationTemplateHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: notificationtemplatehistory.FieldUpdatedAt,
		toTerm: notificationtemplatehistory.ByUpdatedAt,
		toCursor: func(_m *NotificationTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// NotificationTemplateHistoryOrderFieldKey orders NotificationTemplateHistory by key.
	NotificationTemplateHistoryOrderFieldKey = &NotificationTemplateHistoryOrderField{
		Value: func(_m *NotificationTemplateHistory) (ent.Value, error) {
			return _m.Key, nil
		},
		column: notificationtemplatehistory.FieldKey,
		toTerm: notificationtemplatehistory.ByKey,
		toCursor: func(_m *NotificationTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Key,
			}
		},
	}
	// NotificationTemplateHistoryOrderFieldName orders NotificationTemplateHistory by name.
	NotificationTemplateHistoryOrderFieldName = &NotificationTemplateHistoryOrderField{
		Value: func(_m *NotificationTemplateHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: notificationtemplatehistory.FieldName,
		toTerm: notificationtemplatehistory.ByName,
		toCursor: func(_m *NotificationTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// NotificationTemplateHistoryOrderFieldChannel orders NotificationTemplateHistory by channel.
	NotificationTemplateHistoryOrderFieldChannel = &NotificationTemplateHistoryOrderField{
		Value: func(_m *NotificationTemplateHistory) (ent.Value, error) {
			return _m.Channel, nil
		},
		column: notificationtemplatehistory.FieldChannel,
		toTerm: notificationtemplatehistory.ByChannel,
		toCursor: func(_m *NotificationTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Channel,
			}
		},
	}
	// NotificationTemplateHistoryOrderFieldFormat orders NotificationTemplateHistory by format.
	NotificationTemplateHistoryOrderFieldFormat = &NotificationTemplateHistoryOrderField{
		Value: func(_m *NotificationTemplateHistory) (ent.Value, error) {
			return _m.Format, nil
		},
		column: notificationtemplatehistory.FieldFormat,
		toTerm: notificationtemplatehistory.ByFormat,
		toCursor: func(_m *NotificationTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Format,
			}
		},
	}
	// NotificationTemplateHistoryOrderFieldLocale orders NotificationTemplateHistory by locale.
	NotificationTemplateHistoryOrderFieldLocale = &NotificationTemplateHistoryOrderField{
		Value: func(_m *NotificationTemplateHistory) (ent.Value, error) {
			return _m.Locale, nil
		},
		column: notificationtemplatehistory.FieldLocale,
		toTerm: notificationtemplatehistory.ByLocale,
		toCursor: func(_m *NotificationTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Locale,
			}
		},
	}
	// NotificationTemplateHistoryOrderFieldTopicPattern orders NotificationTemplateHistory by topic_pattern.
	NotificationTemplateHistoryOrderFieldTopicPattern = &NotificationTemplateHistoryOrderField{
		Value: func(_m *NotificationTemplateHistory) (ent.Value, error) {
			return _m.TopicPattern, nil
		},
		column: notificationtemplatehistory.FieldTopicPattern,
		toTerm: notificationtemplatehistory.ByTopicPattern,
		toCursor: func(_m *NotificationTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.TopicPattern,
			}
		},
	}
	// NotificationTemplateHistoryOrderFieldActive orders NotificationTemplateHistory by active.
	NotificationTemplateHistoryOrderFieldActive = &NotificationTemplateHistoryOrderField{
		Value: func(_m *NotificationTemplateHistory) (ent.Value, error) {
			return _m.Active, nil
		},
		column: notificationtemplatehistory.FieldActive,
		toTerm: notificationtemplatehistory.ByActive,
		toCursor: func(_m *NotificationTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Active,
			}
		},
	}
	// NotificationTemplateHistoryOrderFieldVersion orders NotificationTemplateHistory by version.
	NotificationTemplateHistoryOrderFieldVersion = &NotificationTemplateHistoryOrderField{
		Value: func(_m *NotificationTemplateHistory) (ent.Value, error) {
			return _m.Version, nil
		},
		column: notificationtemplatehistory.FieldVersion,
		toTerm: notificationtemplatehistory.ByVersion,
		toCursor: func(_m *NotificationTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Version,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NotificationTemplateHistoryOrderField) String() string {
	var str string
	switch f.column {
	case NotificationTemplateHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case NotificationTemplateHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case NotificationTemplateHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case NotificationTemplateHistoryOrderFieldKey.column:
		str = "KEY"
	case NotificationTemplateHistoryOrderFieldName.column:
		str = "NAME"
	case NotificationTemplateHistoryOrderFieldChannel.column:
		str = "CHANNEL"
	case NotificationTemplateHistoryOrderFieldFormat.column:
		str = "FORMAT"
	case NotificationTemplateHistoryOrderFieldLocale.column:
		str = "LOCALE"
	case NotificationTemplateHistoryOrderFieldTopicPattern.column:
		str = "TOPIC_PATTERN"
	case NotificationTemplateHistoryOrderFieldActive.column:
		str = "ACTIVE"
	case NotificationTemplateHistoryOrderFieldVersion.column:
		str = "VERSION"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NotificationTemplateHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NotificationTemplateHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NotificationTemplateHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *NotificationTemplateHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *NotificationTemplateHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *NotificationTemplateHistoryOrderFieldUpdatedAt
	case "KEY":
		*f = *NotificationTemplateHistoryOrderFieldKey
	case "NAME":
		*f = *NotificationTemplateHistoryOrderFieldName
	case "CHANNEL":
		*f = *NotificationTemplateHistoryOrderFieldChannel
	case "FORMAT":
		*f = *NotificationTemplateHistoryOrderFieldFormat
	case "LOCALE":
		*f = *NotificationTemplateHistoryOrderFieldLocale
	case "TOPIC_PATTERN":
		*f = *NotificationTemplateHistoryOrderFieldTopicPattern
	case "ACTIVE":
		*f = *NotificationTemplateHistoryOrderFieldActive
	case "VERSION":
		*f = *NotificationTemplateHistoryOrderFieldVersion
	default:
		return fmt.Errorf("%s is not a valid NotificationTemplateHistoryOrderField", str)
	}
	return nil
}

// NotificationTemplateHistoryOrderField defines the ordering field of NotificationTemplateHistory.
type NotificationTemplateHistoryOrderField struct {
	// Value extracts the ordering value from the given NotificationTemplateHistory.
	Value    func(*NotificationTemplateHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) notificationtemplatehistory.OrderOption
	toCursor func(*NotificationTemplateHistory) Cursor
}

// NotificationTemplateHistoryOrder defines the ordering of NotificationTemplateHistory.
type NotificationTemplateHistoryOrder struct {
	Direction OrderDirection                         `json:"direction"`
	Field     *NotificationTemplateHistoryOrderField `json:"field"`
}

// DefaultNotificationTemplateHistoryOrder is the default ordering of NotificationTemplateHistory.
var DefaultNotificationTemplateHistoryOrder = &NotificationTemplateHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NotificationTemplateHistoryOrderField{
		Value: func(_m *NotificationTemplateHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: notificationtemplatehistory.FieldID,
		toTerm: notificationtemplatehistory.ByID,
		toCursor: func(_m *NotificationTemplateHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts NotificationTemplateHistory into NotificationTemplateHistoryEdge.
func (_m *NotificationTemplateHistory) ToEdge(order *NotificationTemplateHistoryOrder) *NotificationTemplateHistoryEdge {
	if order == nil {
		order = DefaultNotificationTemplateHistoryOrder
	}
	return &NotificationTemplateHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrgMembershipHistoryEdge is the edge representation of OrgMembershipHistory.
type OrgMembershipHistoryEdge struct {
	Node   *OrgMembershipHistory `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// OrgMembershipHistoryConnection is the connection containing edges to OrgMembershipHistory.
type OrgMembershipHistoryConnection struct {
	Edges      []*OrgMembershipHistoryEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *OrgMembershipHistoryConnection) build(nodes []*OrgMembershipHistory, pager *orgmembershiphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrgMembershipHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgMembershipHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgMembershipHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgMembershipHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgMembershipHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgMembershipHistoryPaginateOption enables pagination customization.
type OrgMembershipHistoryPaginateOption func(*orgmembershiphistoryPager) error

// WithOrgMembershipHistoryOrder configures pagination ordering.
func WithOrgMembershipHistoryOrder(order *OrgMembershipHistoryOrder) OrgMembershipHistoryPaginateOption {
	if order == nil {
		order = DefaultOrgMembershipHistoryOrder
	}
	o := *order
	return func(pager *orgmembershiphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrgMembershipHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrgMembershipHistoryFilter configures pagination filter.
func WithOrgMembershipHistoryFilter(filter func(*OrgMembershipHistoryQuery) (*OrgMembershipHistoryQuery, error)) OrgMembershipHistoryPaginateOption {
	return func(pager *orgmembershiphistoryPager) error {
		if filter == nil {
			return errors.New("OrgMembershipHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orgmembershiphistoryPager struct {
	reverse bool
	order   *OrgMembershipHistoryOrder
	filter  func(*OrgMembershipHistoryQuery) (*OrgMembershipHistoryQuery, error)
}

func newOrgMembershipHistoryPager(opts []OrgMembershipHistoryPaginateOption, reverse bool) (*orgmembershiphistoryPager, error) {
	pager := &orgmembershiphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrgMembershipHistoryOrder
	}
	return pager, nil
}

func (p *orgmembershiphistoryPager) applyFilter(query *OrgMembershipHistoryQuery) (*OrgMembershipHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orgmembershiphistoryPager) toCursor(_m *OrgMembershipHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *orgmembershiphistoryPager) applyCursors(query *OrgMembershipHistoryQuery, after, before *Cursor) (*OrgMembershipHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrgMembershipHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orgmembershiphistoryPager) applyOrder(query *OrgMembershipHistoryQuery) *OrgMembershipHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrgMembershipHistoryOrder.Field {
		query = query.Order(DefaultOrgMembershipHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orgmembershiphistoryPager) orderExpr(query *OrgMembershipHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrgMembershipHistoryOrder.Field {
			b.Comma().Ident(DefaultOrgMembershipHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgMembershipHistory.
func (_m *OrgMembershipHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgMembershipHistoryPaginateOption,
) (*OrgMembershipHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgMembershipHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrgMembershipHistoryConnection{Edges: []*OrgMembershipHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrgMembershipHistoryOrderFieldHistoryTime orders OrgMembershipHistory by history_time.
	OrgMembershipHistoryOrderFieldHistoryTime = &OrgMembershipHistoryOrderField{
		Value: func(_m *OrgMembershipHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: orgmembershiphistory.FieldHistoryTime,
		toTerm: orgmembershiphistory.ByHistoryTime,
		toCursor: func(_m *OrgMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// OrgMembershipHistoryOrderFieldCreatedAt orders OrgMembershipHistory by created_at.
	OrgMembershipHistoryOrderFieldCreatedAt = &OrgMembershipHistoryOrderField{
		Value: func(_m *OrgMembershipHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: orgmembershiphistory.FieldCreatedAt,
		toTerm: orgmembershiphistory.ByCreatedAt,
		toCursor: func(_m *OrgMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrgMembershipHistoryOrderFieldUpdatedAt orders OrgMembershipHistory by updated_at.
	OrgMembershipHistoryOrderFieldUpdatedAt = &OrgMembershipHistoryOrderField{
		Value: func(_m *OrgMembershipHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: orgmembershiphistory.FieldUpdatedAt,
		toTerm: orgmembershiphistory.ByUpdatedAt,
		toCursor: func(_m *OrgMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// OrgMembershipHistoryOrderFieldRole orders OrgMembershipHistory by role.
	OrgMembershipHistoryOrderFieldRole = &OrgMembershipHistoryOrderField{
		Value: func(_m *OrgMembershipHistory) (ent.Value, error) {
			return _m.Role, nil
		},
		column: orgmembershiphistory.FieldRole,
		toTerm: orgmembershiphistory.ByRole,
		toCursor: func(_m *OrgMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrgMembershipHistoryOrderField) String() string {
	var str string
	switch f.column {
	case OrgMembershipHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case OrgMembershipHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case OrgMembershipHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrgMembershipHistoryOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrgMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrgMembershipHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrgMembershipHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *OrgMembershipHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *OrgMembershipHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *OrgMembershipHistoryOrderFieldUpdatedAt
	case "ROLE":
		*f = *OrgMembershipHistoryOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid OrgMembershipHistoryOrderField", str)
	}
	return nil
}

// OrgMembershipHistoryOrderField defines the ordering field of OrgMembershipHistory.
type OrgMembershipHistoryOrderField struct {
	// Value extracts the ordering value from the given OrgMembershipHistory.
	Value    func(*OrgMembershipHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orgmembershiphistory.OrderOption
	toCursor func(*OrgMembershipHistory) Cursor
}

// OrgMembershipHistoryOrder defines the ordering of OrgMembershipHistory.
type OrgMembershipHistoryOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *OrgMembershipHistoryOrderField `json:"field"`
}

// DefaultOrgMembershipHistoryOrder is the default ordering of OrgMembershipHistory.
var DefaultOrgMembershipHistoryOrder = &OrgMembershipHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgMembershipHistoryOrderField{
		Value: func(_m *OrgMembershipHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: orgmembershiphistory.FieldID,
		toTerm: orgmembershiphistory.ByID,
		toCursor: func(_m *OrgMembershipHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts OrgMembershipHistory into OrgMembershipHistoryEdge.
func (_m *OrgMembershipHistory) ToEdge(order *OrgMembershipHistoryOrder) *OrgMembershipHistoryEdge {
	if order == nil {
		order = DefaultOrgMembershipHistoryOrder
	}
	return &OrgMembershipHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrgSubscriptionHistoryEdge is the edge representation of OrgSubscriptionHistory.
type OrgSubscriptionHistoryEdge struct {
	Node   *OrgSubscriptionHistory `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// OrgSubscriptionHistoryConnection is the connection containing edges to OrgSubscriptionHistory.
type OrgSubscriptionHistoryConnection struct {
	Edges      []*OrgSubscriptionHistoryEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *OrgSubscriptionHistoryConnection) build(nodes []*OrgSubscriptionHistory, pager *orgsubscriptionhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrgSubscriptionHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgSubscriptionHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgSubscriptionHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgSubscriptionHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgSubscriptionHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgSubscriptionHistoryPaginateOption enables pagination customization.
type OrgSubscriptionHistoryPaginateOption func(*orgsubscriptionhistoryPager) error

// WithOrgSubscriptionHistoryOrder configures pagination ordering.
func WithOrgSubscriptionHistoryOrder(order *OrgSubscriptionHistoryOrder) OrgSubscriptionHistoryPaginateOption {
	if order == nil {
		order = DefaultOrgSubscriptionHistoryOrder
	}
	o := *order
	return func(pager *orgsubscriptionhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrgSubscriptionHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrgSubscriptionHistoryFilter configures pagination filter.
func WithOrgSubscriptionHistoryFilter(filter func(*OrgSubscriptionHistoryQuery) (*OrgSubscriptionHistoryQuery, error)) OrgSubscriptionHistoryPaginateOption {
	return func(pager *orgsubscriptionhistoryPager) error {
		if filter == nil {
			return errors.New("OrgSubscriptionHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orgsubscriptionhistoryPager struct {
	reverse bool
	order   *OrgSubscriptionHistoryOrder
	filter  func(*OrgSubscriptionHistoryQuery) (*OrgSubscriptionHistoryQuery, error)
}

func newOrgSubscriptionHistoryPager(opts []OrgSubscriptionHistoryPaginateOption, reverse bool) (*orgsubscriptionhistoryPager, error) {
	pager := &orgsubscriptionhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrgSubscriptionHistoryOrder
	}
	return pager, nil
}

func (p *orgsubscriptionhistoryPager) applyFilter(query *OrgSubscriptionHistoryQuery) (*OrgSubscriptionHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orgsubscriptionhistoryPager) toCursor(_m *OrgSubscriptionHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *orgsubscriptionhistoryPager) applyCursors(query *OrgSubscriptionHistoryQuery, after, before *Cursor) (*OrgSubscriptionHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrgSubscriptionHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orgsubscriptionhistoryPager) applyOrder(query *OrgSubscriptionHistoryQuery) *OrgSubscriptionHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrgSubscriptionHistoryOrder.Field {
		query = query.Order(DefaultOrgSubscriptionHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orgsubscriptionhistoryPager) orderExpr(query *OrgSubscriptionHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrgSubscriptionHistoryOrder.Field {
			b.Comma().Ident(DefaultOrgSubscriptionHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgSubscriptionHistory.
func (_m *OrgSubscriptionHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgSubscriptionHistoryPaginateOption,
) (*OrgSubscriptionHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgSubscriptionHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrgSubscriptionHistoryConnection{Edges: []*OrgSubscriptionHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrgSubscriptionHistoryOrderFieldHistoryTime orders OrgSubscriptionHistory by history_time.
	OrgSubscriptionHistoryOrderFieldHistoryTime = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: orgsubscriptionhistory.FieldHistoryTime,
		toTerm: orgsubscriptionhistory.ByHistoryTime,
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldCreatedAt orders OrgSubscriptionHistory by created_at.
	OrgSubscriptionHistoryOrderFieldCreatedAt = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: orgsubscriptionhistory.FieldCreatedAt,
		toTerm: orgsubscriptionhistory.ByCreatedAt,
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldUpdatedAt orders OrgSubscriptionHistory by updated_at.
	OrgSubscriptionHistoryOrderFieldUpdatedAt = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: orgsubscriptionhistory.FieldUpdatedAt,
		toTerm: orgsubscriptionhistory.ByUpdatedAt,
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus orders OrgSubscriptionHistory by stripe_subscription_status.
	OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			return _m.StripeSubscriptionStatus, nil
		},
		column: orgsubscriptionhistory.FieldStripeSubscriptionStatus,
		toTerm: orgsubscriptionhistory.ByStripeSubscriptionStatus,
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StripeSubscriptionStatus,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldActive orders OrgSubscriptionHistory by active.
	OrgSubscriptionHistoryOrderFieldActive = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			return _m.Active, nil
		},
		column: orgsubscriptionhistory.FieldActive,
		toTerm: orgsubscriptionhistory.ByActive,
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Active,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldExpiresAt orders OrgSubscriptionHistory by expires_at.
	OrgSubscriptionHistoryOrderFieldExpiresAt = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExpiresAt == nil {
				return nil, nil
			}
			return _m.ExpiresAt, nil
		},
		column: orgsubscriptionhistory.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscriptionhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscriptionhistory.ByExpiresAt(opts...)
		},
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			if _m.ExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExpiresAt,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldTrialExpiresAt orders OrgSubscriptionHistory by trial_expires_at.
	OrgSubscriptionHistoryOrderFieldTrialExpiresAt = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.TrialExpiresAt == nil {
				return nil, nil
			}
			return _m.TrialExpiresAt, nil
		},
		column: orgsubscriptionhistory.FieldTrialExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscriptionhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscriptionhistory.ByTrialExpiresAt(opts...)
		},
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			if _m.TrialExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.TrialExpiresAt,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldDaysUntilDue orders OrgSubscriptionHistory by days_until_due.
	OrgSubscriptionHistoryOrderFieldDaysUntilDue = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.DaysUntilDue == nil {
				return nil, nil
			}
			return _m.DaysUntilDue, nil
		},
		column: orgsubscriptionhistory.FieldDaysUntilDue,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscriptionhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscriptionhistory.ByDaysUntilDue(opts...)
		},
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			if _m.DaysUntilDue == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.DaysUntilDue,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrgSubscriptionHistoryOrderField) String() string {
	var str string
	switch f.column {
	case OrgSubscriptionHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case OrgSubscriptionHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case OrgSubscriptionHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus.column:
		str = "stripe_subscription_status"
	case OrgSubscriptionHistoryOrderFieldActive.column:
		str = "active"
	case OrgSubscriptionHistoryOrderFieldExpiresAt.column:
		str = "expires_at"
	case OrgSubscriptionHistoryOrderFieldTrialExpiresAt.column:
		str = "trial_expires_at"
	case OrgSubscriptionHistoryOrderFieldDaysUntilDue.column:
		str = "days_until_due"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrgSubscriptionHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrgSubscriptionHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrgSubscriptionHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *OrgSubscriptionHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *OrgSubscriptionHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *OrgSubscriptionHistoryOrderFieldUpdatedAt
	case "stripe_subscription_status":
		*f = *OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus
	case "active":
		*f = *OrgSubscriptionHistoryOrderFieldActive
	case "expires_at":
		*f = *OrgSubscriptionHistoryOrderFieldExpiresAt
	case "trial_expires_at":
		*f = *OrgSubscriptionHistoryOrderFieldTrialExpiresAt
	case "days_until_due":
		*f = *OrgSubscriptionHistoryOrderFieldDaysUntilDue
	default:
		return fmt.Errorf("%s is not a valid OrgSubscriptionHistoryOrderField", str)
	}
	return nil
}

// OrgSubscriptionHistoryOrderField defines the ordering field of OrgSubscriptionHistory.
type OrgSubscriptionHistoryOrderField struct {
	// Value extracts the ordering value from the given OrgSubscriptionHistory.
	Value    func(*OrgSubscriptionHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orgsubscriptionhistory.OrderOption
	toCursor func(*OrgSubscriptionHistory) Cursor
}

// OrgSubscriptionHistoryOrder defines the ordering of OrgSubscriptionHistory.
type OrgSubscriptionHistoryOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *OrgSubscriptionHistoryOrderField `json:"field"`
}

// DefaultOrgSubscriptionHistoryOrder is the default ordering of OrgSubscriptionHistory.
var DefaultOrgSubscriptionHistoryOrder = &OrgSubscriptionHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: orgsubscriptionhistory.FieldID,
		toTerm: orgsubscriptionhistory.ByID,
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts OrgSubscriptionHistory into OrgSubscriptionHistoryEdge.
func (_m *OrgSubscriptionHistory) ToEdge(order *OrgSubscriptionHistoryOrder) *OrgSubscriptionHistoryEdge {
	if order == nil {
		order = DefaultOrgSubscriptionHistoryOrder
	}
	return &OrgSubscriptionHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrganizationHistoryEdge is the edge representation of OrganizationHistory.
type OrganizationHistoryEdge struct {
	Node   *OrganizationHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// OrganizationHistoryConnection is the connection containing edges to OrganizationHistory.
type OrganizationHistoryConnection struct {
	Edges      []*OrganizationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *OrganizationHistoryConnection) build(nodes []*OrganizationHistory, pager *organizationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrganizationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrganizationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrganizationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationHistoryPaginateOption enables pagination customization.
type OrganizationHistoryPaginateOption func(*organizationhistoryPager) error

// WithOrganizationHistoryOrder configures pagination ordering.
func WithOrganizationHistoryOrder(order *OrganizationHistoryOrder) OrganizationHistoryPaginateOption {
	if order == nil {
		order = DefaultOrganizationHistoryOrder
	}
	o := *order
	return func(pager *organizationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationHistoryFilter configures pagination filter.
func WithOrganizationHistoryFilter(filter func(*OrganizationHistoryQuery) (*OrganizationHistoryQuery, error)) OrganizationHistoryPaginateOption {
	return func(pager *organizationhistoryPager) error {
		if filter == nil {
			return errors.New("OrganizationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationhistoryPager struct {
	reverse bool
	order   *OrganizationHistoryOrder
	filter  func(*OrganizationHistoryQuery) (*OrganizationHistoryQuery, error)
}

func newOrganizationHistoryPager(opts []OrganizationHistoryPaginateOption, reverse bool) (*organizationhistoryPager, error) {
	pager := &organizationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationHistoryOrder
	}
	return pager, nil
}

func (p *organizationhistoryPager) applyFilter(query *OrganizationHistoryQuery) (*OrganizationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationhistoryPager) toCursor(_m *OrganizationHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *organizationhistoryPager) applyCursors(query *OrganizationHistoryQuery, after, before *Cursor) (*OrganizationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrganizationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *organizationhistoryPager) applyOrder(query *OrganizationHistoryQuery) *OrganizationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrganizationHistoryOrder.Field {
		query = query.Order(DefaultOrganizationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *organizationhistoryPager) orderExpr(query *OrganizationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrganizationHistoryOrder.Field {
			b.Comma().Ident(DefaultOrganizationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrganizationHistory.
func (_m *OrganizationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationHistoryPaginateOption,
) (*OrganizationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrganizationHistoryConnection{Edges: []*OrganizationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationHistoryOrderFieldHistoryTime orders OrganizationHistory by history_time.
	OrganizationHistoryOrderFieldHistoryTime = &OrganizationHistoryOrderField{
		Value: func(_m *OrganizationHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: organizationhistory.FieldHistoryTime,
		toTerm: organizationhistory.ByHistoryTime,
		toCursor: func(_m *OrganizationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// OrganizationHistoryOrderFieldCreatedAt orders OrganizationHistory by created_at.
	OrganizationHistoryOrderFieldCreatedAt = &OrganizationHistoryOrderField{
		Value: func(_m *OrganizationHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: organizationhistory.FieldCreatedAt,
		toTerm: organizationhistory.ByCreatedAt,
		toCursor: func(_m *OrganizationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrganizationHistoryOrderFieldUpdatedAt orders OrganizationHistory by updated_at.
	OrganizationHistoryOrderFieldUpdatedAt = &OrganizationHistoryOrderField{
		Value: func(_m *OrganizationHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: organizationhistory.FieldUpdatedAt,
		toTerm: organizationhistory.ByUpdatedAt,
		toCursor: func(_m *OrganizationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// OrganizationHistoryOrderFieldName orders OrganizationHistory by name.
	OrganizationHistoryOrderFieldName = &OrganizationHistoryOrderField{
		Value: func(_m *OrganizationHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: organizationhistory.FieldName,
		toTerm: organizationhistory.ByName,
		toCursor: func(_m *OrganizationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// OrganizationHistoryOrderFieldDisplayName orders OrganizationHistory by display_name.
	OrganizationHistoryOrderFieldDisplayName = &OrganizationHistoryOrderField{
		Value: func(_m *OrganizationHistory) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: organizationhistory.FieldDisplayName,
		toTerm: organizationhistory.ByDisplayName,
		toCursor: func(_m *OrganizationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case OrganizationHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case OrganizationHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrganizationHistoryOrderFieldName.column:
		str = "name"
	case OrganizationHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *OrganizationHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *OrganizationHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *OrganizationHistoryOrderFieldUpdatedAt
	case "name":
		*f = *OrganizationHistoryOrderFieldName
	case "display_name":
		*f = *OrganizationHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid OrganizationHistoryOrderField", str)
	}
	return nil
}

// OrganizationHistoryOrderField defines the ordering field of OrganizationHistory.
type OrganizationHistoryOrderField struct {
	// Value extracts the ordering value from the given OrganizationHistory.
	Value    func(*OrganizationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organizationhistory.OrderOption
	toCursor func(*OrganizationHistory) Cursor
}

// OrganizationHistoryOrder defines the ordering of OrganizationHistory.
type OrganizationHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *OrganizationHistoryOrderField `json:"field"`
}

// DefaultOrganizationHistoryOrder is the default ordering of OrganizationHistory.
var DefaultOrganizationHistoryOrder = &OrganizationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationHistoryOrderField{
		Value: func(_m *OrganizationHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: organizationhistory.FieldID,
		toTerm: organizationhistory.ByID,
		toCursor: func(_m *OrganizationHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts OrganizationHistory into OrganizationHistoryEdge.
func (_m *OrganizationHistory) ToEdge(order *OrganizationHistoryOrder) *OrganizationHistoryEdge {
	if order == nil {
		order = DefaultOrganizationHistoryOrder
	}
	return &OrganizationHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrganizationSettingHistoryEdge is the edge representation of OrganizationSettingHistory.
type OrganizationSettingHistoryEdge struct {
	Node   *OrganizationSettingHistory `json:"node"`
	Cursor Cursor                      `json:"cursor"`
}

// OrganizationSettingHistoryConnection is the connection containing edges to OrganizationSettingHistory.
type OrganizationSettingHistoryConnection struct {
	Edges      []*OrganizationSettingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                          `json:"pageInfo"`
	TotalCount int                               `json:"totalCount"`
}

func (c *OrganizationSettingHistoryConnection) build(nodes []*OrganizationSettingHistory, pager *organizationsettinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrganizationSettingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrganizationSettingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrganizationSettingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationSettingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationSettingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationSettingHistoryPaginateOption enables pagination customization.
type OrganizationSettingHistoryPaginateOption func(*organizationsettinghistoryPager) error

// WithOrganizationSettingHistoryOrder configures pagination ordering.
func WithOrganizationSettingHistoryOrder(order *OrganizationSettingHistoryOrder) OrganizationSettingHistoryPaginateOption {
	if order == nil {
		order = DefaultOrganizationSettingHistoryOrder
	}
	o := *order
	return func(pager *organizationsettinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationSettingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationSettingHistoryFilter configures pagination filter.
func WithOrganizationSettingHistoryFilter(filter func(*OrganizationSettingHistoryQuery) (*OrganizationSettingHistoryQuery, error)) OrganizationSettingHistoryPaginateOption {
	return func(pager *organizationsettinghistoryPager) error {
		if filter == nil {
			return errors.New("OrganizationSettingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationsettinghistoryPager struct {
	reverse bool
	order   *OrganizationSettingHistoryOrder
	filter  func(*OrganizationSettingHistoryQuery) (*OrganizationSettingHistoryQuery, error)
}

func newOrganizationSettingHistoryPager(opts []OrganizationSettingHistoryPaginateOption, reverse bool) (*organizationsettinghistoryPager, error) {
	pager := &organizationsettinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationSettingHistoryOrder
	}
	return pager, nil
}

func (p *organizationsettinghistoryPager) applyFilter(query *OrganizationSettingHistoryQuery) (*OrganizationSettingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationsettinghistoryPager) toCursor(_m *OrganizationSettingHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *organizationsettinghistoryPager) applyCursors(query *OrganizationSettingHistoryQuery, after, before *Cursor) (*OrganizationSettingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrganizationSettingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *organizationsettinghistoryPager) applyOrder(query *OrganizationSettingHistoryQuery) *OrganizationSettingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrganizationSettingHistoryOrder.Field {
		query = query.Order(DefaultOrganizationSettingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *organizationsettinghistoryPager) orderExpr(query *OrganizationSettingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrganizationSettingHistoryOrder.Field {
			b.Comma().Ident(DefaultOrganizationSettingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrganizationSettingHistory.
func (_m *OrganizationSettingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationSettingHistoryPaginateOption,
) (*OrganizationSettingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationSettingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrganizationSettingHistoryConnection{Edges: []*OrganizationSettingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationSettingHistoryOrderFieldHistoryTime orders OrganizationSettingHistory by history_time.
	OrganizationSettingHistoryOrderFieldHistoryTime = &OrganizationSettingHistoryOrderField{
		Value: func(_m *OrganizationSettingHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: organizationsettinghistory.FieldHistoryTime,
		toTerm: organizationsettinghistory.ByHistoryTime,
		toCursor: func(_m *OrganizationSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// OrganizationSettingHistoryOrderFieldCreatedAt orders OrganizationSettingHistory by created_at.
	OrganizationSettingHistoryOrderFieldCreatedAt = &OrganizationSettingHistoryOrderField{
		Value: func(_m *OrganizationSettingHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: organizationsettinghistory.FieldCreatedAt,
		toTerm: organizationsettinghistory.ByCreatedAt,
		toCursor: func(_m *OrganizationSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrganizationSettingHistoryOrderFieldUpdatedAt orders OrganizationSettingHistory by updated_at.
	OrganizationSettingHistoryOrderFieldUpdatedAt = &OrganizationSettingHistoryOrderField{
		Value: func(_m *OrganizationSettingHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: organizationsettinghistory.FieldUpdatedAt,
		toTerm: organizationsettinghistory.ByUpdatedAt,
		toCursor: func(_m *OrganizationSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationSettingHistoryOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationSettingHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case OrganizationSettingHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case OrganizationSettingHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationSettingHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationSettingHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *OrganizationSettingHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *OrganizationSettingHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *OrganizationSettingHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid OrganizationSettingHistoryOrderField", str)
	}
	return nil
}

// OrganizationSettingHistoryOrderField defines the ordering field of OrganizationSettingHistory.
type OrganizationSettingHistoryOrderField struct {
	// Value extracts the ordering value from the given OrganizationSettingHistory.
	Value    func(*OrganizationSettingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organizationsettinghistory.OrderOption
	toCursor func(*OrganizationSettingHistory) Cursor
}

// OrganizationSettingHistoryOrder defines the ordering of OrganizationSettingHistory.
type OrganizationSettingHistoryOrder struct {
	Direction OrderDirection                        `json:"direction"`
	Field     *OrganizationSettingHistoryOrderField `json:"field"`
}

// DefaultOrganizationSettingHistoryOrder is the default ordering of OrganizationSettingHistory.
var DefaultOrganizationSettingHistoryOrder = &OrganizationSettingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationSettingHistoryOrderField{
		Value: func(_m *OrganizationSettingHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: organizationsettinghistory.FieldID,
		toTerm: organizationsettinghistory.ByID,
		toCursor: func(_m *OrganizationSettingHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts OrganizationSettingHistory into OrganizationSettingHistoryEdge.
func (_m *OrganizationSettingHistory) ToEdge(order *OrganizationSettingHistoryOrder) *OrganizationSettingHistoryEdge {
	if order == nil {
		order = DefaultOrganizationSettingHistoryOrder
	}
	return &OrganizationSettingHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// PlatformHistoryEdge is the edge representation of PlatformHistory.
type PlatformHistoryEdge struct {
	Node   *PlatformHistory `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// PlatformHistoryConnection is the connection containing edges to PlatformHistory.
type PlatformHistoryConnection struct {
	Edges      []*PlatformHistoryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *PlatformHistoryConnection) build(nodes []*PlatformHistory, pager *platformhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *PlatformHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PlatformHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PlatformHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*PlatformHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PlatformHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PlatformHistoryPaginateOption enables pagination customization.
type PlatformHistoryPaginateOption func(*platformhistoryPager) error

// WithPlatformHistoryOrder configures pagination ordering.
func WithPlatformHistoryOrder(order *PlatformHistoryOrder) PlatformHistoryPaginateOption {
	if order == nil {
		order = DefaultPlatformHistoryOrder
	}
	o := *order
	return func(pager *platformhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlatformHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlatformHistoryFilter configures pagination filter.
func WithPlatformHistoryFilter(filter func(*PlatformHistoryQuery) (*PlatformHistoryQuery, error)) PlatformHistoryPaginateOption {
	return func(pager *platformhistoryPager) error {
		if filter == nil {
			return errors.New("PlatformHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type platformhistoryPager struct {
	reverse bool
	order   *PlatformHistoryOrder
	filter  func(*PlatformHistoryQuery) (*PlatformHistoryQuery, error)
}

func newPlatformHistoryPager(opts []PlatformHistoryPaginateOption, reverse bool) (*platformhistoryPager, error) {
	pager := &platformhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlatformHistoryOrder
	}
	return pager, nil
}

func (p *platformhistoryPager) applyFilter(query *PlatformHistoryQuery) (*PlatformHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *platformhistoryPager) toCursor(_m *PlatformHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *platformhistoryPager) applyCursors(query *PlatformHistoryQuery, after, before *Cursor) (*PlatformHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPlatformHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *platformhistoryPager) applyOrder(query *PlatformHistoryQuery) *PlatformHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPlatformHistoryOrder.Field {
		query = query.Order(DefaultPlatformHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *platformhistoryPager) orderExpr(query *PlatformHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPlatformHistoryOrder.Field {
			b.Comma().Ident(DefaultPlatformHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PlatformHistory.
func (_m *PlatformHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlatformHistoryPaginateOption,
) (*PlatformHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlatformHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &PlatformHistoryConnection{Edges: []*PlatformHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PlatformHistoryOrderFieldHistoryTime orders PlatformHistory by history_time.
	PlatformHistoryOrderFieldHistoryTime = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: platformhistory.FieldHistoryTime,
		toTerm: platformhistory.ByHistoryTime,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// PlatformHistoryOrderFieldCreatedAt orders PlatformHistory by created_at.
	PlatformHistoryOrderFieldCreatedAt = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: platformhistory.FieldCreatedAt,
		toTerm: platformhistory.ByCreatedAt,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// PlatformHistoryOrderFieldUpdatedAt orders PlatformHistory by updated_at.
	PlatformHistoryOrderFieldUpdatedAt = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: platformhistory.FieldUpdatedAt,
		toTerm: platformhistory.ByUpdatedAt,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// PlatformHistoryOrderFieldInternalOwner orders PlatformHistory by internal_owner.
	PlatformHistoryOrderFieldInternalOwner = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.InternalOwner, nil
		},
		column: platformhistory.FieldInternalOwner,
		toTerm: platformhistory.ByInternalOwner,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.InternalOwner,
			}
		},
	}
	// PlatformHistoryOrderFieldBusinessOwner orders PlatformHistory by business_owner.
	PlatformHistoryOrderFieldBusinessOwner = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.BusinessOwner, nil
		},
		column: platformhistory.FieldBusinessOwner,
		toTerm: platformhistory.ByBusinessOwner,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.BusinessOwner,
			}
		},
	}
	// PlatformHistoryOrderFieldTechnicalOwner orders PlatformHistory by technical_owner.
	PlatformHistoryOrderFieldTechnicalOwner = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.TechnicalOwner, nil
		},
		column: platformhistory.FieldTechnicalOwner,
		toTerm: platformhistory.ByTechnicalOwner,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.TechnicalOwner,
			}
		},
	}
	// PlatformHistoryOrderFieldSecurityOwner orders PlatformHistory by security_owner.
	PlatformHistoryOrderFieldSecurityOwner = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.SecurityOwner, nil
		},
		column: platformhistory.FieldSecurityOwner,
		toTerm: platformhistory.BySecurityOwner,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SecurityOwner,
			}
		},
	}
	// PlatformHistoryOrderFieldName orders PlatformHistory by name.
	PlatformHistoryOrderFieldName = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: platformhistory.FieldName,
		toTerm: platformhistory.ByName,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// PlatformHistoryOrderFieldBusinessPurpose orders PlatformHistory by business_purpose.
	PlatformHistoryOrderFieldBusinessPurpose = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.BusinessPurpose, nil
		},
		column: platformhistory.FieldBusinessPurpose,
		toTerm: platformhistory.ByBusinessPurpose,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.BusinessPurpose,
			}
		},
	}
	// PlatformHistoryOrderFieldStatus orders PlatformHistory by status.
	PlatformHistoryOrderFieldStatus = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: platformhistory.FieldStatus,
		toTerm: platformhistory.ByStatus,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// PlatformHistoryOrderFieldPhysicalLocation orders PlatformHistory by physical_location.
	PlatformHistoryOrderFieldPhysicalLocation = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.PhysicalLocation, nil
		},
		column: platformhistory.FieldPhysicalLocation,
		toTerm: platformhistory.ByPhysicalLocation,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.PhysicalLocation,
			}
		},
	}
	// PlatformHistoryOrderFieldRegion orders PlatformHistory by region.
	PlatformHistoryOrderFieldRegion = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.Region, nil
		},
		column: platformhistory.FieldRegion,
		toTerm: platformhistory.ByRegion,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Region,
			}
		},
	}
	// PlatformHistoryOrderFieldContainsPii orders PlatformHistory by contains_pii.
	PlatformHistoryOrderFieldContainsPii = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.ContainsPii, nil
		},
		column: platformhistory.FieldContainsPii,
		toTerm: platformhistory.ByContainsPii,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ContainsPii,
			}
		},
	}
	// PlatformHistoryOrderFieldSourceType orders PlatformHistory by source_type.
	PlatformHistoryOrderFieldSourceType = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.SourceType, nil
		},
		column: platformhistory.FieldSourceType,
		toTerm: platformhistory.BySourceType,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SourceType,
			}
		},
	}
	// PlatformHistoryOrderFieldSourceIdentifier orders PlatformHistory by source_identifier.
	PlatformHistoryOrderFieldSourceIdentifier = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.SourceIdentifier, nil
		},
		column: platformhistory.FieldSourceIdentifier,
		toTerm: platformhistory.BySourceIdentifier,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SourceIdentifier,
			}
		},
	}
	// PlatformHistoryOrderFieldCostCenter orders PlatformHistory by cost_center.
	PlatformHistoryOrderFieldCostCenter = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.CostCenter, nil
		},
		column: platformhistory.FieldCostCenter,
		toTerm: platformhistory.ByCostCenter,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CostCenter,
			}
		},
	}
	// PlatformHistoryOrderFieldEstimatedMonthlyCost orders PlatformHistory by estimated_monthly_cost.
	PlatformHistoryOrderFieldEstimatedMonthlyCost = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.EstimatedMonthlyCost, nil
		},
		column: platformhistory.FieldEstimatedMonthlyCost,
		toTerm: platformhistory.ByEstimatedMonthlyCost,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.EstimatedMonthlyCost,
			}
		},
	}
	// PlatformHistoryOrderFieldPurchaseDate orders PlatformHistory by purchase_date.
	PlatformHistoryOrderFieldPurchaseDate = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.PurchaseDate == nil {
				return nil, nil
			}
			return _m.PurchaseDate, nil
		},
		column: platformhistory.FieldPurchaseDate,
		toTerm: func(opts ...sql.OrderTermOption) platformhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return platformhistory.ByPurchaseDate(opts...)
		},
		toCursor: func(_m *PlatformHistory) Cursor {
			if _m.PurchaseDate == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.PurchaseDate,
			}
		},
	}
	// PlatformHistoryOrderFieldExternalReferenceID orders PlatformHistory by external_reference_id.
	PlatformHistoryOrderFieldExternalReferenceID = &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.ExternalReferenceID, nil
		},
		column: platformhistory.FieldExternalReferenceID,
		toTerm: platformhistory.ByExternalReferenceID,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalReferenceID,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PlatformHistoryOrderField) String() string {
	var str string
	switch f.column {
	case PlatformHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case PlatformHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case PlatformHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case PlatformHistoryOrderFieldInternalOwner.column:
		str = "internal_owner"
	case PlatformHistoryOrderFieldBusinessOwner.column:
		str = "business_owner"
	case PlatformHistoryOrderFieldTechnicalOwner.column:
		str = "technical_owner"
	case PlatformHistoryOrderFieldSecurityOwner.column:
		str = "security_owner"
	case PlatformHistoryOrderFieldName.column:
		str = "name"
	case PlatformHistoryOrderFieldBusinessPurpose.column:
		str = "business_purpose"
	case PlatformHistoryOrderFieldStatus.column:
		str = "STATUS"
	case PlatformHistoryOrderFieldPhysicalLocation.column:
		str = "physical_location"
	case PlatformHistoryOrderFieldRegion.column:
		str = "region"
	case PlatformHistoryOrderFieldContainsPii.column:
		str = "contains_pii"
	case PlatformHistoryOrderFieldSourceType.column:
		str = "SOURCE_TYPE"
	case PlatformHistoryOrderFieldSourceIdentifier.column:
		str = "source_identifier"
	case PlatformHistoryOrderFieldCostCenter.column:
		str = "cost_center"
	case PlatformHistoryOrderFieldEstimatedMonthlyCost.column:
		str = "estimated_monthly_cost"
	case PlatformHistoryOrderFieldPurchaseDate.column:
		str = "purchase_date"
	case PlatformHistoryOrderFieldExternalReferenceID.column:
		str = "external_reference_id"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PlatformHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PlatformHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PlatformHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *PlatformHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *PlatformHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *PlatformHistoryOrderFieldUpdatedAt
	case "internal_owner":
		*f = *PlatformHistoryOrderFieldInternalOwner
	case "business_owner":
		*f = *PlatformHistoryOrderFieldBusinessOwner
	case "technical_owner":
		*f = *PlatformHistoryOrderFieldTechnicalOwner
	case "security_owner":
		*f = *PlatformHistoryOrderFieldSecurityOwner
	case "name":
		*f = *PlatformHistoryOrderFieldName
	case "business_purpose":
		*f = *PlatformHistoryOrderFieldBusinessPurpose
	case "STATUS":
		*f = *PlatformHistoryOrderFieldStatus
	case "physical_location":
		*f = *PlatformHistoryOrderFieldPhysicalLocation
	case "region":
		*f = *PlatformHistoryOrderFieldRegion
	case "contains_pii":
		*f = *PlatformHistoryOrderFieldContainsPii
	case "SOURCE_TYPE":
		*f = *PlatformHistoryOrderFieldSourceType
	case "source_identifier":
		*f = *PlatformHistoryOrderFieldSourceIdentifier
	case "cost_center":
		*f = *PlatformHistoryOrderFieldCostCenter
	case "estimated_monthly_cost":
		*f = *PlatformHistoryOrderFieldEstimatedMonthlyCost
	case "purchase_date":
		*f = *PlatformHistoryOrderFieldPurchaseDate
	case "external_reference_id":
		*f = *PlatformHistoryOrderFieldExternalReferenceID
	default:
		return fmt.Errorf("%s is not a valid PlatformHistoryOrderField", str)
	}
	return nil
}

// PlatformHistoryOrderField defines the ordering field of PlatformHistory.
type PlatformHistoryOrderField struct {
	// Value extracts the ordering value from the given PlatformHistory.
	Value    func(*PlatformHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) platformhistory.OrderOption
	toCursor func(*PlatformHistory) Cursor
}

// PlatformHistoryOrder defines the ordering of PlatformHistory.
type PlatformHistoryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *PlatformHistoryOrderField `json:"field"`
}

// DefaultPlatformHistoryOrder is the default ordering of PlatformHistory.
var DefaultPlatformHistoryOrder = &PlatformHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PlatformHistoryOrderField{
		Value: func(_m *PlatformHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: platformhistory.FieldID,
		toTerm: platformhistory.ByID,
		toCursor: func(_m *PlatformHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts PlatformHistory into PlatformHistoryEdge.
func (_m *PlatformHistory) ToEdge(order *PlatformHistoryOrder) *PlatformHistoryEdge {
	if order == nil {
		order = DefaultPlatformHistoryOrder
	}
	return &PlatformHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ProcedureHistoryEdge is the edge representation of ProcedureHistory.
type ProcedureHistoryEdge struct {
	Node   *ProcedureHistory `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ProcedureHistoryConnection is the connection containing edges to ProcedureHistory.
type ProcedureHistoryConnection struct {
	Edges      []*ProcedureHistoryEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ProcedureHistoryConnection) build(nodes []*ProcedureHistory, pager *procedurehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ProcedureHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProcedureHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProcedureHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProcedureHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProcedureHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProcedureHistoryPaginateOption enables pagination customization.
type ProcedureHistoryPaginateOption func(*procedurehistoryPager) error

// WithProcedureHistoryOrder configures pagination ordering.
func WithProcedureHistoryOrder(order *ProcedureHistoryOrder) ProcedureHistoryPaginateOption {
	if order == nil {
		order = DefaultProcedureHistoryOrder
	}
	o := *order
	return func(pager *procedurehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProcedureHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProcedureHistoryFilter configures pagination filter.
func WithProcedureHistoryFilter(filter func(*ProcedureHistoryQuery) (*ProcedureHistoryQuery, error)) ProcedureHistoryPaginateOption {
	return func(pager *procedurehistoryPager) error {
		if filter == nil {
			return errors.New("ProcedureHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type procedurehistoryPager struct {
	reverse bool
	order   *ProcedureHistoryOrder
	filter  func(*ProcedureHistoryQuery) (*ProcedureHistoryQuery, error)
}

func newProcedureHistoryPager(opts []ProcedureHistoryPaginateOption, reverse bool) (*procedurehistoryPager, error) {
	pager := &procedurehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProcedureHistoryOrder
	}
	return pager, nil
}

func (p *procedurehistoryPager) applyFilter(query *ProcedureHistoryQuery) (*ProcedureHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *procedurehistoryPager) toCursor(_m *ProcedureHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *procedurehistoryPager) applyCursors(query *ProcedureHistoryQuery, after, before *Cursor) (*ProcedureHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProcedureHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *procedurehistoryPager) applyOrder(query *ProcedureHistoryQuery) *ProcedureHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProcedureHistoryOrder.Field {
		query = query.Order(DefaultProcedureHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *procedurehistoryPager) orderExpr(query *ProcedureHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProcedureHistoryOrder.Field {
			b.Comma().Ident(DefaultProcedureHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProcedureHistory.
func (_m *ProcedureHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProcedureHistoryPaginateOption,
) (*ProcedureHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProcedureHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ProcedureHistoryConnection{Edges: []*ProcedureHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProcedureHistoryOrderFieldHistoryTime orders ProcedureHistory by history_time.
	ProcedureHistoryOrderFieldHistoryTime = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: procedurehistory.FieldHistoryTime,
		toTerm: procedurehistory.ByHistoryTime,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ProcedureHistoryOrderFieldCreatedAt orders ProcedureHistory by created_at.
	ProcedureHistoryOrderFieldCreatedAt = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: procedurehistory.FieldCreatedAt,
		toTerm: procedurehistory.ByCreatedAt,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ProcedureHistoryOrderFieldUpdatedAt orders ProcedureHistory by updated_at.
	ProcedureHistoryOrderFieldUpdatedAt = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: procedurehistory.FieldUpdatedAt,
		toTerm: procedurehistory.ByUpdatedAt,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ProcedureHistoryOrderFieldRevision orders ProcedureHistory by revision.
	ProcedureHistoryOrderFieldRevision = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: procedurehistory.FieldRevision,
		toTerm: procedurehistory.ByRevision,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// ProcedureHistoryOrderFieldName orders ProcedureHistory by name.
	ProcedureHistoryOrderFieldName = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: procedurehistory.FieldName,
		toTerm: procedurehistory.ByName,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ProcedureHistoryOrderFieldStatus orders ProcedureHistory by status.
	ProcedureHistoryOrderFieldStatus = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: procedurehistory.FieldStatus,
		toTerm: procedurehistory.ByStatus,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ProcedureHistoryOrderFieldReviewDue orders ProcedureHistory by review_due.
	ProcedureHistoryOrderFieldReviewDue = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.ReviewDue, nil
		},
		column: procedurehistory.FieldReviewDue,
		toTerm: procedurehistory.ByReviewDue,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewDue,
			}
		},
	}
	// ProcedureHistoryOrderFieldReviewFrequency orders ProcedureHistory by review_frequency.
	ProcedureHistoryOrderFieldReviewFrequency = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.ReviewFrequency, nil
		},
		column: procedurehistory.FieldReviewFrequency,
		toTerm: procedurehistory.ByReviewFrequency,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewFrequency,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProcedureHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ProcedureHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ProcedureHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ProcedureHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProcedureHistoryOrderFieldRevision.column:
		str = "revision"
	case ProcedureHistoryOrderFieldName.column:
		str = "name"
	case ProcedureHistoryOrderFieldStatus.column:
		str = "STATUS"
	case ProcedureHistoryOrderFieldReviewDue.column:
		str = "review_due"
	case ProcedureHistoryOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProcedureHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProcedureHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProcedureHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ProcedureHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ProcedureHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ProcedureHistoryOrderFieldUpdatedAt
	case "revision":
		*f = *ProcedureHistoryOrderFieldRevision
	case "name":
		*f = *ProcedureHistoryOrderFieldName
	case "STATUS":
		*f = *ProcedureHistoryOrderFieldStatus
	case "review_due":
		*f = *ProcedureHistoryOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *ProcedureHistoryOrderFieldReviewFrequency
	default:
		return fmt.Errorf("%s is not a valid ProcedureHistoryOrderField", str)
	}
	return nil
}

// ProcedureHistoryOrderField defines the ordering field of ProcedureHistory.
type ProcedureHistoryOrderField struct {
	// Value extracts the ordering value from the given ProcedureHistory.
	Value    func(*ProcedureHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) procedurehistory.OrderOption
	toCursor func(*ProcedureHistory) Cursor
}

// ProcedureHistoryOrder defines the ordering of ProcedureHistory.
type ProcedureHistoryOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ProcedureHistoryOrderField `json:"field"`
}

// DefaultProcedureHistoryOrder is the default ordering of ProcedureHistory.
var DefaultProcedureHistoryOrder = &ProcedureHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: procedurehistory.FieldID,
		toTerm: procedurehistory.ByID,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ProcedureHistory into ProcedureHistoryEdge.
func (_m *ProcedureHistory) ToEdge(order *ProcedureHistoryOrder) *ProcedureHistoryEdge {
	if order == nil {
		order = DefaultProcedureHistoryOrder
	}
	return &ProcedureHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ProgramHistoryEdge is the edge representation of ProgramHistory.
type ProgramHistoryEdge struct {
	Node   *ProgramHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ProgramHistoryConnection is the connection containing edges to ProgramHistory.
type ProgramHistoryConnection struct {
	Edges      []*ProgramHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ProgramHistoryConnection) build(nodes []*ProgramHistory, pager *programhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ProgramHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProgramHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProgramHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramHistoryPaginateOption enables pagination customization.
type ProgramHistoryPaginateOption func(*programhistoryPager) error

// WithProgramHistoryOrder configures pagination ordering.
func WithProgramHistoryOrder(order *ProgramHistoryOrder) ProgramHistoryPaginateOption {
	if order == nil {
		order = DefaultProgramHistoryOrder
	}
	o := *order
	return func(pager *programhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProgramHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProgramHistoryFilter configures pagination filter.
func WithProgramHistoryFilter(filter func(*ProgramHistoryQuery) (*ProgramHistoryQuery, error)) ProgramHistoryPaginateOption {
	return func(pager *programhistoryPager) error {
		if filter == nil {
			return errors.New("ProgramHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programhistoryPager struct {
	reverse bool
	order   *ProgramHistoryOrder
	filter  func(*ProgramHistoryQuery) (*ProgramHistoryQuery, error)
}

func newProgramHistoryPager(opts []ProgramHistoryPaginateOption, reverse bool) (*programhistoryPager, error) {
	pager := &programhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProgramHistoryOrder
	}
	return pager, nil
}

func (p *programhistoryPager) applyFilter(query *ProgramHistoryQuery) (*ProgramHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programhistoryPager) toCursor(_m *ProgramHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *programhistoryPager) applyCursors(query *ProgramHistoryQuery, after, before *Cursor) (*ProgramHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProgramHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *programhistoryPager) applyOrder(query *ProgramHistoryQuery) *ProgramHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProgramHistoryOrder.Field {
		query = query.Order(DefaultProgramHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *programhistoryPager) orderExpr(query *ProgramHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProgramHistoryOrder.Field {
			b.Comma().Ident(DefaultProgramHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProgramHistory.
func (_m *ProgramHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramHistoryPaginateOption,
) (*ProgramHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ProgramHistoryConnection{Edges: []*ProgramHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProgramHistoryOrderFieldHistoryTime orders ProgramHistory by history_time.
	ProgramHistoryOrderFieldHistoryTime = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: programhistory.FieldHistoryTime,
		toTerm: programhistory.ByHistoryTime,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ProgramHistoryOrderFieldCreatedAt orders ProgramHistory by created_at.
	ProgramHistoryOrderFieldCreatedAt = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: programhistory.FieldCreatedAt,
		toTerm: programhistory.ByCreatedAt,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ProgramHistoryOrderFieldUpdatedAt orders ProgramHistory by updated_at.
	ProgramHistoryOrderFieldUpdatedAt = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: programhistory.FieldUpdatedAt,
		toTerm: programhistory.ByUpdatedAt,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ProgramHistoryOrderFieldName orders ProgramHistory by name.
	ProgramHistoryOrderFieldName = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: programhistory.FieldName,
		toTerm: programhistory.ByName,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ProgramHistoryOrderFieldStatus orders ProgramHistory by status.
	ProgramHistoryOrderFieldStatus = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: programhistory.FieldStatus,
		toTerm: programhistory.ByStatus,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ProgramHistoryOrderFieldFrameworkName orders ProgramHistory by framework_name.
	ProgramHistoryOrderFieldFrameworkName = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.FrameworkName, nil
		},
		column: programhistory.FieldFrameworkName,
		toTerm: programhistory.ByFrameworkName,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FrameworkName,
			}
		},
	}
	// ProgramHistoryOrderFieldStartDate orders ProgramHistory by start_date.
	ProgramHistoryOrderFieldStartDate = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.StartDate, nil
		},
		column: programhistory.FieldStartDate,
		toTerm: programhistory.ByStartDate,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StartDate,
			}
		},
	}
	// ProgramHistoryOrderFieldEndDate orders ProgramHistory by end_date.
	ProgramHistoryOrderFieldEndDate = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.EndDate, nil
		},
		column: programhistory.FieldEndDate,
		toTerm: programhistory.ByEndDate,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.EndDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProgramHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ProgramHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ProgramHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ProgramHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProgramHistoryOrderFieldName.column:
		str = "name"
	case ProgramHistoryOrderFieldStatus.column:
		str = "STATUS"
	case ProgramHistoryOrderFieldFrameworkName.column:
		str = "framework"
	case ProgramHistoryOrderFieldStartDate.column:
		str = "start_date"
	case ProgramHistoryOrderFieldEndDate.column:
		str = "end_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProgramHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProgramHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProgramHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ProgramHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ProgramHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ProgramHistoryOrderFieldUpdatedAt
	case "name":
		*f = *ProgramHistoryOrderFieldName
	case "STATUS":
		*f = *ProgramHistoryOrderFieldStatus
	case "framework":
		*f = *ProgramHistoryOrderFieldFrameworkName
	case "start_date":
		*f = *ProgramHistoryOrderFieldStartDate
	case "end_date":
		*f = *ProgramHistoryOrderFieldEndDate
	default:
		return fmt.Errorf("%s is not a valid ProgramHistoryOrderField", str)
	}
	return nil
}

// ProgramHistoryOrderField defines the ordering field of ProgramHistory.
type ProgramHistoryOrderField struct {
	// Value extracts the ordering value from the given ProgramHistory.
	Value    func(*ProgramHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) programhistory.OrderOption
	toCursor func(*ProgramHistory) Cursor
}

// ProgramHistoryOrder defines the ordering of ProgramHistory.
type ProgramHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ProgramHistoryOrderField `json:"field"`
}

// DefaultProgramHistoryOrder is the default ordering of ProgramHistory.
var DefaultProgramHistoryOrder = &ProgramHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: programhistory.FieldID,
		toTerm: programhistory.ByID,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ProgramHistory into ProgramHistoryEdge.
func (_m *ProgramHistory) ToEdge(order *ProgramHistoryOrder) *ProgramHistoryEdge {
	if order == nil {
		order = DefaultProgramHistoryOrder
	}
	return &ProgramHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ProgramMembershipHistoryEdge is the edge representation of ProgramMembershipHistory.
type ProgramMembershipHistoryEdge struct {
	Node   *ProgramMembershipHistory `json:"node"`
	Cursor Cursor                    `json:"cursor"`
}

// ProgramMembershipHistoryConnection is the connection containing edges to ProgramMembershipHistory.
type ProgramMembershipHistoryConnection struct {
	Edges      []*ProgramMembershipHistoryEdge `json:"edges"`
	PageInfo   PageInfo                        `json:"pageInfo"`
	TotalCount int                             `json:"totalCount"`
}

func (c *ProgramMembershipHistoryConnection) build(nodes []*ProgramMembershipHistory, pager *programmembershiphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ProgramMembershipHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProgramMembershipHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProgramMembershipHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramMembershipHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramMembershipHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramMembershipHistoryPaginateOption enables pagination customization.
type ProgramMembershipHistoryPaginateOption func(*programmembershiphistoryPager) error

// WithProgramMembershipHistoryOrder configures pagination ordering.
func WithProgramMembershipHistoryOrder(order *ProgramMembershipHistoryOrder) ProgramMembershipHistoryPaginateOption {
	if order == nil {
		order = DefaultProgramMembershipHistoryOrder
	}
	o := *order
	return func(pager *programmembershiphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProgramMembershipHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProgramMembershipHistoryFilter configures pagination filter.
func WithProgramMembershipHistoryFilter(filter func(*ProgramMembershipHistoryQuery) (*ProgramMembershipHistoryQuery, error)) ProgramMembershipHistoryPaginateOption {
	return func(pager *programmembershiphistoryPager) error {
		if filter == nil {
			return errors.New("ProgramMembershipHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programmembershiphistoryPager struct {
	reverse bool
	order   *ProgramMembershipHistoryOrder
	filter  func(*ProgramMembershipHistoryQuery) (*ProgramMembershipHistoryQuery, error)
}

func newProgramMembershipHistoryPager(opts []ProgramMembershipHistoryPaginateOption, reverse bool) (*programmembershiphistoryPager, error) {
	pager := &programmembershiphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProgramMembershipHistoryOrder
	}
	return pager, nil
}

func (p *programmembershiphistoryPager) applyFilter(query *ProgramMembershipHistoryQuery) (*ProgramMembershipHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programmembershiphistoryPager) toCursor(_m *ProgramMembershipHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *programmembershiphistoryPager) applyCursors(query *ProgramMembershipHistoryQuery, after, before *Cursor) (*ProgramMembershipHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProgramMembershipHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *programmembershiphistoryPager) applyOrder(query *ProgramMembershipHistoryQuery) *ProgramMembershipHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProgramMembershipHistoryOrder.Field {
		query = query.Order(DefaultProgramMembershipHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *programmembershiphistoryPager) orderExpr(query *ProgramMembershipHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProgramMembershipHistoryOrder.Field {
			b.Comma().Ident(DefaultProgramMembershipHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProgramMembershipHistory.
func (_m *ProgramMembershipHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramMembershipHistoryPaginateOption,
) (*ProgramMembershipHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramMembershipHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ProgramMembershipHistoryConnection{Edges: []*ProgramMembershipHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProgramMembershipHistoryOrderFieldHistoryTime orders ProgramMembershipHistory by history_time.
	ProgramMembershipHistoryOrderFieldHistoryTime = &ProgramMembershipHistoryOrderField{
		Value: func(_m *ProgramMembershipHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: programmembershiphistory.FieldHistoryTime,
		toTerm: programmembershiphistory.ByHistoryTime,
		toCursor: func(_m *ProgramMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ProgramMembershipHistoryOrderFieldCreatedAt orders ProgramMembershipHistory by created_at.
	ProgramMembershipHistoryOrderFieldCreatedAt = &ProgramMembershipHistoryOrderField{
		Value: func(_m *ProgramMembershipHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: programmembershiphistory.FieldCreatedAt,
		toTerm: programmembershiphistory.ByCreatedAt,
		toCursor: func(_m *ProgramMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ProgramMembershipHistoryOrderFieldUpdatedAt orders ProgramMembershipHistory by updated_at.
	ProgramMembershipHistoryOrderFieldUpdatedAt = &ProgramMembershipHistoryOrderField{
		Value: func(_m *ProgramMembershipHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: programmembershiphistory.FieldUpdatedAt,
		toTerm: programmembershiphistory.ByUpdatedAt,
		toCursor: func(_m *ProgramMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ProgramMembershipHistoryOrderFieldRole orders ProgramMembershipHistory by role.
	ProgramMembershipHistoryOrderFieldRole = &ProgramMembershipHistoryOrderField{
		Value: func(_m *ProgramMembershipHistory) (ent.Value, error) {
			return _m.Role, nil
		},
		column: programmembershiphistory.FieldRole,
		toTerm: programmembershiphistory.ByRole,
		toCursor: func(_m *ProgramMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProgramMembershipHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ProgramMembershipHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ProgramMembershipHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ProgramMembershipHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProgramMembershipHistoryOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProgramMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProgramMembershipHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProgramMembershipHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ProgramMembershipHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ProgramMembershipHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ProgramMembershipHistoryOrderFieldUpdatedAt
	case "ROLE":
		*f = *ProgramMembershipHistoryOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid ProgramMembershipHistoryOrderField", str)
	}
	return nil
}

// ProgramMembershipHistoryOrderField defines the ordering field of ProgramMembershipHistory.
type ProgramMembershipHistoryOrderField struct {
	// Value extracts the ordering value from the given ProgramMembershipHistory.
	Value    func(*ProgramMembershipHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) programmembershiphistory.OrderOption
	toCursor func(*ProgramMembershipHistory) Cursor
}

// ProgramMembershipHistoryOrder defines the ordering of ProgramMembershipHistory.
type ProgramMembershipHistoryOrder struct {
	Direction OrderDirection                      `json:"direction"`
	Field     *ProgramMembershipHistoryOrderField `json:"field"`
}

// DefaultProgramMembershipHistoryOrder is the default ordering of ProgramMembershipHistory.
var DefaultProgramMembershipHistoryOrder = &ProgramMembershipHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramMembershipHistoryOrderField{
		Value: func(_m *ProgramMembershipHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: programmembershiphistory.FieldID,
		toTerm: programmembershiphistory.ByID,
		toCursor: func(_m *ProgramMembershipHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ProgramMembershipHistory into ProgramMembershipHistoryEdge.
func (_m *ProgramMembershipHistory) ToEdge(order *ProgramMembershipHistoryOrder) *ProgramMembershipHistoryEdge {
	if order == nil {
		order = DefaultProgramMembershipHistoryOrder
	}
	return &ProgramMembershipHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// RemediationHistoryEdge is the edge representation of RemediationHistory.
type RemediationHistoryEdge struct {
	Node   *RemediationHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// RemediationHistoryConnection is the connection containing edges to RemediationHistory.
type RemediationHistoryConnection struct {
	Edges      []*RemediationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *RemediationHistoryConnection) build(nodes []*RemediationHistory, pager *remediationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *RemediationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RemediationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RemediationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*RemediationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RemediationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RemediationHistoryPaginateOption enables pagination customization.
type RemediationHistoryPaginateOption func(*remediationhistoryPager) error

// WithRemediationHistoryOrder configures pagination ordering.
func WithRemediationHistoryOrder(order *RemediationHistoryOrder) RemediationHistoryPaginateOption {
	if order == nil {
		order = DefaultRemediationHistoryOrder
	}
	o := *order
	return func(pager *remediationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRemediationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRemediationHistoryFilter configures pagination filter.
func WithRemediationHistoryFilter(filter func(*RemediationHistoryQuery) (*RemediationHistoryQuery, error)) RemediationHistoryPaginateOption {
	return func(pager *remediationhistoryPager) error {
		if filter == nil {
			return errors.New("RemediationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type remediationhistoryPager struct {
	reverse bool
	order   *RemediationHistoryOrder
	filter  func(*RemediationHistoryQuery) (*RemediationHistoryQuery, error)
}

func newRemediationHistoryPager(opts []RemediationHistoryPaginateOption, reverse bool) (*remediationhistoryPager, error) {
	pager := &remediationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRemediationHistoryOrder
	}
	return pager, nil
}

func (p *remediationhistoryPager) applyFilter(query *RemediationHistoryQuery) (*RemediationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *remediationhistoryPager) toCursor(_m *RemediationHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *remediationhistoryPager) applyCursors(query *RemediationHistoryQuery, after, before *Cursor) (*RemediationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRemediationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *remediationhistoryPager) applyOrder(query *RemediationHistoryQuery) *RemediationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRemediationHistoryOrder.Field {
		query = query.Order(DefaultRemediationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *remediationhistoryPager) orderExpr(query *RemediationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRemediationHistoryOrder.Field {
			b.Comma().Ident(DefaultRemediationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to RemediationHistory.
func (_m *RemediationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RemediationHistoryPaginateOption,
) (*RemediationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRemediationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &RemediationHistoryConnection{Edges: []*RemediationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RemediationHistoryOrderFieldHistoryTime orders RemediationHistory by history_time.
	RemediationHistoryOrderFieldHistoryTime = &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: remediationhistory.FieldHistoryTime,
		toTerm: remediationhistory.ByHistoryTime,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// RemediationHistoryOrderFieldCreatedAt orders RemediationHistory by created_at.
	RemediationHistoryOrderFieldCreatedAt = &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: remediationhistory.FieldCreatedAt,
		toTerm: remediationhistory.ByCreatedAt,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// RemediationHistoryOrderFieldUpdatedAt orders RemediationHistory by updated_at.
	RemediationHistoryOrderFieldUpdatedAt = &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: remediationhistory.FieldUpdatedAt,
		toTerm: remediationhistory.ByUpdatedAt,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// RemediationHistoryOrderFieldExternalID orders RemediationHistory by external_id.
	RemediationHistoryOrderFieldExternalID = &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: remediationhistory.FieldExternalID,
		toTerm: remediationhistory.ByExternalID,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// RemediationHistoryOrderFieldExternalOwnerID orders RemediationHistory by external_owner_id.
	RemediationHistoryOrderFieldExternalOwnerID = &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: remediationhistory.FieldExternalOwnerID,
		toTerm: remediationhistory.ByExternalOwnerID,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// RemediationHistoryOrderFieldTitle orders RemediationHistory by title.
	RemediationHistoryOrderFieldTitle = &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: remediationhistory.FieldTitle,
		toTerm: remediationhistory.ByTitle,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// RemediationHistoryOrderFieldState orders RemediationHistory by state.
	RemediationHistoryOrderFieldState = &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.State, nil
		},
		column: remediationhistory.FieldState,
		toTerm: remediationhistory.ByState,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.State,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RemediationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case RemediationHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case RemediationHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case RemediationHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case RemediationHistoryOrderFieldExternalID.column:
		str = "external_id"
	case RemediationHistoryOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case RemediationHistoryOrderFieldTitle.column:
		str = "title"
	case RemediationHistoryOrderFieldState.column:
		str = "state"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RemediationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RemediationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RemediationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *RemediationHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *RemediationHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *RemediationHistoryOrderFieldUpdatedAt
	case "external_id":
		*f = *RemediationHistoryOrderFieldExternalID
	case "external_owner_id":
		*f = *RemediationHistoryOrderFieldExternalOwnerID
	case "title":
		*f = *RemediationHistoryOrderFieldTitle
	case "state":
		*f = *RemediationHistoryOrderFieldState
	default:
		return fmt.Errorf("%s is not a valid RemediationHistoryOrderField", str)
	}
	return nil
}

// RemediationHistoryOrderField defines the ordering field of RemediationHistory.
type RemediationHistoryOrderField struct {
	// Value extracts the ordering value from the given RemediationHistory.
	Value    func(*RemediationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) remediationhistory.OrderOption
	toCursor func(*RemediationHistory) Cursor
}

// RemediationHistoryOrder defines the ordering of RemediationHistory.
type RemediationHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *RemediationHistoryOrderField `json:"field"`
}

// DefaultRemediationHistoryOrder is the default ordering of RemediationHistory.
var DefaultRemediationHistoryOrder = &RemediationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: remediationhistory.FieldID,
		toTerm: remediationhistory.ByID,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts RemediationHistory into RemediationHistoryEdge.
func (_m *RemediationHistory) ToEdge(order *RemediationHistoryOrder) *RemediationHistoryEdge {
	if order == nil {
		order = DefaultRemediationHistoryOrder
	}
	return &RemediationHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ReviewHistoryEdge is the edge representation of ReviewHistory.
type ReviewHistoryEdge struct {
	Node   *ReviewHistory `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// ReviewHistoryConnection is the connection containing edges to ReviewHistory.
type ReviewHistoryConnection struct {
	Edges      []*ReviewHistoryEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *ReviewHistoryConnection) build(nodes []*ReviewHistory, pager *reviewhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ReviewHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReviewHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReviewHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ReviewHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ReviewHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ReviewHistoryPaginateOption enables pagination customization.
type ReviewHistoryPaginateOption func(*reviewhistoryPager) error

// WithReviewHistoryOrder configures pagination ordering.
func WithReviewHistoryOrder(order *ReviewHistoryOrder) ReviewHistoryPaginateOption {
	if order == nil {
		order = DefaultReviewHistoryOrder
	}
	o := *order
	return func(pager *reviewhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReviewHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReviewHistoryFilter configures pagination filter.
func WithReviewHistoryFilter(filter func(*ReviewHistoryQuery) (*ReviewHistoryQuery, error)) ReviewHistoryPaginateOption {
	return func(pager *reviewhistoryPager) error {
		if filter == nil {
			return errors.New("ReviewHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type reviewhistoryPager struct {
	reverse bool
	order   *ReviewHistoryOrder
	filter  func(*ReviewHistoryQuery) (*ReviewHistoryQuery, error)
}

func newReviewHistoryPager(opts []ReviewHistoryPaginateOption, reverse bool) (*reviewhistoryPager, error) {
	pager := &reviewhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReviewHistoryOrder
	}
	return pager, nil
}

func (p *reviewhistoryPager) applyFilter(query *ReviewHistoryQuery) (*ReviewHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *reviewhistoryPager) toCursor(_m *ReviewHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *reviewhistoryPager) applyCursors(query *ReviewHistoryQuery, after, before *Cursor) (*ReviewHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultReviewHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *reviewhistoryPager) applyOrder(query *ReviewHistoryQuery) *ReviewHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultReviewHistoryOrder.Field {
		query = query.Order(DefaultReviewHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *reviewhistoryPager) orderExpr(query *ReviewHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultReviewHistoryOrder.Field {
			b.Comma().Ident(DefaultReviewHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ReviewHistory.
func (_m *ReviewHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReviewHistoryPaginateOption,
) (*ReviewHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReviewHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ReviewHistoryConnection{Edges: []*ReviewHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ReviewHistoryOrderFieldHistoryTime orders ReviewHistory by history_time.
	ReviewHistoryOrderFieldHistoryTime = &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: reviewhistory.FieldHistoryTime,
		toTerm: reviewhistory.ByHistoryTime,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ReviewHistoryOrderFieldCreatedAt orders ReviewHistory by created_at.
	ReviewHistoryOrderFieldCreatedAt = &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: reviewhistory.FieldCreatedAt,
		toTerm: reviewhistory.ByCreatedAt,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ReviewHistoryOrderFieldUpdatedAt orders ReviewHistory by updated_at.
	ReviewHistoryOrderFieldUpdatedAt = &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: reviewhistory.FieldUpdatedAt,
		toTerm: reviewhistory.ByUpdatedAt,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ReviewHistoryOrderFieldExternalID orders ReviewHistory by external_id.
	ReviewHistoryOrderFieldExternalID = &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: reviewhistory.FieldExternalID,
		toTerm: reviewhistory.ByExternalID,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// ReviewHistoryOrderFieldExternalOwnerID orders ReviewHistory by external_owner_id.
	ReviewHistoryOrderFieldExternalOwnerID = &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: reviewhistory.FieldExternalOwnerID,
		toTerm: reviewhistory.ByExternalOwnerID,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// ReviewHistoryOrderFieldTitle orders ReviewHistory by title.
	ReviewHistoryOrderFieldTitle = &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: reviewhistory.FieldTitle,
		toTerm: reviewhistory.ByTitle,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ReviewHistoryOrderFieldState orders ReviewHistory by state.
	ReviewHistoryOrderFieldState = &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.State, nil
		},
		column: reviewhistory.FieldState,
		toTerm: reviewhistory.ByState,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.State,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ReviewHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ReviewHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ReviewHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ReviewHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ReviewHistoryOrderFieldExternalID.column:
		str = "external_id"
	case ReviewHistoryOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case ReviewHistoryOrderFieldTitle.column:
		str = "title"
	case ReviewHistoryOrderFieldState.column:
		str = "state"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ReviewHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ReviewHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ReviewHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ReviewHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ReviewHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ReviewHistoryOrderFieldUpdatedAt
	case "external_id":
		*f = *ReviewHistoryOrderFieldExternalID
	case "external_owner_id":
		*f = *ReviewHistoryOrderFieldExternalOwnerID
	case "title":
		*f = *ReviewHistoryOrderFieldTitle
	case "state":
		*f = *ReviewHistoryOrderFieldState
	default:
		return fmt.Errorf("%s is not a valid ReviewHistoryOrderField", str)
	}
	return nil
}

// ReviewHistoryOrderField defines the ordering field of ReviewHistory.
type ReviewHistoryOrderField struct {
	// Value extracts the ordering value from the given ReviewHistory.
	Value    func(*ReviewHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) reviewhistory.OrderOption
	toCursor func(*ReviewHistory) Cursor
}

// ReviewHistoryOrder defines the ordering of ReviewHistory.
type ReviewHistoryOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *ReviewHistoryOrderField `json:"field"`
}

// DefaultReviewHistoryOrder is the default ordering of ReviewHistory.
var DefaultReviewHistoryOrder = &ReviewHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: reviewhistory.FieldID,
		toTerm: reviewhistory.ByID,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ReviewHistory into ReviewHistoryEdge.
func (_m *ReviewHistory) ToEdge(order *ReviewHistoryOrder) *ReviewHistoryEdge {
	if order == nil {
		order = DefaultReviewHistoryOrder
	}
	return &ReviewHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// RiskHistoryEdge is the edge representation of RiskHistory.
type RiskHistoryEdge struct {
	Node   *RiskHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// RiskHistoryConnection is the connection containing edges to RiskHistory.
type RiskHistoryConnection struct {
	Edges      []*RiskHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *RiskHistoryConnection) build(nodes []*RiskHistory, pager *riskhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *RiskHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RiskHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RiskHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*RiskHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RiskHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RiskHistoryPaginateOption enables pagination customization.
type RiskHistoryPaginateOption func(*riskhistoryPager) error

// WithRiskHistoryOrder configures pagination ordering.
func WithRiskHistoryOrder(order *RiskHistoryOrder) RiskHistoryPaginateOption {
	if order == nil {
		order = DefaultRiskHistoryOrder
	}
	o := *order
	return func(pager *riskhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRiskHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRiskHistoryFilter configures pagination filter.
func WithRiskHistoryFilter(filter func(*RiskHistoryQuery) (*RiskHistoryQuery, error)) RiskHistoryPaginateOption {
	return func(pager *riskhistoryPager) error {
		if filter == nil {
			return errors.New("RiskHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type riskhistoryPager struct {
	reverse bool
	order   *RiskHistoryOrder
	filter  func(*RiskHistoryQuery) (*RiskHistoryQuery, error)
}

func newRiskHistoryPager(opts []RiskHistoryPaginateOption, reverse bool) (*riskhistoryPager, error) {
	pager := &riskhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRiskHistoryOrder
	}
	return pager, nil
}

func (p *riskhistoryPager) applyFilter(query *RiskHistoryQuery) (*RiskHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *riskhistoryPager) toCursor(_m *RiskHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *riskhistoryPager) applyCursors(query *RiskHistoryQuery, after, before *Cursor) (*RiskHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRiskHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *riskhistoryPager) applyOrder(query *RiskHistoryQuery) *RiskHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRiskHistoryOrder.Field {
		query = query.Order(DefaultRiskHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *riskhistoryPager) orderExpr(query *RiskHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRiskHistoryOrder.Field {
			b.Comma().Ident(DefaultRiskHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to RiskHistory.
func (_m *RiskHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RiskHistoryPaginateOption,
) (*RiskHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRiskHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &RiskHistoryConnection{Edges: []*RiskHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RiskHistoryOrderFieldHistoryTime orders RiskHistory by history_time.
	RiskHistoryOrderFieldHistoryTime = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: riskhistory.FieldHistoryTime,
		toTerm: riskhistory.ByHistoryTime,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// RiskHistoryOrderFieldCreatedAt orders RiskHistory by created_at.
	RiskHistoryOrderFieldCreatedAt = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: riskhistory.FieldCreatedAt,
		toTerm: riskhistory.ByCreatedAt,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// RiskHistoryOrderFieldUpdatedAt orders RiskHistory by updated_at.
	RiskHistoryOrderFieldUpdatedAt = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: riskhistory.FieldUpdatedAt,
		toTerm: riskhistory.ByUpdatedAt,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// RiskHistoryOrderFieldName orders RiskHistory by name.
	RiskHistoryOrderFieldName = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: riskhistory.FieldName,
		toTerm: riskhistory.ByName,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// RiskHistoryOrderFieldStatus orders RiskHistory by status.
	RiskHistoryOrderFieldStatus = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: riskhistory.FieldStatus,
		toTerm: riskhistory.ByStatus,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// RiskHistoryOrderFieldImpact orders RiskHistory by impact.
	RiskHistoryOrderFieldImpact = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.Impact, nil
		},
		column: riskhistory.FieldImpact,
		toTerm: riskhistory.ByImpact,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Impact,
			}
		},
	}
	// RiskHistoryOrderFieldLikelihood orders RiskHistory by likelihood.
	RiskHistoryOrderFieldLikelihood = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.Likelihood, nil
		},
		column: riskhistory.FieldLikelihood,
		toTerm: riskhistory.ByLikelihood,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Likelihood,
			}
		},
	}
	// RiskHistoryOrderFieldScore orders RiskHistory by score.
	RiskHistoryOrderFieldScore = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.Score, nil
		},
		column: riskhistory.FieldScore,
		toTerm: riskhistory.ByScore,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Score,
			}
		},
	}
	// RiskHistoryOrderFieldBusinessCosts orders RiskHistory by business_costs.
	RiskHistoryOrderFieldBusinessCosts = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.BusinessCosts, nil
		},
		column: riskhistory.FieldBusinessCosts,
		toTerm: riskhistory.ByBusinessCosts,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.BusinessCosts,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RiskHistoryOrderField) String() string {
	var str string
	switch f.column {
	case RiskHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case RiskHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case RiskHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case RiskHistoryOrderFieldName.column:
		str = "name"
	case RiskHistoryOrderFieldStatus.column:
		str = "STATUS"
	case RiskHistoryOrderFieldImpact.column:
		str = "IMPACT"
	case RiskHistoryOrderFieldLikelihood.column:
		str = "LIKELIHOOD"
	case RiskHistoryOrderFieldScore.column:
		str = "score"
	case RiskHistoryOrderFieldBusinessCosts.column:
		str = "business_costs"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RiskHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RiskHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RiskHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *RiskHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *RiskHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *RiskHistoryOrderFieldUpdatedAt
	case "name":
		*f = *RiskHistoryOrderFieldName
	case "STATUS":
		*f = *RiskHistoryOrderFieldStatus
	case "IMPACT":
		*f = *RiskHistoryOrderFieldImpact
	case "LIKELIHOOD":
		*f = *RiskHistoryOrderFieldLikelihood
	case "score":
		*f = *RiskHistoryOrderFieldScore
	case "business_costs":
		*f = *RiskHistoryOrderFieldBusinessCosts
	default:
		return fmt.Errorf("%s is not a valid RiskHistoryOrderField", str)
	}
	return nil
}

// RiskHistoryOrderField defines the ordering field of RiskHistory.
type RiskHistoryOrderField struct {
	// Value extracts the ordering value from the given RiskHistory.
	Value    func(*RiskHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) riskhistory.OrderOption
	toCursor func(*RiskHistory) Cursor
}

// RiskHistoryOrder defines the ordering of RiskHistory.
type RiskHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *RiskHistoryOrderField `json:"field"`
}

// DefaultRiskHistoryOrder is the default ordering of RiskHistory.
var DefaultRiskHistoryOrder = &RiskHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: riskhistory.FieldID,
		toTerm: riskhistory.ByID,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts RiskHistory into RiskHistoryEdge.
func (_m *RiskHistory) ToEdge(order *RiskHistoryOrder) *RiskHistoryEdge {
	if order == nil {
		order = DefaultRiskHistoryOrder
	}
	return &RiskHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ScanHistoryEdge is the edge representation of ScanHistory.
type ScanHistoryEdge struct {
	Node   *ScanHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// ScanHistoryConnection is the connection containing edges to ScanHistory.
type ScanHistoryConnection struct {
	Edges      []*ScanHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *ScanHistoryConnection) build(nodes []*ScanHistory, pager *scanhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ScanHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ScanHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ScanHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScanHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScanHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScanHistoryPaginateOption enables pagination customization.
type ScanHistoryPaginateOption func(*scanhistoryPager) error

// WithScanHistoryOrder configures pagination ordering.
func WithScanHistoryOrder(order *ScanHistoryOrder) ScanHistoryPaginateOption {
	if order == nil {
		order = DefaultScanHistoryOrder
	}
	o := *order
	return func(pager *scanhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultScanHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithScanHistoryFilter configures pagination filter.
func WithScanHistoryFilter(filter func(*ScanHistoryQuery) (*ScanHistoryQuery, error)) ScanHistoryPaginateOption {
	return func(pager *scanhistoryPager) error {
		if filter == nil {
			return errors.New("ScanHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scanhistoryPager struct {
	reverse bool
	order   *ScanHistoryOrder
	filter  func(*ScanHistoryQuery) (*ScanHistoryQuery, error)
}

func newScanHistoryPager(opts []ScanHistoryPaginateOption, reverse bool) (*scanhistoryPager, error) {
	pager := &scanhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultScanHistoryOrder
	}
	return pager, nil
}

func (p *scanhistoryPager) applyFilter(query *ScanHistoryQuery) (*ScanHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scanhistoryPager) toCursor(_m *ScanHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *scanhistoryPager) applyCursors(query *ScanHistoryQuery, after, before *Cursor) (*ScanHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultScanHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *scanhistoryPager) applyOrder(query *ScanHistoryQuery) *ScanHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultScanHistoryOrder.Field {
		query = query.Order(DefaultScanHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *scanhistoryPager) orderExpr(query *ScanHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultScanHistoryOrder.Field {
			b.Comma().Ident(DefaultScanHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ScanHistory.
func (_m *ScanHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScanHistoryPaginateOption,
) (*ScanHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScanHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ScanHistoryConnection{Edges: []*ScanHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ScanHistoryOrderFieldHistoryTime orders ScanHistory by history_time.
	ScanHistoryOrderFieldHistoryTime = &ScanHistoryOrderField{
		Value: func(_m *ScanHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: scanhistory.FieldHistoryTime,
		toTerm: scanhistory.ByHistoryTime,
		toCursor: func(_m *ScanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ScanHistoryOrderFieldCreatedAt orders ScanHistory by created_at.
	ScanHistoryOrderFieldCreatedAt = &ScanHistoryOrderField{
		Value: func(_m *ScanHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: scanhistory.FieldCreatedAt,
		toTerm: scanhistory.ByCreatedAt,
		toCursor: func(_m *ScanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ScanHistoryOrderFieldUpdatedAt orders ScanHistory by updated_at.
	ScanHistoryOrderFieldUpdatedAt = &ScanHistoryOrderField{
		Value: func(_m *ScanHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: scanhistory.FieldUpdatedAt,
		toTerm: scanhistory.ByUpdatedAt,
		toCursor: func(_m *ScanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ScanHistoryOrderFieldScanType orders ScanHistory by scan_type.
	ScanHistoryOrderFieldScanType = &ScanHistoryOrderField{
		Value: func(_m *ScanHistory) (ent.Value, error) {
			return _m.ScanType, nil
		},
		column: scanhistory.FieldScanType,
		toTerm: scanhistory.ByScanType,
		toCursor: func(_m *ScanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ScanType,
			}
		},
	}
	// ScanHistoryOrderFieldScanDate orders ScanHistory by scan_date.
	ScanHistoryOrderFieldScanDate = &ScanHistoryOrderField{
		Value: func(_m *ScanHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ScanDate == nil {
				return nil, nil
			}
			return _m.ScanDate, nil
		},
		column: scanhistory.FieldScanDate,
		toTerm: func(opts ...sql.OrderTermOption) scanhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return scanhistory.ByScanDate(opts...)
		},
		toCursor: func(_m *ScanHistory) Cursor {
			if _m.ScanDate == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ScanDate,
			}
		},
	}
	// ScanHistoryOrderFieldNextScanRunAt orders ScanHistory by next_scan_run_at.
	ScanHistoryOrderFieldNextScanRunAt = &ScanHistoryOrderField{
		Value: func(_m *ScanHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.NextScanRunAt == nil {
				return nil, nil
			}
			return _m.NextScanRunAt, nil
		},
		column: scanhistory.FieldNextScanRunAt,
		toTerm: func(opts ...sql.OrderTermOption) scanhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return scanhistory.ByNextScanRunAt(opts...)
		},
		toCursor: func(_m *ScanHistory) Cursor {
			if _m.NextScanRunAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.NextScanRunAt,
			}
		},
	}
	// ScanHistoryOrderFieldStatus orders ScanHistory by status.
	ScanHistoryOrderFieldStatus = &ScanHistoryOrderField{
		Value: func(_m *ScanHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: scanhistory.FieldStatus,
		toTerm: scanhistory.ByStatus,
		toCursor: func(_m *ScanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ScanHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ScanHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ScanHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ScanHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ScanHistoryOrderFieldScanType.column:
		str = "SCAN_TYPE"
	case ScanHistoryOrderFieldScanDate.column:
		str = "scan_date"
	case ScanHistoryOrderFieldNextScanRunAt.column:
		str = "next_scan_run_at"
	case ScanHistoryOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ScanHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ScanHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ScanHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ScanHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ScanHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ScanHistoryOrderFieldUpdatedAt
	case "SCAN_TYPE":
		*f = *ScanHistoryOrderFieldScanType
	case "scan_date":
		*f = *ScanHistoryOrderFieldScanDate
	case "next_scan_run_at":
		*f = *ScanHistoryOrderFieldNextScanRunAt
	case "STATUS":
		*f = *ScanHistoryOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ScanHistoryOrderField", str)
	}
	return nil
}

// ScanHistoryOrderField defines the ordering field of ScanHistory.
type ScanHistoryOrderField struct {
	// Value extracts the ordering value from the given ScanHistory.
	Value    func(*ScanHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) scanhistory.OrderOption
	toCursor func(*ScanHistory) Cursor
}

// ScanHistoryOrder defines the ordering of ScanHistory.
type ScanHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *ScanHistoryOrderField `json:"field"`
}

// DefaultScanHistoryOrder is the default ordering of ScanHistory.
var DefaultScanHistoryOrder = &ScanHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScanHistoryOrderField{
		Value: func(_m *ScanHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: scanhistory.FieldID,
		toTerm: scanhistory.ByID,
		toCursor: func(_m *ScanHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ScanHistory into ScanHistoryEdge.
func (_m *ScanHistory) ToEdge(order *ScanHistoryOrder) *ScanHistoryEdge {
	if order == nil {
		order = DefaultScanHistoryOrder
	}
	return &ScanHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ScheduledJobHistoryEdge is the edge representation of ScheduledJobHistory.
type ScheduledJobHistoryEdge struct {
	Node   *ScheduledJobHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// ScheduledJobHistoryConnection is the connection containing edges to ScheduledJobHistory.
type ScheduledJobHistoryConnection struct {
	Edges      []*ScheduledJobHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *ScheduledJobHistoryConnection) build(nodes []*ScheduledJobHistory, pager *scheduledjobhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ScheduledJobHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ScheduledJobHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ScheduledJobHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScheduledJobHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScheduledJobHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScheduledJobHistoryPaginateOption enables pagination customization.
type ScheduledJobHistoryPaginateOption func(*scheduledjobhistoryPager) error

// WithScheduledJobHistoryOrder configures pagination ordering.
func WithScheduledJobHistoryOrder(order *ScheduledJobHistoryOrder) ScheduledJobHistoryPaginateOption {
	if order == nil {
		order = DefaultScheduledJobHistoryOrder
	}
	o := *order
	return func(pager *scheduledjobhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultScheduledJobHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithScheduledJobHistoryFilter configures pagination filter.
func WithScheduledJobHistoryFilter(filter func(*ScheduledJobHistoryQuery) (*ScheduledJobHistoryQuery, error)) ScheduledJobHistoryPaginateOption {
	return func(pager *scheduledjobhistoryPager) error {
		if filter == nil {
			return errors.New("ScheduledJobHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scheduledjobhistoryPager struct {
	reverse bool
	order   *ScheduledJobHistoryOrder
	filter  func(*ScheduledJobHistoryQuery) (*ScheduledJobHistoryQuery, error)
}

func newScheduledJobHistoryPager(opts []ScheduledJobHistoryPaginateOption, reverse bool) (*scheduledjobhistoryPager, error) {
	pager := &scheduledjobhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultScheduledJobHistoryOrder
	}
	return pager, nil
}

func (p *scheduledjobhistoryPager) applyFilter(query *ScheduledJobHistoryQuery) (*ScheduledJobHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scheduledjobhistoryPager) toCursor(_m *ScheduledJobHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *scheduledjobhistoryPager) applyCursors(query *ScheduledJobHistoryQuery, after, before *Cursor) (*ScheduledJobHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultScheduledJobHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *scheduledjobhistoryPager) applyOrder(query *ScheduledJobHistoryQuery) *ScheduledJobHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultScheduledJobHistoryOrder.Field {
		query = query.Order(DefaultScheduledJobHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *scheduledjobhistoryPager) orderExpr(query *ScheduledJobHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultScheduledJobHistoryOrder.Field {
			b.Comma().Ident(DefaultScheduledJobHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ScheduledJobHistory.
func (_m *ScheduledJobHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScheduledJobHistoryPaginateOption,
) (*ScheduledJobHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScheduledJobHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ScheduledJobHistoryConnection{Edges: []*ScheduledJobHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ScheduledJobHistoryOrderFieldHistoryTime orders ScheduledJobHistory by history_time.
	ScheduledJobHistoryOrderFieldHistoryTime = &ScheduledJobHistoryOrderField{
		Value: func(_m *ScheduledJobHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: scheduledjobhistory.FieldHistoryTime,
		toTerm: scheduledjobhistory.ByHistoryTime,
		toCursor: func(_m *ScheduledJobHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ScheduledJobHistoryOrderFieldCreatedAt orders ScheduledJobHistory by created_at.
	ScheduledJobHistoryOrderFieldCreatedAt = &ScheduledJobHistoryOrderField{
		Value: func(_m *ScheduledJobHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: scheduledjobhistory.FieldCreatedAt,
		toTerm: scheduledjobhistory.ByCreatedAt,
		toCursor: func(_m *ScheduledJobHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ScheduledJobHistoryOrderFieldUpdatedAt orders ScheduledJobHistory by updated_at.
	ScheduledJobHistoryOrderFieldUpdatedAt = &ScheduledJobHistoryOrderField{
		Value: func(_m *ScheduledJobHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: scheduledjobhistory.FieldUpdatedAt,
		toTerm: scheduledjobhistory.ByUpdatedAt,
		toCursor: func(_m *ScheduledJobHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ScheduledJobHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ScheduledJobHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ScheduledJobHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ScheduledJobHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ScheduledJobHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ScheduledJobHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ScheduledJobHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ScheduledJobHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ScheduledJobHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ScheduledJobHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ScheduledJobHistoryOrderField", str)
	}
	return nil
}

// ScheduledJobHistoryOrderField defines the ordering field of ScheduledJobHistory.
type ScheduledJobHistoryOrderField struct {
	// Value extracts the ordering value from the given ScheduledJobHistory.
	Value    func(*ScheduledJobHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) scheduledjobhistory.OrderOption
	toCursor func(*ScheduledJobHistory) Cursor
}

// ScheduledJobHistoryOrder defines the ordering of ScheduledJobHistory.
type ScheduledJobHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *ScheduledJobHistoryOrderField `json:"field"`
}

// DefaultScheduledJobHistoryOrder is the default ordering of ScheduledJobHistory.
var DefaultScheduledJobHistoryOrder = &ScheduledJobHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScheduledJobHistoryOrderField{
		Value: func(_m *ScheduledJobHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: scheduledjobhistory.FieldID,
		toTerm: scheduledjobhistory.ByID,
		toCursor: func(_m *ScheduledJobHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ScheduledJobHistory into ScheduledJobHistoryEdge.
func (_m *ScheduledJobHistory) ToEdge(order *ScheduledJobHistoryOrder) *ScheduledJobHistoryEdge {
	if order == nil {
		order = DefaultScheduledJobHistoryOrder
	}
	return &ScheduledJobHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// StandardHistoryEdge is the edge representation of StandardHistory.
type StandardHistoryEdge struct {
	Node   *StandardHistory `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// StandardHistoryConnection is the connection containing edges to StandardHistory.
type StandardHistoryConnection struct {
	Edges      []*StandardHistoryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *StandardHistoryConnection) build(nodes []*StandardHistory, pager *standardhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *StandardHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *StandardHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *StandardHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*StandardHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StandardHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StandardHistoryPaginateOption enables pagination customization.
type StandardHistoryPaginateOption func(*standardhistoryPager) error

// WithStandardHistoryOrder configures pagination ordering.
func WithStandardHistoryOrder(order *StandardHistoryOrder) StandardHistoryPaginateOption {
	if order == nil {
		order = DefaultStandardHistoryOrder
	}
	o := *order
	return func(pager *standardhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStandardHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStandardHistoryFilter configures pagination filter.
func WithStandardHistoryFilter(filter func(*StandardHistoryQuery) (*StandardHistoryQuery, error)) StandardHistoryPaginateOption {
	return func(pager *standardhistoryPager) error {
		if filter == nil {
			return errors.New("StandardHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type standardhistoryPager struct {
	reverse bool
	order   *StandardHistoryOrder
	filter  func(*StandardHistoryQuery) (*StandardHistoryQuery, error)
}

func newStandardHistoryPager(opts []StandardHistoryPaginateOption, reverse bool) (*standardhistoryPager, error) {
	pager := &standardhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStandardHistoryOrder
	}
	return pager, nil
}

func (p *standardhistoryPager) applyFilter(query *StandardHistoryQuery) (*StandardHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *standardhistoryPager) toCursor(_m *StandardHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *standardhistoryPager) applyCursors(query *StandardHistoryQuery, after, before *Cursor) (*StandardHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultStandardHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *standardhistoryPager) applyOrder(query *StandardHistoryQuery) *StandardHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultStandardHistoryOrder.Field {
		query = query.Order(DefaultStandardHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *standardhistoryPager) orderExpr(query *StandardHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultStandardHistoryOrder.Field {
			b.Comma().Ident(DefaultStandardHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to StandardHistory.
func (_m *StandardHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StandardHistoryPaginateOption,
) (*StandardHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStandardHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &StandardHistoryConnection{Edges: []*StandardHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// StandardHistoryOrderFieldHistoryTime orders StandardHistory by history_time.
	StandardHistoryOrderFieldHistoryTime = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: standardhistory.FieldHistoryTime,
		toTerm: standardhistory.ByHistoryTime,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// StandardHistoryOrderFieldCreatedAt orders StandardHistory by created_at.
	StandardHistoryOrderFieldCreatedAt = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: standardhistory.FieldCreatedAt,
		toTerm: standardhistory.ByCreatedAt,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// StandardHistoryOrderFieldUpdatedAt orders StandardHistory by updated_at.
	StandardHistoryOrderFieldUpdatedAt = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: standardhistory.FieldUpdatedAt,
		toTerm: standardhistory.ByUpdatedAt,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// StandardHistoryOrderFieldRevision orders StandardHistory by revision.
	StandardHistoryOrderFieldRevision = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: standardhistory.FieldRevision,
		toTerm: standardhistory.ByRevision,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// StandardHistoryOrderFieldName orders StandardHistory by name.
	StandardHistoryOrderFieldName = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: standardhistory.FieldName,
		toTerm: standardhistory.ByName,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// StandardHistoryOrderFieldShortName orders StandardHistory by short_name.
	StandardHistoryOrderFieldShortName = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.ShortName, nil
		},
		column: standardhistory.FieldShortName,
		toTerm: standardhistory.ByShortName,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ShortName,
			}
		},
	}
	// StandardHistoryOrderFieldFramework orders StandardHistory by framework.
	StandardHistoryOrderFieldFramework = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.Framework, nil
		},
		column: standardhistory.FieldFramework,
		toTerm: standardhistory.ByFramework,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Framework,
			}
		},
	}
	// StandardHistoryOrderFieldGoverningBody orders StandardHistory by governing_body.
	StandardHistoryOrderFieldGoverningBody = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.GoverningBody, nil
		},
		column: standardhistory.FieldGoverningBody,
		toTerm: standardhistory.ByGoverningBody,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.GoverningBody,
			}
		},
	}
	// StandardHistoryOrderFieldStatus orders StandardHistory by status.
	StandardHistoryOrderFieldStatus = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: standardhistory.FieldStatus,
		toTerm: standardhistory.ByStatus,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// StandardHistoryOrderFieldStandardType orders StandardHistory by standard_type.
	StandardHistoryOrderFieldStandardType = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.StandardType, nil
		},
		column: standardhistory.FieldStandardType,
		toTerm: standardhistory.ByStandardType,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StandardType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f StandardHistoryOrderField) String() string {
	var str string
	switch f.column {
	case StandardHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case StandardHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case StandardHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case StandardHistoryOrderFieldRevision.column:
		str = "revision"
	case StandardHistoryOrderFieldName.column:
		str = "name"
	case StandardHistoryOrderFieldShortName.column:
		str = "short_name"
	case StandardHistoryOrderFieldFramework.column:
		str = "framework"
	case StandardHistoryOrderFieldGoverningBody.column:
		str = "governing_body"
	case StandardHistoryOrderFieldStatus.column:
		str = "STATUS"
	case StandardHistoryOrderFieldStandardType.column:
		str = "standard_type"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f StandardHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *StandardHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("StandardHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *StandardHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *StandardHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *StandardHistoryOrderFieldUpdatedAt
	case "revision":
		*f = *StandardHistoryOrderFieldRevision
	case "name":
		*f = *StandardHistoryOrderFieldName
	case "short_name":
		*f = *StandardHistoryOrderFieldShortName
	case "framework":
		*f = *StandardHistoryOrderFieldFramework
	case "governing_body":
		*f = *StandardHistoryOrderFieldGoverningBody
	case "STATUS":
		*f = *StandardHistoryOrderFieldStatus
	case "standard_type":
		*f = *StandardHistoryOrderFieldStandardType
	default:
		return fmt.Errorf("%s is not a valid StandardHistoryOrderField", str)
	}
	return nil
}

// StandardHistoryOrderField defines the ordering field of StandardHistory.
type StandardHistoryOrderField struct {
	// Value extracts the ordering value from the given StandardHistory.
	Value    func(*StandardHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) standardhistory.OrderOption
	toCursor func(*StandardHistory) Cursor
}

// StandardHistoryOrder defines the ordering of StandardHistory.
type StandardHistoryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *StandardHistoryOrderField `json:"field"`
}

// DefaultStandardHistoryOrder is the default ordering of StandardHistory.
var DefaultStandardHistoryOrder = &StandardHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: standardhistory.FieldID,
		toTerm: standardhistory.ByID,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts StandardHistory into StandardHistoryEdge.
func (_m *StandardHistory) ToEdge(order *StandardHistoryOrder) *StandardHistoryEdge {
	if order == nil {
		order = DefaultStandardHistoryOrder
	}
	return &StandardHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// SubcontrolHistoryEdge is the edge representation of SubcontrolHistory.
type SubcontrolHistoryEdge struct {
	Node   *SubcontrolHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// SubcontrolHistoryConnection is the connection containing edges to SubcontrolHistory.
type SubcontrolHistoryConnection struct {
	Edges      []*SubcontrolHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *SubcontrolHistoryConnection) build(nodes []*SubcontrolHistory, pager *subcontrolhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *SubcontrolHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SubcontrolHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SubcontrolHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubcontrolHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubcontrolHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubcontrolHistoryPaginateOption enables pagination customization.
type SubcontrolHistoryPaginateOption func(*subcontrolhistoryPager) error

// WithSubcontrolHistoryOrder configures pagination ordering.
func WithSubcontrolHistoryOrder(order *SubcontrolHistoryOrder) SubcontrolHistoryPaginateOption {
	if order == nil {
		order = DefaultSubcontrolHistoryOrder
	}
	o := *order
	return func(pager *subcontrolhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSubcontrolHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSubcontrolHistoryFilter configures pagination filter.
func WithSubcontrolHistoryFilter(filter func(*SubcontrolHistoryQuery) (*SubcontrolHistoryQuery, error)) SubcontrolHistoryPaginateOption {
	return func(pager *subcontrolhistoryPager) error {
		if filter == nil {
			return errors.New("SubcontrolHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subcontrolhistoryPager struct {
	reverse bool
	order   *SubcontrolHistoryOrder
	filter  func(*SubcontrolHistoryQuery) (*SubcontrolHistoryQuery, error)
}

func newSubcontrolHistoryPager(opts []SubcontrolHistoryPaginateOption, reverse bool) (*subcontrolhistoryPager, error) {
	pager := &subcontrolhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSubcontrolHistoryOrder
	}
	return pager, nil
}

func (p *subcontrolhistoryPager) applyFilter(query *SubcontrolHistoryQuery) (*SubcontrolHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subcontrolhistoryPager) toCursor(_m *SubcontrolHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *subcontrolhistoryPager) applyCursors(query *SubcontrolHistoryQuery, after, before *Cursor) (*SubcontrolHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSubcontrolHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *subcontrolhistoryPager) applyOrder(query *SubcontrolHistoryQuery) *SubcontrolHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSubcontrolHistoryOrder.Field {
		query = query.Order(DefaultSubcontrolHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *subcontrolhistoryPager) orderExpr(query *SubcontrolHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSubcontrolHistoryOrder.Field {
			b.Comma().Ident(DefaultSubcontrolHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SubcontrolHistory.
func (_m *SubcontrolHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubcontrolHistoryPaginateOption,
) (*SubcontrolHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubcontrolHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &SubcontrolHistoryConnection{Edges: []*SubcontrolHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SubcontrolHistoryOrderFieldHistoryTime orders SubcontrolHistory by history_time.
	SubcontrolHistoryOrderFieldHistoryTime = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: subcontrolhistory.FieldHistoryTime,
		toTerm: subcontrolhistory.ByHistoryTime,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// SubcontrolHistoryOrderFieldCreatedAt orders SubcontrolHistory by created_at.
	SubcontrolHistoryOrderFieldCreatedAt = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: subcontrolhistory.FieldCreatedAt,
		toTerm: subcontrolhistory.ByCreatedAt,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// SubcontrolHistoryOrderFieldUpdatedAt orders SubcontrolHistory by updated_at.
	SubcontrolHistoryOrderFieldUpdatedAt = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: subcontrolhistory.FieldUpdatedAt,
		toTerm: subcontrolhistory.ByUpdatedAt,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// SubcontrolHistoryOrderFieldTitle orders SubcontrolHistory by title.
	SubcontrolHistoryOrderFieldTitle = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: subcontrolhistory.FieldTitle,
		toTerm: subcontrolhistory.ByTitle,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// SubcontrolHistoryOrderFieldStatus orders SubcontrolHistory by status.
	SubcontrolHistoryOrderFieldStatus = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: subcontrolhistory.FieldStatus,
		toTerm: subcontrolhistory.ByStatus,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// SubcontrolHistoryOrderFieldSource orders SubcontrolHistory by source.
	SubcontrolHistoryOrderFieldSource = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.Source, nil
		},
		column: subcontrolhistory.FieldSource,
		toTerm: subcontrolhistory.BySource,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
	// SubcontrolHistoryOrderFieldReferenceFramework orders SubcontrolHistory by reference_framework.
	SubcontrolHistoryOrderFieldReferenceFramework = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ReferenceFramework == nil {
				return nil, nil
			}
			return _m.ReferenceFramework, nil
		},
		column: subcontrolhistory.FieldReferenceFramework,
		toTerm: func(opts ...sql.OrderTermOption) subcontrolhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return subcontrolhistory.ByReferenceFramework(opts...)
		},
		toCursor: func(_m *SubcontrolHistory) Cursor {
			if _m.ReferenceFramework == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReferenceFramework,
			}
		},
	}
	// SubcontrolHistoryOrderFieldCategory orders SubcontrolHistory by category.
	SubcontrolHistoryOrderFieldCategory = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.Category, nil
		},
		column: subcontrolhistory.FieldCategory,
		toTerm: subcontrolhistory.ByCategory,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// SubcontrolHistoryOrderFieldSubcategory orders SubcontrolHistory by subcategory.
	SubcontrolHistoryOrderFieldSubcategory = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.Subcategory, nil
		},
		column: subcontrolhistory.FieldSubcategory,
		toTerm: subcontrolhistory.BySubcategory,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Subcategory,
			}
		},
	}
	// SubcontrolHistoryOrderFieldRefCode orders SubcontrolHistory by ref_code.
	SubcontrolHistoryOrderFieldRefCode = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.RefCode, nil
		},
		column: subcontrolhistory.FieldRefCode,
		toTerm: subcontrolhistory.ByRefCode,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RefCode,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SubcontrolHistoryOrderField) String() string {
	var str string
	switch f.column {
	case SubcontrolHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case SubcontrolHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case SubcontrolHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case SubcontrolHistoryOrderFieldTitle.column:
		str = "title"
	case SubcontrolHistoryOrderFieldStatus.column:
		str = "STATUS"
	case SubcontrolHistoryOrderFieldSource.column:
		str = "SOURCE"
	case SubcontrolHistoryOrderFieldReferenceFramework.column:
		str = "REFERENCE_FRAMEWORK"
	case SubcontrolHistoryOrderFieldCategory.column:
		str = "category"
	case SubcontrolHistoryOrderFieldSubcategory.column:
		str = "subcategory"
	case SubcontrolHistoryOrderFieldRefCode.column:
		str = "ref_code"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SubcontrolHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SubcontrolHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SubcontrolHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *SubcontrolHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *SubcontrolHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *SubcontrolHistoryOrderFieldUpdatedAt
	case "title":
		*f = *SubcontrolHistoryOrderFieldTitle
	case "STATUS":
		*f = *SubcontrolHistoryOrderFieldStatus
	case "SOURCE":
		*f = *SubcontrolHistoryOrderFieldSource
	case "REFERENCE_FRAMEWORK":
		*f = *SubcontrolHistoryOrderFieldReferenceFramework
	case "category":
		*f = *SubcontrolHistoryOrderFieldCategory
	case "subcategory":
		*f = *SubcontrolHistoryOrderFieldSubcategory
	case "ref_code":
		*f = *SubcontrolHistoryOrderFieldRefCode
	default:
		return fmt.Errorf("%s is not a valid SubcontrolHistoryOrderField", str)
	}
	return nil
}

// SubcontrolHistoryOrderField defines the ordering field of SubcontrolHistory.
type SubcontrolHistoryOrderField struct {
	// Value extracts the ordering value from the given SubcontrolHistory.
	Value    func(*SubcontrolHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subcontrolhistory.OrderOption
	toCursor func(*SubcontrolHistory) Cursor
}

// SubcontrolHistoryOrder defines the ordering of SubcontrolHistory.
type SubcontrolHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *SubcontrolHistoryOrderField `json:"field"`
}

// DefaultSubcontrolHistoryOrder is the default ordering of SubcontrolHistory.
var DefaultSubcontrolHistoryOrder = &SubcontrolHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: subcontrolhistory.FieldID,
		toTerm: subcontrolhistory.ByID,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts SubcontrolHistory into SubcontrolHistoryEdge.
func (_m *SubcontrolHistory) ToEdge(order *SubcontrolHistoryOrder) *SubcontrolHistoryEdge {
	if order == nil {
		order = DefaultSubcontrolHistoryOrder
	}
	return &SubcontrolHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// SubprocessorHistoryEdge is the edge representation of SubprocessorHistory.
type SubprocessorHistoryEdge struct {
	Node   *SubprocessorHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// SubprocessorHistoryConnection is the connection containing edges to SubprocessorHistory.
type SubprocessorHistoryConnection struct {
	Edges      []*SubprocessorHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *SubprocessorHistoryConnection) build(nodes []*SubprocessorHistory, pager *subprocessorhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *SubprocessorHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SubprocessorHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SubprocessorHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubprocessorHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubprocessorHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubprocessorHistoryPaginateOption enables pagination customization.
type SubprocessorHistoryPaginateOption func(*subprocessorhistoryPager) error

// WithSubprocessorHistoryOrder configures pagination ordering.
func WithSubprocessorHistoryOrder(order *SubprocessorHistoryOrder) SubprocessorHistoryPaginateOption {
	if order == nil {
		order = DefaultSubprocessorHistoryOrder
	}
	o := *order
	return func(pager *subprocessorhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSubprocessorHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSubprocessorHistoryFilter configures pagination filter.
func WithSubprocessorHistoryFilter(filter func(*SubprocessorHistoryQuery) (*SubprocessorHistoryQuery, error)) SubprocessorHistoryPaginateOption {
	return func(pager *subprocessorhistoryPager) error {
		if filter == nil {
			return errors.New("SubprocessorHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subprocessorhistoryPager struct {
	reverse bool
	order   *SubprocessorHistoryOrder
	filter  func(*SubprocessorHistoryQuery) (*SubprocessorHistoryQuery, error)
}

func newSubprocessorHistoryPager(opts []SubprocessorHistoryPaginateOption, reverse bool) (*subprocessorhistoryPager, error) {
	pager := &subprocessorhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSubprocessorHistoryOrder
	}
	return pager, nil
}

func (p *subprocessorhistoryPager) applyFilter(query *SubprocessorHistoryQuery) (*SubprocessorHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subprocessorhistoryPager) toCursor(_m *SubprocessorHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *subprocessorhistoryPager) applyCursors(query *SubprocessorHistoryQuery, after, before *Cursor) (*SubprocessorHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSubprocessorHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *subprocessorhistoryPager) applyOrder(query *SubprocessorHistoryQuery) *SubprocessorHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSubprocessorHistoryOrder.Field {
		query = query.Order(DefaultSubprocessorHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *subprocessorhistoryPager) orderExpr(query *SubprocessorHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSubprocessorHistoryOrder.Field {
			b.Comma().Ident(DefaultSubprocessorHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SubprocessorHistory.
func (_m *SubprocessorHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubprocessorHistoryPaginateOption,
) (*SubprocessorHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubprocessorHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &SubprocessorHistoryConnection{Edges: []*SubprocessorHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SubprocessorHistoryOrderFieldHistoryTime orders SubprocessorHistory by history_time.
	SubprocessorHistoryOrderFieldHistoryTime = &SubprocessorHistoryOrderField{
		Value: func(_m *SubprocessorHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: subprocessorhistory.FieldHistoryTime,
		toTerm: subprocessorhistory.ByHistoryTime,
		toCursor: func(_m *SubprocessorHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// SubprocessorHistoryOrderFieldCreatedAt orders SubprocessorHistory by created_at.
	SubprocessorHistoryOrderFieldCreatedAt = &SubprocessorHistoryOrderField{
		Value: func(_m *SubprocessorHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: subprocessorhistory.FieldCreatedAt,
		toTerm: subprocessorhistory.ByCreatedAt,
		toCursor: func(_m *SubprocessorHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// SubprocessorHistoryOrderFieldUpdatedAt orders SubprocessorHistory by updated_at.
	SubprocessorHistoryOrderFieldUpdatedAt = &SubprocessorHistoryOrderField{
		Value: func(_m *SubprocessorHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: subprocessorhistory.FieldUpdatedAt,
		toTerm: subprocessorhistory.ByUpdatedAt,
		toCursor: func(_m *SubprocessorHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// SubprocessorHistoryOrderFieldName orders SubprocessorHistory by name.
	SubprocessorHistoryOrderFieldName = &SubprocessorHistoryOrderField{
		Value: func(_m *SubprocessorHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: subprocessorhistory.FieldName,
		toTerm: subprocessorhistory.ByName,
		toCursor: func(_m *SubprocessorHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SubprocessorHistoryOrderField) String() string {
	var str string
	switch f.column {
	case SubprocessorHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case SubprocessorHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case SubprocessorHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case SubprocessorHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SubprocessorHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SubprocessorHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SubprocessorHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *SubprocessorHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *SubprocessorHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *SubprocessorHistoryOrderFieldUpdatedAt
	case "name":
		*f = *SubprocessorHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid SubprocessorHistoryOrderField", str)
	}
	return nil
}

// SubprocessorHistoryOrderField defines the ordering field of SubprocessorHistory.
type SubprocessorHistoryOrderField struct {
	// Value extracts the ordering value from the given SubprocessorHistory.
	Value    func(*SubprocessorHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subprocessorhistory.OrderOption
	toCursor func(*SubprocessorHistory) Cursor
}

// SubprocessorHistoryOrder defines the ordering of SubprocessorHistory.
type SubprocessorHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *SubprocessorHistoryOrderField `json:"field"`
}

// DefaultSubprocessorHistoryOrder is the default ordering of SubprocessorHistory.
var DefaultSubprocessorHistoryOrder = &SubprocessorHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubprocessorHistoryOrderField{
		Value: func(_m *SubprocessorHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: subprocessorhistory.FieldID,
		toTerm: subprocessorhistory.ByID,
		toCursor: func(_m *SubprocessorHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts SubprocessorHistory into SubprocessorHistoryEdge.
func (_m *SubprocessorHistory) ToEdge(order *SubprocessorHistoryOrder) *SubprocessorHistoryEdge {
	if order == nil {
		order = DefaultSubprocessorHistoryOrder
	}
	return &SubprocessorHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// SystemDetailHistoryEdge is the edge representation of SystemDetailHistory.
type SystemDetailHistoryEdge struct {
	Node   *SystemDetailHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// SystemDetailHistoryConnection is the connection containing edges to SystemDetailHistory.
type SystemDetailHistoryConnection struct {
	Edges      []*SystemDetailHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *SystemDetailHistoryConnection) build(nodes []*SystemDetailHistory, pager *systemdetailhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *SystemDetailHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SystemDetailHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SystemDetailHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*SystemDetailHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SystemDetailHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SystemDetailHistoryPaginateOption enables pagination customization.
type SystemDetailHistoryPaginateOption func(*systemdetailhistoryPager) error

// WithSystemDetailHistoryOrder configures pagination ordering.
func WithSystemDetailHistoryOrder(order *SystemDetailHistoryOrder) SystemDetailHistoryPaginateOption {
	if order == nil {
		order = DefaultSystemDetailHistoryOrder
	}
	o := *order
	return func(pager *systemdetailhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSystemDetailHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSystemDetailHistoryFilter configures pagination filter.
func WithSystemDetailHistoryFilter(filter func(*SystemDetailHistoryQuery) (*SystemDetailHistoryQuery, error)) SystemDetailHistoryPaginateOption {
	return func(pager *systemdetailhistoryPager) error {
		if filter == nil {
			return errors.New("SystemDetailHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type systemdetailhistoryPager struct {
	reverse bool
	order   *SystemDetailHistoryOrder
	filter  func(*SystemDetailHistoryQuery) (*SystemDetailHistoryQuery, error)
}

func newSystemDetailHistoryPager(opts []SystemDetailHistoryPaginateOption, reverse bool) (*systemdetailhistoryPager, error) {
	pager := &systemdetailhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSystemDetailHistoryOrder
	}
	return pager, nil
}

func (p *systemdetailhistoryPager) applyFilter(query *SystemDetailHistoryQuery) (*SystemDetailHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *systemdetailhistoryPager) toCursor(_m *SystemDetailHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *systemdetailhistoryPager) applyCursors(query *SystemDetailHistoryQuery, after, before *Cursor) (*SystemDetailHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSystemDetailHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *systemdetailhistoryPager) applyOrder(query *SystemDetailHistoryQuery) *SystemDetailHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSystemDetailHistoryOrder.Field {
		query = query.Order(DefaultSystemDetailHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *systemdetailhistoryPager) orderExpr(query *SystemDetailHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSystemDetailHistoryOrder.Field {
			b.Comma().Ident(DefaultSystemDetailHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SystemDetailHistory.
func (_m *SystemDetailHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SystemDetailHistoryPaginateOption,
) (*SystemDetailHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSystemDetailHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &SystemDetailHistoryConnection{Edges: []*SystemDetailHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SystemDetailHistoryOrderFieldHistoryTime orders SystemDetailHistory by history_time.
	SystemDetailHistoryOrderFieldHistoryTime = &SystemDetailHistoryOrderField{
		Value: func(_m *SystemDetailHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: systemdetailhistory.FieldHistoryTime,
		toTerm: systemdetailhistory.ByHistoryTime,
		toCursor: func(_m *SystemDetailHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// SystemDetailHistoryOrderFieldCreatedAt orders SystemDetailHistory by created_at.
	SystemDetailHistoryOrderFieldCreatedAt = &SystemDetailHistoryOrderField{
		Value: func(_m *SystemDetailHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: systemdetailhistory.FieldCreatedAt,
		toTerm: systemdetailhistory.ByCreatedAt,
		toCursor: func(_m *SystemDetailHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// SystemDetailHistoryOrderFieldUpdatedAt orders SystemDetailHistory by updated_at.
	SystemDetailHistoryOrderFieldUpdatedAt = &SystemDetailHistoryOrderField{
		Value: func(_m *SystemDetailHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: systemdetailhistory.FieldUpdatedAt,
		toTerm: systemdetailhistory.ByUpdatedAt,
		toCursor: func(_m *SystemDetailHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// SystemDetailHistoryOrderFieldSystemName orders SystemDetailHistory by system_name.
	SystemDetailHistoryOrderFieldSystemName = &SystemDetailHistoryOrderField{
		Value: func(_m *SystemDetailHistory) (ent.Value, error) {
			return _m.SystemName, nil
		},
		column: systemdetailhistory.FieldSystemName,
		toTerm: systemdetailhistory.BySystemName,
		toCursor: func(_m *SystemDetailHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SystemName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SystemDetailHistoryOrderField) String() string {
	var str string
	switch f.column {
	case SystemDetailHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case SystemDetailHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case SystemDetailHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case SystemDetailHistoryOrderFieldSystemName.column:
		str = "system_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SystemDetailHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SystemDetailHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SystemDetailHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *SystemDetailHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *SystemDetailHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *SystemDetailHistoryOrderFieldUpdatedAt
	case "system_name":
		*f = *SystemDetailHistoryOrderFieldSystemName
	default:
		return fmt.Errorf("%s is not a valid SystemDetailHistoryOrderField", str)
	}
	return nil
}

// SystemDetailHistoryOrderField defines the ordering field of SystemDetailHistory.
type SystemDetailHistoryOrderField struct {
	// Value extracts the ordering value from the given SystemDetailHistory.
	Value    func(*SystemDetailHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) systemdetailhistory.OrderOption
	toCursor func(*SystemDetailHistory) Cursor
}

// SystemDetailHistoryOrder defines the ordering of SystemDetailHistory.
type SystemDetailHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *SystemDetailHistoryOrderField `json:"field"`
}

// DefaultSystemDetailHistoryOrder is the default ordering of SystemDetailHistory.
var DefaultSystemDetailHistoryOrder = &SystemDetailHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SystemDetailHistoryOrderField{
		Value: func(_m *SystemDetailHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: systemdetailhistory.FieldID,
		toTerm: systemdetailhistory.ByID,
		toCursor: func(_m *SystemDetailHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts SystemDetailHistory into SystemDetailHistoryEdge.
func (_m *SystemDetailHistory) ToEdge(order *SystemDetailHistoryOrder) *SystemDetailHistoryEdge {
	if order == nil {
		order = DefaultSystemDetailHistoryOrder
	}
	return &SystemDetailHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TaskHistoryEdge is the edge representation of TaskHistory.
type TaskHistoryEdge struct {
	Node   *TaskHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// TaskHistoryConnection is the connection containing edges to TaskHistory.
type TaskHistoryConnection struct {
	Edges      []*TaskHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *TaskHistoryConnection) build(nodes []*TaskHistory, pager *taskhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TaskHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TaskHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TaskHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TaskHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TaskHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TaskHistoryPaginateOption enables pagination customization.
type TaskHistoryPaginateOption func(*taskhistoryPager) error

// WithTaskHistoryOrder configures pagination ordering.
func WithTaskHistoryOrder(order *TaskHistoryOrder) TaskHistoryPaginateOption {
	if order == nil {
		order = DefaultTaskHistoryOrder
	}
	o := *order
	return func(pager *taskhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTaskHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTaskHistoryFilter configures pagination filter.
func WithTaskHistoryFilter(filter func(*TaskHistoryQuery) (*TaskHistoryQuery, error)) TaskHistoryPaginateOption {
	return func(pager *taskhistoryPager) error {
		if filter == nil {
			return errors.New("TaskHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type taskhistoryPager struct {
	reverse bool
	order   *TaskHistoryOrder
	filter  func(*TaskHistoryQuery) (*TaskHistoryQuery, error)
}

func newTaskHistoryPager(opts []TaskHistoryPaginateOption, reverse bool) (*taskhistoryPager, error) {
	pager := &taskhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTaskHistoryOrder
	}
	return pager, nil
}

func (p *taskhistoryPager) applyFilter(query *TaskHistoryQuery) (*TaskHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *taskhistoryPager) toCursor(_m *TaskHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *taskhistoryPager) applyCursors(query *TaskHistoryQuery, after, before *Cursor) (*TaskHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTaskHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *taskhistoryPager) applyOrder(query *TaskHistoryQuery) *TaskHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTaskHistoryOrder.Field {
		query = query.Order(DefaultTaskHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *taskhistoryPager) orderExpr(query *TaskHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTaskHistoryOrder.Field {
			b.Comma().Ident(DefaultTaskHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TaskHistory.
func (_m *TaskHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TaskHistoryPaginateOption,
) (*TaskHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTaskHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TaskHistoryConnection{Edges: []*TaskHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TaskHistoryOrderFieldHistoryTime orders TaskHistory by history_time.
	TaskHistoryOrderFieldHistoryTime = &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: taskhistory.FieldHistoryTime,
		toTerm: taskhistory.ByHistoryTime,
		toCursor: func(_m *TaskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TaskHistoryOrderFieldCreatedAt orders TaskHistory by created_at.
	TaskHistoryOrderFieldCreatedAt = &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: taskhistory.FieldCreatedAt,
		toTerm: taskhistory.ByCreatedAt,
		toCursor: func(_m *TaskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TaskHistoryOrderFieldUpdatedAt orders TaskHistory by updated_at.
	TaskHistoryOrderFieldUpdatedAt = &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: taskhistory.FieldUpdatedAt,
		toTerm: taskhistory.ByUpdatedAt,
		toCursor: func(_m *TaskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// TaskHistoryOrderFieldTitle orders TaskHistory by title.
	TaskHistoryOrderFieldTitle = &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: taskhistory.FieldTitle,
		toTerm: taskhistory.ByTitle,
		toCursor: func(_m *TaskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// TaskHistoryOrderFieldStatus orders TaskHistory by status.
	TaskHistoryOrderFieldStatus = &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: taskhistory.FieldStatus,
		toTerm: taskhistory.ByStatus,
		toCursor: func(_m *TaskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// TaskHistoryOrderFieldDue orders TaskHistory by due.
	TaskHistoryOrderFieldDue = &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.Due == nil {
				return nil, nil
			}
			return _m.Due, nil
		},
		column: taskhistory.FieldDue,
		toTerm: func(opts ...sql.OrderTermOption) taskhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return taskhistory.ByDue(opts...)
		},
		toCursor: func(_m *TaskHistory) Cursor {
			if _m.Due == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.Due,
			}
		},
	}
	// TaskHistoryOrderFieldCompleted orders TaskHistory by completed.
	TaskHistoryOrderFieldCompleted = &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.Completed == nil {
				return nil, nil
			}
			return _m.Completed, nil
		},
		column: taskhistory.FieldCompleted,
		toTerm: func(opts ...sql.OrderTermOption) taskhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return taskhistory.ByCompleted(opts...)
		},
		toCursor: func(_m *TaskHistory) Cursor {
			if _m.Completed == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.Completed,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TaskHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TaskHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TaskHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TaskHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TaskHistoryOrderFieldTitle.column:
		str = "title"
	case TaskHistoryOrderFieldStatus.column:
		str = "STATUS"
	case TaskHistoryOrderFieldDue.column:
		str = "due"
	case TaskHistoryOrderFieldCompleted.column:
		str = "completed"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TaskHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TaskHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TaskHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TaskHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TaskHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TaskHistoryOrderFieldUpdatedAt
	case "title":
		*f = *TaskHistoryOrderFieldTitle
	case "STATUS":
		*f = *TaskHistoryOrderFieldStatus
	case "due":
		*f = *TaskHistoryOrderFieldDue
	case "completed":
		*f = *TaskHistoryOrderFieldCompleted
	default:
		return fmt.Errorf("%s is not a valid TaskHistoryOrderField", str)
	}
	return nil
}

// TaskHistoryOrderField defines the ordering field of TaskHistory.
type TaskHistoryOrderField struct {
	// Value extracts the ordering value from the given TaskHistory.
	Value    func(*TaskHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) taskhistory.OrderOption
	toCursor func(*TaskHistory) Cursor
}

// TaskHistoryOrder defines the ordering of TaskHistory.
type TaskHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *TaskHistoryOrderField `json:"field"`
}

// DefaultTaskHistoryOrder is the default ordering of TaskHistory.
var DefaultTaskHistoryOrder = &TaskHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: taskhistory.FieldID,
		toTerm: taskhistory.ByID,
		toCursor: func(_m *TaskHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TaskHistory into TaskHistoryEdge.
func (_m *TaskHistory) ToEdge(order *TaskHistoryOrder) *TaskHistoryEdge {
	if order == nil {
		order = DefaultTaskHistoryOrder
	}
	return &TaskHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TemplateHistoryEdge is the edge representation of TemplateHistory.
type TemplateHistoryEdge struct {
	Node   *TemplateHistory `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// TemplateHistoryConnection is the connection containing edges to TemplateHistory.
type TemplateHistoryConnection struct {
	Edges      []*TemplateHistoryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *TemplateHistoryConnection) build(nodes []*TemplateHistory, pager *templatehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TemplateHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TemplateHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TemplateHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TemplateHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TemplateHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TemplateHistoryPaginateOption enables pagination customization.
type TemplateHistoryPaginateOption func(*templatehistoryPager) error

// WithTemplateHistoryOrder configures pagination ordering.
func WithTemplateHistoryOrder(order *TemplateHistoryOrder) TemplateHistoryPaginateOption {
	if order == nil {
		order = DefaultTemplateHistoryOrder
	}
	o := *order
	return func(pager *templatehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTemplateHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTemplateHistoryFilter configures pagination filter.
func WithTemplateHistoryFilter(filter func(*TemplateHistoryQuery) (*TemplateHistoryQuery, error)) TemplateHistoryPaginateOption {
	return func(pager *templatehistoryPager) error {
		if filter == nil {
			return errors.New("TemplateHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type templatehistoryPager struct {
	reverse bool
	order   *TemplateHistoryOrder
	filter  func(*TemplateHistoryQuery) (*TemplateHistoryQuery, error)
}

func newTemplateHistoryPager(opts []TemplateHistoryPaginateOption, reverse bool) (*templatehistoryPager, error) {
	pager := &templatehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTemplateHistoryOrder
	}
	return pager, nil
}

func (p *templatehistoryPager) applyFilter(query *TemplateHistoryQuery) (*TemplateHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *templatehistoryPager) toCursor(_m *TemplateHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *templatehistoryPager) applyCursors(query *TemplateHistoryQuery, after, before *Cursor) (*TemplateHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTemplateHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *templatehistoryPager) applyOrder(query *TemplateHistoryQuery) *TemplateHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTemplateHistoryOrder.Field {
		query = query.Order(DefaultTemplateHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *templatehistoryPager) orderExpr(query *TemplateHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTemplateHistoryOrder.Field {
			b.Comma().Ident(DefaultTemplateHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TemplateHistory.
func (_m *TemplateHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TemplateHistoryPaginateOption,
) (*TemplateHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTemplateHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TemplateHistoryConnection{Edges: []*TemplateHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TemplateHistoryOrderFieldHistoryTime orders TemplateHistory by history_time.
	TemplateHistoryOrderFieldHistoryTime = &TemplateHistoryOrderField{
		Value: func(_m *TemplateHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: templatehistory.FieldHistoryTime,
		toTerm: templatehistory.ByHistoryTime,
		toCursor: func(_m *TemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TemplateHistoryOrderFieldCreatedAt orders TemplateHistory by created_at.
	TemplateHistoryOrderFieldCreatedAt = &TemplateHistoryOrderField{
		Value: func(_m *TemplateHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: templatehistory.FieldCreatedAt,
		toTerm: templatehistory.ByCreatedAt,
		toCursor: func(_m *TemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TemplateHistoryOrderFieldUpdatedAt orders TemplateHistory by updated_at.
	TemplateHistoryOrderFieldUpdatedAt = &TemplateHistoryOrderField{
		Value: func(_m *TemplateHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: templatehistory.FieldUpdatedAt,
		toTerm: templatehistory.ByUpdatedAt,
		toCursor: func(_m *TemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// TemplateHistoryOrderFieldName orders TemplateHistory by name.
	TemplateHistoryOrderFieldName = &TemplateHistoryOrderField{
		Value: func(_m *TemplateHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: templatehistory.FieldName,
		toTerm: templatehistory.ByName,
		toCursor: func(_m *TemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// TemplateHistoryOrderFieldTemplateType orders TemplateHistory by template_type.
	TemplateHistoryOrderFieldTemplateType = &TemplateHistoryOrderField{
		Value: func(_m *TemplateHistory) (ent.Value, error) {
			return _m.TemplateType, nil
		},
		column: templatehistory.FieldTemplateType,
		toTerm: templatehistory.ByTemplateType,
		toCursor: func(_m *TemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.TemplateType,
			}
		},
	}
	// TemplateHistoryOrderFieldKind orders TemplateHistory by kind.
	TemplateHistoryOrderFieldKind = &TemplateHistoryOrderField{
		Value: func(_m *TemplateHistory) (ent.Value, error) {
			return _m.Kind, nil
		},
		column: templatehistory.FieldKind,
		toTerm: templatehistory.ByKind,
		toCursor: func(_m *TemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Kind,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TemplateHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TemplateHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TemplateHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TemplateHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TemplateHistoryOrderFieldName.column:
		str = "name"
	case TemplateHistoryOrderFieldTemplateType.column:
		str = "TEMPLATE_TYPE"
	case TemplateHistoryOrderFieldKind.column:
		str = "KIND"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TemplateHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TemplateHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TemplateHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TemplateHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TemplateHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TemplateHistoryOrderFieldUpdatedAt
	case "name":
		*f = *TemplateHistoryOrderFieldName
	case "TEMPLATE_TYPE":
		*f = *TemplateHistoryOrderFieldTemplateType
	case "KIND":
		*f = *TemplateHistoryOrderFieldKind
	default:
		return fmt.Errorf("%s is not a valid TemplateHistoryOrderField", str)
	}
	return nil
}

// TemplateHistoryOrderField defines the ordering field of TemplateHistory.
type TemplateHistoryOrderField struct {
	// Value extracts the ordering value from the given TemplateHistory.
	Value    func(*TemplateHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) templatehistory.OrderOption
	toCursor func(*TemplateHistory) Cursor
}

// TemplateHistoryOrder defines the ordering of TemplateHistory.
type TemplateHistoryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *TemplateHistoryOrderField `json:"field"`
}

// DefaultTemplateHistoryOrder is the default ordering of TemplateHistory.
var DefaultTemplateHistoryOrder = &TemplateHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TemplateHistoryOrderField{
		Value: func(_m *TemplateHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: templatehistory.FieldID,
		toTerm: templatehistory.ByID,
		toCursor: func(_m *TemplateHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TemplateHistory into TemplateHistoryEdge.
func (_m *TemplateHistory) ToEdge(order *TemplateHistoryOrder) *TemplateHistoryEdge {
	if order == nil {
		order = DefaultTemplateHistoryOrder
	}
	return &TemplateHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterComplianceHistoryEdge is the edge representation of TrustCenterComplianceHistory.
type TrustCenterComplianceHistoryEdge struct {
	Node   *TrustCenterComplianceHistory `json:"node"`
	Cursor Cursor                        `json:"cursor"`
}

// TrustCenterComplianceHistoryConnection is the connection containing edges to TrustCenterComplianceHistory.
type TrustCenterComplianceHistoryConnection struct {
	Edges      []*TrustCenterComplianceHistoryEdge `json:"edges"`
	PageInfo   PageInfo                            `json:"pageInfo"`
	TotalCount int                                 `json:"totalCount"`
}

func (c *TrustCenterComplianceHistoryConnection) build(nodes []*TrustCenterComplianceHistory, pager *trustcentercompliancehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterComplianceHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterComplianceHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterComplianceHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterComplianceHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterComplianceHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterComplianceHistoryPaginateOption enables pagination customization.
type TrustCenterComplianceHistoryPaginateOption func(*trustcentercompliancehistoryPager) error

// WithTrustCenterComplianceHistoryOrder configures pagination ordering.
func WithTrustCenterComplianceHistoryOrder(order *TrustCenterComplianceHistoryOrder) TrustCenterComplianceHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterComplianceHistoryOrder
	}
	o := *order
	return func(pager *trustcentercompliancehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterComplianceHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterComplianceHistoryFilter configures pagination filter.
func WithTrustCenterComplianceHistoryFilter(filter func(*TrustCenterComplianceHistoryQuery) (*TrustCenterComplianceHistoryQuery, error)) TrustCenterComplianceHistoryPaginateOption {
	return func(pager *trustcentercompliancehistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterComplianceHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcentercompliancehistoryPager struct {
	reverse bool
	order   *TrustCenterComplianceHistoryOrder
	filter  func(*TrustCenterComplianceHistoryQuery) (*TrustCenterComplianceHistoryQuery, error)
}

func newTrustCenterComplianceHistoryPager(opts []TrustCenterComplianceHistoryPaginateOption, reverse bool) (*trustcentercompliancehistoryPager, error) {
	pager := &trustcentercompliancehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterComplianceHistoryOrder
	}
	return pager, nil
}

func (p *trustcentercompliancehistoryPager) applyFilter(query *TrustCenterComplianceHistoryQuery) (*TrustCenterComplianceHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcentercompliancehistoryPager) toCursor(_m *TrustCenterComplianceHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcentercompliancehistoryPager) applyCursors(query *TrustCenterComplianceHistoryQuery, after, before *Cursor) (*TrustCenterComplianceHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterComplianceHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcentercompliancehistoryPager) applyOrder(query *TrustCenterComplianceHistoryQuery) *TrustCenterComplianceHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterComplianceHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterComplianceHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcentercompliancehistoryPager) orderExpr(query *TrustCenterComplianceHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterComplianceHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterComplianceHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterComplianceHistory.
func (_m *TrustCenterComplianceHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterComplianceHistoryPaginateOption,
) (*TrustCenterComplianceHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterComplianceHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterComplianceHistoryConnection{Edges: []*TrustCenterComplianceHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterComplianceHistoryOrderFieldHistoryTime orders TrustCenterComplianceHistory by history_time.
	TrustCenterComplianceHistoryOrderFieldHistoryTime = &TrustCenterComplianceHistoryOrderField{
		Value: func(_m *TrustCenterComplianceHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcentercompliancehistory.FieldHistoryTime,
		toTerm: trustcentercompliancehistory.ByHistoryTime,
		toCursor: func(_m *TrustCenterComplianceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustCenterComplianceHistoryOrderFieldCreatedAt orders TrustCenterComplianceHistory by created_at.
	TrustCenterComplianceHistoryOrderFieldCreatedAt = &TrustCenterComplianceHistoryOrderField{
		Value: func(_m *TrustCenterComplianceHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcentercompliancehistory.FieldCreatedAt,
		toTerm: trustcentercompliancehistory.ByCreatedAt,
		toCursor: func(_m *TrustCenterComplianceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterComplianceHistoryOrderFieldUpdatedAt orders TrustCenterComplianceHistory by updated_at.
	TrustCenterComplianceHistoryOrderFieldUpdatedAt = &TrustCenterComplianceHistoryOrderField{
		Value: func(_m *TrustCenterComplianceHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcentercompliancehistory.FieldUpdatedAt,
		toTerm: trustcentercompliancehistory.ByUpdatedAt,
		toCursor: func(_m *TrustCenterComplianceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterComplianceHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterComplianceHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterComplianceHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterComplianceHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterComplianceHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterComplianceHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterComplianceHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterComplianceHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterComplianceHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterComplianceHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterComplianceHistoryOrderField", str)
	}
	return nil
}

// TrustCenterComplianceHistoryOrderField defines the ordering field of TrustCenterComplianceHistory.
type TrustCenterComplianceHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterComplianceHistory.
	Value    func(*TrustCenterComplianceHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcentercompliancehistory.OrderOption
	toCursor func(*TrustCenterComplianceHistory) Cursor
}

// TrustCenterComplianceHistoryOrder defines the ordering of TrustCenterComplianceHistory.
type TrustCenterComplianceHistoryOrder struct {
	Direction OrderDirection                          `json:"direction"`
	Field     *TrustCenterComplianceHistoryOrderField `json:"field"`
}

// DefaultTrustCenterComplianceHistoryOrder is the default ordering of TrustCenterComplianceHistory.
var DefaultTrustCenterComplianceHistoryOrder = &TrustCenterComplianceHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterComplianceHistoryOrderField{
		Value: func(_m *TrustCenterComplianceHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcentercompliancehistory.FieldID,
		toTerm: trustcentercompliancehistory.ByID,
		toCursor: func(_m *TrustCenterComplianceHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterComplianceHistory into TrustCenterComplianceHistoryEdge.
func (_m *TrustCenterComplianceHistory) ToEdge(order *TrustCenterComplianceHistoryOrder) *TrustCenterComplianceHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterComplianceHistoryOrder
	}
	return &TrustCenterComplianceHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterDocHistoryEdge is the edge representation of TrustCenterDocHistory.
type TrustCenterDocHistoryEdge struct {
	Node   *TrustCenterDocHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// TrustCenterDocHistoryConnection is the connection containing edges to TrustCenterDocHistory.
type TrustCenterDocHistoryConnection struct {
	Edges      []*TrustCenterDocHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *TrustCenterDocHistoryConnection) build(nodes []*TrustCenterDocHistory, pager *trustcenterdochistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterDocHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterDocHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterDocHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterDocHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterDocHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterDocHistoryPaginateOption enables pagination customization.
type TrustCenterDocHistoryPaginateOption func(*trustcenterdochistoryPager) error

// WithTrustCenterDocHistoryOrder configures pagination ordering.
func WithTrustCenterDocHistoryOrder(order *TrustCenterDocHistoryOrder) TrustCenterDocHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterDocHistoryOrder
	}
	o := *order
	return func(pager *trustcenterdochistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterDocHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterDocHistoryFilter configures pagination filter.
func WithTrustCenterDocHistoryFilter(filter func(*TrustCenterDocHistoryQuery) (*TrustCenterDocHistoryQuery, error)) TrustCenterDocHistoryPaginateOption {
	return func(pager *trustcenterdochistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterDocHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterdochistoryPager struct {
	reverse bool
	order   *TrustCenterDocHistoryOrder
	filter  func(*TrustCenterDocHistoryQuery) (*TrustCenterDocHistoryQuery, error)
}

func newTrustCenterDocHistoryPager(opts []TrustCenterDocHistoryPaginateOption, reverse bool) (*trustcenterdochistoryPager, error) {
	pager := &trustcenterdochistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterDocHistoryOrder
	}
	return pager, nil
}

func (p *trustcenterdochistoryPager) applyFilter(query *TrustCenterDocHistoryQuery) (*TrustCenterDocHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterdochistoryPager) toCursor(_m *TrustCenterDocHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcenterdochistoryPager) applyCursors(query *TrustCenterDocHistoryQuery, after, before *Cursor) (*TrustCenterDocHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterDocHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcenterdochistoryPager) applyOrder(query *TrustCenterDocHistoryQuery) *TrustCenterDocHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterDocHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterDocHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcenterdochistoryPager) orderExpr(query *TrustCenterDocHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterDocHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterDocHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterDocHistory.
func (_m *TrustCenterDocHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterDocHistoryPaginateOption,
) (*TrustCenterDocHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterDocHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterDocHistoryConnection{Edges: []*TrustCenterDocHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterDocHistoryOrderFieldHistoryTime orders TrustCenterDocHistory by history_time.
	TrustCenterDocHistoryOrderFieldHistoryTime = &TrustCenterDocHistoryOrderField{
		Value: func(_m *TrustCenterDocHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcenterdochistory.FieldHistoryTime,
		toTerm: trustcenterdochistory.ByHistoryTime,
		toCursor: func(_m *TrustCenterDocHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustCenterDocHistoryOrderFieldCreatedAt orders TrustCenterDocHistory by created_at.
	TrustCenterDocHistoryOrderFieldCreatedAt = &TrustCenterDocHistoryOrderField{
		Value: func(_m *TrustCenterDocHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterdochistory.FieldCreatedAt,
		toTerm: trustcenterdochistory.ByCreatedAt,
		toCursor: func(_m *TrustCenterDocHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterDocHistoryOrderFieldUpdatedAt orders TrustCenterDocHistory by updated_at.
	TrustCenterDocHistoryOrderFieldUpdatedAt = &TrustCenterDocHistoryOrderField{
		Value: func(_m *TrustCenterDocHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterdochistory.FieldUpdatedAt,
		toTerm: trustcenterdochistory.ByUpdatedAt,
		toCursor: func(_m *TrustCenterDocHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterDocHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterDocHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterDocHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterDocHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterDocHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterDocHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterDocHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterDocHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterDocHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterDocHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterDocHistoryOrderField", str)
	}
	return nil
}

// TrustCenterDocHistoryOrderField defines the ordering field of TrustCenterDocHistory.
type TrustCenterDocHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterDocHistory.
	Value    func(*TrustCenterDocHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterdochistory.OrderOption
	toCursor func(*TrustCenterDocHistory) Cursor
}

// TrustCenterDocHistoryOrder defines the ordering of TrustCenterDocHistory.
type TrustCenterDocHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *TrustCenterDocHistoryOrderField `json:"field"`
}

// DefaultTrustCenterDocHistoryOrder is the default ordering of TrustCenterDocHistory.
var DefaultTrustCenterDocHistoryOrder = &TrustCenterDocHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterDocHistoryOrderField{
		Value: func(_m *TrustCenterDocHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterdochistory.FieldID,
		toTerm: trustcenterdochistory.ByID,
		toCursor: func(_m *TrustCenterDocHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterDocHistory into TrustCenterDocHistoryEdge.
func (_m *TrustCenterDocHistory) ToEdge(order *TrustCenterDocHistoryOrder) *TrustCenterDocHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterDocHistoryOrder
	}
	return &TrustCenterDocHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterEntityHistoryEdge is the edge representation of TrustCenterEntityHistory.
type TrustCenterEntityHistoryEdge struct {
	Node   *TrustCenterEntityHistory `json:"node"`
	Cursor Cursor                    `json:"cursor"`
}

// TrustCenterEntityHistoryConnection is the connection containing edges to TrustCenterEntityHistory.
type TrustCenterEntityHistoryConnection struct {
	Edges      []*TrustCenterEntityHistoryEdge `json:"edges"`
	PageInfo   PageInfo                        `json:"pageInfo"`
	TotalCount int                             `json:"totalCount"`
}

func (c *TrustCenterEntityHistoryConnection) build(nodes []*TrustCenterEntityHistory, pager *trustcenterentityhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterEntityHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterEntityHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterEntityHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterEntityHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterEntityHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterEntityHistoryPaginateOption enables pagination customization.
type TrustCenterEntityHistoryPaginateOption func(*trustcenterentityhistoryPager) error

// WithTrustCenterEntityHistoryOrder configures pagination ordering.
func WithTrustCenterEntityHistoryOrder(order *TrustCenterEntityHistoryOrder) TrustCenterEntityHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterEntityHistoryOrder
	}
	o := *order
	return func(pager *trustcenterentityhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterEntityHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterEntityHistoryFilter configures pagination filter.
func WithTrustCenterEntityHistoryFilter(filter func(*TrustCenterEntityHistoryQuery) (*TrustCenterEntityHistoryQuery, error)) TrustCenterEntityHistoryPaginateOption {
	return func(pager *trustcenterentityhistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterEntityHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterentityhistoryPager struct {
	reverse bool
	order   *TrustCenterEntityHistoryOrder
	filter  func(*TrustCenterEntityHistoryQuery) (*TrustCenterEntityHistoryQuery, error)
}

func newTrustCenterEntityHistoryPager(opts []TrustCenterEntityHistoryPaginateOption, reverse bool) (*trustcenterentityhistoryPager, error) {
	pager := &trustcenterentityhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterEntityHistoryOrder
	}
	return pager, nil
}

func (p *trustcenterentityhistoryPager) applyFilter(query *TrustCenterEntityHistoryQuery) (*TrustCenterEntityHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterentityhistoryPager) toCursor(_m *TrustCenterEntityHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcenterentityhistoryPager) applyCursors(query *TrustCenterEntityHistoryQuery, after, before *Cursor) (*TrustCenterEntityHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterEntityHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcenterentityhistoryPager) applyOrder(query *TrustCenterEntityHistoryQuery) *TrustCenterEntityHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterEntityHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterEntityHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcenterentityhistoryPager) orderExpr(query *TrustCenterEntityHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterEntityHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterEntityHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterEntityHistory.
func (_m *TrustCenterEntityHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterEntityHistoryPaginateOption,
) (*TrustCenterEntityHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterEntityHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterEntityHistoryConnection{Edges: []*TrustCenterEntityHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterEntityHistoryOrderFieldHistoryTime orders TrustCenterEntityHistory by history_time.
	TrustCenterEntityHistoryOrderFieldHistoryTime = &TrustCenterEntityHistoryOrderField{
		Value: func(_m *TrustCenterEntityHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcenterentityhistory.FieldHistoryTime,
		toTerm: trustcenterentityhistory.ByHistoryTime,
		toCursor: func(_m *TrustCenterEntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustCenterEntityHistoryOrderFieldCreatedAt orders TrustCenterEntityHistory by created_at.
	TrustCenterEntityHistoryOrderFieldCreatedAt = &TrustCenterEntityHistoryOrderField{
		Value: func(_m *TrustCenterEntityHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterentityhistory.FieldCreatedAt,
		toTerm: trustcenterentityhistory.ByCreatedAt,
		toCursor: func(_m *TrustCenterEntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterEntityHistoryOrderFieldUpdatedAt orders TrustCenterEntityHistory by updated_at.
	TrustCenterEntityHistoryOrderFieldUpdatedAt = &TrustCenterEntityHistoryOrderField{
		Value: func(_m *TrustCenterEntityHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterentityhistory.FieldUpdatedAt,
		toTerm: trustcenterentityhistory.ByUpdatedAt,
		toCursor: func(_m *TrustCenterEntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// TrustCenterEntityHistoryOrderFieldName orders TrustCenterEntityHistory by name.
	TrustCenterEntityHistoryOrderFieldName = &TrustCenterEntityHistoryOrderField{
		Value: func(_m *TrustCenterEntityHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: trustcenterentityhistory.FieldName,
		toTerm: trustcenterentityhistory.ByName,
		toCursor: func(_m *TrustCenterEntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterEntityHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterEntityHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterEntityHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterEntityHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TrustCenterEntityHistoryOrderFieldName.column:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterEntityHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterEntityHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterEntityHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterEntityHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterEntityHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterEntityHistoryOrderFieldUpdatedAt
	case "NAME":
		*f = *TrustCenterEntityHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid TrustCenterEntityHistoryOrderField", str)
	}
	return nil
}

// TrustCenterEntityHistoryOrderField defines the ordering field of TrustCenterEntityHistory.
type TrustCenterEntityHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterEntityHistory.
	Value    func(*TrustCenterEntityHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterentityhistory.OrderOption
	toCursor func(*TrustCenterEntityHistory) Cursor
}

// TrustCenterEntityHistoryOrder defines the ordering of TrustCenterEntityHistory.
type TrustCenterEntityHistoryOrder struct {
	Direction OrderDirection                      `json:"direction"`
	Field     *TrustCenterEntityHistoryOrderField `json:"field"`
}

// DefaultTrustCenterEntityHistoryOrder is the default ordering of TrustCenterEntityHistory.
var DefaultTrustCenterEntityHistoryOrder = &TrustCenterEntityHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterEntityHistoryOrderField{
		Value: func(_m *TrustCenterEntityHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterentityhistory.FieldID,
		toTerm: trustcenterentityhistory.ByID,
		toCursor: func(_m *TrustCenterEntityHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterEntityHistory into TrustCenterEntityHistoryEdge.
func (_m *TrustCenterEntityHistory) ToEdge(order *TrustCenterEntityHistoryOrder) *TrustCenterEntityHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterEntityHistoryOrder
	}
	return &TrustCenterEntityHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterFAQHistoryEdge is the edge representation of TrustCenterFAQHistory.
type TrustCenterFAQHistoryEdge struct {
	Node   *TrustCenterFAQHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// TrustCenterFAQHistoryConnection is the connection containing edges to TrustCenterFAQHistory.
type TrustCenterFAQHistoryConnection struct {
	Edges      []*TrustCenterFAQHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *TrustCenterFAQHistoryConnection) build(nodes []*TrustCenterFAQHistory, pager *trustcenterfaqhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterFAQHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterFAQHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterFAQHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterFAQHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterFAQHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterFAQHistoryPaginateOption enables pagination customization.
type TrustCenterFAQHistoryPaginateOption func(*trustcenterfaqhistoryPager) error

// WithTrustCenterFAQHistoryOrder configures pagination ordering.
func WithTrustCenterFAQHistoryOrder(order *TrustCenterFAQHistoryOrder) TrustCenterFAQHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterFAQHistoryOrder
	}
	o := *order
	return func(pager *trustcenterfaqhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterFAQHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterFAQHistoryFilter configures pagination filter.
func WithTrustCenterFAQHistoryFilter(filter func(*TrustCenterFAQHistoryQuery) (*TrustCenterFAQHistoryQuery, error)) TrustCenterFAQHistoryPaginateOption {
	return func(pager *trustcenterfaqhistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterFAQHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterfaqhistoryPager struct {
	reverse bool
	order   *TrustCenterFAQHistoryOrder
	filter  func(*TrustCenterFAQHistoryQuery) (*TrustCenterFAQHistoryQuery, error)
}

func newTrustCenterFAQHistoryPager(opts []TrustCenterFAQHistoryPaginateOption, reverse bool) (*trustcenterfaqhistoryPager, error) {
	pager := &trustcenterfaqhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterFAQHistoryOrder
	}
	return pager, nil
}

func (p *trustcenterfaqhistoryPager) applyFilter(query *TrustCenterFAQHistoryQuery) (*TrustCenterFAQHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterfaqhistoryPager) toCursor(_m *TrustCenterFAQHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcenterfaqhistoryPager) applyCursors(query *TrustCenterFAQHistoryQuery, after, before *Cursor) (*TrustCenterFAQHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterFAQHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcenterfaqhistoryPager) applyOrder(query *TrustCenterFAQHistoryQuery) *TrustCenterFAQHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterFAQHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterFAQHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcenterfaqhistoryPager) orderExpr(query *TrustCenterFAQHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterFAQHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterFAQHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterFAQHistory.
func (_m *TrustCenterFAQHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterFAQHistoryPaginateOption,
) (*TrustCenterFAQHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterFAQHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterFAQHistoryConnection{Edges: []*TrustCenterFAQHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterFAQHistoryOrderFieldHistoryTime orders TrustCenterFAQHistory by history_time.
	TrustCenterFAQHistoryOrderFieldHistoryTime = &TrustCenterFAQHistoryOrderField{
		Value: func(_m *TrustCenterFAQHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcenterfaqhistory.FieldHistoryTime,
		toTerm: trustcenterfaqhistory.ByHistoryTime,
		toCursor: func(_m *TrustCenterFAQHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustCenterFAQHistoryOrderFieldCreatedAt orders TrustCenterFAQHistory by created_at.
	TrustCenterFAQHistoryOrderFieldCreatedAt = &TrustCenterFAQHistoryOrderField{
		Value: func(_m *TrustCenterFAQHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterfaqhistory.FieldCreatedAt,
		toTerm: trustcenterfaqhistory.ByCreatedAt,
		toCursor: func(_m *TrustCenterFAQHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterFAQHistoryOrderFieldUpdatedAt orders TrustCenterFAQHistory by updated_at.
	TrustCenterFAQHistoryOrderFieldUpdatedAt = &TrustCenterFAQHistoryOrderField{
		Value: func(_m *TrustCenterFAQHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterfaqhistory.FieldUpdatedAt,
		toTerm: trustcenterfaqhistory.ByUpdatedAt,
		toCursor: func(_m *TrustCenterFAQHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterFAQHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterFAQHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterFAQHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterFAQHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterFAQHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterFAQHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterFAQHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterFAQHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterFAQHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterFAQHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterFAQHistoryOrderField", str)
	}
	return nil
}

// TrustCenterFAQHistoryOrderField defines the ordering field of TrustCenterFAQHistory.
type TrustCenterFAQHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterFAQHistory.
	Value    func(*TrustCenterFAQHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterfaqhistory.OrderOption
	toCursor func(*TrustCenterFAQHistory) Cursor
}

// TrustCenterFAQHistoryOrder defines the ordering of TrustCenterFAQHistory.
type TrustCenterFAQHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *TrustCenterFAQHistoryOrderField `json:"field"`
}

// DefaultTrustCenterFAQHistoryOrder is the default ordering of TrustCenterFAQHistory.
var DefaultTrustCenterFAQHistoryOrder = &TrustCenterFAQHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterFAQHistoryOrderField{
		Value: func(_m *TrustCenterFAQHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterfaqhistory.FieldID,
		toTerm: trustcenterfaqhistory.ByID,
		toCursor: func(_m *TrustCenterFAQHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterFAQHistory into TrustCenterFAQHistoryEdge.
func (_m *TrustCenterFAQHistory) ToEdge(order *TrustCenterFAQHistoryOrder) *TrustCenterFAQHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterFAQHistoryOrder
	}
	return &TrustCenterFAQHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterHistoryEdge is the edge representation of TrustCenterHistory.
type TrustCenterHistoryEdge struct {
	Node   *TrustCenterHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// TrustCenterHistoryConnection is the connection containing edges to TrustCenterHistory.
type TrustCenterHistoryConnection struct {
	Edges      []*TrustCenterHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *TrustCenterHistoryConnection) build(nodes []*TrustCenterHistory, pager *trustcenterhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterHistoryPaginateOption enables pagination customization.
type TrustCenterHistoryPaginateOption func(*trustcenterhistoryPager) error

// WithTrustCenterHistoryOrder configures pagination ordering.
func WithTrustCenterHistoryOrder(order *TrustCenterHistoryOrder) TrustCenterHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterHistoryOrder
	}
	o := *order
	return func(pager *trustcenterhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterHistoryFilter configures pagination filter.
func WithTrustCenterHistoryFilter(filter func(*TrustCenterHistoryQuery) (*TrustCenterHistoryQuery, error)) TrustCenterHistoryPaginateOption {
	return func(pager *trustcenterhistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterhistoryPager struct {
	reverse bool
	order   *TrustCenterHistoryOrder
	filter  func(*TrustCenterHistoryQuery) (*TrustCenterHistoryQuery, error)
}

func newTrustCenterHistoryPager(opts []TrustCenterHistoryPaginateOption, reverse bool) (*trustcenterhistoryPager, error) {
	pager := &trustcenterhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterHistoryOrder
	}
	return pager, nil
}

func (p *trustcenterhistoryPager) applyFilter(query *TrustCenterHistoryQuery) (*TrustCenterHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterhistoryPager) toCursor(_m *TrustCenterHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcenterhistoryPager) applyCursors(query *TrustCenterHistoryQuery, after, before *Cursor) (*TrustCenterHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcenterhistoryPager) applyOrder(query *TrustCenterHistoryQuery) *TrustCenterHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcenterhistoryPager) orderExpr(query *TrustCenterHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterHistory.
func (_m *TrustCenterHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterHistoryPaginateOption,
) (*TrustCenterHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterHistoryConnection{Edges: []*TrustCenterHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterHistoryOrderFieldHistoryTime orders TrustCenterHistory by history_time.
	TrustCenterHistoryOrderFieldHistoryTime = &TrustCenterHistoryOrderField{
		Value: func(_m *TrustCenterHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcenterhistory.FieldHistoryTime,
		toTerm: trustcenterhistory.ByHistoryTime,
		toCursor: func(_m *TrustCenterHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustCenterHistoryOrderFieldCreatedAt orders TrustCenterHistory by created_at.
	TrustCenterHistoryOrderFieldCreatedAt = &TrustCenterHistoryOrderField{
		Value: func(_m *TrustCenterHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterhistory.FieldCreatedAt,
		toTerm: trustcenterhistory.ByCreatedAt,
		toCursor: func(_m *TrustCenterHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterHistoryOrderFieldUpdatedAt orders TrustCenterHistory by updated_at.
	TrustCenterHistoryOrderFieldUpdatedAt = &TrustCenterHistoryOrderField{
		Value: func(_m *TrustCenterHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterhistory.FieldUpdatedAt,
		toTerm: trustcenterhistory.ByUpdatedAt,
		toCursor: func(_m *TrustCenterHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterHistoryOrderField", str)
	}
	return nil
}

// TrustCenterHistoryOrderField defines the ordering field of TrustCenterHistory.
type TrustCenterHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterHistory.
	Value    func(*TrustCenterHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterhistory.OrderOption
	toCursor func(*TrustCenterHistory) Cursor
}

// TrustCenterHistoryOrder defines the ordering of TrustCenterHistory.
type TrustCenterHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *TrustCenterHistoryOrderField `json:"field"`
}

// DefaultTrustCenterHistoryOrder is the default ordering of TrustCenterHistory.
var DefaultTrustCenterHistoryOrder = &TrustCenterHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterHistoryOrderField{
		Value: func(_m *TrustCenterHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterhistory.FieldID,
		toTerm: trustcenterhistory.ByID,
		toCursor: func(_m *TrustCenterHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterHistory into TrustCenterHistoryEdge.
func (_m *TrustCenterHistory) ToEdge(order *TrustCenterHistoryOrder) *TrustCenterHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterHistoryOrder
	}
	return &TrustCenterHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterNDARequestHistoryEdge is the edge representation of TrustCenterNDARequestHistory.
type TrustCenterNDARequestHistoryEdge struct {
	Node   *TrustCenterNDARequestHistory `json:"node"`
	Cursor Cursor                        `json:"cursor"`
}

// TrustCenterNDARequestHistoryConnection is the connection containing edges to TrustCenterNDARequestHistory.
type TrustCenterNDARequestHistoryConnection struct {
	Edges      []*TrustCenterNDARequestHistoryEdge `json:"edges"`
	PageInfo   PageInfo                            `json:"pageInfo"`
	TotalCount int                                 `json:"totalCount"`
}

func (c *TrustCenterNDARequestHistoryConnection) build(nodes []*TrustCenterNDARequestHistory, pager *trustcenterndarequesthistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterNDARequestHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterNDARequestHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterNDARequestHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterNDARequestHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterNDARequestHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterNDARequestHistoryPaginateOption enables pagination customization.
type TrustCenterNDARequestHistoryPaginateOption func(*trustcenterndarequesthistoryPager) error

// WithTrustCenterNDARequestHistoryOrder configures pagination ordering.
func WithTrustCenterNDARequestHistoryOrder(order *TrustCenterNDARequestHistoryOrder) TrustCenterNDARequestHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterNDARequestHistoryOrder
	}
	o := *order
	return func(pager *trustcenterndarequesthistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterNDARequestHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterNDARequestHistoryFilter configures pagination filter.
func WithTrustCenterNDARequestHistoryFilter(filter func(*TrustCenterNDARequestHistoryQuery) (*TrustCenterNDARequestHistoryQuery, error)) TrustCenterNDARequestHistoryPaginateOption {
	return func(pager *trustcenterndarequesthistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterNDARequestHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterndarequesthistoryPager struct {
	reverse bool
	order   *TrustCenterNDARequestHistoryOrder
	filter  func(*TrustCenterNDARequestHistoryQuery) (*TrustCenterNDARequestHistoryQuery, error)
}

func newTrustCenterNDARequestHistoryPager(opts []TrustCenterNDARequestHistoryPaginateOption, reverse bool) (*trustcenterndarequesthistoryPager, error) {
	pager := &trustcenterndarequesthistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterNDARequestHistoryOrder
	}
	return pager, nil
}

func (p *trustcenterndarequesthistoryPager) applyFilter(query *TrustCenterNDARequestHistoryQuery) (*TrustCenterNDARequestHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterndarequesthistoryPager) toCursor(_m *TrustCenterNDARequestHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcenterndarequesthistoryPager) applyCursors(query *TrustCenterNDARequestHistoryQuery, after, before *Cursor) (*TrustCenterNDARequestHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterNDARequestHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcenterndarequesthistoryPager) applyOrder(query *TrustCenterNDARequestHistoryQuery) *TrustCenterNDARequestHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterNDARequestHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterNDARequestHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcenterndarequesthistoryPager) orderExpr(query *TrustCenterNDARequestHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterNDARequestHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterNDARequestHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterNDARequestHistory.
func (_m *TrustCenterNDARequestHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterNDARequestHistoryPaginateOption,
) (*TrustCenterNDARequestHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterNDARequestHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterNDARequestHistoryConnection{Edges: []*TrustCenterNDARequestHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterNDARequestHistoryOrderFieldHistoryTime orders TrustCenterNDARequestHistory by history_time.
	TrustCenterNDARequestHistoryOrderFieldHistoryTime = &TrustCenterNDARequestHistoryOrderField{
		Value: func(_m *TrustCenterNDARequestHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcenterndarequesthistory.FieldHistoryTime,
		toTerm: trustcenterndarequesthistory.ByHistoryTime,
		toCursor: func(_m *TrustCenterNDARequestHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustCenterNDARequestHistoryOrderFieldCreatedAt orders TrustCenterNDARequestHistory by created_at.
	TrustCenterNDARequestHistoryOrderFieldCreatedAt = &TrustCenterNDARequestHistoryOrderField{
		Value: func(_m *TrustCenterNDARequestHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterndarequesthistory.FieldCreatedAt,
		toTerm: trustcenterndarequesthistory.ByCreatedAt,
		toCursor: func(_m *TrustCenterNDARequestHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterNDARequestHistoryOrderFieldUpdatedAt orders TrustCenterNDARequestHistory by updated_at.
	TrustCenterNDARequestHistoryOrderFieldUpdatedAt = &TrustCenterNDARequestHistoryOrderField{
		Value: func(_m *TrustCenterNDARequestHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterndarequesthistory.FieldUpdatedAt,
		toTerm: trustcenterndarequesthistory.ByUpdatedAt,
		toCursor: func(_m *TrustCenterNDARequestHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterNDARequestHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterNDARequestHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterNDARequestHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterNDARequestHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterNDARequestHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterNDARequestHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterNDARequestHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterNDARequestHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterNDARequestHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterNDARequestHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterNDARequestHistoryOrderField", str)
	}
	return nil
}

// TrustCenterNDARequestHistoryOrderField defines the ordering field of TrustCenterNDARequestHistory.
type TrustCenterNDARequestHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterNDARequestHistory.
	Value    func(*TrustCenterNDARequestHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterndarequesthistory.OrderOption
	toCursor func(*TrustCenterNDARequestHistory) Cursor
}

// TrustCenterNDARequestHistoryOrder defines the ordering of TrustCenterNDARequestHistory.
type TrustCenterNDARequestHistoryOrder struct {
	Direction OrderDirection                          `json:"direction"`
	Field     *TrustCenterNDARequestHistoryOrderField `json:"field"`
}

// DefaultTrustCenterNDARequestHistoryOrder is the default ordering of TrustCenterNDARequestHistory.
var DefaultTrustCenterNDARequestHistoryOrder = &TrustCenterNDARequestHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterNDARequestHistoryOrderField{
		Value: func(_m *TrustCenterNDARequestHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterndarequesthistory.FieldID,
		toTerm: trustcenterndarequesthistory.ByID,
		toCursor: func(_m *TrustCenterNDARequestHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterNDARequestHistory into TrustCenterNDARequestHistoryEdge.
func (_m *TrustCenterNDARequestHistory) ToEdge(order *TrustCenterNDARequestHistoryOrder) *TrustCenterNDARequestHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterNDARequestHistoryOrder
	}
	return &TrustCenterNDARequestHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterSettingHistoryEdge is the edge representation of TrustCenterSettingHistory.
type TrustCenterSettingHistoryEdge struct {
	Node   *TrustCenterSettingHistory `json:"node"`
	Cursor Cursor                     `json:"cursor"`
}

// TrustCenterSettingHistoryConnection is the connection containing edges to TrustCenterSettingHistory.
type TrustCenterSettingHistoryConnection struct {
	Edges      []*TrustCenterSettingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                         `json:"pageInfo"`
	TotalCount int                              `json:"totalCount"`
}

func (c *TrustCenterSettingHistoryConnection) build(nodes []*TrustCenterSettingHistory, pager *trustcentersettinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterSettingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterSettingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterSettingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterSettingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterSettingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterSettingHistoryPaginateOption enables pagination customization.
type TrustCenterSettingHistoryPaginateOption func(*trustcentersettinghistoryPager) error

// WithTrustCenterSettingHistoryOrder configures pagination ordering.
func WithTrustCenterSettingHistoryOrder(order *TrustCenterSettingHistoryOrder) TrustCenterSettingHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterSettingHistoryOrder
	}
	o := *order
	return func(pager *trustcentersettinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterSettingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterSettingHistoryFilter configures pagination filter.
func WithTrustCenterSettingHistoryFilter(filter func(*TrustCenterSettingHistoryQuery) (*TrustCenterSettingHistoryQuery, error)) TrustCenterSettingHistoryPaginateOption {
	return func(pager *trustcentersettinghistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterSettingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcentersettinghistoryPager struct {
	reverse bool
	order   *TrustCenterSettingHistoryOrder
	filter  func(*TrustCenterSettingHistoryQuery) (*TrustCenterSettingHistoryQuery, error)
}

func newTrustCenterSettingHistoryPager(opts []TrustCenterSettingHistoryPaginateOption, reverse bool) (*trustcentersettinghistoryPager, error) {
	pager := &trustcentersettinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterSettingHistoryOrder
	}
	return pager, nil
}

func (p *trustcentersettinghistoryPager) applyFilter(query *TrustCenterSettingHistoryQuery) (*TrustCenterSettingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcentersettinghistoryPager) toCursor(_m *TrustCenterSettingHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcentersettinghistoryPager) applyCursors(query *TrustCenterSettingHistoryQuery, after, before *Cursor) (*TrustCenterSettingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterSettingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcentersettinghistoryPager) applyOrder(query *TrustCenterSettingHistoryQuery) *TrustCenterSettingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterSettingHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterSettingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcentersettinghistoryPager) orderExpr(query *TrustCenterSettingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterSettingHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterSettingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterSettingHistory.
func (_m *TrustCenterSettingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterSettingHistoryPaginateOption,
) (*TrustCenterSettingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterSettingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterSettingHistoryConnection{Edges: []*TrustCenterSettingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterSettingHistoryOrderFieldHistoryTime orders TrustCenterSettingHistory by history_time.
	TrustCenterSettingHistoryOrderFieldHistoryTime = &TrustCenterSettingHistoryOrderField{
		Value: func(_m *TrustCenterSettingHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcentersettinghistory.FieldHistoryTime,
		toTerm: trustcentersettinghistory.ByHistoryTime,
		toCursor: func(_m *TrustCenterSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustCenterSettingHistoryOrderFieldCreatedAt orders TrustCenterSettingHistory by created_at.
	TrustCenterSettingHistoryOrderFieldCreatedAt = &TrustCenterSettingHistoryOrderField{
		Value: func(_m *TrustCenterSettingHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcentersettinghistory.FieldCreatedAt,
		toTerm: trustcentersettinghistory.ByCreatedAt,
		toCursor: func(_m *TrustCenterSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterSettingHistoryOrderFieldUpdatedAt orders TrustCenterSettingHistory by updated_at.
	TrustCenterSettingHistoryOrderFieldUpdatedAt = &TrustCenterSettingHistoryOrderField{
		Value: func(_m *TrustCenterSettingHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcentersettinghistory.FieldUpdatedAt,
		toTerm: trustcentersettinghistory.ByUpdatedAt,
		toCursor: func(_m *TrustCenterSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterSettingHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterSettingHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterSettingHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterSettingHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterSettingHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterSettingHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterSettingHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterSettingHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterSettingHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterSettingHistoryOrderField", str)
	}
	return nil
}

// TrustCenterSettingHistoryOrderField defines the ordering field of TrustCenterSettingHistory.
type TrustCenterSettingHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterSettingHistory.
	Value    func(*TrustCenterSettingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcentersettinghistory.OrderOption
	toCursor func(*TrustCenterSettingHistory) Cursor
}

// TrustCenterSettingHistoryOrder defines the ordering of TrustCenterSettingHistory.
type TrustCenterSettingHistoryOrder struct {
	Direction OrderDirection                       `json:"direction"`
	Field     *TrustCenterSettingHistoryOrderField `json:"field"`
}

// DefaultTrustCenterSettingHistoryOrder is the default ordering of TrustCenterSettingHistory.
var DefaultTrustCenterSettingHistoryOrder = &TrustCenterSettingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterSettingHistoryOrderField{
		Value: func(_m *TrustCenterSettingHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcentersettinghistory.FieldID,
		toTerm: trustcentersettinghistory.ByID,
		toCursor: func(_m *TrustCenterSettingHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterSettingHistory into TrustCenterSettingHistoryEdge.
func (_m *TrustCenterSettingHistory) ToEdge(order *TrustCenterSettingHistoryOrder) *TrustCenterSettingHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterSettingHistoryOrder
	}
	return &TrustCenterSettingHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterSubprocessorHistoryEdge is the edge representation of TrustCenterSubprocessorHistory.
type TrustCenterSubprocessorHistoryEdge struct {
	Node   *TrustCenterSubprocessorHistory `json:"node"`
	Cursor Cursor                          `json:"cursor"`
}

// TrustCenterSubprocessorHistoryConnection is the connection containing edges to TrustCenterSubprocessorHistory.
type TrustCenterSubprocessorHistoryConnection struct {
	Edges      []*TrustCenterSubprocessorHistoryEdge `json:"edges"`
	PageInfo   PageInfo                              `json:"pageInfo"`
	TotalCount int                                   `json:"totalCount"`
}

func (c *TrustCenterSubprocessorHistoryConnection) build(nodes []*TrustCenterSubprocessorHistory, pager *trustcentersubprocessorhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterSubprocessorHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterSubprocessorHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterSubprocessorHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterSubprocessorHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterSubprocessorHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterSubprocessorHistoryPaginateOption enables pagination customization.
type TrustCenterSubprocessorHistoryPaginateOption func(*trustcentersubprocessorhistoryPager) error

// WithTrustCenterSubprocessorHistoryOrder configures pagination ordering.
func WithTrustCenterSubprocessorHistoryOrder(order *TrustCenterSubprocessorHistoryOrder) TrustCenterSubprocessorHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterSubprocessorHistoryOrder
	}
	o := *order
	return func(pager *trustcentersubprocessorhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterSubprocessorHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterSubprocessorHistoryFilter configures pagination filter.
func WithTrustCenterSubprocessorHistoryFilter(filter func(*TrustCenterSubprocessorHistoryQuery) (*TrustCenterSubprocessorHistoryQuery, error)) TrustCenterSubprocessorHistoryPaginateOption {
	return func(pager *trustcentersubprocessorhistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterSubprocessorHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcentersubprocessorhistoryPager struct {
	reverse bool
	order   *TrustCenterSubprocessorHistoryOrder
	filter  func(*TrustCenterSubprocessorHistoryQuery) (*TrustCenterSubprocessorHistoryQuery, error)
}

func newTrustCenterSubprocessorHistoryPager(opts []TrustCenterSubprocessorHistoryPaginateOption, reverse bool) (*trustcentersubprocessorhistoryPager, error) {
	pager := &trustcentersubprocessorhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterSubprocessorHistoryOrder
	}
	return pager, nil
}

func (p *trustcentersubprocessorhistoryPager) applyFilter(query *TrustCenterSubprocessorHistoryQuery) (*TrustCenterSubprocessorHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcentersubprocessorhistoryPager) toCursor(_m *TrustCenterSubprocessorHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcentersubprocessorhistoryPager) applyCursors(query *TrustCenterSubprocessorHistoryQuery, after, before *Cursor) (*TrustCenterSubprocessorHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterSubprocessorHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcentersubprocessorhistoryPager) applyOrder(query *TrustCenterSubprocessorHistoryQuery) *TrustCenterSubprocessorHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterSubprocessorHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterSubprocessorHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcentersubprocessorhistoryPager) orderExpr(query *TrustCenterSubprocessorHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterSubprocessorHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterSubprocessorHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterSubprocessorHistory.
func (_m *TrustCenterSubprocessorHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterSubprocessorHistoryPaginateOption,
) (*TrustCenterSubprocessorHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterSubprocessorHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterSubprocessorHistoryConnection{Edges: []*TrustCenterSubprocessorHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterSubprocessorHistoryOrderFieldHistoryTime orders TrustCenterSubprocessorHistory by history_time.
	TrustCenterSubprocessorHistoryOrderFieldHistoryTime = &TrustCenterSubprocessorHistoryOrderField{
		Value: func(_m *TrustCenterSubprocessorHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcentersubprocessorhistory.FieldHistoryTime,
		toTerm: trustcentersubprocessorhistory.ByHistoryTime,
		toCursor: func(_m *TrustCenterSubprocessorHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustCenterSubprocessorHistoryOrderFieldCreatedAt orders TrustCenterSubprocessorHistory by created_at.
	TrustCenterSubprocessorHistoryOrderFieldCreatedAt = &TrustCenterSubprocessorHistoryOrderField{
		Value: func(_m *TrustCenterSubprocessorHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcentersubprocessorhistory.FieldCreatedAt,
		toTerm: trustcentersubprocessorhistory.ByCreatedAt,
		toCursor: func(_m *TrustCenterSubprocessorHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterSubprocessorHistoryOrderFieldUpdatedAt orders TrustCenterSubprocessorHistory by updated_at.
	TrustCenterSubprocessorHistoryOrderFieldUpdatedAt = &TrustCenterSubprocessorHistoryOrderField{
		Value: func(_m *TrustCenterSubprocessorHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcentersubprocessorhistory.FieldUpdatedAt,
		toTerm: trustcentersubprocessorhistory.ByUpdatedAt,
		toCursor: func(_m *TrustCenterSubprocessorHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterSubprocessorHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterSubprocessorHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterSubprocessorHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterSubprocessorHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterSubprocessorHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterSubprocessorHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterSubprocessorHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterSubprocessorHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterSubprocessorHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterSubprocessorHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterSubprocessorHistoryOrderField", str)
	}
	return nil
}

// TrustCenterSubprocessorHistoryOrderField defines the ordering field of TrustCenterSubprocessorHistory.
type TrustCenterSubprocessorHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterSubprocessorHistory.
	Value    func(*TrustCenterSubprocessorHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcentersubprocessorhistory.OrderOption
	toCursor func(*TrustCenterSubprocessorHistory) Cursor
}

// TrustCenterSubprocessorHistoryOrder defines the ordering of TrustCenterSubprocessorHistory.
type TrustCenterSubprocessorHistoryOrder struct {
	Direction OrderDirection                            `json:"direction"`
	Field     *TrustCenterSubprocessorHistoryOrderField `json:"field"`
}

// DefaultTrustCenterSubprocessorHistoryOrder is the default ordering of TrustCenterSubprocessorHistory.
var DefaultTrustCenterSubprocessorHistoryOrder = &TrustCenterSubprocessorHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterSubprocessorHistoryOrderField{
		Value: func(_m *TrustCenterSubprocessorHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcentersubprocessorhistory.FieldID,
		toTerm: trustcentersubprocessorhistory.ByID,
		toCursor: func(_m *TrustCenterSubprocessorHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterSubprocessorHistory into TrustCenterSubprocessorHistoryEdge.
func (_m *TrustCenterSubprocessorHistory) ToEdge(order *TrustCenterSubprocessorHistoryOrder) *TrustCenterSubprocessorHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterSubprocessorHistoryOrder
	}
	return &TrustCenterSubprocessorHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterWatermarkConfigHistoryEdge is the edge representation of TrustCenterWatermarkConfigHistory.
type TrustCenterWatermarkConfigHistoryEdge struct {
	Node   *TrustCenterWatermarkConfigHistory `json:"node"`
	Cursor Cursor                             `json:"cursor"`
}

// TrustCenterWatermarkConfigHistoryConnection is the connection containing edges to TrustCenterWatermarkConfigHistory.
type TrustCenterWatermarkConfigHistoryConnection struct {
	Edges      []*TrustCenterWatermarkConfigHistoryEdge `json:"edges"`
	PageInfo   PageInfo                                 `json:"pageInfo"`
	TotalCount int                                      `json:"totalCount"`
}

func (c *TrustCenterWatermarkConfigHistoryConnection) build(nodes []*TrustCenterWatermarkConfigHistory, pager *trustcenterwatermarkconfighistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterWatermarkConfigHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterWatermarkConfigHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterWatermarkConfigHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterWatermarkConfigHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterWatermarkConfigHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterWatermarkConfigHistoryPaginateOption enables pagination customization.
type TrustCenterWatermarkConfigHistoryPaginateOption func(*trustcenterwatermarkconfighistoryPager) error

// WithTrustCenterWatermarkConfigHistoryOrder configures pagination ordering.
func WithTrustCenterWatermarkConfigHistoryOrder(order *TrustCenterWatermarkConfigHistoryOrder) TrustCenterWatermarkConfigHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterWatermarkConfigHistoryOrder
	}
	o := *order
	return func(pager *trustcenterwatermarkconfighistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterWatermarkConfigHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterWatermarkConfigHistoryFilter configures pagination filter.
func WithTrustCenterWatermarkConfigHistoryFilter(filter func(*TrustCenterWatermarkConfigHistoryQuery) (*TrustCenterWatermarkConfigHistoryQuery, error)) TrustCenterWatermarkConfigHistoryPaginateOption {
	return func(pager *trustcenterwatermarkconfighistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterWatermarkConfigHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterwatermarkconfighistoryPager struct {
	reverse bool
	order   *TrustCenterWatermarkConfigHistoryOrder
	filter  func(*TrustCenterWatermarkConfigHistoryQuery) (*TrustCenterWatermarkConfigHistoryQuery, error)
}

func newTrustCenterWatermarkConfigHistoryPager(opts []TrustCenterWatermarkConfigHistoryPaginateOption, reverse bool) (*trustcenterwatermarkconfighistoryPager, error) {
	pager := &trustcenterwatermarkconfighistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterWatermarkConfigHistoryOrder
	}
	return pager, nil
}

func (p *trustcenterwatermarkconfighistoryPager) applyFilter(query *TrustCenterWatermarkConfigHistoryQuery) (*TrustCenterWatermarkConfigHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterwatermarkconfighistoryPager) toCursor(_m *TrustCenterWatermarkConfigHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcenterwatermarkconfighistoryPager) applyCursors(query *TrustCenterWatermarkConfigHistoryQuery, after, before *Cursor) (*TrustCenterWatermarkConfigHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterWatermarkConfigHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcenterwatermarkconfighistoryPager) applyOrder(query *TrustCenterWatermarkConfigHistoryQuery) *TrustCenterWatermarkConfigHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterWatermarkConfigHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterWatermarkConfigHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcenterwatermarkconfighistoryPager) orderExpr(query *TrustCenterWatermarkConfigHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterWatermarkConfigHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterWatermarkConfigHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterWatermarkConfigHistory.
func (_m *TrustCenterWatermarkConfigHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterWatermarkConfigHistoryPaginateOption,
) (*TrustCenterWatermarkConfigHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterWatermarkConfigHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterWatermarkConfigHistoryConnection{Edges: []*TrustCenterWatermarkConfigHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterWatermarkConfigHistoryOrderFieldHistoryTime orders TrustCenterWatermarkConfigHistory by history_time.
	TrustCenterWatermarkConfigHistoryOrderFieldHistoryTime = &TrustCenterWatermarkConfigHistoryOrderField{
		Value: func(_m *TrustCenterWatermarkConfigHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcenterwatermarkconfighistory.FieldHistoryTime,
		toTerm: trustcenterwatermarkconfighistory.ByHistoryTime,
		toCursor: func(_m *TrustCenterWatermarkConfigHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustCenterWatermarkConfigHistoryOrderFieldCreatedAt orders TrustCenterWatermarkConfigHistory by created_at.
	TrustCenterWatermarkConfigHistoryOrderFieldCreatedAt = &TrustCenterWatermarkConfigHistoryOrderField{
		Value: func(_m *TrustCenterWatermarkConfigHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterwatermarkconfighistory.FieldCreatedAt,
		toTerm: trustcenterwatermarkconfighistory.ByCreatedAt,
		toCursor: func(_m *TrustCenterWatermarkConfigHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterWatermarkConfigHistoryOrderFieldUpdatedAt orders TrustCenterWatermarkConfigHistory by updated_at.
	TrustCenterWatermarkConfigHistoryOrderFieldUpdatedAt = &TrustCenterWatermarkConfigHistoryOrderField{
		Value: func(_m *TrustCenterWatermarkConfigHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterwatermarkconfighistory.FieldUpdatedAt,
		toTerm: trustcenterwatermarkconfighistory.ByUpdatedAt,
		toCursor: func(_m *TrustCenterWatermarkConfigHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterWatermarkConfigHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterWatermarkConfigHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterWatermarkConfigHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterWatermarkConfigHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterWatermarkConfigHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterWatermarkConfigHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterWatermarkConfigHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterWatermarkConfigHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterWatermarkConfigHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterWatermarkConfigHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterWatermarkConfigHistoryOrderField", str)
	}
	return nil
}

// TrustCenterWatermarkConfigHistoryOrderField defines the ordering field of TrustCenterWatermarkConfigHistory.
type TrustCenterWatermarkConfigHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterWatermarkConfigHistory.
	Value    func(*TrustCenterWatermarkConfigHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterwatermarkconfighistory.OrderOption
	toCursor func(*TrustCenterWatermarkConfigHistory) Cursor
}

// TrustCenterWatermarkConfigHistoryOrder defines the ordering of TrustCenterWatermarkConfigHistory.
type TrustCenterWatermarkConfigHistoryOrder struct {
	Direction OrderDirection                               `json:"direction"`
	Field     *TrustCenterWatermarkConfigHistoryOrderField `json:"field"`
}

// DefaultTrustCenterWatermarkConfigHistoryOrder is the default ordering of TrustCenterWatermarkConfigHistory.
var DefaultTrustCenterWatermarkConfigHistoryOrder = &TrustCenterWatermarkConfigHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterWatermarkConfigHistoryOrderField{
		Value: func(_m *TrustCenterWatermarkConfigHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterwatermarkconfighistory.FieldID,
		toTerm: trustcenterwatermarkconfighistory.ByID,
		toCursor: func(_m *TrustCenterWatermarkConfigHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterWatermarkConfigHistory into TrustCenterWatermarkConfigHistoryEdge.
func (_m *TrustCenterWatermarkConfigHistory) ToEdge(order *TrustCenterWatermarkConfigHistoryOrder) *TrustCenterWatermarkConfigHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterWatermarkConfigHistoryOrder
	}
	return &TrustCenterWatermarkConfigHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// UserHistoryEdge is the edge representation of UserHistory.
type UserHistoryEdge struct {
	Node   *UserHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// UserHistoryConnection is the connection containing edges to UserHistory.
type UserHistoryConnection struct {
	Edges      []*UserHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *UserHistoryConnection) build(nodes []*UserHistory, pager *userhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *UserHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserHistoryPaginateOption enables pagination customization.
type UserHistoryPaginateOption func(*userhistoryPager) error

// WithUserHistoryOrder configures pagination ordering.
func WithUserHistoryOrder(order *UserHistoryOrder) UserHistoryPaginateOption {
	if order == nil {
		order = DefaultUserHistoryOrder
	}
	o := *order
	return func(pager *userhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserHistoryFilter configures pagination filter.
func WithUserHistoryFilter(filter func(*UserHistoryQuery) (*UserHistoryQuery, error)) UserHistoryPaginateOption {
	return func(pager *userhistoryPager) error {
		if filter == nil {
			return errors.New("UserHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userhistoryPager struct {
	reverse bool
	order   *UserHistoryOrder
	filter  func(*UserHistoryQuery) (*UserHistoryQuery, error)
}

func newUserHistoryPager(opts []UserHistoryPaginateOption, reverse bool) (*userhistoryPager, error) {
	pager := &userhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserHistoryOrder
	}
	return pager, nil
}

func (p *userhistoryPager) applyFilter(query *UserHistoryQuery) (*UserHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userhistoryPager) toCursor(_m *UserHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *userhistoryPager) applyCursors(query *UserHistoryQuery, after, before *Cursor) (*UserHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userhistoryPager) applyOrder(query *UserHistoryQuery) *UserHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserHistoryOrder.Field {
		query = query.Order(DefaultUserHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userhistoryPager) orderExpr(query *UserHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserHistoryOrder.Field {
			b.Comma().Ident(DefaultUserHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserHistory.
func (_m *UserHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserHistoryPaginateOption,
) (*UserHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &UserHistoryConnection{Edges: []*UserHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserHistoryOrderFieldHistoryTime orders UserHistory by history_time.
	UserHistoryOrderFieldHistoryTime = &UserHistoryOrderField{
		Value: func(_m *UserHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: userhistory.FieldHistoryTime,
		toTerm: userhistory.ByHistoryTime,
		toCursor: func(_m *UserHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// UserHistoryOrderFieldCreatedAt orders UserHistory by created_at.
	UserHistoryOrderFieldCreatedAt = &UserHistoryOrderField{
		Value: func(_m *UserHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: userhistory.FieldCreatedAt,
		toTerm: userhistory.ByCreatedAt,
		toCursor: func(_m *UserHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// UserHistoryOrderFieldUpdatedAt orders UserHistory by updated_at.
	UserHistoryOrderFieldUpdatedAt = &UserHistoryOrderField{
		Value: func(_m *UserHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: userhistory.FieldUpdatedAt,
		toTerm: userhistory.ByUpdatedAt,
		toCursor: func(_m *UserHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// UserHistoryOrderFieldFirstName orders UserHistory by first_name.
	UserHistoryOrderFieldFirstName = &UserHistoryOrderField{
		Value: func(_m *UserHistory) (ent.Value, error) {
			return _m.FirstName, nil
		},
		column: userhistory.FieldFirstName,
		toTerm: userhistory.ByFirstName,
		toCursor: func(_m *UserHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FirstName,
			}
		},
	}
	// UserHistoryOrderFieldLastName orders UserHistory by last_name.
	UserHistoryOrderFieldLastName = &UserHistoryOrderField{
		Value: func(_m *UserHistory) (ent.Value, error) {
			return _m.LastName, nil
		},
		column: userhistory.FieldLastName,
		toTerm: userhistory.ByLastName,
		toCursor: func(_m *UserHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastName,
			}
		},
	}
	// UserHistoryOrderFieldDisplayName orders UserHistory by display_name.
	UserHistoryOrderFieldDisplayName = &UserHistoryOrderField{
		Value: func(_m *UserHistory) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: userhistory.FieldDisplayName,
		toTerm: userhistory.ByDisplayName,
		toCursor: func(_m *UserHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserHistoryOrderField) String() string {
	var str string
	switch f.column {
	case UserHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case UserHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case UserHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case UserHistoryOrderFieldFirstName.column:
		str = "first_name"
	case UserHistoryOrderFieldLastName.column:
		str = "last_name"
	case UserHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *UserHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *UserHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *UserHistoryOrderFieldUpdatedAt
	case "first_name":
		*f = *UserHistoryOrderFieldFirstName
	case "last_name":
		*f = *UserHistoryOrderFieldLastName
	case "display_name":
		*f = *UserHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid UserHistoryOrderField", str)
	}
	return nil
}

// UserHistoryOrderField defines the ordering field of UserHistory.
type UserHistoryOrderField struct {
	// Value extracts the ordering value from the given UserHistory.
	Value    func(*UserHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userhistory.OrderOption
	toCursor func(*UserHistory) Cursor
}

// UserHistoryOrder defines the ordering of UserHistory.
type UserHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *UserHistoryOrderField `json:"field"`
}

// DefaultUserHistoryOrder is the default ordering of UserHistory.
var DefaultUserHistoryOrder = &UserHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserHistoryOrderField{
		Value: func(_m *UserHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: userhistory.FieldID,
		toTerm: userhistory.ByID,
		toCursor: func(_m *UserHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts UserHistory into UserHistoryEdge.
func (_m *UserHistory) ToEdge(order *UserHistoryOrder) *UserHistoryEdge {
	if order == nil {
		order = DefaultUserHistoryOrder
	}
	return &UserHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// UserSettingHistoryEdge is the edge representation of UserSettingHistory.
type UserSettingHistoryEdge struct {
	Node   *UserSettingHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// UserSettingHistoryConnection is the connection containing edges to UserSettingHistory.
type UserSettingHistoryConnection struct {
	Edges      []*UserSettingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *UserSettingHistoryConnection) build(nodes []*UserSettingHistory, pager *usersettinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *UserSettingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserSettingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserSettingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserSettingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserSettingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserSettingHistoryPaginateOption enables pagination customization.
type UserSettingHistoryPaginateOption func(*usersettinghistoryPager) error

// WithUserSettingHistoryOrder configures pagination ordering.
func WithUserSettingHistoryOrder(order *UserSettingHistoryOrder) UserSettingHistoryPaginateOption {
	if order == nil {
		order = DefaultUserSettingHistoryOrder
	}
	o := *order
	return func(pager *usersettinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserSettingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserSettingHistoryFilter configures pagination filter.
func WithUserSettingHistoryFilter(filter func(*UserSettingHistoryQuery) (*UserSettingHistoryQuery, error)) UserSettingHistoryPaginateOption {
	return func(pager *usersettinghistoryPager) error {
		if filter == nil {
			return errors.New("UserSettingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usersettinghistoryPager struct {
	reverse bool
	order   *UserSettingHistoryOrder
	filter  func(*UserSettingHistoryQuery) (*UserSettingHistoryQuery, error)
}

func newUserSettingHistoryPager(opts []UserSettingHistoryPaginateOption, reverse bool) (*usersettinghistoryPager, error) {
	pager := &usersettinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserSettingHistoryOrder
	}
	return pager, nil
}

func (p *usersettinghistoryPager) applyFilter(query *UserSettingHistoryQuery) (*UserSettingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usersettinghistoryPager) toCursor(_m *UserSettingHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *usersettinghistoryPager) applyCursors(query *UserSettingHistoryQuery, after, before *Cursor) (*UserSettingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserSettingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *usersettinghistoryPager) applyOrder(query *UserSettingHistoryQuery) *UserSettingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserSettingHistoryOrder.Field {
		query = query.Order(DefaultUserSettingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *usersettinghistoryPager) orderExpr(query *UserSettingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserSettingHistoryOrder.Field {
			b.Comma().Ident(DefaultUserSettingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserSettingHistory.
func (_m *UserSettingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserSettingHistoryPaginateOption,
) (*UserSettingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserSettingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &UserSettingHistoryConnection{Edges: []*UserSettingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserSettingHistoryOrderFieldHistoryTime orders UserSettingHistory by history_time.
	UserSettingHistoryOrderFieldHistoryTime = &UserSettingHistoryOrderField{
		Value: func(_m *UserSettingHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: usersettinghistory.FieldHistoryTime,
		toTerm: usersettinghistory.ByHistoryTime,
		toCursor: func(_m *UserSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// UserSettingHistoryOrderFieldCreatedAt orders UserSettingHistory by created_at.
	UserSettingHistoryOrderFieldCreatedAt = &UserSettingHistoryOrderField{
		Value: func(_m *UserSettingHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: usersettinghistory.FieldCreatedAt,
		toTerm: usersettinghistory.ByCreatedAt,
		toCursor: func(_m *UserSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// UserSettingHistoryOrderFieldUpdatedAt orders UserSettingHistory by updated_at.
	UserSettingHistoryOrderFieldUpdatedAt = &UserSettingHistoryOrderField{
		Value: func(_m *UserSettingHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: usersettinghistory.FieldUpdatedAt,
		toTerm: usersettinghistory.ByUpdatedAt,
		toCursor: func(_m *UserSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserSettingHistoryOrderField) String() string {
	var str string
	switch f.column {
	case UserSettingHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case UserSettingHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case UserSettingHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserSettingHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserSettingHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *UserSettingHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *UserSettingHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *UserSettingHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserSettingHistoryOrderField", str)
	}
	return nil
}

// UserSettingHistoryOrderField defines the ordering field of UserSettingHistory.
type UserSettingHistoryOrderField struct {
	// Value extracts the ordering value from the given UserSettingHistory.
	Value    func(*UserSettingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) usersettinghistory.OrderOption
	toCursor func(*UserSettingHistory) Cursor
}

// UserSettingHistoryOrder defines the ordering of UserSettingHistory.
type UserSettingHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *UserSettingHistoryOrderField `json:"field"`
}

// DefaultUserSettingHistoryOrder is the default ordering of UserSettingHistory.
var DefaultUserSettingHistoryOrder = &UserSettingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserSettingHistoryOrderField{
		Value: func(_m *UserSettingHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: usersettinghistory.FieldID,
		toTerm: usersettinghistory.ByID,
		toCursor: func(_m *UserSettingHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts UserSettingHistory into UserSettingHistoryEdge.
func (_m *UserSettingHistory) ToEdge(order *UserSettingHistoryOrder) *UserSettingHistoryEdge {
	if order == nil {
		order = DefaultUserSettingHistoryOrder
	}
	return &UserSettingHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// VulnerabilityHistoryEdge is the edge representation of VulnerabilityHistory.
type VulnerabilityHistoryEdge struct {
	Node   *VulnerabilityHistory `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// VulnerabilityHistoryConnection is the connection containing edges to VulnerabilityHistory.
type VulnerabilityHistoryConnection struct {
	Edges      []*VulnerabilityHistoryEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *VulnerabilityHistoryConnection) build(nodes []*VulnerabilityHistory, pager *vulnerabilityhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *VulnerabilityHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *VulnerabilityHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *VulnerabilityHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*VulnerabilityHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &VulnerabilityHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// VulnerabilityHistoryPaginateOption enables pagination customization.
type VulnerabilityHistoryPaginateOption func(*vulnerabilityhistoryPager) error

// WithVulnerabilityHistoryOrder configures pagination ordering.
func WithVulnerabilityHistoryOrder(order *VulnerabilityHistoryOrder) VulnerabilityHistoryPaginateOption {
	if order == nil {
		order = DefaultVulnerabilityHistoryOrder
	}
	o := *order
	return func(pager *vulnerabilityhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVulnerabilityHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVulnerabilityHistoryFilter configures pagination filter.
func WithVulnerabilityHistoryFilter(filter func(*VulnerabilityHistoryQuery) (*VulnerabilityHistoryQuery, error)) VulnerabilityHistoryPaginateOption {
	return func(pager *vulnerabilityhistoryPager) error {
		if filter == nil {
			return errors.New("VulnerabilityHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vulnerabilityhistoryPager struct {
	reverse bool
	order   *VulnerabilityHistoryOrder
	filter  func(*VulnerabilityHistoryQuery) (*VulnerabilityHistoryQuery, error)
}

func newVulnerabilityHistoryPager(opts []VulnerabilityHistoryPaginateOption, reverse bool) (*vulnerabilityhistoryPager, error) {
	pager := &vulnerabilityhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVulnerabilityHistoryOrder
	}
	return pager, nil
}

func (p *vulnerabilityhistoryPager) applyFilter(query *VulnerabilityHistoryQuery) (*VulnerabilityHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vulnerabilityhistoryPager) toCursor(_m *VulnerabilityHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *vulnerabilityhistoryPager) applyCursors(query *VulnerabilityHistoryQuery, after, before *Cursor) (*VulnerabilityHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultVulnerabilityHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *vulnerabilityhistoryPager) applyOrder(query *VulnerabilityHistoryQuery) *VulnerabilityHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultVulnerabilityHistoryOrder.Field {
		query = query.Order(DefaultVulnerabilityHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *vulnerabilityhistoryPager) orderExpr(query *VulnerabilityHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultVulnerabilityHistoryOrder.Field {
			b.Comma().Ident(DefaultVulnerabilityHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to VulnerabilityHistory.
func (_m *VulnerabilityHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VulnerabilityHistoryPaginateOption,
) (*VulnerabilityHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVulnerabilityHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &VulnerabilityHistoryConnection{Edges: []*VulnerabilityHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// VulnerabilityHistoryOrderFieldHistoryTime orders VulnerabilityHistory by history_time.
	VulnerabilityHistoryOrderFieldHistoryTime = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: vulnerabilityhistory.FieldHistoryTime,
		toTerm: vulnerabilityhistory.ByHistoryTime,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// VulnerabilityHistoryOrderFieldCreatedAt orders VulnerabilityHistory by created_at.
	VulnerabilityHistoryOrderFieldCreatedAt = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: vulnerabilityhistory.FieldCreatedAt,
		toTerm: vulnerabilityhistory.ByCreatedAt,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// VulnerabilityHistoryOrderFieldUpdatedAt orders VulnerabilityHistory by updated_at.
	VulnerabilityHistoryOrderFieldUpdatedAt = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: vulnerabilityhistory.FieldUpdatedAt,
		toTerm: vulnerabilityhistory.ByUpdatedAt,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// VulnerabilityHistoryOrderFieldExternalOwnerID orders VulnerabilityHistory by external_owner_id.
	VulnerabilityHistoryOrderFieldExternalOwnerID = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: vulnerabilityhistory.FieldExternalOwnerID,
		toTerm: vulnerabilityhistory.ByExternalOwnerID,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// VulnerabilityHistoryOrderFieldExternalID orders VulnerabilityHistory by external_id.
	VulnerabilityHistoryOrderFieldExternalID = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: vulnerabilityhistory.FieldExternalID,
		toTerm: vulnerabilityhistory.ByExternalID,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// VulnerabilityHistoryOrderFieldCveID orders VulnerabilityHistory by cve_id.
	VulnerabilityHistoryOrderFieldCveID = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.CveID, nil
		},
		column: vulnerabilityhistory.FieldCveID,
		toTerm: vulnerabilityhistory.ByCveID,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CveID,
			}
		},
	}
	// VulnerabilityHistoryOrderFieldCategory orders VulnerabilityHistory by category.
	VulnerabilityHistoryOrderFieldCategory = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.Category, nil
		},
		column: vulnerabilityhistory.FieldCategory,
		toTerm: vulnerabilityhistory.ByCategory,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// VulnerabilityHistoryOrderFieldSeverity orders VulnerabilityHistory by severity.
	VulnerabilityHistoryOrderFieldSeverity = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.Severity, nil
		},
		column: vulnerabilityhistory.FieldSeverity,
		toTerm: vulnerabilityhistory.BySeverity,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Severity,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VulnerabilityHistoryOrderField) String() string {
	var str string
	switch f.column {
	case VulnerabilityHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case VulnerabilityHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case VulnerabilityHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case VulnerabilityHistoryOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case VulnerabilityHistoryOrderFieldExternalID.column:
		str = "external_id"
	case VulnerabilityHistoryOrderFieldCveID.column:
		str = "cve_id"
	case VulnerabilityHistoryOrderFieldCategory.column:
		str = "category"
	case VulnerabilityHistoryOrderFieldSeverity.column:
		str = "severity"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VulnerabilityHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VulnerabilityHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VulnerabilityHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *VulnerabilityHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *VulnerabilityHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *VulnerabilityHistoryOrderFieldUpdatedAt
	case "external_owner_id":
		*f = *VulnerabilityHistoryOrderFieldExternalOwnerID
	case "external_id":
		*f = *VulnerabilityHistoryOrderFieldExternalID
	case "cve_id":
		*f = *VulnerabilityHistoryOrderFieldCveID
	case "category":
		*f = *VulnerabilityHistoryOrderFieldCategory
	case "severity":
		*f = *VulnerabilityHistoryOrderFieldSeverity
	default:
		return fmt.Errorf("%s is not a valid VulnerabilityHistoryOrderField", str)
	}
	return nil
}

// VulnerabilityHistoryOrderField defines the ordering field of VulnerabilityHistory.
type VulnerabilityHistoryOrderField struct {
	// Value extracts the ordering value from the given VulnerabilityHistory.
	Value    func(*VulnerabilityHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) vulnerabilityhistory.OrderOption
	toCursor func(*VulnerabilityHistory) Cursor
}

// VulnerabilityHistoryOrder defines the ordering of VulnerabilityHistory.
type VulnerabilityHistoryOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *VulnerabilityHistoryOrderField `json:"field"`
}

// DefaultVulnerabilityHistoryOrder is the default ordering of VulnerabilityHistory.
var DefaultVulnerabilityHistoryOrder = &VulnerabilityHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: vulnerabilityhistory.FieldID,
		toTerm: vulnerabilityhistory.ByID,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts VulnerabilityHistory into VulnerabilityHistoryEdge.
func (_m *VulnerabilityHistory) ToEdge(order *VulnerabilityHistoryOrder) *VulnerabilityHistoryEdge {
	if order == nil {
		order = DefaultVulnerabilityHistoryOrder
	}
	return &VulnerabilityHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowAssignmentHistoryEdge is the edge representation of WorkflowAssignmentHistory.
type WorkflowAssignmentHistoryEdge struct {
	Node   *WorkflowAssignmentHistory `json:"node"`
	Cursor Cursor                     `json:"cursor"`
}

// WorkflowAssignmentHistoryConnection is the connection containing edges to WorkflowAssignmentHistory.
type WorkflowAssignmentHistoryConnection struct {
	Edges      []*WorkflowAssignmentHistoryEdge `json:"edges"`
	PageInfo   PageInfo                         `json:"pageInfo"`
	TotalCount int                              `json:"totalCount"`
}

func (c *WorkflowAssignmentHistoryConnection) build(nodes []*WorkflowAssignmentHistory, pager *workflowassignmenthistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowAssignmentHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowAssignmentHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowAssignmentHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowAssignmentHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowAssignmentHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowAssignmentHistoryPaginateOption enables pagination customization.
type WorkflowAssignmentHistoryPaginateOption func(*workflowassignmenthistoryPager) error

// WithWorkflowAssignmentHistoryOrder configures pagination ordering.
func WithWorkflowAssignmentHistoryOrder(order *WorkflowAssignmentHistoryOrder) WorkflowAssignmentHistoryPaginateOption {
	if order == nil {
		order = DefaultWorkflowAssignmentHistoryOrder
	}
	o := *order
	return func(pager *workflowassignmenthistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkflowAssignmentHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkflowAssignmentHistoryFilter configures pagination filter.
func WithWorkflowAssignmentHistoryFilter(filter func(*WorkflowAssignmentHistoryQuery) (*WorkflowAssignmentHistoryQuery, error)) WorkflowAssignmentHistoryPaginateOption {
	return func(pager *workflowassignmenthistoryPager) error {
		if filter == nil {
			return errors.New("WorkflowAssignmentHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowassignmenthistoryPager struct {
	reverse bool
	order   *WorkflowAssignmentHistoryOrder
	filter  func(*WorkflowAssignmentHistoryQuery) (*WorkflowAssignmentHistoryQuery, error)
}

func newWorkflowAssignmentHistoryPager(opts []WorkflowAssignmentHistoryPaginateOption, reverse bool) (*workflowassignmenthistoryPager, error) {
	pager := &workflowassignmenthistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkflowAssignmentHistoryOrder
	}
	return pager, nil
}

func (p *workflowassignmenthistoryPager) applyFilter(query *WorkflowAssignmentHistoryQuery) (*WorkflowAssignmentHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowassignmenthistoryPager) toCursor(_m *WorkflowAssignmentHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *workflowassignmenthistoryPager) applyCursors(query *WorkflowAssignmentHistoryQuery, after, before *Cursor) (*WorkflowAssignmentHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkflowAssignmentHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workflowassignmenthistoryPager) applyOrder(query *WorkflowAssignmentHistoryQuery) *WorkflowAssignmentHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkflowAssignmentHistoryOrder.Field {
		query = query.Order(DefaultWorkflowAssignmentHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workflowassignmenthistoryPager) orderExpr(query *WorkflowAssignmentHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkflowAssignmentHistoryOrder.Field {
			b.Comma().Ident(DefaultWorkflowAssignmentHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowAssignmentHistory.
func (_m *WorkflowAssignmentHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowAssignmentHistoryPaginateOption,
) (*WorkflowAssignmentHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowAssignmentHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowAssignmentHistoryConnection{Edges: []*WorkflowAssignmentHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowAssignmentHistoryOrderFieldHistoryTime orders WorkflowAssignmentHistory by history_time.
	WorkflowAssignmentHistoryOrderFieldHistoryTime = &WorkflowAssignmentHistoryOrderField{
		Value: func(_m *WorkflowAssignmentHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: workflowassignmenthistory.FieldHistoryTime,
		toTerm: workflowassignmenthistory.ByHistoryTime,
		toCursor: func(_m *WorkflowAssignmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// WorkflowAssignmentHistoryOrderFieldCreatedAt orders WorkflowAssignmentHistory by created_at.
	WorkflowAssignmentHistoryOrderFieldCreatedAt = &WorkflowAssignmentHistoryOrderField{
		Value: func(_m *WorkflowAssignmentHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowassignmenthistory.FieldCreatedAt,
		toTerm: workflowassignmenthistory.ByCreatedAt,
		toCursor: func(_m *WorkflowAssignmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowAssignmentHistoryOrderFieldUpdatedAt orders WorkflowAssignmentHistory by updated_at.
	WorkflowAssignmentHistoryOrderFieldUpdatedAt = &WorkflowAssignmentHistoryOrderField{
		Value: func(_m *WorkflowAssignmentHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowassignmenthistory.FieldUpdatedAt,
		toTerm: workflowassignmenthistory.ByUpdatedAt,
		toCursor: func(_m *WorkflowAssignmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowAssignmentHistoryOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowAssignmentHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case WorkflowAssignmentHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowAssignmentHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowAssignmentHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowAssignmentHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowAssignmentHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *WorkflowAssignmentHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *WorkflowAssignmentHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowAssignmentHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowAssignmentHistoryOrderField", str)
	}
	return nil
}

// WorkflowAssignmentHistoryOrderField defines the ordering field of WorkflowAssignmentHistory.
type WorkflowAssignmentHistoryOrderField struct {
	// Value extracts the ordering value from the given WorkflowAssignmentHistory.
	Value    func(*WorkflowAssignmentHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowassignmenthistory.OrderOption
	toCursor func(*WorkflowAssignmentHistory) Cursor
}

// WorkflowAssignmentHistoryOrder defines the ordering of WorkflowAssignmentHistory.
type WorkflowAssignmentHistoryOrder struct {
	Direction OrderDirection                       `json:"direction"`
	Field     *WorkflowAssignmentHistoryOrderField `json:"field"`
}

// DefaultWorkflowAssignmentHistoryOrder is the default ordering of WorkflowAssignmentHistory.
var DefaultWorkflowAssignmentHistoryOrder = &WorkflowAssignmentHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowAssignmentHistoryOrderField{
		Value: func(_m *WorkflowAssignmentHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowassignmenthistory.FieldID,
		toTerm: workflowassignmenthistory.ByID,
		toCursor: func(_m *WorkflowAssignmentHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowAssignmentHistory into WorkflowAssignmentHistoryEdge.
func (_m *WorkflowAssignmentHistory) ToEdge(order *WorkflowAssignmentHistoryOrder) *WorkflowAssignmentHistoryEdge {
	if order == nil {
		order = DefaultWorkflowAssignmentHistoryOrder
	}
	return &WorkflowAssignmentHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowAssignmentTargetHistoryEdge is the edge representation of WorkflowAssignmentTargetHistory.
type WorkflowAssignmentTargetHistoryEdge struct {
	Node   *WorkflowAssignmentTargetHistory `json:"node"`
	Cursor Cursor                           `json:"cursor"`
}

// WorkflowAssignmentTargetHistoryConnection is the connection containing edges to WorkflowAssignmentTargetHistory.
type WorkflowAssignmentTargetHistoryConnection struct {
	Edges      []*WorkflowAssignmentTargetHistoryEdge `json:"edges"`
	PageInfo   PageInfo                               `json:"pageInfo"`
	TotalCount int                                    `json:"totalCount"`
}

func (c *WorkflowAssignmentTargetHistoryConnection) build(nodes []*WorkflowAssignmentTargetHistory, pager *workflowassignmenttargethistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowAssignmentTargetHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowAssignmentTargetHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowAssignmentTargetHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowAssignmentTargetHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowAssignmentTargetHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowAssignmentTargetHistoryPaginateOption enables pagination customization.
type WorkflowAssignmentTargetHistoryPaginateOption func(*workflowassignmenttargethistoryPager) error

// WithWorkflowAssignmentTargetHistoryOrder configures pagination ordering.
func WithWorkflowAssignmentTargetHistoryOrder(order *WorkflowAssignmentTargetHistoryOrder) WorkflowAssignmentTargetHistoryPaginateOption {
	if order == nil {
		order = DefaultWorkflowAssignmentTargetHistoryOrder
	}
	o := *order
	return func(pager *workflowassignmenttargethistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkflowAssignmentTargetHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkflowAssignmentTargetHistoryFilter configures pagination filter.
func WithWorkflowAssignmentTargetHistoryFilter(filter func(*WorkflowAssignmentTargetHistoryQuery) (*WorkflowAssignmentTargetHistoryQuery, error)) WorkflowAssignmentTargetHistoryPaginateOption {
	return func(pager *workflowassignmenttargethistoryPager) error {
		if filter == nil {
			return errors.New("WorkflowAssignmentTargetHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowassignmenttargethistoryPager struct {
	reverse bool
	order   *WorkflowAssignmentTargetHistoryOrder
	filter  func(*WorkflowAssignmentTargetHistoryQuery) (*WorkflowAssignmentTargetHistoryQuery, error)
}

func newWorkflowAssignmentTargetHistoryPager(opts []WorkflowAssignmentTargetHistoryPaginateOption, reverse bool) (*workflowassignmenttargethistoryPager, error) {
	pager := &workflowassignmenttargethistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkflowAssignmentTargetHistoryOrder
	}
	return pager, nil
}

func (p *workflowassignmenttargethistoryPager) applyFilter(query *WorkflowAssignmentTargetHistoryQuery) (*WorkflowAssignmentTargetHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowassignmenttargethistoryPager) toCursor(_m *WorkflowAssignmentTargetHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *workflowassignmenttargethistoryPager) applyCursors(query *WorkflowAssignmentTargetHistoryQuery, after, before *Cursor) (*WorkflowAssignmentTargetHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkflowAssignmentTargetHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workflowassignmenttargethistoryPager) applyOrder(query *WorkflowAssignmentTargetHistoryQuery) *WorkflowAssignmentTargetHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkflowAssignmentTargetHistoryOrder.Field {
		query = query.Order(DefaultWorkflowAssignmentTargetHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workflowassignmenttargethistoryPager) orderExpr(query *WorkflowAssignmentTargetHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkflowAssignmentTargetHistoryOrder.Field {
			b.Comma().Ident(DefaultWorkflowAssignmentTargetHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowAssignmentTargetHistory.
func (_m *WorkflowAssignmentTargetHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowAssignmentTargetHistoryPaginateOption,
) (*WorkflowAssignmentTargetHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowAssignmentTargetHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowAssignmentTargetHistoryConnection{Edges: []*WorkflowAssignmentTargetHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowAssignmentTargetHistoryOrderFieldHistoryTime orders WorkflowAssignmentTargetHistory by history_time.
	WorkflowAssignmentTargetHistoryOrderFieldHistoryTime = &WorkflowAssignmentTargetHistoryOrderField{
		Value: func(_m *WorkflowAssignmentTargetHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: workflowassignmenttargethistory.FieldHistoryTime,
		toTerm: workflowassignmenttargethistory.ByHistoryTime,
		toCursor: func(_m *WorkflowAssignmentTargetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// WorkflowAssignmentTargetHistoryOrderFieldCreatedAt orders WorkflowAssignmentTargetHistory by created_at.
	WorkflowAssignmentTargetHistoryOrderFieldCreatedAt = &WorkflowAssignmentTargetHistoryOrderField{
		Value: func(_m *WorkflowAssignmentTargetHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowassignmenttargethistory.FieldCreatedAt,
		toTerm: workflowassignmenttargethistory.ByCreatedAt,
		toCursor: func(_m *WorkflowAssignmentTargetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowAssignmentTargetHistoryOrderFieldUpdatedAt orders WorkflowAssignmentTargetHistory by updated_at.
	WorkflowAssignmentTargetHistoryOrderFieldUpdatedAt = &WorkflowAssignmentTargetHistoryOrderField{
		Value: func(_m *WorkflowAssignmentTargetHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowassignmenttargethistory.FieldUpdatedAt,
		toTerm: workflowassignmenttargethistory.ByUpdatedAt,
		toCursor: func(_m *WorkflowAssignmentTargetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowAssignmentTargetHistoryOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowAssignmentTargetHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case WorkflowAssignmentTargetHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowAssignmentTargetHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowAssignmentTargetHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowAssignmentTargetHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowAssignmentTargetHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *WorkflowAssignmentTargetHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *WorkflowAssignmentTargetHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowAssignmentTargetHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowAssignmentTargetHistoryOrderField", str)
	}
	return nil
}

// WorkflowAssignmentTargetHistoryOrderField defines the ordering field of WorkflowAssignmentTargetHistory.
type WorkflowAssignmentTargetHistoryOrderField struct {
	// Value extracts the ordering value from the given WorkflowAssignmentTargetHistory.
	Value    func(*WorkflowAssignmentTargetHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowassignmenttargethistory.OrderOption
	toCursor func(*WorkflowAssignmentTargetHistory) Cursor
}

// WorkflowAssignmentTargetHistoryOrder defines the ordering of WorkflowAssignmentTargetHistory.
type WorkflowAssignmentTargetHistoryOrder struct {
	Direction OrderDirection                             `json:"direction"`
	Field     *WorkflowAssignmentTargetHistoryOrderField `json:"field"`
}

// DefaultWorkflowAssignmentTargetHistoryOrder is the default ordering of WorkflowAssignmentTargetHistory.
var DefaultWorkflowAssignmentTargetHistoryOrder = &WorkflowAssignmentTargetHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowAssignmentTargetHistoryOrderField{
		Value: func(_m *WorkflowAssignmentTargetHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowassignmenttargethistory.FieldID,
		toTerm: workflowassignmenttargethistory.ByID,
		toCursor: func(_m *WorkflowAssignmentTargetHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowAssignmentTargetHistory into WorkflowAssignmentTargetHistoryEdge.
func (_m *WorkflowAssignmentTargetHistory) ToEdge(order *WorkflowAssignmentTargetHistoryOrder) *WorkflowAssignmentTargetHistoryEdge {
	if order == nil {
		order = DefaultWorkflowAssignmentTargetHistoryOrder
	}
	return &WorkflowAssignmentTargetHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowDefinitionHistoryEdge is the edge representation of WorkflowDefinitionHistory.
type WorkflowDefinitionHistoryEdge struct {
	Node   *WorkflowDefinitionHistory `json:"node"`
	Cursor Cursor                     `json:"cursor"`
}

// WorkflowDefinitionHistoryConnection is the connection containing edges to WorkflowDefinitionHistory.
type WorkflowDefinitionHistoryConnection struct {
	Edges      []*WorkflowDefinitionHistoryEdge `json:"edges"`
	PageInfo   PageInfo                         `json:"pageInfo"`
	TotalCount int                              `json:"totalCount"`
}

func (c *WorkflowDefinitionHistoryConnection) build(nodes []*WorkflowDefinitionHistory, pager *workflowdefinitionhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowDefinitionHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowDefinitionHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowDefinitionHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowDefinitionHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowDefinitionHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowDefinitionHistoryPaginateOption enables pagination customization.
type WorkflowDefinitionHistoryPaginateOption func(*workflowdefinitionhistoryPager) error

// WithWorkflowDefinitionHistoryOrder configures pagination ordering.
func WithWorkflowDefinitionHistoryOrder(order *WorkflowDefinitionHistoryOrder) WorkflowDefinitionHistoryPaginateOption {
	if order == nil {
		order = DefaultWorkflowDefinitionHistoryOrder
	}
	o := *order
	return func(pager *workflowdefinitionhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkflowDefinitionHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkflowDefinitionHistoryFilter configures pagination filter.
func WithWorkflowDefinitionHistoryFilter(filter func(*WorkflowDefinitionHistoryQuery) (*WorkflowDefinitionHistoryQuery, error)) WorkflowDefinitionHistoryPaginateOption {
	return func(pager *workflowdefinitionhistoryPager) error {
		if filter == nil {
			return errors.New("WorkflowDefinitionHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowdefinitionhistoryPager struct {
	reverse bool
	order   *WorkflowDefinitionHistoryOrder
	filter  func(*WorkflowDefinitionHistoryQuery) (*WorkflowDefinitionHistoryQuery, error)
}

func newWorkflowDefinitionHistoryPager(opts []WorkflowDefinitionHistoryPaginateOption, reverse bool) (*workflowdefinitionhistoryPager, error) {
	pager := &workflowdefinitionhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkflowDefinitionHistoryOrder
	}
	return pager, nil
}

func (p *workflowdefinitionhistoryPager) applyFilter(query *WorkflowDefinitionHistoryQuery) (*WorkflowDefinitionHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowdefinitionhistoryPager) toCursor(_m *WorkflowDefinitionHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *workflowdefinitionhistoryPager) applyCursors(query *WorkflowDefinitionHistoryQuery, after, before *Cursor) (*WorkflowDefinitionHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkflowDefinitionHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workflowdefinitionhistoryPager) applyOrder(query *WorkflowDefinitionHistoryQuery) *WorkflowDefinitionHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkflowDefinitionHistoryOrder.Field {
		query = query.Order(DefaultWorkflowDefinitionHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workflowdefinitionhistoryPager) orderExpr(query *WorkflowDefinitionHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkflowDefinitionHistoryOrder.Field {
			b.Comma().Ident(DefaultWorkflowDefinitionHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowDefinitionHistory.
func (_m *WorkflowDefinitionHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowDefinitionHistoryPaginateOption,
) (*WorkflowDefinitionHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowDefinitionHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowDefinitionHistoryConnection{Edges: []*WorkflowDefinitionHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowDefinitionHistoryOrderFieldHistoryTime orders WorkflowDefinitionHistory by history_time.
	WorkflowDefinitionHistoryOrderFieldHistoryTime = &WorkflowDefinitionHistoryOrderField{
		Value: func(_m *WorkflowDefinitionHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: workflowdefinitionhistory.FieldHistoryTime,
		toTerm: workflowdefinitionhistory.ByHistoryTime,
		toCursor: func(_m *WorkflowDefinitionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// WorkflowDefinitionHistoryOrderFieldCreatedAt orders WorkflowDefinitionHistory by created_at.
	WorkflowDefinitionHistoryOrderFieldCreatedAt = &WorkflowDefinitionHistoryOrderField{
		Value: func(_m *WorkflowDefinitionHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowdefinitionhistory.FieldCreatedAt,
		toTerm: workflowdefinitionhistory.ByCreatedAt,
		toCursor: func(_m *WorkflowDefinitionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowDefinitionHistoryOrderFieldUpdatedAt orders WorkflowDefinitionHistory by updated_at.
	WorkflowDefinitionHistoryOrderFieldUpdatedAt = &WorkflowDefinitionHistoryOrderField{
		Value: func(_m *WorkflowDefinitionHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowdefinitionhistory.FieldUpdatedAt,
		toTerm: workflowdefinitionhistory.ByUpdatedAt,
		toCursor: func(_m *WorkflowDefinitionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowDefinitionHistoryOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowDefinitionHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case WorkflowDefinitionHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowDefinitionHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowDefinitionHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowDefinitionHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowDefinitionHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *WorkflowDefinitionHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *WorkflowDefinitionHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowDefinitionHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowDefinitionHistoryOrderField", str)
	}
	return nil
}

// WorkflowDefinitionHistoryOrderField defines the ordering field of WorkflowDefinitionHistory.
type WorkflowDefinitionHistoryOrderField struct {
	// Value extracts the ordering value from the given WorkflowDefinitionHistory.
	Value    func(*WorkflowDefinitionHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowdefinitionhistory.OrderOption
	toCursor func(*WorkflowDefinitionHistory) Cursor
}

// WorkflowDefinitionHistoryOrder defines the ordering of WorkflowDefinitionHistory.
type WorkflowDefinitionHistoryOrder struct {
	Direction OrderDirection                       `json:"direction"`
	Field     *WorkflowDefinitionHistoryOrderField `json:"field"`
}

// DefaultWorkflowDefinitionHistoryOrder is the default ordering of WorkflowDefinitionHistory.
var DefaultWorkflowDefinitionHistoryOrder = &WorkflowDefinitionHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowDefinitionHistoryOrderField{
		Value: func(_m *WorkflowDefinitionHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowdefinitionhistory.FieldID,
		toTerm: workflowdefinitionhistory.ByID,
		toCursor: func(_m *WorkflowDefinitionHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowDefinitionHistory into WorkflowDefinitionHistoryEdge.
func (_m *WorkflowDefinitionHistory) ToEdge(order *WorkflowDefinitionHistoryOrder) *WorkflowDefinitionHistoryEdge {
	if order == nil {
		order = DefaultWorkflowDefinitionHistoryOrder
	}
	return &WorkflowDefinitionHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowEventHistoryEdge is the edge representation of WorkflowEventHistory.
type WorkflowEventHistoryEdge struct {
	Node   *WorkflowEventHistory `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// WorkflowEventHistoryConnection is the connection containing edges to WorkflowEventHistory.
type WorkflowEventHistoryConnection struct {
	Edges      []*WorkflowEventHistoryEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *WorkflowEventHistoryConnection) build(nodes []*WorkflowEventHistory, pager *workfloweventhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowEventHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowEventHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowEventHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowEventHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowEventHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowEventHistoryPaginateOption enables pagination customization.
type WorkflowEventHistoryPaginateOption func(*workfloweventhistoryPager) error

// WithWorkflowEventHistoryOrder configures pagination ordering.
func WithWorkflowEventHistoryOrder(order *WorkflowEventHistoryOrder) WorkflowEventHistoryPaginateOption {
	if order == nil {
		order = DefaultWorkflowEventHistoryOrder
	}
	o := *order
	return func(pager *workfloweventhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkflowEventHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkflowEventHistoryFilter configures pagination filter.
func WithWorkflowEventHistoryFilter(filter func(*WorkflowEventHistoryQuery) (*WorkflowEventHistoryQuery, error)) WorkflowEventHistoryPaginateOption {
	return func(pager *workfloweventhistoryPager) error {
		if filter == nil {
			return errors.New("WorkflowEventHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workfloweventhistoryPager struct {
	reverse bool
	order   *WorkflowEventHistoryOrder
	filter  func(*WorkflowEventHistoryQuery) (*WorkflowEventHistoryQuery, error)
}

func newWorkflowEventHistoryPager(opts []WorkflowEventHistoryPaginateOption, reverse bool) (*workfloweventhistoryPager, error) {
	pager := &workfloweventhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkflowEventHistoryOrder
	}
	return pager, nil
}

func (p *workfloweventhistoryPager) applyFilter(query *WorkflowEventHistoryQuery) (*WorkflowEventHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workfloweventhistoryPager) toCursor(_m *WorkflowEventHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *workfloweventhistoryPager) applyCursors(query *WorkflowEventHistoryQuery, after, before *Cursor) (*WorkflowEventHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkflowEventHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workfloweventhistoryPager) applyOrder(query *WorkflowEventHistoryQuery) *WorkflowEventHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkflowEventHistoryOrder.Field {
		query = query.Order(DefaultWorkflowEventHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workfloweventhistoryPager) orderExpr(query *WorkflowEventHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkflowEventHistoryOrder.Field {
			b.Comma().Ident(DefaultWorkflowEventHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowEventHistory.
func (_m *WorkflowEventHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowEventHistoryPaginateOption,
) (*WorkflowEventHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowEventHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowEventHistoryConnection{Edges: []*WorkflowEventHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowEventHistoryOrderFieldHistoryTime orders WorkflowEventHistory by history_time.
	WorkflowEventHistoryOrderFieldHistoryTime = &WorkflowEventHistoryOrderField{
		Value: func(_m *WorkflowEventHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: workfloweventhistory.FieldHistoryTime,
		toTerm: workfloweventhistory.ByHistoryTime,
		toCursor: func(_m *WorkflowEventHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// WorkflowEventHistoryOrderFieldCreatedAt orders WorkflowEventHistory by created_at.
	WorkflowEventHistoryOrderFieldCreatedAt = &WorkflowEventHistoryOrderField{
		Value: func(_m *WorkflowEventHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workfloweventhistory.FieldCreatedAt,
		toTerm: workfloweventhistory.ByCreatedAt,
		toCursor: func(_m *WorkflowEventHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowEventHistoryOrderFieldUpdatedAt orders WorkflowEventHistory by updated_at.
	WorkflowEventHistoryOrderFieldUpdatedAt = &WorkflowEventHistoryOrderField{
		Value: func(_m *WorkflowEventHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workfloweventhistory.FieldUpdatedAt,
		toTerm: workfloweventhistory.ByUpdatedAt,
		toCursor: func(_m *WorkflowEventHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowEventHistoryOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowEventHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case WorkflowEventHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowEventHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowEventHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowEventHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowEventHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *WorkflowEventHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *WorkflowEventHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowEventHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowEventHistoryOrderField", str)
	}
	return nil
}

// WorkflowEventHistoryOrderField defines the ordering field of WorkflowEventHistory.
type WorkflowEventHistoryOrderField struct {
	// Value extracts the ordering value from the given WorkflowEventHistory.
	Value    func(*WorkflowEventHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workfloweventhistory.OrderOption
	toCursor func(*WorkflowEventHistory) Cursor
}

// WorkflowEventHistoryOrder defines the ordering of WorkflowEventHistory.
type WorkflowEventHistoryOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *WorkflowEventHistoryOrderField `json:"field"`
}

// DefaultWorkflowEventHistoryOrder is the default ordering of WorkflowEventHistory.
var DefaultWorkflowEventHistoryOrder = &WorkflowEventHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowEventHistoryOrderField{
		Value: func(_m *WorkflowEventHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workfloweventhistory.FieldID,
		toTerm: workfloweventhistory.ByID,
		toCursor: func(_m *WorkflowEventHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowEventHistory into WorkflowEventHistoryEdge.
func (_m *WorkflowEventHistory) ToEdge(order *WorkflowEventHistoryOrder) *WorkflowEventHistoryEdge {
	if order == nil {
		order = DefaultWorkflowEventHistoryOrder
	}
	return &WorkflowEventHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowInstanceHistoryEdge is the edge representation of WorkflowInstanceHistory.
type WorkflowInstanceHistoryEdge struct {
	Node   *WorkflowInstanceHistory `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// WorkflowInstanceHistoryConnection is the connection containing edges to WorkflowInstanceHistory.
type WorkflowInstanceHistoryConnection struct {
	Edges      []*WorkflowInstanceHistoryEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *WorkflowInstanceHistoryConnection) build(nodes []*WorkflowInstanceHistory, pager *workflowinstancehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowInstanceHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowInstanceHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowInstanceHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowInstanceHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowInstanceHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowInstanceHistoryPaginateOption enables pagination customization.
type WorkflowInstanceHistoryPaginateOption func(*workflowinstancehistoryPager) error

// WithWorkflowInstanceHistoryOrder configures pagination ordering.
func WithWorkflowInstanceHistoryOrder(order *WorkflowInstanceHistoryOrder) WorkflowInstanceHistoryPaginateOption {
	if order == nil {
		order = DefaultWorkflowInstanceHistoryOrder
	}
	o := *order
	return func(pager *workflowinstancehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkflowInstanceHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkflowInstanceHistoryFilter configures pagination filter.
func WithWorkflowInstanceHistoryFilter(filter func(*WorkflowInstanceHistoryQuery) (*WorkflowInstanceHistoryQuery, error)) WorkflowInstanceHistoryPaginateOption {
	return func(pager *workflowinstancehistoryPager) error {
		if filter == nil {
			return errors.New("WorkflowInstanceHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowinstancehistoryPager struct {
	reverse bool
	order   *WorkflowInstanceHistoryOrder
	filter  func(*WorkflowInstanceHistoryQuery) (*WorkflowInstanceHistoryQuery, error)
}

func newWorkflowInstanceHistoryPager(opts []WorkflowInstanceHistoryPaginateOption, reverse bool) (*workflowinstancehistoryPager, error) {
	pager := &workflowinstancehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkflowInstanceHistoryOrder
	}
	return pager, nil
}

func (p *workflowinstancehistoryPager) applyFilter(query *WorkflowInstanceHistoryQuery) (*WorkflowInstanceHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowinstancehistoryPager) toCursor(_m *WorkflowInstanceHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *workflowinstancehistoryPager) applyCursors(query *WorkflowInstanceHistoryQuery, after, before *Cursor) (*WorkflowInstanceHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkflowInstanceHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workflowinstancehistoryPager) applyOrder(query *WorkflowInstanceHistoryQuery) *WorkflowInstanceHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkflowInstanceHistoryOrder.Field {
		query = query.Order(DefaultWorkflowInstanceHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workflowinstancehistoryPager) orderExpr(query *WorkflowInstanceHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkflowInstanceHistoryOrder.Field {
			b.Comma().Ident(DefaultWorkflowInstanceHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowInstanceHistory.
func (_m *WorkflowInstanceHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowInstanceHistoryPaginateOption,
) (*WorkflowInstanceHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowInstanceHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowInstanceHistoryConnection{Edges: []*WorkflowInstanceHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowInstanceHistoryOrderFieldHistoryTime orders WorkflowInstanceHistory by history_time.
	WorkflowInstanceHistoryOrderFieldHistoryTime = &WorkflowInstanceHistoryOrderField{
		Value: func(_m *WorkflowInstanceHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: workflowinstancehistory.FieldHistoryTime,
		toTerm: workflowinstancehistory.ByHistoryTime,
		toCursor: func(_m *WorkflowInstanceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// WorkflowInstanceHistoryOrderFieldCreatedAt orders WorkflowInstanceHistory by created_at.
	WorkflowInstanceHistoryOrderFieldCreatedAt = &WorkflowInstanceHistoryOrderField{
		Value: func(_m *WorkflowInstanceHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowinstancehistory.FieldCreatedAt,
		toTerm: workflowinstancehistory.ByCreatedAt,
		toCursor: func(_m *WorkflowInstanceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowInstanceHistoryOrderFieldUpdatedAt orders WorkflowInstanceHistory by updated_at.
	WorkflowInstanceHistoryOrderFieldUpdatedAt = &WorkflowInstanceHistoryOrderField{
		Value: func(_m *WorkflowInstanceHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowinstancehistory.FieldUpdatedAt,
		toTerm: workflowinstancehistory.ByUpdatedAt,
		toCursor: func(_m *WorkflowInstanceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowInstanceHistoryOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowInstanceHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case WorkflowInstanceHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowInstanceHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowInstanceHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowInstanceHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowInstanceHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *WorkflowInstanceHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *WorkflowInstanceHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowInstanceHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowInstanceHistoryOrderField", str)
	}
	return nil
}

// WorkflowInstanceHistoryOrderField defines the ordering field of WorkflowInstanceHistory.
type WorkflowInstanceHistoryOrderField struct {
	// Value extracts the ordering value from the given WorkflowInstanceHistory.
	Value    func(*WorkflowInstanceHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowinstancehistory.OrderOption
	toCursor func(*WorkflowInstanceHistory) Cursor
}

// WorkflowInstanceHistoryOrder defines the ordering of WorkflowInstanceHistory.
type WorkflowInstanceHistoryOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *WorkflowInstanceHistoryOrderField `json:"field"`
}

// DefaultWorkflowInstanceHistoryOrder is the default ordering of WorkflowInstanceHistory.
var DefaultWorkflowInstanceHistoryOrder = &WorkflowInstanceHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowInstanceHistoryOrderField{
		Value: func(_m *WorkflowInstanceHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowinstancehistory.FieldID,
		toTerm: workflowinstancehistory.ByID,
		toCursor: func(_m *WorkflowInstanceHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowInstanceHistory into WorkflowInstanceHistoryEdge.
func (_m *WorkflowInstanceHistory) ToEdge(order *WorkflowInstanceHistoryOrder) *WorkflowInstanceHistoryEdge {
	if order == nil {
		order = DefaultWorkflowInstanceHistoryOrder
	}
	return &WorkflowInstanceHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowObjectRefHistoryEdge is the edge representation of WorkflowObjectRefHistory.
type WorkflowObjectRefHistoryEdge struct {
	Node   *WorkflowObjectRefHistory `json:"node"`
	Cursor Cursor                    `json:"cursor"`
}

// WorkflowObjectRefHistoryConnection is the connection containing edges to WorkflowObjectRefHistory.
type WorkflowObjectRefHistoryConnection struct {
	Edges      []*WorkflowObjectRefHistoryEdge `json:"edges"`
	PageInfo   PageInfo                        `json:"pageInfo"`
	TotalCount int                             `json:"totalCount"`
}

func (c *WorkflowObjectRefHistoryConnection) build(nodes []*WorkflowObjectRefHistory, pager *workflowobjectrefhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowObjectRefHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowObjectRefHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowObjectRefHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowObjectRefHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowObjectRefHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowObjectRefHistoryPaginateOption enables pagination customization.
type WorkflowObjectRefHistoryPaginateOption func(*workflowobjectrefhistoryPager) error

// WithWorkflowObjectRefHistoryOrder configures pagination ordering.
func WithWorkflowObjectRefHistoryOrder(order *WorkflowObjectRefHistoryOrder) WorkflowObjectRefHistoryPaginateOption {
	if order == nil {
		order = DefaultWorkflowObjectRefHistoryOrder
	}
	o := *order
	return func(pager *workflowobjectrefhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkflowObjectRefHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkflowObjectRefHistoryFilter configures pagination filter.
func WithWorkflowObjectRefHistoryFilter(filter func(*WorkflowObjectRefHistoryQuery) (*WorkflowObjectRefHistoryQuery, error)) WorkflowObjectRefHistoryPaginateOption {
	return func(pager *workflowobjectrefhistoryPager) error {
		if filter == nil {
			return errors.New("WorkflowObjectRefHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowobjectrefhistoryPager struct {
	reverse bool
	order   *WorkflowObjectRefHistoryOrder
	filter  func(*WorkflowObjectRefHistoryQuery) (*WorkflowObjectRefHistoryQuery, error)
}

func newWorkflowObjectRefHistoryPager(opts []WorkflowObjectRefHistoryPaginateOption, reverse bool) (*workflowobjectrefhistoryPager, error) {
	pager := &workflowobjectrefhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkflowObjectRefHistoryOrder
	}
	return pager, nil
}

func (p *workflowobjectrefhistoryPager) applyFilter(query *WorkflowObjectRefHistoryQuery) (*WorkflowObjectRefHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowobjectrefhistoryPager) toCursor(_m *WorkflowObjectRefHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *workflowobjectrefhistoryPager) applyCursors(query *WorkflowObjectRefHistoryQuery, after, before *Cursor) (*WorkflowObjectRefHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkflowObjectRefHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workflowobjectrefhistoryPager) applyOrder(query *WorkflowObjectRefHistoryQuery) *WorkflowObjectRefHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkflowObjectRefHistoryOrder.Field {
		query = query.Order(DefaultWorkflowObjectRefHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workflowobjectrefhistoryPager) orderExpr(query *WorkflowObjectRefHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkflowObjectRefHistoryOrder.Field {
			b.Comma().Ident(DefaultWorkflowObjectRefHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowObjectRefHistory.
func (_m *WorkflowObjectRefHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowObjectRefHistoryPaginateOption,
) (*WorkflowObjectRefHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowObjectRefHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowObjectRefHistoryConnection{Edges: []*WorkflowObjectRefHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowObjectRefHistoryOrderFieldHistoryTime orders WorkflowObjectRefHistory by history_time.
	WorkflowObjectRefHistoryOrderFieldHistoryTime = &WorkflowObjectRefHistoryOrderField{
		Value: func(_m *WorkflowObjectRefHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: workflowobjectrefhistory.FieldHistoryTime,
		toTerm: workflowobjectrefhistory.ByHistoryTime,
		toCursor: func(_m *WorkflowObjectRefHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// WorkflowObjectRefHistoryOrderFieldCreatedAt orders WorkflowObjectRefHistory by created_at.
	WorkflowObjectRefHistoryOrderFieldCreatedAt = &WorkflowObjectRefHistoryOrderField{
		Value: func(_m *WorkflowObjectRefHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowobjectrefhistory.FieldCreatedAt,
		toTerm: workflowobjectrefhistory.ByCreatedAt,
		toCursor: func(_m *WorkflowObjectRefHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowObjectRefHistoryOrderFieldUpdatedAt orders WorkflowObjectRefHistory by updated_at.
	WorkflowObjectRefHistoryOrderFieldUpdatedAt = &WorkflowObjectRefHistoryOrderField{
		Value: func(_m *WorkflowObjectRefHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowobjectrefhistory.FieldUpdatedAt,
		toTerm: workflowobjectrefhistory.ByUpdatedAt,
		toCursor: func(_m *WorkflowObjectRefHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowObjectRefHistoryOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowObjectRefHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case WorkflowObjectRefHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowObjectRefHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowObjectRefHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowObjectRefHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowObjectRefHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *WorkflowObjectRefHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *WorkflowObjectRefHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowObjectRefHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowObjectRefHistoryOrderField", str)
	}
	return nil
}

// WorkflowObjectRefHistoryOrderField defines the ordering field of WorkflowObjectRefHistory.
type WorkflowObjectRefHistoryOrderField struct {
	// Value extracts the ordering value from the given WorkflowObjectRefHistory.
	Value    func(*WorkflowObjectRefHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowobjectrefhistory.OrderOption
	toCursor func(*WorkflowObjectRefHistory) Cursor
}

// WorkflowObjectRefHistoryOrder defines the ordering of WorkflowObjectRefHistory.
type WorkflowObjectRefHistoryOrder struct {
	Direction OrderDirection                      `json:"direction"`
	Field     *WorkflowObjectRefHistoryOrderField `json:"field"`
}

// DefaultWorkflowObjectRefHistoryOrder is the default ordering of WorkflowObjectRefHistory.
var DefaultWorkflowObjectRefHistoryOrder = &WorkflowObjectRefHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowObjectRefHistoryOrderField{
		Value: func(_m *WorkflowObjectRefHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowobjectrefhistory.FieldID,
		toTerm: workflowobjectrefhistory.ByID,
		toCursor: func(_m *WorkflowObjectRefHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowObjectRefHistory into WorkflowObjectRefHistoryEdge.
func (_m *WorkflowObjectRefHistory) ToEdge(order *WorkflowObjectRefHistoryOrder) *WorkflowObjectRefHistoryEdge {
	if order == nil {
		order = DefaultWorkflowObjectRefHistoryOrder
	}
	return &WorkflowObjectRefHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}
