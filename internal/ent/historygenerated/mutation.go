// Code generated by ent, DO NOT EDIT.

package historygenerated

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/theopenlane/core/internal/ent/historygenerated/actionplanhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/assessmenthistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/assessmentresponsehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/assethistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/contacthistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/controlhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/controlimplementationhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/controlobjectivehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/customdomainhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/directoryaccounthistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/directorygrouphistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/directorymembershiphistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/discussionhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/dnsverificationhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/documentdatahistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/entityhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/entitytypehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/evidencehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/filehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/findingcontrolhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/findinghistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/grouphistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/groupmembershiphistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/groupsettinghistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/hushhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/integrationhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/internalpolicyhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/jobtemplatehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/mappabledomainhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/mappedcontrolhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/narrativehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/notehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/organizationhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/organizationsettinghistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/orgmembershiphistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/orgsubscriptionhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/predicate"
	"github.com/theopenlane/core/internal/ent/historygenerated/procedurehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/programhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/programmembershiphistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/remediationhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/reviewhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/riskhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/scanhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/scheduledjobhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/standardhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/subcontrolhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/subprocessorhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/taskhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/templatehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcentercompliancehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcenterdochistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcenterentityhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcenterhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcentersettinghistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcentersubprocessorhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/trustcenterwatermarkconfighistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/userhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/usersettinghistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/vulnerabilityhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/workflowassignmenthistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/workflowassignmenttargethistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/workflowdefinitionhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/workfloweventhistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/workflowinstancehistory"
	"github.com/theopenlane/core/internal/ent/historygenerated/workflowobjectrefhistory"
	"github.com/theopenlane/core/pkg/enums"
	"github.com/theopenlane/core/pkg/models"
	"github.com/theopenlane/entx/history"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActionPlanHistory                 = "ActionPlanHistory"
	TypeAssessmentHistory                 = "AssessmentHistory"
	TypeAssessmentResponseHistory         = "AssessmentResponseHistory"
	TypeAssetHistory                      = "AssetHistory"
	TypeContactHistory                    = "ContactHistory"
	TypeControlHistory                    = "ControlHistory"
	TypeControlImplementationHistory      = "ControlImplementationHistory"
	TypeControlObjectiveHistory           = "ControlObjectiveHistory"
	TypeCustomDomainHistory               = "CustomDomainHistory"
	TypeDNSVerificationHistory            = "DNSVerificationHistory"
	TypeDirectoryAccountHistory           = "DirectoryAccountHistory"
	TypeDirectoryGroupHistory             = "DirectoryGroupHistory"
	TypeDirectoryMembershipHistory        = "DirectoryMembershipHistory"
	TypeDiscussionHistory                 = "DiscussionHistory"
	TypeDocumentDataHistory               = "DocumentDataHistory"
	TypeEntityHistory                     = "EntityHistory"
	TypeEntityTypeHistory                 = "EntityTypeHistory"
	TypeEvidenceHistory                   = "EvidenceHistory"
	TypeFileHistory                       = "FileHistory"
	TypeFindingControlHistory             = "FindingControlHistory"
	TypeFindingHistory                    = "FindingHistory"
	TypeGroupHistory                      = "GroupHistory"
	TypeGroupMembershipHistory            = "GroupMembershipHistory"
	TypeGroupSettingHistory               = "GroupSettingHistory"
	TypeHushHistory                       = "HushHistory"
	TypeIntegrationHistory                = "IntegrationHistory"
	TypeInternalPolicyHistory             = "InternalPolicyHistory"
	TypeJobTemplateHistory                = "JobTemplateHistory"
	TypeMappableDomainHistory             = "MappableDomainHistory"
	TypeMappedControlHistory              = "MappedControlHistory"
	TypeNarrativeHistory                  = "NarrativeHistory"
	TypeNoteHistory                       = "NoteHistory"
	TypeOrgMembershipHistory              = "OrgMembershipHistory"
	TypeOrgSubscriptionHistory            = "OrgSubscriptionHistory"
	TypeOrganizationHistory               = "OrganizationHistory"
	TypeOrganizationSettingHistory        = "OrganizationSettingHistory"
	TypeProcedureHistory                  = "ProcedureHistory"
	TypeProgramHistory                    = "ProgramHistory"
	TypeProgramMembershipHistory          = "ProgramMembershipHistory"
	TypeRemediationHistory                = "RemediationHistory"
	TypeReviewHistory                     = "ReviewHistory"
	TypeRiskHistory                       = "RiskHistory"
	TypeScanHistory                       = "ScanHistory"
	TypeScheduledJobHistory               = "ScheduledJobHistory"
	TypeStandardHistory                   = "StandardHistory"
	TypeSubcontrolHistory                 = "SubcontrolHistory"
	TypeSubprocessorHistory               = "SubprocessorHistory"
	TypeTaskHistory                       = "TaskHistory"
	TypeTemplateHistory                   = "TemplateHistory"
	TypeTrustCenterComplianceHistory      = "TrustCenterComplianceHistory"
	TypeTrustCenterDocHistory             = "TrustCenterDocHistory"
	TypeTrustCenterHistory                = "TrustCenterHistory"
	TypeTrustCenterSettingHistory         = "TrustCenterSettingHistory"
	TypeTrustCenterSubprocessorHistory    = "TrustCenterSubprocessorHistory"
	TypeTrustCenterWatermarkConfigHistory = "TrustCenterWatermarkConfigHistory"
	TypeTrustcenterEntityHistory          = "TrustcenterEntityHistory"
	TypeUserHistory                       = "UserHistory"
	TypeUserSettingHistory                = "UserSettingHistory"
	TypeVulnerabilityHistory              = "VulnerabilityHistory"
	TypeWorkflowAssignmentHistory         = "WorkflowAssignmentHistory"
	TypeWorkflowAssignmentTargetHistory   = "WorkflowAssignmentTargetHistory"
	TypeWorkflowDefinitionHistory         = "WorkflowDefinitionHistory"
	TypeWorkflowEventHistory              = "WorkflowEventHistory"
	TypeWorkflowInstanceHistory           = "WorkflowInstanceHistory"
	TypeWorkflowObjectRefHistory          = "WorkflowObjectRefHistory"
)

// ActionPlanHistoryMutation represents an operation that mutates the ActionPlanHistory nodes in the graph.
type ActionPlanHistoryMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *string
	history_time                            *time.Time
	ref                                     *string
	operation                               *history.OpType
	created_at                              *time.Time
	updated_at                              *time.Time
	created_by                              *string
	updated_by                              *string
	deleted_at                              *time.Time
	deleted_by                              *string
	tags                                    *[]string
	appendtags                              []string
	revision                                *string
	name                                    *string
	status                                  *enums.DocumentStatus
	action_plan_type                        *string
	details                                 *string
	approval_required                       *bool
	review_due                              *time.Time
	review_frequency                        *enums.Frequency
	approver_id                             *string
	delegate_id                             *string
	summary                                 *string
	tag_suggestions                         *[]string
	appendtag_suggestions                   []string
	dismissed_tag_suggestions               *[]string
	appenddismissed_tag_suggestions         []string
	control_suggestions                     *[]string
	appendcontrol_suggestions               []string
	dismissed_control_suggestions           *[]string
	appenddismissed_control_suggestions     []string
	improvement_suggestions                 *[]string
	appendimprovement_suggestions           []string
	dismissed_improvement_suggestions       *[]string
	appenddismissed_improvement_suggestions []string
	url                                     *string
	file_id                                 *string
	owner_id                                *string
	system_owned                            *bool
	internal_notes                          *string
	system_internal_id                      *string
	action_plan_kind_name                   *string
	action_plan_kind_id                     *string
	title                                   *string
	description                             *string
	due_date                                *time.Time
	completed_at                            *time.Time
	priority                                *enums.Priority
	requires_approval                       *bool
	blocked                                 *bool
	blocker_reason                          *string
	metadata                                *map[string]interface{}
	raw_payload                             *map[string]interface{}
	source                                  *string
	clearedFields                           map[string]struct{}
	done                                    bool
	oldValue                                func(context.Context) (*ActionPlanHistory, error)
	predicates                              []predicate.ActionPlanHistory
}

var _ ent.Mutation = (*ActionPlanHistoryMutation)(nil)

// actionplanhistoryOption allows management of the mutation configuration using functional options.
type actionplanhistoryOption func(*ActionPlanHistoryMutation)

// newActionPlanHistoryMutation creates new mutation for the ActionPlanHistory entity.
func newActionPlanHistoryMutation(c config, op Op, opts ...actionplanhistoryOption) *ActionPlanHistoryMutation {
	m := &ActionPlanHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeActionPlanHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActionPlanHistoryID sets the ID field of the mutation.
func withActionPlanHistoryID(id string) actionplanhistoryOption {
	return func(m *ActionPlanHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ActionPlanHistory
		)
		m.oldValue = func(ctx context.Context) (*ActionPlanHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActionPlanHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActionPlanHistory sets the old ActionPlanHistory of the mutation.
func withActionPlanHistory(node *ActionPlanHistory) actionplanhistoryOption {
	return func(m *ActionPlanHistoryMutation) {
		m.oldValue = func(context.Context) (*ActionPlanHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActionPlanHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActionPlanHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActionPlanHistory entities.
func (m *ActionPlanHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActionPlanHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActionPlanHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActionPlanHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ActionPlanHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ActionPlanHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ActionPlanHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ActionPlanHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ActionPlanHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ActionPlanHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[actionplanhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ActionPlanHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, actionplanhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ActionPlanHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ActionPlanHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ActionPlanHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ActionPlanHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActionPlanHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ActionPlanHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[actionplanhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActionPlanHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, actionplanhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActionPlanHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActionPlanHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ActionPlanHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[actionplanhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActionPlanHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, actionplanhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ActionPlanHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ActionPlanHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ActionPlanHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[actionplanhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ActionPlanHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, actionplanhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ActionPlanHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ActionPlanHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ActionPlanHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[actionplanhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ActionPlanHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, actionplanhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ActionPlanHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ActionPlanHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ActionPlanHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[actionplanhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ActionPlanHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, actionplanhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ActionPlanHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ActionPlanHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ActionPlanHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[actionplanhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ActionPlanHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, actionplanhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *ActionPlanHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ActionPlanHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ActionPlanHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ActionPlanHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ActionPlanHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[actionplanhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ActionPlanHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, actionplanhistory.FieldTags)
}

// SetRevision sets the "revision" field.
func (m *ActionPlanHistoryMutation) SetRevision(s string) {
	m.revision = &s
}

// Revision returns the value of the "revision" field in the mutation.
func (m *ActionPlanHistoryMutation) Revision() (r string, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldRevision(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// ClearRevision clears the value of the "revision" field.
func (m *ActionPlanHistoryMutation) ClearRevision() {
	m.revision = nil
	m.clearedFields[actionplanhistory.FieldRevision] = struct{}{}
}

// RevisionCleared returns if the "revision" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) RevisionCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldRevision]
	return ok
}

// ResetRevision resets all changes to the "revision" field.
func (m *ActionPlanHistoryMutation) ResetRevision() {
	m.revision = nil
	delete(m.clearedFields, actionplanhistory.FieldRevision)
}

// SetName sets the "name" field.
func (m *ActionPlanHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ActionPlanHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ActionPlanHistoryMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *ActionPlanHistoryMutation) SetStatus(es enums.DocumentStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *ActionPlanHistoryMutation) Status() (r enums.DocumentStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldStatus(ctx context.Context) (v enums.DocumentStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ActionPlanHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[actionplanhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ActionPlanHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, actionplanhistory.FieldStatus)
}

// SetActionPlanType sets the "action_plan_type" field.
func (m *ActionPlanHistoryMutation) SetActionPlanType(s string) {
	m.action_plan_type = &s
}

// ActionPlanType returns the value of the "action_plan_type" field in the mutation.
func (m *ActionPlanHistoryMutation) ActionPlanType() (r string, exists bool) {
	v := m.action_plan_type
	if v == nil {
		return
	}
	return *v, true
}

// OldActionPlanType returns the old "action_plan_type" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldActionPlanType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionPlanType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionPlanType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionPlanType: %w", err)
	}
	return oldValue.ActionPlanType, nil
}

// ClearActionPlanType clears the value of the "action_plan_type" field.
func (m *ActionPlanHistoryMutation) ClearActionPlanType() {
	m.action_plan_type = nil
	m.clearedFields[actionplanhistory.FieldActionPlanType] = struct{}{}
}

// ActionPlanTypeCleared returns if the "action_plan_type" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) ActionPlanTypeCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldActionPlanType]
	return ok
}

// ResetActionPlanType resets all changes to the "action_plan_type" field.
func (m *ActionPlanHistoryMutation) ResetActionPlanType() {
	m.action_plan_type = nil
	delete(m.clearedFields, actionplanhistory.FieldActionPlanType)
}

// SetDetails sets the "details" field.
func (m *ActionPlanHistoryMutation) SetDetails(s string) {
	m.details = &s
}

// Details returns the value of the "details" field in the mutation.
func (m *ActionPlanHistoryMutation) Details() (r string, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *ActionPlanHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[actionplanhistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *ActionPlanHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, actionplanhistory.FieldDetails)
}

// SetApprovalRequired sets the "approval_required" field.
func (m *ActionPlanHistoryMutation) SetApprovalRequired(b bool) {
	m.approval_required = &b
}

// ApprovalRequired returns the value of the "approval_required" field in the mutation.
func (m *ActionPlanHistoryMutation) ApprovalRequired() (r bool, exists bool) {
	v := m.approval_required
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalRequired returns the old "approval_required" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldApprovalRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalRequired: %w", err)
	}
	return oldValue.ApprovalRequired, nil
}

// ClearApprovalRequired clears the value of the "approval_required" field.
func (m *ActionPlanHistoryMutation) ClearApprovalRequired() {
	m.approval_required = nil
	m.clearedFields[actionplanhistory.FieldApprovalRequired] = struct{}{}
}

// ApprovalRequiredCleared returns if the "approval_required" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) ApprovalRequiredCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldApprovalRequired]
	return ok
}

// ResetApprovalRequired resets all changes to the "approval_required" field.
func (m *ActionPlanHistoryMutation) ResetApprovalRequired() {
	m.approval_required = nil
	delete(m.clearedFields, actionplanhistory.FieldApprovalRequired)
}

// SetReviewDue sets the "review_due" field.
func (m *ActionPlanHistoryMutation) SetReviewDue(t time.Time) {
	m.review_due = &t
}

// ReviewDue returns the value of the "review_due" field in the mutation.
func (m *ActionPlanHistoryMutation) ReviewDue() (r time.Time, exists bool) {
	v := m.review_due
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewDue returns the old "review_due" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldReviewDue(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewDue: %w", err)
	}
	return oldValue.ReviewDue, nil
}

// ClearReviewDue clears the value of the "review_due" field.
func (m *ActionPlanHistoryMutation) ClearReviewDue() {
	m.review_due = nil
	m.clearedFields[actionplanhistory.FieldReviewDue] = struct{}{}
}

// ReviewDueCleared returns if the "review_due" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) ReviewDueCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldReviewDue]
	return ok
}

// ResetReviewDue resets all changes to the "review_due" field.
func (m *ActionPlanHistoryMutation) ResetReviewDue() {
	m.review_due = nil
	delete(m.clearedFields, actionplanhistory.FieldReviewDue)
}

// SetReviewFrequency sets the "review_frequency" field.
func (m *ActionPlanHistoryMutation) SetReviewFrequency(e enums.Frequency) {
	m.review_frequency = &e
}

// ReviewFrequency returns the value of the "review_frequency" field in the mutation.
func (m *ActionPlanHistoryMutation) ReviewFrequency() (r enums.Frequency, exists bool) {
	v := m.review_frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewFrequency returns the old "review_frequency" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldReviewFrequency(ctx context.Context) (v enums.Frequency, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewFrequency: %w", err)
	}
	return oldValue.ReviewFrequency, nil
}

// ClearReviewFrequency clears the value of the "review_frequency" field.
func (m *ActionPlanHistoryMutation) ClearReviewFrequency() {
	m.review_frequency = nil
	m.clearedFields[actionplanhistory.FieldReviewFrequency] = struct{}{}
}

// ReviewFrequencyCleared returns if the "review_frequency" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) ReviewFrequencyCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldReviewFrequency]
	return ok
}

// ResetReviewFrequency resets all changes to the "review_frequency" field.
func (m *ActionPlanHistoryMutation) ResetReviewFrequency() {
	m.review_frequency = nil
	delete(m.clearedFields, actionplanhistory.FieldReviewFrequency)
}

// SetApproverID sets the "approver_id" field.
func (m *ActionPlanHistoryMutation) SetApproverID(s string) {
	m.approver_id = &s
}

// ApproverID returns the value of the "approver_id" field in the mutation.
func (m *ActionPlanHistoryMutation) ApproverID() (r string, exists bool) {
	v := m.approver_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApproverID returns the old "approver_id" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldApproverID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproverID: %w", err)
	}
	return oldValue.ApproverID, nil
}

// ClearApproverID clears the value of the "approver_id" field.
func (m *ActionPlanHistoryMutation) ClearApproverID() {
	m.approver_id = nil
	m.clearedFields[actionplanhistory.FieldApproverID] = struct{}{}
}

// ApproverIDCleared returns if the "approver_id" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) ApproverIDCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldApproverID]
	return ok
}

// ResetApproverID resets all changes to the "approver_id" field.
func (m *ActionPlanHistoryMutation) ResetApproverID() {
	m.approver_id = nil
	delete(m.clearedFields, actionplanhistory.FieldApproverID)
}

// SetDelegateID sets the "delegate_id" field.
func (m *ActionPlanHistoryMutation) SetDelegateID(s string) {
	m.delegate_id = &s
}

// DelegateID returns the value of the "delegate_id" field in the mutation.
func (m *ActionPlanHistoryMutation) DelegateID() (r string, exists bool) {
	v := m.delegate_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegateID returns the old "delegate_id" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldDelegateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelegateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelegateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegateID: %w", err)
	}
	return oldValue.DelegateID, nil
}

// ClearDelegateID clears the value of the "delegate_id" field.
func (m *ActionPlanHistoryMutation) ClearDelegateID() {
	m.delegate_id = nil
	m.clearedFields[actionplanhistory.FieldDelegateID] = struct{}{}
}

// DelegateIDCleared returns if the "delegate_id" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) DelegateIDCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldDelegateID]
	return ok
}

// ResetDelegateID resets all changes to the "delegate_id" field.
func (m *ActionPlanHistoryMutation) ResetDelegateID() {
	m.delegate_id = nil
	delete(m.clearedFields, actionplanhistory.FieldDelegateID)
}

// SetSummary sets the "summary" field.
func (m *ActionPlanHistoryMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *ActionPlanHistoryMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *ActionPlanHistoryMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[actionplanhistory.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *ActionPlanHistoryMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, actionplanhistory.FieldSummary)
}

// SetTagSuggestions sets the "tag_suggestions" field.
func (m *ActionPlanHistoryMutation) SetTagSuggestions(s []string) {
	m.tag_suggestions = &s
	m.appendtag_suggestions = nil
}

// TagSuggestions returns the value of the "tag_suggestions" field in the mutation.
func (m *ActionPlanHistoryMutation) TagSuggestions() (r []string, exists bool) {
	v := m.tag_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldTagSuggestions returns the old "tag_suggestions" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldTagSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagSuggestions: %w", err)
	}
	return oldValue.TagSuggestions, nil
}

// AppendTagSuggestions adds s to the "tag_suggestions" field.
func (m *ActionPlanHistoryMutation) AppendTagSuggestions(s []string) {
	m.appendtag_suggestions = append(m.appendtag_suggestions, s...)
}

// AppendedTagSuggestions returns the list of values that were appended to the "tag_suggestions" field in this mutation.
func (m *ActionPlanHistoryMutation) AppendedTagSuggestions() ([]string, bool) {
	if len(m.appendtag_suggestions) == 0 {
		return nil, false
	}
	return m.appendtag_suggestions, true
}

// ClearTagSuggestions clears the value of the "tag_suggestions" field.
func (m *ActionPlanHistoryMutation) ClearTagSuggestions() {
	m.tag_suggestions = nil
	m.appendtag_suggestions = nil
	m.clearedFields[actionplanhistory.FieldTagSuggestions] = struct{}{}
}

// TagSuggestionsCleared returns if the "tag_suggestions" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) TagSuggestionsCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldTagSuggestions]
	return ok
}

// ResetTagSuggestions resets all changes to the "tag_suggestions" field.
func (m *ActionPlanHistoryMutation) ResetTagSuggestions() {
	m.tag_suggestions = nil
	m.appendtag_suggestions = nil
	delete(m.clearedFields, actionplanhistory.FieldTagSuggestions)
}

// SetDismissedTagSuggestions sets the "dismissed_tag_suggestions" field.
func (m *ActionPlanHistoryMutation) SetDismissedTagSuggestions(s []string) {
	m.dismissed_tag_suggestions = &s
	m.appenddismissed_tag_suggestions = nil
}

// DismissedTagSuggestions returns the value of the "dismissed_tag_suggestions" field in the mutation.
func (m *ActionPlanHistoryMutation) DismissedTagSuggestions() (r []string, exists bool) {
	v := m.dismissed_tag_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldDismissedTagSuggestions returns the old "dismissed_tag_suggestions" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldDismissedTagSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDismissedTagSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDismissedTagSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDismissedTagSuggestions: %w", err)
	}
	return oldValue.DismissedTagSuggestions, nil
}

// AppendDismissedTagSuggestions adds s to the "dismissed_tag_suggestions" field.
func (m *ActionPlanHistoryMutation) AppendDismissedTagSuggestions(s []string) {
	m.appenddismissed_tag_suggestions = append(m.appenddismissed_tag_suggestions, s...)
}

// AppendedDismissedTagSuggestions returns the list of values that were appended to the "dismissed_tag_suggestions" field in this mutation.
func (m *ActionPlanHistoryMutation) AppendedDismissedTagSuggestions() ([]string, bool) {
	if len(m.appenddismissed_tag_suggestions) == 0 {
		return nil, false
	}
	return m.appenddismissed_tag_suggestions, true
}

// ClearDismissedTagSuggestions clears the value of the "dismissed_tag_suggestions" field.
func (m *ActionPlanHistoryMutation) ClearDismissedTagSuggestions() {
	m.dismissed_tag_suggestions = nil
	m.appenddismissed_tag_suggestions = nil
	m.clearedFields[actionplanhistory.FieldDismissedTagSuggestions] = struct{}{}
}

// DismissedTagSuggestionsCleared returns if the "dismissed_tag_suggestions" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) DismissedTagSuggestionsCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldDismissedTagSuggestions]
	return ok
}

// ResetDismissedTagSuggestions resets all changes to the "dismissed_tag_suggestions" field.
func (m *ActionPlanHistoryMutation) ResetDismissedTagSuggestions() {
	m.dismissed_tag_suggestions = nil
	m.appenddismissed_tag_suggestions = nil
	delete(m.clearedFields, actionplanhistory.FieldDismissedTagSuggestions)
}

// SetControlSuggestions sets the "control_suggestions" field.
func (m *ActionPlanHistoryMutation) SetControlSuggestions(s []string) {
	m.control_suggestions = &s
	m.appendcontrol_suggestions = nil
}

// ControlSuggestions returns the value of the "control_suggestions" field in the mutation.
func (m *ActionPlanHistoryMutation) ControlSuggestions() (r []string, exists bool) {
	v := m.control_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldControlSuggestions returns the old "control_suggestions" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldControlSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlSuggestions: %w", err)
	}
	return oldValue.ControlSuggestions, nil
}

// AppendControlSuggestions adds s to the "control_suggestions" field.
func (m *ActionPlanHistoryMutation) AppendControlSuggestions(s []string) {
	m.appendcontrol_suggestions = append(m.appendcontrol_suggestions, s...)
}

// AppendedControlSuggestions returns the list of values that were appended to the "control_suggestions" field in this mutation.
func (m *ActionPlanHistoryMutation) AppendedControlSuggestions() ([]string, bool) {
	if len(m.appendcontrol_suggestions) == 0 {
		return nil, false
	}
	return m.appendcontrol_suggestions, true
}

// ClearControlSuggestions clears the value of the "control_suggestions" field.
func (m *ActionPlanHistoryMutation) ClearControlSuggestions() {
	m.control_suggestions = nil
	m.appendcontrol_suggestions = nil
	m.clearedFields[actionplanhistory.FieldControlSuggestions] = struct{}{}
}

// ControlSuggestionsCleared returns if the "control_suggestions" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) ControlSuggestionsCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldControlSuggestions]
	return ok
}

// ResetControlSuggestions resets all changes to the "control_suggestions" field.
func (m *ActionPlanHistoryMutation) ResetControlSuggestions() {
	m.control_suggestions = nil
	m.appendcontrol_suggestions = nil
	delete(m.clearedFields, actionplanhistory.FieldControlSuggestions)
}

// SetDismissedControlSuggestions sets the "dismissed_control_suggestions" field.
func (m *ActionPlanHistoryMutation) SetDismissedControlSuggestions(s []string) {
	m.dismissed_control_suggestions = &s
	m.appenddismissed_control_suggestions = nil
}

// DismissedControlSuggestions returns the value of the "dismissed_control_suggestions" field in the mutation.
func (m *ActionPlanHistoryMutation) DismissedControlSuggestions() (r []string, exists bool) {
	v := m.dismissed_control_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldDismissedControlSuggestions returns the old "dismissed_control_suggestions" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldDismissedControlSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDismissedControlSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDismissedControlSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDismissedControlSuggestions: %w", err)
	}
	return oldValue.DismissedControlSuggestions, nil
}

// AppendDismissedControlSuggestions adds s to the "dismissed_control_suggestions" field.
func (m *ActionPlanHistoryMutation) AppendDismissedControlSuggestions(s []string) {
	m.appenddismissed_control_suggestions = append(m.appenddismissed_control_suggestions, s...)
}

// AppendedDismissedControlSuggestions returns the list of values that were appended to the "dismissed_control_suggestions" field in this mutation.
func (m *ActionPlanHistoryMutation) AppendedDismissedControlSuggestions() ([]string, bool) {
	if len(m.appenddismissed_control_suggestions) == 0 {
		return nil, false
	}
	return m.appenddismissed_control_suggestions, true
}

// ClearDismissedControlSuggestions clears the value of the "dismissed_control_suggestions" field.
func (m *ActionPlanHistoryMutation) ClearDismissedControlSuggestions() {
	m.dismissed_control_suggestions = nil
	m.appenddismissed_control_suggestions = nil
	m.clearedFields[actionplanhistory.FieldDismissedControlSuggestions] = struct{}{}
}

// DismissedControlSuggestionsCleared returns if the "dismissed_control_suggestions" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) DismissedControlSuggestionsCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldDismissedControlSuggestions]
	return ok
}

// ResetDismissedControlSuggestions resets all changes to the "dismissed_control_suggestions" field.
func (m *ActionPlanHistoryMutation) ResetDismissedControlSuggestions() {
	m.dismissed_control_suggestions = nil
	m.appenddismissed_control_suggestions = nil
	delete(m.clearedFields, actionplanhistory.FieldDismissedControlSuggestions)
}

// SetImprovementSuggestions sets the "improvement_suggestions" field.
func (m *ActionPlanHistoryMutation) SetImprovementSuggestions(s []string) {
	m.improvement_suggestions = &s
	m.appendimprovement_suggestions = nil
}

// ImprovementSuggestions returns the value of the "improvement_suggestions" field in the mutation.
func (m *ActionPlanHistoryMutation) ImprovementSuggestions() (r []string, exists bool) {
	v := m.improvement_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldImprovementSuggestions returns the old "improvement_suggestions" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldImprovementSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImprovementSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImprovementSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImprovementSuggestions: %w", err)
	}
	return oldValue.ImprovementSuggestions, nil
}

// AppendImprovementSuggestions adds s to the "improvement_suggestions" field.
func (m *ActionPlanHistoryMutation) AppendImprovementSuggestions(s []string) {
	m.appendimprovement_suggestions = append(m.appendimprovement_suggestions, s...)
}

// AppendedImprovementSuggestions returns the list of values that were appended to the "improvement_suggestions" field in this mutation.
func (m *ActionPlanHistoryMutation) AppendedImprovementSuggestions() ([]string, bool) {
	if len(m.appendimprovement_suggestions) == 0 {
		return nil, false
	}
	return m.appendimprovement_suggestions, true
}

// ClearImprovementSuggestions clears the value of the "improvement_suggestions" field.
func (m *ActionPlanHistoryMutation) ClearImprovementSuggestions() {
	m.improvement_suggestions = nil
	m.appendimprovement_suggestions = nil
	m.clearedFields[actionplanhistory.FieldImprovementSuggestions] = struct{}{}
}

// ImprovementSuggestionsCleared returns if the "improvement_suggestions" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) ImprovementSuggestionsCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldImprovementSuggestions]
	return ok
}

// ResetImprovementSuggestions resets all changes to the "improvement_suggestions" field.
func (m *ActionPlanHistoryMutation) ResetImprovementSuggestions() {
	m.improvement_suggestions = nil
	m.appendimprovement_suggestions = nil
	delete(m.clearedFields, actionplanhistory.FieldImprovementSuggestions)
}

// SetDismissedImprovementSuggestions sets the "dismissed_improvement_suggestions" field.
func (m *ActionPlanHistoryMutation) SetDismissedImprovementSuggestions(s []string) {
	m.dismissed_improvement_suggestions = &s
	m.appenddismissed_improvement_suggestions = nil
}

// DismissedImprovementSuggestions returns the value of the "dismissed_improvement_suggestions" field in the mutation.
func (m *ActionPlanHistoryMutation) DismissedImprovementSuggestions() (r []string, exists bool) {
	v := m.dismissed_improvement_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldDismissedImprovementSuggestions returns the old "dismissed_improvement_suggestions" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldDismissedImprovementSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDismissedImprovementSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDismissedImprovementSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDismissedImprovementSuggestions: %w", err)
	}
	return oldValue.DismissedImprovementSuggestions, nil
}

// AppendDismissedImprovementSuggestions adds s to the "dismissed_improvement_suggestions" field.
func (m *ActionPlanHistoryMutation) AppendDismissedImprovementSuggestions(s []string) {
	m.appenddismissed_improvement_suggestions = append(m.appenddismissed_improvement_suggestions, s...)
}

// AppendedDismissedImprovementSuggestions returns the list of values that were appended to the "dismissed_improvement_suggestions" field in this mutation.
func (m *ActionPlanHistoryMutation) AppendedDismissedImprovementSuggestions() ([]string, bool) {
	if len(m.appenddismissed_improvement_suggestions) == 0 {
		return nil, false
	}
	return m.appenddismissed_improvement_suggestions, true
}

// ClearDismissedImprovementSuggestions clears the value of the "dismissed_improvement_suggestions" field.
func (m *ActionPlanHistoryMutation) ClearDismissedImprovementSuggestions() {
	m.dismissed_improvement_suggestions = nil
	m.appenddismissed_improvement_suggestions = nil
	m.clearedFields[actionplanhistory.FieldDismissedImprovementSuggestions] = struct{}{}
}

// DismissedImprovementSuggestionsCleared returns if the "dismissed_improvement_suggestions" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) DismissedImprovementSuggestionsCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldDismissedImprovementSuggestions]
	return ok
}

// ResetDismissedImprovementSuggestions resets all changes to the "dismissed_improvement_suggestions" field.
func (m *ActionPlanHistoryMutation) ResetDismissedImprovementSuggestions() {
	m.dismissed_improvement_suggestions = nil
	m.appenddismissed_improvement_suggestions = nil
	delete(m.clearedFields, actionplanhistory.FieldDismissedImprovementSuggestions)
}

// SetURL sets the "url" field.
func (m *ActionPlanHistoryMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ActionPlanHistoryMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ActionPlanHistoryMutation) ClearURL() {
	m.url = nil
	m.clearedFields[actionplanhistory.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) URLCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ActionPlanHistoryMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, actionplanhistory.FieldURL)
}

// SetFileID sets the "file_id" field.
func (m *ActionPlanHistoryMutation) SetFileID(s string) {
	m.file_id = &s
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *ActionPlanHistoryMutation) FileID() (r string, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ClearFileID clears the value of the "file_id" field.
func (m *ActionPlanHistoryMutation) ClearFileID() {
	m.file_id = nil
	m.clearedFields[actionplanhistory.FieldFileID] = struct{}{}
}

// FileIDCleared returns if the "file_id" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) FileIDCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldFileID]
	return ok
}

// ResetFileID resets all changes to the "file_id" field.
func (m *ActionPlanHistoryMutation) ResetFileID() {
	m.file_id = nil
	delete(m.clearedFields, actionplanhistory.FieldFileID)
}

// SetOwnerID sets the "owner_id" field.
func (m *ActionPlanHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ActionPlanHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *ActionPlanHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[actionplanhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ActionPlanHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, actionplanhistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *ActionPlanHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *ActionPlanHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *ActionPlanHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[actionplanhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *ActionPlanHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, actionplanhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *ActionPlanHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *ActionPlanHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *ActionPlanHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[actionplanhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *ActionPlanHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, actionplanhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *ActionPlanHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *ActionPlanHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *ActionPlanHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[actionplanhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *ActionPlanHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, actionplanhistory.FieldSystemInternalID)
}

// SetActionPlanKindName sets the "action_plan_kind_name" field.
func (m *ActionPlanHistoryMutation) SetActionPlanKindName(s string) {
	m.action_plan_kind_name = &s
}

// ActionPlanKindName returns the value of the "action_plan_kind_name" field in the mutation.
func (m *ActionPlanHistoryMutation) ActionPlanKindName() (r string, exists bool) {
	v := m.action_plan_kind_name
	if v == nil {
		return
	}
	return *v, true
}

// OldActionPlanKindName returns the old "action_plan_kind_name" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldActionPlanKindName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionPlanKindName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionPlanKindName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionPlanKindName: %w", err)
	}
	return oldValue.ActionPlanKindName, nil
}

// ClearActionPlanKindName clears the value of the "action_plan_kind_name" field.
func (m *ActionPlanHistoryMutation) ClearActionPlanKindName() {
	m.action_plan_kind_name = nil
	m.clearedFields[actionplanhistory.FieldActionPlanKindName] = struct{}{}
}

// ActionPlanKindNameCleared returns if the "action_plan_kind_name" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) ActionPlanKindNameCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldActionPlanKindName]
	return ok
}

// ResetActionPlanKindName resets all changes to the "action_plan_kind_name" field.
func (m *ActionPlanHistoryMutation) ResetActionPlanKindName() {
	m.action_plan_kind_name = nil
	delete(m.clearedFields, actionplanhistory.FieldActionPlanKindName)
}

// SetActionPlanKindID sets the "action_plan_kind_id" field.
func (m *ActionPlanHistoryMutation) SetActionPlanKindID(s string) {
	m.action_plan_kind_id = &s
}

// ActionPlanKindID returns the value of the "action_plan_kind_id" field in the mutation.
func (m *ActionPlanHistoryMutation) ActionPlanKindID() (r string, exists bool) {
	v := m.action_plan_kind_id
	if v == nil {
		return
	}
	return *v, true
}

// OldActionPlanKindID returns the old "action_plan_kind_id" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldActionPlanKindID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionPlanKindID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionPlanKindID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionPlanKindID: %w", err)
	}
	return oldValue.ActionPlanKindID, nil
}

// ClearActionPlanKindID clears the value of the "action_plan_kind_id" field.
func (m *ActionPlanHistoryMutation) ClearActionPlanKindID() {
	m.action_plan_kind_id = nil
	m.clearedFields[actionplanhistory.FieldActionPlanKindID] = struct{}{}
}

// ActionPlanKindIDCleared returns if the "action_plan_kind_id" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) ActionPlanKindIDCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldActionPlanKindID]
	return ok
}

// ResetActionPlanKindID resets all changes to the "action_plan_kind_id" field.
func (m *ActionPlanHistoryMutation) ResetActionPlanKindID() {
	m.action_plan_kind_id = nil
	delete(m.clearedFields, actionplanhistory.FieldActionPlanKindID)
}

// SetTitle sets the "title" field.
func (m *ActionPlanHistoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ActionPlanHistoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ActionPlanHistoryMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ActionPlanHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ActionPlanHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ActionPlanHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[actionplanhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ActionPlanHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, actionplanhistory.FieldDescription)
}

// SetDueDate sets the "due_date" field.
func (m *ActionPlanHistoryMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *ActionPlanHistoryMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of the "due_date" field.
func (m *ActionPlanHistoryMutation) ClearDueDate() {
	m.due_date = nil
	m.clearedFields[actionplanhistory.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "due_date" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *ActionPlanHistoryMutation) ResetDueDate() {
	m.due_date = nil
	delete(m.clearedFields, actionplanhistory.FieldDueDate)
}

// SetCompletedAt sets the "completed_at" field.
func (m *ActionPlanHistoryMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *ActionPlanHistoryMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *ActionPlanHistoryMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[actionplanhistory.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *ActionPlanHistoryMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, actionplanhistory.FieldCompletedAt)
}

// SetPriority sets the "priority" field.
func (m *ActionPlanHistoryMutation) SetPriority(e enums.Priority) {
	m.priority = &e
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ActionPlanHistoryMutation) Priority() (r enums.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldPriority(ctx context.Context) (v enums.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ClearPriority clears the value of the "priority" field.
func (m *ActionPlanHistoryMutation) ClearPriority() {
	m.priority = nil
	m.clearedFields[actionplanhistory.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *ActionPlanHistoryMutation) ResetPriority() {
	m.priority = nil
	delete(m.clearedFields, actionplanhistory.FieldPriority)
}

// SetRequiresApproval sets the "requires_approval" field.
func (m *ActionPlanHistoryMutation) SetRequiresApproval(b bool) {
	m.requires_approval = &b
}

// RequiresApproval returns the value of the "requires_approval" field in the mutation.
func (m *ActionPlanHistoryMutation) RequiresApproval() (r bool, exists bool) {
	v := m.requires_approval
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresApproval returns the old "requires_approval" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldRequiresApproval(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresApproval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresApproval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresApproval: %w", err)
	}
	return oldValue.RequiresApproval, nil
}

// ResetRequiresApproval resets all changes to the "requires_approval" field.
func (m *ActionPlanHistoryMutation) ResetRequiresApproval() {
	m.requires_approval = nil
}

// SetBlocked sets the "blocked" field.
func (m *ActionPlanHistoryMutation) SetBlocked(b bool) {
	m.blocked = &b
}

// Blocked returns the value of the "blocked" field in the mutation.
func (m *ActionPlanHistoryMutation) Blocked() (r bool, exists bool) {
	v := m.blocked
	if v == nil {
		return
	}
	return *v, true
}

// OldBlocked returns the old "blocked" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldBlocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlocked: %w", err)
	}
	return oldValue.Blocked, nil
}

// ResetBlocked resets all changes to the "blocked" field.
func (m *ActionPlanHistoryMutation) ResetBlocked() {
	m.blocked = nil
}

// SetBlockerReason sets the "blocker_reason" field.
func (m *ActionPlanHistoryMutation) SetBlockerReason(s string) {
	m.blocker_reason = &s
}

// BlockerReason returns the value of the "blocker_reason" field in the mutation.
func (m *ActionPlanHistoryMutation) BlockerReason() (r string, exists bool) {
	v := m.blocker_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockerReason returns the old "blocker_reason" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldBlockerReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockerReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockerReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockerReason: %w", err)
	}
	return oldValue.BlockerReason, nil
}

// ClearBlockerReason clears the value of the "blocker_reason" field.
func (m *ActionPlanHistoryMutation) ClearBlockerReason() {
	m.blocker_reason = nil
	m.clearedFields[actionplanhistory.FieldBlockerReason] = struct{}{}
}

// BlockerReasonCleared returns if the "blocker_reason" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) BlockerReasonCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldBlockerReason]
	return ok
}

// ResetBlockerReason resets all changes to the "blocker_reason" field.
func (m *ActionPlanHistoryMutation) ResetBlockerReason() {
	m.blocker_reason = nil
	delete(m.clearedFields, actionplanhistory.FieldBlockerReason)
}

// SetMetadata sets the "metadata" field.
func (m *ActionPlanHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ActionPlanHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ActionPlanHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[actionplanhistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ActionPlanHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, actionplanhistory.FieldMetadata)
}

// SetRawPayload sets the "raw_payload" field.
func (m *ActionPlanHistoryMutation) SetRawPayload(value map[string]interface{}) {
	m.raw_payload = &value
}

// RawPayload returns the value of the "raw_payload" field in the mutation.
func (m *ActionPlanHistoryMutation) RawPayload() (r map[string]interface{}, exists bool) {
	v := m.raw_payload
	if v == nil {
		return
	}
	return *v, true
}

// OldRawPayload returns the old "raw_payload" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldRawPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawPayload: %w", err)
	}
	return oldValue.RawPayload, nil
}

// ClearRawPayload clears the value of the "raw_payload" field.
func (m *ActionPlanHistoryMutation) ClearRawPayload() {
	m.raw_payload = nil
	m.clearedFields[actionplanhistory.FieldRawPayload] = struct{}{}
}

// RawPayloadCleared returns if the "raw_payload" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) RawPayloadCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldRawPayload]
	return ok
}

// ResetRawPayload resets all changes to the "raw_payload" field.
func (m *ActionPlanHistoryMutation) ResetRawPayload() {
	m.raw_payload = nil
	delete(m.clearedFields, actionplanhistory.FieldRawPayload)
}

// SetSource sets the "source" field.
func (m *ActionPlanHistoryMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ActionPlanHistoryMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *ActionPlanHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[actionplanhistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *ActionPlanHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, actionplanhistory.FieldSource)
}

// Where appends a list predicates to the ActionPlanHistoryMutation builder.
func (m *ActionPlanHistoryMutation) Where(ps ...predicate.ActionPlanHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActionPlanHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActionPlanHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActionPlanHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActionPlanHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActionPlanHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActionPlanHistory).
func (m *ActionPlanHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActionPlanHistoryMutation) Fields() []string {
	fields := make([]string, 0, 46)
	if m.history_time != nil {
		fields = append(fields, actionplanhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, actionplanhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, actionplanhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, actionplanhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, actionplanhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, actionplanhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, actionplanhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, actionplanhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, actionplanhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, actionplanhistory.FieldTags)
	}
	if m.revision != nil {
		fields = append(fields, actionplanhistory.FieldRevision)
	}
	if m.name != nil {
		fields = append(fields, actionplanhistory.FieldName)
	}
	if m.status != nil {
		fields = append(fields, actionplanhistory.FieldStatus)
	}
	if m.action_plan_type != nil {
		fields = append(fields, actionplanhistory.FieldActionPlanType)
	}
	if m.details != nil {
		fields = append(fields, actionplanhistory.FieldDetails)
	}
	if m.approval_required != nil {
		fields = append(fields, actionplanhistory.FieldApprovalRequired)
	}
	if m.review_due != nil {
		fields = append(fields, actionplanhistory.FieldReviewDue)
	}
	if m.review_frequency != nil {
		fields = append(fields, actionplanhistory.FieldReviewFrequency)
	}
	if m.approver_id != nil {
		fields = append(fields, actionplanhistory.FieldApproverID)
	}
	if m.delegate_id != nil {
		fields = append(fields, actionplanhistory.FieldDelegateID)
	}
	if m.summary != nil {
		fields = append(fields, actionplanhistory.FieldSummary)
	}
	if m.tag_suggestions != nil {
		fields = append(fields, actionplanhistory.FieldTagSuggestions)
	}
	if m.dismissed_tag_suggestions != nil {
		fields = append(fields, actionplanhistory.FieldDismissedTagSuggestions)
	}
	if m.control_suggestions != nil {
		fields = append(fields, actionplanhistory.FieldControlSuggestions)
	}
	if m.dismissed_control_suggestions != nil {
		fields = append(fields, actionplanhistory.FieldDismissedControlSuggestions)
	}
	if m.improvement_suggestions != nil {
		fields = append(fields, actionplanhistory.FieldImprovementSuggestions)
	}
	if m.dismissed_improvement_suggestions != nil {
		fields = append(fields, actionplanhistory.FieldDismissedImprovementSuggestions)
	}
	if m.url != nil {
		fields = append(fields, actionplanhistory.FieldURL)
	}
	if m.file_id != nil {
		fields = append(fields, actionplanhistory.FieldFileID)
	}
	if m.owner_id != nil {
		fields = append(fields, actionplanhistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, actionplanhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, actionplanhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, actionplanhistory.FieldSystemInternalID)
	}
	if m.action_plan_kind_name != nil {
		fields = append(fields, actionplanhistory.FieldActionPlanKindName)
	}
	if m.action_plan_kind_id != nil {
		fields = append(fields, actionplanhistory.FieldActionPlanKindID)
	}
	if m.title != nil {
		fields = append(fields, actionplanhistory.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, actionplanhistory.FieldDescription)
	}
	if m.due_date != nil {
		fields = append(fields, actionplanhistory.FieldDueDate)
	}
	if m.completed_at != nil {
		fields = append(fields, actionplanhistory.FieldCompletedAt)
	}
	if m.priority != nil {
		fields = append(fields, actionplanhistory.FieldPriority)
	}
	if m.requires_approval != nil {
		fields = append(fields, actionplanhistory.FieldRequiresApproval)
	}
	if m.blocked != nil {
		fields = append(fields, actionplanhistory.FieldBlocked)
	}
	if m.blocker_reason != nil {
		fields = append(fields, actionplanhistory.FieldBlockerReason)
	}
	if m.metadata != nil {
		fields = append(fields, actionplanhistory.FieldMetadata)
	}
	if m.raw_payload != nil {
		fields = append(fields, actionplanhistory.FieldRawPayload)
	}
	if m.source != nil {
		fields = append(fields, actionplanhistory.FieldSource)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActionPlanHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case actionplanhistory.FieldHistoryTime:
		return m.HistoryTime()
	case actionplanhistory.FieldRef:
		return m.Ref()
	case actionplanhistory.FieldOperation:
		return m.Operation()
	case actionplanhistory.FieldCreatedAt:
		return m.CreatedAt()
	case actionplanhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case actionplanhistory.FieldCreatedBy:
		return m.CreatedBy()
	case actionplanhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case actionplanhistory.FieldDeletedAt:
		return m.DeletedAt()
	case actionplanhistory.FieldDeletedBy:
		return m.DeletedBy()
	case actionplanhistory.FieldTags:
		return m.Tags()
	case actionplanhistory.FieldRevision:
		return m.Revision()
	case actionplanhistory.FieldName:
		return m.Name()
	case actionplanhistory.FieldStatus:
		return m.Status()
	case actionplanhistory.FieldActionPlanType:
		return m.ActionPlanType()
	case actionplanhistory.FieldDetails:
		return m.Details()
	case actionplanhistory.FieldApprovalRequired:
		return m.ApprovalRequired()
	case actionplanhistory.FieldReviewDue:
		return m.ReviewDue()
	case actionplanhistory.FieldReviewFrequency:
		return m.ReviewFrequency()
	case actionplanhistory.FieldApproverID:
		return m.ApproverID()
	case actionplanhistory.FieldDelegateID:
		return m.DelegateID()
	case actionplanhistory.FieldSummary:
		return m.Summary()
	case actionplanhistory.FieldTagSuggestions:
		return m.TagSuggestions()
	case actionplanhistory.FieldDismissedTagSuggestions:
		return m.DismissedTagSuggestions()
	case actionplanhistory.FieldControlSuggestions:
		return m.ControlSuggestions()
	case actionplanhistory.FieldDismissedControlSuggestions:
		return m.DismissedControlSuggestions()
	case actionplanhistory.FieldImprovementSuggestions:
		return m.ImprovementSuggestions()
	case actionplanhistory.FieldDismissedImprovementSuggestions:
		return m.DismissedImprovementSuggestions()
	case actionplanhistory.FieldURL:
		return m.URL()
	case actionplanhistory.FieldFileID:
		return m.FileID()
	case actionplanhistory.FieldOwnerID:
		return m.OwnerID()
	case actionplanhistory.FieldSystemOwned:
		return m.SystemOwned()
	case actionplanhistory.FieldInternalNotes:
		return m.InternalNotes()
	case actionplanhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case actionplanhistory.FieldActionPlanKindName:
		return m.ActionPlanKindName()
	case actionplanhistory.FieldActionPlanKindID:
		return m.ActionPlanKindID()
	case actionplanhistory.FieldTitle:
		return m.Title()
	case actionplanhistory.FieldDescription:
		return m.Description()
	case actionplanhistory.FieldDueDate:
		return m.DueDate()
	case actionplanhistory.FieldCompletedAt:
		return m.CompletedAt()
	case actionplanhistory.FieldPriority:
		return m.Priority()
	case actionplanhistory.FieldRequiresApproval:
		return m.RequiresApproval()
	case actionplanhistory.FieldBlocked:
		return m.Blocked()
	case actionplanhistory.FieldBlockerReason:
		return m.BlockerReason()
	case actionplanhistory.FieldMetadata:
		return m.Metadata()
	case actionplanhistory.FieldRawPayload:
		return m.RawPayload()
	case actionplanhistory.FieldSource:
		return m.Source()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActionPlanHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case actionplanhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case actionplanhistory.FieldRef:
		return m.OldRef(ctx)
	case actionplanhistory.FieldOperation:
		return m.OldOperation(ctx)
	case actionplanhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case actionplanhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case actionplanhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case actionplanhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case actionplanhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case actionplanhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case actionplanhistory.FieldTags:
		return m.OldTags(ctx)
	case actionplanhistory.FieldRevision:
		return m.OldRevision(ctx)
	case actionplanhistory.FieldName:
		return m.OldName(ctx)
	case actionplanhistory.FieldStatus:
		return m.OldStatus(ctx)
	case actionplanhistory.FieldActionPlanType:
		return m.OldActionPlanType(ctx)
	case actionplanhistory.FieldDetails:
		return m.OldDetails(ctx)
	case actionplanhistory.FieldApprovalRequired:
		return m.OldApprovalRequired(ctx)
	case actionplanhistory.FieldReviewDue:
		return m.OldReviewDue(ctx)
	case actionplanhistory.FieldReviewFrequency:
		return m.OldReviewFrequency(ctx)
	case actionplanhistory.FieldApproverID:
		return m.OldApproverID(ctx)
	case actionplanhistory.FieldDelegateID:
		return m.OldDelegateID(ctx)
	case actionplanhistory.FieldSummary:
		return m.OldSummary(ctx)
	case actionplanhistory.FieldTagSuggestions:
		return m.OldTagSuggestions(ctx)
	case actionplanhistory.FieldDismissedTagSuggestions:
		return m.OldDismissedTagSuggestions(ctx)
	case actionplanhistory.FieldControlSuggestions:
		return m.OldControlSuggestions(ctx)
	case actionplanhistory.FieldDismissedControlSuggestions:
		return m.OldDismissedControlSuggestions(ctx)
	case actionplanhistory.FieldImprovementSuggestions:
		return m.OldImprovementSuggestions(ctx)
	case actionplanhistory.FieldDismissedImprovementSuggestions:
		return m.OldDismissedImprovementSuggestions(ctx)
	case actionplanhistory.FieldURL:
		return m.OldURL(ctx)
	case actionplanhistory.FieldFileID:
		return m.OldFileID(ctx)
	case actionplanhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case actionplanhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case actionplanhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case actionplanhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case actionplanhistory.FieldActionPlanKindName:
		return m.OldActionPlanKindName(ctx)
	case actionplanhistory.FieldActionPlanKindID:
		return m.OldActionPlanKindID(ctx)
	case actionplanhistory.FieldTitle:
		return m.OldTitle(ctx)
	case actionplanhistory.FieldDescription:
		return m.OldDescription(ctx)
	case actionplanhistory.FieldDueDate:
		return m.OldDueDate(ctx)
	case actionplanhistory.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case actionplanhistory.FieldPriority:
		return m.OldPriority(ctx)
	case actionplanhistory.FieldRequiresApproval:
		return m.OldRequiresApproval(ctx)
	case actionplanhistory.FieldBlocked:
		return m.OldBlocked(ctx)
	case actionplanhistory.FieldBlockerReason:
		return m.OldBlockerReason(ctx)
	case actionplanhistory.FieldMetadata:
		return m.OldMetadata(ctx)
	case actionplanhistory.FieldRawPayload:
		return m.OldRawPayload(ctx)
	case actionplanhistory.FieldSource:
		return m.OldSource(ctx)
	}
	return nil, fmt.Errorf("unknown ActionPlanHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionPlanHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case actionplanhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case actionplanhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case actionplanhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case actionplanhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case actionplanhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case actionplanhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case actionplanhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case actionplanhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case actionplanhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case actionplanhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case actionplanhistory.FieldRevision:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case actionplanhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case actionplanhistory.FieldStatus:
		v, ok := value.(enums.DocumentStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case actionplanhistory.FieldActionPlanType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionPlanType(v)
		return nil
	case actionplanhistory.FieldDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case actionplanhistory.FieldApprovalRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalRequired(v)
		return nil
	case actionplanhistory.FieldReviewDue:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewDue(v)
		return nil
	case actionplanhistory.FieldReviewFrequency:
		v, ok := value.(enums.Frequency)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewFrequency(v)
		return nil
	case actionplanhistory.FieldApproverID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproverID(v)
		return nil
	case actionplanhistory.FieldDelegateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegateID(v)
		return nil
	case actionplanhistory.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case actionplanhistory.FieldTagSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagSuggestions(v)
		return nil
	case actionplanhistory.FieldDismissedTagSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDismissedTagSuggestions(v)
		return nil
	case actionplanhistory.FieldControlSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlSuggestions(v)
		return nil
	case actionplanhistory.FieldDismissedControlSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDismissedControlSuggestions(v)
		return nil
	case actionplanhistory.FieldImprovementSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImprovementSuggestions(v)
		return nil
	case actionplanhistory.FieldDismissedImprovementSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDismissedImprovementSuggestions(v)
		return nil
	case actionplanhistory.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case actionplanhistory.FieldFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case actionplanhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case actionplanhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case actionplanhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case actionplanhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case actionplanhistory.FieldActionPlanKindName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionPlanKindName(v)
		return nil
	case actionplanhistory.FieldActionPlanKindID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionPlanKindID(v)
		return nil
	case actionplanhistory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case actionplanhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case actionplanhistory.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case actionplanhistory.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case actionplanhistory.FieldPriority:
		v, ok := value.(enums.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case actionplanhistory.FieldRequiresApproval:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresApproval(v)
		return nil
	case actionplanhistory.FieldBlocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlocked(v)
		return nil
	case actionplanhistory.FieldBlockerReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockerReason(v)
		return nil
	case actionplanhistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case actionplanhistory.FieldRawPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawPayload(v)
		return nil
	case actionplanhistory.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	}
	return fmt.Errorf("unknown ActionPlanHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActionPlanHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActionPlanHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionPlanHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActionPlanHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActionPlanHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(actionplanhistory.FieldRef) {
		fields = append(fields, actionplanhistory.FieldRef)
	}
	if m.FieldCleared(actionplanhistory.FieldCreatedAt) {
		fields = append(fields, actionplanhistory.FieldCreatedAt)
	}
	if m.FieldCleared(actionplanhistory.FieldUpdatedAt) {
		fields = append(fields, actionplanhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(actionplanhistory.FieldCreatedBy) {
		fields = append(fields, actionplanhistory.FieldCreatedBy)
	}
	if m.FieldCleared(actionplanhistory.FieldUpdatedBy) {
		fields = append(fields, actionplanhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(actionplanhistory.FieldDeletedAt) {
		fields = append(fields, actionplanhistory.FieldDeletedAt)
	}
	if m.FieldCleared(actionplanhistory.FieldDeletedBy) {
		fields = append(fields, actionplanhistory.FieldDeletedBy)
	}
	if m.FieldCleared(actionplanhistory.FieldTags) {
		fields = append(fields, actionplanhistory.FieldTags)
	}
	if m.FieldCleared(actionplanhistory.FieldRevision) {
		fields = append(fields, actionplanhistory.FieldRevision)
	}
	if m.FieldCleared(actionplanhistory.FieldStatus) {
		fields = append(fields, actionplanhistory.FieldStatus)
	}
	if m.FieldCleared(actionplanhistory.FieldActionPlanType) {
		fields = append(fields, actionplanhistory.FieldActionPlanType)
	}
	if m.FieldCleared(actionplanhistory.FieldDetails) {
		fields = append(fields, actionplanhistory.FieldDetails)
	}
	if m.FieldCleared(actionplanhistory.FieldApprovalRequired) {
		fields = append(fields, actionplanhistory.FieldApprovalRequired)
	}
	if m.FieldCleared(actionplanhistory.FieldReviewDue) {
		fields = append(fields, actionplanhistory.FieldReviewDue)
	}
	if m.FieldCleared(actionplanhistory.FieldReviewFrequency) {
		fields = append(fields, actionplanhistory.FieldReviewFrequency)
	}
	if m.FieldCleared(actionplanhistory.FieldApproverID) {
		fields = append(fields, actionplanhistory.FieldApproverID)
	}
	if m.FieldCleared(actionplanhistory.FieldDelegateID) {
		fields = append(fields, actionplanhistory.FieldDelegateID)
	}
	if m.FieldCleared(actionplanhistory.FieldSummary) {
		fields = append(fields, actionplanhistory.FieldSummary)
	}
	if m.FieldCleared(actionplanhistory.FieldTagSuggestions) {
		fields = append(fields, actionplanhistory.FieldTagSuggestions)
	}
	if m.FieldCleared(actionplanhistory.FieldDismissedTagSuggestions) {
		fields = append(fields, actionplanhistory.FieldDismissedTagSuggestions)
	}
	if m.FieldCleared(actionplanhistory.FieldControlSuggestions) {
		fields = append(fields, actionplanhistory.FieldControlSuggestions)
	}
	if m.FieldCleared(actionplanhistory.FieldDismissedControlSuggestions) {
		fields = append(fields, actionplanhistory.FieldDismissedControlSuggestions)
	}
	if m.FieldCleared(actionplanhistory.FieldImprovementSuggestions) {
		fields = append(fields, actionplanhistory.FieldImprovementSuggestions)
	}
	if m.FieldCleared(actionplanhistory.FieldDismissedImprovementSuggestions) {
		fields = append(fields, actionplanhistory.FieldDismissedImprovementSuggestions)
	}
	if m.FieldCleared(actionplanhistory.FieldURL) {
		fields = append(fields, actionplanhistory.FieldURL)
	}
	if m.FieldCleared(actionplanhistory.FieldFileID) {
		fields = append(fields, actionplanhistory.FieldFileID)
	}
	if m.FieldCleared(actionplanhistory.FieldOwnerID) {
		fields = append(fields, actionplanhistory.FieldOwnerID)
	}
	if m.FieldCleared(actionplanhistory.FieldSystemOwned) {
		fields = append(fields, actionplanhistory.FieldSystemOwned)
	}
	if m.FieldCleared(actionplanhistory.FieldInternalNotes) {
		fields = append(fields, actionplanhistory.FieldInternalNotes)
	}
	if m.FieldCleared(actionplanhistory.FieldSystemInternalID) {
		fields = append(fields, actionplanhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(actionplanhistory.FieldActionPlanKindName) {
		fields = append(fields, actionplanhistory.FieldActionPlanKindName)
	}
	if m.FieldCleared(actionplanhistory.FieldActionPlanKindID) {
		fields = append(fields, actionplanhistory.FieldActionPlanKindID)
	}
	if m.FieldCleared(actionplanhistory.FieldDescription) {
		fields = append(fields, actionplanhistory.FieldDescription)
	}
	if m.FieldCleared(actionplanhistory.FieldDueDate) {
		fields = append(fields, actionplanhistory.FieldDueDate)
	}
	if m.FieldCleared(actionplanhistory.FieldCompletedAt) {
		fields = append(fields, actionplanhistory.FieldCompletedAt)
	}
	if m.FieldCleared(actionplanhistory.FieldPriority) {
		fields = append(fields, actionplanhistory.FieldPriority)
	}
	if m.FieldCleared(actionplanhistory.FieldBlockerReason) {
		fields = append(fields, actionplanhistory.FieldBlockerReason)
	}
	if m.FieldCleared(actionplanhistory.FieldMetadata) {
		fields = append(fields, actionplanhistory.FieldMetadata)
	}
	if m.FieldCleared(actionplanhistory.FieldRawPayload) {
		fields = append(fields, actionplanhistory.FieldRawPayload)
	}
	if m.FieldCleared(actionplanhistory.FieldSource) {
		fields = append(fields, actionplanhistory.FieldSource)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActionPlanHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActionPlanHistoryMutation) ClearField(name string) error {
	switch name {
	case actionplanhistory.FieldRef:
		m.ClearRef()
		return nil
	case actionplanhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case actionplanhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case actionplanhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case actionplanhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case actionplanhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case actionplanhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case actionplanhistory.FieldTags:
		m.ClearTags()
		return nil
	case actionplanhistory.FieldRevision:
		m.ClearRevision()
		return nil
	case actionplanhistory.FieldStatus:
		m.ClearStatus()
		return nil
	case actionplanhistory.FieldActionPlanType:
		m.ClearActionPlanType()
		return nil
	case actionplanhistory.FieldDetails:
		m.ClearDetails()
		return nil
	case actionplanhistory.FieldApprovalRequired:
		m.ClearApprovalRequired()
		return nil
	case actionplanhistory.FieldReviewDue:
		m.ClearReviewDue()
		return nil
	case actionplanhistory.FieldReviewFrequency:
		m.ClearReviewFrequency()
		return nil
	case actionplanhistory.FieldApproverID:
		m.ClearApproverID()
		return nil
	case actionplanhistory.FieldDelegateID:
		m.ClearDelegateID()
		return nil
	case actionplanhistory.FieldSummary:
		m.ClearSummary()
		return nil
	case actionplanhistory.FieldTagSuggestions:
		m.ClearTagSuggestions()
		return nil
	case actionplanhistory.FieldDismissedTagSuggestions:
		m.ClearDismissedTagSuggestions()
		return nil
	case actionplanhistory.FieldControlSuggestions:
		m.ClearControlSuggestions()
		return nil
	case actionplanhistory.FieldDismissedControlSuggestions:
		m.ClearDismissedControlSuggestions()
		return nil
	case actionplanhistory.FieldImprovementSuggestions:
		m.ClearImprovementSuggestions()
		return nil
	case actionplanhistory.FieldDismissedImprovementSuggestions:
		m.ClearDismissedImprovementSuggestions()
		return nil
	case actionplanhistory.FieldURL:
		m.ClearURL()
		return nil
	case actionplanhistory.FieldFileID:
		m.ClearFileID()
		return nil
	case actionplanhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case actionplanhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case actionplanhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case actionplanhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case actionplanhistory.FieldActionPlanKindName:
		m.ClearActionPlanKindName()
		return nil
	case actionplanhistory.FieldActionPlanKindID:
		m.ClearActionPlanKindID()
		return nil
	case actionplanhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case actionplanhistory.FieldDueDate:
		m.ClearDueDate()
		return nil
	case actionplanhistory.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case actionplanhistory.FieldPriority:
		m.ClearPriority()
		return nil
	case actionplanhistory.FieldBlockerReason:
		m.ClearBlockerReason()
		return nil
	case actionplanhistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	case actionplanhistory.FieldRawPayload:
		m.ClearRawPayload()
		return nil
	case actionplanhistory.FieldSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown ActionPlanHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActionPlanHistoryMutation) ResetField(name string) error {
	switch name {
	case actionplanhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case actionplanhistory.FieldRef:
		m.ResetRef()
		return nil
	case actionplanhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case actionplanhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case actionplanhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case actionplanhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case actionplanhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case actionplanhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case actionplanhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case actionplanhistory.FieldTags:
		m.ResetTags()
		return nil
	case actionplanhistory.FieldRevision:
		m.ResetRevision()
		return nil
	case actionplanhistory.FieldName:
		m.ResetName()
		return nil
	case actionplanhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case actionplanhistory.FieldActionPlanType:
		m.ResetActionPlanType()
		return nil
	case actionplanhistory.FieldDetails:
		m.ResetDetails()
		return nil
	case actionplanhistory.FieldApprovalRequired:
		m.ResetApprovalRequired()
		return nil
	case actionplanhistory.FieldReviewDue:
		m.ResetReviewDue()
		return nil
	case actionplanhistory.FieldReviewFrequency:
		m.ResetReviewFrequency()
		return nil
	case actionplanhistory.FieldApproverID:
		m.ResetApproverID()
		return nil
	case actionplanhistory.FieldDelegateID:
		m.ResetDelegateID()
		return nil
	case actionplanhistory.FieldSummary:
		m.ResetSummary()
		return nil
	case actionplanhistory.FieldTagSuggestions:
		m.ResetTagSuggestions()
		return nil
	case actionplanhistory.FieldDismissedTagSuggestions:
		m.ResetDismissedTagSuggestions()
		return nil
	case actionplanhistory.FieldControlSuggestions:
		m.ResetControlSuggestions()
		return nil
	case actionplanhistory.FieldDismissedControlSuggestions:
		m.ResetDismissedControlSuggestions()
		return nil
	case actionplanhistory.FieldImprovementSuggestions:
		m.ResetImprovementSuggestions()
		return nil
	case actionplanhistory.FieldDismissedImprovementSuggestions:
		m.ResetDismissedImprovementSuggestions()
		return nil
	case actionplanhistory.FieldURL:
		m.ResetURL()
		return nil
	case actionplanhistory.FieldFileID:
		m.ResetFileID()
		return nil
	case actionplanhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case actionplanhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case actionplanhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case actionplanhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case actionplanhistory.FieldActionPlanKindName:
		m.ResetActionPlanKindName()
		return nil
	case actionplanhistory.FieldActionPlanKindID:
		m.ResetActionPlanKindID()
		return nil
	case actionplanhistory.FieldTitle:
		m.ResetTitle()
		return nil
	case actionplanhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case actionplanhistory.FieldDueDate:
		m.ResetDueDate()
		return nil
	case actionplanhistory.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case actionplanhistory.FieldPriority:
		m.ResetPriority()
		return nil
	case actionplanhistory.FieldRequiresApproval:
		m.ResetRequiresApproval()
		return nil
	case actionplanhistory.FieldBlocked:
		m.ResetBlocked()
		return nil
	case actionplanhistory.FieldBlockerReason:
		m.ResetBlockerReason()
		return nil
	case actionplanhistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	case actionplanhistory.FieldRawPayload:
		m.ResetRawPayload()
		return nil
	case actionplanhistory.FieldSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown ActionPlanHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActionPlanHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActionPlanHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActionPlanHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActionPlanHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActionPlanHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActionPlanHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActionPlanHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ActionPlanHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActionPlanHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ActionPlanHistory edge %s", name)
}

// AssessmentHistoryMutation represents an operation that mutates the AssessmentHistory nodes in the graph.
type AssessmentHistoryMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	history_time             *time.Time
	ref                      *string
	operation                *history.OpType
	created_at               *time.Time
	updated_at               *time.Time
	created_by               *string
	updated_by               *string
	deleted_at               *time.Time
	deleted_by               *string
	tags                     *[]string
	appendtags               []string
	owner_id                 *string
	name                     *string
	assessment_type          *enums.AssessmentType
	template_id              *string
	jsonconfig               *map[string]interface{}
	uischema                 *map[string]interface{}
	response_due_duration    *int64
	addresponse_due_duration *int64
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*AssessmentHistory, error)
	predicates               []predicate.AssessmentHistory
}

var _ ent.Mutation = (*AssessmentHistoryMutation)(nil)

// assessmenthistoryOption allows management of the mutation configuration using functional options.
type assessmenthistoryOption func(*AssessmentHistoryMutation)

// newAssessmentHistoryMutation creates new mutation for the AssessmentHistory entity.
func newAssessmentHistoryMutation(c config, op Op, opts ...assessmenthistoryOption) *AssessmentHistoryMutation {
	m := &AssessmentHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeAssessmentHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssessmentHistoryID sets the ID field of the mutation.
func withAssessmentHistoryID(id string) assessmenthistoryOption {
	return func(m *AssessmentHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *AssessmentHistory
		)
		m.oldValue = func(ctx context.Context) (*AssessmentHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssessmentHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssessmentHistory sets the old AssessmentHistory of the mutation.
func withAssessmentHistory(node *AssessmentHistory) assessmenthistoryOption {
	return func(m *AssessmentHistoryMutation) {
		m.oldValue = func(context.Context) (*AssessmentHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssessmentHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssessmentHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AssessmentHistory entities.
func (m *AssessmentHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssessmentHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssessmentHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssessmentHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *AssessmentHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *AssessmentHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *AssessmentHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *AssessmentHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *AssessmentHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *AssessmentHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[assessmenthistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *AssessmentHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[assessmenthistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *AssessmentHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, assessmenthistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *AssessmentHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *AssessmentHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *AssessmentHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AssessmentHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssessmentHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AssessmentHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[assessmenthistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AssessmentHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[assessmenthistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssessmentHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, assessmenthistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssessmentHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssessmentHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AssessmentHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[assessmenthistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AssessmentHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[assessmenthistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssessmentHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, assessmenthistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *AssessmentHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AssessmentHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AssessmentHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[assessmenthistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AssessmentHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[assessmenthistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AssessmentHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, assessmenthistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AssessmentHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AssessmentHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AssessmentHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[assessmenthistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AssessmentHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[assessmenthistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AssessmentHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, assessmenthistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AssessmentHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AssessmentHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AssessmentHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[assessmenthistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AssessmentHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[assessmenthistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AssessmentHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, assessmenthistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *AssessmentHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *AssessmentHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *AssessmentHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[assessmenthistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *AssessmentHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[assessmenthistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *AssessmentHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, assessmenthistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *AssessmentHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *AssessmentHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *AssessmentHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *AssessmentHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *AssessmentHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[assessmenthistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *AssessmentHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[assessmenthistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *AssessmentHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, assessmenthistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *AssessmentHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *AssessmentHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *AssessmentHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[assessmenthistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *AssessmentHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[assessmenthistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *AssessmentHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, assessmenthistory.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *AssessmentHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AssessmentHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AssessmentHistoryMutation) ResetName() {
	m.name = nil
}

// SetAssessmentType sets the "assessment_type" field.
func (m *AssessmentHistoryMutation) SetAssessmentType(et enums.AssessmentType) {
	m.assessment_type = &et
}

// AssessmentType returns the value of the "assessment_type" field in the mutation.
func (m *AssessmentHistoryMutation) AssessmentType() (r enums.AssessmentType, exists bool) {
	v := m.assessment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAssessmentType returns the old "assessment_type" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldAssessmentType(ctx context.Context) (v enums.AssessmentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssessmentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssessmentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssessmentType: %w", err)
	}
	return oldValue.AssessmentType, nil
}

// ResetAssessmentType resets all changes to the "assessment_type" field.
func (m *AssessmentHistoryMutation) ResetAssessmentType() {
	m.assessment_type = nil
}

// SetTemplateID sets the "template_id" field.
func (m *AssessmentHistoryMutation) SetTemplateID(s string) {
	m.template_id = &s
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *AssessmentHistoryMutation) TemplateID() (r string, exists bool) {
	v := m.template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ClearTemplateID clears the value of the "template_id" field.
func (m *AssessmentHistoryMutation) ClearTemplateID() {
	m.template_id = nil
	m.clearedFields[assessmenthistory.FieldTemplateID] = struct{}{}
}

// TemplateIDCleared returns if the "template_id" field was cleared in this mutation.
func (m *AssessmentHistoryMutation) TemplateIDCleared() bool {
	_, ok := m.clearedFields[assessmenthistory.FieldTemplateID]
	return ok
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *AssessmentHistoryMutation) ResetTemplateID() {
	m.template_id = nil
	delete(m.clearedFields, assessmenthistory.FieldTemplateID)
}

// SetJsonconfig sets the "jsonconfig" field.
func (m *AssessmentHistoryMutation) SetJsonconfig(value map[string]interface{}) {
	m.jsonconfig = &value
}

// Jsonconfig returns the value of the "jsonconfig" field in the mutation.
func (m *AssessmentHistoryMutation) Jsonconfig() (r map[string]interface{}, exists bool) {
	v := m.jsonconfig
	if v == nil {
		return
	}
	return *v, true
}

// OldJsonconfig returns the old "jsonconfig" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldJsonconfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJsonconfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJsonconfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJsonconfig: %w", err)
	}
	return oldValue.Jsonconfig, nil
}

// ClearJsonconfig clears the value of the "jsonconfig" field.
func (m *AssessmentHistoryMutation) ClearJsonconfig() {
	m.jsonconfig = nil
	m.clearedFields[assessmenthistory.FieldJsonconfig] = struct{}{}
}

// JsonconfigCleared returns if the "jsonconfig" field was cleared in this mutation.
func (m *AssessmentHistoryMutation) JsonconfigCleared() bool {
	_, ok := m.clearedFields[assessmenthistory.FieldJsonconfig]
	return ok
}

// ResetJsonconfig resets all changes to the "jsonconfig" field.
func (m *AssessmentHistoryMutation) ResetJsonconfig() {
	m.jsonconfig = nil
	delete(m.clearedFields, assessmenthistory.FieldJsonconfig)
}

// SetUischema sets the "uischema" field.
func (m *AssessmentHistoryMutation) SetUischema(value map[string]interface{}) {
	m.uischema = &value
}

// Uischema returns the value of the "uischema" field in the mutation.
func (m *AssessmentHistoryMutation) Uischema() (r map[string]interface{}, exists bool) {
	v := m.uischema
	if v == nil {
		return
	}
	return *v, true
}

// OldUischema returns the old "uischema" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldUischema(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUischema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUischema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUischema: %w", err)
	}
	return oldValue.Uischema, nil
}

// ClearUischema clears the value of the "uischema" field.
func (m *AssessmentHistoryMutation) ClearUischema() {
	m.uischema = nil
	m.clearedFields[assessmenthistory.FieldUischema] = struct{}{}
}

// UischemaCleared returns if the "uischema" field was cleared in this mutation.
func (m *AssessmentHistoryMutation) UischemaCleared() bool {
	_, ok := m.clearedFields[assessmenthistory.FieldUischema]
	return ok
}

// ResetUischema resets all changes to the "uischema" field.
func (m *AssessmentHistoryMutation) ResetUischema() {
	m.uischema = nil
	delete(m.clearedFields, assessmenthistory.FieldUischema)
}

// SetResponseDueDuration sets the "response_due_duration" field.
func (m *AssessmentHistoryMutation) SetResponseDueDuration(i int64) {
	m.response_due_duration = &i
	m.addresponse_due_duration = nil
}

// ResponseDueDuration returns the value of the "response_due_duration" field in the mutation.
func (m *AssessmentHistoryMutation) ResponseDueDuration() (r int64, exists bool) {
	v := m.response_due_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseDueDuration returns the old "response_due_duration" field's value of the AssessmentHistory entity.
// If the AssessmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentHistoryMutation) OldResponseDueDuration(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseDueDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseDueDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseDueDuration: %w", err)
	}
	return oldValue.ResponseDueDuration, nil
}

// AddResponseDueDuration adds i to the "response_due_duration" field.
func (m *AssessmentHistoryMutation) AddResponseDueDuration(i int64) {
	if m.addresponse_due_duration != nil {
		*m.addresponse_due_duration += i
	} else {
		m.addresponse_due_duration = &i
	}
}

// AddedResponseDueDuration returns the value that was added to the "response_due_duration" field in this mutation.
func (m *AssessmentHistoryMutation) AddedResponseDueDuration() (r int64, exists bool) {
	v := m.addresponse_due_duration
	if v == nil {
		return
	}
	return *v, true
}

// ClearResponseDueDuration clears the value of the "response_due_duration" field.
func (m *AssessmentHistoryMutation) ClearResponseDueDuration() {
	m.response_due_duration = nil
	m.addresponse_due_duration = nil
	m.clearedFields[assessmenthistory.FieldResponseDueDuration] = struct{}{}
}

// ResponseDueDurationCleared returns if the "response_due_duration" field was cleared in this mutation.
func (m *AssessmentHistoryMutation) ResponseDueDurationCleared() bool {
	_, ok := m.clearedFields[assessmenthistory.FieldResponseDueDuration]
	return ok
}

// ResetResponseDueDuration resets all changes to the "response_due_duration" field.
func (m *AssessmentHistoryMutation) ResetResponseDueDuration() {
	m.response_due_duration = nil
	m.addresponse_due_duration = nil
	delete(m.clearedFields, assessmenthistory.FieldResponseDueDuration)
}

// Where appends a list predicates to the AssessmentHistoryMutation builder.
func (m *AssessmentHistoryMutation) Where(ps ...predicate.AssessmentHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssessmentHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssessmentHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AssessmentHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssessmentHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssessmentHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AssessmentHistory).
func (m *AssessmentHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssessmentHistoryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.history_time != nil {
		fields = append(fields, assessmenthistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, assessmenthistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, assessmenthistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, assessmenthistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, assessmenthistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, assessmenthistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, assessmenthistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, assessmenthistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, assessmenthistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, assessmenthistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, assessmenthistory.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, assessmenthistory.FieldName)
	}
	if m.assessment_type != nil {
		fields = append(fields, assessmenthistory.FieldAssessmentType)
	}
	if m.template_id != nil {
		fields = append(fields, assessmenthistory.FieldTemplateID)
	}
	if m.jsonconfig != nil {
		fields = append(fields, assessmenthistory.FieldJsonconfig)
	}
	if m.uischema != nil {
		fields = append(fields, assessmenthistory.FieldUischema)
	}
	if m.response_due_duration != nil {
		fields = append(fields, assessmenthistory.FieldResponseDueDuration)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssessmentHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assessmenthistory.FieldHistoryTime:
		return m.HistoryTime()
	case assessmenthistory.FieldRef:
		return m.Ref()
	case assessmenthistory.FieldOperation:
		return m.Operation()
	case assessmenthistory.FieldCreatedAt:
		return m.CreatedAt()
	case assessmenthistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case assessmenthistory.FieldCreatedBy:
		return m.CreatedBy()
	case assessmenthistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case assessmenthistory.FieldDeletedAt:
		return m.DeletedAt()
	case assessmenthistory.FieldDeletedBy:
		return m.DeletedBy()
	case assessmenthistory.FieldTags:
		return m.Tags()
	case assessmenthistory.FieldOwnerID:
		return m.OwnerID()
	case assessmenthistory.FieldName:
		return m.Name()
	case assessmenthistory.FieldAssessmentType:
		return m.AssessmentType()
	case assessmenthistory.FieldTemplateID:
		return m.TemplateID()
	case assessmenthistory.FieldJsonconfig:
		return m.Jsonconfig()
	case assessmenthistory.FieldUischema:
		return m.Uischema()
	case assessmenthistory.FieldResponseDueDuration:
		return m.ResponseDueDuration()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssessmentHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assessmenthistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case assessmenthistory.FieldRef:
		return m.OldRef(ctx)
	case assessmenthistory.FieldOperation:
		return m.OldOperation(ctx)
	case assessmenthistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case assessmenthistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case assessmenthistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case assessmenthistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case assessmenthistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case assessmenthistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case assessmenthistory.FieldTags:
		return m.OldTags(ctx)
	case assessmenthistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case assessmenthistory.FieldName:
		return m.OldName(ctx)
	case assessmenthistory.FieldAssessmentType:
		return m.OldAssessmentType(ctx)
	case assessmenthistory.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case assessmenthistory.FieldJsonconfig:
		return m.OldJsonconfig(ctx)
	case assessmenthistory.FieldUischema:
		return m.OldUischema(ctx)
	case assessmenthistory.FieldResponseDueDuration:
		return m.OldResponseDueDuration(ctx)
	}
	return nil, fmt.Errorf("unknown AssessmentHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssessmentHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assessmenthistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case assessmenthistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case assessmenthistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case assessmenthistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case assessmenthistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case assessmenthistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case assessmenthistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case assessmenthistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case assessmenthistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case assessmenthistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case assessmenthistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case assessmenthistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case assessmenthistory.FieldAssessmentType:
		v, ok := value.(enums.AssessmentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssessmentType(v)
		return nil
	case assessmenthistory.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case assessmenthistory.FieldJsonconfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJsonconfig(v)
		return nil
	case assessmenthistory.FieldUischema:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUischema(v)
		return nil
	case assessmenthistory.FieldResponseDueDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseDueDuration(v)
		return nil
	}
	return fmt.Errorf("unknown AssessmentHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssessmentHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addresponse_due_duration != nil {
		fields = append(fields, assessmenthistory.FieldResponseDueDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssessmentHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case assessmenthistory.FieldResponseDueDuration:
		return m.AddedResponseDueDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssessmentHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case assessmenthistory.FieldResponseDueDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResponseDueDuration(v)
		return nil
	}
	return fmt.Errorf("unknown AssessmentHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssessmentHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assessmenthistory.FieldRef) {
		fields = append(fields, assessmenthistory.FieldRef)
	}
	if m.FieldCleared(assessmenthistory.FieldCreatedAt) {
		fields = append(fields, assessmenthistory.FieldCreatedAt)
	}
	if m.FieldCleared(assessmenthistory.FieldUpdatedAt) {
		fields = append(fields, assessmenthistory.FieldUpdatedAt)
	}
	if m.FieldCleared(assessmenthistory.FieldCreatedBy) {
		fields = append(fields, assessmenthistory.FieldCreatedBy)
	}
	if m.FieldCleared(assessmenthistory.FieldUpdatedBy) {
		fields = append(fields, assessmenthistory.FieldUpdatedBy)
	}
	if m.FieldCleared(assessmenthistory.FieldDeletedAt) {
		fields = append(fields, assessmenthistory.FieldDeletedAt)
	}
	if m.FieldCleared(assessmenthistory.FieldDeletedBy) {
		fields = append(fields, assessmenthistory.FieldDeletedBy)
	}
	if m.FieldCleared(assessmenthistory.FieldTags) {
		fields = append(fields, assessmenthistory.FieldTags)
	}
	if m.FieldCleared(assessmenthistory.FieldOwnerID) {
		fields = append(fields, assessmenthistory.FieldOwnerID)
	}
	if m.FieldCleared(assessmenthistory.FieldTemplateID) {
		fields = append(fields, assessmenthistory.FieldTemplateID)
	}
	if m.FieldCleared(assessmenthistory.FieldJsonconfig) {
		fields = append(fields, assessmenthistory.FieldJsonconfig)
	}
	if m.FieldCleared(assessmenthistory.FieldUischema) {
		fields = append(fields, assessmenthistory.FieldUischema)
	}
	if m.FieldCleared(assessmenthistory.FieldResponseDueDuration) {
		fields = append(fields, assessmenthistory.FieldResponseDueDuration)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssessmentHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssessmentHistoryMutation) ClearField(name string) error {
	switch name {
	case assessmenthistory.FieldRef:
		m.ClearRef()
		return nil
	case assessmenthistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case assessmenthistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case assessmenthistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case assessmenthistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case assessmenthistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case assessmenthistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case assessmenthistory.FieldTags:
		m.ClearTags()
		return nil
	case assessmenthistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case assessmenthistory.FieldTemplateID:
		m.ClearTemplateID()
		return nil
	case assessmenthistory.FieldJsonconfig:
		m.ClearJsonconfig()
		return nil
	case assessmenthistory.FieldUischema:
		m.ClearUischema()
		return nil
	case assessmenthistory.FieldResponseDueDuration:
		m.ClearResponseDueDuration()
		return nil
	}
	return fmt.Errorf("unknown AssessmentHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssessmentHistoryMutation) ResetField(name string) error {
	switch name {
	case assessmenthistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case assessmenthistory.FieldRef:
		m.ResetRef()
		return nil
	case assessmenthistory.FieldOperation:
		m.ResetOperation()
		return nil
	case assessmenthistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case assessmenthistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case assessmenthistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case assessmenthistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case assessmenthistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case assessmenthistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case assessmenthistory.FieldTags:
		m.ResetTags()
		return nil
	case assessmenthistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case assessmenthistory.FieldName:
		m.ResetName()
		return nil
	case assessmenthistory.FieldAssessmentType:
		m.ResetAssessmentType()
		return nil
	case assessmenthistory.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case assessmenthistory.FieldJsonconfig:
		m.ResetJsonconfig()
		return nil
	case assessmenthistory.FieldUischema:
		m.ResetUischema()
		return nil
	case assessmenthistory.FieldResponseDueDuration:
		m.ResetResponseDueDuration()
		return nil
	}
	return fmt.Errorf("unknown AssessmentHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssessmentHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssessmentHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssessmentHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssessmentHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssessmentHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssessmentHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssessmentHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AssessmentHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssessmentHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AssessmentHistory edge %s", name)
}

// AssessmentResponseHistoryMutation represents an operation that mutates the AssessmentResponseHistory nodes in the graph.
type AssessmentResponseHistoryMutation struct {
	config
	op               Op
	typ              string
	id               *string
	history_time     *time.Time
	ref              *string
	operation        *history.OpType
	created_at       *time.Time
	updated_at       *time.Time
	created_by       *string
	updated_by       *string
	deleted_at       *time.Time
	deleted_by       *string
	owner_id         *string
	assessment_id    *string
	email            *string
	send_attempts    *int
	addsend_attempts *int
	status           *enums.AssessmentResponseStatus
	assigned_at      *time.Time
	started_at       *time.Time
	completed_at     *time.Time
	due_date         *time.Time
	document_data_id *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*AssessmentResponseHistory, error)
	predicates       []predicate.AssessmentResponseHistory
}

var _ ent.Mutation = (*AssessmentResponseHistoryMutation)(nil)

// assessmentresponsehistoryOption allows management of the mutation configuration using functional options.
type assessmentresponsehistoryOption func(*AssessmentResponseHistoryMutation)

// newAssessmentResponseHistoryMutation creates new mutation for the AssessmentResponseHistory entity.
func newAssessmentResponseHistoryMutation(c config, op Op, opts ...assessmentresponsehistoryOption) *AssessmentResponseHistoryMutation {
	m := &AssessmentResponseHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeAssessmentResponseHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssessmentResponseHistoryID sets the ID field of the mutation.
func withAssessmentResponseHistoryID(id string) assessmentresponsehistoryOption {
	return func(m *AssessmentResponseHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *AssessmentResponseHistory
		)
		m.oldValue = func(ctx context.Context) (*AssessmentResponseHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssessmentResponseHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssessmentResponseHistory sets the old AssessmentResponseHistory of the mutation.
func withAssessmentResponseHistory(node *AssessmentResponseHistory) assessmentresponsehistoryOption {
	return func(m *AssessmentResponseHistoryMutation) {
		m.oldValue = func(context.Context) (*AssessmentResponseHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssessmentResponseHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssessmentResponseHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AssessmentResponseHistory entities.
func (m *AssessmentResponseHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssessmentResponseHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssessmentResponseHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssessmentResponseHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *AssessmentResponseHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *AssessmentResponseHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *AssessmentResponseHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *AssessmentResponseHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *AssessmentResponseHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *AssessmentResponseHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[assessmentresponsehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *AssessmentResponseHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[assessmentresponsehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *AssessmentResponseHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, assessmentresponsehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *AssessmentResponseHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *AssessmentResponseHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *AssessmentResponseHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AssessmentResponseHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssessmentResponseHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AssessmentResponseHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[assessmentresponsehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AssessmentResponseHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[assessmentresponsehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssessmentResponseHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, assessmentresponsehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssessmentResponseHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssessmentResponseHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AssessmentResponseHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[assessmentresponsehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AssessmentResponseHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[assessmentresponsehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssessmentResponseHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, assessmentresponsehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *AssessmentResponseHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AssessmentResponseHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AssessmentResponseHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[assessmentresponsehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AssessmentResponseHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[assessmentresponsehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AssessmentResponseHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, assessmentresponsehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AssessmentResponseHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AssessmentResponseHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AssessmentResponseHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[assessmentresponsehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AssessmentResponseHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[assessmentresponsehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AssessmentResponseHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, assessmentresponsehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AssessmentResponseHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AssessmentResponseHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AssessmentResponseHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[assessmentresponsehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AssessmentResponseHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[assessmentresponsehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AssessmentResponseHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, assessmentresponsehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *AssessmentResponseHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *AssessmentResponseHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *AssessmentResponseHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[assessmentresponsehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *AssessmentResponseHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[assessmentresponsehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *AssessmentResponseHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, assessmentresponsehistory.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *AssessmentResponseHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *AssessmentResponseHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *AssessmentResponseHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[assessmentresponsehistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *AssessmentResponseHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[assessmentresponsehistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *AssessmentResponseHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, assessmentresponsehistory.FieldOwnerID)
}

// SetAssessmentID sets the "assessment_id" field.
func (m *AssessmentResponseHistoryMutation) SetAssessmentID(s string) {
	m.assessment_id = &s
}

// AssessmentID returns the value of the "assessment_id" field in the mutation.
func (m *AssessmentResponseHistoryMutation) AssessmentID() (r string, exists bool) {
	v := m.assessment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssessmentID returns the old "assessment_id" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldAssessmentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssessmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssessmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssessmentID: %w", err)
	}
	return oldValue.AssessmentID, nil
}

// ResetAssessmentID resets all changes to the "assessment_id" field.
func (m *AssessmentResponseHistoryMutation) ResetAssessmentID() {
	m.assessment_id = nil
}

// SetEmail sets the "email" field.
func (m *AssessmentResponseHistoryMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AssessmentResponseHistoryMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AssessmentResponseHistoryMutation) ResetEmail() {
	m.email = nil
}

// SetSendAttempts sets the "send_attempts" field.
func (m *AssessmentResponseHistoryMutation) SetSendAttempts(i int) {
	m.send_attempts = &i
	m.addsend_attempts = nil
}

// SendAttempts returns the value of the "send_attempts" field in the mutation.
func (m *AssessmentResponseHistoryMutation) SendAttempts() (r int, exists bool) {
	v := m.send_attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldSendAttempts returns the old "send_attempts" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldSendAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSendAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSendAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendAttempts: %w", err)
	}
	return oldValue.SendAttempts, nil
}

// AddSendAttempts adds i to the "send_attempts" field.
func (m *AssessmentResponseHistoryMutation) AddSendAttempts(i int) {
	if m.addsend_attempts != nil {
		*m.addsend_attempts += i
	} else {
		m.addsend_attempts = &i
	}
}

// AddedSendAttempts returns the value that was added to the "send_attempts" field in this mutation.
func (m *AssessmentResponseHistoryMutation) AddedSendAttempts() (r int, exists bool) {
	v := m.addsend_attempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetSendAttempts resets all changes to the "send_attempts" field.
func (m *AssessmentResponseHistoryMutation) ResetSendAttempts() {
	m.send_attempts = nil
	m.addsend_attempts = nil
}

// SetStatus sets the "status" field.
func (m *AssessmentResponseHistoryMutation) SetStatus(ers enums.AssessmentResponseStatus) {
	m.status = &ers
}

// Status returns the value of the "status" field in the mutation.
func (m *AssessmentResponseHistoryMutation) Status() (r enums.AssessmentResponseStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldStatus(ctx context.Context) (v enums.AssessmentResponseStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AssessmentResponseHistoryMutation) ResetStatus() {
	m.status = nil
}

// SetAssignedAt sets the "assigned_at" field.
func (m *AssessmentResponseHistoryMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *AssessmentResponseHistoryMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldAssignedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *AssessmentResponseHistoryMutation) ResetAssignedAt() {
	m.assigned_at = nil
}

// SetStartedAt sets the "started_at" field.
func (m *AssessmentResponseHistoryMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *AssessmentResponseHistoryMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *AssessmentResponseHistoryMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *AssessmentResponseHistoryMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *AssessmentResponseHistoryMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *AssessmentResponseHistoryMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[assessmentresponsehistory.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *AssessmentResponseHistoryMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[assessmentresponsehistory.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *AssessmentResponseHistoryMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, assessmentresponsehistory.FieldCompletedAt)
}

// SetDueDate sets the "due_date" field.
func (m *AssessmentResponseHistoryMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *AssessmentResponseHistoryMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of the "due_date" field.
func (m *AssessmentResponseHistoryMutation) ClearDueDate() {
	m.due_date = nil
	m.clearedFields[assessmentresponsehistory.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "due_date" field was cleared in this mutation.
func (m *AssessmentResponseHistoryMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[assessmentresponsehistory.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *AssessmentResponseHistoryMutation) ResetDueDate() {
	m.due_date = nil
	delete(m.clearedFields, assessmentresponsehistory.FieldDueDate)
}

// SetDocumentDataID sets the "document_data_id" field.
func (m *AssessmentResponseHistoryMutation) SetDocumentDataID(s string) {
	m.document_data_id = &s
}

// DocumentDataID returns the value of the "document_data_id" field in the mutation.
func (m *AssessmentResponseHistoryMutation) DocumentDataID() (r string, exists bool) {
	v := m.document_data_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentDataID returns the old "document_data_id" field's value of the AssessmentResponseHistory entity.
// If the AssessmentResponseHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssessmentResponseHistoryMutation) OldDocumentDataID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentDataID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentDataID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentDataID: %w", err)
	}
	return oldValue.DocumentDataID, nil
}

// ClearDocumentDataID clears the value of the "document_data_id" field.
func (m *AssessmentResponseHistoryMutation) ClearDocumentDataID() {
	m.document_data_id = nil
	m.clearedFields[assessmentresponsehistory.FieldDocumentDataID] = struct{}{}
}

// DocumentDataIDCleared returns if the "document_data_id" field was cleared in this mutation.
func (m *AssessmentResponseHistoryMutation) DocumentDataIDCleared() bool {
	_, ok := m.clearedFields[assessmentresponsehistory.FieldDocumentDataID]
	return ok
}

// ResetDocumentDataID resets all changes to the "document_data_id" field.
func (m *AssessmentResponseHistoryMutation) ResetDocumentDataID() {
	m.document_data_id = nil
	delete(m.clearedFields, assessmentresponsehistory.FieldDocumentDataID)
}

// Where appends a list predicates to the AssessmentResponseHistoryMutation builder.
func (m *AssessmentResponseHistoryMutation) Where(ps ...predicate.AssessmentResponseHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssessmentResponseHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssessmentResponseHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AssessmentResponseHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssessmentResponseHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssessmentResponseHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AssessmentResponseHistory).
func (m *AssessmentResponseHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssessmentResponseHistoryMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.history_time != nil {
		fields = append(fields, assessmentresponsehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, assessmentresponsehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, assessmentresponsehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, assessmentresponsehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, assessmentresponsehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, assessmentresponsehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, assessmentresponsehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, assessmentresponsehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, assessmentresponsehistory.FieldDeletedBy)
	}
	if m.owner_id != nil {
		fields = append(fields, assessmentresponsehistory.FieldOwnerID)
	}
	if m.assessment_id != nil {
		fields = append(fields, assessmentresponsehistory.FieldAssessmentID)
	}
	if m.email != nil {
		fields = append(fields, assessmentresponsehistory.FieldEmail)
	}
	if m.send_attempts != nil {
		fields = append(fields, assessmentresponsehistory.FieldSendAttempts)
	}
	if m.status != nil {
		fields = append(fields, assessmentresponsehistory.FieldStatus)
	}
	if m.assigned_at != nil {
		fields = append(fields, assessmentresponsehistory.FieldAssignedAt)
	}
	if m.started_at != nil {
		fields = append(fields, assessmentresponsehistory.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, assessmentresponsehistory.FieldCompletedAt)
	}
	if m.due_date != nil {
		fields = append(fields, assessmentresponsehistory.FieldDueDate)
	}
	if m.document_data_id != nil {
		fields = append(fields, assessmentresponsehistory.FieldDocumentDataID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssessmentResponseHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assessmentresponsehistory.FieldHistoryTime:
		return m.HistoryTime()
	case assessmentresponsehistory.FieldRef:
		return m.Ref()
	case assessmentresponsehistory.FieldOperation:
		return m.Operation()
	case assessmentresponsehistory.FieldCreatedAt:
		return m.CreatedAt()
	case assessmentresponsehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case assessmentresponsehistory.FieldCreatedBy:
		return m.CreatedBy()
	case assessmentresponsehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case assessmentresponsehistory.FieldDeletedAt:
		return m.DeletedAt()
	case assessmentresponsehistory.FieldDeletedBy:
		return m.DeletedBy()
	case assessmentresponsehistory.FieldOwnerID:
		return m.OwnerID()
	case assessmentresponsehistory.FieldAssessmentID:
		return m.AssessmentID()
	case assessmentresponsehistory.FieldEmail:
		return m.Email()
	case assessmentresponsehistory.FieldSendAttempts:
		return m.SendAttempts()
	case assessmentresponsehistory.FieldStatus:
		return m.Status()
	case assessmentresponsehistory.FieldAssignedAt:
		return m.AssignedAt()
	case assessmentresponsehistory.FieldStartedAt:
		return m.StartedAt()
	case assessmentresponsehistory.FieldCompletedAt:
		return m.CompletedAt()
	case assessmentresponsehistory.FieldDueDate:
		return m.DueDate()
	case assessmentresponsehistory.FieldDocumentDataID:
		return m.DocumentDataID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssessmentResponseHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assessmentresponsehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case assessmentresponsehistory.FieldRef:
		return m.OldRef(ctx)
	case assessmentresponsehistory.FieldOperation:
		return m.OldOperation(ctx)
	case assessmentresponsehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case assessmentresponsehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case assessmentresponsehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case assessmentresponsehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case assessmentresponsehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case assessmentresponsehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case assessmentresponsehistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case assessmentresponsehistory.FieldAssessmentID:
		return m.OldAssessmentID(ctx)
	case assessmentresponsehistory.FieldEmail:
		return m.OldEmail(ctx)
	case assessmentresponsehistory.FieldSendAttempts:
		return m.OldSendAttempts(ctx)
	case assessmentresponsehistory.FieldStatus:
		return m.OldStatus(ctx)
	case assessmentresponsehistory.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case assessmentresponsehistory.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case assessmentresponsehistory.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case assessmentresponsehistory.FieldDueDate:
		return m.OldDueDate(ctx)
	case assessmentresponsehistory.FieldDocumentDataID:
		return m.OldDocumentDataID(ctx)
	}
	return nil, fmt.Errorf("unknown AssessmentResponseHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssessmentResponseHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assessmentresponsehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case assessmentresponsehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case assessmentresponsehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case assessmentresponsehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case assessmentresponsehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case assessmentresponsehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case assessmentresponsehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case assessmentresponsehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case assessmentresponsehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case assessmentresponsehistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case assessmentresponsehistory.FieldAssessmentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssessmentID(v)
		return nil
	case assessmentresponsehistory.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case assessmentresponsehistory.FieldSendAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendAttempts(v)
		return nil
	case assessmentresponsehistory.FieldStatus:
		v, ok := value.(enums.AssessmentResponseStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case assessmentresponsehistory.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case assessmentresponsehistory.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case assessmentresponsehistory.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case assessmentresponsehistory.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case assessmentresponsehistory.FieldDocumentDataID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentDataID(v)
		return nil
	}
	return fmt.Errorf("unknown AssessmentResponseHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssessmentResponseHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addsend_attempts != nil {
		fields = append(fields, assessmentresponsehistory.FieldSendAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssessmentResponseHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case assessmentresponsehistory.FieldSendAttempts:
		return m.AddedSendAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssessmentResponseHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case assessmentresponsehistory.FieldSendAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSendAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown AssessmentResponseHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssessmentResponseHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assessmentresponsehistory.FieldRef) {
		fields = append(fields, assessmentresponsehistory.FieldRef)
	}
	if m.FieldCleared(assessmentresponsehistory.FieldCreatedAt) {
		fields = append(fields, assessmentresponsehistory.FieldCreatedAt)
	}
	if m.FieldCleared(assessmentresponsehistory.FieldUpdatedAt) {
		fields = append(fields, assessmentresponsehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(assessmentresponsehistory.FieldCreatedBy) {
		fields = append(fields, assessmentresponsehistory.FieldCreatedBy)
	}
	if m.FieldCleared(assessmentresponsehistory.FieldUpdatedBy) {
		fields = append(fields, assessmentresponsehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(assessmentresponsehistory.FieldDeletedAt) {
		fields = append(fields, assessmentresponsehistory.FieldDeletedAt)
	}
	if m.FieldCleared(assessmentresponsehistory.FieldDeletedBy) {
		fields = append(fields, assessmentresponsehistory.FieldDeletedBy)
	}
	if m.FieldCleared(assessmentresponsehistory.FieldOwnerID) {
		fields = append(fields, assessmentresponsehistory.FieldOwnerID)
	}
	if m.FieldCleared(assessmentresponsehistory.FieldCompletedAt) {
		fields = append(fields, assessmentresponsehistory.FieldCompletedAt)
	}
	if m.FieldCleared(assessmentresponsehistory.FieldDueDate) {
		fields = append(fields, assessmentresponsehistory.FieldDueDate)
	}
	if m.FieldCleared(assessmentresponsehistory.FieldDocumentDataID) {
		fields = append(fields, assessmentresponsehistory.FieldDocumentDataID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssessmentResponseHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssessmentResponseHistoryMutation) ClearField(name string) error {
	switch name {
	case assessmentresponsehistory.FieldRef:
		m.ClearRef()
		return nil
	case assessmentresponsehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case assessmentresponsehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case assessmentresponsehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case assessmentresponsehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case assessmentresponsehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case assessmentresponsehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case assessmentresponsehistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case assessmentresponsehistory.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case assessmentresponsehistory.FieldDueDate:
		m.ClearDueDate()
		return nil
	case assessmentresponsehistory.FieldDocumentDataID:
		m.ClearDocumentDataID()
		return nil
	}
	return fmt.Errorf("unknown AssessmentResponseHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssessmentResponseHistoryMutation) ResetField(name string) error {
	switch name {
	case assessmentresponsehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case assessmentresponsehistory.FieldRef:
		m.ResetRef()
		return nil
	case assessmentresponsehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case assessmentresponsehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case assessmentresponsehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case assessmentresponsehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case assessmentresponsehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case assessmentresponsehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case assessmentresponsehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case assessmentresponsehistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case assessmentresponsehistory.FieldAssessmentID:
		m.ResetAssessmentID()
		return nil
	case assessmentresponsehistory.FieldEmail:
		m.ResetEmail()
		return nil
	case assessmentresponsehistory.FieldSendAttempts:
		m.ResetSendAttempts()
		return nil
	case assessmentresponsehistory.FieldStatus:
		m.ResetStatus()
		return nil
	case assessmentresponsehistory.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case assessmentresponsehistory.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case assessmentresponsehistory.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case assessmentresponsehistory.FieldDueDate:
		m.ResetDueDate()
		return nil
	case assessmentresponsehistory.FieldDocumentDataID:
		m.ResetDocumentDataID()
		return nil
	}
	return fmt.Errorf("unknown AssessmentResponseHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssessmentResponseHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssessmentResponseHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssessmentResponseHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssessmentResponseHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssessmentResponseHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssessmentResponseHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssessmentResponseHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AssessmentResponseHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssessmentResponseHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AssessmentResponseHistory edge %s", name)
}

// AssetHistoryMutation represents an operation that mutates the AssetHistory nodes in the graph.
type AssetHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	history_time       *time.Time
	ref                *string
	operation          *history.OpType
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	deleted_at         *time.Time
	deleted_by         *string
	tags               *[]string
	appendtags         []string
	owner_id           *string
	system_owned       *bool
	internal_notes     *string
	system_internal_id *string
	asset_type         *enums.AssetType
	name               *string
	description        *string
	identifier         *string
	website            *string
	cpe                *string
	categories         *[]string
	appendcategories   []string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*AssetHistory, error)
	predicates         []predicate.AssetHistory
}

var _ ent.Mutation = (*AssetHistoryMutation)(nil)

// assethistoryOption allows management of the mutation configuration using functional options.
type assethistoryOption func(*AssetHistoryMutation)

// newAssetHistoryMutation creates new mutation for the AssetHistory entity.
func newAssetHistoryMutation(c config, op Op, opts ...assethistoryOption) *AssetHistoryMutation {
	m := &AssetHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeAssetHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetHistoryID sets the ID field of the mutation.
func withAssetHistoryID(id string) assethistoryOption {
	return func(m *AssetHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *AssetHistory
		)
		m.oldValue = func(ctx context.Context) (*AssetHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssetHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssetHistory sets the old AssetHistory of the mutation.
func withAssetHistory(node *AssetHistory) assethistoryOption {
	return func(m *AssetHistoryMutation) {
		m.oldValue = func(context.Context) (*AssetHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AssetHistory entities.
func (m *AssetHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssetHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *AssetHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *AssetHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *AssetHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *AssetHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *AssetHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *AssetHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[assethistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *AssetHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *AssetHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, assethistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *AssetHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *AssetHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *AssetHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AssetHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssetHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AssetHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[assethistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AssetHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssetHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, assethistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssetHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssetHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AssetHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[assethistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AssetHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssetHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, assethistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *AssetHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AssetHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AssetHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[assethistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AssetHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AssetHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, assethistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AssetHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AssetHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AssetHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[assethistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AssetHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AssetHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, assethistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AssetHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AssetHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AssetHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[assethistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AssetHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AssetHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, assethistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *AssetHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *AssetHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *AssetHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[assethistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *AssetHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *AssetHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, assethistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *AssetHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *AssetHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *AssetHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *AssetHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *AssetHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[assethistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *AssetHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *AssetHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, assethistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *AssetHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *AssetHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *AssetHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[assethistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *AssetHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *AssetHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, assethistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *AssetHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *AssetHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *AssetHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[assethistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *AssetHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *AssetHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, assethistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *AssetHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *AssetHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *AssetHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[assethistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *AssetHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *AssetHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, assethistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *AssetHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *AssetHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *AssetHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[assethistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *AssetHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *AssetHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, assethistory.FieldSystemInternalID)
}

// SetAssetType sets the "asset_type" field.
func (m *AssetHistoryMutation) SetAssetType(et enums.AssetType) {
	m.asset_type = &et
}

// AssetType returns the value of the "asset_type" field in the mutation.
func (m *AssetHistoryMutation) AssetType() (r enums.AssetType, exists bool) {
	v := m.asset_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetType returns the old "asset_type" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldAssetType(ctx context.Context) (v enums.AssetType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetType: %w", err)
	}
	return oldValue.AssetType, nil
}

// ResetAssetType resets all changes to the "asset_type" field.
func (m *AssetHistoryMutation) ResetAssetType() {
	m.asset_type = nil
}

// SetName sets the "name" field.
func (m *AssetHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AssetHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AssetHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AssetHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AssetHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AssetHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[assethistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AssetHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AssetHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, assethistory.FieldDescription)
}

// SetIdentifier sets the "identifier" field.
func (m *AssetHistoryMutation) SetIdentifier(s string) {
	m.identifier = &s
}

// Identifier returns the value of the "identifier" field in the mutation.
func (m *AssetHistoryMutation) Identifier() (r string, exists bool) {
	v := m.identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentifier returns the old "identifier" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentifier: %w", err)
	}
	return oldValue.Identifier, nil
}

// ClearIdentifier clears the value of the "identifier" field.
func (m *AssetHistoryMutation) ClearIdentifier() {
	m.identifier = nil
	m.clearedFields[assethistory.FieldIdentifier] = struct{}{}
}

// IdentifierCleared returns if the "identifier" field was cleared in this mutation.
func (m *AssetHistoryMutation) IdentifierCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldIdentifier]
	return ok
}

// ResetIdentifier resets all changes to the "identifier" field.
func (m *AssetHistoryMutation) ResetIdentifier() {
	m.identifier = nil
	delete(m.clearedFields, assethistory.FieldIdentifier)
}

// SetWebsite sets the "website" field.
func (m *AssetHistoryMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *AssetHistoryMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *AssetHistoryMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[assethistory.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *AssetHistoryMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *AssetHistoryMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, assethistory.FieldWebsite)
}

// SetCpe sets the "cpe" field.
func (m *AssetHistoryMutation) SetCpe(s string) {
	m.cpe = &s
}

// Cpe returns the value of the "cpe" field in the mutation.
func (m *AssetHistoryMutation) Cpe() (r string, exists bool) {
	v := m.cpe
	if v == nil {
		return
	}
	return *v, true
}

// OldCpe returns the old "cpe" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldCpe(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCpe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCpe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCpe: %w", err)
	}
	return oldValue.Cpe, nil
}

// ClearCpe clears the value of the "cpe" field.
func (m *AssetHistoryMutation) ClearCpe() {
	m.cpe = nil
	m.clearedFields[assethistory.FieldCpe] = struct{}{}
}

// CpeCleared returns if the "cpe" field was cleared in this mutation.
func (m *AssetHistoryMutation) CpeCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldCpe]
	return ok
}

// ResetCpe resets all changes to the "cpe" field.
func (m *AssetHistoryMutation) ResetCpe() {
	m.cpe = nil
	delete(m.clearedFields, assethistory.FieldCpe)
}

// SetCategories sets the "categories" field.
func (m *AssetHistoryMutation) SetCategories(s []string) {
	m.categories = &s
	m.appendcategories = nil
}

// Categories returns the value of the "categories" field in the mutation.
func (m *AssetHistoryMutation) Categories() (r []string, exists bool) {
	v := m.categories
	if v == nil {
		return
	}
	return *v, true
}

// OldCategories returns the old "categories" field's value of the AssetHistory entity.
// If the AssetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetHistoryMutation) OldCategories(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategories: %w", err)
	}
	return oldValue.Categories, nil
}

// AppendCategories adds s to the "categories" field.
func (m *AssetHistoryMutation) AppendCategories(s []string) {
	m.appendcategories = append(m.appendcategories, s...)
}

// AppendedCategories returns the list of values that were appended to the "categories" field in this mutation.
func (m *AssetHistoryMutation) AppendedCategories() ([]string, bool) {
	if len(m.appendcategories) == 0 {
		return nil, false
	}
	return m.appendcategories, true
}

// ClearCategories clears the value of the "categories" field.
func (m *AssetHistoryMutation) ClearCategories() {
	m.categories = nil
	m.appendcategories = nil
	m.clearedFields[assethistory.FieldCategories] = struct{}{}
}

// CategoriesCleared returns if the "categories" field was cleared in this mutation.
func (m *AssetHistoryMutation) CategoriesCleared() bool {
	_, ok := m.clearedFields[assethistory.FieldCategories]
	return ok
}

// ResetCategories resets all changes to the "categories" field.
func (m *AssetHistoryMutation) ResetCategories() {
	m.categories = nil
	m.appendcategories = nil
	delete(m.clearedFields, assethistory.FieldCategories)
}

// Where appends a list predicates to the AssetHistoryMutation builder.
func (m *AssetHistoryMutation) Where(ps ...predicate.AssetHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssetHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssetHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AssetHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssetHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssetHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AssetHistory).
func (m *AssetHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetHistoryMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.history_time != nil {
		fields = append(fields, assethistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, assethistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, assethistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, assethistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, assethistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, assethistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, assethistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, assethistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, assethistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, assethistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, assethistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, assethistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, assethistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, assethistory.FieldSystemInternalID)
	}
	if m.asset_type != nil {
		fields = append(fields, assethistory.FieldAssetType)
	}
	if m.name != nil {
		fields = append(fields, assethistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, assethistory.FieldDescription)
	}
	if m.identifier != nil {
		fields = append(fields, assethistory.FieldIdentifier)
	}
	if m.website != nil {
		fields = append(fields, assethistory.FieldWebsite)
	}
	if m.cpe != nil {
		fields = append(fields, assethistory.FieldCpe)
	}
	if m.categories != nil {
		fields = append(fields, assethistory.FieldCategories)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assethistory.FieldHistoryTime:
		return m.HistoryTime()
	case assethistory.FieldRef:
		return m.Ref()
	case assethistory.FieldOperation:
		return m.Operation()
	case assethistory.FieldCreatedAt:
		return m.CreatedAt()
	case assethistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case assethistory.FieldCreatedBy:
		return m.CreatedBy()
	case assethistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case assethistory.FieldDeletedAt:
		return m.DeletedAt()
	case assethistory.FieldDeletedBy:
		return m.DeletedBy()
	case assethistory.FieldTags:
		return m.Tags()
	case assethistory.FieldOwnerID:
		return m.OwnerID()
	case assethistory.FieldSystemOwned:
		return m.SystemOwned()
	case assethistory.FieldInternalNotes:
		return m.InternalNotes()
	case assethistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case assethistory.FieldAssetType:
		return m.AssetType()
	case assethistory.FieldName:
		return m.Name()
	case assethistory.FieldDescription:
		return m.Description()
	case assethistory.FieldIdentifier:
		return m.Identifier()
	case assethistory.FieldWebsite:
		return m.Website()
	case assethistory.FieldCpe:
		return m.Cpe()
	case assethistory.FieldCategories:
		return m.Categories()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assethistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case assethistory.FieldRef:
		return m.OldRef(ctx)
	case assethistory.FieldOperation:
		return m.OldOperation(ctx)
	case assethistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case assethistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case assethistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case assethistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case assethistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case assethistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case assethistory.FieldTags:
		return m.OldTags(ctx)
	case assethistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case assethistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case assethistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case assethistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case assethistory.FieldAssetType:
		return m.OldAssetType(ctx)
	case assethistory.FieldName:
		return m.OldName(ctx)
	case assethistory.FieldDescription:
		return m.OldDescription(ctx)
	case assethistory.FieldIdentifier:
		return m.OldIdentifier(ctx)
	case assethistory.FieldWebsite:
		return m.OldWebsite(ctx)
	case assethistory.FieldCpe:
		return m.OldCpe(ctx)
	case assethistory.FieldCategories:
		return m.OldCategories(ctx)
	}
	return nil, fmt.Errorf("unknown AssetHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assethistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case assethistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case assethistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case assethistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case assethistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case assethistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case assethistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case assethistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case assethistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case assethistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case assethistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case assethistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case assethistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case assethistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case assethistory.FieldAssetType:
		v, ok := value.(enums.AssetType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetType(v)
		return nil
	case assethistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case assethistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case assethistory.FieldIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentifier(v)
		return nil
	case assethistory.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case assethistory.FieldCpe:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCpe(v)
		return nil
	case assethistory.FieldCategories:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategories(v)
		return nil
	}
	return fmt.Errorf("unknown AssetHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AssetHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assethistory.FieldRef) {
		fields = append(fields, assethistory.FieldRef)
	}
	if m.FieldCleared(assethistory.FieldCreatedAt) {
		fields = append(fields, assethistory.FieldCreatedAt)
	}
	if m.FieldCleared(assethistory.FieldUpdatedAt) {
		fields = append(fields, assethistory.FieldUpdatedAt)
	}
	if m.FieldCleared(assethistory.FieldCreatedBy) {
		fields = append(fields, assethistory.FieldCreatedBy)
	}
	if m.FieldCleared(assethistory.FieldUpdatedBy) {
		fields = append(fields, assethistory.FieldUpdatedBy)
	}
	if m.FieldCleared(assethistory.FieldDeletedAt) {
		fields = append(fields, assethistory.FieldDeletedAt)
	}
	if m.FieldCleared(assethistory.FieldDeletedBy) {
		fields = append(fields, assethistory.FieldDeletedBy)
	}
	if m.FieldCleared(assethistory.FieldTags) {
		fields = append(fields, assethistory.FieldTags)
	}
	if m.FieldCleared(assethistory.FieldOwnerID) {
		fields = append(fields, assethistory.FieldOwnerID)
	}
	if m.FieldCleared(assethistory.FieldSystemOwned) {
		fields = append(fields, assethistory.FieldSystemOwned)
	}
	if m.FieldCleared(assethistory.FieldInternalNotes) {
		fields = append(fields, assethistory.FieldInternalNotes)
	}
	if m.FieldCleared(assethistory.FieldSystemInternalID) {
		fields = append(fields, assethistory.FieldSystemInternalID)
	}
	if m.FieldCleared(assethistory.FieldDescription) {
		fields = append(fields, assethistory.FieldDescription)
	}
	if m.FieldCleared(assethistory.FieldIdentifier) {
		fields = append(fields, assethistory.FieldIdentifier)
	}
	if m.FieldCleared(assethistory.FieldWebsite) {
		fields = append(fields, assethistory.FieldWebsite)
	}
	if m.FieldCleared(assethistory.FieldCpe) {
		fields = append(fields, assethistory.FieldCpe)
	}
	if m.FieldCleared(assethistory.FieldCategories) {
		fields = append(fields, assethistory.FieldCategories)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetHistoryMutation) ClearField(name string) error {
	switch name {
	case assethistory.FieldRef:
		m.ClearRef()
		return nil
	case assethistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case assethistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case assethistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case assethistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case assethistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case assethistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case assethistory.FieldTags:
		m.ClearTags()
		return nil
	case assethistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case assethistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case assethistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case assethistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case assethistory.FieldDescription:
		m.ClearDescription()
		return nil
	case assethistory.FieldIdentifier:
		m.ClearIdentifier()
		return nil
	case assethistory.FieldWebsite:
		m.ClearWebsite()
		return nil
	case assethistory.FieldCpe:
		m.ClearCpe()
		return nil
	case assethistory.FieldCategories:
		m.ClearCategories()
		return nil
	}
	return fmt.Errorf("unknown AssetHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetHistoryMutation) ResetField(name string) error {
	switch name {
	case assethistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case assethistory.FieldRef:
		m.ResetRef()
		return nil
	case assethistory.FieldOperation:
		m.ResetOperation()
		return nil
	case assethistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case assethistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case assethistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case assethistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case assethistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case assethistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case assethistory.FieldTags:
		m.ResetTags()
		return nil
	case assethistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case assethistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case assethistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case assethistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case assethistory.FieldAssetType:
		m.ResetAssetType()
		return nil
	case assethistory.FieldName:
		m.ResetName()
		return nil
	case assethistory.FieldDescription:
		m.ResetDescription()
		return nil
	case assethistory.FieldIdentifier:
		m.ResetIdentifier()
		return nil
	case assethistory.FieldWebsite:
		m.ResetWebsite()
		return nil
	case assethistory.FieldCpe:
		m.ResetCpe()
		return nil
	case assethistory.FieldCategories:
		m.ResetCategories()
		return nil
	}
	return fmt.Errorf("unknown AssetHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AssetHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AssetHistory edge %s", name)
}

// ContactHistoryMutation represents an operation that mutates the ContactHistory nodes in the graph.
type ContactHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	deleted_at    *time.Time
	deleted_by    *string
	tags          *[]string
	appendtags    []string
	owner_id      *string
	full_name     *string
	title         *string
	company       *string
	email         *string
	phone_number  *string
	address       *string
	status        *enums.UserStatus
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ContactHistory, error)
	predicates    []predicate.ContactHistory
}

var _ ent.Mutation = (*ContactHistoryMutation)(nil)

// contacthistoryOption allows management of the mutation configuration using functional options.
type contacthistoryOption func(*ContactHistoryMutation)

// newContactHistoryMutation creates new mutation for the ContactHistory entity.
func newContactHistoryMutation(c config, op Op, opts ...contacthistoryOption) *ContactHistoryMutation {
	m := &ContactHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeContactHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContactHistoryID sets the ID field of the mutation.
func withContactHistoryID(id string) contacthistoryOption {
	return func(m *ContactHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ContactHistory
		)
		m.oldValue = func(ctx context.Context) (*ContactHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ContactHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContactHistory sets the old ContactHistory of the mutation.
func withContactHistory(node *ContactHistory) contacthistoryOption {
	return func(m *ContactHistoryMutation) {
		m.oldValue = func(context.Context) (*ContactHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContactHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContactHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ContactHistory entities.
func (m *ContactHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContactHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContactHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ContactHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ContactHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ContactHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ContactHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ContactHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ContactHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ContactHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[contacthistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ContactHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ContactHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, contacthistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ContactHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ContactHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ContactHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ContactHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContactHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ContactHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[contacthistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ContactHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContactHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, contacthistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContactHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContactHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ContactHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[contacthistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ContactHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContactHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, contacthistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ContactHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ContactHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ContactHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[contacthistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ContactHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ContactHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, contacthistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ContactHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ContactHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ContactHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[contacthistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ContactHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ContactHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, contacthistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ContactHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ContactHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ContactHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[contacthistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ContactHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ContactHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, contacthistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ContactHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ContactHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ContactHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[contacthistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ContactHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ContactHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, contacthistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *ContactHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ContactHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ContactHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ContactHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ContactHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[contacthistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ContactHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ContactHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, contacthistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *ContactHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ContactHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *ContactHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[contacthistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *ContactHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ContactHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, contacthistory.FieldOwnerID)
}

// SetFullName sets the "full_name" field.
func (m *ContactHistoryMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *ContactHistoryMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ClearFullName clears the value of the "full_name" field.
func (m *ContactHistoryMutation) ClearFullName() {
	m.full_name = nil
	m.clearedFields[contacthistory.FieldFullName] = struct{}{}
}

// FullNameCleared returns if the "full_name" field was cleared in this mutation.
func (m *ContactHistoryMutation) FullNameCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldFullName]
	return ok
}

// ResetFullName resets all changes to the "full_name" field.
func (m *ContactHistoryMutation) ResetFullName() {
	m.full_name = nil
	delete(m.clearedFields, contacthistory.FieldFullName)
}

// SetTitle sets the "title" field.
func (m *ContactHistoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ContactHistoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ContactHistoryMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[contacthistory.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ContactHistoryMutation) TitleCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ContactHistoryMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, contacthistory.FieldTitle)
}

// SetCompany sets the "company" field.
func (m *ContactHistoryMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *ContactHistoryMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *ContactHistoryMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[contacthistory.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *ContactHistoryMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *ContactHistoryMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, contacthistory.FieldCompany)
}

// SetEmail sets the "email" field.
func (m *ContactHistoryMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *ContactHistoryMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *ContactHistoryMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[contacthistory.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *ContactHistoryMutation) EmailCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *ContactHistoryMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, contacthistory.FieldEmail)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *ContactHistoryMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *ContactHistoryMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *ContactHistoryMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[contacthistory.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *ContactHistoryMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *ContactHistoryMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, contacthistory.FieldPhoneNumber)
}

// SetAddress sets the "address" field.
func (m *ContactHistoryMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *ContactHistoryMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *ContactHistoryMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[contacthistory.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *ContactHistoryMutation) AddressCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *ContactHistoryMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, contacthistory.FieldAddress)
}

// SetStatus sets the "status" field.
func (m *ContactHistoryMutation) SetStatus(es enums.UserStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *ContactHistoryMutation) Status() (r enums.UserStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldStatus(ctx context.Context) (v enums.UserStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ContactHistoryMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the ContactHistoryMutation builder.
func (m *ContactHistoryMutation) Where(ps ...predicate.ContactHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContactHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContactHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ContactHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContactHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContactHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ContactHistory).
func (m *ContactHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContactHistoryMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.history_time != nil {
		fields = append(fields, contacthistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, contacthistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, contacthistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, contacthistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contacthistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, contacthistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, contacthistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, contacthistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, contacthistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, contacthistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, contacthistory.FieldOwnerID)
	}
	if m.full_name != nil {
		fields = append(fields, contacthistory.FieldFullName)
	}
	if m.title != nil {
		fields = append(fields, contacthistory.FieldTitle)
	}
	if m.company != nil {
		fields = append(fields, contacthistory.FieldCompany)
	}
	if m.email != nil {
		fields = append(fields, contacthistory.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, contacthistory.FieldPhoneNumber)
	}
	if m.address != nil {
		fields = append(fields, contacthistory.FieldAddress)
	}
	if m.status != nil {
		fields = append(fields, contacthistory.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContactHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contacthistory.FieldHistoryTime:
		return m.HistoryTime()
	case contacthistory.FieldRef:
		return m.Ref()
	case contacthistory.FieldOperation:
		return m.Operation()
	case contacthistory.FieldCreatedAt:
		return m.CreatedAt()
	case contacthistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case contacthistory.FieldCreatedBy:
		return m.CreatedBy()
	case contacthistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case contacthistory.FieldDeletedAt:
		return m.DeletedAt()
	case contacthistory.FieldDeletedBy:
		return m.DeletedBy()
	case contacthistory.FieldTags:
		return m.Tags()
	case contacthistory.FieldOwnerID:
		return m.OwnerID()
	case contacthistory.FieldFullName:
		return m.FullName()
	case contacthistory.FieldTitle:
		return m.Title()
	case contacthistory.FieldCompany:
		return m.Company()
	case contacthistory.FieldEmail:
		return m.Email()
	case contacthistory.FieldPhoneNumber:
		return m.PhoneNumber()
	case contacthistory.FieldAddress:
		return m.Address()
	case contacthistory.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContactHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contacthistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case contacthistory.FieldRef:
		return m.OldRef(ctx)
	case contacthistory.FieldOperation:
		return m.OldOperation(ctx)
	case contacthistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contacthistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contacthistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case contacthistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case contacthistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case contacthistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case contacthistory.FieldTags:
		return m.OldTags(ctx)
	case contacthistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case contacthistory.FieldFullName:
		return m.OldFullName(ctx)
	case contacthistory.FieldTitle:
		return m.OldTitle(ctx)
	case contacthistory.FieldCompany:
		return m.OldCompany(ctx)
	case contacthistory.FieldEmail:
		return m.OldEmail(ctx)
	case contacthistory.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case contacthistory.FieldAddress:
		return m.OldAddress(ctx)
	case contacthistory.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ContactHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contacthistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case contacthistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case contacthistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case contacthistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contacthistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contacthistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case contacthistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case contacthistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case contacthistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case contacthistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case contacthistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case contacthistory.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case contacthistory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case contacthistory.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case contacthistory.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case contacthistory.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case contacthistory.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case contacthistory.FieldStatus:
		v, ok := value.(enums.UserStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ContactHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContactHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContactHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ContactHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContactHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contacthistory.FieldRef) {
		fields = append(fields, contacthistory.FieldRef)
	}
	if m.FieldCleared(contacthistory.FieldCreatedAt) {
		fields = append(fields, contacthistory.FieldCreatedAt)
	}
	if m.FieldCleared(contacthistory.FieldUpdatedAt) {
		fields = append(fields, contacthistory.FieldUpdatedAt)
	}
	if m.FieldCleared(contacthistory.FieldCreatedBy) {
		fields = append(fields, contacthistory.FieldCreatedBy)
	}
	if m.FieldCleared(contacthistory.FieldUpdatedBy) {
		fields = append(fields, contacthistory.FieldUpdatedBy)
	}
	if m.FieldCleared(contacthistory.FieldDeletedAt) {
		fields = append(fields, contacthistory.FieldDeletedAt)
	}
	if m.FieldCleared(contacthistory.FieldDeletedBy) {
		fields = append(fields, contacthistory.FieldDeletedBy)
	}
	if m.FieldCleared(contacthistory.FieldTags) {
		fields = append(fields, contacthistory.FieldTags)
	}
	if m.FieldCleared(contacthistory.FieldOwnerID) {
		fields = append(fields, contacthistory.FieldOwnerID)
	}
	if m.FieldCleared(contacthistory.FieldFullName) {
		fields = append(fields, contacthistory.FieldFullName)
	}
	if m.FieldCleared(contacthistory.FieldTitle) {
		fields = append(fields, contacthistory.FieldTitle)
	}
	if m.FieldCleared(contacthistory.FieldCompany) {
		fields = append(fields, contacthistory.FieldCompany)
	}
	if m.FieldCleared(contacthistory.FieldEmail) {
		fields = append(fields, contacthistory.FieldEmail)
	}
	if m.FieldCleared(contacthistory.FieldPhoneNumber) {
		fields = append(fields, contacthistory.FieldPhoneNumber)
	}
	if m.FieldCleared(contacthistory.FieldAddress) {
		fields = append(fields, contacthistory.FieldAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContactHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContactHistoryMutation) ClearField(name string) error {
	switch name {
	case contacthistory.FieldRef:
		m.ClearRef()
		return nil
	case contacthistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case contacthistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case contacthistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case contacthistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case contacthistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case contacthistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case contacthistory.FieldTags:
		m.ClearTags()
		return nil
	case contacthistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case contacthistory.FieldFullName:
		m.ClearFullName()
		return nil
	case contacthistory.FieldTitle:
		m.ClearTitle()
		return nil
	case contacthistory.FieldCompany:
		m.ClearCompany()
		return nil
	case contacthistory.FieldEmail:
		m.ClearEmail()
		return nil
	case contacthistory.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case contacthistory.FieldAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown ContactHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContactHistoryMutation) ResetField(name string) error {
	switch name {
	case contacthistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case contacthistory.FieldRef:
		m.ResetRef()
		return nil
	case contacthistory.FieldOperation:
		m.ResetOperation()
		return nil
	case contacthistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contacthistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contacthistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case contacthistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case contacthistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case contacthistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case contacthistory.FieldTags:
		m.ResetTags()
		return nil
	case contacthistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case contacthistory.FieldFullName:
		m.ResetFullName()
		return nil
	case contacthistory.FieldTitle:
		m.ResetTitle()
		return nil
	case contacthistory.FieldCompany:
		m.ResetCompany()
		return nil
	case contacthistory.FieldEmail:
		m.ResetEmail()
		return nil
	case contacthistory.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case contacthistory.FieldAddress:
		m.ResetAddress()
		return nil
	case contacthistory.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ContactHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContactHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContactHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContactHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContactHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContactHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContactHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContactHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ContactHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContactHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ContactHistory edge %s", name)
}

// ControlHistoryMutation represents an operation that mutates the ControlHistory nodes in the graph.
type ControlHistoryMutation struct {
	config
	op                            Op
	typ                           string
	id                            *string
	history_time                  *time.Time
	ref                           *string
	operation                     *history.OpType
	created_at                    *time.Time
	updated_at                    *time.Time
	created_by                    *string
	updated_by                    *string
	deleted_at                    *time.Time
	deleted_by                    *string
	display_id                    *string
	tags                          *[]string
	appendtags                    []string
	title                         *string
	description                   *string
	aliases                       *[]string
	appendaliases                 []string
	reference_id                  *string
	auditor_reference_id          *string
	responsible_party_id          *string
	status                        *enums.ControlStatus
	source                        *enums.ControlSource
	reference_framework           *string
	reference_framework_revision  *string
	control_type                  *enums.ControlType
	category                      *string
	category_id                   *string
	subcategory                   *string
	mapped_categories             *[]string
	appendmapped_categories       []string
	assessment_objectives         *[]models.AssessmentObjective
	appendassessment_objectives   []models.AssessmentObjective
	assessment_methods            *[]models.AssessmentMethod
	appendassessment_methods      []models.AssessmentMethod
	control_questions             *[]string
	appendcontrol_questions       []string
	implementation_guidance       *[]models.ImplementationGuidance
	appendimplementation_guidance []models.ImplementationGuidance
	example_evidence              *[]models.ExampleEvidence
	appendexample_evidence        []models.ExampleEvidence
	references                    *[]models.Reference
	appendreferences              []models.Reference
	control_owner_id              *string
	delegate_id                   *string
	owner_id                      *string
	system_owned                  *bool
	internal_notes                *string
	system_internal_id            *string
	control_kind_name             *string
	control_kind_id               *string
	ref_code                      *string
	standard_id                   *string
	clearedFields                 map[string]struct{}
	done                          bool
	oldValue                      func(context.Context) (*ControlHistory, error)
	predicates                    []predicate.ControlHistory
}

var _ ent.Mutation = (*ControlHistoryMutation)(nil)

// controlhistoryOption allows management of the mutation configuration using functional options.
type controlhistoryOption func(*ControlHistoryMutation)

// newControlHistoryMutation creates new mutation for the ControlHistory entity.
func newControlHistoryMutation(c config, op Op, opts ...controlhistoryOption) *ControlHistoryMutation {
	m := &ControlHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeControlHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withControlHistoryID sets the ID field of the mutation.
func withControlHistoryID(id string) controlhistoryOption {
	return func(m *ControlHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ControlHistory
		)
		m.oldValue = func(ctx context.Context) (*ControlHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ControlHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withControlHistory sets the old ControlHistory of the mutation.
func withControlHistory(node *ControlHistory) controlhistoryOption {
	return func(m *ControlHistoryMutation) {
		m.oldValue = func(context.Context) (*ControlHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ControlHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ControlHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ControlHistory entities.
func (m *ControlHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ControlHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ControlHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ControlHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ControlHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ControlHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ControlHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ControlHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ControlHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ControlHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[controlhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ControlHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ControlHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, controlhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ControlHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ControlHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ControlHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ControlHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ControlHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ControlHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[controlhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ControlHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ControlHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, controlhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ControlHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ControlHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ControlHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[controlhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ControlHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ControlHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, controlhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ControlHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ControlHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ControlHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[controlhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ControlHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ControlHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, controlhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ControlHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ControlHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ControlHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[controlhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ControlHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ControlHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, controlhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ControlHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ControlHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ControlHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[controlhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ControlHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ControlHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, controlhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ControlHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ControlHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ControlHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[controlhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ControlHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ControlHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, controlhistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *ControlHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *ControlHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *ControlHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *ControlHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ControlHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ControlHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ControlHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ControlHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[controlhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ControlHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ControlHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, controlhistory.FieldTags)
}

// SetTitle sets the "title" field.
func (m *ControlHistoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ControlHistoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ControlHistoryMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[controlhistory.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ControlHistoryMutation) TitleCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ControlHistoryMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, controlhistory.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *ControlHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ControlHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ControlHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[controlhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ControlHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ControlHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, controlhistory.FieldDescription)
}

// SetAliases sets the "aliases" field.
func (m *ControlHistoryMutation) SetAliases(s []string) {
	m.aliases = &s
	m.appendaliases = nil
}

// Aliases returns the value of the "aliases" field in the mutation.
func (m *ControlHistoryMutation) Aliases() (r []string, exists bool) {
	v := m.aliases
	if v == nil {
		return
	}
	return *v, true
}

// OldAliases returns the old "aliases" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldAliases(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAliases is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAliases requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAliases: %w", err)
	}
	return oldValue.Aliases, nil
}

// AppendAliases adds s to the "aliases" field.
func (m *ControlHistoryMutation) AppendAliases(s []string) {
	m.appendaliases = append(m.appendaliases, s...)
}

// AppendedAliases returns the list of values that were appended to the "aliases" field in this mutation.
func (m *ControlHistoryMutation) AppendedAliases() ([]string, bool) {
	if len(m.appendaliases) == 0 {
		return nil, false
	}
	return m.appendaliases, true
}

// ClearAliases clears the value of the "aliases" field.
func (m *ControlHistoryMutation) ClearAliases() {
	m.aliases = nil
	m.appendaliases = nil
	m.clearedFields[controlhistory.FieldAliases] = struct{}{}
}

// AliasesCleared returns if the "aliases" field was cleared in this mutation.
func (m *ControlHistoryMutation) AliasesCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldAliases]
	return ok
}

// ResetAliases resets all changes to the "aliases" field.
func (m *ControlHistoryMutation) ResetAliases() {
	m.aliases = nil
	m.appendaliases = nil
	delete(m.clearedFields, controlhistory.FieldAliases)
}

// SetReferenceID sets the "reference_id" field.
func (m *ControlHistoryMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *ControlHistoryMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ClearReferenceID clears the value of the "reference_id" field.
func (m *ControlHistoryMutation) ClearReferenceID() {
	m.reference_id = nil
	m.clearedFields[controlhistory.FieldReferenceID] = struct{}{}
}

// ReferenceIDCleared returns if the "reference_id" field was cleared in this mutation.
func (m *ControlHistoryMutation) ReferenceIDCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldReferenceID]
	return ok
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *ControlHistoryMutation) ResetReferenceID() {
	m.reference_id = nil
	delete(m.clearedFields, controlhistory.FieldReferenceID)
}

// SetAuditorReferenceID sets the "auditor_reference_id" field.
func (m *ControlHistoryMutation) SetAuditorReferenceID(s string) {
	m.auditor_reference_id = &s
}

// AuditorReferenceID returns the value of the "auditor_reference_id" field in the mutation.
func (m *ControlHistoryMutation) AuditorReferenceID() (r string, exists bool) {
	v := m.auditor_reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditorReferenceID returns the old "auditor_reference_id" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldAuditorReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditorReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditorReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditorReferenceID: %w", err)
	}
	return oldValue.AuditorReferenceID, nil
}

// ClearAuditorReferenceID clears the value of the "auditor_reference_id" field.
func (m *ControlHistoryMutation) ClearAuditorReferenceID() {
	m.auditor_reference_id = nil
	m.clearedFields[controlhistory.FieldAuditorReferenceID] = struct{}{}
}

// AuditorReferenceIDCleared returns if the "auditor_reference_id" field was cleared in this mutation.
func (m *ControlHistoryMutation) AuditorReferenceIDCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldAuditorReferenceID]
	return ok
}

// ResetAuditorReferenceID resets all changes to the "auditor_reference_id" field.
func (m *ControlHistoryMutation) ResetAuditorReferenceID() {
	m.auditor_reference_id = nil
	delete(m.clearedFields, controlhistory.FieldAuditorReferenceID)
}

// SetResponsiblePartyID sets the "responsible_party_id" field.
func (m *ControlHistoryMutation) SetResponsiblePartyID(s string) {
	m.responsible_party_id = &s
}

// ResponsiblePartyID returns the value of the "responsible_party_id" field in the mutation.
func (m *ControlHistoryMutation) ResponsiblePartyID() (r string, exists bool) {
	v := m.responsible_party_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResponsiblePartyID returns the old "responsible_party_id" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldResponsiblePartyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponsiblePartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponsiblePartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponsiblePartyID: %w", err)
	}
	return oldValue.ResponsiblePartyID, nil
}

// ClearResponsiblePartyID clears the value of the "responsible_party_id" field.
func (m *ControlHistoryMutation) ClearResponsiblePartyID() {
	m.responsible_party_id = nil
	m.clearedFields[controlhistory.FieldResponsiblePartyID] = struct{}{}
}

// ResponsiblePartyIDCleared returns if the "responsible_party_id" field was cleared in this mutation.
func (m *ControlHistoryMutation) ResponsiblePartyIDCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldResponsiblePartyID]
	return ok
}

// ResetResponsiblePartyID resets all changes to the "responsible_party_id" field.
func (m *ControlHistoryMutation) ResetResponsiblePartyID() {
	m.responsible_party_id = nil
	delete(m.clearedFields, controlhistory.FieldResponsiblePartyID)
}

// SetStatus sets the "status" field.
func (m *ControlHistoryMutation) SetStatus(es enums.ControlStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *ControlHistoryMutation) Status() (r enums.ControlStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldStatus(ctx context.Context) (v enums.ControlStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ControlHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[controlhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ControlHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ControlHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, controlhistory.FieldStatus)
}

// SetSource sets the "source" field.
func (m *ControlHistoryMutation) SetSource(es enums.ControlSource) {
	m.source = &es
}

// Source returns the value of the "source" field in the mutation.
func (m *ControlHistoryMutation) Source() (r enums.ControlSource, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldSource(ctx context.Context) (v enums.ControlSource, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *ControlHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[controlhistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *ControlHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *ControlHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, controlhistory.FieldSource)
}

// SetReferenceFramework sets the "reference_framework" field.
func (m *ControlHistoryMutation) SetReferenceFramework(s string) {
	m.reference_framework = &s
}

// ReferenceFramework returns the value of the "reference_framework" field in the mutation.
func (m *ControlHistoryMutation) ReferenceFramework() (r string, exists bool) {
	v := m.reference_framework
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceFramework returns the old "reference_framework" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldReferenceFramework(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceFramework is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceFramework requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceFramework: %w", err)
	}
	return oldValue.ReferenceFramework, nil
}

// ClearReferenceFramework clears the value of the "reference_framework" field.
func (m *ControlHistoryMutation) ClearReferenceFramework() {
	m.reference_framework = nil
	m.clearedFields[controlhistory.FieldReferenceFramework] = struct{}{}
}

// ReferenceFrameworkCleared returns if the "reference_framework" field was cleared in this mutation.
func (m *ControlHistoryMutation) ReferenceFrameworkCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldReferenceFramework]
	return ok
}

// ResetReferenceFramework resets all changes to the "reference_framework" field.
func (m *ControlHistoryMutation) ResetReferenceFramework() {
	m.reference_framework = nil
	delete(m.clearedFields, controlhistory.FieldReferenceFramework)
}

// SetReferenceFrameworkRevision sets the "reference_framework_revision" field.
func (m *ControlHistoryMutation) SetReferenceFrameworkRevision(s string) {
	m.reference_framework_revision = &s
}

// ReferenceFrameworkRevision returns the value of the "reference_framework_revision" field in the mutation.
func (m *ControlHistoryMutation) ReferenceFrameworkRevision() (r string, exists bool) {
	v := m.reference_framework_revision
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceFrameworkRevision returns the old "reference_framework_revision" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldReferenceFrameworkRevision(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceFrameworkRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceFrameworkRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceFrameworkRevision: %w", err)
	}
	return oldValue.ReferenceFrameworkRevision, nil
}

// ClearReferenceFrameworkRevision clears the value of the "reference_framework_revision" field.
func (m *ControlHistoryMutation) ClearReferenceFrameworkRevision() {
	m.reference_framework_revision = nil
	m.clearedFields[controlhistory.FieldReferenceFrameworkRevision] = struct{}{}
}

// ReferenceFrameworkRevisionCleared returns if the "reference_framework_revision" field was cleared in this mutation.
func (m *ControlHistoryMutation) ReferenceFrameworkRevisionCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldReferenceFrameworkRevision]
	return ok
}

// ResetReferenceFrameworkRevision resets all changes to the "reference_framework_revision" field.
func (m *ControlHistoryMutation) ResetReferenceFrameworkRevision() {
	m.reference_framework_revision = nil
	delete(m.clearedFields, controlhistory.FieldReferenceFrameworkRevision)
}

// SetControlType sets the "control_type" field.
func (m *ControlHistoryMutation) SetControlType(et enums.ControlType) {
	m.control_type = &et
}

// ControlType returns the value of the "control_type" field in the mutation.
func (m *ControlHistoryMutation) ControlType() (r enums.ControlType, exists bool) {
	v := m.control_type
	if v == nil {
		return
	}
	return *v, true
}

// OldControlType returns the old "control_type" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldControlType(ctx context.Context) (v enums.ControlType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlType: %w", err)
	}
	return oldValue.ControlType, nil
}

// ClearControlType clears the value of the "control_type" field.
func (m *ControlHistoryMutation) ClearControlType() {
	m.control_type = nil
	m.clearedFields[controlhistory.FieldControlType] = struct{}{}
}

// ControlTypeCleared returns if the "control_type" field was cleared in this mutation.
func (m *ControlHistoryMutation) ControlTypeCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldControlType]
	return ok
}

// ResetControlType resets all changes to the "control_type" field.
func (m *ControlHistoryMutation) ResetControlType() {
	m.control_type = nil
	delete(m.clearedFields, controlhistory.FieldControlType)
}

// SetCategory sets the "category" field.
func (m *ControlHistoryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ControlHistoryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ControlHistoryMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[controlhistory.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ControlHistoryMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ControlHistoryMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, controlhistory.FieldCategory)
}

// SetCategoryID sets the "category_id" field.
func (m *ControlHistoryMutation) SetCategoryID(s string) {
	m.category_id = &s
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *ControlHistoryMutation) CategoryID() (r string, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldCategoryID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *ControlHistoryMutation) ClearCategoryID() {
	m.category_id = nil
	m.clearedFields[controlhistory.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *ControlHistoryMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *ControlHistoryMutation) ResetCategoryID() {
	m.category_id = nil
	delete(m.clearedFields, controlhistory.FieldCategoryID)
}

// SetSubcategory sets the "subcategory" field.
func (m *ControlHistoryMutation) SetSubcategory(s string) {
	m.subcategory = &s
}

// Subcategory returns the value of the "subcategory" field in the mutation.
func (m *ControlHistoryMutation) Subcategory() (r string, exists bool) {
	v := m.subcategory
	if v == nil {
		return
	}
	return *v, true
}

// OldSubcategory returns the old "subcategory" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldSubcategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubcategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubcategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubcategory: %w", err)
	}
	return oldValue.Subcategory, nil
}

// ClearSubcategory clears the value of the "subcategory" field.
func (m *ControlHistoryMutation) ClearSubcategory() {
	m.subcategory = nil
	m.clearedFields[controlhistory.FieldSubcategory] = struct{}{}
}

// SubcategoryCleared returns if the "subcategory" field was cleared in this mutation.
func (m *ControlHistoryMutation) SubcategoryCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldSubcategory]
	return ok
}

// ResetSubcategory resets all changes to the "subcategory" field.
func (m *ControlHistoryMutation) ResetSubcategory() {
	m.subcategory = nil
	delete(m.clearedFields, controlhistory.FieldSubcategory)
}

// SetMappedCategories sets the "mapped_categories" field.
func (m *ControlHistoryMutation) SetMappedCategories(s []string) {
	m.mapped_categories = &s
	m.appendmapped_categories = nil
}

// MappedCategories returns the value of the "mapped_categories" field in the mutation.
func (m *ControlHistoryMutation) MappedCategories() (r []string, exists bool) {
	v := m.mapped_categories
	if v == nil {
		return
	}
	return *v, true
}

// OldMappedCategories returns the old "mapped_categories" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldMappedCategories(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappedCategories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappedCategories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappedCategories: %w", err)
	}
	return oldValue.MappedCategories, nil
}

// AppendMappedCategories adds s to the "mapped_categories" field.
func (m *ControlHistoryMutation) AppendMappedCategories(s []string) {
	m.appendmapped_categories = append(m.appendmapped_categories, s...)
}

// AppendedMappedCategories returns the list of values that were appended to the "mapped_categories" field in this mutation.
func (m *ControlHistoryMutation) AppendedMappedCategories() ([]string, bool) {
	if len(m.appendmapped_categories) == 0 {
		return nil, false
	}
	return m.appendmapped_categories, true
}

// ClearMappedCategories clears the value of the "mapped_categories" field.
func (m *ControlHistoryMutation) ClearMappedCategories() {
	m.mapped_categories = nil
	m.appendmapped_categories = nil
	m.clearedFields[controlhistory.FieldMappedCategories] = struct{}{}
}

// MappedCategoriesCleared returns if the "mapped_categories" field was cleared in this mutation.
func (m *ControlHistoryMutation) MappedCategoriesCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldMappedCategories]
	return ok
}

// ResetMappedCategories resets all changes to the "mapped_categories" field.
func (m *ControlHistoryMutation) ResetMappedCategories() {
	m.mapped_categories = nil
	m.appendmapped_categories = nil
	delete(m.clearedFields, controlhistory.FieldMappedCategories)
}

// SetAssessmentObjectives sets the "assessment_objectives" field.
func (m *ControlHistoryMutation) SetAssessmentObjectives(mo []models.AssessmentObjective) {
	m.assessment_objectives = &mo
	m.appendassessment_objectives = nil
}

// AssessmentObjectives returns the value of the "assessment_objectives" field in the mutation.
func (m *ControlHistoryMutation) AssessmentObjectives() (r []models.AssessmentObjective, exists bool) {
	v := m.assessment_objectives
	if v == nil {
		return
	}
	return *v, true
}

// OldAssessmentObjectives returns the old "assessment_objectives" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldAssessmentObjectives(ctx context.Context) (v []models.AssessmentObjective, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssessmentObjectives is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssessmentObjectives requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssessmentObjectives: %w", err)
	}
	return oldValue.AssessmentObjectives, nil
}

// AppendAssessmentObjectives adds mo to the "assessment_objectives" field.
func (m *ControlHistoryMutation) AppendAssessmentObjectives(mo []models.AssessmentObjective) {
	m.appendassessment_objectives = append(m.appendassessment_objectives, mo...)
}

// AppendedAssessmentObjectives returns the list of values that were appended to the "assessment_objectives" field in this mutation.
func (m *ControlHistoryMutation) AppendedAssessmentObjectives() ([]models.AssessmentObjective, bool) {
	if len(m.appendassessment_objectives) == 0 {
		return nil, false
	}
	return m.appendassessment_objectives, true
}

// ClearAssessmentObjectives clears the value of the "assessment_objectives" field.
func (m *ControlHistoryMutation) ClearAssessmentObjectives() {
	m.assessment_objectives = nil
	m.appendassessment_objectives = nil
	m.clearedFields[controlhistory.FieldAssessmentObjectives] = struct{}{}
}

// AssessmentObjectivesCleared returns if the "assessment_objectives" field was cleared in this mutation.
func (m *ControlHistoryMutation) AssessmentObjectivesCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldAssessmentObjectives]
	return ok
}

// ResetAssessmentObjectives resets all changes to the "assessment_objectives" field.
func (m *ControlHistoryMutation) ResetAssessmentObjectives() {
	m.assessment_objectives = nil
	m.appendassessment_objectives = nil
	delete(m.clearedFields, controlhistory.FieldAssessmentObjectives)
}

// SetAssessmentMethods sets the "assessment_methods" field.
func (m *ControlHistoryMutation) SetAssessmentMethods(mm []models.AssessmentMethod) {
	m.assessment_methods = &mm
	m.appendassessment_methods = nil
}

// AssessmentMethods returns the value of the "assessment_methods" field in the mutation.
func (m *ControlHistoryMutation) AssessmentMethods() (r []models.AssessmentMethod, exists bool) {
	v := m.assessment_methods
	if v == nil {
		return
	}
	return *v, true
}

// OldAssessmentMethods returns the old "assessment_methods" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldAssessmentMethods(ctx context.Context) (v []models.AssessmentMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssessmentMethods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssessmentMethods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssessmentMethods: %w", err)
	}
	return oldValue.AssessmentMethods, nil
}

// AppendAssessmentMethods adds mm to the "assessment_methods" field.
func (m *ControlHistoryMutation) AppendAssessmentMethods(mm []models.AssessmentMethod) {
	m.appendassessment_methods = append(m.appendassessment_methods, mm...)
}

// AppendedAssessmentMethods returns the list of values that were appended to the "assessment_methods" field in this mutation.
func (m *ControlHistoryMutation) AppendedAssessmentMethods() ([]models.AssessmentMethod, bool) {
	if len(m.appendassessment_methods) == 0 {
		return nil, false
	}
	return m.appendassessment_methods, true
}

// ClearAssessmentMethods clears the value of the "assessment_methods" field.
func (m *ControlHistoryMutation) ClearAssessmentMethods() {
	m.assessment_methods = nil
	m.appendassessment_methods = nil
	m.clearedFields[controlhistory.FieldAssessmentMethods] = struct{}{}
}

// AssessmentMethodsCleared returns if the "assessment_methods" field was cleared in this mutation.
func (m *ControlHistoryMutation) AssessmentMethodsCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldAssessmentMethods]
	return ok
}

// ResetAssessmentMethods resets all changes to the "assessment_methods" field.
func (m *ControlHistoryMutation) ResetAssessmentMethods() {
	m.assessment_methods = nil
	m.appendassessment_methods = nil
	delete(m.clearedFields, controlhistory.FieldAssessmentMethods)
}

// SetControlQuestions sets the "control_questions" field.
func (m *ControlHistoryMutation) SetControlQuestions(s []string) {
	m.control_questions = &s
	m.appendcontrol_questions = nil
}

// ControlQuestions returns the value of the "control_questions" field in the mutation.
func (m *ControlHistoryMutation) ControlQuestions() (r []string, exists bool) {
	v := m.control_questions
	if v == nil {
		return
	}
	return *v, true
}

// OldControlQuestions returns the old "control_questions" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldControlQuestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlQuestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlQuestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlQuestions: %w", err)
	}
	return oldValue.ControlQuestions, nil
}

// AppendControlQuestions adds s to the "control_questions" field.
func (m *ControlHistoryMutation) AppendControlQuestions(s []string) {
	m.appendcontrol_questions = append(m.appendcontrol_questions, s...)
}

// AppendedControlQuestions returns the list of values that were appended to the "control_questions" field in this mutation.
func (m *ControlHistoryMutation) AppendedControlQuestions() ([]string, bool) {
	if len(m.appendcontrol_questions) == 0 {
		return nil, false
	}
	return m.appendcontrol_questions, true
}

// ClearControlQuestions clears the value of the "control_questions" field.
func (m *ControlHistoryMutation) ClearControlQuestions() {
	m.control_questions = nil
	m.appendcontrol_questions = nil
	m.clearedFields[controlhistory.FieldControlQuestions] = struct{}{}
}

// ControlQuestionsCleared returns if the "control_questions" field was cleared in this mutation.
func (m *ControlHistoryMutation) ControlQuestionsCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldControlQuestions]
	return ok
}

// ResetControlQuestions resets all changes to the "control_questions" field.
func (m *ControlHistoryMutation) ResetControlQuestions() {
	m.control_questions = nil
	m.appendcontrol_questions = nil
	delete(m.clearedFields, controlhistory.FieldControlQuestions)
}

// SetImplementationGuidance sets the "implementation_guidance" field.
func (m *ControlHistoryMutation) SetImplementationGuidance(mg []models.ImplementationGuidance) {
	m.implementation_guidance = &mg
	m.appendimplementation_guidance = nil
}

// ImplementationGuidance returns the value of the "implementation_guidance" field in the mutation.
func (m *ControlHistoryMutation) ImplementationGuidance() (r []models.ImplementationGuidance, exists bool) {
	v := m.implementation_guidance
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementationGuidance returns the old "implementation_guidance" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldImplementationGuidance(ctx context.Context) (v []models.ImplementationGuidance, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementationGuidance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementationGuidance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementationGuidance: %w", err)
	}
	return oldValue.ImplementationGuidance, nil
}

// AppendImplementationGuidance adds mg to the "implementation_guidance" field.
func (m *ControlHistoryMutation) AppendImplementationGuidance(mg []models.ImplementationGuidance) {
	m.appendimplementation_guidance = append(m.appendimplementation_guidance, mg...)
}

// AppendedImplementationGuidance returns the list of values that were appended to the "implementation_guidance" field in this mutation.
func (m *ControlHistoryMutation) AppendedImplementationGuidance() ([]models.ImplementationGuidance, bool) {
	if len(m.appendimplementation_guidance) == 0 {
		return nil, false
	}
	return m.appendimplementation_guidance, true
}

// ClearImplementationGuidance clears the value of the "implementation_guidance" field.
func (m *ControlHistoryMutation) ClearImplementationGuidance() {
	m.implementation_guidance = nil
	m.appendimplementation_guidance = nil
	m.clearedFields[controlhistory.FieldImplementationGuidance] = struct{}{}
}

// ImplementationGuidanceCleared returns if the "implementation_guidance" field was cleared in this mutation.
func (m *ControlHistoryMutation) ImplementationGuidanceCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldImplementationGuidance]
	return ok
}

// ResetImplementationGuidance resets all changes to the "implementation_guidance" field.
func (m *ControlHistoryMutation) ResetImplementationGuidance() {
	m.implementation_guidance = nil
	m.appendimplementation_guidance = nil
	delete(m.clearedFields, controlhistory.FieldImplementationGuidance)
}

// SetExampleEvidence sets the "example_evidence" field.
func (m *ControlHistoryMutation) SetExampleEvidence(me []models.ExampleEvidence) {
	m.example_evidence = &me
	m.appendexample_evidence = nil
}

// ExampleEvidence returns the value of the "example_evidence" field in the mutation.
func (m *ControlHistoryMutation) ExampleEvidence() (r []models.ExampleEvidence, exists bool) {
	v := m.example_evidence
	if v == nil {
		return
	}
	return *v, true
}

// OldExampleEvidence returns the old "example_evidence" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldExampleEvidence(ctx context.Context) (v []models.ExampleEvidence, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExampleEvidence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExampleEvidence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExampleEvidence: %w", err)
	}
	return oldValue.ExampleEvidence, nil
}

// AppendExampleEvidence adds me to the "example_evidence" field.
func (m *ControlHistoryMutation) AppendExampleEvidence(me []models.ExampleEvidence) {
	m.appendexample_evidence = append(m.appendexample_evidence, me...)
}

// AppendedExampleEvidence returns the list of values that were appended to the "example_evidence" field in this mutation.
func (m *ControlHistoryMutation) AppendedExampleEvidence() ([]models.ExampleEvidence, bool) {
	if len(m.appendexample_evidence) == 0 {
		return nil, false
	}
	return m.appendexample_evidence, true
}

// ClearExampleEvidence clears the value of the "example_evidence" field.
func (m *ControlHistoryMutation) ClearExampleEvidence() {
	m.example_evidence = nil
	m.appendexample_evidence = nil
	m.clearedFields[controlhistory.FieldExampleEvidence] = struct{}{}
}

// ExampleEvidenceCleared returns if the "example_evidence" field was cleared in this mutation.
func (m *ControlHistoryMutation) ExampleEvidenceCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldExampleEvidence]
	return ok
}

// ResetExampleEvidence resets all changes to the "example_evidence" field.
func (m *ControlHistoryMutation) ResetExampleEvidence() {
	m.example_evidence = nil
	m.appendexample_evidence = nil
	delete(m.clearedFields, controlhistory.FieldExampleEvidence)
}

// SetReferences sets the "references" field.
func (m *ControlHistoryMutation) SetReferences(value []models.Reference) {
	m.references = &value
	m.appendreferences = nil
}

// References returns the value of the "references" field in the mutation.
func (m *ControlHistoryMutation) References() (r []models.Reference, exists bool) {
	v := m.references
	if v == nil {
		return
	}
	return *v, true
}

// OldReferences returns the old "references" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldReferences(ctx context.Context) (v []models.Reference, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferences: %w", err)
	}
	return oldValue.References, nil
}

// AppendReferences adds value to the "references" field.
func (m *ControlHistoryMutation) AppendReferences(value []models.Reference) {
	m.appendreferences = append(m.appendreferences, value...)
}

// AppendedReferences returns the list of values that were appended to the "references" field in this mutation.
func (m *ControlHistoryMutation) AppendedReferences() ([]models.Reference, bool) {
	if len(m.appendreferences) == 0 {
		return nil, false
	}
	return m.appendreferences, true
}

// ClearReferences clears the value of the "references" field.
func (m *ControlHistoryMutation) ClearReferences() {
	m.references = nil
	m.appendreferences = nil
	m.clearedFields[controlhistory.FieldReferences] = struct{}{}
}

// ReferencesCleared returns if the "references" field was cleared in this mutation.
func (m *ControlHistoryMutation) ReferencesCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldReferences]
	return ok
}

// ResetReferences resets all changes to the "references" field.
func (m *ControlHistoryMutation) ResetReferences() {
	m.references = nil
	m.appendreferences = nil
	delete(m.clearedFields, controlhistory.FieldReferences)
}

// SetControlOwnerID sets the "control_owner_id" field.
func (m *ControlHistoryMutation) SetControlOwnerID(s string) {
	m.control_owner_id = &s
}

// ControlOwnerID returns the value of the "control_owner_id" field in the mutation.
func (m *ControlHistoryMutation) ControlOwnerID() (r string, exists bool) {
	v := m.control_owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldControlOwnerID returns the old "control_owner_id" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldControlOwnerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlOwnerID: %w", err)
	}
	return oldValue.ControlOwnerID, nil
}

// ClearControlOwnerID clears the value of the "control_owner_id" field.
func (m *ControlHistoryMutation) ClearControlOwnerID() {
	m.control_owner_id = nil
	m.clearedFields[controlhistory.FieldControlOwnerID] = struct{}{}
}

// ControlOwnerIDCleared returns if the "control_owner_id" field was cleared in this mutation.
func (m *ControlHistoryMutation) ControlOwnerIDCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldControlOwnerID]
	return ok
}

// ResetControlOwnerID resets all changes to the "control_owner_id" field.
func (m *ControlHistoryMutation) ResetControlOwnerID() {
	m.control_owner_id = nil
	delete(m.clearedFields, controlhistory.FieldControlOwnerID)
}

// SetDelegateID sets the "delegate_id" field.
func (m *ControlHistoryMutation) SetDelegateID(s string) {
	m.delegate_id = &s
}

// DelegateID returns the value of the "delegate_id" field in the mutation.
func (m *ControlHistoryMutation) DelegateID() (r string, exists bool) {
	v := m.delegate_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegateID returns the old "delegate_id" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldDelegateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelegateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelegateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegateID: %w", err)
	}
	return oldValue.DelegateID, nil
}

// ClearDelegateID clears the value of the "delegate_id" field.
func (m *ControlHistoryMutation) ClearDelegateID() {
	m.delegate_id = nil
	m.clearedFields[controlhistory.FieldDelegateID] = struct{}{}
}

// DelegateIDCleared returns if the "delegate_id" field was cleared in this mutation.
func (m *ControlHistoryMutation) DelegateIDCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldDelegateID]
	return ok
}

// ResetDelegateID resets all changes to the "delegate_id" field.
func (m *ControlHistoryMutation) ResetDelegateID() {
	m.delegate_id = nil
	delete(m.clearedFields, controlhistory.FieldDelegateID)
}

// SetOwnerID sets the "owner_id" field.
func (m *ControlHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ControlHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *ControlHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[controlhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *ControlHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ControlHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, controlhistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *ControlHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *ControlHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *ControlHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[controlhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *ControlHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *ControlHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, controlhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *ControlHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *ControlHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *ControlHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[controlhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *ControlHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *ControlHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, controlhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *ControlHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *ControlHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *ControlHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[controlhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *ControlHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *ControlHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, controlhistory.FieldSystemInternalID)
}

// SetControlKindName sets the "control_kind_name" field.
func (m *ControlHistoryMutation) SetControlKindName(s string) {
	m.control_kind_name = &s
}

// ControlKindName returns the value of the "control_kind_name" field in the mutation.
func (m *ControlHistoryMutation) ControlKindName() (r string, exists bool) {
	v := m.control_kind_name
	if v == nil {
		return
	}
	return *v, true
}

// OldControlKindName returns the old "control_kind_name" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldControlKindName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlKindName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlKindName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlKindName: %w", err)
	}
	return oldValue.ControlKindName, nil
}

// ClearControlKindName clears the value of the "control_kind_name" field.
func (m *ControlHistoryMutation) ClearControlKindName() {
	m.control_kind_name = nil
	m.clearedFields[controlhistory.FieldControlKindName] = struct{}{}
}

// ControlKindNameCleared returns if the "control_kind_name" field was cleared in this mutation.
func (m *ControlHistoryMutation) ControlKindNameCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldControlKindName]
	return ok
}

// ResetControlKindName resets all changes to the "control_kind_name" field.
func (m *ControlHistoryMutation) ResetControlKindName() {
	m.control_kind_name = nil
	delete(m.clearedFields, controlhistory.FieldControlKindName)
}

// SetControlKindID sets the "control_kind_id" field.
func (m *ControlHistoryMutation) SetControlKindID(s string) {
	m.control_kind_id = &s
}

// ControlKindID returns the value of the "control_kind_id" field in the mutation.
func (m *ControlHistoryMutation) ControlKindID() (r string, exists bool) {
	v := m.control_kind_id
	if v == nil {
		return
	}
	return *v, true
}

// OldControlKindID returns the old "control_kind_id" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldControlKindID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlKindID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlKindID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlKindID: %w", err)
	}
	return oldValue.ControlKindID, nil
}

// ClearControlKindID clears the value of the "control_kind_id" field.
func (m *ControlHistoryMutation) ClearControlKindID() {
	m.control_kind_id = nil
	m.clearedFields[controlhistory.FieldControlKindID] = struct{}{}
}

// ControlKindIDCleared returns if the "control_kind_id" field was cleared in this mutation.
func (m *ControlHistoryMutation) ControlKindIDCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldControlKindID]
	return ok
}

// ResetControlKindID resets all changes to the "control_kind_id" field.
func (m *ControlHistoryMutation) ResetControlKindID() {
	m.control_kind_id = nil
	delete(m.clearedFields, controlhistory.FieldControlKindID)
}

// SetRefCode sets the "ref_code" field.
func (m *ControlHistoryMutation) SetRefCode(s string) {
	m.ref_code = &s
}

// RefCode returns the value of the "ref_code" field in the mutation.
func (m *ControlHistoryMutation) RefCode() (r string, exists bool) {
	v := m.ref_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRefCode returns the old "ref_code" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldRefCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefCode: %w", err)
	}
	return oldValue.RefCode, nil
}

// ResetRefCode resets all changes to the "ref_code" field.
func (m *ControlHistoryMutation) ResetRefCode() {
	m.ref_code = nil
}

// SetStandardID sets the "standard_id" field.
func (m *ControlHistoryMutation) SetStandardID(s string) {
	m.standard_id = &s
}

// StandardID returns the value of the "standard_id" field in the mutation.
func (m *ControlHistoryMutation) StandardID() (r string, exists bool) {
	v := m.standard_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStandardID returns the old "standard_id" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldStandardID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStandardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStandardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStandardID: %w", err)
	}
	return oldValue.StandardID, nil
}

// ClearStandardID clears the value of the "standard_id" field.
func (m *ControlHistoryMutation) ClearStandardID() {
	m.standard_id = nil
	m.clearedFields[controlhistory.FieldStandardID] = struct{}{}
}

// StandardIDCleared returns if the "standard_id" field was cleared in this mutation.
func (m *ControlHistoryMutation) StandardIDCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldStandardID]
	return ok
}

// ResetStandardID resets all changes to the "standard_id" field.
func (m *ControlHistoryMutation) ResetStandardID() {
	m.standard_id = nil
	delete(m.clearedFields, controlhistory.FieldStandardID)
}

// Where appends a list predicates to the ControlHistoryMutation builder.
func (m *ControlHistoryMutation) Where(ps ...predicate.ControlHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ControlHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ControlHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ControlHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ControlHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ControlHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ControlHistory).
func (m *ControlHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ControlHistoryMutation) Fields() []string {
	fields := make([]string, 0, 42)
	if m.history_time != nil {
		fields = append(fields, controlhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, controlhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, controlhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, controlhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, controlhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, controlhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, controlhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, controlhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, controlhistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, controlhistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, controlhistory.FieldTags)
	}
	if m.title != nil {
		fields = append(fields, controlhistory.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, controlhistory.FieldDescription)
	}
	if m.aliases != nil {
		fields = append(fields, controlhistory.FieldAliases)
	}
	if m.reference_id != nil {
		fields = append(fields, controlhistory.FieldReferenceID)
	}
	if m.auditor_reference_id != nil {
		fields = append(fields, controlhistory.FieldAuditorReferenceID)
	}
	if m.responsible_party_id != nil {
		fields = append(fields, controlhistory.FieldResponsiblePartyID)
	}
	if m.status != nil {
		fields = append(fields, controlhistory.FieldStatus)
	}
	if m.source != nil {
		fields = append(fields, controlhistory.FieldSource)
	}
	if m.reference_framework != nil {
		fields = append(fields, controlhistory.FieldReferenceFramework)
	}
	if m.reference_framework_revision != nil {
		fields = append(fields, controlhistory.FieldReferenceFrameworkRevision)
	}
	if m.control_type != nil {
		fields = append(fields, controlhistory.FieldControlType)
	}
	if m.category != nil {
		fields = append(fields, controlhistory.FieldCategory)
	}
	if m.category_id != nil {
		fields = append(fields, controlhistory.FieldCategoryID)
	}
	if m.subcategory != nil {
		fields = append(fields, controlhistory.FieldSubcategory)
	}
	if m.mapped_categories != nil {
		fields = append(fields, controlhistory.FieldMappedCategories)
	}
	if m.assessment_objectives != nil {
		fields = append(fields, controlhistory.FieldAssessmentObjectives)
	}
	if m.assessment_methods != nil {
		fields = append(fields, controlhistory.FieldAssessmentMethods)
	}
	if m.control_questions != nil {
		fields = append(fields, controlhistory.FieldControlQuestions)
	}
	if m.implementation_guidance != nil {
		fields = append(fields, controlhistory.FieldImplementationGuidance)
	}
	if m.example_evidence != nil {
		fields = append(fields, controlhistory.FieldExampleEvidence)
	}
	if m.references != nil {
		fields = append(fields, controlhistory.FieldReferences)
	}
	if m.control_owner_id != nil {
		fields = append(fields, controlhistory.FieldControlOwnerID)
	}
	if m.delegate_id != nil {
		fields = append(fields, controlhistory.FieldDelegateID)
	}
	if m.owner_id != nil {
		fields = append(fields, controlhistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, controlhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, controlhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, controlhistory.FieldSystemInternalID)
	}
	if m.control_kind_name != nil {
		fields = append(fields, controlhistory.FieldControlKindName)
	}
	if m.control_kind_id != nil {
		fields = append(fields, controlhistory.FieldControlKindID)
	}
	if m.ref_code != nil {
		fields = append(fields, controlhistory.FieldRefCode)
	}
	if m.standard_id != nil {
		fields = append(fields, controlhistory.FieldStandardID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ControlHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case controlhistory.FieldHistoryTime:
		return m.HistoryTime()
	case controlhistory.FieldRef:
		return m.Ref()
	case controlhistory.FieldOperation:
		return m.Operation()
	case controlhistory.FieldCreatedAt:
		return m.CreatedAt()
	case controlhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case controlhistory.FieldCreatedBy:
		return m.CreatedBy()
	case controlhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case controlhistory.FieldDeletedAt:
		return m.DeletedAt()
	case controlhistory.FieldDeletedBy:
		return m.DeletedBy()
	case controlhistory.FieldDisplayID:
		return m.DisplayID()
	case controlhistory.FieldTags:
		return m.Tags()
	case controlhistory.FieldTitle:
		return m.Title()
	case controlhistory.FieldDescription:
		return m.Description()
	case controlhistory.FieldAliases:
		return m.Aliases()
	case controlhistory.FieldReferenceID:
		return m.ReferenceID()
	case controlhistory.FieldAuditorReferenceID:
		return m.AuditorReferenceID()
	case controlhistory.FieldResponsiblePartyID:
		return m.ResponsiblePartyID()
	case controlhistory.FieldStatus:
		return m.Status()
	case controlhistory.FieldSource:
		return m.Source()
	case controlhistory.FieldReferenceFramework:
		return m.ReferenceFramework()
	case controlhistory.FieldReferenceFrameworkRevision:
		return m.ReferenceFrameworkRevision()
	case controlhistory.FieldControlType:
		return m.ControlType()
	case controlhistory.FieldCategory:
		return m.Category()
	case controlhistory.FieldCategoryID:
		return m.CategoryID()
	case controlhistory.FieldSubcategory:
		return m.Subcategory()
	case controlhistory.FieldMappedCategories:
		return m.MappedCategories()
	case controlhistory.FieldAssessmentObjectives:
		return m.AssessmentObjectives()
	case controlhistory.FieldAssessmentMethods:
		return m.AssessmentMethods()
	case controlhistory.FieldControlQuestions:
		return m.ControlQuestions()
	case controlhistory.FieldImplementationGuidance:
		return m.ImplementationGuidance()
	case controlhistory.FieldExampleEvidence:
		return m.ExampleEvidence()
	case controlhistory.FieldReferences:
		return m.References()
	case controlhistory.FieldControlOwnerID:
		return m.ControlOwnerID()
	case controlhistory.FieldDelegateID:
		return m.DelegateID()
	case controlhistory.FieldOwnerID:
		return m.OwnerID()
	case controlhistory.FieldSystemOwned:
		return m.SystemOwned()
	case controlhistory.FieldInternalNotes:
		return m.InternalNotes()
	case controlhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case controlhistory.FieldControlKindName:
		return m.ControlKindName()
	case controlhistory.FieldControlKindID:
		return m.ControlKindID()
	case controlhistory.FieldRefCode:
		return m.RefCode()
	case controlhistory.FieldStandardID:
		return m.StandardID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ControlHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case controlhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case controlhistory.FieldRef:
		return m.OldRef(ctx)
	case controlhistory.FieldOperation:
		return m.OldOperation(ctx)
	case controlhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case controlhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case controlhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case controlhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case controlhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case controlhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case controlhistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case controlhistory.FieldTags:
		return m.OldTags(ctx)
	case controlhistory.FieldTitle:
		return m.OldTitle(ctx)
	case controlhistory.FieldDescription:
		return m.OldDescription(ctx)
	case controlhistory.FieldAliases:
		return m.OldAliases(ctx)
	case controlhistory.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case controlhistory.FieldAuditorReferenceID:
		return m.OldAuditorReferenceID(ctx)
	case controlhistory.FieldResponsiblePartyID:
		return m.OldResponsiblePartyID(ctx)
	case controlhistory.FieldStatus:
		return m.OldStatus(ctx)
	case controlhistory.FieldSource:
		return m.OldSource(ctx)
	case controlhistory.FieldReferenceFramework:
		return m.OldReferenceFramework(ctx)
	case controlhistory.FieldReferenceFrameworkRevision:
		return m.OldReferenceFrameworkRevision(ctx)
	case controlhistory.FieldControlType:
		return m.OldControlType(ctx)
	case controlhistory.FieldCategory:
		return m.OldCategory(ctx)
	case controlhistory.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case controlhistory.FieldSubcategory:
		return m.OldSubcategory(ctx)
	case controlhistory.FieldMappedCategories:
		return m.OldMappedCategories(ctx)
	case controlhistory.FieldAssessmentObjectives:
		return m.OldAssessmentObjectives(ctx)
	case controlhistory.FieldAssessmentMethods:
		return m.OldAssessmentMethods(ctx)
	case controlhistory.FieldControlQuestions:
		return m.OldControlQuestions(ctx)
	case controlhistory.FieldImplementationGuidance:
		return m.OldImplementationGuidance(ctx)
	case controlhistory.FieldExampleEvidence:
		return m.OldExampleEvidence(ctx)
	case controlhistory.FieldReferences:
		return m.OldReferences(ctx)
	case controlhistory.FieldControlOwnerID:
		return m.OldControlOwnerID(ctx)
	case controlhistory.FieldDelegateID:
		return m.OldDelegateID(ctx)
	case controlhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case controlhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case controlhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case controlhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case controlhistory.FieldControlKindName:
		return m.OldControlKindName(ctx)
	case controlhistory.FieldControlKindID:
		return m.OldControlKindID(ctx)
	case controlhistory.FieldRefCode:
		return m.OldRefCode(ctx)
	case controlhistory.FieldStandardID:
		return m.OldStandardID(ctx)
	}
	return nil, fmt.Errorf("unknown ControlHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ControlHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case controlhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case controlhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case controlhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case controlhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case controlhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case controlhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case controlhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case controlhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case controlhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case controlhistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case controlhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case controlhistory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case controlhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case controlhistory.FieldAliases:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAliases(v)
		return nil
	case controlhistory.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case controlhistory.FieldAuditorReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditorReferenceID(v)
		return nil
	case controlhistory.FieldResponsiblePartyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponsiblePartyID(v)
		return nil
	case controlhistory.FieldStatus:
		v, ok := value.(enums.ControlStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case controlhistory.FieldSource:
		v, ok := value.(enums.ControlSource)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case controlhistory.FieldReferenceFramework:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceFramework(v)
		return nil
	case controlhistory.FieldReferenceFrameworkRevision:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceFrameworkRevision(v)
		return nil
	case controlhistory.FieldControlType:
		v, ok := value.(enums.ControlType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlType(v)
		return nil
	case controlhistory.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case controlhistory.FieldCategoryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case controlhistory.FieldSubcategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubcategory(v)
		return nil
	case controlhistory.FieldMappedCategories:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappedCategories(v)
		return nil
	case controlhistory.FieldAssessmentObjectives:
		v, ok := value.([]models.AssessmentObjective)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssessmentObjectives(v)
		return nil
	case controlhistory.FieldAssessmentMethods:
		v, ok := value.([]models.AssessmentMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssessmentMethods(v)
		return nil
	case controlhistory.FieldControlQuestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlQuestions(v)
		return nil
	case controlhistory.FieldImplementationGuidance:
		v, ok := value.([]models.ImplementationGuidance)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementationGuidance(v)
		return nil
	case controlhistory.FieldExampleEvidence:
		v, ok := value.([]models.ExampleEvidence)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExampleEvidence(v)
		return nil
	case controlhistory.FieldReferences:
		v, ok := value.([]models.Reference)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferences(v)
		return nil
	case controlhistory.FieldControlOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlOwnerID(v)
		return nil
	case controlhistory.FieldDelegateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegateID(v)
		return nil
	case controlhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case controlhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case controlhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case controlhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case controlhistory.FieldControlKindName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlKindName(v)
		return nil
	case controlhistory.FieldControlKindID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlKindID(v)
		return nil
	case controlhistory.FieldRefCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefCode(v)
		return nil
	case controlhistory.FieldStandardID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStandardID(v)
		return nil
	}
	return fmt.Errorf("unknown ControlHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ControlHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ControlHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ControlHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ControlHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ControlHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(controlhistory.FieldRef) {
		fields = append(fields, controlhistory.FieldRef)
	}
	if m.FieldCleared(controlhistory.FieldCreatedAt) {
		fields = append(fields, controlhistory.FieldCreatedAt)
	}
	if m.FieldCleared(controlhistory.FieldUpdatedAt) {
		fields = append(fields, controlhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(controlhistory.FieldCreatedBy) {
		fields = append(fields, controlhistory.FieldCreatedBy)
	}
	if m.FieldCleared(controlhistory.FieldUpdatedBy) {
		fields = append(fields, controlhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(controlhistory.FieldDeletedAt) {
		fields = append(fields, controlhistory.FieldDeletedAt)
	}
	if m.FieldCleared(controlhistory.FieldDeletedBy) {
		fields = append(fields, controlhistory.FieldDeletedBy)
	}
	if m.FieldCleared(controlhistory.FieldTags) {
		fields = append(fields, controlhistory.FieldTags)
	}
	if m.FieldCleared(controlhistory.FieldTitle) {
		fields = append(fields, controlhistory.FieldTitle)
	}
	if m.FieldCleared(controlhistory.FieldDescription) {
		fields = append(fields, controlhistory.FieldDescription)
	}
	if m.FieldCleared(controlhistory.FieldAliases) {
		fields = append(fields, controlhistory.FieldAliases)
	}
	if m.FieldCleared(controlhistory.FieldReferenceID) {
		fields = append(fields, controlhistory.FieldReferenceID)
	}
	if m.FieldCleared(controlhistory.FieldAuditorReferenceID) {
		fields = append(fields, controlhistory.FieldAuditorReferenceID)
	}
	if m.FieldCleared(controlhistory.FieldResponsiblePartyID) {
		fields = append(fields, controlhistory.FieldResponsiblePartyID)
	}
	if m.FieldCleared(controlhistory.FieldStatus) {
		fields = append(fields, controlhistory.FieldStatus)
	}
	if m.FieldCleared(controlhistory.FieldSource) {
		fields = append(fields, controlhistory.FieldSource)
	}
	if m.FieldCleared(controlhistory.FieldReferenceFramework) {
		fields = append(fields, controlhistory.FieldReferenceFramework)
	}
	if m.FieldCleared(controlhistory.FieldReferenceFrameworkRevision) {
		fields = append(fields, controlhistory.FieldReferenceFrameworkRevision)
	}
	if m.FieldCleared(controlhistory.FieldControlType) {
		fields = append(fields, controlhistory.FieldControlType)
	}
	if m.FieldCleared(controlhistory.FieldCategory) {
		fields = append(fields, controlhistory.FieldCategory)
	}
	if m.FieldCleared(controlhistory.FieldCategoryID) {
		fields = append(fields, controlhistory.FieldCategoryID)
	}
	if m.FieldCleared(controlhistory.FieldSubcategory) {
		fields = append(fields, controlhistory.FieldSubcategory)
	}
	if m.FieldCleared(controlhistory.FieldMappedCategories) {
		fields = append(fields, controlhistory.FieldMappedCategories)
	}
	if m.FieldCleared(controlhistory.FieldAssessmentObjectives) {
		fields = append(fields, controlhistory.FieldAssessmentObjectives)
	}
	if m.FieldCleared(controlhistory.FieldAssessmentMethods) {
		fields = append(fields, controlhistory.FieldAssessmentMethods)
	}
	if m.FieldCleared(controlhistory.FieldControlQuestions) {
		fields = append(fields, controlhistory.FieldControlQuestions)
	}
	if m.FieldCleared(controlhistory.FieldImplementationGuidance) {
		fields = append(fields, controlhistory.FieldImplementationGuidance)
	}
	if m.FieldCleared(controlhistory.FieldExampleEvidence) {
		fields = append(fields, controlhistory.FieldExampleEvidence)
	}
	if m.FieldCleared(controlhistory.FieldReferences) {
		fields = append(fields, controlhistory.FieldReferences)
	}
	if m.FieldCleared(controlhistory.FieldControlOwnerID) {
		fields = append(fields, controlhistory.FieldControlOwnerID)
	}
	if m.FieldCleared(controlhistory.FieldDelegateID) {
		fields = append(fields, controlhistory.FieldDelegateID)
	}
	if m.FieldCleared(controlhistory.FieldOwnerID) {
		fields = append(fields, controlhistory.FieldOwnerID)
	}
	if m.FieldCleared(controlhistory.FieldSystemOwned) {
		fields = append(fields, controlhistory.FieldSystemOwned)
	}
	if m.FieldCleared(controlhistory.FieldInternalNotes) {
		fields = append(fields, controlhistory.FieldInternalNotes)
	}
	if m.FieldCleared(controlhistory.FieldSystemInternalID) {
		fields = append(fields, controlhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(controlhistory.FieldControlKindName) {
		fields = append(fields, controlhistory.FieldControlKindName)
	}
	if m.FieldCleared(controlhistory.FieldControlKindID) {
		fields = append(fields, controlhistory.FieldControlKindID)
	}
	if m.FieldCleared(controlhistory.FieldStandardID) {
		fields = append(fields, controlhistory.FieldStandardID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ControlHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ControlHistoryMutation) ClearField(name string) error {
	switch name {
	case controlhistory.FieldRef:
		m.ClearRef()
		return nil
	case controlhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case controlhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case controlhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case controlhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case controlhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case controlhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case controlhistory.FieldTags:
		m.ClearTags()
		return nil
	case controlhistory.FieldTitle:
		m.ClearTitle()
		return nil
	case controlhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case controlhistory.FieldAliases:
		m.ClearAliases()
		return nil
	case controlhistory.FieldReferenceID:
		m.ClearReferenceID()
		return nil
	case controlhistory.FieldAuditorReferenceID:
		m.ClearAuditorReferenceID()
		return nil
	case controlhistory.FieldResponsiblePartyID:
		m.ClearResponsiblePartyID()
		return nil
	case controlhistory.FieldStatus:
		m.ClearStatus()
		return nil
	case controlhistory.FieldSource:
		m.ClearSource()
		return nil
	case controlhistory.FieldReferenceFramework:
		m.ClearReferenceFramework()
		return nil
	case controlhistory.FieldReferenceFrameworkRevision:
		m.ClearReferenceFrameworkRevision()
		return nil
	case controlhistory.FieldControlType:
		m.ClearControlType()
		return nil
	case controlhistory.FieldCategory:
		m.ClearCategory()
		return nil
	case controlhistory.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case controlhistory.FieldSubcategory:
		m.ClearSubcategory()
		return nil
	case controlhistory.FieldMappedCategories:
		m.ClearMappedCategories()
		return nil
	case controlhistory.FieldAssessmentObjectives:
		m.ClearAssessmentObjectives()
		return nil
	case controlhistory.FieldAssessmentMethods:
		m.ClearAssessmentMethods()
		return nil
	case controlhistory.FieldControlQuestions:
		m.ClearControlQuestions()
		return nil
	case controlhistory.FieldImplementationGuidance:
		m.ClearImplementationGuidance()
		return nil
	case controlhistory.FieldExampleEvidence:
		m.ClearExampleEvidence()
		return nil
	case controlhistory.FieldReferences:
		m.ClearReferences()
		return nil
	case controlhistory.FieldControlOwnerID:
		m.ClearControlOwnerID()
		return nil
	case controlhistory.FieldDelegateID:
		m.ClearDelegateID()
		return nil
	case controlhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case controlhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case controlhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case controlhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case controlhistory.FieldControlKindName:
		m.ClearControlKindName()
		return nil
	case controlhistory.FieldControlKindID:
		m.ClearControlKindID()
		return nil
	case controlhistory.FieldStandardID:
		m.ClearStandardID()
		return nil
	}
	return fmt.Errorf("unknown ControlHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ControlHistoryMutation) ResetField(name string) error {
	switch name {
	case controlhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case controlhistory.FieldRef:
		m.ResetRef()
		return nil
	case controlhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case controlhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case controlhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case controlhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case controlhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case controlhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case controlhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case controlhistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case controlhistory.FieldTags:
		m.ResetTags()
		return nil
	case controlhistory.FieldTitle:
		m.ResetTitle()
		return nil
	case controlhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case controlhistory.FieldAliases:
		m.ResetAliases()
		return nil
	case controlhistory.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case controlhistory.FieldAuditorReferenceID:
		m.ResetAuditorReferenceID()
		return nil
	case controlhistory.FieldResponsiblePartyID:
		m.ResetResponsiblePartyID()
		return nil
	case controlhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case controlhistory.FieldSource:
		m.ResetSource()
		return nil
	case controlhistory.FieldReferenceFramework:
		m.ResetReferenceFramework()
		return nil
	case controlhistory.FieldReferenceFrameworkRevision:
		m.ResetReferenceFrameworkRevision()
		return nil
	case controlhistory.FieldControlType:
		m.ResetControlType()
		return nil
	case controlhistory.FieldCategory:
		m.ResetCategory()
		return nil
	case controlhistory.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case controlhistory.FieldSubcategory:
		m.ResetSubcategory()
		return nil
	case controlhistory.FieldMappedCategories:
		m.ResetMappedCategories()
		return nil
	case controlhistory.FieldAssessmentObjectives:
		m.ResetAssessmentObjectives()
		return nil
	case controlhistory.FieldAssessmentMethods:
		m.ResetAssessmentMethods()
		return nil
	case controlhistory.FieldControlQuestions:
		m.ResetControlQuestions()
		return nil
	case controlhistory.FieldImplementationGuidance:
		m.ResetImplementationGuidance()
		return nil
	case controlhistory.FieldExampleEvidence:
		m.ResetExampleEvidence()
		return nil
	case controlhistory.FieldReferences:
		m.ResetReferences()
		return nil
	case controlhistory.FieldControlOwnerID:
		m.ResetControlOwnerID()
		return nil
	case controlhistory.FieldDelegateID:
		m.ResetDelegateID()
		return nil
	case controlhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case controlhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case controlhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case controlhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case controlhistory.FieldControlKindName:
		m.ResetControlKindName()
		return nil
	case controlhistory.FieldControlKindID:
		m.ResetControlKindID()
		return nil
	case controlhistory.FieldRefCode:
		m.ResetRefCode()
		return nil
	case controlhistory.FieldStandardID:
		m.ResetStandardID()
		return nil
	}
	return fmt.Errorf("unknown ControlHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ControlHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ControlHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ControlHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ControlHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ControlHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ControlHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ControlHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ControlHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ControlHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ControlHistory edge %s", name)
}

// ControlImplementationHistoryMutation represents an operation that mutates the ControlImplementationHistory nodes in the graph.
type ControlImplementationHistoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	history_time        *time.Time
	ref                 *string
	operation           *history.OpType
	created_at          *time.Time
	updated_at          *time.Time
	created_by          *string
	updated_by          *string
	deleted_at          *time.Time
	deleted_by          *string
	tags                *[]string
	appendtags          []string
	owner_id            *string
	system_owned        *bool
	internal_notes      *string
	system_internal_id  *string
	status              *enums.DocumentStatus
	implementation_date *time.Time
	verified            *bool
	verification_date   *time.Time
	details             *string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*ControlImplementationHistory, error)
	predicates          []predicate.ControlImplementationHistory
}

var _ ent.Mutation = (*ControlImplementationHistoryMutation)(nil)

// controlimplementationhistoryOption allows management of the mutation configuration using functional options.
type controlimplementationhistoryOption func(*ControlImplementationHistoryMutation)

// newControlImplementationHistoryMutation creates new mutation for the ControlImplementationHistory entity.
func newControlImplementationHistoryMutation(c config, op Op, opts ...controlimplementationhistoryOption) *ControlImplementationHistoryMutation {
	m := &ControlImplementationHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeControlImplementationHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withControlImplementationHistoryID sets the ID field of the mutation.
func withControlImplementationHistoryID(id string) controlimplementationhistoryOption {
	return func(m *ControlImplementationHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ControlImplementationHistory
		)
		m.oldValue = func(ctx context.Context) (*ControlImplementationHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ControlImplementationHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withControlImplementationHistory sets the old ControlImplementationHistory of the mutation.
func withControlImplementationHistory(node *ControlImplementationHistory) controlimplementationhistoryOption {
	return func(m *ControlImplementationHistoryMutation) {
		m.oldValue = func(context.Context) (*ControlImplementationHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ControlImplementationHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ControlImplementationHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ControlImplementationHistory entities.
func (m *ControlImplementationHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ControlImplementationHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ControlImplementationHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ControlImplementationHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ControlImplementationHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ControlImplementationHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ControlImplementationHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ControlImplementationHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ControlImplementationHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ControlImplementationHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[controlimplementationhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ControlImplementationHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, controlimplementationhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ControlImplementationHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ControlImplementationHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ControlImplementationHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ControlImplementationHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ControlImplementationHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ControlImplementationHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[controlimplementationhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ControlImplementationHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, controlimplementationhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ControlImplementationHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ControlImplementationHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ControlImplementationHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[controlimplementationhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ControlImplementationHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, controlimplementationhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ControlImplementationHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ControlImplementationHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ControlImplementationHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[controlimplementationhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ControlImplementationHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, controlimplementationhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ControlImplementationHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ControlImplementationHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ControlImplementationHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[controlimplementationhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ControlImplementationHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, controlimplementationhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ControlImplementationHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ControlImplementationHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ControlImplementationHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[controlimplementationhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ControlImplementationHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, controlimplementationhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ControlImplementationHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ControlImplementationHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ControlImplementationHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[controlimplementationhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ControlImplementationHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, controlimplementationhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *ControlImplementationHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ControlImplementationHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ControlImplementationHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ControlImplementationHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ControlImplementationHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[controlimplementationhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ControlImplementationHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, controlimplementationhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *ControlImplementationHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ControlImplementationHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *ControlImplementationHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[controlimplementationhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ControlImplementationHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, controlimplementationhistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *ControlImplementationHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *ControlImplementationHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *ControlImplementationHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[controlimplementationhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *ControlImplementationHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, controlimplementationhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *ControlImplementationHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *ControlImplementationHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *ControlImplementationHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[controlimplementationhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *ControlImplementationHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, controlimplementationhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *ControlImplementationHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *ControlImplementationHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *ControlImplementationHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[controlimplementationhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *ControlImplementationHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, controlimplementationhistory.FieldSystemInternalID)
}

// SetStatus sets the "status" field.
func (m *ControlImplementationHistoryMutation) SetStatus(es enums.DocumentStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *ControlImplementationHistoryMutation) Status() (r enums.DocumentStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldStatus(ctx context.Context) (v enums.DocumentStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ControlImplementationHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[controlimplementationhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ControlImplementationHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, controlimplementationhistory.FieldStatus)
}

// SetImplementationDate sets the "implementation_date" field.
func (m *ControlImplementationHistoryMutation) SetImplementationDate(t time.Time) {
	m.implementation_date = &t
}

// ImplementationDate returns the value of the "implementation_date" field in the mutation.
func (m *ControlImplementationHistoryMutation) ImplementationDate() (r time.Time, exists bool) {
	v := m.implementation_date
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementationDate returns the old "implementation_date" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldImplementationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementationDate: %w", err)
	}
	return oldValue.ImplementationDate, nil
}

// ClearImplementationDate clears the value of the "implementation_date" field.
func (m *ControlImplementationHistoryMutation) ClearImplementationDate() {
	m.implementation_date = nil
	m.clearedFields[controlimplementationhistory.FieldImplementationDate] = struct{}{}
}

// ImplementationDateCleared returns if the "implementation_date" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) ImplementationDateCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldImplementationDate]
	return ok
}

// ResetImplementationDate resets all changes to the "implementation_date" field.
func (m *ControlImplementationHistoryMutation) ResetImplementationDate() {
	m.implementation_date = nil
	delete(m.clearedFields, controlimplementationhistory.FieldImplementationDate)
}

// SetVerified sets the "verified" field.
func (m *ControlImplementationHistoryMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *ControlImplementationHistoryMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ClearVerified clears the value of the "verified" field.
func (m *ControlImplementationHistoryMutation) ClearVerified() {
	m.verified = nil
	m.clearedFields[controlimplementationhistory.FieldVerified] = struct{}{}
}

// VerifiedCleared returns if the "verified" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) VerifiedCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldVerified]
	return ok
}

// ResetVerified resets all changes to the "verified" field.
func (m *ControlImplementationHistoryMutation) ResetVerified() {
	m.verified = nil
	delete(m.clearedFields, controlimplementationhistory.FieldVerified)
}

// SetVerificationDate sets the "verification_date" field.
func (m *ControlImplementationHistoryMutation) SetVerificationDate(t time.Time) {
	m.verification_date = &t
}

// VerificationDate returns the value of the "verification_date" field in the mutation.
func (m *ControlImplementationHistoryMutation) VerificationDate() (r time.Time, exists bool) {
	v := m.verification_date
	if v == nil {
		return
	}
	return *v, true
}

// OldVerificationDate returns the old "verification_date" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldVerificationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerificationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerificationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerificationDate: %w", err)
	}
	return oldValue.VerificationDate, nil
}

// ClearVerificationDate clears the value of the "verification_date" field.
func (m *ControlImplementationHistoryMutation) ClearVerificationDate() {
	m.verification_date = nil
	m.clearedFields[controlimplementationhistory.FieldVerificationDate] = struct{}{}
}

// VerificationDateCleared returns if the "verification_date" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) VerificationDateCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldVerificationDate]
	return ok
}

// ResetVerificationDate resets all changes to the "verification_date" field.
func (m *ControlImplementationHistoryMutation) ResetVerificationDate() {
	m.verification_date = nil
	delete(m.clearedFields, controlimplementationhistory.FieldVerificationDate)
}

// SetDetails sets the "details" field.
func (m *ControlImplementationHistoryMutation) SetDetails(s string) {
	m.details = &s
}

// Details returns the value of the "details" field in the mutation.
func (m *ControlImplementationHistoryMutation) Details() (r string, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the ControlImplementationHistory entity.
// If the ControlImplementationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlImplementationHistoryMutation) OldDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *ControlImplementationHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[controlimplementationhistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[controlimplementationhistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *ControlImplementationHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, controlimplementationhistory.FieldDetails)
}

// Where appends a list predicates to the ControlImplementationHistoryMutation builder.
func (m *ControlImplementationHistoryMutation) Where(ps ...predicate.ControlImplementationHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ControlImplementationHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ControlImplementationHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ControlImplementationHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ControlImplementationHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ControlImplementationHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ControlImplementationHistory).
func (m *ControlImplementationHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ControlImplementationHistoryMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.history_time != nil {
		fields = append(fields, controlimplementationhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, controlimplementationhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, controlimplementationhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, controlimplementationhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, controlimplementationhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, controlimplementationhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, controlimplementationhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, controlimplementationhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, controlimplementationhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, controlimplementationhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, controlimplementationhistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, controlimplementationhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, controlimplementationhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, controlimplementationhistory.FieldSystemInternalID)
	}
	if m.status != nil {
		fields = append(fields, controlimplementationhistory.FieldStatus)
	}
	if m.implementation_date != nil {
		fields = append(fields, controlimplementationhistory.FieldImplementationDate)
	}
	if m.verified != nil {
		fields = append(fields, controlimplementationhistory.FieldVerified)
	}
	if m.verification_date != nil {
		fields = append(fields, controlimplementationhistory.FieldVerificationDate)
	}
	if m.details != nil {
		fields = append(fields, controlimplementationhistory.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ControlImplementationHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case controlimplementationhistory.FieldHistoryTime:
		return m.HistoryTime()
	case controlimplementationhistory.FieldRef:
		return m.Ref()
	case controlimplementationhistory.FieldOperation:
		return m.Operation()
	case controlimplementationhistory.FieldCreatedAt:
		return m.CreatedAt()
	case controlimplementationhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case controlimplementationhistory.FieldCreatedBy:
		return m.CreatedBy()
	case controlimplementationhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case controlimplementationhistory.FieldDeletedAt:
		return m.DeletedAt()
	case controlimplementationhistory.FieldDeletedBy:
		return m.DeletedBy()
	case controlimplementationhistory.FieldTags:
		return m.Tags()
	case controlimplementationhistory.FieldOwnerID:
		return m.OwnerID()
	case controlimplementationhistory.FieldSystemOwned:
		return m.SystemOwned()
	case controlimplementationhistory.FieldInternalNotes:
		return m.InternalNotes()
	case controlimplementationhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case controlimplementationhistory.FieldStatus:
		return m.Status()
	case controlimplementationhistory.FieldImplementationDate:
		return m.ImplementationDate()
	case controlimplementationhistory.FieldVerified:
		return m.Verified()
	case controlimplementationhistory.FieldVerificationDate:
		return m.VerificationDate()
	case controlimplementationhistory.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ControlImplementationHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case controlimplementationhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case controlimplementationhistory.FieldRef:
		return m.OldRef(ctx)
	case controlimplementationhistory.FieldOperation:
		return m.OldOperation(ctx)
	case controlimplementationhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case controlimplementationhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case controlimplementationhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case controlimplementationhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case controlimplementationhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case controlimplementationhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case controlimplementationhistory.FieldTags:
		return m.OldTags(ctx)
	case controlimplementationhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case controlimplementationhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case controlimplementationhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case controlimplementationhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case controlimplementationhistory.FieldStatus:
		return m.OldStatus(ctx)
	case controlimplementationhistory.FieldImplementationDate:
		return m.OldImplementationDate(ctx)
	case controlimplementationhistory.FieldVerified:
		return m.OldVerified(ctx)
	case controlimplementationhistory.FieldVerificationDate:
		return m.OldVerificationDate(ctx)
	case controlimplementationhistory.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown ControlImplementationHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ControlImplementationHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case controlimplementationhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case controlimplementationhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case controlimplementationhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case controlimplementationhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case controlimplementationhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case controlimplementationhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case controlimplementationhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case controlimplementationhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case controlimplementationhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case controlimplementationhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case controlimplementationhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case controlimplementationhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case controlimplementationhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case controlimplementationhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case controlimplementationhistory.FieldStatus:
		v, ok := value.(enums.DocumentStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case controlimplementationhistory.FieldImplementationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementationDate(v)
		return nil
	case controlimplementationhistory.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	case controlimplementationhistory.FieldVerificationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerificationDate(v)
		return nil
	case controlimplementationhistory.FieldDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown ControlImplementationHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ControlImplementationHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ControlImplementationHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ControlImplementationHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ControlImplementationHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ControlImplementationHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(controlimplementationhistory.FieldRef) {
		fields = append(fields, controlimplementationhistory.FieldRef)
	}
	if m.FieldCleared(controlimplementationhistory.FieldCreatedAt) {
		fields = append(fields, controlimplementationhistory.FieldCreatedAt)
	}
	if m.FieldCleared(controlimplementationhistory.FieldUpdatedAt) {
		fields = append(fields, controlimplementationhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(controlimplementationhistory.FieldCreatedBy) {
		fields = append(fields, controlimplementationhistory.FieldCreatedBy)
	}
	if m.FieldCleared(controlimplementationhistory.FieldUpdatedBy) {
		fields = append(fields, controlimplementationhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(controlimplementationhistory.FieldDeletedAt) {
		fields = append(fields, controlimplementationhistory.FieldDeletedAt)
	}
	if m.FieldCleared(controlimplementationhistory.FieldDeletedBy) {
		fields = append(fields, controlimplementationhistory.FieldDeletedBy)
	}
	if m.FieldCleared(controlimplementationhistory.FieldTags) {
		fields = append(fields, controlimplementationhistory.FieldTags)
	}
	if m.FieldCleared(controlimplementationhistory.FieldOwnerID) {
		fields = append(fields, controlimplementationhistory.FieldOwnerID)
	}
	if m.FieldCleared(controlimplementationhistory.FieldSystemOwned) {
		fields = append(fields, controlimplementationhistory.FieldSystemOwned)
	}
	if m.FieldCleared(controlimplementationhistory.FieldInternalNotes) {
		fields = append(fields, controlimplementationhistory.FieldInternalNotes)
	}
	if m.FieldCleared(controlimplementationhistory.FieldSystemInternalID) {
		fields = append(fields, controlimplementationhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(controlimplementationhistory.FieldStatus) {
		fields = append(fields, controlimplementationhistory.FieldStatus)
	}
	if m.FieldCleared(controlimplementationhistory.FieldImplementationDate) {
		fields = append(fields, controlimplementationhistory.FieldImplementationDate)
	}
	if m.FieldCleared(controlimplementationhistory.FieldVerified) {
		fields = append(fields, controlimplementationhistory.FieldVerified)
	}
	if m.FieldCleared(controlimplementationhistory.FieldVerificationDate) {
		fields = append(fields, controlimplementationhistory.FieldVerificationDate)
	}
	if m.FieldCleared(controlimplementationhistory.FieldDetails) {
		fields = append(fields, controlimplementationhistory.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ControlImplementationHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ControlImplementationHistoryMutation) ClearField(name string) error {
	switch name {
	case controlimplementationhistory.FieldRef:
		m.ClearRef()
		return nil
	case controlimplementationhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case controlimplementationhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case controlimplementationhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case controlimplementationhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case controlimplementationhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case controlimplementationhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case controlimplementationhistory.FieldTags:
		m.ClearTags()
		return nil
	case controlimplementationhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case controlimplementationhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case controlimplementationhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case controlimplementationhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case controlimplementationhistory.FieldStatus:
		m.ClearStatus()
		return nil
	case controlimplementationhistory.FieldImplementationDate:
		m.ClearImplementationDate()
		return nil
	case controlimplementationhistory.FieldVerified:
		m.ClearVerified()
		return nil
	case controlimplementationhistory.FieldVerificationDate:
		m.ClearVerificationDate()
		return nil
	case controlimplementationhistory.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown ControlImplementationHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ControlImplementationHistoryMutation) ResetField(name string) error {
	switch name {
	case controlimplementationhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case controlimplementationhistory.FieldRef:
		m.ResetRef()
		return nil
	case controlimplementationhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case controlimplementationhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case controlimplementationhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case controlimplementationhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case controlimplementationhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case controlimplementationhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case controlimplementationhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case controlimplementationhistory.FieldTags:
		m.ResetTags()
		return nil
	case controlimplementationhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case controlimplementationhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case controlimplementationhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case controlimplementationhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case controlimplementationhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case controlimplementationhistory.FieldImplementationDate:
		m.ResetImplementationDate()
		return nil
	case controlimplementationhistory.FieldVerified:
		m.ResetVerified()
		return nil
	case controlimplementationhistory.FieldVerificationDate:
		m.ResetVerificationDate()
		return nil
	case controlimplementationhistory.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown ControlImplementationHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ControlImplementationHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ControlImplementationHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ControlImplementationHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ControlImplementationHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ControlImplementationHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ControlImplementationHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ControlImplementationHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ControlImplementationHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ControlImplementationHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ControlImplementationHistory edge %s", name)
}

// ControlObjectiveHistoryMutation represents an operation that mutates the ControlObjectiveHistory nodes in the graph.
type ControlObjectiveHistoryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	history_time           *time.Time
	ref                    *string
	operation              *history.OpType
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	deleted_at             *time.Time
	deleted_by             *string
	display_id             *string
	tags                   *[]string
	appendtags             []string
	revision               *string
	owner_id               *string
	system_owned           *bool
	internal_notes         *string
	system_internal_id     *string
	name                   *string
	desired_outcome        *string
	status                 *enums.ObjectiveStatus
	source                 *enums.ControlSource
	control_objective_type *string
	category               *string
	subcategory            *string
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ControlObjectiveHistory, error)
	predicates             []predicate.ControlObjectiveHistory
}

var _ ent.Mutation = (*ControlObjectiveHistoryMutation)(nil)

// controlobjectivehistoryOption allows management of the mutation configuration using functional options.
type controlobjectivehistoryOption func(*ControlObjectiveHistoryMutation)

// newControlObjectiveHistoryMutation creates new mutation for the ControlObjectiveHistory entity.
func newControlObjectiveHistoryMutation(c config, op Op, opts ...controlobjectivehistoryOption) *ControlObjectiveHistoryMutation {
	m := &ControlObjectiveHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeControlObjectiveHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withControlObjectiveHistoryID sets the ID field of the mutation.
func withControlObjectiveHistoryID(id string) controlobjectivehistoryOption {
	return func(m *ControlObjectiveHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ControlObjectiveHistory
		)
		m.oldValue = func(ctx context.Context) (*ControlObjectiveHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ControlObjectiveHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withControlObjectiveHistory sets the old ControlObjectiveHistory of the mutation.
func withControlObjectiveHistory(node *ControlObjectiveHistory) controlobjectivehistoryOption {
	return func(m *ControlObjectiveHistoryMutation) {
		m.oldValue = func(context.Context) (*ControlObjectiveHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ControlObjectiveHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ControlObjectiveHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ControlObjectiveHistory entities.
func (m *ControlObjectiveHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ControlObjectiveHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ControlObjectiveHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ControlObjectiveHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ControlObjectiveHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ControlObjectiveHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ControlObjectiveHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ControlObjectiveHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ControlObjectiveHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[controlobjectivehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ControlObjectiveHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, controlobjectivehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ControlObjectiveHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ControlObjectiveHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ControlObjectiveHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ControlObjectiveHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ControlObjectiveHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[controlobjectivehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ControlObjectiveHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, controlobjectivehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ControlObjectiveHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ControlObjectiveHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ControlObjectiveHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[controlobjectivehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ControlObjectiveHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, controlobjectivehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ControlObjectiveHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ControlObjectiveHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ControlObjectiveHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[controlobjectivehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ControlObjectiveHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, controlobjectivehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ControlObjectiveHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ControlObjectiveHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ControlObjectiveHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[controlobjectivehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ControlObjectiveHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, controlobjectivehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ControlObjectiveHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ControlObjectiveHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ControlObjectiveHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[controlobjectivehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ControlObjectiveHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, controlobjectivehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ControlObjectiveHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ControlObjectiveHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ControlObjectiveHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[controlobjectivehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ControlObjectiveHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, controlobjectivehistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *ControlObjectiveHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *ControlObjectiveHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *ControlObjectiveHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *ControlObjectiveHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ControlObjectiveHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ControlObjectiveHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ControlObjectiveHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[controlobjectivehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ControlObjectiveHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, controlobjectivehistory.FieldTags)
}

// SetRevision sets the "revision" field.
func (m *ControlObjectiveHistoryMutation) SetRevision(s string) {
	m.revision = &s
}

// Revision returns the value of the "revision" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Revision() (r string, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldRevision(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// ClearRevision clears the value of the "revision" field.
func (m *ControlObjectiveHistoryMutation) ClearRevision() {
	m.revision = nil
	m.clearedFields[controlobjectivehistory.FieldRevision] = struct{}{}
}

// RevisionCleared returns if the "revision" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) RevisionCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldRevision]
	return ok
}

// ResetRevision resets all changes to the "revision" field.
func (m *ControlObjectiveHistoryMutation) ResetRevision() {
	m.revision = nil
	delete(m.clearedFields, controlobjectivehistory.FieldRevision)
}

// SetOwnerID sets the "owner_id" field.
func (m *ControlObjectiveHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ControlObjectiveHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *ControlObjectiveHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[controlobjectivehistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ControlObjectiveHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, controlobjectivehistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *ControlObjectiveHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *ControlObjectiveHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *ControlObjectiveHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[controlobjectivehistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *ControlObjectiveHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, controlobjectivehistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *ControlObjectiveHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *ControlObjectiveHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *ControlObjectiveHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[controlobjectivehistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *ControlObjectiveHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, controlobjectivehistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *ControlObjectiveHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *ControlObjectiveHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *ControlObjectiveHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[controlobjectivehistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *ControlObjectiveHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, controlobjectivehistory.FieldSystemInternalID)
}

// SetName sets the "name" field.
func (m *ControlObjectiveHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ControlObjectiveHistoryMutation) ResetName() {
	m.name = nil
}

// SetDesiredOutcome sets the "desired_outcome" field.
func (m *ControlObjectiveHistoryMutation) SetDesiredOutcome(s string) {
	m.desired_outcome = &s
}

// DesiredOutcome returns the value of the "desired_outcome" field in the mutation.
func (m *ControlObjectiveHistoryMutation) DesiredOutcome() (r string, exists bool) {
	v := m.desired_outcome
	if v == nil {
		return
	}
	return *v, true
}

// OldDesiredOutcome returns the old "desired_outcome" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldDesiredOutcome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesiredOutcome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesiredOutcome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesiredOutcome: %w", err)
	}
	return oldValue.DesiredOutcome, nil
}

// ClearDesiredOutcome clears the value of the "desired_outcome" field.
func (m *ControlObjectiveHistoryMutation) ClearDesiredOutcome() {
	m.desired_outcome = nil
	m.clearedFields[controlobjectivehistory.FieldDesiredOutcome] = struct{}{}
}

// DesiredOutcomeCleared returns if the "desired_outcome" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) DesiredOutcomeCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldDesiredOutcome]
	return ok
}

// ResetDesiredOutcome resets all changes to the "desired_outcome" field.
func (m *ControlObjectiveHistoryMutation) ResetDesiredOutcome() {
	m.desired_outcome = nil
	delete(m.clearedFields, controlobjectivehistory.FieldDesiredOutcome)
}

// SetStatus sets the "status" field.
func (m *ControlObjectiveHistoryMutation) SetStatus(es enums.ObjectiveStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Status() (r enums.ObjectiveStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldStatus(ctx context.Context) (v enums.ObjectiveStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ControlObjectiveHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[controlobjectivehistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ControlObjectiveHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, controlobjectivehistory.FieldStatus)
}

// SetSource sets the "source" field.
func (m *ControlObjectiveHistoryMutation) SetSource(es enums.ControlSource) {
	m.source = &es
}

// Source returns the value of the "source" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Source() (r enums.ControlSource, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldSource(ctx context.Context) (v enums.ControlSource, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *ControlObjectiveHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[controlobjectivehistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *ControlObjectiveHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, controlobjectivehistory.FieldSource)
}

// SetControlObjectiveType sets the "control_objective_type" field.
func (m *ControlObjectiveHistoryMutation) SetControlObjectiveType(s string) {
	m.control_objective_type = &s
}

// ControlObjectiveType returns the value of the "control_objective_type" field in the mutation.
func (m *ControlObjectiveHistoryMutation) ControlObjectiveType() (r string, exists bool) {
	v := m.control_objective_type
	if v == nil {
		return
	}
	return *v, true
}

// OldControlObjectiveType returns the old "control_objective_type" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldControlObjectiveType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlObjectiveType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlObjectiveType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlObjectiveType: %w", err)
	}
	return oldValue.ControlObjectiveType, nil
}

// ClearControlObjectiveType clears the value of the "control_objective_type" field.
func (m *ControlObjectiveHistoryMutation) ClearControlObjectiveType() {
	m.control_objective_type = nil
	m.clearedFields[controlobjectivehistory.FieldControlObjectiveType] = struct{}{}
}

// ControlObjectiveTypeCleared returns if the "control_objective_type" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) ControlObjectiveTypeCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldControlObjectiveType]
	return ok
}

// ResetControlObjectiveType resets all changes to the "control_objective_type" field.
func (m *ControlObjectiveHistoryMutation) ResetControlObjectiveType() {
	m.control_objective_type = nil
	delete(m.clearedFields, controlobjectivehistory.FieldControlObjectiveType)
}

// SetCategory sets the "category" field.
func (m *ControlObjectiveHistoryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ControlObjectiveHistoryMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[controlobjectivehistory.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ControlObjectiveHistoryMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, controlobjectivehistory.FieldCategory)
}

// SetSubcategory sets the "subcategory" field.
func (m *ControlObjectiveHistoryMutation) SetSubcategory(s string) {
	m.subcategory = &s
}

// Subcategory returns the value of the "subcategory" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Subcategory() (r string, exists bool) {
	v := m.subcategory
	if v == nil {
		return
	}
	return *v, true
}

// OldSubcategory returns the old "subcategory" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldSubcategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubcategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubcategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubcategory: %w", err)
	}
	return oldValue.Subcategory, nil
}

// ClearSubcategory clears the value of the "subcategory" field.
func (m *ControlObjectiveHistoryMutation) ClearSubcategory() {
	m.subcategory = nil
	m.clearedFields[controlobjectivehistory.FieldSubcategory] = struct{}{}
}

// SubcategoryCleared returns if the "subcategory" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) SubcategoryCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldSubcategory]
	return ok
}

// ResetSubcategory resets all changes to the "subcategory" field.
func (m *ControlObjectiveHistoryMutation) ResetSubcategory() {
	m.subcategory = nil
	delete(m.clearedFields, controlobjectivehistory.FieldSubcategory)
}

// Where appends a list predicates to the ControlObjectiveHistoryMutation builder.
func (m *ControlObjectiveHistoryMutation) Where(ps ...predicate.ControlObjectiveHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ControlObjectiveHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ControlObjectiveHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ControlObjectiveHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ControlObjectiveHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ControlObjectiveHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ControlObjectiveHistory).
func (m *ControlObjectiveHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ControlObjectiveHistoryMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.history_time != nil {
		fields = append(fields, controlobjectivehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, controlobjectivehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, controlobjectivehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, controlobjectivehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, controlobjectivehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, controlobjectivehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, controlobjectivehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, controlobjectivehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, controlobjectivehistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, controlobjectivehistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, controlobjectivehistory.FieldTags)
	}
	if m.revision != nil {
		fields = append(fields, controlobjectivehistory.FieldRevision)
	}
	if m.owner_id != nil {
		fields = append(fields, controlobjectivehistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, controlobjectivehistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, controlobjectivehistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, controlobjectivehistory.FieldSystemInternalID)
	}
	if m.name != nil {
		fields = append(fields, controlobjectivehistory.FieldName)
	}
	if m.desired_outcome != nil {
		fields = append(fields, controlobjectivehistory.FieldDesiredOutcome)
	}
	if m.status != nil {
		fields = append(fields, controlobjectivehistory.FieldStatus)
	}
	if m.source != nil {
		fields = append(fields, controlobjectivehistory.FieldSource)
	}
	if m.control_objective_type != nil {
		fields = append(fields, controlobjectivehistory.FieldControlObjectiveType)
	}
	if m.category != nil {
		fields = append(fields, controlobjectivehistory.FieldCategory)
	}
	if m.subcategory != nil {
		fields = append(fields, controlobjectivehistory.FieldSubcategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ControlObjectiveHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case controlobjectivehistory.FieldHistoryTime:
		return m.HistoryTime()
	case controlobjectivehistory.FieldRef:
		return m.Ref()
	case controlobjectivehistory.FieldOperation:
		return m.Operation()
	case controlobjectivehistory.FieldCreatedAt:
		return m.CreatedAt()
	case controlobjectivehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case controlobjectivehistory.FieldCreatedBy:
		return m.CreatedBy()
	case controlobjectivehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case controlobjectivehistory.FieldDeletedAt:
		return m.DeletedAt()
	case controlobjectivehistory.FieldDeletedBy:
		return m.DeletedBy()
	case controlobjectivehistory.FieldDisplayID:
		return m.DisplayID()
	case controlobjectivehistory.FieldTags:
		return m.Tags()
	case controlobjectivehistory.FieldRevision:
		return m.Revision()
	case controlobjectivehistory.FieldOwnerID:
		return m.OwnerID()
	case controlobjectivehistory.FieldSystemOwned:
		return m.SystemOwned()
	case controlobjectivehistory.FieldInternalNotes:
		return m.InternalNotes()
	case controlobjectivehistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case controlobjectivehistory.FieldName:
		return m.Name()
	case controlobjectivehistory.FieldDesiredOutcome:
		return m.DesiredOutcome()
	case controlobjectivehistory.FieldStatus:
		return m.Status()
	case controlobjectivehistory.FieldSource:
		return m.Source()
	case controlobjectivehistory.FieldControlObjectiveType:
		return m.ControlObjectiveType()
	case controlobjectivehistory.FieldCategory:
		return m.Category()
	case controlobjectivehistory.FieldSubcategory:
		return m.Subcategory()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ControlObjectiveHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case controlobjectivehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case controlobjectivehistory.FieldRef:
		return m.OldRef(ctx)
	case controlobjectivehistory.FieldOperation:
		return m.OldOperation(ctx)
	case controlobjectivehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case controlobjectivehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case controlobjectivehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case controlobjectivehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case controlobjectivehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case controlobjectivehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case controlobjectivehistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case controlobjectivehistory.FieldTags:
		return m.OldTags(ctx)
	case controlobjectivehistory.FieldRevision:
		return m.OldRevision(ctx)
	case controlobjectivehistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case controlobjectivehistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case controlobjectivehistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case controlobjectivehistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case controlobjectivehistory.FieldName:
		return m.OldName(ctx)
	case controlobjectivehistory.FieldDesiredOutcome:
		return m.OldDesiredOutcome(ctx)
	case controlobjectivehistory.FieldStatus:
		return m.OldStatus(ctx)
	case controlobjectivehistory.FieldSource:
		return m.OldSource(ctx)
	case controlobjectivehistory.FieldControlObjectiveType:
		return m.OldControlObjectiveType(ctx)
	case controlobjectivehistory.FieldCategory:
		return m.OldCategory(ctx)
	case controlobjectivehistory.FieldSubcategory:
		return m.OldSubcategory(ctx)
	}
	return nil, fmt.Errorf("unknown ControlObjectiveHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ControlObjectiveHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case controlobjectivehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case controlobjectivehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case controlobjectivehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case controlobjectivehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case controlobjectivehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case controlobjectivehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case controlobjectivehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case controlobjectivehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case controlobjectivehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case controlobjectivehistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case controlobjectivehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case controlobjectivehistory.FieldRevision:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case controlobjectivehistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case controlobjectivehistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case controlobjectivehistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case controlobjectivehistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case controlobjectivehistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case controlobjectivehistory.FieldDesiredOutcome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesiredOutcome(v)
		return nil
	case controlobjectivehistory.FieldStatus:
		v, ok := value.(enums.ObjectiveStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case controlobjectivehistory.FieldSource:
		v, ok := value.(enums.ControlSource)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case controlobjectivehistory.FieldControlObjectiveType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlObjectiveType(v)
		return nil
	case controlobjectivehistory.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case controlobjectivehistory.FieldSubcategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubcategory(v)
		return nil
	}
	return fmt.Errorf("unknown ControlObjectiveHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ControlObjectiveHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ControlObjectiveHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ControlObjectiveHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ControlObjectiveHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ControlObjectiveHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(controlobjectivehistory.FieldRef) {
		fields = append(fields, controlobjectivehistory.FieldRef)
	}
	if m.FieldCleared(controlobjectivehistory.FieldCreatedAt) {
		fields = append(fields, controlobjectivehistory.FieldCreatedAt)
	}
	if m.FieldCleared(controlobjectivehistory.FieldUpdatedAt) {
		fields = append(fields, controlobjectivehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(controlobjectivehistory.FieldCreatedBy) {
		fields = append(fields, controlobjectivehistory.FieldCreatedBy)
	}
	if m.FieldCleared(controlobjectivehistory.FieldUpdatedBy) {
		fields = append(fields, controlobjectivehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(controlobjectivehistory.FieldDeletedAt) {
		fields = append(fields, controlobjectivehistory.FieldDeletedAt)
	}
	if m.FieldCleared(controlobjectivehistory.FieldDeletedBy) {
		fields = append(fields, controlobjectivehistory.FieldDeletedBy)
	}
	if m.FieldCleared(controlobjectivehistory.FieldTags) {
		fields = append(fields, controlobjectivehistory.FieldTags)
	}
	if m.FieldCleared(controlobjectivehistory.FieldRevision) {
		fields = append(fields, controlobjectivehistory.FieldRevision)
	}
	if m.FieldCleared(controlobjectivehistory.FieldOwnerID) {
		fields = append(fields, controlobjectivehistory.FieldOwnerID)
	}
	if m.FieldCleared(controlobjectivehistory.FieldSystemOwned) {
		fields = append(fields, controlobjectivehistory.FieldSystemOwned)
	}
	if m.FieldCleared(controlobjectivehistory.FieldInternalNotes) {
		fields = append(fields, controlobjectivehistory.FieldInternalNotes)
	}
	if m.FieldCleared(controlobjectivehistory.FieldSystemInternalID) {
		fields = append(fields, controlobjectivehistory.FieldSystemInternalID)
	}
	if m.FieldCleared(controlobjectivehistory.FieldDesiredOutcome) {
		fields = append(fields, controlobjectivehistory.FieldDesiredOutcome)
	}
	if m.FieldCleared(controlobjectivehistory.FieldStatus) {
		fields = append(fields, controlobjectivehistory.FieldStatus)
	}
	if m.FieldCleared(controlobjectivehistory.FieldSource) {
		fields = append(fields, controlobjectivehistory.FieldSource)
	}
	if m.FieldCleared(controlobjectivehistory.FieldControlObjectiveType) {
		fields = append(fields, controlobjectivehistory.FieldControlObjectiveType)
	}
	if m.FieldCleared(controlobjectivehistory.FieldCategory) {
		fields = append(fields, controlobjectivehistory.FieldCategory)
	}
	if m.FieldCleared(controlobjectivehistory.FieldSubcategory) {
		fields = append(fields, controlobjectivehistory.FieldSubcategory)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ControlObjectiveHistoryMutation) ClearField(name string) error {
	switch name {
	case controlobjectivehistory.FieldRef:
		m.ClearRef()
		return nil
	case controlobjectivehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case controlobjectivehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case controlobjectivehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case controlobjectivehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case controlobjectivehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case controlobjectivehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case controlobjectivehistory.FieldTags:
		m.ClearTags()
		return nil
	case controlobjectivehistory.FieldRevision:
		m.ClearRevision()
		return nil
	case controlobjectivehistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case controlobjectivehistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case controlobjectivehistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case controlobjectivehistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case controlobjectivehistory.FieldDesiredOutcome:
		m.ClearDesiredOutcome()
		return nil
	case controlobjectivehistory.FieldStatus:
		m.ClearStatus()
		return nil
	case controlobjectivehistory.FieldSource:
		m.ClearSource()
		return nil
	case controlobjectivehistory.FieldControlObjectiveType:
		m.ClearControlObjectiveType()
		return nil
	case controlobjectivehistory.FieldCategory:
		m.ClearCategory()
		return nil
	case controlobjectivehistory.FieldSubcategory:
		m.ClearSubcategory()
		return nil
	}
	return fmt.Errorf("unknown ControlObjectiveHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ControlObjectiveHistoryMutation) ResetField(name string) error {
	switch name {
	case controlobjectivehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case controlobjectivehistory.FieldRef:
		m.ResetRef()
		return nil
	case controlobjectivehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case controlobjectivehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case controlobjectivehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case controlobjectivehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case controlobjectivehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case controlobjectivehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case controlobjectivehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case controlobjectivehistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case controlobjectivehistory.FieldTags:
		m.ResetTags()
		return nil
	case controlobjectivehistory.FieldRevision:
		m.ResetRevision()
		return nil
	case controlobjectivehistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case controlobjectivehistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case controlobjectivehistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case controlobjectivehistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case controlobjectivehistory.FieldName:
		m.ResetName()
		return nil
	case controlobjectivehistory.FieldDesiredOutcome:
		m.ResetDesiredOutcome()
		return nil
	case controlobjectivehistory.FieldStatus:
		m.ResetStatus()
		return nil
	case controlobjectivehistory.FieldSource:
		m.ResetSource()
		return nil
	case controlobjectivehistory.FieldControlObjectiveType:
		m.ResetControlObjectiveType()
		return nil
	case controlobjectivehistory.FieldCategory:
		m.ResetCategory()
		return nil
	case controlobjectivehistory.FieldSubcategory:
		m.ResetSubcategory()
		return nil
	}
	return fmt.Errorf("unknown ControlObjectiveHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ControlObjectiveHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ControlObjectiveHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ControlObjectiveHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ControlObjectiveHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ControlObjectiveHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ControlObjectiveHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ControlObjectiveHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ControlObjectiveHistory edge %s", name)
}

// CustomDomainHistoryMutation represents an operation that mutates the CustomDomainHistory nodes in the graph.
type CustomDomainHistoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	history_time        *time.Time
	ref                 *string
	operation           *history.OpType
	created_at          *time.Time
	updated_at          *time.Time
	created_by          *string
	updated_by          *string
	deleted_at          *time.Time
	deleted_by          *string
	tags                *[]string
	appendtags          []string
	owner_id            *string
	system_owned        *bool
	internal_notes      *string
	system_internal_id  *string
	cname_record        *string
	mappable_domain_id  *string
	dns_verification_id *string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*CustomDomainHistory, error)
	predicates          []predicate.CustomDomainHistory
}

var _ ent.Mutation = (*CustomDomainHistoryMutation)(nil)

// customdomainhistoryOption allows management of the mutation configuration using functional options.
type customdomainhistoryOption func(*CustomDomainHistoryMutation)

// newCustomDomainHistoryMutation creates new mutation for the CustomDomainHistory entity.
func newCustomDomainHistoryMutation(c config, op Op, opts ...customdomainhistoryOption) *CustomDomainHistoryMutation {
	m := &CustomDomainHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomDomainHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomDomainHistoryID sets the ID field of the mutation.
func withCustomDomainHistoryID(id string) customdomainhistoryOption {
	return func(m *CustomDomainHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomDomainHistory
		)
		m.oldValue = func(ctx context.Context) (*CustomDomainHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomDomainHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomDomainHistory sets the old CustomDomainHistory of the mutation.
func withCustomDomainHistory(node *CustomDomainHistory) customdomainhistoryOption {
	return func(m *CustomDomainHistoryMutation) {
		m.oldValue = func(context.Context) (*CustomDomainHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomDomainHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomDomainHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CustomDomainHistory entities.
func (m *CustomDomainHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomDomainHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomDomainHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomDomainHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *CustomDomainHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *CustomDomainHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *CustomDomainHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *CustomDomainHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *CustomDomainHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *CustomDomainHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[customdomainhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *CustomDomainHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[customdomainhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *CustomDomainHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, customdomainhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *CustomDomainHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *CustomDomainHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *CustomDomainHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomDomainHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomDomainHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *CustomDomainHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[customdomainhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *CustomDomainHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[customdomainhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomDomainHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, customdomainhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomDomainHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomDomainHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CustomDomainHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[customdomainhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CustomDomainHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[customdomainhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomDomainHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, customdomainhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *CustomDomainHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CustomDomainHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *CustomDomainHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[customdomainhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *CustomDomainHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[customdomainhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CustomDomainHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, customdomainhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CustomDomainHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CustomDomainHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *CustomDomainHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[customdomainhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *CustomDomainHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[customdomainhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CustomDomainHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, customdomainhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CustomDomainHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CustomDomainHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CustomDomainHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[customdomainhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CustomDomainHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[customdomainhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CustomDomainHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, customdomainhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *CustomDomainHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *CustomDomainHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *CustomDomainHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[customdomainhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *CustomDomainHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[customdomainhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *CustomDomainHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, customdomainhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *CustomDomainHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *CustomDomainHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *CustomDomainHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *CustomDomainHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *CustomDomainHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[customdomainhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *CustomDomainHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[customdomainhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *CustomDomainHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, customdomainhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *CustomDomainHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *CustomDomainHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *CustomDomainHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[customdomainhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *CustomDomainHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[customdomainhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *CustomDomainHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, customdomainhistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *CustomDomainHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *CustomDomainHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *CustomDomainHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[customdomainhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *CustomDomainHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[customdomainhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *CustomDomainHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, customdomainhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *CustomDomainHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *CustomDomainHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *CustomDomainHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[customdomainhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *CustomDomainHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[customdomainhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *CustomDomainHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, customdomainhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *CustomDomainHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *CustomDomainHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *CustomDomainHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[customdomainhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *CustomDomainHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[customdomainhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *CustomDomainHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, customdomainhistory.FieldSystemInternalID)
}

// SetCnameRecord sets the "cname_record" field.
func (m *CustomDomainHistoryMutation) SetCnameRecord(s string) {
	m.cname_record = &s
}

// CnameRecord returns the value of the "cname_record" field in the mutation.
func (m *CustomDomainHistoryMutation) CnameRecord() (r string, exists bool) {
	v := m.cname_record
	if v == nil {
		return
	}
	return *v, true
}

// OldCnameRecord returns the old "cname_record" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldCnameRecord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCnameRecord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCnameRecord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCnameRecord: %w", err)
	}
	return oldValue.CnameRecord, nil
}

// ResetCnameRecord resets all changes to the "cname_record" field.
func (m *CustomDomainHistoryMutation) ResetCnameRecord() {
	m.cname_record = nil
}

// SetMappableDomainID sets the "mappable_domain_id" field.
func (m *CustomDomainHistoryMutation) SetMappableDomainID(s string) {
	m.mappable_domain_id = &s
}

// MappableDomainID returns the value of the "mappable_domain_id" field in the mutation.
func (m *CustomDomainHistoryMutation) MappableDomainID() (r string, exists bool) {
	v := m.mappable_domain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappableDomainID returns the old "mappable_domain_id" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldMappableDomainID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappableDomainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappableDomainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappableDomainID: %w", err)
	}
	return oldValue.MappableDomainID, nil
}

// ResetMappableDomainID resets all changes to the "mappable_domain_id" field.
func (m *CustomDomainHistoryMutation) ResetMappableDomainID() {
	m.mappable_domain_id = nil
}

// SetDNSVerificationID sets the "dns_verification_id" field.
func (m *CustomDomainHistoryMutation) SetDNSVerificationID(s string) {
	m.dns_verification_id = &s
}

// DNSVerificationID returns the value of the "dns_verification_id" field in the mutation.
func (m *CustomDomainHistoryMutation) DNSVerificationID() (r string, exists bool) {
	v := m.dns_verification_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSVerificationID returns the old "dns_verification_id" field's value of the CustomDomainHistory entity.
// If the CustomDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomDomainHistoryMutation) OldDNSVerificationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSVerificationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSVerificationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSVerificationID: %w", err)
	}
	return oldValue.DNSVerificationID, nil
}

// ClearDNSVerificationID clears the value of the "dns_verification_id" field.
func (m *CustomDomainHistoryMutation) ClearDNSVerificationID() {
	m.dns_verification_id = nil
	m.clearedFields[customdomainhistory.FieldDNSVerificationID] = struct{}{}
}

// DNSVerificationIDCleared returns if the "dns_verification_id" field was cleared in this mutation.
func (m *CustomDomainHistoryMutation) DNSVerificationIDCleared() bool {
	_, ok := m.clearedFields[customdomainhistory.FieldDNSVerificationID]
	return ok
}

// ResetDNSVerificationID resets all changes to the "dns_verification_id" field.
func (m *CustomDomainHistoryMutation) ResetDNSVerificationID() {
	m.dns_verification_id = nil
	delete(m.clearedFields, customdomainhistory.FieldDNSVerificationID)
}

// Where appends a list predicates to the CustomDomainHistoryMutation builder.
func (m *CustomDomainHistoryMutation) Where(ps ...predicate.CustomDomainHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomDomainHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomDomainHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomDomainHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomDomainHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomDomainHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomDomainHistory).
func (m *CustomDomainHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomDomainHistoryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.history_time != nil {
		fields = append(fields, customdomainhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, customdomainhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, customdomainhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, customdomainhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customdomainhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, customdomainhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, customdomainhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, customdomainhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, customdomainhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, customdomainhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, customdomainhistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, customdomainhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, customdomainhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, customdomainhistory.FieldSystemInternalID)
	}
	if m.cname_record != nil {
		fields = append(fields, customdomainhistory.FieldCnameRecord)
	}
	if m.mappable_domain_id != nil {
		fields = append(fields, customdomainhistory.FieldMappableDomainID)
	}
	if m.dns_verification_id != nil {
		fields = append(fields, customdomainhistory.FieldDNSVerificationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomDomainHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customdomainhistory.FieldHistoryTime:
		return m.HistoryTime()
	case customdomainhistory.FieldRef:
		return m.Ref()
	case customdomainhistory.FieldOperation:
		return m.Operation()
	case customdomainhistory.FieldCreatedAt:
		return m.CreatedAt()
	case customdomainhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case customdomainhistory.FieldCreatedBy:
		return m.CreatedBy()
	case customdomainhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case customdomainhistory.FieldDeletedAt:
		return m.DeletedAt()
	case customdomainhistory.FieldDeletedBy:
		return m.DeletedBy()
	case customdomainhistory.FieldTags:
		return m.Tags()
	case customdomainhistory.FieldOwnerID:
		return m.OwnerID()
	case customdomainhistory.FieldSystemOwned:
		return m.SystemOwned()
	case customdomainhistory.FieldInternalNotes:
		return m.InternalNotes()
	case customdomainhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case customdomainhistory.FieldCnameRecord:
		return m.CnameRecord()
	case customdomainhistory.FieldMappableDomainID:
		return m.MappableDomainID()
	case customdomainhistory.FieldDNSVerificationID:
		return m.DNSVerificationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomDomainHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customdomainhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case customdomainhistory.FieldRef:
		return m.OldRef(ctx)
	case customdomainhistory.FieldOperation:
		return m.OldOperation(ctx)
	case customdomainhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customdomainhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customdomainhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case customdomainhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case customdomainhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case customdomainhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case customdomainhistory.FieldTags:
		return m.OldTags(ctx)
	case customdomainhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case customdomainhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case customdomainhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case customdomainhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case customdomainhistory.FieldCnameRecord:
		return m.OldCnameRecord(ctx)
	case customdomainhistory.FieldMappableDomainID:
		return m.OldMappableDomainID(ctx)
	case customdomainhistory.FieldDNSVerificationID:
		return m.OldDNSVerificationID(ctx)
	}
	return nil, fmt.Errorf("unknown CustomDomainHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomDomainHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customdomainhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case customdomainhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case customdomainhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case customdomainhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customdomainhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customdomainhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case customdomainhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case customdomainhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case customdomainhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case customdomainhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case customdomainhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case customdomainhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case customdomainhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case customdomainhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case customdomainhistory.FieldCnameRecord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCnameRecord(v)
		return nil
	case customdomainhistory.FieldMappableDomainID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappableDomainID(v)
		return nil
	case customdomainhistory.FieldDNSVerificationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSVerificationID(v)
		return nil
	}
	return fmt.Errorf("unknown CustomDomainHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomDomainHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomDomainHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomDomainHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CustomDomainHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomDomainHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customdomainhistory.FieldRef) {
		fields = append(fields, customdomainhistory.FieldRef)
	}
	if m.FieldCleared(customdomainhistory.FieldCreatedAt) {
		fields = append(fields, customdomainhistory.FieldCreatedAt)
	}
	if m.FieldCleared(customdomainhistory.FieldUpdatedAt) {
		fields = append(fields, customdomainhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(customdomainhistory.FieldCreatedBy) {
		fields = append(fields, customdomainhistory.FieldCreatedBy)
	}
	if m.FieldCleared(customdomainhistory.FieldUpdatedBy) {
		fields = append(fields, customdomainhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(customdomainhistory.FieldDeletedAt) {
		fields = append(fields, customdomainhistory.FieldDeletedAt)
	}
	if m.FieldCleared(customdomainhistory.FieldDeletedBy) {
		fields = append(fields, customdomainhistory.FieldDeletedBy)
	}
	if m.FieldCleared(customdomainhistory.FieldTags) {
		fields = append(fields, customdomainhistory.FieldTags)
	}
	if m.FieldCleared(customdomainhistory.FieldOwnerID) {
		fields = append(fields, customdomainhistory.FieldOwnerID)
	}
	if m.FieldCleared(customdomainhistory.FieldSystemOwned) {
		fields = append(fields, customdomainhistory.FieldSystemOwned)
	}
	if m.FieldCleared(customdomainhistory.FieldInternalNotes) {
		fields = append(fields, customdomainhistory.FieldInternalNotes)
	}
	if m.FieldCleared(customdomainhistory.FieldSystemInternalID) {
		fields = append(fields, customdomainhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(customdomainhistory.FieldDNSVerificationID) {
		fields = append(fields, customdomainhistory.FieldDNSVerificationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomDomainHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomDomainHistoryMutation) ClearField(name string) error {
	switch name {
	case customdomainhistory.FieldRef:
		m.ClearRef()
		return nil
	case customdomainhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case customdomainhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case customdomainhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case customdomainhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case customdomainhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case customdomainhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case customdomainhistory.FieldTags:
		m.ClearTags()
		return nil
	case customdomainhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case customdomainhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case customdomainhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case customdomainhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case customdomainhistory.FieldDNSVerificationID:
		m.ClearDNSVerificationID()
		return nil
	}
	return fmt.Errorf("unknown CustomDomainHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomDomainHistoryMutation) ResetField(name string) error {
	switch name {
	case customdomainhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case customdomainhistory.FieldRef:
		m.ResetRef()
		return nil
	case customdomainhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case customdomainhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customdomainhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customdomainhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case customdomainhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case customdomainhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case customdomainhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case customdomainhistory.FieldTags:
		m.ResetTags()
		return nil
	case customdomainhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case customdomainhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case customdomainhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case customdomainhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case customdomainhistory.FieldCnameRecord:
		m.ResetCnameRecord()
		return nil
	case customdomainhistory.FieldMappableDomainID:
		m.ResetMappableDomainID()
		return nil
	case customdomainhistory.FieldDNSVerificationID:
		m.ResetDNSVerificationID()
		return nil
	}
	return fmt.Errorf("unknown CustomDomainHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomDomainHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomDomainHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomDomainHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomDomainHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomDomainHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomDomainHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomDomainHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CustomDomainHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomDomainHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CustomDomainHistory edge %s", name)
}

// DNSVerificationHistoryMutation represents an operation that mutates the DNSVerificationHistory nodes in the graph.
type DNSVerificationHistoryMutation struct {
	config
	op                             Op
	typ                            string
	id                             *string
	history_time                   *time.Time
	ref                            *string
	operation                      *history.OpType
	created_at                     *time.Time
	updated_at                     *time.Time
	created_by                     *string
	updated_by                     *string
	deleted_at                     *time.Time
	deleted_by                     *string
	tags                           *[]string
	appendtags                     []string
	owner_id                       *string
	cloudflare_hostname_id         *string
	dns_txt_record                 *string
	dns_txt_value                  *string
	dns_verification_status        *enums.DNSVerificationStatus
	dns_verification_status_reason *string
	acme_challenge_path            *string
	expected_acme_challenge_value  *string
	acme_challenge_status          *enums.SSLVerificationStatus
	acme_challenge_status_reason   *string
	clearedFields                  map[string]struct{}
	done                           bool
	oldValue                       func(context.Context) (*DNSVerificationHistory, error)
	predicates                     []predicate.DNSVerificationHistory
}

var _ ent.Mutation = (*DNSVerificationHistoryMutation)(nil)

// dnsverificationhistoryOption allows management of the mutation configuration using functional options.
type dnsverificationhistoryOption func(*DNSVerificationHistoryMutation)

// newDNSVerificationHistoryMutation creates new mutation for the DNSVerificationHistory entity.
func newDNSVerificationHistoryMutation(c config, op Op, opts ...dnsverificationhistoryOption) *DNSVerificationHistoryMutation {
	m := &DNSVerificationHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeDNSVerificationHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDNSVerificationHistoryID sets the ID field of the mutation.
func withDNSVerificationHistoryID(id string) dnsverificationhistoryOption {
	return func(m *DNSVerificationHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *DNSVerificationHistory
		)
		m.oldValue = func(ctx context.Context) (*DNSVerificationHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DNSVerificationHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDNSVerificationHistory sets the old DNSVerificationHistory of the mutation.
func withDNSVerificationHistory(node *DNSVerificationHistory) dnsverificationhistoryOption {
	return func(m *DNSVerificationHistoryMutation) {
		m.oldValue = func(context.Context) (*DNSVerificationHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DNSVerificationHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DNSVerificationHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DNSVerificationHistory entities.
func (m *DNSVerificationHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DNSVerificationHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DNSVerificationHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DNSVerificationHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *DNSVerificationHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *DNSVerificationHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *DNSVerificationHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *DNSVerificationHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *DNSVerificationHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *DNSVerificationHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[dnsverificationhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *DNSVerificationHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[dnsverificationhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *DNSVerificationHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, dnsverificationhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *DNSVerificationHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *DNSVerificationHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *DNSVerificationHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DNSVerificationHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DNSVerificationHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DNSVerificationHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[dnsverificationhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DNSVerificationHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[dnsverificationhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DNSVerificationHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, dnsverificationhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DNSVerificationHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DNSVerificationHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DNSVerificationHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[dnsverificationhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DNSVerificationHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[dnsverificationhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DNSVerificationHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, dnsverificationhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *DNSVerificationHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DNSVerificationHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DNSVerificationHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[dnsverificationhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DNSVerificationHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[dnsverificationhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DNSVerificationHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, dnsverificationhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DNSVerificationHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DNSVerificationHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DNSVerificationHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[dnsverificationhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DNSVerificationHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[dnsverificationhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DNSVerificationHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, dnsverificationhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DNSVerificationHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DNSVerificationHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DNSVerificationHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dnsverificationhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DNSVerificationHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dnsverificationhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DNSVerificationHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dnsverificationhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *DNSVerificationHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *DNSVerificationHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *DNSVerificationHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[dnsverificationhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *DNSVerificationHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[dnsverificationhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *DNSVerificationHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, dnsverificationhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *DNSVerificationHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *DNSVerificationHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *DNSVerificationHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *DNSVerificationHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *DNSVerificationHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[dnsverificationhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *DNSVerificationHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[dnsverificationhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *DNSVerificationHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, dnsverificationhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *DNSVerificationHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *DNSVerificationHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *DNSVerificationHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[dnsverificationhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *DNSVerificationHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[dnsverificationhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *DNSVerificationHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, dnsverificationhistory.FieldOwnerID)
}

// SetCloudflareHostnameID sets the "cloudflare_hostname_id" field.
func (m *DNSVerificationHistoryMutation) SetCloudflareHostnameID(s string) {
	m.cloudflare_hostname_id = &s
}

// CloudflareHostnameID returns the value of the "cloudflare_hostname_id" field in the mutation.
func (m *DNSVerificationHistoryMutation) CloudflareHostnameID() (r string, exists bool) {
	v := m.cloudflare_hostname_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCloudflareHostnameID returns the old "cloudflare_hostname_id" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldCloudflareHostnameID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloudflareHostnameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloudflareHostnameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloudflareHostnameID: %w", err)
	}
	return oldValue.CloudflareHostnameID, nil
}

// ResetCloudflareHostnameID resets all changes to the "cloudflare_hostname_id" field.
func (m *DNSVerificationHistoryMutation) ResetCloudflareHostnameID() {
	m.cloudflare_hostname_id = nil
}

// SetDNSTxtRecord sets the "dns_txt_record" field.
func (m *DNSVerificationHistoryMutation) SetDNSTxtRecord(s string) {
	m.dns_txt_record = &s
}

// DNSTxtRecord returns the value of the "dns_txt_record" field in the mutation.
func (m *DNSVerificationHistoryMutation) DNSTxtRecord() (r string, exists bool) {
	v := m.dns_txt_record
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSTxtRecord returns the old "dns_txt_record" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldDNSTxtRecord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSTxtRecord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSTxtRecord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSTxtRecord: %w", err)
	}
	return oldValue.DNSTxtRecord, nil
}

// ResetDNSTxtRecord resets all changes to the "dns_txt_record" field.
func (m *DNSVerificationHistoryMutation) ResetDNSTxtRecord() {
	m.dns_txt_record = nil
}

// SetDNSTxtValue sets the "dns_txt_value" field.
func (m *DNSVerificationHistoryMutation) SetDNSTxtValue(s string) {
	m.dns_txt_value = &s
}

// DNSTxtValue returns the value of the "dns_txt_value" field in the mutation.
func (m *DNSVerificationHistoryMutation) DNSTxtValue() (r string, exists bool) {
	v := m.dns_txt_value
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSTxtValue returns the old "dns_txt_value" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldDNSTxtValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSTxtValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSTxtValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSTxtValue: %w", err)
	}
	return oldValue.DNSTxtValue, nil
}

// ResetDNSTxtValue resets all changes to the "dns_txt_value" field.
func (m *DNSVerificationHistoryMutation) ResetDNSTxtValue() {
	m.dns_txt_value = nil
}

// SetDNSVerificationStatus sets the "dns_verification_status" field.
func (m *DNSVerificationHistoryMutation) SetDNSVerificationStatus(evs enums.DNSVerificationStatus) {
	m.dns_verification_status = &evs
}

// DNSVerificationStatus returns the value of the "dns_verification_status" field in the mutation.
func (m *DNSVerificationHistoryMutation) DNSVerificationStatus() (r enums.DNSVerificationStatus, exists bool) {
	v := m.dns_verification_status
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSVerificationStatus returns the old "dns_verification_status" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldDNSVerificationStatus(ctx context.Context) (v enums.DNSVerificationStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSVerificationStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSVerificationStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSVerificationStatus: %w", err)
	}
	return oldValue.DNSVerificationStatus, nil
}

// ResetDNSVerificationStatus resets all changes to the "dns_verification_status" field.
func (m *DNSVerificationHistoryMutation) ResetDNSVerificationStatus() {
	m.dns_verification_status = nil
}

// SetDNSVerificationStatusReason sets the "dns_verification_status_reason" field.
func (m *DNSVerificationHistoryMutation) SetDNSVerificationStatusReason(s string) {
	m.dns_verification_status_reason = &s
}

// DNSVerificationStatusReason returns the value of the "dns_verification_status_reason" field in the mutation.
func (m *DNSVerificationHistoryMutation) DNSVerificationStatusReason() (r string, exists bool) {
	v := m.dns_verification_status_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSVerificationStatusReason returns the old "dns_verification_status_reason" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldDNSVerificationStatusReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSVerificationStatusReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSVerificationStatusReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSVerificationStatusReason: %w", err)
	}
	return oldValue.DNSVerificationStatusReason, nil
}

// ClearDNSVerificationStatusReason clears the value of the "dns_verification_status_reason" field.
func (m *DNSVerificationHistoryMutation) ClearDNSVerificationStatusReason() {
	m.dns_verification_status_reason = nil
	m.clearedFields[dnsverificationhistory.FieldDNSVerificationStatusReason] = struct{}{}
}

// DNSVerificationStatusReasonCleared returns if the "dns_verification_status_reason" field was cleared in this mutation.
func (m *DNSVerificationHistoryMutation) DNSVerificationStatusReasonCleared() bool {
	_, ok := m.clearedFields[dnsverificationhistory.FieldDNSVerificationStatusReason]
	return ok
}

// ResetDNSVerificationStatusReason resets all changes to the "dns_verification_status_reason" field.
func (m *DNSVerificationHistoryMutation) ResetDNSVerificationStatusReason() {
	m.dns_verification_status_reason = nil
	delete(m.clearedFields, dnsverificationhistory.FieldDNSVerificationStatusReason)
}

// SetAcmeChallengePath sets the "acme_challenge_path" field.
func (m *DNSVerificationHistoryMutation) SetAcmeChallengePath(s string) {
	m.acme_challenge_path = &s
}

// AcmeChallengePath returns the value of the "acme_challenge_path" field in the mutation.
func (m *DNSVerificationHistoryMutation) AcmeChallengePath() (r string, exists bool) {
	v := m.acme_challenge_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAcmeChallengePath returns the old "acme_challenge_path" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldAcmeChallengePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcmeChallengePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcmeChallengePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcmeChallengePath: %w", err)
	}
	return oldValue.AcmeChallengePath, nil
}

// ClearAcmeChallengePath clears the value of the "acme_challenge_path" field.
func (m *DNSVerificationHistoryMutation) ClearAcmeChallengePath() {
	m.acme_challenge_path = nil
	m.clearedFields[dnsverificationhistory.FieldAcmeChallengePath] = struct{}{}
}

// AcmeChallengePathCleared returns if the "acme_challenge_path" field was cleared in this mutation.
func (m *DNSVerificationHistoryMutation) AcmeChallengePathCleared() bool {
	_, ok := m.clearedFields[dnsverificationhistory.FieldAcmeChallengePath]
	return ok
}

// ResetAcmeChallengePath resets all changes to the "acme_challenge_path" field.
func (m *DNSVerificationHistoryMutation) ResetAcmeChallengePath() {
	m.acme_challenge_path = nil
	delete(m.clearedFields, dnsverificationhistory.FieldAcmeChallengePath)
}

// SetExpectedAcmeChallengeValue sets the "expected_acme_challenge_value" field.
func (m *DNSVerificationHistoryMutation) SetExpectedAcmeChallengeValue(s string) {
	m.expected_acme_challenge_value = &s
}

// ExpectedAcmeChallengeValue returns the value of the "expected_acme_challenge_value" field in the mutation.
func (m *DNSVerificationHistoryMutation) ExpectedAcmeChallengeValue() (r string, exists bool) {
	v := m.expected_acme_challenge_value
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectedAcmeChallengeValue returns the old "expected_acme_challenge_value" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldExpectedAcmeChallengeValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpectedAcmeChallengeValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpectedAcmeChallengeValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectedAcmeChallengeValue: %w", err)
	}
	return oldValue.ExpectedAcmeChallengeValue, nil
}

// ClearExpectedAcmeChallengeValue clears the value of the "expected_acme_challenge_value" field.
func (m *DNSVerificationHistoryMutation) ClearExpectedAcmeChallengeValue() {
	m.expected_acme_challenge_value = nil
	m.clearedFields[dnsverificationhistory.FieldExpectedAcmeChallengeValue] = struct{}{}
}

// ExpectedAcmeChallengeValueCleared returns if the "expected_acme_challenge_value" field was cleared in this mutation.
func (m *DNSVerificationHistoryMutation) ExpectedAcmeChallengeValueCleared() bool {
	_, ok := m.clearedFields[dnsverificationhistory.FieldExpectedAcmeChallengeValue]
	return ok
}

// ResetExpectedAcmeChallengeValue resets all changes to the "expected_acme_challenge_value" field.
func (m *DNSVerificationHistoryMutation) ResetExpectedAcmeChallengeValue() {
	m.expected_acme_challenge_value = nil
	delete(m.clearedFields, dnsverificationhistory.FieldExpectedAcmeChallengeValue)
}

// SetAcmeChallengeStatus sets the "acme_challenge_status" field.
func (m *DNSVerificationHistoryMutation) SetAcmeChallengeStatus(evs enums.SSLVerificationStatus) {
	m.acme_challenge_status = &evs
}

// AcmeChallengeStatus returns the value of the "acme_challenge_status" field in the mutation.
func (m *DNSVerificationHistoryMutation) AcmeChallengeStatus() (r enums.SSLVerificationStatus, exists bool) {
	v := m.acme_challenge_status
	if v == nil {
		return
	}
	return *v, true
}

// OldAcmeChallengeStatus returns the old "acme_challenge_status" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldAcmeChallengeStatus(ctx context.Context) (v enums.SSLVerificationStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcmeChallengeStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcmeChallengeStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcmeChallengeStatus: %w", err)
	}
	return oldValue.AcmeChallengeStatus, nil
}

// ResetAcmeChallengeStatus resets all changes to the "acme_challenge_status" field.
func (m *DNSVerificationHistoryMutation) ResetAcmeChallengeStatus() {
	m.acme_challenge_status = nil
}

// SetAcmeChallengeStatusReason sets the "acme_challenge_status_reason" field.
func (m *DNSVerificationHistoryMutation) SetAcmeChallengeStatusReason(s string) {
	m.acme_challenge_status_reason = &s
}

// AcmeChallengeStatusReason returns the value of the "acme_challenge_status_reason" field in the mutation.
func (m *DNSVerificationHistoryMutation) AcmeChallengeStatusReason() (r string, exists bool) {
	v := m.acme_challenge_status_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldAcmeChallengeStatusReason returns the old "acme_challenge_status_reason" field's value of the DNSVerificationHistory entity.
// If the DNSVerificationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSVerificationHistoryMutation) OldAcmeChallengeStatusReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcmeChallengeStatusReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcmeChallengeStatusReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcmeChallengeStatusReason: %w", err)
	}
	return oldValue.AcmeChallengeStatusReason, nil
}

// ClearAcmeChallengeStatusReason clears the value of the "acme_challenge_status_reason" field.
func (m *DNSVerificationHistoryMutation) ClearAcmeChallengeStatusReason() {
	m.acme_challenge_status_reason = nil
	m.clearedFields[dnsverificationhistory.FieldAcmeChallengeStatusReason] = struct{}{}
}

// AcmeChallengeStatusReasonCleared returns if the "acme_challenge_status_reason" field was cleared in this mutation.
func (m *DNSVerificationHistoryMutation) AcmeChallengeStatusReasonCleared() bool {
	_, ok := m.clearedFields[dnsverificationhistory.FieldAcmeChallengeStatusReason]
	return ok
}

// ResetAcmeChallengeStatusReason resets all changes to the "acme_challenge_status_reason" field.
func (m *DNSVerificationHistoryMutation) ResetAcmeChallengeStatusReason() {
	m.acme_challenge_status_reason = nil
	delete(m.clearedFields, dnsverificationhistory.FieldAcmeChallengeStatusReason)
}

// Where appends a list predicates to the DNSVerificationHistoryMutation builder.
func (m *DNSVerificationHistoryMutation) Where(ps ...predicate.DNSVerificationHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DNSVerificationHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DNSVerificationHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DNSVerificationHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DNSVerificationHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DNSVerificationHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DNSVerificationHistory).
func (m *DNSVerificationHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DNSVerificationHistoryMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.history_time != nil {
		fields = append(fields, dnsverificationhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, dnsverificationhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, dnsverificationhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, dnsverificationhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dnsverificationhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, dnsverificationhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, dnsverificationhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, dnsverificationhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, dnsverificationhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, dnsverificationhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, dnsverificationhistory.FieldOwnerID)
	}
	if m.cloudflare_hostname_id != nil {
		fields = append(fields, dnsverificationhistory.FieldCloudflareHostnameID)
	}
	if m.dns_txt_record != nil {
		fields = append(fields, dnsverificationhistory.FieldDNSTxtRecord)
	}
	if m.dns_txt_value != nil {
		fields = append(fields, dnsverificationhistory.FieldDNSTxtValue)
	}
	if m.dns_verification_status != nil {
		fields = append(fields, dnsverificationhistory.FieldDNSVerificationStatus)
	}
	if m.dns_verification_status_reason != nil {
		fields = append(fields, dnsverificationhistory.FieldDNSVerificationStatusReason)
	}
	if m.acme_challenge_path != nil {
		fields = append(fields, dnsverificationhistory.FieldAcmeChallengePath)
	}
	if m.expected_acme_challenge_value != nil {
		fields = append(fields, dnsverificationhistory.FieldExpectedAcmeChallengeValue)
	}
	if m.acme_challenge_status != nil {
		fields = append(fields, dnsverificationhistory.FieldAcmeChallengeStatus)
	}
	if m.acme_challenge_status_reason != nil {
		fields = append(fields, dnsverificationhistory.FieldAcmeChallengeStatusReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DNSVerificationHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dnsverificationhistory.FieldHistoryTime:
		return m.HistoryTime()
	case dnsverificationhistory.FieldRef:
		return m.Ref()
	case dnsverificationhistory.FieldOperation:
		return m.Operation()
	case dnsverificationhistory.FieldCreatedAt:
		return m.CreatedAt()
	case dnsverificationhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case dnsverificationhistory.FieldCreatedBy:
		return m.CreatedBy()
	case dnsverificationhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case dnsverificationhistory.FieldDeletedAt:
		return m.DeletedAt()
	case dnsverificationhistory.FieldDeletedBy:
		return m.DeletedBy()
	case dnsverificationhistory.FieldTags:
		return m.Tags()
	case dnsverificationhistory.FieldOwnerID:
		return m.OwnerID()
	case dnsverificationhistory.FieldCloudflareHostnameID:
		return m.CloudflareHostnameID()
	case dnsverificationhistory.FieldDNSTxtRecord:
		return m.DNSTxtRecord()
	case dnsverificationhistory.FieldDNSTxtValue:
		return m.DNSTxtValue()
	case dnsverificationhistory.FieldDNSVerificationStatus:
		return m.DNSVerificationStatus()
	case dnsverificationhistory.FieldDNSVerificationStatusReason:
		return m.DNSVerificationStatusReason()
	case dnsverificationhistory.FieldAcmeChallengePath:
		return m.AcmeChallengePath()
	case dnsverificationhistory.FieldExpectedAcmeChallengeValue:
		return m.ExpectedAcmeChallengeValue()
	case dnsverificationhistory.FieldAcmeChallengeStatus:
		return m.AcmeChallengeStatus()
	case dnsverificationhistory.FieldAcmeChallengeStatusReason:
		return m.AcmeChallengeStatusReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DNSVerificationHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dnsverificationhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case dnsverificationhistory.FieldRef:
		return m.OldRef(ctx)
	case dnsverificationhistory.FieldOperation:
		return m.OldOperation(ctx)
	case dnsverificationhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dnsverificationhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dnsverificationhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case dnsverificationhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case dnsverificationhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dnsverificationhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case dnsverificationhistory.FieldTags:
		return m.OldTags(ctx)
	case dnsverificationhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case dnsverificationhistory.FieldCloudflareHostnameID:
		return m.OldCloudflareHostnameID(ctx)
	case dnsverificationhistory.FieldDNSTxtRecord:
		return m.OldDNSTxtRecord(ctx)
	case dnsverificationhistory.FieldDNSTxtValue:
		return m.OldDNSTxtValue(ctx)
	case dnsverificationhistory.FieldDNSVerificationStatus:
		return m.OldDNSVerificationStatus(ctx)
	case dnsverificationhistory.FieldDNSVerificationStatusReason:
		return m.OldDNSVerificationStatusReason(ctx)
	case dnsverificationhistory.FieldAcmeChallengePath:
		return m.OldAcmeChallengePath(ctx)
	case dnsverificationhistory.FieldExpectedAcmeChallengeValue:
		return m.OldExpectedAcmeChallengeValue(ctx)
	case dnsverificationhistory.FieldAcmeChallengeStatus:
		return m.OldAcmeChallengeStatus(ctx)
	case dnsverificationhistory.FieldAcmeChallengeStatusReason:
		return m.OldAcmeChallengeStatusReason(ctx)
	}
	return nil, fmt.Errorf("unknown DNSVerificationHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSVerificationHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dnsverificationhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case dnsverificationhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case dnsverificationhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case dnsverificationhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dnsverificationhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dnsverificationhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case dnsverificationhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case dnsverificationhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dnsverificationhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case dnsverificationhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case dnsverificationhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case dnsverificationhistory.FieldCloudflareHostnameID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloudflareHostnameID(v)
		return nil
	case dnsverificationhistory.FieldDNSTxtRecord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSTxtRecord(v)
		return nil
	case dnsverificationhistory.FieldDNSTxtValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSTxtValue(v)
		return nil
	case dnsverificationhistory.FieldDNSVerificationStatus:
		v, ok := value.(enums.DNSVerificationStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSVerificationStatus(v)
		return nil
	case dnsverificationhistory.FieldDNSVerificationStatusReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSVerificationStatusReason(v)
		return nil
	case dnsverificationhistory.FieldAcmeChallengePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcmeChallengePath(v)
		return nil
	case dnsverificationhistory.FieldExpectedAcmeChallengeValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectedAcmeChallengeValue(v)
		return nil
	case dnsverificationhistory.FieldAcmeChallengeStatus:
		v, ok := value.(enums.SSLVerificationStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcmeChallengeStatus(v)
		return nil
	case dnsverificationhistory.FieldAcmeChallengeStatusReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcmeChallengeStatusReason(v)
		return nil
	}
	return fmt.Errorf("unknown DNSVerificationHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DNSVerificationHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DNSVerificationHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSVerificationHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DNSVerificationHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DNSVerificationHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dnsverificationhistory.FieldRef) {
		fields = append(fields, dnsverificationhistory.FieldRef)
	}
	if m.FieldCleared(dnsverificationhistory.FieldCreatedAt) {
		fields = append(fields, dnsverificationhistory.FieldCreatedAt)
	}
	if m.FieldCleared(dnsverificationhistory.FieldUpdatedAt) {
		fields = append(fields, dnsverificationhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(dnsverificationhistory.FieldCreatedBy) {
		fields = append(fields, dnsverificationhistory.FieldCreatedBy)
	}
	if m.FieldCleared(dnsverificationhistory.FieldUpdatedBy) {
		fields = append(fields, dnsverificationhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(dnsverificationhistory.FieldDeletedAt) {
		fields = append(fields, dnsverificationhistory.FieldDeletedAt)
	}
	if m.FieldCleared(dnsverificationhistory.FieldDeletedBy) {
		fields = append(fields, dnsverificationhistory.FieldDeletedBy)
	}
	if m.FieldCleared(dnsverificationhistory.FieldTags) {
		fields = append(fields, dnsverificationhistory.FieldTags)
	}
	if m.FieldCleared(dnsverificationhistory.FieldOwnerID) {
		fields = append(fields, dnsverificationhistory.FieldOwnerID)
	}
	if m.FieldCleared(dnsverificationhistory.FieldDNSVerificationStatusReason) {
		fields = append(fields, dnsverificationhistory.FieldDNSVerificationStatusReason)
	}
	if m.FieldCleared(dnsverificationhistory.FieldAcmeChallengePath) {
		fields = append(fields, dnsverificationhistory.FieldAcmeChallengePath)
	}
	if m.FieldCleared(dnsverificationhistory.FieldExpectedAcmeChallengeValue) {
		fields = append(fields, dnsverificationhistory.FieldExpectedAcmeChallengeValue)
	}
	if m.FieldCleared(dnsverificationhistory.FieldAcmeChallengeStatusReason) {
		fields = append(fields, dnsverificationhistory.FieldAcmeChallengeStatusReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DNSVerificationHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DNSVerificationHistoryMutation) ClearField(name string) error {
	switch name {
	case dnsverificationhistory.FieldRef:
		m.ClearRef()
		return nil
	case dnsverificationhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case dnsverificationhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case dnsverificationhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case dnsverificationhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case dnsverificationhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dnsverificationhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case dnsverificationhistory.FieldTags:
		m.ClearTags()
		return nil
	case dnsverificationhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case dnsverificationhistory.FieldDNSVerificationStatusReason:
		m.ClearDNSVerificationStatusReason()
		return nil
	case dnsverificationhistory.FieldAcmeChallengePath:
		m.ClearAcmeChallengePath()
		return nil
	case dnsverificationhistory.FieldExpectedAcmeChallengeValue:
		m.ClearExpectedAcmeChallengeValue()
		return nil
	case dnsverificationhistory.FieldAcmeChallengeStatusReason:
		m.ClearAcmeChallengeStatusReason()
		return nil
	}
	return fmt.Errorf("unknown DNSVerificationHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DNSVerificationHistoryMutation) ResetField(name string) error {
	switch name {
	case dnsverificationhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case dnsverificationhistory.FieldRef:
		m.ResetRef()
		return nil
	case dnsverificationhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case dnsverificationhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dnsverificationhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dnsverificationhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case dnsverificationhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case dnsverificationhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dnsverificationhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case dnsverificationhistory.FieldTags:
		m.ResetTags()
		return nil
	case dnsverificationhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case dnsverificationhistory.FieldCloudflareHostnameID:
		m.ResetCloudflareHostnameID()
		return nil
	case dnsverificationhistory.FieldDNSTxtRecord:
		m.ResetDNSTxtRecord()
		return nil
	case dnsverificationhistory.FieldDNSTxtValue:
		m.ResetDNSTxtValue()
		return nil
	case dnsverificationhistory.FieldDNSVerificationStatus:
		m.ResetDNSVerificationStatus()
		return nil
	case dnsverificationhistory.FieldDNSVerificationStatusReason:
		m.ResetDNSVerificationStatusReason()
		return nil
	case dnsverificationhistory.FieldAcmeChallengePath:
		m.ResetAcmeChallengePath()
		return nil
	case dnsverificationhistory.FieldExpectedAcmeChallengeValue:
		m.ResetExpectedAcmeChallengeValue()
		return nil
	case dnsverificationhistory.FieldAcmeChallengeStatus:
		m.ResetAcmeChallengeStatus()
		return nil
	case dnsverificationhistory.FieldAcmeChallengeStatusReason:
		m.ResetAcmeChallengeStatusReason()
		return nil
	}
	return fmt.Errorf("unknown DNSVerificationHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DNSVerificationHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DNSVerificationHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DNSVerificationHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DNSVerificationHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DNSVerificationHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DNSVerificationHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DNSVerificationHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DNSVerificationHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DNSVerificationHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DNSVerificationHistory edge %s", name)
}

// DirectoryAccountHistoryMutation represents an operation that mutates the DirectoryAccountHistory nodes in the graph.
type DirectoryAccountHistoryMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	history_time          *time.Time
	ref                   *string
	operation             *history.OpType
	created_at            *time.Time
	updated_at            *time.Time
	created_by            *string
	updated_by            *string
	display_id            *string
	tags                  *[]string
	appendtags            []string
	owner_id              *string
	integration_id        *string
	directory_sync_run_id *string
	external_id           *string
	secondary_key         *string
	canonical_email       *string
	display_name          *string
	given_name            *string
	family_name           *string
	job_title             *string
	department            *string
	organization_unit     *string
	account_type          *enums.DirectoryAccountType
	status                *enums.DirectoryAccountStatus
	mfa_state             *enums.DirectoryAccountMFAState
	last_seen_ip          *string
	last_login_at         *time.Time
	observed_at           *time.Time
	profile_hash          *string
	profile               *map[string]interface{}
	raw_profile_file_id   *string
	source_version        *string
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*DirectoryAccountHistory, error)
	predicates            []predicate.DirectoryAccountHistory
}

var _ ent.Mutation = (*DirectoryAccountHistoryMutation)(nil)

// directoryaccounthistoryOption allows management of the mutation configuration using functional options.
type directoryaccounthistoryOption func(*DirectoryAccountHistoryMutation)

// newDirectoryAccountHistoryMutation creates new mutation for the DirectoryAccountHistory entity.
func newDirectoryAccountHistoryMutation(c config, op Op, opts ...directoryaccounthistoryOption) *DirectoryAccountHistoryMutation {
	m := &DirectoryAccountHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeDirectoryAccountHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDirectoryAccountHistoryID sets the ID field of the mutation.
func withDirectoryAccountHistoryID(id string) directoryaccounthistoryOption {
	return func(m *DirectoryAccountHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *DirectoryAccountHistory
		)
		m.oldValue = func(ctx context.Context) (*DirectoryAccountHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DirectoryAccountHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDirectoryAccountHistory sets the old DirectoryAccountHistory of the mutation.
func withDirectoryAccountHistory(node *DirectoryAccountHistory) directoryaccounthistoryOption {
	return func(m *DirectoryAccountHistoryMutation) {
		m.oldValue = func(context.Context) (*DirectoryAccountHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DirectoryAccountHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DirectoryAccountHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DirectoryAccountHistory entities.
func (m *DirectoryAccountHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DirectoryAccountHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DirectoryAccountHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DirectoryAccountHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *DirectoryAccountHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *DirectoryAccountHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *DirectoryAccountHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *DirectoryAccountHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *DirectoryAccountHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *DirectoryAccountHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[directoryaccounthistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *DirectoryAccountHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, directoryaccounthistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *DirectoryAccountHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *DirectoryAccountHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *DirectoryAccountHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DirectoryAccountHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DirectoryAccountHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DirectoryAccountHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[directoryaccounthistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DirectoryAccountHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, directoryaccounthistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DirectoryAccountHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DirectoryAccountHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DirectoryAccountHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[directoryaccounthistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DirectoryAccountHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, directoryaccounthistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *DirectoryAccountHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DirectoryAccountHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DirectoryAccountHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[directoryaccounthistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DirectoryAccountHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, directoryaccounthistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DirectoryAccountHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DirectoryAccountHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DirectoryAccountHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[directoryaccounthistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DirectoryAccountHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, directoryaccounthistory.FieldUpdatedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *DirectoryAccountHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *DirectoryAccountHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *DirectoryAccountHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *DirectoryAccountHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *DirectoryAccountHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *DirectoryAccountHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *DirectoryAccountHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *DirectoryAccountHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[directoryaccounthistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *DirectoryAccountHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, directoryaccounthistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *DirectoryAccountHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *DirectoryAccountHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *DirectoryAccountHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[directoryaccounthistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *DirectoryAccountHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, directoryaccounthistory.FieldOwnerID)
}

// SetIntegrationID sets the "integration_id" field.
func (m *DirectoryAccountHistoryMutation) SetIntegrationID(s string) {
	m.integration_id = &s
}

// IntegrationID returns the value of the "integration_id" field in the mutation.
func (m *DirectoryAccountHistoryMutation) IntegrationID() (r string, exists bool) {
	v := m.integration_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIntegrationID returns the old "integration_id" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldIntegrationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntegrationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntegrationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntegrationID: %w", err)
	}
	return oldValue.IntegrationID, nil
}

// ResetIntegrationID resets all changes to the "integration_id" field.
func (m *DirectoryAccountHistoryMutation) ResetIntegrationID() {
	m.integration_id = nil
}

// SetDirectorySyncRunID sets the "directory_sync_run_id" field.
func (m *DirectoryAccountHistoryMutation) SetDirectorySyncRunID(s string) {
	m.directory_sync_run_id = &s
}

// DirectorySyncRunID returns the value of the "directory_sync_run_id" field in the mutation.
func (m *DirectoryAccountHistoryMutation) DirectorySyncRunID() (r string, exists bool) {
	v := m.directory_sync_run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectorySyncRunID returns the old "directory_sync_run_id" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldDirectorySyncRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectorySyncRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectorySyncRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectorySyncRunID: %w", err)
	}
	return oldValue.DirectorySyncRunID, nil
}

// ResetDirectorySyncRunID resets all changes to the "directory_sync_run_id" field.
func (m *DirectoryAccountHistoryMutation) ResetDirectorySyncRunID() {
	m.directory_sync_run_id = nil
}

// SetExternalID sets the "external_id" field.
func (m *DirectoryAccountHistoryMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *DirectoryAccountHistoryMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *DirectoryAccountHistoryMutation) ResetExternalID() {
	m.external_id = nil
}

// SetSecondaryKey sets the "secondary_key" field.
func (m *DirectoryAccountHistoryMutation) SetSecondaryKey(s string) {
	m.secondary_key = &s
}

// SecondaryKey returns the value of the "secondary_key" field in the mutation.
func (m *DirectoryAccountHistoryMutation) SecondaryKey() (r string, exists bool) {
	v := m.secondary_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondaryKey returns the old "secondary_key" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldSecondaryKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondaryKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondaryKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondaryKey: %w", err)
	}
	return oldValue.SecondaryKey, nil
}

// ClearSecondaryKey clears the value of the "secondary_key" field.
func (m *DirectoryAccountHistoryMutation) ClearSecondaryKey() {
	m.secondary_key = nil
	m.clearedFields[directoryaccounthistory.FieldSecondaryKey] = struct{}{}
}

// SecondaryKeyCleared returns if the "secondary_key" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) SecondaryKeyCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldSecondaryKey]
	return ok
}

// ResetSecondaryKey resets all changes to the "secondary_key" field.
func (m *DirectoryAccountHistoryMutation) ResetSecondaryKey() {
	m.secondary_key = nil
	delete(m.clearedFields, directoryaccounthistory.FieldSecondaryKey)
}

// SetCanonicalEmail sets the "canonical_email" field.
func (m *DirectoryAccountHistoryMutation) SetCanonicalEmail(s string) {
	m.canonical_email = &s
}

// CanonicalEmail returns the value of the "canonical_email" field in the mutation.
func (m *DirectoryAccountHistoryMutation) CanonicalEmail() (r string, exists bool) {
	v := m.canonical_email
	if v == nil {
		return
	}
	return *v, true
}

// OldCanonicalEmail returns the old "canonical_email" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldCanonicalEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanonicalEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanonicalEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanonicalEmail: %w", err)
	}
	return oldValue.CanonicalEmail, nil
}

// ClearCanonicalEmail clears the value of the "canonical_email" field.
func (m *DirectoryAccountHistoryMutation) ClearCanonicalEmail() {
	m.canonical_email = nil
	m.clearedFields[directoryaccounthistory.FieldCanonicalEmail] = struct{}{}
}

// CanonicalEmailCleared returns if the "canonical_email" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) CanonicalEmailCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldCanonicalEmail]
	return ok
}

// ResetCanonicalEmail resets all changes to the "canonical_email" field.
func (m *DirectoryAccountHistoryMutation) ResetCanonicalEmail() {
	m.canonical_email = nil
	delete(m.clearedFields, directoryaccounthistory.FieldCanonicalEmail)
}

// SetDisplayName sets the "display_name" field.
func (m *DirectoryAccountHistoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *DirectoryAccountHistoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *DirectoryAccountHistoryMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[directoryaccounthistory.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *DirectoryAccountHistoryMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, directoryaccounthistory.FieldDisplayName)
}

// SetGivenName sets the "given_name" field.
func (m *DirectoryAccountHistoryMutation) SetGivenName(s string) {
	m.given_name = &s
}

// GivenName returns the value of the "given_name" field in the mutation.
func (m *DirectoryAccountHistoryMutation) GivenName() (r string, exists bool) {
	v := m.given_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGivenName returns the old "given_name" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldGivenName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGivenName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGivenName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGivenName: %w", err)
	}
	return oldValue.GivenName, nil
}

// ClearGivenName clears the value of the "given_name" field.
func (m *DirectoryAccountHistoryMutation) ClearGivenName() {
	m.given_name = nil
	m.clearedFields[directoryaccounthistory.FieldGivenName] = struct{}{}
}

// GivenNameCleared returns if the "given_name" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) GivenNameCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldGivenName]
	return ok
}

// ResetGivenName resets all changes to the "given_name" field.
func (m *DirectoryAccountHistoryMutation) ResetGivenName() {
	m.given_name = nil
	delete(m.clearedFields, directoryaccounthistory.FieldGivenName)
}

// SetFamilyName sets the "family_name" field.
func (m *DirectoryAccountHistoryMutation) SetFamilyName(s string) {
	m.family_name = &s
}

// FamilyName returns the value of the "family_name" field in the mutation.
func (m *DirectoryAccountHistoryMutation) FamilyName() (r string, exists bool) {
	v := m.family_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFamilyName returns the old "family_name" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldFamilyName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamilyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamilyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamilyName: %w", err)
	}
	return oldValue.FamilyName, nil
}

// ClearFamilyName clears the value of the "family_name" field.
func (m *DirectoryAccountHistoryMutation) ClearFamilyName() {
	m.family_name = nil
	m.clearedFields[directoryaccounthistory.FieldFamilyName] = struct{}{}
}

// FamilyNameCleared returns if the "family_name" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) FamilyNameCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldFamilyName]
	return ok
}

// ResetFamilyName resets all changes to the "family_name" field.
func (m *DirectoryAccountHistoryMutation) ResetFamilyName() {
	m.family_name = nil
	delete(m.clearedFields, directoryaccounthistory.FieldFamilyName)
}

// SetJobTitle sets the "job_title" field.
func (m *DirectoryAccountHistoryMutation) SetJobTitle(s string) {
	m.job_title = &s
}

// JobTitle returns the value of the "job_title" field in the mutation.
func (m *DirectoryAccountHistoryMutation) JobTitle() (r string, exists bool) {
	v := m.job_title
	if v == nil {
		return
	}
	return *v, true
}

// OldJobTitle returns the old "job_title" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldJobTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobTitle: %w", err)
	}
	return oldValue.JobTitle, nil
}

// ClearJobTitle clears the value of the "job_title" field.
func (m *DirectoryAccountHistoryMutation) ClearJobTitle() {
	m.job_title = nil
	m.clearedFields[directoryaccounthistory.FieldJobTitle] = struct{}{}
}

// JobTitleCleared returns if the "job_title" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) JobTitleCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldJobTitle]
	return ok
}

// ResetJobTitle resets all changes to the "job_title" field.
func (m *DirectoryAccountHistoryMutation) ResetJobTitle() {
	m.job_title = nil
	delete(m.clearedFields, directoryaccounthistory.FieldJobTitle)
}

// SetDepartment sets the "department" field.
func (m *DirectoryAccountHistoryMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the value of the "department" field in the mutation.
func (m *DirectoryAccountHistoryMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old "department" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldDepartment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ClearDepartment clears the value of the "department" field.
func (m *DirectoryAccountHistoryMutation) ClearDepartment() {
	m.department = nil
	m.clearedFields[directoryaccounthistory.FieldDepartment] = struct{}{}
}

// DepartmentCleared returns if the "department" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) DepartmentCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldDepartment]
	return ok
}

// ResetDepartment resets all changes to the "department" field.
func (m *DirectoryAccountHistoryMutation) ResetDepartment() {
	m.department = nil
	delete(m.clearedFields, directoryaccounthistory.FieldDepartment)
}

// SetOrganizationUnit sets the "organization_unit" field.
func (m *DirectoryAccountHistoryMutation) SetOrganizationUnit(s string) {
	m.organization_unit = &s
}

// OrganizationUnit returns the value of the "organization_unit" field in the mutation.
func (m *DirectoryAccountHistoryMutation) OrganizationUnit() (r string, exists bool) {
	v := m.organization_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationUnit returns the old "organization_unit" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldOrganizationUnit(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationUnit: %w", err)
	}
	return oldValue.OrganizationUnit, nil
}

// ClearOrganizationUnit clears the value of the "organization_unit" field.
func (m *DirectoryAccountHistoryMutation) ClearOrganizationUnit() {
	m.organization_unit = nil
	m.clearedFields[directoryaccounthistory.FieldOrganizationUnit] = struct{}{}
}

// OrganizationUnitCleared returns if the "organization_unit" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) OrganizationUnitCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldOrganizationUnit]
	return ok
}

// ResetOrganizationUnit resets all changes to the "organization_unit" field.
func (m *DirectoryAccountHistoryMutation) ResetOrganizationUnit() {
	m.organization_unit = nil
	delete(m.clearedFields, directoryaccounthistory.FieldOrganizationUnit)
}

// SetAccountType sets the "account_type" field.
func (m *DirectoryAccountHistoryMutation) SetAccountType(eat enums.DirectoryAccountType) {
	m.account_type = &eat
}

// AccountType returns the value of the "account_type" field in the mutation.
func (m *DirectoryAccountHistoryMutation) AccountType() (r enums.DirectoryAccountType, exists bool) {
	v := m.account_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountType returns the old "account_type" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldAccountType(ctx context.Context) (v enums.DirectoryAccountType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountType: %w", err)
	}
	return oldValue.AccountType, nil
}

// ClearAccountType clears the value of the "account_type" field.
func (m *DirectoryAccountHistoryMutation) ClearAccountType() {
	m.account_type = nil
	m.clearedFields[directoryaccounthistory.FieldAccountType] = struct{}{}
}

// AccountTypeCleared returns if the "account_type" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) AccountTypeCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldAccountType]
	return ok
}

// ResetAccountType resets all changes to the "account_type" field.
func (m *DirectoryAccountHistoryMutation) ResetAccountType() {
	m.account_type = nil
	delete(m.clearedFields, directoryaccounthistory.FieldAccountType)
}

// SetStatus sets the "status" field.
func (m *DirectoryAccountHistoryMutation) SetStatus(eas enums.DirectoryAccountStatus) {
	m.status = &eas
}

// Status returns the value of the "status" field in the mutation.
func (m *DirectoryAccountHistoryMutation) Status() (r enums.DirectoryAccountStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldStatus(ctx context.Context) (v enums.DirectoryAccountStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DirectoryAccountHistoryMutation) ResetStatus() {
	m.status = nil
}

// SetMfaState sets the "mfa_state" field.
func (m *DirectoryAccountHistoryMutation) SetMfaState(eams enums.DirectoryAccountMFAState) {
	m.mfa_state = &eams
}

// MfaState returns the value of the "mfa_state" field in the mutation.
func (m *DirectoryAccountHistoryMutation) MfaState() (r enums.DirectoryAccountMFAState, exists bool) {
	v := m.mfa_state
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaState returns the old "mfa_state" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldMfaState(ctx context.Context) (v enums.DirectoryAccountMFAState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaState: %w", err)
	}
	return oldValue.MfaState, nil
}

// ResetMfaState resets all changes to the "mfa_state" field.
func (m *DirectoryAccountHistoryMutation) ResetMfaState() {
	m.mfa_state = nil
}

// SetLastSeenIP sets the "last_seen_ip" field.
func (m *DirectoryAccountHistoryMutation) SetLastSeenIP(s string) {
	m.last_seen_ip = &s
}

// LastSeenIP returns the value of the "last_seen_ip" field in the mutation.
func (m *DirectoryAccountHistoryMutation) LastSeenIP() (r string, exists bool) {
	v := m.last_seen_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenIP returns the old "last_seen_ip" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldLastSeenIP(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeenIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeenIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenIP: %w", err)
	}
	return oldValue.LastSeenIP, nil
}

// ClearLastSeenIP clears the value of the "last_seen_ip" field.
func (m *DirectoryAccountHistoryMutation) ClearLastSeenIP() {
	m.last_seen_ip = nil
	m.clearedFields[directoryaccounthistory.FieldLastSeenIP] = struct{}{}
}

// LastSeenIPCleared returns if the "last_seen_ip" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) LastSeenIPCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldLastSeenIP]
	return ok
}

// ResetLastSeenIP resets all changes to the "last_seen_ip" field.
func (m *DirectoryAccountHistoryMutation) ResetLastSeenIP() {
	m.last_seen_ip = nil
	delete(m.clearedFields, directoryaccounthistory.FieldLastSeenIP)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *DirectoryAccountHistoryMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *DirectoryAccountHistoryMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *DirectoryAccountHistoryMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[directoryaccounthistory.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *DirectoryAccountHistoryMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, directoryaccounthistory.FieldLastLoginAt)
}

// SetObservedAt sets the "observed_at" field.
func (m *DirectoryAccountHistoryMutation) SetObservedAt(t time.Time) {
	m.observed_at = &t
}

// ObservedAt returns the value of the "observed_at" field in the mutation.
func (m *DirectoryAccountHistoryMutation) ObservedAt() (r time.Time, exists bool) {
	v := m.observed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldObservedAt returns the old "observed_at" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldObservedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObservedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObservedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObservedAt: %w", err)
	}
	return oldValue.ObservedAt, nil
}

// ResetObservedAt resets all changes to the "observed_at" field.
func (m *DirectoryAccountHistoryMutation) ResetObservedAt() {
	m.observed_at = nil
}

// SetProfileHash sets the "profile_hash" field.
func (m *DirectoryAccountHistoryMutation) SetProfileHash(s string) {
	m.profile_hash = &s
}

// ProfileHash returns the value of the "profile_hash" field in the mutation.
func (m *DirectoryAccountHistoryMutation) ProfileHash() (r string, exists bool) {
	v := m.profile_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileHash returns the old "profile_hash" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldProfileHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileHash: %w", err)
	}
	return oldValue.ProfileHash, nil
}

// ResetProfileHash resets all changes to the "profile_hash" field.
func (m *DirectoryAccountHistoryMutation) ResetProfileHash() {
	m.profile_hash = nil
}

// SetProfile sets the "profile" field.
func (m *DirectoryAccountHistoryMutation) SetProfile(value map[string]interface{}) {
	m.profile = &value
}

// Profile returns the value of the "profile" field in the mutation.
func (m *DirectoryAccountHistoryMutation) Profile() (r map[string]interface{}, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfile returns the old "profile" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldProfile(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfile: %w", err)
	}
	return oldValue.Profile, nil
}

// ClearProfile clears the value of the "profile" field.
func (m *DirectoryAccountHistoryMutation) ClearProfile() {
	m.profile = nil
	m.clearedFields[directoryaccounthistory.FieldProfile] = struct{}{}
}

// ProfileCleared returns if the "profile" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) ProfileCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldProfile]
	return ok
}

// ResetProfile resets all changes to the "profile" field.
func (m *DirectoryAccountHistoryMutation) ResetProfile() {
	m.profile = nil
	delete(m.clearedFields, directoryaccounthistory.FieldProfile)
}

// SetRawProfileFileID sets the "raw_profile_file_id" field.
func (m *DirectoryAccountHistoryMutation) SetRawProfileFileID(s string) {
	m.raw_profile_file_id = &s
}

// RawProfileFileID returns the value of the "raw_profile_file_id" field in the mutation.
func (m *DirectoryAccountHistoryMutation) RawProfileFileID() (r string, exists bool) {
	v := m.raw_profile_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRawProfileFileID returns the old "raw_profile_file_id" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldRawProfileFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawProfileFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawProfileFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawProfileFileID: %w", err)
	}
	return oldValue.RawProfileFileID, nil
}

// ClearRawProfileFileID clears the value of the "raw_profile_file_id" field.
func (m *DirectoryAccountHistoryMutation) ClearRawProfileFileID() {
	m.raw_profile_file_id = nil
	m.clearedFields[directoryaccounthistory.FieldRawProfileFileID] = struct{}{}
}

// RawProfileFileIDCleared returns if the "raw_profile_file_id" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) RawProfileFileIDCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldRawProfileFileID]
	return ok
}

// ResetRawProfileFileID resets all changes to the "raw_profile_file_id" field.
func (m *DirectoryAccountHistoryMutation) ResetRawProfileFileID() {
	m.raw_profile_file_id = nil
	delete(m.clearedFields, directoryaccounthistory.FieldRawProfileFileID)
}

// SetSourceVersion sets the "source_version" field.
func (m *DirectoryAccountHistoryMutation) SetSourceVersion(s string) {
	m.source_version = &s
}

// SourceVersion returns the value of the "source_version" field in the mutation.
func (m *DirectoryAccountHistoryMutation) SourceVersion() (r string, exists bool) {
	v := m.source_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceVersion returns the old "source_version" field's value of the DirectoryAccountHistory entity.
// If the DirectoryAccountHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryAccountHistoryMutation) OldSourceVersion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceVersion: %w", err)
	}
	return oldValue.SourceVersion, nil
}

// ClearSourceVersion clears the value of the "source_version" field.
func (m *DirectoryAccountHistoryMutation) ClearSourceVersion() {
	m.source_version = nil
	m.clearedFields[directoryaccounthistory.FieldSourceVersion] = struct{}{}
}

// SourceVersionCleared returns if the "source_version" field was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) SourceVersionCleared() bool {
	_, ok := m.clearedFields[directoryaccounthistory.FieldSourceVersion]
	return ok
}

// ResetSourceVersion resets all changes to the "source_version" field.
func (m *DirectoryAccountHistoryMutation) ResetSourceVersion() {
	m.source_version = nil
	delete(m.clearedFields, directoryaccounthistory.FieldSourceVersion)
}

// Where appends a list predicates to the DirectoryAccountHistoryMutation builder.
func (m *DirectoryAccountHistoryMutation) Where(ps ...predicate.DirectoryAccountHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DirectoryAccountHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DirectoryAccountHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DirectoryAccountHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DirectoryAccountHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DirectoryAccountHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DirectoryAccountHistory).
func (m *DirectoryAccountHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DirectoryAccountHistoryMutation) Fields() []string {
	fields := make([]string, 0, 31)
	if m.history_time != nil {
		fields = append(fields, directoryaccounthistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, directoryaccounthistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, directoryaccounthistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, directoryaccounthistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, directoryaccounthistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, directoryaccounthistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, directoryaccounthistory.FieldUpdatedBy)
	}
	if m.display_id != nil {
		fields = append(fields, directoryaccounthistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, directoryaccounthistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, directoryaccounthistory.FieldOwnerID)
	}
	if m.integration_id != nil {
		fields = append(fields, directoryaccounthistory.FieldIntegrationID)
	}
	if m.directory_sync_run_id != nil {
		fields = append(fields, directoryaccounthistory.FieldDirectorySyncRunID)
	}
	if m.external_id != nil {
		fields = append(fields, directoryaccounthistory.FieldExternalID)
	}
	if m.secondary_key != nil {
		fields = append(fields, directoryaccounthistory.FieldSecondaryKey)
	}
	if m.canonical_email != nil {
		fields = append(fields, directoryaccounthistory.FieldCanonicalEmail)
	}
	if m.display_name != nil {
		fields = append(fields, directoryaccounthistory.FieldDisplayName)
	}
	if m.given_name != nil {
		fields = append(fields, directoryaccounthistory.FieldGivenName)
	}
	if m.family_name != nil {
		fields = append(fields, directoryaccounthistory.FieldFamilyName)
	}
	if m.job_title != nil {
		fields = append(fields, directoryaccounthistory.FieldJobTitle)
	}
	if m.department != nil {
		fields = append(fields, directoryaccounthistory.FieldDepartment)
	}
	if m.organization_unit != nil {
		fields = append(fields, directoryaccounthistory.FieldOrganizationUnit)
	}
	if m.account_type != nil {
		fields = append(fields, directoryaccounthistory.FieldAccountType)
	}
	if m.status != nil {
		fields = append(fields, directoryaccounthistory.FieldStatus)
	}
	if m.mfa_state != nil {
		fields = append(fields, directoryaccounthistory.FieldMfaState)
	}
	if m.last_seen_ip != nil {
		fields = append(fields, directoryaccounthistory.FieldLastSeenIP)
	}
	if m.last_login_at != nil {
		fields = append(fields, directoryaccounthistory.FieldLastLoginAt)
	}
	if m.observed_at != nil {
		fields = append(fields, directoryaccounthistory.FieldObservedAt)
	}
	if m.profile_hash != nil {
		fields = append(fields, directoryaccounthistory.FieldProfileHash)
	}
	if m.profile != nil {
		fields = append(fields, directoryaccounthistory.FieldProfile)
	}
	if m.raw_profile_file_id != nil {
		fields = append(fields, directoryaccounthistory.FieldRawProfileFileID)
	}
	if m.source_version != nil {
		fields = append(fields, directoryaccounthistory.FieldSourceVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DirectoryAccountHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case directoryaccounthistory.FieldHistoryTime:
		return m.HistoryTime()
	case directoryaccounthistory.FieldRef:
		return m.Ref()
	case directoryaccounthistory.FieldOperation:
		return m.Operation()
	case directoryaccounthistory.FieldCreatedAt:
		return m.CreatedAt()
	case directoryaccounthistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case directoryaccounthistory.FieldCreatedBy:
		return m.CreatedBy()
	case directoryaccounthistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case directoryaccounthistory.FieldDisplayID:
		return m.DisplayID()
	case directoryaccounthistory.FieldTags:
		return m.Tags()
	case directoryaccounthistory.FieldOwnerID:
		return m.OwnerID()
	case directoryaccounthistory.FieldIntegrationID:
		return m.IntegrationID()
	case directoryaccounthistory.FieldDirectorySyncRunID:
		return m.DirectorySyncRunID()
	case directoryaccounthistory.FieldExternalID:
		return m.ExternalID()
	case directoryaccounthistory.FieldSecondaryKey:
		return m.SecondaryKey()
	case directoryaccounthistory.FieldCanonicalEmail:
		return m.CanonicalEmail()
	case directoryaccounthistory.FieldDisplayName:
		return m.DisplayName()
	case directoryaccounthistory.FieldGivenName:
		return m.GivenName()
	case directoryaccounthistory.FieldFamilyName:
		return m.FamilyName()
	case directoryaccounthistory.FieldJobTitle:
		return m.JobTitle()
	case directoryaccounthistory.FieldDepartment:
		return m.Department()
	case directoryaccounthistory.FieldOrganizationUnit:
		return m.OrganizationUnit()
	case directoryaccounthistory.FieldAccountType:
		return m.AccountType()
	case directoryaccounthistory.FieldStatus:
		return m.Status()
	case directoryaccounthistory.FieldMfaState:
		return m.MfaState()
	case directoryaccounthistory.FieldLastSeenIP:
		return m.LastSeenIP()
	case directoryaccounthistory.FieldLastLoginAt:
		return m.LastLoginAt()
	case directoryaccounthistory.FieldObservedAt:
		return m.ObservedAt()
	case directoryaccounthistory.FieldProfileHash:
		return m.ProfileHash()
	case directoryaccounthistory.FieldProfile:
		return m.Profile()
	case directoryaccounthistory.FieldRawProfileFileID:
		return m.RawProfileFileID()
	case directoryaccounthistory.FieldSourceVersion:
		return m.SourceVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DirectoryAccountHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case directoryaccounthistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case directoryaccounthistory.FieldRef:
		return m.OldRef(ctx)
	case directoryaccounthistory.FieldOperation:
		return m.OldOperation(ctx)
	case directoryaccounthistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case directoryaccounthistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case directoryaccounthistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case directoryaccounthistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case directoryaccounthistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case directoryaccounthistory.FieldTags:
		return m.OldTags(ctx)
	case directoryaccounthistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case directoryaccounthistory.FieldIntegrationID:
		return m.OldIntegrationID(ctx)
	case directoryaccounthistory.FieldDirectorySyncRunID:
		return m.OldDirectorySyncRunID(ctx)
	case directoryaccounthistory.FieldExternalID:
		return m.OldExternalID(ctx)
	case directoryaccounthistory.FieldSecondaryKey:
		return m.OldSecondaryKey(ctx)
	case directoryaccounthistory.FieldCanonicalEmail:
		return m.OldCanonicalEmail(ctx)
	case directoryaccounthistory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case directoryaccounthistory.FieldGivenName:
		return m.OldGivenName(ctx)
	case directoryaccounthistory.FieldFamilyName:
		return m.OldFamilyName(ctx)
	case directoryaccounthistory.FieldJobTitle:
		return m.OldJobTitle(ctx)
	case directoryaccounthistory.FieldDepartment:
		return m.OldDepartment(ctx)
	case directoryaccounthistory.FieldOrganizationUnit:
		return m.OldOrganizationUnit(ctx)
	case directoryaccounthistory.FieldAccountType:
		return m.OldAccountType(ctx)
	case directoryaccounthistory.FieldStatus:
		return m.OldStatus(ctx)
	case directoryaccounthistory.FieldMfaState:
		return m.OldMfaState(ctx)
	case directoryaccounthistory.FieldLastSeenIP:
		return m.OldLastSeenIP(ctx)
	case directoryaccounthistory.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case directoryaccounthistory.FieldObservedAt:
		return m.OldObservedAt(ctx)
	case directoryaccounthistory.FieldProfileHash:
		return m.OldProfileHash(ctx)
	case directoryaccounthistory.FieldProfile:
		return m.OldProfile(ctx)
	case directoryaccounthistory.FieldRawProfileFileID:
		return m.OldRawProfileFileID(ctx)
	case directoryaccounthistory.FieldSourceVersion:
		return m.OldSourceVersion(ctx)
	}
	return nil, fmt.Errorf("unknown DirectoryAccountHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DirectoryAccountHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case directoryaccounthistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case directoryaccounthistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case directoryaccounthistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case directoryaccounthistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case directoryaccounthistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case directoryaccounthistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case directoryaccounthistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case directoryaccounthistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case directoryaccounthistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case directoryaccounthistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case directoryaccounthistory.FieldIntegrationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntegrationID(v)
		return nil
	case directoryaccounthistory.FieldDirectorySyncRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectorySyncRunID(v)
		return nil
	case directoryaccounthistory.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case directoryaccounthistory.FieldSecondaryKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondaryKey(v)
		return nil
	case directoryaccounthistory.FieldCanonicalEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanonicalEmail(v)
		return nil
	case directoryaccounthistory.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case directoryaccounthistory.FieldGivenName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGivenName(v)
		return nil
	case directoryaccounthistory.FieldFamilyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamilyName(v)
		return nil
	case directoryaccounthistory.FieldJobTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobTitle(v)
		return nil
	case directoryaccounthistory.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	case directoryaccounthistory.FieldOrganizationUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationUnit(v)
		return nil
	case directoryaccounthistory.FieldAccountType:
		v, ok := value.(enums.DirectoryAccountType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountType(v)
		return nil
	case directoryaccounthistory.FieldStatus:
		v, ok := value.(enums.DirectoryAccountStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case directoryaccounthistory.FieldMfaState:
		v, ok := value.(enums.DirectoryAccountMFAState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaState(v)
		return nil
	case directoryaccounthistory.FieldLastSeenIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenIP(v)
		return nil
	case directoryaccounthistory.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case directoryaccounthistory.FieldObservedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObservedAt(v)
		return nil
	case directoryaccounthistory.FieldProfileHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileHash(v)
		return nil
	case directoryaccounthistory.FieldProfile:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfile(v)
		return nil
	case directoryaccounthistory.FieldRawProfileFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawProfileFileID(v)
		return nil
	case directoryaccounthistory.FieldSourceVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceVersion(v)
		return nil
	}
	return fmt.Errorf("unknown DirectoryAccountHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DirectoryAccountHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DirectoryAccountHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DirectoryAccountHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DirectoryAccountHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DirectoryAccountHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(directoryaccounthistory.FieldRef) {
		fields = append(fields, directoryaccounthistory.FieldRef)
	}
	if m.FieldCleared(directoryaccounthistory.FieldCreatedAt) {
		fields = append(fields, directoryaccounthistory.FieldCreatedAt)
	}
	if m.FieldCleared(directoryaccounthistory.FieldUpdatedAt) {
		fields = append(fields, directoryaccounthistory.FieldUpdatedAt)
	}
	if m.FieldCleared(directoryaccounthistory.FieldCreatedBy) {
		fields = append(fields, directoryaccounthistory.FieldCreatedBy)
	}
	if m.FieldCleared(directoryaccounthistory.FieldUpdatedBy) {
		fields = append(fields, directoryaccounthistory.FieldUpdatedBy)
	}
	if m.FieldCleared(directoryaccounthistory.FieldTags) {
		fields = append(fields, directoryaccounthistory.FieldTags)
	}
	if m.FieldCleared(directoryaccounthistory.FieldOwnerID) {
		fields = append(fields, directoryaccounthistory.FieldOwnerID)
	}
	if m.FieldCleared(directoryaccounthistory.FieldSecondaryKey) {
		fields = append(fields, directoryaccounthistory.FieldSecondaryKey)
	}
	if m.FieldCleared(directoryaccounthistory.FieldCanonicalEmail) {
		fields = append(fields, directoryaccounthistory.FieldCanonicalEmail)
	}
	if m.FieldCleared(directoryaccounthistory.FieldDisplayName) {
		fields = append(fields, directoryaccounthistory.FieldDisplayName)
	}
	if m.FieldCleared(directoryaccounthistory.FieldGivenName) {
		fields = append(fields, directoryaccounthistory.FieldGivenName)
	}
	if m.FieldCleared(directoryaccounthistory.FieldFamilyName) {
		fields = append(fields, directoryaccounthistory.FieldFamilyName)
	}
	if m.FieldCleared(directoryaccounthistory.FieldJobTitle) {
		fields = append(fields, directoryaccounthistory.FieldJobTitle)
	}
	if m.FieldCleared(directoryaccounthistory.FieldDepartment) {
		fields = append(fields, directoryaccounthistory.FieldDepartment)
	}
	if m.FieldCleared(directoryaccounthistory.FieldOrganizationUnit) {
		fields = append(fields, directoryaccounthistory.FieldOrganizationUnit)
	}
	if m.FieldCleared(directoryaccounthistory.FieldAccountType) {
		fields = append(fields, directoryaccounthistory.FieldAccountType)
	}
	if m.FieldCleared(directoryaccounthistory.FieldLastSeenIP) {
		fields = append(fields, directoryaccounthistory.FieldLastSeenIP)
	}
	if m.FieldCleared(directoryaccounthistory.FieldLastLoginAt) {
		fields = append(fields, directoryaccounthistory.FieldLastLoginAt)
	}
	if m.FieldCleared(directoryaccounthistory.FieldProfile) {
		fields = append(fields, directoryaccounthistory.FieldProfile)
	}
	if m.FieldCleared(directoryaccounthistory.FieldRawProfileFileID) {
		fields = append(fields, directoryaccounthistory.FieldRawProfileFileID)
	}
	if m.FieldCleared(directoryaccounthistory.FieldSourceVersion) {
		fields = append(fields, directoryaccounthistory.FieldSourceVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DirectoryAccountHistoryMutation) ClearField(name string) error {
	switch name {
	case directoryaccounthistory.FieldRef:
		m.ClearRef()
		return nil
	case directoryaccounthistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case directoryaccounthistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case directoryaccounthistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case directoryaccounthistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case directoryaccounthistory.FieldTags:
		m.ClearTags()
		return nil
	case directoryaccounthistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case directoryaccounthistory.FieldSecondaryKey:
		m.ClearSecondaryKey()
		return nil
	case directoryaccounthistory.FieldCanonicalEmail:
		m.ClearCanonicalEmail()
		return nil
	case directoryaccounthistory.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case directoryaccounthistory.FieldGivenName:
		m.ClearGivenName()
		return nil
	case directoryaccounthistory.FieldFamilyName:
		m.ClearFamilyName()
		return nil
	case directoryaccounthistory.FieldJobTitle:
		m.ClearJobTitle()
		return nil
	case directoryaccounthistory.FieldDepartment:
		m.ClearDepartment()
		return nil
	case directoryaccounthistory.FieldOrganizationUnit:
		m.ClearOrganizationUnit()
		return nil
	case directoryaccounthistory.FieldAccountType:
		m.ClearAccountType()
		return nil
	case directoryaccounthistory.FieldLastSeenIP:
		m.ClearLastSeenIP()
		return nil
	case directoryaccounthistory.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case directoryaccounthistory.FieldProfile:
		m.ClearProfile()
		return nil
	case directoryaccounthistory.FieldRawProfileFileID:
		m.ClearRawProfileFileID()
		return nil
	case directoryaccounthistory.FieldSourceVersion:
		m.ClearSourceVersion()
		return nil
	}
	return fmt.Errorf("unknown DirectoryAccountHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DirectoryAccountHistoryMutation) ResetField(name string) error {
	switch name {
	case directoryaccounthistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case directoryaccounthistory.FieldRef:
		m.ResetRef()
		return nil
	case directoryaccounthistory.FieldOperation:
		m.ResetOperation()
		return nil
	case directoryaccounthistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case directoryaccounthistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case directoryaccounthistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case directoryaccounthistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case directoryaccounthistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case directoryaccounthistory.FieldTags:
		m.ResetTags()
		return nil
	case directoryaccounthistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case directoryaccounthistory.FieldIntegrationID:
		m.ResetIntegrationID()
		return nil
	case directoryaccounthistory.FieldDirectorySyncRunID:
		m.ResetDirectorySyncRunID()
		return nil
	case directoryaccounthistory.FieldExternalID:
		m.ResetExternalID()
		return nil
	case directoryaccounthistory.FieldSecondaryKey:
		m.ResetSecondaryKey()
		return nil
	case directoryaccounthistory.FieldCanonicalEmail:
		m.ResetCanonicalEmail()
		return nil
	case directoryaccounthistory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case directoryaccounthistory.FieldGivenName:
		m.ResetGivenName()
		return nil
	case directoryaccounthistory.FieldFamilyName:
		m.ResetFamilyName()
		return nil
	case directoryaccounthistory.FieldJobTitle:
		m.ResetJobTitle()
		return nil
	case directoryaccounthistory.FieldDepartment:
		m.ResetDepartment()
		return nil
	case directoryaccounthistory.FieldOrganizationUnit:
		m.ResetOrganizationUnit()
		return nil
	case directoryaccounthistory.FieldAccountType:
		m.ResetAccountType()
		return nil
	case directoryaccounthistory.FieldStatus:
		m.ResetStatus()
		return nil
	case directoryaccounthistory.FieldMfaState:
		m.ResetMfaState()
		return nil
	case directoryaccounthistory.FieldLastSeenIP:
		m.ResetLastSeenIP()
		return nil
	case directoryaccounthistory.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case directoryaccounthistory.FieldObservedAt:
		m.ResetObservedAt()
		return nil
	case directoryaccounthistory.FieldProfileHash:
		m.ResetProfileHash()
		return nil
	case directoryaccounthistory.FieldProfile:
		m.ResetProfile()
		return nil
	case directoryaccounthistory.FieldRawProfileFileID:
		m.ResetRawProfileFileID()
		return nil
	case directoryaccounthistory.FieldSourceVersion:
		m.ResetSourceVersion()
		return nil
	}
	return fmt.Errorf("unknown DirectoryAccountHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DirectoryAccountHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DirectoryAccountHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DirectoryAccountHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DirectoryAccountHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DirectoryAccountHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DirectoryAccountHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DirectoryAccountHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DirectoryAccountHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DirectoryAccountHistory edge %s", name)
}

// DirectoryGroupHistoryMutation represents an operation that mutates the DirectoryGroupHistory nodes in the graph.
type DirectoryGroupHistoryMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	history_time             *time.Time
	ref                      *string
	operation                *history.OpType
	created_at               *time.Time
	updated_at               *time.Time
	created_by               *string
	updated_by               *string
	display_id               *string
	tags                     *[]string
	appendtags               []string
	owner_id                 *string
	integration_id           *string
	directory_sync_run_id    *string
	external_id              *string
	email                    *string
	display_name             *string
	description              *string
	classification           *enums.DirectoryGroupClassification
	status                   *enums.DirectoryGroupStatus
	external_sharing_allowed *bool
	member_count             *int
	addmember_count          *int
	observed_at              *time.Time
	profile_hash             *string
	profile                  *map[string]interface{}
	raw_profile_file_id      *string
	source_version           *string
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*DirectoryGroupHistory, error)
	predicates               []predicate.DirectoryGroupHistory
}

var _ ent.Mutation = (*DirectoryGroupHistoryMutation)(nil)

// directorygrouphistoryOption allows management of the mutation configuration using functional options.
type directorygrouphistoryOption func(*DirectoryGroupHistoryMutation)

// newDirectoryGroupHistoryMutation creates new mutation for the DirectoryGroupHistory entity.
func newDirectoryGroupHistoryMutation(c config, op Op, opts ...directorygrouphistoryOption) *DirectoryGroupHistoryMutation {
	m := &DirectoryGroupHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeDirectoryGroupHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDirectoryGroupHistoryID sets the ID field of the mutation.
func withDirectoryGroupHistoryID(id string) directorygrouphistoryOption {
	return func(m *DirectoryGroupHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *DirectoryGroupHistory
		)
		m.oldValue = func(ctx context.Context) (*DirectoryGroupHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DirectoryGroupHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDirectoryGroupHistory sets the old DirectoryGroupHistory of the mutation.
func withDirectoryGroupHistory(node *DirectoryGroupHistory) directorygrouphistoryOption {
	return func(m *DirectoryGroupHistoryMutation) {
		m.oldValue = func(context.Context) (*DirectoryGroupHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DirectoryGroupHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DirectoryGroupHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DirectoryGroupHistory entities.
func (m *DirectoryGroupHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DirectoryGroupHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DirectoryGroupHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DirectoryGroupHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *DirectoryGroupHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *DirectoryGroupHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *DirectoryGroupHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *DirectoryGroupHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *DirectoryGroupHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *DirectoryGroupHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[directorygrouphistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[directorygrouphistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *DirectoryGroupHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, directorygrouphistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *DirectoryGroupHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *DirectoryGroupHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *DirectoryGroupHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DirectoryGroupHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DirectoryGroupHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DirectoryGroupHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[directorygrouphistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[directorygrouphistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DirectoryGroupHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, directorygrouphistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DirectoryGroupHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DirectoryGroupHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DirectoryGroupHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[directorygrouphistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[directorygrouphistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DirectoryGroupHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, directorygrouphistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *DirectoryGroupHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DirectoryGroupHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DirectoryGroupHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[directorygrouphistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[directorygrouphistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DirectoryGroupHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, directorygrouphistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DirectoryGroupHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DirectoryGroupHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DirectoryGroupHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[directorygrouphistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[directorygrouphistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DirectoryGroupHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, directorygrouphistory.FieldUpdatedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *DirectoryGroupHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *DirectoryGroupHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *DirectoryGroupHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *DirectoryGroupHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *DirectoryGroupHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *DirectoryGroupHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *DirectoryGroupHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *DirectoryGroupHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[directorygrouphistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[directorygrouphistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *DirectoryGroupHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, directorygrouphistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *DirectoryGroupHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *DirectoryGroupHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *DirectoryGroupHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[directorygrouphistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[directorygrouphistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *DirectoryGroupHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, directorygrouphistory.FieldOwnerID)
}

// SetIntegrationID sets the "integration_id" field.
func (m *DirectoryGroupHistoryMutation) SetIntegrationID(s string) {
	m.integration_id = &s
}

// IntegrationID returns the value of the "integration_id" field in the mutation.
func (m *DirectoryGroupHistoryMutation) IntegrationID() (r string, exists bool) {
	v := m.integration_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIntegrationID returns the old "integration_id" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldIntegrationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntegrationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntegrationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntegrationID: %w", err)
	}
	return oldValue.IntegrationID, nil
}

// ResetIntegrationID resets all changes to the "integration_id" field.
func (m *DirectoryGroupHistoryMutation) ResetIntegrationID() {
	m.integration_id = nil
}

// SetDirectorySyncRunID sets the "directory_sync_run_id" field.
func (m *DirectoryGroupHistoryMutation) SetDirectorySyncRunID(s string) {
	m.directory_sync_run_id = &s
}

// DirectorySyncRunID returns the value of the "directory_sync_run_id" field in the mutation.
func (m *DirectoryGroupHistoryMutation) DirectorySyncRunID() (r string, exists bool) {
	v := m.directory_sync_run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectorySyncRunID returns the old "directory_sync_run_id" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldDirectorySyncRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectorySyncRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectorySyncRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectorySyncRunID: %w", err)
	}
	return oldValue.DirectorySyncRunID, nil
}

// ResetDirectorySyncRunID resets all changes to the "directory_sync_run_id" field.
func (m *DirectoryGroupHistoryMutation) ResetDirectorySyncRunID() {
	m.directory_sync_run_id = nil
}

// SetExternalID sets the "external_id" field.
func (m *DirectoryGroupHistoryMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *DirectoryGroupHistoryMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *DirectoryGroupHistoryMutation) ResetExternalID() {
	m.external_id = nil
}

// SetEmail sets the "email" field.
func (m *DirectoryGroupHistoryMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *DirectoryGroupHistoryMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *DirectoryGroupHistoryMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[directorygrouphistory.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) EmailCleared() bool {
	_, ok := m.clearedFields[directorygrouphistory.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *DirectoryGroupHistoryMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, directorygrouphistory.FieldEmail)
}

// SetDisplayName sets the "display_name" field.
func (m *DirectoryGroupHistoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *DirectoryGroupHistoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *DirectoryGroupHistoryMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[directorygrouphistory.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[directorygrouphistory.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *DirectoryGroupHistoryMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, directorygrouphistory.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *DirectoryGroupHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DirectoryGroupHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DirectoryGroupHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[directorygrouphistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[directorygrouphistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DirectoryGroupHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, directorygrouphistory.FieldDescription)
}

// SetClassification sets the "classification" field.
func (m *DirectoryGroupHistoryMutation) SetClassification(egc enums.DirectoryGroupClassification) {
	m.classification = &egc
}

// Classification returns the value of the "classification" field in the mutation.
func (m *DirectoryGroupHistoryMutation) Classification() (r enums.DirectoryGroupClassification, exists bool) {
	v := m.classification
	if v == nil {
		return
	}
	return *v, true
}

// OldClassification returns the old "classification" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldClassification(ctx context.Context) (v enums.DirectoryGroupClassification, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassification: %w", err)
	}
	return oldValue.Classification, nil
}

// ResetClassification resets all changes to the "classification" field.
func (m *DirectoryGroupHistoryMutation) ResetClassification() {
	m.classification = nil
}

// SetStatus sets the "status" field.
func (m *DirectoryGroupHistoryMutation) SetStatus(egs enums.DirectoryGroupStatus) {
	m.status = &egs
}

// Status returns the value of the "status" field in the mutation.
func (m *DirectoryGroupHistoryMutation) Status() (r enums.DirectoryGroupStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldStatus(ctx context.Context) (v enums.DirectoryGroupStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DirectoryGroupHistoryMutation) ResetStatus() {
	m.status = nil
}

// SetExternalSharingAllowed sets the "external_sharing_allowed" field.
func (m *DirectoryGroupHistoryMutation) SetExternalSharingAllowed(b bool) {
	m.external_sharing_allowed = &b
}

// ExternalSharingAllowed returns the value of the "external_sharing_allowed" field in the mutation.
func (m *DirectoryGroupHistoryMutation) ExternalSharingAllowed() (r bool, exists bool) {
	v := m.external_sharing_allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalSharingAllowed returns the old "external_sharing_allowed" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldExternalSharingAllowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalSharingAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalSharingAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalSharingAllowed: %w", err)
	}
	return oldValue.ExternalSharingAllowed, nil
}

// ClearExternalSharingAllowed clears the value of the "external_sharing_allowed" field.
func (m *DirectoryGroupHistoryMutation) ClearExternalSharingAllowed() {
	m.external_sharing_allowed = nil
	m.clearedFields[directorygrouphistory.FieldExternalSharingAllowed] = struct{}{}
}

// ExternalSharingAllowedCleared returns if the "external_sharing_allowed" field was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) ExternalSharingAllowedCleared() bool {
	_, ok := m.clearedFields[directorygrouphistory.FieldExternalSharingAllowed]
	return ok
}

// ResetExternalSharingAllowed resets all changes to the "external_sharing_allowed" field.
func (m *DirectoryGroupHistoryMutation) ResetExternalSharingAllowed() {
	m.external_sharing_allowed = nil
	delete(m.clearedFields, directorygrouphistory.FieldExternalSharingAllowed)
}

// SetMemberCount sets the "member_count" field.
func (m *DirectoryGroupHistoryMutation) SetMemberCount(i int) {
	m.member_count = &i
	m.addmember_count = nil
}

// MemberCount returns the value of the "member_count" field in the mutation.
func (m *DirectoryGroupHistoryMutation) MemberCount() (r int, exists bool) {
	v := m.member_count
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberCount returns the old "member_count" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldMemberCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberCount: %w", err)
	}
	return oldValue.MemberCount, nil
}

// AddMemberCount adds i to the "member_count" field.
func (m *DirectoryGroupHistoryMutation) AddMemberCount(i int) {
	if m.addmember_count != nil {
		*m.addmember_count += i
	} else {
		m.addmember_count = &i
	}
}

// AddedMemberCount returns the value that was added to the "member_count" field in this mutation.
func (m *DirectoryGroupHistoryMutation) AddedMemberCount() (r int, exists bool) {
	v := m.addmember_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberCount clears the value of the "member_count" field.
func (m *DirectoryGroupHistoryMutation) ClearMemberCount() {
	m.member_count = nil
	m.addmember_count = nil
	m.clearedFields[directorygrouphistory.FieldMemberCount] = struct{}{}
}

// MemberCountCleared returns if the "member_count" field was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) MemberCountCleared() bool {
	_, ok := m.clearedFields[directorygrouphistory.FieldMemberCount]
	return ok
}

// ResetMemberCount resets all changes to the "member_count" field.
func (m *DirectoryGroupHistoryMutation) ResetMemberCount() {
	m.member_count = nil
	m.addmember_count = nil
	delete(m.clearedFields, directorygrouphistory.FieldMemberCount)
}

// SetObservedAt sets the "observed_at" field.
func (m *DirectoryGroupHistoryMutation) SetObservedAt(t time.Time) {
	m.observed_at = &t
}

// ObservedAt returns the value of the "observed_at" field in the mutation.
func (m *DirectoryGroupHistoryMutation) ObservedAt() (r time.Time, exists bool) {
	v := m.observed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldObservedAt returns the old "observed_at" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldObservedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObservedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObservedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObservedAt: %w", err)
	}
	return oldValue.ObservedAt, nil
}

// ResetObservedAt resets all changes to the "observed_at" field.
func (m *DirectoryGroupHistoryMutation) ResetObservedAt() {
	m.observed_at = nil
}

// SetProfileHash sets the "profile_hash" field.
func (m *DirectoryGroupHistoryMutation) SetProfileHash(s string) {
	m.profile_hash = &s
}

// ProfileHash returns the value of the "profile_hash" field in the mutation.
func (m *DirectoryGroupHistoryMutation) ProfileHash() (r string, exists bool) {
	v := m.profile_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileHash returns the old "profile_hash" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldProfileHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileHash: %w", err)
	}
	return oldValue.ProfileHash, nil
}

// ResetProfileHash resets all changes to the "profile_hash" field.
func (m *DirectoryGroupHistoryMutation) ResetProfileHash() {
	m.profile_hash = nil
}

// SetProfile sets the "profile" field.
func (m *DirectoryGroupHistoryMutation) SetProfile(value map[string]interface{}) {
	m.profile = &value
}

// Profile returns the value of the "profile" field in the mutation.
func (m *DirectoryGroupHistoryMutation) Profile() (r map[string]interface{}, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfile returns the old "profile" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldProfile(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfile: %w", err)
	}
	return oldValue.Profile, nil
}

// ClearProfile clears the value of the "profile" field.
func (m *DirectoryGroupHistoryMutation) ClearProfile() {
	m.profile = nil
	m.clearedFields[directorygrouphistory.FieldProfile] = struct{}{}
}

// ProfileCleared returns if the "profile" field was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) ProfileCleared() bool {
	_, ok := m.clearedFields[directorygrouphistory.FieldProfile]
	return ok
}

// ResetProfile resets all changes to the "profile" field.
func (m *DirectoryGroupHistoryMutation) ResetProfile() {
	m.profile = nil
	delete(m.clearedFields, directorygrouphistory.FieldProfile)
}

// SetRawProfileFileID sets the "raw_profile_file_id" field.
func (m *DirectoryGroupHistoryMutation) SetRawProfileFileID(s string) {
	m.raw_profile_file_id = &s
}

// RawProfileFileID returns the value of the "raw_profile_file_id" field in the mutation.
func (m *DirectoryGroupHistoryMutation) RawProfileFileID() (r string, exists bool) {
	v := m.raw_profile_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRawProfileFileID returns the old "raw_profile_file_id" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldRawProfileFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawProfileFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawProfileFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawProfileFileID: %w", err)
	}
	return oldValue.RawProfileFileID, nil
}

// ClearRawProfileFileID clears the value of the "raw_profile_file_id" field.
func (m *DirectoryGroupHistoryMutation) ClearRawProfileFileID() {
	m.raw_profile_file_id = nil
	m.clearedFields[directorygrouphistory.FieldRawProfileFileID] = struct{}{}
}

// RawProfileFileIDCleared returns if the "raw_profile_file_id" field was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) RawProfileFileIDCleared() bool {
	_, ok := m.clearedFields[directorygrouphistory.FieldRawProfileFileID]
	return ok
}

// ResetRawProfileFileID resets all changes to the "raw_profile_file_id" field.
func (m *DirectoryGroupHistoryMutation) ResetRawProfileFileID() {
	m.raw_profile_file_id = nil
	delete(m.clearedFields, directorygrouphistory.FieldRawProfileFileID)
}

// SetSourceVersion sets the "source_version" field.
func (m *DirectoryGroupHistoryMutation) SetSourceVersion(s string) {
	m.source_version = &s
}

// SourceVersion returns the value of the "source_version" field in the mutation.
func (m *DirectoryGroupHistoryMutation) SourceVersion() (r string, exists bool) {
	v := m.source_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceVersion returns the old "source_version" field's value of the DirectoryGroupHistory entity.
// If the DirectoryGroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryGroupHistoryMutation) OldSourceVersion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceVersion: %w", err)
	}
	return oldValue.SourceVersion, nil
}

// ClearSourceVersion clears the value of the "source_version" field.
func (m *DirectoryGroupHistoryMutation) ClearSourceVersion() {
	m.source_version = nil
	m.clearedFields[directorygrouphistory.FieldSourceVersion] = struct{}{}
}

// SourceVersionCleared returns if the "source_version" field was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) SourceVersionCleared() bool {
	_, ok := m.clearedFields[directorygrouphistory.FieldSourceVersion]
	return ok
}

// ResetSourceVersion resets all changes to the "source_version" field.
func (m *DirectoryGroupHistoryMutation) ResetSourceVersion() {
	m.source_version = nil
	delete(m.clearedFields, directorygrouphistory.FieldSourceVersion)
}

// Where appends a list predicates to the DirectoryGroupHistoryMutation builder.
func (m *DirectoryGroupHistoryMutation) Where(ps ...predicate.DirectoryGroupHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DirectoryGroupHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DirectoryGroupHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DirectoryGroupHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DirectoryGroupHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DirectoryGroupHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DirectoryGroupHistory).
func (m *DirectoryGroupHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DirectoryGroupHistoryMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.history_time != nil {
		fields = append(fields, directorygrouphistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, directorygrouphistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, directorygrouphistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, directorygrouphistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, directorygrouphistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, directorygrouphistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, directorygrouphistory.FieldUpdatedBy)
	}
	if m.display_id != nil {
		fields = append(fields, directorygrouphistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, directorygrouphistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, directorygrouphistory.FieldOwnerID)
	}
	if m.integration_id != nil {
		fields = append(fields, directorygrouphistory.FieldIntegrationID)
	}
	if m.directory_sync_run_id != nil {
		fields = append(fields, directorygrouphistory.FieldDirectorySyncRunID)
	}
	if m.external_id != nil {
		fields = append(fields, directorygrouphistory.FieldExternalID)
	}
	if m.email != nil {
		fields = append(fields, directorygrouphistory.FieldEmail)
	}
	if m.display_name != nil {
		fields = append(fields, directorygrouphistory.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, directorygrouphistory.FieldDescription)
	}
	if m.classification != nil {
		fields = append(fields, directorygrouphistory.FieldClassification)
	}
	if m.status != nil {
		fields = append(fields, directorygrouphistory.FieldStatus)
	}
	if m.external_sharing_allowed != nil {
		fields = append(fields, directorygrouphistory.FieldExternalSharingAllowed)
	}
	if m.member_count != nil {
		fields = append(fields, directorygrouphistory.FieldMemberCount)
	}
	if m.observed_at != nil {
		fields = append(fields, directorygrouphistory.FieldObservedAt)
	}
	if m.profile_hash != nil {
		fields = append(fields, directorygrouphistory.FieldProfileHash)
	}
	if m.profile != nil {
		fields = append(fields, directorygrouphistory.FieldProfile)
	}
	if m.raw_profile_file_id != nil {
		fields = append(fields, directorygrouphistory.FieldRawProfileFileID)
	}
	if m.source_version != nil {
		fields = append(fields, directorygrouphistory.FieldSourceVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DirectoryGroupHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case directorygrouphistory.FieldHistoryTime:
		return m.HistoryTime()
	case directorygrouphistory.FieldRef:
		return m.Ref()
	case directorygrouphistory.FieldOperation:
		return m.Operation()
	case directorygrouphistory.FieldCreatedAt:
		return m.CreatedAt()
	case directorygrouphistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case directorygrouphistory.FieldCreatedBy:
		return m.CreatedBy()
	case directorygrouphistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case directorygrouphistory.FieldDisplayID:
		return m.DisplayID()
	case directorygrouphistory.FieldTags:
		return m.Tags()
	case directorygrouphistory.FieldOwnerID:
		return m.OwnerID()
	case directorygrouphistory.FieldIntegrationID:
		return m.IntegrationID()
	case directorygrouphistory.FieldDirectorySyncRunID:
		return m.DirectorySyncRunID()
	case directorygrouphistory.FieldExternalID:
		return m.ExternalID()
	case directorygrouphistory.FieldEmail:
		return m.Email()
	case directorygrouphistory.FieldDisplayName:
		return m.DisplayName()
	case directorygrouphistory.FieldDescription:
		return m.Description()
	case directorygrouphistory.FieldClassification:
		return m.Classification()
	case directorygrouphistory.FieldStatus:
		return m.Status()
	case directorygrouphistory.FieldExternalSharingAllowed:
		return m.ExternalSharingAllowed()
	case directorygrouphistory.FieldMemberCount:
		return m.MemberCount()
	case directorygrouphistory.FieldObservedAt:
		return m.ObservedAt()
	case directorygrouphistory.FieldProfileHash:
		return m.ProfileHash()
	case directorygrouphistory.FieldProfile:
		return m.Profile()
	case directorygrouphistory.FieldRawProfileFileID:
		return m.RawProfileFileID()
	case directorygrouphistory.FieldSourceVersion:
		return m.SourceVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DirectoryGroupHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case directorygrouphistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case directorygrouphistory.FieldRef:
		return m.OldRef(ctx)
	case directorygrouphistory.FieldOperation:
		return m.OldOperation(ctx)
	case directorygrouphistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case directorygrouphistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case directorygrouphistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case directorygrouphistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case directorygrouphistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case directorygrouphistory.FieldTags:
		return m.OldTags(ctx)
	case directorygrouphistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case directorygrouphistory.FieldIntegrationID:
		return m.OldIntegrationID(ctx)
	case directorygrouphistory.FieldDirectorySyncRunID:
		return m.OldDirectorySyncRunID(ctx)
	case directorygrouphistory.FieldExternalID:
		return m.OldExternalID(ctx)
	case directorygrouphistory.FieldEmail:
		return m.OldEmail(ctx)
	case directorygrouphistory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case directorygrouphistory.FieldDescription:
		return m.OldDescription(ctx)
	case directorygrouphistory.FieldClassification:
		return m.OldClassification(ctx)
	case directorygrouphistory.FieldStatus:
		return m.OldStatus(ctx)
	case directorygrouphistory.FieldExternalSharingAllowed:
		return m.OldExternalSharingAllowed(ctx)
	case directorygrouphistory.FieldMemberCount:
		return m.OldMemberCount(ctx)
	case directorygrouphistory.FieldObservedAt:
		return m.OldObservedAt(ctx)
	case directorygrouphistory.FieldProfileHash:
		return m.OldProfileHash(ctx)
	case directorygrouphistory.FieldProfile:
		return m.OldProfile(ctx)
	case directorygrouphistory.FieldRawProfileFileID:
		return m.OldRawProfileFileID(ctx)
	case directorygrouphistory.FieldSourceVersion:
		return m.OldSourceVersion(ctx)
	}
	return nil, fmt.Errorf("unknown DirectoryGroupHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DirectoryGroupHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case directorygrouphistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case directorygrouphistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case directorygrouphistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case directorygrouphistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case directorygrouphistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case directorygrouphistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case directorygrouphistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case directorygrouphistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case directorygrouphistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case directorygrouphistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case directorygrouphistory.FieldIntegrationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntegrationID(v)
		return nil
	case directorygrouphistory.FieldDirectorySyncRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectorySyncRunID(v)
		return nil
	case directorygrouphistory.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case directorygrouphistory.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case directorygrouphistory.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case directorygrouphistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case directorygrouphistory.FieldClassification:
		v, ok := value.(enums.DirectoryGroupClassification)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassification(v)
		return nil
	case directorygrouphistory.FieldStatus:
		v, ok := value.(enums.DirectoryGroupStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case directorygrouphistory.FieldExternalSharingAllowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalSharingAllowed(v)
		return nil
	case directorygrouphistory.FieldMemberCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberCount(v)
		return nil
	case directorygrouphistory.FieldObservedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObservedAt(v)
		return nil
	case directorygrouphistory.FieldProfileHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileHash(v)
		return nil
	case directorygrouphistory.FieldProfile:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfile(v)
		return nil
	case directorygrouphistory.FieldRawProfileFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawProfileFileID(v)
		return nil
	case directorygrouphistory.FieldSourceVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceVersion(v)
		return nil
	}
	return fmt.Errorf("unknown DirectoryGroupHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DirectoryGroupHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addmember_count != nil {
		fields = append(fields, directorygrouphistory.FieldMemberCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DirectoryGroupHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case directorygrouphistory.FieldMemberCount:
		return m.AddedMemberCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DirectoryGroupHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case directorygrouphistory.FieldMemberCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberCount(v)
		return nil
	}
	return fmt.Errorf("unknown DirectoryGroupHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DirectoryGroupHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(directorygrouphistory.FieldRef) {
		fields = append(fields, directorygrouphistory.FieldRef)
	}
	if m.FieldCleared(directorygrouphistory.FieldCreatedAt) {
		fields = append(fields, directorygrouphistory.FieldCreatedAt)
	}
	if m.FieldCleared(directorygrouphistory.FieldUpdatedAt) {
		fields = append(fields, directorygrouphistory.FieldUpdatedAt)
	}
	if m.FieldCleared(directorygrouphistory.FieldCreatedBy) {
		fields = append(fields, directorygrouphistory.FieldCreatedBy)
	}
	if m.FieldCleared(directorygrouphistory.FieldUpdatedBy) {
		fields = append(fields, directorygrouphistory.FieldUpdatedBy)
	}
	if m.FieldCleared(directorygrouphistory.FieldTags) {
		fields = append(fields, directorygrouphistory.FieldTags)
	}
	if m.FieldCleared(directorygrouphistory.FieldOwnerID) {
		fields = append(fields, directorygrouphistory.FieldOwnerID)
	}
	if m.FieldCleared(directorygrouphistory.FieldEmail) {
		fields = append(fields, directorygrouphistory.FieldEmail)
	}
	if m.FieldCleared(directorygrouphistory.FieldDisplayName) {
		fields = append(fields, directorygrouphistory.FieldDisplayName)
	}
	if m.FieldCleared(directorygrouphistory.FieldDescription) {
		fields = append(fields, directorygrouphistory.FieldDescription)
	}
	if m.FieldCleared(directorygrouphistory.FieldExternalSharingAllowed) {
		fields = append(fields, directorygrouphistory.FieldExternalSharingAllowed)
	}
	if m.FieldCleared(directorygrouphistory.FieldMemberCount) {
		fields = append(fields, directorygrouphistory.FieldMemberCount)
	}
	if m.FieldCleared(directorygrouphistory.FieldProfile) {
		fields = append(fields, directorygrouphistory.FieldProfile)
	}
	if m.FieldCleared(directorygrouphistory.FieldRawProfileFileID) {
		fields = append(fields, directorygrouphistory.FieldRawProfileFileID)
	}
	if m.FieldCleared(directorygrouphistory.FieldSourceVersion) {
		fields = append(fields, directorygrouphistory.FieldSourceVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DirectoryGroupHistoryMutation) ClearField(name string) error {
	switch name {
	case directorygrouphistory.FieldRef:
		m.ClearRef()
		return nil
	case directorygrouphistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case directorygrouphistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case directorygrouphistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case directorygrouphistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case directorygrouphistory.FieldTags:
		m.ClearTags()
		return nil
	case directorygrouphistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case directorygrouphistory.FieldEmail:
		m.ClearEmail()
		return nil
	case directorygrouphistory.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case directorygrouphistory.FieldDescription:
		m.ClearDescription()
		return nil
	case directorygrouphistory.FieldExternalSharingAllowed:
		m.ClearExternalSharingAllowed()
		return nil
	case directorygrouphistory.FieldMemberCount:
		m.ClearMemberCount()
		return nil
	case directorygrouphistory.FieldProfile:
		m.ClearProfile()
		return nil
	case directorygrouphistory.FieldRawProfileFileID:
		m.ClearRawProfileFileID()
		return nil
	case directorygrouphistory.FieldSourceVersion:
		m.ClearSourceVersion()
		return nil
	}
	return fmt.Errorf("unknown DirectoryGroupHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DirectoryGroupHistoryMutation) ResetField(name string) error {
	switch name {
	case directorygrouphistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case directorygrouphistory.FieldRef:
		m.ResetRef()
		return nil
	case directorygrouphistory.FieldOperation:
		m.ResetOperation()
		return nil
	case directorygrouphistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case directorygrouphistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case directorygrouphistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case directorygrouphistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case directorygrouphistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case directorygrouphistory.FieldTags:
		m.ResetTags()
		return nil
	case directorygrouphistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case directorygrouphistory.FieldIntegrationID:
		m.ResetIntegrationID()
		return nil
	case directorygrouphistory.FieldDirectorySyncRunID:
		m.ResetDirectorySyncRunID()
		return nil
	case directorygrouphistory.FieldExternalID:
		m.ResetExternalID()
		return nil
	case directorygrouphistory.FieldEmail:
		m.ResetEmail()
		return nil
	case directorygrouphistory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case directorygrouphistory.FieldDescription:
		m.ResetDescription()
		return nil
	case directorygrouphistory.FieldClassification:
		m.ResetClassification()
		return nil
	case directorygrouphistory.FieldStatus:
		m.ResetStatus()
		return nil
	case directorygrouphistory.FieldExternalSharingAllowed:
		m.ResetExternalSharingAllowed()
		return nil
	case directorygrouphistory.FieldMemberCount:
		m.ResetMemberCount()
		return nil
	case directorygrouphistory.FieldObservedAt:
		m.ResetObservedAt()
		return nil
	case directorygrouphistory.FieldProfileHash:
		m.ResetProfileHash()
		return nil
	case directorygrouphistory.FieldProfile:
		m.ResetProfile()
		return nil
	case directorygrouphistory.FieldRawProfileFileID:
		m.ResetRawProfileFileID()
		return nil
	case directorygrouphistory.FieldSourceVersion:
		m.ResetSourceVersion()
		return nil
	}
	return fmt.Errorf("unknown DirectoryGroupHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DirectoryGroupHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DirectoryGroupHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DirectoryGroupHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DirectoryGroupHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DirectoryGroupHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DirectoryGroupHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DirectoryGroupHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DirectoryGroupHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DirectoryGroupHistory edge %s", name)
}

// DirectoryMembershipHistoryMutation represents an operation that mutates the DirectoryMembershipHistory nodes in the graph.
type DirectoryMembershipHistoryMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	history_time          *time.Time
	ref                   *string
	operation             *history.OpType
	created_at            *time.Time
	updated_at            *time.Time
	created_by            *string
	updated_by            *string
	display_id            *string
	owner_id              *string
	integration_id        *string
	directory_sync_run_id *string
	directory_account_id  *string
	directory_group_id    *string
	role                  *enums.DirectoryMembershipRole
	source                *string
	first_seen_at         *time.Time
	last_seen_at          *time.Time
	observed_at           *time.Time
	last_confirmed_run_id *string
	metadata              *map[string]interface{}
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*DirectoryMembershipHistory, error)
	predicates            []predicate.DirectoryMembershipHistory
}

var _ ent.Mutation = (*DirectoryMembershipHistoryMutation)(nil)

// directorymembershiphistoryOption allows management of the mutation configuration using functional options.
type directorymembershiphistoryOption func(*DirectoryMembershipHistoryMutation)

// newDirectoryMembershipHistoryMutation creates new mutation for the DirectoryMembershipHistory entity.
func newDirectoryMembershipHistoryMutation(c config, op Op, opts ...directorymembershiphistoryOption) *DirectoryMembershipHistoryMutation {
	m := &DirectoryMembershipHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeDirectoryMembershipHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDirectoryMembershipHistoryID sets the ID field of the mutation.
func withDirectoryMembershipHistoryID(id string) directorymembershiphistoryOption {
	return func(m *DirectoryMembershipHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *DirectoryMembershipHistory
		)
		m.oldValue = func(ctx context.Context) (*DirectoryMembershipHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DirectoryMembershipHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDirectoryMembershipHistory sets the old DirectoryMembershipHistory of the mutation.
func withDirectoryMembershipHistory(node *DirectoryMembershipHistory) directorymembershiphistoryOption {
	return func(m *DirectoryMembershipHistoryMutation) {
		m.oldValue = func(context.Context) (*DirectoryMembershipHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DirectoryMembershipHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DirectoryMembershipHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DirectoryMembershipHistory entities.
func (m *DirectoryMembershipHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DirectoryMembershipHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DirectoryMembershipHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DirectoryMembershipHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *DirectoryMembershipHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *DirectoryMembershipHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *DirectoryMembershipHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *DirectoryMembershipHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[directorymembershiphistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *DirectoryMembershipHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[directorymembershiphistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *DirectoryMembershipHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, directorymembershiphistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *DirectoryMembershipHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *DirectoryMembershipHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DirectoryMembershipHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DirectoryMembershipHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[directorymembershiphistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DirectoryMembershipHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[directorymembershiphistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DirectoryMembershipHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, directorymembershiphistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DirectoryMembershipHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DirectoryMembershipHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[directorymembershiphistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DirectoryMembershipHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[directorymembershiphistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DirectoryMembershipHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, directorymembershiphistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *DirectoryMembershipHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DirectoryMembershipHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[directorymembershiphistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DirectoryMembershipHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[directorymembershiphistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DirectoryMembershipHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, directorymembershiphistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DirectoryMembershipHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DirectoryMembershipHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[directorymembershiphistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DirectoryMembershipHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[directorymembershiphistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DirectoryMembershipHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, directorymembershiphistory.FieldUpdatedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *DirectoryMembershipHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *DirectoryMembershipHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *DirectoryMembershipHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *DirectoryMembershipHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[directorymembershiphistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *DirectoryMembershipHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[directorymembershiphistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *DirectoryMembershipHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, directorymembershiphistory.FieldOwnerID)
}

// SetIntegrationID sets the "integration_id" field.
func (m *DirectoryMembershipHistoryMutation) SetIntegrationID(s string) {
	m.integration_id = &s
}

// IntegrationID returns the value of the "integration_id" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) IntegrationID() (r string, exists bool) {
	v := m.integration_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIntegrationID returns the old "integration_id" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldIntegrationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntegrationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntegrationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntegrationID: %w", err)
	}
	return oldValue.IntegrationID, nil
}

// ResetIntegrationID resets all changes to the "integration_id" field.
func (m *DirectoryMembershipHistoryMutation) ResetIntegrationID() {
	m.integration_id = nil
}

// SetDirectorySyncRunID sets the "directory_sync_run_id" field.
func (m *DirectoryMembershipHistoryMutation) SetDirectorySyncRunID(s string) {
	m.directory_sync_run_id = &s
}

// DirectorySyncRunID returns the value of the "directory_sync_run_id" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) DirectorySyncRunID() (r string, exists bool) {
	v := m.directory_sync_run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectorySyncRunID returns the old "directory_sync_run_id" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldDirectorySyncRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectorySyncRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectorySyncRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectorySyncRunID: %w", err)
	}
	return oldValue.DirectorySyncRunID, nil
}

// ResetDirectorySyncRunID resets all changes to the "directory_sync_run_id" field.
func (m *DirectoryMembershipHistoryMutation) ResetDirectorySyncRunID() {
	m.directory_sync_run_id = nil
}

// SetDirectoryAccountID sets the "directory_account_id" field.
func (m *DirectoryMembershipHistoryMutation) SetDirectoryAccountID(s string) {
	m.directory_account_id = &s
}

// DirectoryAccountID returns the value of the "directory_account_id" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) DirectoryAccountID() (r string, exists bool) {
	v := m.directory_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectoryAccountID returns the old "directory_account_id" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldDirectoryAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectoryAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectoryAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectoryAccountID: %w", err)
	}
	return oldValue.DirectoryAccountID, nil
}

// ResetDirectoryAccountID resets all changes to the "directory_account_id" field.
func (m *DirectoryMembershipHistoryMutation) ResetDirectoryAccountID() {
	m.directory_account_id = nil
}

// SetDirectoryGroupID sets the "directory_group_id" field.
func (m *DirectoryMembershipHistoryMutation) SetDirectoryGroupID(s string) {
	m.directory_group_id = &s
}

// DirectoryGroupID returns the value of the "directory_group_id" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) DirectoryGroupID() (r string, exists bool) {
	v := m.directory_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectoryGroupID returns the old "directory_group_id" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldDirectoryGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectoryGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectoryGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectoryGroupID: %w", err)
	}
	return oldValue.DirectoryGroupID, nil
}

// ResetDirectoryGroupID resets all changes to the "directory_group_id" field.
func (m *DirectoryMembershipHistoryMutation) ResetDirectoryGroupID() {
	m.directory_group_id = nil
}

// SetRole sets the "role" field.
func (m *DirectoryMembershipHistoryMutation) SetRole(emr enums.DirectoryMembershipRole) {
	m.role = &emr
}

// Role returns the value of the "role" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) Role() (r enums.DirectoryMembershipRole, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldRole(ctx context.Context) (v enums.DirectoryMembershipRole, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of the "role" field.
func (m *DirectoryMembershipHistoryMutation) ClearRole() {
	m.role = nil
	m.clearedFields[directorymembershiphistory.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *DirectoryMembershipHistoryMutation) RoleCleared() bool {
	_, ok := m.clearedFields[directorymembershiphistory.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *DirectoryMembershipHistoryMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, directorymembershiphistory.FieldRole)
}

// SetSource sets the "source" field.
func (m *DirectoryMembershipHistoryMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldSource(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *DirectoryMembershipHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[directorymembershiphistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *DirectoryMembershipHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[directorymembershiphistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *DirectoryMembershipHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, directorymembershiphistory.FieldSource)
}

// SetFirstSeenAt sets the "first_seen_at" field.
func (m *DirectoryMembershipHistoryMutation) SetFirstSeenAt(t time.Time) {
	m.first_seen_at = &t
}

// FirstSeenAt returns the value of the "first_seen_at" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) FirstSeenAt() (r time.Time, exists bool) {
	v := m.first_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstSeenAt returns the old "first_seen_at" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldFirstSeenAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstSeenAt: %w", err)
	}
	return oldValue.FirstSeenAt, nil
}

// ClearFirstSeenAt clears the value of the "first_seen_at" field.
func (m *DirectoryMembershipHistoryMutation) ClearFirstSeenAt() {
	m.first_seen_at = nil
	m.clearedFields[directorymembershiphistory.FieldFirstSeenAt] = struct{}{}
}

// FirstSeenAtCleared returns if the "first_seen_at" field was cleared in this mutation.
func (m *DirectoryMembershipHistoryMutation) FirstSeenAtCleared() bool {
	_, ok := m.clearedFields[directorymembershiphistory.FieldFirstSeenAt]
	return ok
}

// ResetFirstSeenAt resets all changes to the "first_seen_at" field.
func (m *DirectoryMembershipHistoryMutation) ResetFirstSeenAt() {
	m.first_seen_at = nil
	delete(m.clearedFields, directorymembershiphistory.FieldFirstSeenAt)
}

// SetLastSeenAt sets the "last_seen_at" field.
func (m *DirectoryMembershipHistoryMutation) SetLastSeenAt(t time.Time) {
	m.last_seen_at = &t
}

// LastSeenAt returns the value of the "last_seen_at" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) LastSeenAt() (r time.Time, exists bool) {
	v := m.last_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenAt returns the old "last_seen_at" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldLastSeenAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenAt: %w", err)
	}
	return oldValue.LastSeenAt, nil
}

// ClearLastSeenAt clears the value of the "last_seen_at" field.
func (m *DirectoryMembershipHistoryMutation) ClearLastSeenAt() {
	m.last_seen_at = nil
	m.clearedFields[directorymembershiphistory.FieldLastSeenAt] = struct{}{}
}

// LastSeenAtCleared returns if the "last_seen_at" field was cleared in this mutation.
func (m *DirectoryMembershipHistoryMutation) LastSeenAtCleared() bool {
	_, ok := m.clearedFields[directorymembershiphistory.FieldLastSeenAt]
	return ok
}

// ResetLastSeenAt resets all changes to the "last_seen_at" field.
func (m *DirectoryMembershipHistoryMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
	delete(m.clearedFields, directorymembershiphistory.FieldLastSeenAt)
}

// SetObservedAt sets the "observed_at" field.
func (m *DirectoryMembershipHistoryMutation) SetObservedAt(t time.Time) {
	m.observed_at = &t
}

// ObservedAt returns the value of the "observed_at" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) ObservedAt() (r time.Time, exists bool) {
	v := m.observed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldObservedAt returns the old "observed_at" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldObservedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObservedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObservedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObservedAt: %w", err)
	}
	return oldValue.ObservedAt, nil
}

// ResetObservedAt resets all changes to the "observed_at" field.
func (m *DirectoryMembershipHistoryMutation) ResetObservedAt() {
	m.observed_at = nil
}

// SetLastConfirmedRunID sets the "last_confirmed_run_id" field.
func (m *DirectoryMembershipHistoryMutation) SetLastConfirmedRunID(s string) {
	m.last_confirmed_run_id = &s
}

// LastConfirmedRunID returns the value of the "last_confirmed_run_id" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) LastConfirmedRunID() (r string, exists bool) {
	v := m.last_confirmed_run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLastConfirmedRunID returns the old "last_confirmed_run_id" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldLastConfirmedRunID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastConfirmedRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastConfirmedRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastConfirmedRunID: %w", err)
	}
	return oldValue.LastConfirmedRunID, nil
}

// ClearLastConfirmedRunID clears the value of the "last_confirmed_run_id" field.
func (m *DirectoryMembershipHistoryMutation) ClearLastConfirmedRunID() {
	m.last_confirmed_run_id = nil
	m.clearedFields[directorymembershiphistory.FieldLastConfirmedRunID] = struct{}{}
}

// LastConfirmedRunIDCleared returns if the "last_confirmed_run_id" field was cleared in this mutation.
func (m *DirectoryMembershipHistoryMutation) LastConfirmedRunIDCleared() bool {
	_, ok := m.clearedFields[directorymembershiphistory.FieldLastConfirmedRunID]
	return ok
}

// ResetLastConfirmedRunID resets all changes to the "last_confirmed_run_id" field.
func (m *DirectoryMembershipHistoryMutation) ResetLastConfirmedRunID() {
	m.last_confirmed_run_id = nil
	delete(m.clearedFields, directorymembershiphistory.FieldLastConfirmedRunID)
}

// SetMetadata sets the "metadata" field.
func (m *DirectoryMembershipHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *DirectoryMembershipHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the DirectoryMembershipHistory entity.
// If the DirectoryMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectoryMembershipHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *DirectoryMembershipHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[directorymembershiphistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *DirectoryMembershipHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[directorymembershiphistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *DirectoryMembershipHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, directorymembershiphistory.FieldMetadata)
}

// Where appends a list predicates to the DirectoryMembershipHistoryMutation builder.
func (m *DirectoryMembershipHistoryMutation) Where(ps ...predicate.DirectoryMembershipHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DirectoryMembershipHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DirectoryMembershipHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DirectoryMembershipHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DirectoryMembershipHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DirectoryMembershipHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DirectoryMembershipHistory).
func (m *DirectoryMembershipHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DirectoryMembershipHistoryMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.history_time != nil {
		fields = append(fields, directorymembershiphistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, directorymembershiphistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, directorymembershiphistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, directorymembershiphistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, directorymembershiphistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, directorymembershiphistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, directorymembershiphistory.FieldUpdatedBy)
	}
	if m.display_id != nil {
		fields = append(fields, directorymembershiphistory.FieldDisplayID)
	}
	if m.owner_id != nil {
		fields = append(fields, directorymembershiphistory.FieldOwnerID)
	}
	if m.integration_id != nil {
		fields = append(fields, directorymembershiphistory.FieldIntegrationID)
	}
	if m.directory_sync_run_id != nil {
		fields = append(fields, directorymembershiphistory.FieldDirectorySyncRunID)
	}
	if m.directory_account_id != nil {
		fields = append(fields, directorymembershiphistory.FieldDirectoryAccountID)
	}
	if m.directory_group_id != nil {
		fields = append(fields, directorymembershiphistory.FieldDirectoryGroupID)
	}
	if m.role != nil {
		fields = append(fields, directorymembershiphistory.FieldRole)
	}
	if m.source != nil {
		fields = append(fields, directorymembershiphistory.FieldSource)
	}
	if m.first_seen_at != nil {
		fields = append(fields, directorymembershiphistory.FieldFirstSeenAt)
	}
	if m.last_seen_at != nil {
		fields = append(fields, directorymembershiphistory.FieldLastSeenAt)
	}
	if m.observed_at != nil {
		fields = append(fields, directorymembershiphistory.FieldObservedAt)
	}
	if m.last_confirmed_run_id != nil {
		fields = append(fields, directorymembershiphistory.FieldLastConfirmedRunID)
	}
	if m.metadata != nil {
		fields = append(fields, directorymembershiphistory.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DirectoryMembershipHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case directorymembershiphistory.FieldHistoryTime:
		return m.HistoryTime()
	case directorymembershiphistory.FieldRef:
		return m.Ref()
	case directorymembershiphistory.FieldOperation:
		return m.Operation()
	case directorymembershiphistory.FieldCreatedAt:
		return m.CreatedAt()
	case directorymembershiphistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case directorymembershiphistory.FieldCreatedBy:
		return m.CreatedBy()
	case directorymembershiphistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case directorymembershiphistory.FieldDisplayID:
		return m.DisplayID()
	case directorymembershiphistory.FieldOwnerID:
		return m.OwnerID()
	case directorymembershiphistory.FieldIntegrationID:
		return m.IntegrationID()
	case directorymembershiphistory.FieldDirectorySyncRunID:
		return m.DirectorySyncRunID()
	case directorymembershiphistory.FieldDirectoryAccountID:
		return m.DirectoryAccountID()
	case directorymembershiphistory.FieldDirectoryGroupID:
		return m.DirectoryGroupID()
	case directorymembershiphistory.FieldRole:
		return m.Role()
	case directorymembershiphistory.FieldSource:
		return m.Source()
	case directorymembershiphistory.FieldFirstSeenAt:
		return m.FirstSeenAt()
	case directorymembershiphistory.FieldLastSeenAt:
		return m.LastSeenAt()
	case directorymembershiphistory.FieldObservedAt:
		return m.ObservedAt()
	case directorymembershiphistory.FieldLastConfirmedRunID:
		return m.LastConfirmedRunID()
	case directorymembershiphistory.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DirectoryMembershipHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case directorymembershiphistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case directorymembershiphistory.FieldRef:
		return m.OldRef(ctx)
	case directorymembershiphistory.FieldOperation:
		return m.OldOperation(ctx)
	case directorymembershiphistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case directorymembershiphistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case directorymembershiphistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case directorymembershiphistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case directorymembershiphistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case directorymembershiphistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case directorymembershiphistory.FieldIntegrationID:
		return m.OldIntegrationID(ctx)
	case directorymembershiphistory.FieldDirectorySyncRunID:
		return m.OldDirectorySyncRunID(ctx)
	case directorymembershiphistory.FieldDirectoryAccountID:
		return m.OldDirectoryAccountID(ctx)
	case directorymembershiphistory.FieldDirectoryGroupID:
		return m.OldDirectoryGroupID(ctx)
	case directorymembershiphistory.FieldRole:
		return m.OldRole(ctx)
	case directorymembershiphistory.FieldSource:
		return m.OldSource(ctx)
	case directorymembershiphistory.FieldFirstSeenAt:
		return m.OldFirstSeenAt(ctx)
	case directorymembershiphistory.FieldLastSeenAt:
		return m.OldLastSeenAt(ctx)
	case directorymembershiphistory.FieldObservedAt:
		return m.OldObservedAt(ctx)
	case directorymembershiphistory.FieldLastConfirmedRunID:
		return m.OldLastConfirmedRunID(ctx)
	case directorymembershiphistory.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown DirectoryMembershipHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DirectoryMembershipHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case directorymembershiphistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case directorymembershiphistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case directorymembershiphistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case directorymembershiphistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case directorymembershiphistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case directorymembershiphistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case directorymembershiphistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case directorymembershiphistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case directorymembershiphistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case directorymembershiphistory.FieldIntegrationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntegrationID(v)
		return nil
	case directorymembershiphistory.FieldDirectorySyncRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectorySyncRunID(v)
		return nil
	case directorymembershiphistory.FieldDirectoryAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectoryAccountID(v)
		return nil
	case directorymembershiphistory.FieldDirectoryGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectoryGroupID(v)
		return nil
	case directorymembershiphistory.FieldRole:
		v, ok := value.(enums.DirectoryMembershipRole)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case directorymembershiphistory.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case directorymembershiphistory.FieldFirstSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstSeenAt(v)
		return nil
	case directorymembershiphistory.FieldLastSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenAt(v)
		return nil
	case directorymembershiphistory.FieldObservedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObservedAt(v)
		return nil
	case directorymembershiphistory.FieldLastConfirmedRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastConfirmedRunID(v)
		return nil
	case directorymembershiphistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown DirectoryMembershipHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DirectoryMembershipHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DirectoryMembershipHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DirectoryMembershipHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DirectoryMembershipHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DirectoryMembershipHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(directorymembershiphistory.FieldRef) {
		fields = append(fields, directorymembershiphistory.FieldRef)
	}
	if m.FieldCleared(directorymembershiphistory.FieldCreatedAt) {
		fields = append(fields, directorymembershiphistory.FieldCreatedAt)
	}
	if m.FieldCleared(directorymembershiphistory.FieldUpdatedAt) {
		fields = append(fields, directorymembershiphistory.FieldUpdatedAt)
	}
	if m.FieldCleared(directorymembershiphistory.FieldCreatedBy) {
		fields = append(fields, directorymembershiphistory.FieldCreatedBy)
	}
	if m.FieldCleared(directorymembershiphistory.FieldUpdatedBy) {
		fields = append(fields, directorymembershiphistory.FieldUpdatedBy)
	}
	if m.FieldCleared(directorymembershiphistory.FieldOwnerID) {
		fields = append(fields, directorymembershiphistory.FieldOwnerID)
	}
	if m.FieldCleared(directorymembershiphistory.FieldRole) {
		fields = append(fields, directorymembershiphistory.FieldRole)
	}
	if m.FieldCleared(directorymembershiphistory.FieldSource) {
		fields = append(fields, directorymembershiphistory.FieldSource)
	}
	if m.FieldCleared(directorymembershiphistory.FieldFirstSeenAt) {
		fields = append(fields, directorymembershiphistory.FieldFirstSeenAt)
	}
	if m.FieldCleared(directorymembershiphistory.FieldLastSeenAt) {
		fields = append(fields, directorymembershiphistory.FieldLastSeenAt)
	}
	if m.FieldCleared(directorymembershiphistory.FieldLastConfirmedRunID) {
		fields = append(fields, directorymembershiphistory.FieldLastConfirmedRunID)
	}
	if m.FieldCleared(directorymembershiphistory.FieldMetadata) {
		fields = append(fields, directorymembershiphistory.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DirectoryMembershipHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DirectoryMembershipHistoryMutation) ClearField(name string) error {
	switch name {
	case directorymembershiphistory.FieldRef:
		m.ClearRef()
		return nil
	case directorymembershiphistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case directorymembershiphistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case directorymembershiphistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case directorymembershiphistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case directorymembershiphistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case directorymembershiphistory.FieldRole:
		m.ClearRole()
		return nil
	case directorymembershiphistory.FieldSource:
		m.ClearSource()
		return nil
	case directorymembershiphistory.FieldFirstSeenAt:
		m.ClearFirstSeenAt()
		return nil
	case directorymembershiphistory.FieldLastSeenAt:
		m.ClearLastSeenAt()
		return nil
	case directorymembershiphistory.FieldLastConfirmedRunID:
		m.ClearLastConfirmedRunID()
		return nil
	case directorymembershiphistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown DirectoryMembershipHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DirectoryMembershipHistoryMutation) ResetField(name string) error {
	switch name {
	case directorymembershiphistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case directorymembershiphistory.FieldRef:
		m.ResetRef()
		return nil
	case directorymembershiphistory.FieldOperation:
		m.ResetOperation()
		return nil
	case directorymembershiphistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case directorymembershiphistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case directorymembershiphistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case directorymembershiphistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case directorymembershiphistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case directorymembershiphistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case directorymembershiphistory.FieldIntegrationID:
		m.ResetIntegrationID()
		return nil
	case directorymembershiphistory.FieldDirectorySyncRunID:
		m.ResetDirectorySyncRunID()
		return nil
	case directorymembershiphistory.FieldDirectoryAccountID:
		m.ResetDirectoryAccountID()
		return nil
	case directorymembershiphistory.FieldDirectoryGroupID:
		m.ResetDirectoryGroupID()
		return nil
	case directorymembershiphistory.FieldRole:
		m.ResetRole()
		return nil
	case directorymembershiphistory.FieldSource:
		m.ResetSource()
		return nil
	case directorymembershiphistory.FieldFirstSeenAt:
		m.ResetFirstSeenAt()
		return nil
	case directorymembershiphistory.FieldLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	case directorymembershiphistory.FieldObservedAt:
		m.ResetObservedAt()
		return nil
	case directorymembershiphistory.FieldLastConfirmedRunID:
		m.ResetLastConfirmedRunID()
		return nil
	case directorymembershiphistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown DirectoryMembershipHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DirectoryMembershipHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DirectoryMembershipHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DirectoryMembershipHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DirectoryMembershipHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DirectoryMembershipHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DirectoryMembershipHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DirectoryMembershipHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DirectoryMembershipHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DirectoryMembershipHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DirectoryMembershipHistory edge %s", name)
}

// DiscussionHistoryMutation represents an operation that mutates the DiscussionHistory nodes in the graph.
type DiscussionHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	deleted_at    *time.Time
	deleted_by    *string
	owner_id      *string
	external_id   *string
	is_resolved   *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DiscussionHistory, error)
	predicates    []predicate.DiscussionHistory
}

var _ ent.Mutation = (*DiscussionHistoryMutation)(nil)

// discussionhistoryOption allows management of the mutation configuration using functional options.
type discussionhistoryOption func(*DiscussionHistoryMutation)

// newDiscussionHistoryMutation creates new mutation for the DiscussionHistory entity.
func newDiscussionHistoryMutation(c config, op Op, opts ...discussionhistoryOption) *DiscussionHistoryMutation {
	m := &DiscussionHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeDiscussionHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiscussionHistoryID sets the ID field of the mutation.
func withDiscussionHistoryID(id string) discussionhistoryOption {
	return func(m *DiscussionHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *DiscussionHistory
		)
		m.oldValue = func(ctx context.Context) (*DiscussionHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DiscussionHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiscussionHistory sets the old DiscussionHistory of the mutation.
func withDiscussionHistory(node *DiscussionHistory) discussionhistoryOption {
	return func(m *DiscussionHistoryMutation) {
		m.oldValue = func(context.Context) (*DiscussionHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiscussionHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiscussionHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DiscussionHistory entities.
func (m *DiscussionHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiscussionHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiscussionHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DiscussionHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *DiscussionHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *DiscussionHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the DiscussionHistory entity.
// If the DiscussionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscussionHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *DiscussionHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *DiscussionHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *DiscussionHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the DiscussionHistory entity.
// If the DiscussionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscussionHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *DiscussionHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[discussionhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *DiscussionHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[discussionhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *DiscussionHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, discussionhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *DiscussionHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *DiscussionHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the DiscussionHistory entity.
// If the DiscussionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscussionHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *DiscussionHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DiscussionHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DiscussionHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DiscussionHistory entity.
// If the DiscussionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscussionHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DiscussionHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[discussionhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DiscussionHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[discussionhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DiscussionHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, discussionhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DiscussionHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DiscussionHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DiscussionHistory entity.
// If the DiscussionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscussionHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DiscussionHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[discussionhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DiscussionHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[discussionhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DiscussionHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, discussionhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *DiscussionHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DiscussionHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DiscussionHistory entity.
// If the DiscussionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscussionHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DiscussionHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[discussionhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DiscussionHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[discussionhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DiscussionHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, discussionhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DiscussionHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DiscussionHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DiscussionHistory entity.
// If the DiscussionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscussionHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DiscussionHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[discussionhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DiscussionHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[discussionhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DiscussionHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, discussionhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DiscussionHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DiscussionHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DiscussionHistory entity.
// If the DiscussionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscussionHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DiscussionHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[discussionhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DiscussionHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[discussionhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DiscussionHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, discussionhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *DiscussionHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *DiscussionHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the DiscussionHistory entity.
// If the DiscussionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscussionHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *DiscussionHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[discussionhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *DiscussionHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[discussionhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *DiscussionHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, discussionhistory.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *DiscussionHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *DiscussionHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the DiscussionHistory entity.
// If the DiscussionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscussionHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *DiscussionHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[discussionhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *DiscussionHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[discussionhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *DiscussionHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, discussionhistory.FieldOwnerID)
}

// SetExternalID sets the "external_id" field.
func (m *DiscussionHistoryMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *DiscussionHistoryMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the DiscussionHistory entity.
// If the DiscussionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscussionHistoryMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *DiscussionHistoryMutation) ResetExternalID() {
	m.external_id = nil
}

// SetIsResolved sets the "is_resolved" field.
func (m *DiscussionHistoryMutation) SetIsResolved(b bool) {
	m.is_resolved = &b
}

// IsResolved returns the value of the "is_resolved" field in the mutation.
func (m *DiscussionHistoryMutation) IsResolved() (r bool, exists bool) {
	v := m.is_resolved
	if v == nil {
		return
	}
	return *v, true
}

// OldIsResolved returns the old "is_resolved" field's value of the DiscussionHistory entity.
// If the DiscussionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscussionHistoryMutation) OldIsResolved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsResolved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsResolved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsResolved: %w", err)
	}
	return oldValue.IsResolved, nil
}

// ResetIsResolved resets all changes to the "is_resolved" field.
func (m *DiscussionHistoryMutation) ResetIsResolved() {
	m.is_resolved = nil
}

// Where appends a list predicates to the DiscussionHistoryMutation builder.
func (m *DiscussionHistoryMutation) Where(ps ...predicate.DiscussionHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DiscussionHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DiscussionHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DiscussionHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DiscussionHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DiscussionHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DiscussionHistory).
func (m *DiscussionHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiscussionHistoryMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.history_time != nil {
		fields = append(fields, discussionhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, discussionhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, discussionhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, discussionhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, discussionhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, discussionhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, discussionhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, discussionhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, discussionhistory.FieldDeletedBy)
	}
	if m.owner_id != nil {
		fields = append(fields, discussionhistory.FieldOwnerID)
	}
	if m.external_id != nil {
		fields = append(fields, discussionhistory.FieldExternalID)
	}
	if m.is_resolved != nil {
		fields = append(fields, discussionhistory.FieldIsResolved)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiscussionHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case discussionhistory.FieldHistoryTime:
		return m.HistoryTime()
	case discussionhistory.FieldRef:
		return m.Ref()
	case discussionhistory.FieldOperation:
		return m.Operation()
	case discussionhistory.FieldCreatedAt:
		return m.CreatedAt()
	case discussionhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case discussionhistory.FieldCreatedBy:
		return m.CreatedBy()
	case discussionhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case discussionhistory.FieldDeletedAt:
		return m.DeletedAt()
	case discussionhistory.FieldDeletedBy:
		return m.DeletedBy()
	case discussionhistory.FieldOwnerID:
		return m.OwnerID()
	case discussionhistory.FieldExternalID:
		return m.ExternalID()
	case discussionhistory.FieldIsResolved:
		return m.IsResolved()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiscussionHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case discussionhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case discussionhistory.FieldRef:
		return m.OldRef(ctx)
	case discussionhistory.FieldOperation:
		return m.OldOperation(ctx)
	case discussionhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case discussionhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case discussionhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case discussionhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case discussionhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case discussionhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case discussionhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case discussionhistory.FieldExternalID:
		return m.OldExternalID(ctx)
	case discussionhistory.FieldIsResolved:
		return m.OldIsResolved(ctx)
	}
	return nil, fmt.Errorf("unknown DiscussionHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscussionHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case discussionhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case discussionhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case discussionhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case discussionhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case discussionhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case discussionhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case discussionhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case discussionhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case discussionhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case discussionhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case discussionhistory.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case discussionhistory.FieldIsResolved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsResolved(v)
		return nil
	}
	return fmt.Errorf("unknown DiscussionHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiscussionHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiscussionHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscussionHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DiscussionHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiscussionHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(discussionhistory.FieldRef) {
		fields = append(fields, discussionhistory.FieldRef)
	}
	if m.FieldCleared(discussionhistory.FieldCreatedAt) {
		fields = append(fields, discussionhistory.FieldCreatedAt)
	}
	if m.FieldCleared(discussionhistory.FieldUpdatedAt) {
		fields = append(fields, discussionhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(discussionhistory.FieldCreatedBy) {
		fields = append(fields, discussionhistory.FieldCreatedBy)
	}
	if m.FieldCleared(discussionhistory.FieldUpdatedBy) {
		fields = append(fields, discussionhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(discussionhistory.FieldDeletedAt) {
		fields = append(fields, discussionhistory.FieldDeletedAt)
	}
	if m.FieldCleared(discussionhistory.FieldDeletedBy) {
		fields = append(fields, discussionhistory.FieldDeletedBy)
	}
	if m.FieldCleared(discussionhistory.FieldOwnerID) {
		fields = append(fields, discussionhistory.FieldOwnerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiscussionHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiscussionHistoryMutation) ClearField(name string) error {
	switch name {
	case discussionhistory.FieldRef:
		m.ClearRef()
		return nil
	case discussionhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case discussionhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case discussionhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case discussionhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case discussionhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case discussionhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case discussionhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	}
	return fmt.Errorf("unknown DiscussionHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiscussionHistoryMutation) ResetField(name string) error {
	switch name {
	case discussionhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case discussionhistory.FieldRef:
		m.ResetRef()
		return nil
	case discussionhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case discussionhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case discussionhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case discussionhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case discussionhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case discussionhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case discussionhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case discussionhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case discussionhistory.FieldExternalID:
		m.ResetExternalID()
		return nil
	case discussionhistory.FieldIsResolved:
		m.ResetIsResolved()
		return nil
	}
	return fmt.Errorf("unknown DiscussionHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiscussionHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiscussionHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiscussionHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiscussionHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiscussionHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiscussionHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiscussionHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DiscussionHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiscussionHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DiscussionHistory edge %s", name)
}

// DocumentDataHistoryMutation represents an operation that mutates the DocumentDataHistory nodes in the graph.
type DocumentDataHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	deleted_at    *time.Time
	deleted_by    *string
	tags          *[]string
	appendtags    []string
	owner_id      *string
	template_id   *string
	data          *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DocumentDataHistory, error)
	predicates    []predicate.DocumentDataHistory
}

var _ ent.Mutation = (*DocumentDataHistoryMutation)(nil)

// documentdatahistoryOption allows management of the mutation configuration using functional options.
type documentdatahistoryOption func(*DocumentDataHistoryMutation)

// newDocumentDataHistoryMutation creates new mutation for the DocumentDataHistory entity.
func newDocumentDataHistoryMutation(c config, op Op, opts ...documentdatahistoryOption) *DocumentDataHistoryMutation {
	m := &DocumentDataHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeDocumentDataHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentDataHistoryID sets the ID field of the mutation.
func withDocumentDataHistoryID(id string) documentdatahistoryOption {
	return func(m *DocumentDataHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *DocumentDataHistory
		)
		m.oldValue = func(ctx context.Context) (*DocumentDataHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DocumentDataHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocumentDataHistory sets the old DocumentDataHistory of the mutation.
func withDocumentDataHistory(node *DocumentDataHistory) documentdatahistoryOption {
	return func(m *DocumentDataHistoryMutation) {
		m.oldValue = func(context.Context) (*DocumentDataHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentDataHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentDataHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DocumentDataHistory entities.
func (m *DocumentDataHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentDataHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentDataHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DocumentDataHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *DocumentDataHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *DocumentDataHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *DocumentDataHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *DocumentDataHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *DocumentDataHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *DocumentDataHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[documentdatahistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *DocumentDataHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, documentdatahistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *DocumentDataHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *DocumentDataHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *DocumentDataHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DocumentDataHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocumentDataHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DocumentDataHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[documentdatahistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocumentDataHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, documentdatahistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DocumentDataHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DocumentDataHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DocumentDataHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[documentdatahistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DocumentDataHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, documentdatahistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *DocumentDataHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DocumentDataHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DocumentDataHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[documentdatahistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DocumentDataHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, documentdatahistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DocumentDataHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DocumentDataHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DocumentDataHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[documentdatahistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DocumentDataHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, documentdatahistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DocumentDataHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DocumentDataHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DocumentDataHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[documentdatahistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DocumentDataHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, documentdatahistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *DocumentDataHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *DocumentDataHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *DocumentDataHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[documentdatahistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *DocumentDataHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, documentdatahistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *DocumentDataHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *DocumentDataHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *DocumentDataHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *DocumentDataHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *DocumentDataHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[documentdatahistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *DocumentDataHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, documentdatahistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *DocumentDataHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *DocumentDataHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *DocumentDataHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[documentdatahistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *DocumentDataHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, documentdatahistory.FieldOwnerID)
}

// SetTemplateID sets the "template_id" field.
func (m *DocumentDataHistoryMutation) SetTemplateID(s string) {
	m.template_id = &s
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *DocumentDataHistoryMutation) TemplateID() (r string, exists bool) {
	v := m.template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ClearTemplateID clears the value of the "template_id" field.
func (m *DocumentDataHistoryMutation) ClearTemplateID() {
	m.template_id = nil
	m.clearedFields[documentdatahistory.FieldTemplateID] = struct{}{}
}

// TemplateIDCleared returns if the "template_id" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) TemplateIDCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldTemplateID]
	return ok
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *DocumentDataHistoryMutation) ResetTemplateID() {
	m.template_id = nil
	delete(m.clearedFields, documentdatahistory.FieldTemplateID)
}

// SetData sets the "data" field.
func (m *DocumentDataHistoryMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *DocumentDataHistoryMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *DocumentDataHistoryMutation) ResetData() {
	m.data = nil
}

// Where appends a list predicates to the DocumentDataHistoryMutation builder.
func (m *DocumentDataHistoryMutation) Where(ps ...predicate.DocumentDataHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentDataHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentDataHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DocumentDataHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentDataHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentDataHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DocumentDataHistory).
func (m *DocumentDataHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentDataHistoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.history_time != nil {
		fields = append(fields, documentdatahistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, documentdatahistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, documentdatahistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, documentdatahistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, documentdatahistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, documentdatahistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, documentdatahistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, documentdatahistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, documentdatahistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, documentdatahistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, documentdatahistory.FieldOwnerID)
	}
	if m.template_id != nil {
		fields = append(fields, documentdatahistory.FieldTemplateID)
	}
	if m.data != nil {
		fields = append(fields, documentdatahistory.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentDataHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case documentdatahistory.FieldHistoryTime:
		return m.HistoryTime()
	case documentdatahistory.FieldRef:
		return m.Ref()
	case documentdatahistory.FieldOperation:
		return m.Operation()
	case documentdatahistory.FieldCreatedAt:
		return m.CreatedAt()
	case documentdatahistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case documentdatahistory.FieldCreatedBy:
		return m.CreatedBy()
	case documentdatahistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case documentdatahistory.FieldDeletedAt:
		return m.DeletedAt()
	case documentdatahistory.FieldDeletedBy:
		return m.DeletedBy()
	case documentdatahistory.FieldTags:
		return m.Tags()
	case documentdatahistory.FieldOwnerID:
		return m.OwnerID()
	case documentdatahistory.FieldTemplateID:
		return m.TemplateID()
	case documentdatahistory.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentDataHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case documentdatahistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case documentdatahistory.FieldRef:
		return m.OldRef(ctx)
	case documentdatahistory.FieldOperation:
		return m.OldOperation(ctx)
	case documentdatahistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case documentdatahistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case documentdatahistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case documentdatahistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case documentdatahistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case documentdatahistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case documentdatahistory.FieldTags:
		return m.OldTags(ctx)
	case documentdatahistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case documentdatahistory.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case documentdatahistory.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown DocumentDataHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentDataHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case documentdatahistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case documentdatahistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case documentdatahistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case documentdatahistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case documentdatahistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case documentdatahistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case documentdatahistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case documentdatahistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case documentdatahistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case documentdatahistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case documentdatahistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case documentdatahistory.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case documentdatahistory.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentDataHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentDataHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentDataHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentDataHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DocumentDataHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentDataHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(documentdatahistory.FieldRef) {
		fields = append(fields, documentdatahistory.FieldRef)
	}
	if m.FieldCleared(documentdatahistory.FieldCreatedAt) {
		fields = append(fields, documentdatahistory.FieldCreatedAt)
	}
	if m.FieldCleared(documentdatahistory.FieldUpdatedAt) {
		fields = append(fields, documentdatahistory.FieldUpdatedAt)
	}
	if m.FieldCleared(documentdatahistory.FieldCreatedBy) {
		fields = append(fields, documentdatahistory.FieldCreatedBy)
	}
	if m.FieldCleared(documentdatahistory.FieldUpdatedBy) {
		fields = append(fields, documentdatahistory.FieldUpdatedBy)
	}
	if m.FieldCleared(documentdatahistory.FieldDeletedAt) {
		fields = append(fields, documentdatahistory.FieldDeletedAt)
	}
	if m.FieldCleared(documentdatahistory.FieldDeletedBy) {
		fields = append(fields, documentdatahistory.FieldDeletedBy)
	}
	if m.FieldCleared(documentdatahistory.FieldTags) {
		fields = append(fields, documentdatahistory.FieldTags)
	}
	if m.FieldCleared(documentdatahistory.FieldOwnerID) {
		fields = append(fields, documentdatahistory.FieldOwnerID)
	}
	if m.FieldCleared(documentdatahistory.FieldTemplateID) {
		fields = append(fields, documentdatahistory.FieldTemplateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentDataHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentDataHistoryMutation) ClearField(name string) error {
	switch name {
	case documentdatahistory.FieldRef:
		m.ClearRef()
		return nil
	case documentdatahistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case documentdatahistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case documentdatahistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case documentdatahistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case documentdatahistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case documentdatahistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case documentdatahistory.FieldTags:
		m.ClearTags()
		return nil
	case documentdatahistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case documentdatahistory.FieldTemplateID:
		m.ClearTemplateID()
		return nil
	}
	return fmt.Errorf("unknown DocumentDataHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentDataHistoryMutation) ResetField(name string) error {
	switch name {
	case documentdatahistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case documentdatahistory.FieldRef:
		m.ResetRef()
		return nil
	case documentdatahistory.FieldOperation:
		m.ResetOperation()
		return nil
	case documentdatahistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case documentdatahistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case documentdatahistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case documentdatahistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case documentdatahistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case documentdatahistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case documentdatahistory.FieldTags:
		m.ResetTags()
		return nil
	case documentdatahistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case documentdatahistory.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case documentdatahistory.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown DocumentDataHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentDataHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentDataHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentDataHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentDataHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentDataHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentDataHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentDataHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DocumentDataHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentDataHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DocumentDataHistory edge %s", name)
}

// EntityHistoryMutation represents an operation that mutates the EntityHistory nodes in the graph.
type EntityHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	history_time       *time.Time
	ref                *string
	operation          *history.OpType
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	deleted_at         *time.Time
	deleted_by         *string
	tags               *[]string
	appendtags         []string
	owner_id           *string
	system_owned       *bool
	internal_notes     *string
	system_internal_id *string
	name               *string
	display_name       *string
	description        *string
	domains            *[]string
	appenddomains      []string
	entity_type_id     *string
	status             *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*EntityHistory, error)
	predicates         []predicate.EntityHistory
}

var _ ent.Mutation = (*EntityHistoryMutation)(nil)

// entityhistoryOption allows management of the mutation configuration using functional options.
type entityhistoryOption func(*EntityHistoryMutation)

// newEntityHistoryMutation creates new mutation for the EntityHistory entity.
func newEntityHistoryMutation(c config, op Op, opts ...entityhistoryOption) *EntityHistoryMutation {
	m := &EntityHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeEntityHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityHistoryID sets the ID field of the mutation.
func withEntityHistoryID(id string) entityhistoryOption {
	return func(m *EntityHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *EntityHistory
		)
		m.oldValue = func(ctx context.Context) (*EntityHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntityHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntityHistory sets the old EntityHistory of the mutation.
func withEntityHistory(node *EntityHistory) entityhistoryOption {
	return func(m *EntityHistoryMutation) {
		m.oldValue = func(context.Context) (*EntityHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntityHistory entities.
func (m *EntityHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntityHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *EntityHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *EntityHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *EntityHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *EntityHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *EntityHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *EntityHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[entityhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *EntityHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *EntityHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, entityhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *EntityHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *EntityHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *EntityHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EntityHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntityHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EntityHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[entityhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EntityHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntityHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, entityhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntityHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntityHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntityHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entityhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntityHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntityHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entityhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EntityHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntityHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EntityHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[entityhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EntityHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntityHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, entityhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EntityHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EntityHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EntityHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[entityhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EntityHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EntityHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, entityhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntityHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntityHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntityHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entityhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntityHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntityHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entityhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *EntityHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *EntityHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *EntityHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[entityhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *EntityHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *EntityHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, entityhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *EntityHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EntityHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EntityHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EntityHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EntityHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[entityhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EntityHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EntityHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, entityhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *EntityHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *EntityHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *EntityHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[entityhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *EntityHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *EntityHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, entityhistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *EntityHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *EntityHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *EntityHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[entityhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *EntityHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *EntityHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, entityhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *EntityHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *EntityHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *EntityHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[entityhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *EntityHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *EntityHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, entityhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *EntityHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *EntityHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *EntityHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[entityhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *EntityHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *EntityHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, entityhistory.FieldSystemInternalID)
}

// SetName sets the "name" field.
func (m *EntityHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EntityHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *EntityHistoryMutation) ClearName() {
	m.name = nil
	m.clearedFields[entityhistory.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *EntityHistoryMutation) NameCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *EntityHistoryMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, entityhistory.FieldName)
}

// SetDisplayName sets the "display_name" field.
func (m *EntityHistoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *EntityHistoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *EntityHistoryMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[entityhistory.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *EntityHistoryMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *EntityHistoryMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, entityhistory.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *EntityHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EntityHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EntityHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[entityhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EntityHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EntityHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, entityhistory.FieldDescription)
}

// SetDomains sets the "domains" field.
func (m *EntityHistoryMutation) SetDomains(s []string) {
	m.domains = &s
	m.appenddomains = nil
}

// Domains returns the value of the "domains" field in the mutation.
func (m *EntityHistoryMutation) Domains() (r []string, exists bool) {
	v := m.domains
	if v == nil {
		return
	}
	return *v, true
}

// OldDomains returns the old "domains" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldDomains(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomains: %w", err)
	}
	return oldValue.Domains, nil
}

// AppendDomains adds s to the "domains" field.
func (m *EntityHistoryMutation) AppendDomains(s []string) {
	m.appenddomains = append(m.appenddomains, s...)
}

// AppendedDomains returns the list of values that were appended to the "domains" field in this mutation.
func (m *EntityHistoryMutation) AppendedDomains() ([]string, bool) {
	if len(m.appenddomains) == 0 {
		return nil, false
	}
	return m.appenddomains, true
}

// ClearDomains clears the value of the "domains" field.
func (m *EntityHistoryMutation) ClearDomains() {
	m.domains = nil
	m.appenddomains = nil
	m.clearedFields[entityhistory.FieldDomains] = struct{}{}
}

// DomainsCleared returns if the "domains" field was cleared in this mutation.
func (m *EntityHistoryMutation) DomainsCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldDomains]
	return ok
}

// ResetDomains resets all changes to the "domains" field.
func (m *EntityHistoryMutation) ResetDomains() {
	m.domains = nil
	m.appenddomains = nil
	delete(m.clearedFields, entityhistory.FieldDomains)
}

// SetEntityTypeID sets the "entity_type_id" field.
func (m *EntityHistoryMutation) SetEntityTypeID(s string) {
	m.entity_type_id = &s
}

// EntityTypeID returns the value of the "entity_type_id" field in the mutation.
func (m *EntityHistoryMutation) EntityTypeID() (r string, exists bool) {
	v := m.entity_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityTypeID returns the old "entity_type_id" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldEntityTypeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityTypeID: %w", err)
	}
	return oldValue.EntityTypeID, nil
}

// ClearEntityTypeID clears the value of the "entity_type_id" field.
func (m *EntityHistoryMutation) ClearEntityTypeID() {
	m.entity_type_id = nil
	m.clearedFields[entityhistory.FieldEntityTypeID] = struct{}{}
}

// EntityTypeIDCleared returns if the "entity_type_id" field was cleared in this mutation.
func (m *EntityHistoryMutation) EntityTypeIDCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldEntityTypeID]
	return ok
}

// ResetEntityTypeID resets all changes to the "entity_type_id" field.
func (m *EntityHistoryMutation) ResetEntityTypeID() {
	m.entity_type_id = nil
	delete(m.clearedFields, entityhistory.FieldEntityTypeID)
}

// SetStatus sets the "status" field.
func (m *EntityHistoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EntityHistoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *EntityHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[entityhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *EntityHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *EntityHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, entityhistory.FieldStatus)
}

// Where appends a list predicates to the EntityHistoryMutation builder.
func (m *EntityHistoryMutation) Where(ps ...predicate.EntityHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntityHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntityHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntityHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntityHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntityHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntityHistory).
func (m *EntityHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityHistoryMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.history_time != nil {
		fields = append(fields, entityhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, entityhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, entityhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, entityhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entityhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, entityhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, entityhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, entityhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, entityhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, entityhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, entityhistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, entityhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, entityhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, entityhistory.FieldSystemInternalID)
	}
	if m.name != nil {
		fields = append(fields, entityhistory.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, entityhistory.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, entityhistory.FieldDescription)
	}
	if m.domains != nil {
		fields = append(fields, entityhistory.FieldDomains)
	}
	if m.entity_type_id != nil {
		fields = append(fields, entityhistory.FieldEntityTypeID)
	}
	if m.status != nil {
		fields = append(fields, entityhistory.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entityhistory.FieldHistoryTime:
		return m.HistoryTime()
	case entityhistory.FieldRef:
		return m.Ref()
	case entityhistory.FieldOperation:
		return m.Operation()
	case entityhistory.FieldCreatedAt:
		return m.CreatedAt()
	case entityhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case entityhistory.FieldCreatedBy:
		return m.CreatedBy()
	case entityhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case entityhistory.FieldDeletedAt:
		return m.DeletedAt()
	case entityhistory.FieldDeletedBy:
		return m.DeletedBy()
	case entityhistory.FieldTags:
		return m.Tags()
	case entityhistory.FieldOwnerID:
		return m.OwnerID()
	case entityhistory.FieldSystemOwned:
		return m.SystemOwned()
	case entityhistory.FieldInternalNotes:
		return m.InternalNotes()
	case entityhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case entityhistory.FieldName:
		return m.Name()
	case entityhistory.FieldDisplayName:
		return m.DisplayName()
	case entityhistory.FieldDescription:
		return m.Description()
	case entityhistory.FieldDomains:
		return m.Domains()
	case entityhistory.FieldEntityTypeID:
		return m.EntityTypeID()
	case entityhistory.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entityhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case entityhistory.FieldRef:
		return m.OldRef(ctx)
	case entityhistory.FieldOperation:
		return m.OldOperation(ctx)
	case entityhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entityhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entityhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entityhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case entityhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entityhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case entityhistory.FieldTags:
		return m.OldTags(ctx)
	case entityhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case entityhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case entityhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case entityhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case entityhistory.FieldName:
		return m.OldName(ctx)
	case entityhistory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case entityhistory.FieldDescription:
		return m.OldDescription(ctx)
	case entityhistory.FieldDomains:
		return m.OldDomains(ctx)
	case entityhistory.FieldEntityTypeID:
		return m.OldEntityTypeID(ctx)
	case entityhistory.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown EntityHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entityhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case entityhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case entityhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case entityhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entityhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entityhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entityhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case entityhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entityhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case entityhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case entityhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case entityhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case entityhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case entityhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case entityhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case entityhistory.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case entityhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case entityhistory.FieldDomains:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomains(v)
		return nil
	case entityhistory.FieldEntityTypeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityTypeID(v)
		return nil
	case entityhistory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown EntityHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntityHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entityhistory.FieldRef) {
		fields = append(fields, entityhistory.FieldRef)
	}
	if m.FieldCleared(entityhistory.FieldCreatedAt) {
		fields = append(fields, entityhistory.FieldCreatedAt)
	}
	if m.FieldCleared(entityhistory.FieldUpdatedAt) {
		fields = append(fields, entityhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(entityhistory.FieldCreatedBy) {
		fields = append(fields, entityhistory.FieldCreatedBy)
	}
	if m.FieldCleared(entityhistory.FieldUpdatedBy) {
		fields = append(fields, entityhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(entityhistory.FieldDeletedAt) {
		fields = append(fields, entityhistory.FieldDeletedAt)
	}
	if m.FieldCleared(entityhistory.FieldDeletedBy) {
		fields = append(fields, entityhistory.FieldDeletedBy)
	}
	if m.FieldCleared(entityhistory.FieldTags) {
		fields = append(fields, entityhistory.FieldTags)
	}
	if m.FieldCleared(entityhistory.FieldOwnerID) {
		fields = append(fields, entityhistory.FieldOwnerID)
	}
	if m.FieldCleared(entityhistory.FieldSystemOwned) {
		fields = append(fields, entityhistory.FieldSystemOwned)
	}
	if m.FieldCleared(entityhistory.FieldInternalNotes) {
		fields = append(fields, entityhistory.FieldInternalNotes)
	}
	if m.FieldCleared(entityhistory.FieldSystemInternalID) {
		fields = append(fields, entityhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(entityhistory.FieldName) {
		fields = append(fields, entityhistory.FieldName)
	}
	if m.FieldCleared(entityhistory.FieldDisplayName) {
		fields = append(fields, entityhistory.FieldDisplayName)
	}
	if m.FieldCleared(entityhistory.FieldDescription) {
		fields = append(fields, entityhistory.FieldDescription)
	}
	if m.FieldCleared(entityhistory.FieldDomains) {
		fields = append(fields, entityhistory.FieldDomains)
	}
	if m.FieldCleared(entityhistory.FieldEntityTypeID) {
		fields = append(fields, entityhistory.FieldEntityTypeID)
	}
	if m.FieldCleared(entityhistory.FieldStatus) {
		fields = append(fields, entityhistory.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityHistoryMutation) ClearField(name string) error {
	switch name {
	case entityhistory.FieldRef:
		m.ClearRef()
		return nil
	case entityhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case entityhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case entityhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case entityhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case entityhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entityhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case entityhistory.FieldTags:
		m.ClearTags()
		return nil
	case entityhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case entityhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case entityhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case entityhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case entityhistory.FieldName:
		m.ClearName()
		return nil
	case entityhistory.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case entityhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case entityhistory.FieldDomains:
		m.ClearDomains()
		return nil
	case entityhistory.FieldEntityTypeID:
		m.ClearEntityTypeID()
		return nil
	case entityhistory.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown EntityHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityHistoryMutation) ResetField(name string) error {
	switch name {
	case entityhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case entityhistory.FieldRef:
		m.ResetRef()
		return nil
	case entityhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case entityhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entityhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entityhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entityhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case entityhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entityhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case entityhistory.FieldTags:
		m.ResetTags()
		return nil
	case entityhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case entityhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case entityhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case entityhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case entityhistory.FieldName:
		m.ResetName()
		return nil
	case entityhistory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case entityhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case entityhistory.FieldDomains:
		m.ResetDomains()
		return nil
	case entityhistory.FieldEntityTypeID:
		m.ResetEntityTypeID()
		return nil
	case entityhistory.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown EntityHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EntityHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EntityHistory edge %s", name)
}

// EntityTypeHistoryMutation represents an operation that mutates the EntityTypeHistory nodes in the graph.
type EntityTypeHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	history_time       *time.Time
	ref                *string
	operation          *history.OpType
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	deleted_at         *time.Time
	deleted_by         *string
	tags               *[]string
	appendtags         []string
	owner_id           *string
	system_owned       *bool
	internal_notes     *string
	system_internal_id *string
	name               *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*EntityTypeHistory, error)
	predicates         []predicate.EntityTypeHistory
}

var _ ent.Mutation = (*EntityTypeHistoryMutation)(nil)

// entitytypehistoryOption allows management of the mutation configuration using functional options.
type entitytypehistoryOption func(*EntityTypeHistoryMutation)

// newEntityTypeHistoryMutation creates new mutation for the EntityTypeHistory entity.
func newEntityTypeHistoryMutation(c config, op Op, opts ...entitytypehistoryOption) *EntityTypeHistoryMutation {
	m := &EntityTypeHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeEntityTypeHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityTypeHistoryID sets the ID field of the mutation.
func withEntityTypeHistoryID(id string) entitytypehistoryOption {
	return func(m *EntityTypeHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *EntityTypeHistory
		)
		m.oldValue = func(ctx context.Context) (*EntityTypeHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntityTypeHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntityTypeHistory sets the old EntityTypeHistory of the mutation.
func withEntityTypeHistory(node *EntityTypeHistory) entitytypehistoryOption {
	return func(m *EntityTypeHistoryMutation) {
		m.oldValue = func(context.Context) (*EntityTypeHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityTypeHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityTypeHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntityTypeHistory entities.
func (m *EntityTypeHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityTypeHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityTypeHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntityTypeHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *EntityTypeHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *EntityTypeHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *EntityTypeHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *EntityTypeHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *EntityTypeHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *EntityTypeHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[entitytypehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *EntityTypeHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, entitytypehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *EntityTypeHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *EntityTypeHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *EntityTypeHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EntityTypeHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntityTypeHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EntityTypeHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[entitytypehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntityTypeHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, entitytypehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntityTypeHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntityTypeHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntityTypeHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entitytypehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntityTypeHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entitytypehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EntityTypeHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntityTypeHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EntityTypeHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[entitytypehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntityTypeHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, entitytypehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EntityTypeHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EntityTypeHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EntityTypeHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[entitytypehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EntityTypeHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, entitytypehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntityTypeHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntityTypeHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntityTypeHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entitytypehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntityTypeHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entitytypehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *EntityTypeHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *EntityTypeHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *EntityTypeHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[entitytypehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *EntityTypeHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, entitytypehistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *EntityTypeHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EntityTypeHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EntityTypeHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EntityTypeHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EntityTypeHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[entitytypehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EntityTypeHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, entitytypehistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *EntityTypeHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *EntityTypeHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *EntityTypeHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[entitytypehistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *EntityTypeHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, entitytypehistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *EntityTypeHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *EntityTypeHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *EntityTypeHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[entitytypehistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *EntityTypeHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, entitytypehistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *EntityTypeHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *EntityTypeHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *EntityTypeHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[entitytypehistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *EntityTypeHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, entitytypehistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *EntityTypeHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *EntityTypeHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *EntityTypeHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[entitytypehistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *EntityTypeHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, entitytypehistory.FieldSystemInternalID)
}

// SetName sets the "name" field.
func (m *EntityTypeHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EntityTypeHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EntityTypeHistoryMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the EntityTypeHistoryMutation builder.
func (m *EntityTypeHistoryMutation) Where(ps ...predicate.EntityTypeHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntityTypeHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntityTypeHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntityTypeHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntityTypeHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntityTypeHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntityTypeHistory).
func (m *EntityTypeHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityTypeHistoryMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.history_time != nil {
		fields = append(fields, entitytypehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, entitytypehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, entitytypehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, entitytypehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entitytypehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, entitytypehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, entitytypehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, entitytypehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, entitytypehistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, entitytypehistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, entitytypehistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, entitytypehistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, entitytypehistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, entitytypehistory.FieldSystemInternalID)
	}
	if m.name != nil {
		fields = append(fields, entitytypehistory.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityTypeHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitytypehistory.FieldHistoryTime:
		return m.HistoryTime()
	case entitytypehistory.FieldRef:
		return m.Ref()
	case entitytypehistory.FieldOperation:
		return m.Operation()
	case entitytypehistory.FieldCreatedAt:
		return m.CreatedAt()
	case entitytypehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case entitytypehistory.FieldCreatedBy:
		return m.CreatedBy()
	case entitytypehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case entitytypehistory.FieldDeletedAt:
		return m.DeletedAt()
	case entitytypehistory.FieldDeletedBy:
		return m.DeletedBy()
	case entitytypehistory.FieldTags:
		return m.Tags()
	case entitytypehistory.FieldOwnerID:
		return m.OwnerID()
	case entitytypehistory.FieldSystemOwned:
		return m.SystemOwned()
	case entitytypehistory.FieldInternalNotes:
		return m.InternalNotes()
	case entitytypehistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case entitytypehistory.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityTypeHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitytypehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case entitytypehistory.FieldRef:
		return m.OldRef(ctx)
	case entitytypehistory.FieldOperation:
		return m.OldOperation(ctx)
	case entitytypehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitytypehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entitytypehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entitytypehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case entitytypehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entitytypehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case entitytypehistory.FieldTags:
		return m.OldTags(ctx)
	case entitytypehistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case entitytypehistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case entitytypehistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case entitytypehistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case entitytypehistory.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown EntityTypeHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityTypeHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitytypehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case entitytypehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case entitytypehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case entitytypehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitytypehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entitytypehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entitytypehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case entitytypehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entitytypehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case entitytypehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case entitytypehistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case entitytypehistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case entitytypehistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case entitytypehistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case entitytypehistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown EntityTypeHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityTypeHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityTypeHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityTypeHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntityTypeHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityTypeHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitytypehistory.FieldRef) {
		fields = append(fields, entitytypehistory.FieldRef)
	}
	if m.FieldCleared(entitytypehistory.FieldCreatedAt) {
		fields = append(fields, entitytypehistory.FieldCreatedAt)
	}
	if m.FieldCleared(entitytypehistory.FieldUpdatedAt) {
		fields = append(fields, entitytypehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(entitytypehistory.FieldCreatedBy) {
		fields = append(fields, entitytypehistory.FieldCreatedBy)
	}
	if m.FieldCleared(entitytypehistory.FieldUpdatedBy) {
		fields = append(fields, entitytypehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(entitytypehistory.FieldDeletedAt) {
		fields = append(fields, entitytypehistory.FieldDeletedAt)
	}
	if m.FieldCleared(entitytypehistory.FieldDeletedBy) {
		fields = append(fields, entitytypehistory.FieldDeletedBy)
	}
	if m.FieldCleared(entitytypehistory.FieldTags) {
		fields = append(fields, entitytypehistory.FieldTags)
	}
	if m.FieldCleared(entitytypehistory.FieldOwnerID) {
		fields = append(fields, entitytypehistory.FieldOwnerID)
	}
	if m.FieldCleared(entitytypehistory.FieldSystemOwned) {
		fields = append(fields, entitytypehistory.FieldSystemOwned)
	}
	if m.FieldCleared(entitytypehistory.FieldInternalNotes) {
		fields = append(fields, entitytypehistory.FieldInternalNotes)
	}
	if m.FieldCleared(entitytypehistory.FieldSystemInternalID) {
		fields = append(fields, entitytypehistory.FieldSystemInternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityTypeHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityTypeHistoryMutation) ClearField(name string) error {
	switch name {
	case entitytypehistory.FieldRef:
		m.ClearRef()
		return nil
	case entitytypehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case entitytypehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case entitytypehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case entitytypehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case entitytypehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entitytypehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case entitytypehistory.FieldTags:
		m.ClearTags()
		return nil
	case entitytypehistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case entitytypehistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case entitytypehistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case entitytypehistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	}
	return fmt.Errorf("unknown EntityTypeHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityTypeHistoryMutation) ResetField(name string) error {
	switch name {
	case entitytypehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case entitytypehistory.FieldRef:
		m.ResetRef()
		return nil
	case entitytypehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case entitytypehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitytypehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entitytypehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entitytypehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case entitytypehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entitytypehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case entitytypehistory.FieldTags:
		m.ResetTags()
		return nil
	case entitytypehistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case entitytypehistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case entitytypehistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case entitytypehistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case entitytypehistory.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown EntityTypeHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityTypeHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityTypeHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityTypeHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityTypeHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityTypeHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityTypeHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityTypeHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EntityTypeHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityTypeHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EntityTypeHistory edge %s", name)
}

// EvidenceHistoryMutation represents an operation that mutates the EvidenceHistory nodes in the graph.
type EvidenceHistoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	history_time         *time.Time
	ref                  *string
	operation            *history.OpType
	created_at           *time.Time
	updated_at           *time.Time
	created_by           *string
	updated_by           *string
	deleted_at           *time.Time
	deleted_by           *string
	display_id           *string
	tags                 *[]string
	appendtags           []string
	owner_id             *string
	name                 *string
	description          *string
	collection_procedure *string
	creation_date        *time.Time
	renewal_date         *time.Time
	source               *string
	is_automated         *bool
	url                  *string
	status               *enums.EvidenceStatus
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*EvidenceHistory, error)
	predicates           []predicate.EvidenceHistory
}

var _ ent.Mutation = (*EvidenceHistoryMutation)(nil)

// evidencehistoryOption allows management of the mutation configuration using functional options.
type evidencehistoryOption func(*EvidenceHistoryMutation)

// newEvidenceHistoryMutation creates new mutation for the EvidenceHistory entity.
func newEvidenceHistoryMutation(c config, op Op, opts ...evidencehistoryOption) *EvidenceHistoryMutation {
	m := &EvidenceHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeEvidenceHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEvidenceHistoryID sets the ID field of the mutation.
func withEvidenceHistoryID(id string) evidencehistoryOption {
	return func(m *EvidenceHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *EvidenceHistory
		)
		m.oldValue = func(ctx context.Context) (*EvidenceHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EvidenceHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvidenceHistory sets the old EvidenceHistory of the mutation.
func withEvidenceHistory(node *EvidenceHistory) evidencehistoryOption {
	return func(m *EvidenceHistoryMutation) {
		m.oldValue = func(context.Context) (*EvidenceHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EvidenceHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EvidenceHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EvidenceHistory entities.
func (m *EvidenceHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EvidenceHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EvidenceHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EvidenceHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *EvidenceHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *EvidenceHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *EvidenceHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *EvidenceHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *EvidenceHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *EvidenceHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[evidencehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *EvidenceHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, evidencehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *EvidenceHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *EvidenceHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *EvidenceHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EvidenceHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EvidenceHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EvidenceHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[evidencehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EvidenceHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, evidencehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EvidenceHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EvidenceHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EvidenceHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[evidencehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EvidenceHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, evidencehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EvidenceHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EvidenceHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EvidenceHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[evidencehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EvidenceHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, evidencehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EvidenceHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EvidenceHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EvidenceHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[evidencehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EvidenceHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, evidencehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EvidenceHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EvidenceHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EvidenceHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[evidencehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EvidenceHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, evidencehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *EvidenceHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *EvidenceHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *EvidenceHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[evidencehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *EvidenceHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, evidencehistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *EvidenceHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *EvidenceHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *EvidenceHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *EvidenceHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EvidenceHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EvidenceHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EvidenceHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EvidenceHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[evidencehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EvidenceHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, evidencehistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *EvidenceHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *EvidenceHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *EvidenceHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[evidencehistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *EvidenceHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, evidencehistory.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *EvidenceHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EvidenceHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EvidenceHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EvidenceHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EvidenceHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EvidenceHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[evidencehistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EvidenceHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, evidencehistory.FieldDescription)
}

// SetCollectionProcedure sets the "collection_procedure" field.
func (m *EvidenceHistoryMutation) SetCollectionProcedure(s string) {
	m.collection_procedure = &s
}

// CollectionProcedure returns the value of the "collection_procedure" field in the mutation.
func (m *EvidenceHistoryMutation) CollectionProcedure() (r string, exists bool) {
	v := m.collection_procedure
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectionProcedure returns the old "collection_procedure" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldCollectionProcedure(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectionProcedure is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectionProcedure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectionProcedure: %w", err)
	}
	return oldValue.CollectionProcedure, nil
}

// ClearCollectionProcedure clears the value of the "collection_procedure" field.
func (m *EvidenceHistoryMutation) ClearCollectionProcedure() {
	m.collection_procedure = nil
	m.clearedFields[evidencehistory.FieldCollectionProcedure] = struct{}{}
}

// CollectionProcedureCleared returns if the "collection_procedure" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) CollectionProcedureCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldCollectionProcedure]
	return ok
}

// ResetCollectionProcedure resets all changes to the "collection_procedure" field.
func (m *EvidenceHistoryMutation) ResetCollectionProcedure() {
	m.collection_procedure = nil
	delete(m.clearedFields, evidencehistory.FieldCollectionProcedure)
}

// SetCreationDate sets the "creation_date" field.
func (m *EvidenceHistoryMutation) SetCreationDate(t time.Time) {
	m.creation_date = &t
}

// CreationDate returns the value of the "creation_date" field in the mutation.
func (m *EvidenceHistoryMutation) CreationDate() (r time.Time, exists bool) {
	v := m.creation_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreationDate returns the old "creation_date" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldCreationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreationDate: %w", err)
	}
	return oldValue.CreationDate, nil
}

// ResetCreationDate resets all changes to the "creation_date" field.
func (m *EvidenceHistoryMutation) ResetCreationDate() {
	m.creation_date = nil
}

// SetRenewalDate sets the "renewal_date" field.
func (m *EvidenceHistoryMutation) SetRenewalDate(t time.Time) {
	m.renewal_date = &t
}

// RenewalDate returns the value of the "renewal_date" field in the mutation.
func (m *EvidenceHistoryMutation) RenewalDate() (r time.Time, exists bool) {
	v := m.renewal_date
	if v == nil {
		return
	}
	return *v, true
}

// OldRenewalDate returns the old "renewal_date" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldRenewalDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenewalDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenewalDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenewalDate: %w", err)
	}
	return oldValue.RenewalDate, nil
}

// ClearRenewalDate clears the value of the "renewal_date" field.
func (m *EvidenceHistoryMutation) ClearRenewalDate() {
	m.renewal_date = nil
	m.clearedFields[evidencehistory.FieldRenewalDate] = struct{}{}
}

// RenewalDateCleared returns if the "renewal_date" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) RenewalDateCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldRenewalDate]
	return ok
}

// ResetRenewalDate resets all changes to the "renewal_date" field.
func (m *EvidenceHistoryMutation) ResetRenewalDate() {
	m.renewal_date = nil
	delete(m.clearedFields, evidencehistory.FieldRenewalDate)
}

// SetSource sets the "source" field.
func (m *EvidenceHistoryMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *EvidenceHistoryMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *EvidenceHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[evidencehistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *EvidenceHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, evidencehistory.FieldSource)
}

// SetIsAutomated sets the "is_automated" field.
func (m *EvidenceHistoryMutation) SetIsAutomated(b bool) {
	m.is_automated = &b
}

// IsAutomated returns the value of the "is_automated" field in the mutation.
func (m *EvidenceHistoryMutation) IsAutomated() (r bool, exists bool) {
	v := m.is_automated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAutomated returns the old "is_automated" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldIsAutomated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAutomated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAutomated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAutomated: %w", err)
	}
	return oldValue.IsAutomated, nil
}

// ClearIsAutomated clears the value of the "is_automated" field.
func (m *EvidenceHistoryMutation) ClearIsAutomated() {
	m.is_automated = nil
	m.clearedFields[evidencehistory.FieldIsAutomated] = struct{}{}
}

// IsAutomatedCleared returns if the "is_automated" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) IsAutomatedCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldIsAutomated]
	return ok
}

// ResetIsAutomated resets all changes to the "is_automated" field.
func (m *EvidenceHistoryMutation) ResetIsAutomated() {
	m.is_automated = nil
	delete(m.clearedFields, evidencehistory.FieldIsAutomated)
}

// SetURL sets the "url" field.
func (m *EvidenceHistoryMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *EvidenceHistoryMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *EvidenceHistoryMutation) ClearURL() {
	m.url = nil
	m.clearedFields[evidencehistory.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) URLCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *EvidenceHistoryMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, evidencehistory.FieldURL)
}

// SetStatus sets the "status" field.
func (m *EvidenceHistoryMutation) SetStatus(es enums.EvidenceStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *EvidenceHistoryMutation) Status() (r enums.EvidenceStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EvidenceHistory entity.
// If the EvidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvidenceHistoryMutation) OldStatus(ctx context.Context) (v enums.EvidenceStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *EvidenceHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[evidencehistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *EvidenceHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[evidencehistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *EvidenceHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, evidencehistory.FieldStatus)
}

// Where appends a list predicates to the EvidenceHistoryMutation builder.
func (m *EvidenceHistoryMutation) Where(ps ...predicate.EvidenceHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EvidenceHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EvidenceHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EvidenceHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EvidenceHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EvidenceHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EvidenceHistory).
func (m *EvidenceHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EvidenceHistoryMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.history_time != nil {
		fields = append(fields, evidencehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, evidencehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, evidencehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, evidencehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, evidencehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, evidencehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, evidencehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, evidencehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, evidencehistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, evidencehistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, evidencehistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, evidencehistory.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, evidencehistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, evidencehistory.FieldDescription)
	}
	if m.collection_procedure != nil {
		fields = append(fields, evidencehistory.FieldCollectionProcedure)
	}
	if m.creation_date != nil {
		fields = append(fields, evidencehistory.FieldCreationDate)
	}
	if m.renewal_date != nil {
		fields = append(fields, evidencehistory.FieldRenewalDate)
	}
	if m.source != nil {
		fields = append(fields, evidencehistory.FieldSource)
	}
	if m.is_automated != nil {
		fields = append(fields, evidencehistory.FieldIsAutomated)
	}
	if m.url != nil {
		fields = append(fields, evidencehistory.FieldURL)
	}
	if m.status != nil {
		fields = append(fields, evidencehistory.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EvidenceHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case evidencehistory.FieldHistoryTime:
		return m.HistoryTime()
	case evidencehistory.FieldRef:
		return m.Ref()
	case evidencehistory.FieldOperation:
		return m.Operation()
	case evidencehistory.FieldCreatedAt:
		return m.CreatedAt()
	case evidencehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case evidencehistory.FieldCreatedBy:
		return m.CreatedBy()
	case evidencehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case evidencehistory.FieldDeletedAt:
		return m.DeletedAt()
	case evidencehistory.FieldDeletedBy:
		return m.DeletedBy()
	case evidencehistory.FieldDisplayID:
		return m.DisplayID()
	case evidencehistory.FieldTags:
		return m.Tags()
	case evidencehistory.FieldOwnerID:
		return m.OwnerID()
	case evidencehistory.FieldName:
		return m.Name()
	case evidencehistory.FieldDescription:
		return m.Description()
	case evidencehistory.FieldCollectionProcedure:
		return m.CollectionProcedure()
	case evidencehistory.FieldCreationDate:
		return m.CreationDate()
	case evidencehistory.FieldRenewalDate:
		return m.RenewalDate()
	case evidencehistory.FieldSource:
		return m.Source()
	case evidencehistory.FieldIsAutomated:
		return m.IsAutomated()
	case evidencehistory.FieldURL:
		return m.URL()
	case evidencehistory.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EvidenceHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case evidencehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case evidencehistory.FieldRef:
		return m.OldRef(ctx)
	case evidencehistory.FieldOperation:
		return m.OldOperation(ctx)
	case evidencehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case evidencehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case evidencehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case evidencehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case evidencehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case evidencehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case evidencehistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case evidencehistory.FieldTags:
		return m.OldTags(ctx)
	case evidencehistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case evidencehistory.FieldName:
		return m.OldName(ctx)
	case evidencehistory.FieldDescription:
		return m.OldDescription(ctx)
	case evidencehistory.FieldCollectionProcedure:
		return m.OldCollectionProcedure(ctx)
	case evidencehistory.FieldCreationDate:
		return m.OldCreationDate(ctx)
	case evidencehistory.FieldRenewalDate:
		return m.OldRenewalDate(ctx)
	case evidencehistory.FieldSource:
		return m.OldSource(ctx)
	case evidencehistory.FieldIsAutomated:
		return m.OldIsAutomated(ctx)
	case evidencehistory.FieldURL:
		return m.OldURL(ctx)
	case evidencehistory.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown EvidenceHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EvidenceHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case evidencehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case evidencehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case evidencehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case evidencehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case evidencehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case evidencehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case evidencehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case evidencehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case evidencehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case evidencehistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case evidencehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case evidencehistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case evidencehistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case evidencehistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case evidencehistory.FieldCollectionProcedure:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectionProcedure(v)
		return nil
	case evidencehistory.FieldCreationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreationDate(v)
		return nil
	case evidencehistory.FieldRenewalDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenewalDate(v)
		return nil
	case evidencehistory.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case evidencehistory.FieldIsAutomated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAutomated(v)
		return nil
	case evidencehistory.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case evidencehistory.FieldStatus:
		v, ok := value.(enums.EvidenceStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown EvidenceHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EvidenceHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EvidenceHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EvidenceHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EvidenceHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EvidenceHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(evidencehistory.FieldRef) {
		fields = append(fields, evidencehistory.FieldRef)
	}
	if m.FieldCleared(evidencehistory.FieldCreatedAt) {
		fields = append(fields, evidencehistory.FieldCreatedAt)
	}
	if m.FieldCleared(evidencehistory.FieldUpdatedAt) {
		fields = append(fields, evidencehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(evidencehistory.FieldCreatedBy) {
		fields = append(fields, evidencehistory.FieldCreatedBy)
	}
	if m.FieldCleared(evidencehistory.FieldUpdatedBy) {
		fields = append(fields, evidencehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(evidencehistory.FieldDeletedAt) {
		fields = append(fields, evidencehistory.FieldDeletedAt)
	}
	if m.FieldCleared(evidencehistory.FieldDeletedBy) {
		fields = append(fields, evidencehistory.FieldDeletedBy)
	}
	if m.FieldCleared(evidencehistory.FieldTags) {
		fields = append(fields, evidencehistory.FieldTags)
	}
	if m.FieldCleared(evidencehistory.FieldOwnerID) {
		fields = append(fields, evidencehistory.FieldOwnerID)
	}
	if m.FieldCleared(evidencehistory.FieldDescription) {
		fields = append(fields, evidencehistory.FieldDescription)
	}
	if m.FieldCleared(evidencehistory.FieldCollectionProcedure) {
		fields = append(fields, evidencehistory.FieldCollectionProcedure)
	}
	if m.FieldCleared(evidencehistory.FieldRenewalDate) {
		fields = append(fields, evidencehistory.FieldRenewalDate)
	}
	if m.FieldCleared(evidencehistory.FieldSource) {
		fields = append(fields, evidencehistory.FieldSource)
	}
	if m.FieldCleared(evidencehistory.FieldIsAutomated) {
		fields = append(fields, evidencehistory.FieldIsAutomated)
	}
	if m.FieldCleared(evidencehistory.FieldURL) {
		fields = append(fields, evidencehistory.FieldURL)
	}
	if m.FieldCleared(evidencehistory.FieldStatus) {
		fields = append(fields, evidencehistory.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EvidenceHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EvidenceHistoryMutation) ClearField(name string) error {
	switch name {
	case evidencehistory.FieldRef:
		m.ClearRef()
		return nil
	case evidencehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case evidencehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case evidencehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case evidencehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case evidencehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case evidencehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case evidencehistory.FieldTags:
		m.ClearTags()
		return nil
	case evidencehistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case evidencehistory.FieldDescription:
		m.ClearDescription()
		return nil
	case evidencehistory.FieldCollectionProcedure:
		m.ClearCollectionProcedure()
		return nil
	case evidencehistory.FieldRenewalDate:
		m.ClearRenewalDate()
		return nil
	case evidencehistory.FieldSource:
		m.ClearSource()
		return nil
	case evidencehistory.FieldIsAutomated:
		m.ClearIsAutomated()
		return nil
	case evidencehistory.FieldURL:
		m.ClearURL()
		return nil
	case evidencehistory.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown EvidenceHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EvidenceHistoryMutation) ResetField(name string) error {
	switch name {
	case evidencehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case evidencehistory.FieldRef:
		m.ResetRef()
		return nil
	case evidencehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case evidencehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case evidencehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case evidencehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case evidencehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case evidencehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case evidencehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case evidencehistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case evidencehistory.FieldTags:
		m.ResetTags()
		return nil
	case evidencehistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case evidencehistory.FieldName:
		m.ResetName()
		return nil
	case evidencehistory.FieldDescription:
		m.ResetDescription()
		return nil
	case evidencehistory.FieldCollectionProcedure:
		m.ResetCollectionProcedure()
		return nil
	case evidencehistory.FieldCreationDate:
		m.ResetCreationDate()
		return nil
	case evidencehistory.FieldRenewalDate:
		m.ResetRenewalDate()
		return nil
	case evidencehistory.FieldSource:
		m.ResetSource()
		return nil
	case evidencehistory.FieldIsAutomated:
		m.ResetIsAutomated()
		return nil
	case evidencehistory.FieldURL:
		m.ResetURL()
		return nil
	case evidencehistory.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown EvidenceHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EvidenceHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EvidenceHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EvidenceHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EvidenceHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EvidenceHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EvidenceHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EvidenceHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EvidenceHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EvidenceHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EvidenceHistory edge %s", name)
}

// FileHistoryMutation represents an operation that mutates the FileHistory nodes in the graph.
type FileHistoryMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	history_time            *time.Time
	ref                     *string
	operation               *history.OpType
	created_at              *time.Time
	updated_at              *time.Time
	created_by              *string
	updated_by              *string
	deleted_at              *time.Time
	deleted_by              *string
	tags                    *[]string
	appendtags              []string
	system_owned            *bool
	internal_notes          *string
	system_internal_id      *string
	provided_file_name      *string
	provided_file_extension *string
	provided_file_size      *int64
	addprovided_file_size   *int64
	persisted_file_size     *int64
	addpersisted_file_size  *int64
	detected_mime_type      *string
	md5_hash                *string
	detected_content_type   *string
	store_key               *string
	category_type           *string
	uri                     *string
	storage_scheme          *string
	storage_volume          *string
	storage_path            *string
	file_contents           *[]byte
	metadata                *map[string]interface{}
	storage_region          *string
	storage_provider        *string
	last_accessed_at        *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*FileHistory, error)
	predicates              []predicate.FileHistory
}

var _ ent.Mutation = (*FileHistoryMutation)(nil)

// filehistoryOption allows management of the mutation configuration using functional options.
type filehistoryOption func(*FileHistoryMutation)

// newFileHistoryMutation creates new mutation for the FileHistory entity.
func newFileHistoryMutation(c config, op Op, opts ...filehistoryOption) *FileHistoryMutation {
	m := &FileHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeFileHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileHistoryID sets the ID field of the mutation.
func withFileHistoryID(id string) filehistoryOption {
	return func(m *FileHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *FileHistory
		)
		m.oldValue = func(ctx context.Context) (*FileHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileHistory sets the old FileHistory of the mutation.
func withFileHistory(node *FileHistory) filehistoryOption {
	return func(m *FileHistoryMutation) {
		m.oldValue = func(context.Context) (*FileHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileHistory entities.
func (m *FileHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *FileHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *FileHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *FileHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *FileHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *FileHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *FileHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[filehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *FileHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *FileHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, filehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *FileHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *FileHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *FileHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FileHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *FileHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[filehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *FileHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, filehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *FileHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[filehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *FileHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, filehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *FileHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FileHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *FileHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[filehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *FileHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FileHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, filehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FileHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FileHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *FileHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[filehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *FileHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FileHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, filehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FileHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FileHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FileHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[filehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FileHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FileHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, filehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FileHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FileHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *FileHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[filehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *FileHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FileHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, filehistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *FileHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FileHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *FileHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *FileHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *FileHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[filehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *FileHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *FileHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, filehistory.FieldTags)
}

// SetSystemOwned sets the "system_owned" field.
func (m *FileHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *FileHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *FileHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[filehistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *FileHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *FileHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, filehistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *FileHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *FileHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *FileHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[filehistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *FileHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *FileHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, filehistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *FileHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *FileHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *FileHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[filehistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *FileHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *FileHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, filehistory.FieldSystemInternalID)
}

// SetProvidedFileName sets the "provided_file_name" field.
func (m *FileHistoryMutation) SetProvidedFileName(s string) {
	m.provided_file_name = &s
}

// ProvidedFileName returns the value of the "provided_file_name" field in the mutation.
func (m *FileHistoryMutation) ProvidedFileName() (r string, exists bool) {
	v := m.provided_file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProvidedFileName returns the old "provided_file_name" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldProvidedFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvidedFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvidedFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvidedFileName: %w", err)
	}
	return oldValue.ProvidedFileName, nil
}

// ResetProvidedFileName resets all changes to the "provided_file_name" field.
func (m *FileHistoryMutation) ResetProvidedFileName() {
	m.provided_file_name = nil
}

// SetProvidedFileExtension sets the "provided_file_extension" field.
func (m *FileHistoryMutation) SetProvidedFileExtension(s string) {
	m.provided_file_extension = &s
}

// ProvidedFileExtension returns the value of the "provided_file_extension" field in the mutation.
func (m *FileHistoryMutation) ProvidedFileExtension() (r string, exists bool) {
	v := m.provided_file_extension
	if v == nil {
		return
	}
	return *v, true
}

// OldProvidedFileExtension returns the old "provided_file_extension" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldProvidedFileExtension(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvidedFileExtension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvidedFileExtension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvidedFileExtension: %w", err)
	}
	return oldValue.ProvidedFileExtension, nil
}

// ResetProvidedFileExtension resets all changes to the "provided_file_extension" field.
func (m *FileHistoryMutation) ResetProvidedFileExtension() {
	m.provided_file_extension = nil
}

// SetProvidedFileSize sets the "provided_file_size" field.
func (m *FileHistoryMutation) SetProvidedFileSize(i int64) {
	m.provided_file_size = &i
	m.addprovided_file_size = nil
}

// ProvidedFileSize returns the value of the "provided_file_size" field in the mutation.
func (m *FileHistoryMutation) ProvidedFileSize() (r int64, exists bool) {
	v := m.provided_file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldProvidedFileSize returns the old "provided_file_size" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldProvidedFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvidedFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvidedFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvidedFileSize: %w", err)
	}
	return oldValue.ProvidedFileSize, nil
}

// AddProvidedFileSize adds i to the "provided_file_size" field.
func (m *FileHistoryMutation) AddProvidedFileSize(i int64) {
	if m.addprovided_file_size != nil {
		*m.addprovided_file_size += i
	} else {
		m.addprovided_file_size = &i
	}
}

// AddedProvidedFileSize returns the value that was added to the "provided_file_size" field in this mutation.
func (m *FileHistoryMutation) AddedProvidedFileSize() (r int64, exists bool) {
	v := m.addprovided_file_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearProvidedFileSize clears the value of the "provided_file_size" field.
func (m *FileHistoryMutation) ClearProvidedFileSize() {
	m.provided_file_size = nil
	m.addprovided_file_size = nil
	m.clearedFields[filehistory.FieldProvidedFileSize] = struct{}{}
}

// ProvidedFileSizeCleared returns if the "provided_file_size" field was cleared in this mutation.
func (m *FileHistoryMutation) ProvidedFileSizeCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldProvidedFileSize]
	return ok
}

// ResetProvidedFileSize resets all changes to the "provided_file_size" field.
func (m *FileHistoryMutation) ResetProvidedFileSize() {
	m.provided_file_size = nil
	m.addprovided_file_size = nil
	delete(m.clearedFields, filehistory.FieldProvidedFileSize)
}

// SetPersistedFileSize sets the "persisted_file_size" field.
func (m *FileHistoryMutation) SetPersistedFileSize(i int64) {
	m.persisted_file_size = &i
	m.addpersisted_file_size = nil
}

// PersistedFileSize returns the value of the "persisted_file_size" field in the mutation.
func (m *FileHistoryMutation) PersistedFileSize() (r int64, exists bool) {
	v := m.persisted_file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldPersistedFileSize returns the old "persisted_file_size" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldPersistedFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersistedFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersistedFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersistedFileSize: %w", err)
	}
	return oldValue.PersistedFileSize, nil
}

// AddPersistedFileSize adds i to the "persisted_file_size" field.
func (m *FileHistoryMutation) AddPersistedFileSize(i int64) {
	if m.addpersisted_file_size != nil {
		*m.addpersisted_file_size += i
	} else {
		m.addpersisted_file_size = &i
	}
}

// AddedPersistedFileSize returns the value that was added to the "persisted_file_size" field in this mutation.
func (m *FileHistoryMutation) AddedPersistedFileSize() (r int64, exists bool) {
	v := m.addpersisted_file_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearPersistedFileSize clears the value of the "persisted_file_size" field.
func (m *FileHistoryMutation) ClearPersistedFileSize() {
	m.persisted_file_size = nil
	m.addpersisted_file_size = nil
	m.clearedFields[filehistory.FieldPersistedFileSize] = struct{}{}
}

// PersistedFileSizeCleared returns if the "persisted_file_size" field was cleared in this mutation.
func (m *FileHistoryMutation) PersistedFileSizeCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldPersistedFileSize]
	return ok
}

// ResetPersistedFileSize resets all changes to the "persisted_file_size" field.
func (m *FileHistoryMutation) ResetPersistedFileSize() {
	m.persisted_file_size = nil
	m.addpersisted_file_size = nil
	delete(m.clearedFields, filehistory.FieldPersistedFileSize)
}

// SetDetectedMimeType sets the "detected_mime_type" field.
func (m *FileHistoryMutation) SetDetectedMimeType(s string) {
	m.detected_mime_type = &s
}

// DetectedMimeType returns the value of the "detected_mime_type" field in the mutation.
func (m *FileHistoryMutation) DetectedMimeType() (r string, exists bool) {
	v := m.detected_mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDetectedMimeType returns the old "detected_mime_type" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldDetectedMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetectedMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetectedMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetectedMimeType: %w", err)
	}
	return oldValue.DetectedMimeType, nil
}

// ClearDetectedMimeType clears the value of the "detected_mime_type" field.
func (m *FileHistoryMutation) ClearDetectedMimeType() {
	m.detected_mime_type = nil
	m.clearedFields[filehistory.FieldDetectedMimeType] = struct{}{}
}

// DetectedMimeTypeCleared returns if the "detected_mime_type" field was cleared in this mutation.
func (m *FileHistoryMutation) DetectedMimeTypeCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldDetectedMimeType]
	return ok
}

// ResetDetectedMimeType resets all changes to the "detected_mime_type" field.
func (m *FileHistoryMutation) ResetDetectedMimeType() {
	m.detected_mime_type = nil
	delete(m.clearedFields, filehistory.FieldDetectedMimeType)
}

// SetMd5Hash sets the "md5_hash" field.
func (m *FileHistoryMutation) SetMd5Hash(s string) {
	m.md5_hash = &s
}

// Md5Hash returns the value of the "md5_hash" field in the mutation.
func (m *FileHistoryMutation) Md5Hash() (r string, exists bool) {
	v := m.md5_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldMd5Hash returns the old "md5_hash" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldMd5Hash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMd5Hash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMd5Hash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMd5Hash: %w", err)
	}
	return oldValue.Md5Hash, nil
}

// ClearMd5Hash clears the value of the "md5_hash" field.
func (m *FileHistoryMutation) ClearMd5Hash() {
	m.md5_hash = nil
	m.clearedFields[filehistory.FieldMd5Hash] = struct{}{}
}

// Md5HashCleared returns if the "md5_hash" field was cleared in this mutation.
func (m *FileHistoryMutation) Md5HashCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldMd5Hash]
	return ok
}

// ResetMd5Hash resets all changes to the "md5_hash" field.
func (m *FileHistoryMutation) ResetMd5Hash() {
	m.md5_hash = nil
	delete(m.clearedFields, filehistory.FieldMd5Hash)
}

// SetDetectedContentType sets the "detected_content_type" field.
func (m *FileHistoryMutation) SetDetectedContentType(s string) {
	m.detected_content_type = &s
}

// DetectedContentType returns the value of the "detected_content_type" field in the mutation.
func (m *FileHistoryMutation) DetectedContentType() (r string, exists bool) {
	v := m.detected_content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDetectedContentType returns the old "detected_content_type" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldDetectedContentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetectedContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetectedContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetectedContentType: %w", err)
	}
	return oldValue.DetectedContentType, nil
}

// ResetDetectedContentType resets all changes to the "detected_content_type" field.
func (m *FileHistoryMutation) ResetDetectedContentType() {
	m.detected_content_type = nil
}

// SetStoreKey sets the "store_key" field.
func (m *FileHistoryMutation) SetStoreKey(s string) {
	m.store_key = &s
}

// StoreKey returns the value of the "store_key" field in the mutation.
func (m *FileHistoryMutation) StoreKey() (r string, exists bool) {
	v := m.store_key
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreKey returns the old "store_key" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldStoreKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreKey: %w", err)
	}
	return oldValue.StoreKey, nil
}

// ClearStoreKey clears the value of the "store_key" field.
func (m *FileHistoryMutation) ClearStoreKey() {
	m.store_key = nil
	m.clearedFields[filehistory.FieldStoreKey] = struct{}{}
}

// StoreKeyCleared returns if the "store_key" field was cleared in this mutation.
func (m *FileHistoryMutation) StoreKeyCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldStoreKey]
	return ok
}

// ResetStoreKey resets all changes to the "store_key" field.
func (m *FileHistoryMutation) ResetStoreKey() {
	m.store_key = nil
	delete(m.clearedFields, filehistory.FieldStoreKey)
}

// SetCategoryType sets the "category_type" field.
func (m *FileHistoryMutation) SetCategoryType(s string) {
	m.category_type = &s
}

// CategoryType returns the value of the "category_type" field in the mutation.
func (m *FileHistoryMutation) CategoryType() (r string, exists bool) {
	v := m.category_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryType returns the old "category_type" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldCategoryType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryType: %w", err)
	}
	return oldValue.CategoryType, nil
}

// ClearCategoryType clears the value of the "category_type" field.
func (m *FileHistoryMutation) ClearCategoryType() {
	m.category_type = nil
	m.clearedFields[filehistory.FieldCategoryType] = struct{}{}
}

// CategoryTypeCleared returns if the "category_type" field was cleared in this mutation.
func (m *FileHistoryMutation) CategoryTypeCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldCategoryType]
	return ok
}

// ResetCategoryType resets all changes to the "category_type" field.
func (m *FileHistoryMutation) ResetCategoryType() {
	m.category_type = nil
	delete(m.clearedFields, filehistory.FieldCategoryType)
}

// SetURI sets the "uri" field.
func (m *FileHistoryMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *FileHistoryMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ClearURI clears the value of the "uri" field.
func (m *FileHistoryMutation) ClearURI() {
	m.uri = nil
	m.clearedFields[filehistory.FieldURI] = struct{}{}
}

// URICleared returns if the "uri" field was cleared in this mutation.
func (m *FileHistoryMutation) URICleared() bool {
	_, ok := m.clearedFields[filehistory.FieldURI]
	return ok
}

// ResetURI resets all changes to the "uri" field.
func (m *FileHistoryMutation) ResetURI() {
	m.uri = nil
	delete(m.clearedFields, filehistory.FieldURI)
}

// SetStorageScheme sets the "storage_scheme" field.
func (m *FileHistoryMutation) SetStorageScheme(s string) {
	m.storage_scheme = &s
}

// StorageScheme returns the value of the "storage_scheme" field in the mutation.
func (m *FileHistoryMutation) StorageScheme() (r string, exists bool) {
	v := m.storage_scheme
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageScheme returns the old "storage_scheme" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldStorageScheme(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageScheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageScheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageScheme: %w", err)
	}
	return oldValue.StorageScheme, nil
}

// ClearStorageScheme clears the value of the "storage_scheme" field.
func (m *FileHistoryMutation) ClearStorageScheme() {
	m.storage_scheme = nil
	m.clearedFields[filehistory.FieldStorageScheme] = struct{}{}
}

// StorageSchemeCleared returns if the "storage_scheme" field was cleared in this mutation.
func (m *FileHistoryMutation) StorageSchemeCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldStorageScheme]
	return ok
}

// ResetStorageScheme resets all changes to the "storage_scheme" field.
func (m *FileHistoryMutation) ResetStorageScheme() {
	m.storage_scheme = nil
	delete(m.clearedFields, filehistory.FieldStorageScheme)
}

// SetStorageVolume sets the "storage_volume" field.
func (m *FileHistoryMutation) SetStorageVolume(s string) {
	m.storage_volume = &s
}

// StorageVolume returns the value of the "storage_volume" field in the mutation.
func (m *FileHistoryMutation) StorageVolume() (r string, exists bool) {
	v := m.storage_volume
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageVolume returns the old "storage_volume" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldStorageVolume(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageVolume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageVolume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageVolume: %w", err)
	}
	return oldValue.StorageVolume, nil
}

// ClearStorageVolume clears the value of the "storage_volume" field.
func (m *FileHistoryMutation) ClearStorageVolume() {
	m.storage_volume = nil
	m.clearedFields[filehistory.FieldStorageVolume] = struct{}{}
}

// StorageVolumeCleared returns if the "storage_volume" field was cleared in this mutation.
func (m *FileHistoryMutation) StorageVolumeCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldStorageVolume]
	return ok
}

// ResetStorageVolume resets all changes to the "storage_volume" field.
func (m *FileHistoryMutation) ResetStorageVolume() {
	m.storage_volume = nil
	delete(m.clearedFields, filehistory.FieldStorageVolume)
}

// SetStoragePath sets the "storage_path" field.
func (m *FileHistoryMutation) SetStoragePath(s string) {
	m.storage_path = &s
}

// StoragePath returns the value of the "storage_path" field in the mutation.
func (m *FileHistoryMutation) StoragePath() (r string, exists bool) {
	v := m.storage_path
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePath returns the old "storage_path" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldStoragePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePath: %w", err)
	}
	return oldValue.StoragePath, nil
}

// ClearStoragePath clears the value of the "storage_path" field.
func (m *FileHistoryMutation) ClearStoragePath() {
	m.storage_path = nil
	m.clearedFields[filehistory.FieldStoragePath] = struct{}{}
}

// StoragePathCleared returns if the "storage_path" field was cleared in this mutation.
func (m *FileHistoryMutation) StoragePathCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldStoragePath]
	return ok
}

// ResetStoragePath resets all changes to the "storage_path" field.
func (m *FileHistoryMutation) ResetStoragePath() {
	m.storage_path = nil
	delete(m.clearedFields, filehistory.FieldStoragePath)
}

// SetFileContents sets the "file_contents" field.
func (m *FileHistoryMutation) SetFileContents(b []byte) {
	m.file_contents = &b
}

// FileContents returns the value of the "file_contents" field in the mutation.
func (m *FileHistoryMutation) FileContents() (r []byte, exists bool) {
	v := m.file_contents
	if v == nil {
		return
	}
	return *v, true
}

// OldFileContents returns the old "file_contents" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldFileContents(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileContents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileContents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileContents: %w", err)
	}
	return oldValue.FileContents, nil
}

// ClearFileContents clears the value of the "file_contents" field.
func (m *FileHistoryMutation) ClearFileContents() {
	m.file_contents = nil
	m.clearedFields[filehistory.FieldFileContents] = struct{}{}
}

// FileContentsCleared returns if the "file_contents" field was cleared in this mutation.
func (m *FileHistoryMutation) FileContentsCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldFileContents]
	return ok
}

// ResetFileContents resets all changes to the "file_contents" field.
func (m *FileHistoryMutation) ResetFileContents() {
	m.file_contents = nil
	delete(m.clearedFields, filehistory.FieldFileContents)
}

// SetMetadata sets the "metadata" field.
func (m *FileHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *FileHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *FileHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[filehistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *FileHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *FileHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, filehistory.FieldMetadata)
}

// SetStorageRegion sets the "storage_region" field.
func (m *FileHistoryMutation) SetStorageRegion(s string) {
	m.storage_region = &s
}

// StorageRegion returns the value of the "storage_region" field in the mutation.
func (m *FileHistoryMutation) StorageRegion() (r string, exists bool) {
	v := m.storage_region
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageRegion returns the old "storage_region" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldStorageRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageRegion: %w", err)
	}
	return oldValue.StorageRegion, nil
}

// ClearStorageRegion clears the value of the "storage_region" field.
func (m *FileHistoryMutation) ClearStorageRegion() {
	m.storage_region = nil
	m.clearedFields[filehistory.FieldStorageRegion] = struct{}{}
}

// StorageRegionCleared returns if the "storage_region" field was cleared in this mutation.
func (m *FileHistoryMutation) StorageRegionCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldStorageRegion]
	return ok
}

// ResetStorageRegion resets all changes to the "storage_region" field.
func (m *FileHistoryMutation) ResetStorageRegion() {
	m.storage_region = nil
	delete(m.clearedFields, filehistory.FieldStorageRegion)
}

// SetStorageProvider sets the "storage_provider" field.
func (m *FileHistoryMutation) SetStorageProvider(s string) {
	m.storage_provider = &s
}

// StorageProvider returns the value of the "storage_provider" field in the mutation.
func (m *FileHistoryMutation) StorageProvider() (r string, exists bool) {
	v := m.storage_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageProvider returns the old "storage_provider" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldStorageProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageProvider: %w", err)
	}
	return oldValue.StorageProvider, nil
}

// ClearStorageProvider clears the value of the "storage_provider" field.
func (m *FileHistoryMutation) ClearStorageProvider() {
	m.storage_provider = nil
	m.clearedFields[filehistory.FieldStorageProvider] = struct{}{}
}

// StorageProviderCleared returns if the "storage_provider" field was cleared in this mutation.
func (m *FileHistoryMutation) StorageProviderCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldStorageProvider]
	return ok
}

// ResetStorageProvider resets all changes to the "storage_provider" field.
func (m *FileHistoryMutation) ResetStorageProvider() {
	m.storage_provider = nil
	delete(m.clearedFields, filehistory.FieldStorageProvider)
}

// SetLastAccessedAt sets the "last_accessed_at" field.
func (m *FileHistoryMutation) SetLastAccessedAt(t time.Time) {
	m.last_accessed_at = &t
}

// LastAccessedAt returns the value of the "last_accessed_at" field in the mutation.
func (m *FileHistoryMutation) LastAccessedAt() (r time.Time, exists bool) {
	v := m.last_accessed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastAccessedAt returns the old "last_accessed_at" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldLastAccessedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastAccessedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastAccessedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastAccessedAt: %w", err)
	}
	return oldValue.LastAccessedAt, nil
}

// ClearLastAccessedAt clears the value of the "last_accessed_at" field.
func (m *FileHistoryMutation) ClearLastAccessedAt() {
	m.last_accessed_at = nil
	m.clearedFields[filehistory.FieldLastAccessedAt] = struct{}{}
}

// LastAccessedAtCleared returns if the "last_accessed_at" field was cleared in this mutation.
func (m *FileHistoryMutation) LastAccessedAtCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldLastAccessedAt]
	return ok
}

// ResetLastAccessedAt resets all changes to the "last_accessed_at" field.
func (m *FileHistoryMutation) ResetLastAccessedAt() {
	m.last_accessed_at = nil
	delete(m.clearedFields, filehistory.FieldLastAccessedAt)
}

// Where appends a list predicates to the FileHistoryMutation builder.
func (m *FileHistoryMutation) Where(ps ...predicate.FileHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FileHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FileHistory).
func (m *FileHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileHistoryMutation) Fields() []string {
	fields := make([]string, 0, 31)
	if m.history_time != nil {
		fields = append(fields, filehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, filehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, filehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, filehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, filehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, filehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, filehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, filehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, filehistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, filehistory.FieldTags)
	}
	if m.system_owned != nil {
		fields = append(fields, filehistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, filehistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, filehistory.FieldSystemInternalID)
	}
	if m.provided_file_name != nil {
		fields = append(fields, filehistory.FieldProvidedFileName)
	}
	if m.provided_file_extension != nil {
		fields = append(fields, filehistory.FieldProvidedFileExtension)
	}
	if m.provided_file_size != nil {
		fields = append(fields, filehistory.FieldProvidedFileSize)
	}
	if m.persisted_file_size != nil {
		fields = append(fields, filehistory.FieldPersistedFileSize)
	}
	if m.detected_mime_type != nil {
		fields = append(fields, filehistory.FieldDetectedMimeType)
	}
	if m.md5_hash != nil {
		fields = append(fields, filehistory.FieldMd5Hash)
	}
	if m.detected_content_type != nil {
		fields = append(fields, filehistory.FieldDetectedContentType)
	}
	if m.store_key != nil {
		fields = append(fields, filehistory.FieldStoreKey)
	}
	if m.category_type != nil {
		fields = append(fields, filehistory.FieldCategoryType)
	}
	if m.uri != nil {
		fields = append(fields, filehistory.FieldURI)
	}
	if m.storage_scheme != nil {
		fields = append(fields, filehistory.FieldStorageScheme)
	}
	if m.storage_volume != nil {
		fields = append(fields, filehistory.FieldStorageVolume)
	}
	if m.storage_path != nil {
		fields = append(fields, filehistory.FieldStoragePath)
	}
	if m.file_contents != nil {
		fields = append(fields, filehistory.FieldFileContents)
	}
	if m.metadata != nil {
		fields = append(fields, filehistory.FieldMetadata)
	}
	if m.storage_region != nil {
		fields = append(fields, filehistory.FieldStorageRegion)
	}
	if m.storage_provider != nil {
		fields = append(fields, filehistory.FieldStorageProvider)
	}
	if m.last_accessed_at != nil {
		fields = append(fields, filehistory.FieldLastAccessedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filehistory.FieldHistoryTime:
		return m.HistoryTime()
	case filehistory.FieldRef:
		return m.Ref()
	case filehistory.FieldOperation:
		return m.Operation()
	case filehistory.FieldCreatedAt:
		return m.CreatedAt()
	case filehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case filehistory.FieldCreatedBy:
		return m.CreatedBy()
	case filehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case filehistory.FieldDeletedAt:
		return m.DeletedAt()
	case filehistory.FieldDeletedBy:
		return m.DeletedBy()
	case filehistory.FieldTags:
		return m.Tags()
	case filehistory.FieldSystemOwned:
		return m.SystemOwned()
	case filehistory.FieldInternalNotes:
		return m.InternalNotes()
	case filehistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case filehistory.FieldProvidedFileName:
		return m.ProvidedFileName()
	case filehistory.FieldProvidedFileExtension:
		return m.ProvidedFileExtension()
	case filehistory.FieldProvidedFileSize:
		return m.ProvidedFileSize()
	case filehistory.FieldPersistedFileSize:
		return m.PersistedFileSize()
	case filehistory.FieldDetectedMimeType:
		return m.DetectedMimeType()
	case filehistory.FieldMd5Hash:
		return m.Md5Hash()
	case filehistory.FieldDetectedContentType:
		return m.DetectedContentType()
	case filehistory.FieldStoreKey:
		return m.StoreKey()
	case filehistory.FieldCategoryType:
		return m.CategoryType()
	case filehistory.FieldURI:
		return m.URI()
	case filehistory.FieldStorageScheme:
		return m.StorageScheme()
	case filehistory.FieldStorageVolume:
		return m.StorageVolume()
	case filehistory.FieldStoragePath:
		return m.StoragePath()
	case filehistory.FieldFileContents:
		return m.FileContents()
	case filehistory.FieldMetadata:
		return m.Metadata()
	case filehistory.FieldStorageRegion:
		return m.StorageRegion()
	case filehistory.FieldStorageProvider:
		return m.StorageProvider()
	case filehistory.FieldLastAccessedAt:
		return m.LastAccessedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case filehistory.FieldRef:
		return m.OldRef(ctx)
	case filehistory.FieldOperation:
		return m.OldOperation(ctx)
	case filehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case filehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case filehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case filehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case filehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case filehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case filehistory.FieldTags:
		return m.OldTags(ctx)
	case filehistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case filehistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case filehistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case filehistory.FieldProvidedFileName:
		return m.OldProvidedFileName(ctx)
	case filehistory.FieldProvidedFileExtension:
		return m.OldProvidedFileExtension(ctx)
	case filehistory.FieldProvidedFileSize:
		return m.OldProvidedFileSize(ctx)
	case filehistory.FieldPersistedFileSize:
		return m.OldPersistedFileSize(ctx)
	case filehistory.FieldDetectedMimeType:
		return m.OldDetectedMimeType(ctx)
	case filehistory.FieldMd5Hash:
		return m.OldMd5Hash(ctx)
	case filehistory.FieldDetectedContentType:
		return m.OldDetectedContentType(ctx)
	case filehistory.FieldStoreKey:
		return m.OldStoreKey(ctx)
	case filehistory.FieldCategoryType:
		return m.OldCategoryType(ctx)
	case filehistory.FieldURI:
		return m.OldURI(ctx)
	case filehistory.FieldStorageScheme:
		return m.OldStorageScheme(ctx)
	case filehistory.FieldStorageVolume:
		return m.OldStorageVolume(ctx)
	case filehistory.FieldStoragePath:
		return m.OldStoragePath(ctx)
	case filehistory.FieldFileContents:
		return m.OldFileContents(ctx)
	case filehistory.FieldMetadata:
		return m.OldMetadata(ctx)
	case filehistory.FieldStorageRegion:
		return m.OldStorageRegion(ctx)
	case filehistory.FieldStorageProvider:
		return m.OldStorageProvider(ctx)
	case filehistory.FieldLastAccessedAt:
		return m.OldLastAccessedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FileHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case filehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case filehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case filehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case filehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case filehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case filehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case filehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case filehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case filehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case filehistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case filehistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case filehistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case filehistory.FieldProvidedFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvidedFileName(v)
		return nil
	case filehistory.FieldProvidedFileExtension:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvidedFileExtension(v)
		return nil
	case filehistory.FieldProvidedFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvidedFileSize(v)
		return nil
	case filehistory.FieldPersistedFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersistedFileSize(v)
		return nil
	case filehistory.FieldDetectedMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetectedMimeType(v)
		return nil
	case filehistory.FieldMd5Hash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMd5Hash(v)
		return nil
	case filehistory.FieldDetectedContentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetectedContentType(v)
		return nil
	case filehistory.FieldStoreKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreKey(v)
		return nil
	case filehistory.FieldCategoryType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryType(v)
		return nil
	case filehistory.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case filehistory.FieldStorageScheme:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageScheme(v)
		return nil
	case filehistory.FieldStorageVolume:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageVolume(v)
		return nil
	case filehistory.FieldStoragePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePath(v)
		return nil
	case filehistory.FieldFileContents:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileContents(v)
		return nil
	case filehistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case filehistory.FieldStorageRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageRegion(v)
		return nil
	case filehistory.FieldStorageProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageProvider(v)
		return nil
	case filehistory.FieldLastAccessedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastAccessedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FileHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addprovided_file_size != nil {
		fields = append(fields, filehistory.FieldProvidedFileSize)
	}
	if m.addpersisted_file_size != nil {
		fields = append(fields, filehistory.FieldPersistedFileSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case filehistory.FieldProvidedFileSize:
		return m.AddedProvidedFileSize()
	case filehistory.FieldPersistedFileSize:
		return m.AddedPersistedFileSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case filehistory.FieldProvidedFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProvidedFileSize(v)
		return nil
	case filehistory.FieldPersistedFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPersistedFileSize(v)
		return nil
	}
	return fmt.Errorf("unknown FileHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(filehistory.FieldRef) {
		fields = append(fields, filehistory.FieldRef)
	}
	if m.FieldCleared(filehistory.FieldCreatedAt) {
		fields = append(fields, filehistory.FieldCreatedAt)
	}
	if m.FieldCleared(filehistory.FieldUpdatedAt) {
		fields = append(fields, filehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(filehistory.FieldCreatedBy) {
		fields = append(fields, filehistory.FieldCreatedBy)
	}
	if m.FieldCleared(filehistory.FieldUpdatedBy) {
		fields = append(fields, filehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(filehistory.FieldDeletedAt) {
		fields = append(fields, filehistory.FieldDeletedAt)
	}
	if m.FieldCleared(filehistory.FieldDeletedBy) {
		fields = append(fields, filehistory.FieldDeletedBy)
	}
	if m.FieldCleared(filehistory.FieldTags) {
		fields = append(fields, filehistory.FieldTags)
	}
	if m.FieldCleared(filehistory.FieldSystemOwned) {
		fields = append(fields, filehistory.FieldSystemOwned)
	}
	if m.FieldCleared(filehistory.FieldInternalNotes) {
		fields = append(fields, filehistory.FieldInternalNotes)
	}
	if m.FieldCleared(filehistory.FieldSystemInternalID) {
		fields = append(fields, filehistory.FieldSystemInternalID)
	}
	if m.FieldCleared(filehistory.FieldProvidedFileSize) {
		fields = append(fields, filehistory.FieldProvidedFileSize)
	}
	if m.FieldCleared(filehistory.FieldPersistedFileSize) {
		fields = append(fields, filehistory.FieldPersistedFileSize)
	}
	if m.FieldCleared(filehistory.FieldDetectedMimeType) {
		fields = append(fields, filehistory.FieldDetectedMimeType)
	}
	if m.FieldCleared(filehistory.FieldMd5Hash) {
		fields = append(fields, filehistory.FieldMd5Hash)
	}
	if m.FieldCleared(filehistory.FieldStoreKey) {
		fields = append(fields, filehistory.FieldStoreKey)
	}
	if m.FieldCleared(filehistory.FieldCategoryType) {
		fields = append(fields, filehistory.FieldCategoryType)
	}
	if m.FieldCleared(filehistory.FieldURI) {
		fields = append(fields, filehistory.FieldURI)
	}
	if m.FieldCleared(filehistory.FieldStorageScheme) {
		fields = append(fields, filehistory.FieldStorageScheme)
	}
	if m.FieldCleared(filehistory.FieldStorageVolume) {
		fields = append(fields, filehistory.FieldStorageVolume)
	}
	if m.FieldCleared(filehistory.FieldStoragePath) {
		fields = append(fields, filehistory.FieldStoragePath)
	}
	if m.FieldCleared(filehistory.FieldFileContents) {
		fields = append(fields, filehistory.FieldFileContents)
	}
	if m.FieldCleared(filehistory.FieldMetadata) {
		fields = append(fields, filehistory.FieldMetadata)
	}
	if m.FieldCleared(filehistory.FieldStorageRegion) {
		fields = append(fields, filehistory.FieldStorageRegion)
	}
	if m.FieldCleared(filehistory.FieldStorageProvider) {
		fields = append(fields, filehistory.FieldStorageProvider)
	}
	if m.FieldCleared(filehistory.FieldLastAccessedAt) {
		fields = append(fields, filehistory.FieldLastAccessedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileHistoryMutation) ClearField(name string) error {
	switch name {
	case filehistory.FieldRef:
		m.ClearRef()
		return nil
	case filehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case filehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case filehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case filehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case filehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case filehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case filehistory.FieldTags:
		m.ClearTags()
		return nil
	case filehistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case filehistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case filehistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case filehistory.FieldProvidedFileSize:
		m.ClearProvidedFileSize()
		return nil
	case filehistory.FieldPersistedFileSize:
		m.ClearPersistedFileSize()
		return nil
	case filehistory.FieldDetectedMimeType:
		m.ClearDetectedMimeType()
		return nil
	case filehistory.FieldMd5Hash:
		m.ClearMd5Hash()
		return nil
	case filehistory.FieldStoreKey:
		m.ClearStoreKey()
		return nil
	case filehistory.FieldCategoryType:
		m.ClearCategoryType()
		return nil
	case filehistory.FieldURI:
		m.ClearURI()
		return nil
	case filehistory.FieldStorageScheme:
		m.ClearStorageScheme()
		return nil
	case filehistory.FieldStorageVolume:
		m.ClearStorageVolume()
		return nil
	case filehistory.FieldStoragePath:
		m.ClearStoragePath()
		return nil
	case filehistory.FieldFileContents:
		m.ClearFileContents()
		return nil
	case filehistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	case filehistory.FieldStorageRegion:
		m.ClearStorageRegion()
		return nil
	case filehistory.FieldStorageProvider:
		m.ClearStorageProvider()
		return nil
	case filehistory.FieldLastAccessedAt:
		m.ClearLastAccessedAt()
		return nil
	}
	return fmt.Errorf("unknown FileHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileHistoryMutation) ResetField(name string) error {
	switch name {
	case filehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case filehistory.FieldRef:
		m.ResetRef()
		return nil
	case filehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case filehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case filehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case filehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case filehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case filehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case filehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case filehistory.FieldTags:
		m.ResetTags()
		return nil
	case filehistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case filehistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case filehistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case filehistory.FieldProvidedFileName:
		m.ResetProvidedFileName()
		return nil
	case filehistory.FieldProvidedFileExtension:
		m.ResetProvidedFileExtension()
		return nil
	case filehistory.FieldProvidedFileSize:
		m.ResetProvidedFileSize()
		return nil
	case filehistory.FieldPersistedFileSize:
		m.ResetPersistedFileSize()
		return nil
	case filehistory.FieldDetectedMimeType:
		m.ResetDetectedMimeType()
		return nil
	case filehistory.FieldMd5Hash:
		m.ResetMd5Hash()
		return nil
	case filehistory.FieldDetectedContentType:
		m.ResetDetectedContentType()
		return nil
	case filehistory.FieldStoreKey:
		m.ResetStoreKey()
		return nil
	case filehistory.FieldCategoryType:
		m.ResetCategoryType()
		return nil
	case filehistory.FieldURI:
		m.ResetURI()
		return nil
	case filehistory.FieldStorageScheme:
		m.ResetStorageScheme()
		return nil
	case filehistory.FieldStorageVolume:
		m.ResetStorageVolume()
		return nil
	case filehistory.FieldStoragePath:
		m.ResetStoragePath()
		return nil
	case filehistory.FieldFileContents:
		m.ResetFileContents()
		return nil
	case filehistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	case filehistory.FieldStorageRegion:
		m.ResetStorageRegion()
		return nil
	case filehistory.FieldStorageProvider:
		m.ResetStorageProvider()
		return nil
	case filehistory.FieldLastAccessedAt:
		m.ResetLastAccessedAt()
		return nil
	}
	return fmt.Errorf("unknown FileHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FileHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FileHistory edge %s", name)
}

// FindingControlHistoryMutation represents an operation that mutates the FindingControlHistory nodes in the graph.
type FindingControlHistoryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	history_time              *time.Time
	ref                       *string
	operation                 *history.OpType
	created_at                *time.Time
	updated_at                *time.Time
	created_by                *string
	updated_by                *string
	finding_id                *string
	control_id                *string
	standard_id               *string
	external_standard         *string
	external_standard_version *string
	external_control_id       *string
	source                    *string
	metadata                  *map[string]interface{}
	discovered_at             *models.DateTime
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*FindingControlHistory, error)
	predicates                []predicate.FindingControlHistory
}

var _ ent.Mutation = (*FindingControlHistoryMutation)(nil)

// findingcontrolhistoryOption allows management of the mutation configuration using functional options.
type findingcontrolhistoryOption func(*FindingControlHistoryMutation)

// newFindingControlHistoryMutation creates new mutation for the FindingControlHistory entity.
func newFindingControlHistoryMutation(c config, op Op, opts ...findingcontrolhistoryOption) *FindingControlHistoryMutation {
	m := &FindingControlHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeFindingControlHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFindingControlHistoryID sets the ID field of the mutation.
func withFindingControlHistoryID(id string) findingcontrolhistoryOption {
	return func(m *FindingControlHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *FindingControlHistory
		)
		m.oldValue = func(ctx context.Context) (*FindingControlHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FindingControlHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFindingControlHistory sets the old FindingControlHistory of the mutation.
func withFindingControlHistory(node *FindingControlHistory) findingcontrolhistoryOption {
	return func(m *FindingControlHistoryMutation) {
		m.oldValue = func(context.Context) (*FindingControlHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FindingControlHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FindingControlHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FindingControlHistory entities.
func (m *FindingControlHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FindingControlHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FindingControlHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FindingControlHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *FindingControlHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *FindingControlHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *FindingControlHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *FindingControlHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *FindingControlHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *FindingControlHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[findingcontrolhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *FindingControlHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[findingcontrolhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *FindingControlHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, findingcontrolhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *FindingControlHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *FindingControlHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *FindingControlHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FindingControlHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FindingControlHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *FindingControlHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[findingcontrolhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *FindingControlHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[findingcontrolhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FindingControlHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, findingcontrolhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FindingControlHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FindingControlHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *FindingControlHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[findingcontrolhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *FindingControlHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[findingcontrolhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FindingControlHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, findingcontrolhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *FindingControlHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FindingControlHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *FindingControlHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[findingcontrolhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *FindingControlHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[findingcontrolhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FindingControlHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, findingcontrolhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FindingControlHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FindingControlHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *FindingControlHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[findingcontrolhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *FindingControlHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[findingcontrolhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FindingControlHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, findingcontrolhistory.FieldUpdatedBy)
}

// SetFindingID sets the "finding_id" field.
func (m *FindingControlHistoryMutation) SetFindingID(s string) {
	m.finding_id = &s
}

// FindingID returns the value of the "finding_id" field in the mutation.
func (m *FindingControlHistoryMutation) FindingID() (r string, exists bool) {
	v := m.finding_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFindingID returns the old "finding_id" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldFindingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFindingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFindingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFindingID: %w", err)
	}
	return oldValue.FindingID, nil
}

// ResetFindingID resets all changes to the "finding_id" field.
func (m *FindingControlHistoryMutation) ResetFindingID() {
	m.finding_id = nil
}

// SetControlID sets the "control_id" field.
func (m *FindingControlHistoryMutation) SetControlID(s string) {
	m.control_id = &s
}

// ControlID returns the value of the "control_id" field in the mutation.
func (m *FindingControlHistoryMutation) ControlID() (r string, exists bool) {
	v := m.control_id
	if v == nil {
		return
	}
	return *v, true
}

// OldControlID returns the old "control_id" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldControlID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlID: %w", err)
	}
	return oldValue.ControlID, nil
}

// ResetControlID resets all changes to the "control_id" field.
func (m *FindingControlHistoryMutation) ResetControlID() {
	m.control_id = nil
}

// SetStandardID sets the "standard_id" field.
func (m *FindingControlHistoryMutation) SetStandardID(s string) {
	m.standard_id = &s
}

// StandardID returns the value of the "standard_id" field in the mutation.
func (m *FindingControlHistoryMutation) StandardID() (r string, exists bool) {
	v := m.standard_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStandardID returns the old "standard_id" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldStandardID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStandardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStandardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStandardID: %w", err)
	}
	return oldValue.StandardID, nil
}

// ClearStandardID clears the value of the "standard_id" field.
func (m *FindingControlHistoryMutation) ClearStandardID() {
	m.standard_id = nil
	m.clearedFields[findingcontrolhistory.FieldStandardID] = struct{}{}
}

// StandardIDCleared returns if the "standard_id" field was cleared in this mutation.
func (m *FindingControlHistoryMutation) StandardIDCleared() bool {
	_, ok := m.clearedFields[findingcontrolhistory.FieldStandardID]
	return ok
}

// ResetStandardID resets all changes to the "standard_id" field.
func (m *FindingControlHistoryMutation) ResetStandardID() {
	m.standard_id = nil
	delete(m.clearedFields, findingcontrolhistory.FieldStandardID)
}

// SetExternalStandard sets the "external_standard" field.
func (m *FindingControlHistoryMutation) SetExternalStandard(s string) {
	m.external_standard = &s
}

// ExternalStandard returns the value of the "external_standard" field in the mutation.
func (m *FindingControlHistoryMutation) ExternalStandard() (r string, exists bool) {
	v := m.external_standard
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalStandard returns the old "external_standard" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldExternalStandard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalStandard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalStandard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalStandard: %w", err)
	}
	return oldValue.ExternalStandard, nil
}

// ClearExternalStandard clears the value of the "external_standard" field.
func (m *FindingControlHistoryMutation) ClearExternalStandard() {
	m.external_standard = nil
	m.clearedFields[findingcontrolhistory.FieldExternalStandard] = struct{}{}
}

// ExternalStandardCleared returns if the "external_standard" field was cleared in this mutation.
func (m *FindingControlHistoryMutation) ExternalStandardCleared() bool {
	_, ok := m.clearedFields[findingcontrolhistory.FieldExternalStandard]
	return ok
}

// ResetExternalStandard resets all changes to the "external_standard" field.
func (m *FindingControlHistoryMutation) ResetExternalStandard() {
	m.external_standard = nil
	delete(m.clearedFields, findingcontrolhistory.FieldExternalStandard)
}

// SetExternalStandardVersion sets the "external_standard_version" field.
func (m *FindingControlHistoryMutation) SetExternalStandardVersion(s string) {
	m.external_standard_version = &s
}

// ExternalStandardVersion returns the value of the "external_standard_version" field in the mutation.
func (m *FindingControlHistoryMutation) ExternalStandardVersion() (r string, exists bool) {
	v := m.external_standard_version
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalStandardVersion returns the old "external_standard_version" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldExternalStandardVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalStandardVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalStandardVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalStandardVersion: %w", err)
	}
	return oldValue.ExternalStandardVersion, nil
}

// ClearExternalStandardVersion clears the value of the "external_standard_version" field.
func (m *FindingControlHistoryMutation) ClearExternalStandardVersion() {
	m.external_standard_version = nil
	m.clearedFields[findingcontrolhistory.FieldExternalStandardVersion] = struct{}{}
}

// ExternalStandardVersionCleared returns if the "external_standard_version" field was cleared in this mutation.
func (m *FindingControlHistoryMutation) ExternalStandardVersionCleared() bool {
	_, ok := m.clearedFields[findingcontrolhistory.FieldExternalStandardVersion]
	return ok
}

// ResetExternalStandardVersion resets all changes to the "external_standard_version" field.
func (m *FindingControlHistoryMutation) ResetExternalStandardVersion() {
	m.external_standard_version = nil
	delete(m.clearedFields, findingcontrolhistory.FieldExternalStandardVersion)
}

// SetExternalControlID sets the "external_control_id" field.
func (m *FindingControlHistoryMutation) SetExternalControlID(s string) {
	m.external_control_id = &s
}

// ExternalControlID returns the value of the "external_control_id" field in the mutation.
func (m *FindingControlHistoryMutation) ExternalControlID() (r string, exists bool) {
	v := m.external_control_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalControlID returns the old "external_control_id" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldExternalControlID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalControlID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalControlID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalControlID: %w", err)
	}
	return oldValue.ExternalControlID, nil
}

// ClearExternalControlID clears the value of the "external_control_id" field.
func (m *FindingControlHistoryMutation) ClearExternalControlID() {
	m.external_control_id = nil
	m.clearedFields[findingcontrolhistory.FieldExternalControlID] = struct{}{}
}

// ExternalControlIDCleared returns if the "external_control_id" field was cleared in this mutation.
func (m *FindingControlHistoryMutation) ExternalControlIDCleared() bool {
	_, ok := m.clearedFields[findingcontrolhistory.FieldExternalControlID]
	return ok
}

// ResetExternalControlID resets all changes to the "external_control_id" field.
func (m *FindingControlHistoryMutation) ResetExternalControlID() {
	m.external_control_id = nil
	delete(m.clearedFields, findingcontrolhistory.FieldExternalControlID)
}

// SetSource sets the "source" field.
func (m *FindingControlHistoryMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *FindingControlHistoryMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *FindingControlHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[findingcontrolhistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *FindingControlHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[findingcontrolhistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *FindingControlHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, findingcontrolhistory.FieldSource)
}

// SetMetadata sets the "metadata" field.
func (m *FindingControlHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *FindingControlHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *FindingControlHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[findingcontrolhistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *FindingControlHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[findingcontrolhistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *FindingControlHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, findingcontrolhistory.FieldMetadata)
}

// SetDiscoveredAt sets the "discovered_at" field.
func (m *FindingControlHistoryMutation) SetDiscoveredAt(mt models.DateTime) {
	m.discovered_at = &mt
}

// DiscoveredAt returns the value of the "discovered_at" field in the mutation.
func (m *FindingControlHistoryMutation) DiscoveredAt() (r models.DateTime, exists bool) {
	v := m.discovered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveredAt returns the old "discovered_at" field's value of the FindingControlHistory entity.
// If the FindingControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingControlHistoryMutation) OldDiscoveredAt(ctx context.Context) (v *models.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveredAt: %w", err)
	}
	return oldValue.DiscoveredAt, nil
}

// ClearDiscoveredAt clears the value of the "discovered_at" field.
func (m *FindingControlHistoryMutation) ClearDiscoveredAt() {
	m.discovered_at = nil
	m.clearedFields[findingcontrolhistory.FieldDiscoveredAt] = struct{}{}
}

// DiscoveredAtCleared returns if the "discovered_at" field was cleared in this mutation.
func (m *FindingControlHistoryMutation) DiscoveredAtCleared() bool {
	_, ok := m.clearedFields[findingcontrolhistory.FieldDiscoveredAt]
	return ok
}

// ResetDiscoveredAt resets all changes to the "discovered_at" field.
func (m *FindingControlHistoryMutation) ResetDiscoveredAt() {
	m.discovered_at = nil
	delete(m.clearedFields, findingcontrolhistory.FieldDiscoveredAt)
}

// Where appends a list predicates to the FindingControlHistoryMutation builder.
func (m *FindingControlHistoryMutation) Where(ps ...predicate.FindingControlHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FindingControlHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FindingControlHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FindingControlHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FindingControlHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FindingControlHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FindingControlHistory).
func (m *FindingControlHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FindingControlHistoryMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.history_time != nil {
		fields = append(fields, findingcontrolhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, findingcontrolhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, findingcontrolhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, findingcontrolhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, findingcontrolhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, findingcontrolhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, findingcontrolhistory.FieldUpdatedBy)
	}
	if m.finding_id != nil {
		fields = append(fields, findingcontrolhistory.FieldFindingID)
	}
	if m.control_id != nil {
		fields = append(fields, findingcontrolhistory.FieldControlID)
	}
	if m.standard_id != nil {
		fields = append(fields, findingcontrolhistory.FieldStandardID)
	}
	if m.external_standard != nil {
		fields = append(fields, findingcontrolhistory.FieldExternalStandard)
	}
	if m.external_standard_version != nil {
		fields = append(fields, findingcontrolhistory.FieldExternalStandardVersion)
	}
	if m.external_control_id != nil {
		fields = append(fields, findingcontrolhistory.FieldExternalControlID)
	}
	if m.source != nil {
		fields = append(fields, findingcontrolhistory.FieldSource)
	}
	if m.metadata != nil {
		fields = append(fields, findingcontrolhistory.FieldMetadata)
	}
	if m.discovered_at != nil {
		fields = append(fields, findingcontrolhistory.FieldDiscoveredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FindingControlHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case findingcontrolhistory.FieldHistoryTime:
		return m.HistoryTime()
	case findingcontrolhistory.FieldRef:
		return m.Ref()
	case findingcontrolhistory.FieldOperation:
		return m.Operation()
	case findingcontrolhistory.FieldCreatedAt:
		return m.CreatedAt()
	case findingcontrolhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case findingcontrolhistory.FieldCreatedBy:
		return m.CreatedBy()
	case findingcontrolhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case findingcontrolhistory.FieldFindingID:
		return m.FindingID()
	case findingcontrolhistory.FieldControlID:
		return m.ControlID()
	case findingcontrolhistory.FieldStandardID:
		return m.StandardID()
	case findingcontrolhistory.FieldExternalStandard:
		return m.ExternalStandard()
	case findingcontrolhistory.FieldExternalStandardVersion:
		return m.ExternalStandardVersion()
	case findingcontrolhistory.FieldExternalControlID:
		return m.ExternalControlID()
	case findingcontrolhistory.FieldSource:
		return m.Source()
	case findingcontrolhistory.FieldMetadata:
		return m.Metadata()
	case findingcontrolhistory.FieldDiscoveredAt:
		return m.DiscoveredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FindingControlHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case findingcontrolhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case findingcontrolhistory.FieldRef:
		return m.OldRef(ctx)
	case findingcontrolhistory.FieldOperation:
		return m.OldOperation(ctx)
	case findingcontrolhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case findingcontrolhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case findingcontrolhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case findingcontrolhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case findingcontrolhistory.FieldFindingID:
		return m.OldFindingID(ctx)
	case findingcontrolhistory.FieldControlID:
		return m.OldControlID(ctx)
	case findingcontrolhistory.FieldStandardID:
		return m.OldStandardID(ctx)
	case findingcontrolhistory.FieldExternalStandard:
		return m.OldExternalStandard(ctx)
	case findingcontrolhistory.FieldExternalStandardVersion:
		return m.OldExternalStandardVersion(ctx)
	case findingcontrolhistory.FieldExternalControlID:
		return m.OldExternalControlID(ctx)
	case findingcontrolhistory.FieldSource:
		return m.OldSource(ctx)
	case findingcontrolhistory.FieldMetadata:
		return m.OldMetadata(ctx)
	case findingcontrolhistory.FieldDiscoveredAt:
		return m.OldDiscoveredAt(ctx)
	}
	return nil, fmt.Errorf("unknown FindingControlHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FindingControlHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case findingcontrolhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case findingcontrolhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case findingcontrolhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case findingcontrolhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case findingcontrolhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case findingcontrolhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case findingcontrolhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case findingcontrolhistory.FieldFindingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFindingID(v)
		return nil
	case findingcontrolhistory.FieldControlID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlID(v)
		return nil
	case findingcontrolhistory.FieldStandardID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStandardID(v)
		return nil
	case findingcontrolhistory.FieldExternalStandard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalStandard(v)
		return nil
	case findingcontrolhistory.FieldExternalStandardVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalStandardVersion(v)
		return nil
	case findingcontrolhistory.FieldExternalControlID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalControlID(v)
		return nil
	case findingcontrolhistory.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case findingcontrolhistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case findingcontrolhistory.FieldDiscoveredAt:
		v, ok := value.(models.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveredAt(v)
		return nil
	}
	return fmt.Errorf("unknown FindingControlHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FindingControlHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FindingControlHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FindingControlHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FindingControlHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FindingControlHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(findingcontrolhistory.FieldRef) {
		fields = append(fields, findingcontrolhistory.FieldRef)
	}
	if m.FieldCleared(findingcontrolhistory.FieldCreatedAt) {
		fields = append(fields, findingcontrolhistory.FieldCreatedAt)
	}
	if m.FieldCleared(findingcontrolhistory.FieldUpdatedAt) {
		fields = append(fields, findingcontrolhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(findingcontrolhistory.FieldCreatedBy) {
		fields = append(fields, findingcontrolhistory.FieldCreatedBy)
	}
	if m.FieldCleared(findingcontrolhistory.FieldUpdatedBy) {
		fields = append(fields, findingcontrolhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(findingcontrolhistory.FieldStandardID) {
		fields = append(fields, findingcontrolhistory.FieldStandardID)
	}
	if m.FieldCleared(findingcontrolhistory.FieldExternalStandard) {
		fields = append(fields, findingcontrolhistory.FieldExternalStandard)
	}
	if m.FieldCleared(findingcontrolhistory.FieldExternalStandardVersion) {
		fields = append(fields, findingcontrolhistory.FieldExternalStandardVersion)
	}
	if m.FieldCleared(findingcontrolhistory.FieldExternalControlID) {
		fields = append(fields, findingcontrolhistory.FieldExternalControlID)
	}
	if m.FieldCleared(findingcontrolhistory.FieldSource) {
		fields = append(fields, findingcontrolhistory.FieldSource)
	}
	if m.FieldCleared(findingcontrolhistory.FieldMetadata) {
		fields = append(fields, findingcontrolhistory.FieldMetadata)
	}
	if m.FieldCleared(findingcontrolhistory.FieldDiscoveredAt) {
		fields = append(fields, findingcontrolhistory.FieldDiscoveredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FindingControlHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FindingControlHistoryMutation) ClearField(name string) error {
	switch name {
	case findingcontrolhistory.FieldRef:
		m.ClearRef()
		return nil
	case findingcontrolhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case findingcontrolhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case findingcontrolhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case findingcontrolhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case findingcontrolhistory.FieldStandardID:
		m.ClearStandardID()
		return nil
	case findingcontrolhistory.FieldExternalStandard:
		m.ClearExternalStandard()
		return nil
	case findingcontrolhistory.FieldExternalStandardVersion:
		m.ClearExternalStandardVersion()
		return nil
	case findingcontrolhistory.FieldExternalControlID:
		m.ClearExternalControlID()
		return nil
	case findingcontrolhistory.FieldSource:
		m.ClearSource()
		return nil
	case findingcontrolhistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	case findingcontrolhistory.FieldDiscoveredAt:
		m.ClearDiscoveredAt()
		return nil
	}
	return fmt.Errorf("unknown FindingControlHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FindingControlHistoryMutation) ResetField(name string) error {
	switch name {
	case findingcontrolhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case findingcontrolhistory.FieldRef:
		m.ResetRef()
		return nil
	case findingcontrolhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case findingcontrolhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case findingcontrolhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case findingcontrolhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case findingcontrolhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case findingcontrolhistory.FieldFindingID:
		m.ResetFindingID()
		return nil
	case findingcontrolhistory.FieldControlID:
		m.ResetControlID()
		return nil
	case findingcontrolhistory.FieldStandardID:
		m.ResetStandardID()
		return nil
	case findingcontrolhistory.FieldExternalStandard:
		m.ResetExternalStandard()
		return nil
	case findingcontrolhistory.FieldExternalStandardVersion:
		m.ResetExternalStandardVersion()
		return nil
	case findingcontrolhistory.FieldExternalControlID:
		m.ResetExternalControlID()
		return nil
	case findingcontrolhistory.FieldSource:
		m.ResetSource()
		return nil
	case findingcontrolhistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	case findingcontrolhistory.FieldDiscoveredAt:
		m.ResetDiscoveredAt()
		return nil
	}
	return fmt.Errorf("unknown FindingControlHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FindingControlHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FindingControlHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FindingControlHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FindingControlHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FindingControlHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FindingControlHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FindingControlHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FindingControlHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FindingControlHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FindingControlHistory edge %s", name)
}

// FindingHistoryMutation represents an operation that mutates the FindingHistory nodes in the graph.
type FindingHistoryMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	history_time             *time.Time
	ref                      *string
	operation                *history.OpType
	created_at               *time.Time
	updated_at               *time.Time
	created_by               *string
	updated_by               *string
	deleted_at               *time.Time
	deleted_by               *string
	display_id               *string
	tags                     *[]string
	appendtags               []string
	owner_id                 *string
	system_owned             *bool
	internal_notes           *string
	system_internal_id       *string
	external_id              *string
	external_owner_id        *string
	source                   *string
	resource_name            *string
	display_name             *string
	state                    *string
	category                 *string
	categories               *[]string
	appendcategories         []string
	finding_class            *string
	severity                 *string
	numeric_severity         *float64
	addnumeric_severity      *float64
	score                    *float64
	addscore                 *float64
	impact                   *float64
	addimpact                *float64
	exploitability           *float64
	addexploitability        *float64
	priority                 *string
	open                     *bool
	blocks_production        *bool
	production               *bool
	public                   *bool
	validated                *bool
	assessment_id            *string
	description              *string
	recommendation           *string
	recommended_actions      *string
	references               *[]string
	appendreferences         []string
	steps_to_reproduce       *[]string
	appendsteps_to_reproduce []string
	targets                  *[]string
	appendtargets            []string
	target_details           *map[string]interface{}
	vector                   *string
	remediation_sla          *int
	addremediation_sla       *int
	status                   *string
	event_time               *models.DateTime
	reported_at              *models.DateTime
	source_updated_at        *models.DateTime
	external_uri             *string
	metadata                 *map[string]interface{}
	raw_payload              *map[string]interface{}
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*FindingHistory, error)
	predicates               []predicate.FindingHistory
}

var _ ent.Mutation = (*FindingHistoryMutation)(nil)

// findinghistoryOption allows management of the mutation configuration using functional options.
type findinghistoryOption func(*FindingHistoryMutation)

// newFindingHistoryMutation creates new mutation for the FindingHistory entity.
func newFindingHistoryMutation(c config, op Op, opts ...findinghistoryOption) *FindingHistoryMutation {
	m := &FindingHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeFindingHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFindingHistoryID sets the ID field of the mutation.
func withFindingHistoryID(id string) findinghistoryOption {
	return func(m *FindingHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *FindingHistory
		)
		m.oldValue = func(ctx context.Context) (*FindingHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FindingHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFindingHistory sets the old FindingHistory of the mutation.
func withFindingHistory(node *FindingHistory) findinghistoryOption {
	return func(m *FindingHistoryMutation) {
		m.oldValue = func(context.Context) (*FindingHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FindingHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FindingHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FindingHistory entities.
func (m *FindingHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FindingHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FindingHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FindingHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *FindingHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *FindingHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *FindingHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *FindingHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *FindingHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *FindingHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[findinghistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *FindingHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *FindingHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, findinghistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *FindingHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *FindingHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *FindingHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FindingHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FindingHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *FindingHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[findinghistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *FindingHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FindingHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, findinghistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FindingHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FindingHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *FindingHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[findinghistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *FindingHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FindingHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, findinghistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *FindingHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FindingHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *FindingHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[findinghistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *FindingHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FindingHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, findinghistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FindingHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FindingHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *FindingHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[findinghistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *FindingHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FindingHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, findinghistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FindingHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FindingHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FindingHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[findinghistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FindingHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FindingHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, findinghistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FindingHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FindingHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *FindingHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[findinghistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *FindingHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FindingHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, findinghistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *FindingHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *FindingHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *FindingHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *FindingHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FindingHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *FindingHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *FindingHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *FindingHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[findinghistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *FindingHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *FindingHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, findinghistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *FindingHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *FindingHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *FindingHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[findinghistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *FindingHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *FindingHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, findinghistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *FindingHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *FindingHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *FindingHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[findinghistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *FindingHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *FindingHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, findinghistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *FindingHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *FindingHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *FindingHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[findinghistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *FindingHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *FindingHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, findinghistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *FindingHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *FindingHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *FindingHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[findinghistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *FindingHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *FindingHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, findinghistory.FieldSystemInternalID)
}

// SetExternalID sets the "external_id" field.
func (m *FindingHistoryMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *FindingHistoryMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *FindingHistoryMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[findinghistory.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *FindingHistoryMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *FindingHistoryMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, findinghistory.FieldExternalID)
}

// SetExternalOwnerID sets the "external_owner_id" field.
func (m *FindingHistoryMutation) SetExternalOwnerID(s string) {
	m.external_owner_id = &s
}

// ExternalOwnerID returns the value of the "external_owner_id" field in the mutation.
func (m *FindingHistoryMutation) ExternalOwnerID() (r string, exists bool) {
	v := m.external_owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalOwnerID returns the old "external_owner_id" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldExternalOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalOwnerID: %w", err)
	}
	return oldValue.ExternalOwnerID, nil
}

// ClearExternalOwnerID clears the value of the "external_owner_id" field.
func (m *FindingHistoryMutation) ClearExternalOwnerID() {
	m.external_owner_id = nil
	m.clearedFields[findinghistory.FieldExternalOwnerID] = struct{}{}
}

// ExternalOwnerIDCleared returns if the "external_owner_id" field was cleared in this mutation.
func (m *FindingHistoryMutation) ExternalOwnerIDCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldExternalOwnerID]
	return ok
}

// ResetExternalOwnerID resets all changes to the "external_owner_id" field.
func (m *FindingHistoryMutation) ResetExternalOwnerID() {
	m.external_owner_id = nil
	delete(m.clearedFields, findinghistory.FieldExternalOwnerID)
}

// SetSource sets the "source" field.
func (m *FindingHistoryMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *FindingHistoryMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *FindingHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[findinghistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *FindingHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *FindingHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, findinghistory.FieldSource)
}

// SetResourceName sets the "resource_name" field.
func (m *FindingHistoryMutation) SetResourceName(s string) {
	m.resource_name = &s
}

// ResourceName returns the value of the "resource_name" field in the mutation.
func (m *FindingHistoryMutation) ResourceName() (r string, exists bool) {
	v := m.resource_name
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceName returns the old "resource_name" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldResourceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceName: %w", err)
	}
	return oldValue.ResourceName, nil
}

// ClearResourceName clears the value of the "resource_name" field.
func (m *FindingHistoryMutation) ClearResourceName() {
	m.resource_name = nil
	m.clearedFields[findinghistory.FieldResourceName] = struct{}{}
}

// ResourceNameCleared returns if the "resource_name" field was cleared in this mutation.
func (m *FindingHistoryMutation) ResourceNameCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldResourceName]
	return ok
}

// ResetResourceName resets all changes to the "resource_name" field.
func (m *FindingHistoryMutation) ResetResourceName() {
	m.resource_name = nil
	delete(m.clearedFields, findinghistory.FieldResourceName)
}

// SetDisplayName sets the "display_name" field.
func (m *FindingHistoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *FindingHistoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *FindingHistoryMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[findinghistory.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *FindingHistoryMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *FindingHistoryMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, findinghistory.FieldDisplayName)
}

// SetState sets the "state" field.
func (m *FindingHistoryMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *FindingHistoryMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *FindingHistoryMutation) ClearState() {
	m.state = nil
	m.clearedFields[findinghistory.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *FindingHistoryMutation) StateCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *FindingHistoryMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, findinghistory.FieldState)
}

// SetCategory sets the "category" field.
func (m *FindingHistoryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *FindingHistoryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *FindingHistoryMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[findinghistory.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *FindingHistoryMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *FindingHistoryMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, findinghistory.FieldCategory)
}

// SetCategories sets the "categories" field.
func (m *FindingHistoryMutation) SetCategories(s []string) {
	m.categories = &s
	m.appendcategories = nil
}

// Categories returns the value of the "categories" field in the mutation.
func (m *FindingHistoryMutation) Categories() (r []string, exists bool) {
	v := m.categories
	if v == nil {
		return
	}
	return *v, true
}

// OldCategories returns the old "categories" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldCategories(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategories: %w", err)
	}
	return oldValue.Categories, nil
}

// AppendCategories adds s to the "categories" field.
func (m *FindingHistoryMutation) AppendCategories(s []string) {
	m.appendcategories = append(m.appendcategories, s...)
}

// AppendedCategories returns the list of values that were appended to the "categories" field in this mutation.
func (m *FindingHistoryMutation) AppendedCategories() ([]string, bool) {
	if len(m.appendcategories) == 0 {
		return nil, false
	}
	return m.appendcategories, true
}

// ClearCategories clears the value of the "categories" field.
func (m *FindingHistoryMutation) ClearCategories() {
	m.categories = nil
	m.appendcategories = nil
	m.clearedFields[findinghistory.FieldCategories] = struct{}{}
}

// CategoriesCleared returns if the "categories" field was cleared in this mutation.
func (m *FindingHistoryMutation) CategoriesCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldCategories]
	return ok
}

// ResetCategories resets all changes to the "categories" field.
func (m *FindingHistoryMutation) ResetCategories() {
	m.categories = nil
	m.appendcategories = nil
	delete(m.clearedFields, findinghistory.FieldCategories)
}

// SetFindingClass sets the "finding_class" field.
func (m *FindingHistoryMutation) SetFindingClass(s string) {
	m.finding_class = &s
}

// FindingClass returns the value of the "finding_class" field in the mutation.
func (m *FindingHistoryMutation) FindingClass() (r string, exists bool) {
	v := m.finding_class
	if v == nil {
		return
	}
	return *v, true
}

// OldFindingClass returns the old "finding_class" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldFindingClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFindingClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFindingClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFindingClass: %w", err)
	}
	return oldValue.FindingClass, nil
}

// ClearFindingClass clears the value of the "finding_class" field.
func (m *FindingHistoryMutation) ClearFindingClass() {
	m.finding_class = nil
	m.clearedFields[findinghistory.FieldFindingClass] = struct{}{}
}

// FindingClassCleared returns if the "finding_class" field was cleared in this mutation.
func (m *FindingHistoryMutation) FindingClassCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldFindingClass]
	return ok
}

// ResetFindingClass resets all changes to the "finding_class" field.
func (m *FindingHistoryMutation) ResetFindingClass() {
	m.finding_class = nil
	delete(m.clearedFields, findinghistory.FieldFindingClass)
}

// SetSeverity sets the "severity" field.
func (m *FindingHistoryMutation) SetSeverity(s string) {
	m.severity = &s
}

// Severity returns the value of the "severity" field in the mutation.
func (m *FindingHistoryMutation) Severity() (r string, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldSeverity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ClearSeverity clears the value of the "severity" field.
func (m *FindingHistoryMutation) ClearSeverity() {
	m.severity = nil
	m.clearedFields[findinghistory.FieldSeverity] = struct{}{}
}

// SeverityCleared returns if the "severity" field was cleared in this mutation.
func (m *FindingHistoryMutation) SeverityCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldSeverity]
	return ok
}

// ResetSeverity resets all changes to the "severity" field.
func (m *FindingHistoryMutation) ResetSeverity() {
	m.severity = nil
	delete(m.clearedFields, findinghistory.FieldSeverity)
}

// SetNumericSeverity sets the "numeric_severity" field.
func (m *FindingHistoryMutation) SetNumericSeverity(f float64) {
	m.numeric_severity = &f
	m.addnumeric_severity = nil
}

// NumericSeverity returns the value of the "numeric_severity" field in the mutation.
func (m *FindingHistoryMutation) NumericSeverity() (r float64, exists bool) {
	v := m.numeric_severity
	if v == nil {
		return
	}
	return *v, true
}

// OldNumericSeverity returns the old "numeric_severity" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldNumericSeverity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumericSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumericSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumericSeverity: %w", err)
	}
	return oldValue.NumericSeverity, nil
}

// AddNumericSeverity adds f to the "numeric_severity" field.
func (m *FindingHistoryMutation) AddNumericSeverity(f float64) {
	if m.addnumeric_severity != nil {
		*m.addnumeric_severity += f
	} else {
		m.addnumeric_severity = &f
	}
}

// AddedNumericSeverity returns the value that was added to the "numeric_severity" field in this mutation.
func (m *FindingHistoryMutation) AddedNumericSeverity() (r float64, exists bool) {
	v := m.addnumeric_severity
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumericSeverity clears the value of the "numeric_severity" field.
func (m *FindingHistoryMutation) ClearNumericSeverity() {
	m.numeric_severity = nil
	m.addnumeric_severity = nil
	m.clearedFields[findinghistory.FieldNumericSeverity] = struct{}{}
}

// NumericSeverityCleared returns if the "numeric_severity" field was cleared in this mutation.
func (m *FindingHistoryMutation) NumericSeverityCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldNumericSeverity]
	return ok
}

// ResetNumericSeverity resets all changes to the "numeric_severity" field.
func (m *FindingHistoryMutation) ResetNumericSeverity() {
	m.numeric_severity = nil
	m.addnumeric_severity = nil
	delete(m.clearedFields, findinghistory.FieldNumericSeverity)
}

// SetScore sets the "score" field.
func (m *FindingHistoryMutation) SetScore(f float64) {
	m.score = &f
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *FindingHistoryMutation) Score() (r float64, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds f to the "score" field.
func (m *FindingHistoryMutation) AddScore(f float64) {
	if m.addscore != nil {
		*m.addscore += f
	} else {
		m.addscore = &f
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *FindingHistoryMutation) AddedScore() (r float64, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *FindingHistoryMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[findinghistory.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *FindingHistoryMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *FindingHistoryMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, findinghistory.FieldScore)
}

// SetImpact sets the "impact" field.
func (m *FindingHistoryMutation) SetImpact(f float64) {
	m.impact = &f
	m.addimpact = nil
}

// Impact returns the value of the "impact" field in the mutation.
func (m *FindingHistoryMutation) Impact() (r float64, exists bool) {
	v := m.impact
	if v == nil {
		return
	}
	return *v, true
}

// OldImpact returns the old "impact" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldImpact(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpact: %w", err)
	}
	return oldValue.Impact, nil
}

// AddImpact adds f to the "impact" field.
func (m *FindingHistoryMutation) AddImpact(f float64) {
	if m.addimpact != nil {
		*m.addimpact += f
	} else {
		m.addimpact = &f
	}
}

// AddedImpact returns the value that was added to the "impact" field in this mutation.
func (m *FindingHistoryMutation) AddedImpact() (r float64, exists bool) {
	v := m.addimpact
	if v == nil {
		return
	}
	return *v, true
}

// ClearImpact clears the value of the "impact" field.
func (m *FindingHistoryMutation) ClearImpact() {
	m.impact = nil
	m.addimpact = nil
	m.clearedFields[findinghistory.FieldImpact] = struct{}{}
}

// ImpactCleared returns if the "impact" field was cleared in this mutation.
func (m *FindingHistoryMutation) ImpactCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldImpact]
	return ok
}

// ResetImpact resets all changes to the "impact" field.
func (m *FindingHistoryMutation) ResetImpact() {
	m.impact = nil
	m.addimpact = nil
	delete(m.clearedFields, findinghistory.FieldImpact)
}

// SetExploitability sets the "exploitability" field.
func (m *FindingHistoryMutation) SetExploitability(f float64) {
	m.exploitability = &f
	m.addexploitability = nil
}

// Exploitability returns the value of the "exploitability" field in the mutation.
func (m *FindingHistoryMutation) Exploitability() (r float64, exists bool) {
	v := m.exploitability
	if v == nil {
		return
	}
	return *v, true
}

// OldExploitability returns the old "exploitability" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldExploitability(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExploitability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExploitability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExploitability: %w", err)
	}
	return oldValue.Exploitability, nil
}

// AddExploitability adds f to the "exploitability" field.
func (m *FindingHistoryMutation) AddExploitability(f float64) {
	if m.addexploitability != nil {
		*m.addexploitability += f
	} else {
		m.addexploitability = &f
	}
}

// AddedExploitability returns the value that was added to the "exploitability" field in this mutation.
func (m *FindingHistoryMutation) AddedExploitability() (r float64, exists bool) {
	v := m.addexploitability
	if v == nil {
		return
	}
	return *v, true
}

// ClearExploitability clears the value of the "exploitability" field.
func (m *FindingHistoryMutation) ClearExploitability() {
	m.exploitability = nil
	m.addexploitability = nil
	m.clearedFields[findinghistory.FieldExploitability] = struct{}{}
}

// ExploitabilityCleared returns if the "exploitability" field was cleared in this mutation.
func (m *FindingHistoryMutation) ExploitabilityCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldExploitability]
	return ok
}

// ResetExploitability resets all changes to the "exploitability" field.
func (m *FindingHistoryMutation) ResetExploitability() {
	m.exploitability = nil
	m.addexploitability = nil
	delete(m.clearedFields, findinghistory.FieldExploitability)
}

// SetPriority sets the "priority" field.
func (m *FindingHistoryMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *FindingHistoryMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ClearPriority clears the value of the "priority" field.
func (m *FindingHistoryMutation) ClearPriority() {
	m.priority = nil
	m.clearedFields[findinghistory.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *FindingHistoryMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *FindingHistoryMutation) ResetPriority() {
	m.priority = nil
	delete(m.clearedFields, findinghistory.FieldPriority)
}

// SetOpen sets the "open" field.
func (m *FindingHistoryMutation) SetOpen(b bool) {
	m.open = &b
}

// Open returns the value of the "open" field in the mutation.
func (m *FindingHistoryMutation) Open() (r bool, exists bool) {
	v := m.open
	if v == nil {
		return
	}
	return *v, true
}

// OldOpen returns the old "open" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldOpen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpen: %w", err)
	}
	return oldValue.Open, nil
}

// ClearOpen clears the value of the "open" field.
func (m *FindingHistoryMutation) ClearOpen() {
	m.open = nil
	m.clearedFields[findinghistory.FieldOpen] = struct{}{}
}

// OpenCleared returns if the "open" field was cleared in this mutation.
func (m *FindingHistoryMutation) OpenCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldOpen]
	return ok
}

// ResetOpen resets all changes to the "open" field.
func (m *FindingHistoryMutation) ResetOpen() {
	m.open = nil
	delete(m.clearedFields, findinghistory.FieldOpen)
}

// SetBlocksProduction sets the "blocks_production" field.
func (m *FindingHistoryMutation) SetBlocksProduction(b bool) {
	m.blocks_production = &b
}

// BlocksProduction returns the value of the "blocks_production" field in the mutation.
func (m *FindingHistoryMutation) BlocksProduction() (r bool, exists bool) {
	v := m.blocks_production
	if v == nil {
		return
	}
	return *v, true
}

// OldBlocksProduction returns the old "blocks_production" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldBlocksProduction(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlocksProduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlocksProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlocksProduction: %w", err)
	}
	return oldValue.BlocksProduction, nil
}

// ClearBlocksProduction clears the value of the "blocks_production" field.
func (m *FindingHistoryMutation) ClearBlocksProduction() {
	m.blocks_production = nil
	m.clearedFields[findinghistory.FieldBlocksProduction] = struct{}{}
}

// BlocksProductionCleared returns if the "blocks_production" field was cleared in this mutation.
func (m *FindingHistoryMutation) BlocksProductionCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldBlocksProduction]
	return ok
}

// ResetBlocksProduction resets all changes to the "blocks_production" field.
func (m *FindingHistoryMutation) ResetBlocksProduction() {
	m.blocks_production = nil
	delete(m.clearedFields, findinghistory.FieldBlocksProduction)
}

// SetProduction sets the "production" field.
func (m *FindingHistoryMutation) SetProduction(b bool) {
	m.production = &b
}

// Production returns the value of the "production" field in the mutation.
func (m *FindingHistoryMutation) Production() (r bool, exists bool) {
	v := m.production
	if v == nil {
		return
	}
	return *v, true
}

// OldProduction returns the old "production" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldProduction(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProduction: %w", err)
	}
	return oldValue.Production, nil
}

// ClearProduction clears the value of the "production" field.
func (m *FindingHistoryMutation) ClearProduction() {
	m.production = nil
	m.clearedFields[findinghistory.FieldProduction] = struct{}{}
}

// ProductionCleared returns if the "production" field was cleared in this mutation.
func (m *FindingHistoryMutation) ProductionCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldProduction]
	return ok
}

// ResetProduction resets all changes to the "production" field.
func (m *FindingHistoryMutation) ResetProduction() {
	m.production = nil
	delete(m.clearedFields, findinghistory.FieldProduction)
}

// SetPublic sets the "public" field.
func (m *FindingHistoryMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *FindingHistoryMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ClearPublic clears the value of the "public" field.
func (m *FindingHistoryMutation) ClearPublic() {
	m.public = nil
	m.clearedFields[findinghistory.FieldPublic] = struct{}{}
}

// PublicCleared returns if the "public" field was cleared in this mutation.
func (m *FindingHistoryMutation) PublicCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldPublic]
	return ok
}

// ResetPublic resets all changes to the "public" field.
func (m *FindingHistoryMutation) ResetPublic() {
	m.public = nil
	delete(m.clearedFields, findinghistory.FieldPublic)
}

// SetValidated sets the "validated" field.
func (m *FindingHistoryMutation) SetValidated(b bool) {
	m.validated = &b
}

// Validated returns the value of the "validated" field in the mutation.
func (m *FindingHistoryMutation) Validated() (r bool, exists bool) {
	v := m.validated
	if v == nil {
		return
	}
	return *v, true
}

// OldValidated returns the old "validated" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldValidated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidated: %w", err)
	}
	return oldValue.Validated, nil
}

// ClearValidated clears the value of the "validated" field.
func (m *FindingHistoryMutation) ClearValidated() {
	m.validated = nil
	m.clearedFields[findinghistory.FieldValidated] = struct{}{}
}

// ValidatedCleared returns if the "validated" field was cleared in this mutation.
func (m *FindingHistoryMutation) ValidatedCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldValidated]
	return ok
}

// ResetValidated resets all changes to the "validated" field.
func (m *FindingHistoryMutation) ResetValidated() {
	m.validated = nil
	delete(m.clearedFields, findinghistory.FieldValidated)
}

// SetAssessmentID sets the "assessment_id" field.
func (m *FindingHistoryMutation) SetAssessmentID(s string) {
	m.assessment_id = &s
}

// AssessmentID returns the value of the "assessment_id" field in the mutation.
func (m *FindingHistoryMutation) AssessmentID() (r string, exists bool) {
	v := m.assessment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssessmentID returns the old "assessment_id" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldAssessmentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssessmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssessmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssessmentID: %w", err)
	}
	return oldValue.AssessmentID, nil
}

// ClearAssessmentID clears the value of the "assessment_id" field.
func (m *FindingHistoryMutation) ClearAssessmentID() {
	m.assessment_id = nil
	m.clearedFields[findinghistory.FieldAssessmentID] = struct{}{}
}

// AssessmentIDCleared returns if the "assessment_id" field was cleared in this mutation.
func (m *FindingHistoryMutation) AssessmentIDCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldAssessmentID]
	return ok
}

// ResetAssessmentID resets all changes to the "assessment_id" field.
func (m *FindingHistoryMutation) ResetAssessmentID() {
	m.assessment_id = nil
	delete(m.clearedFields, findinghistory.FieldAssessmentID)
}

// SetDescription sets the "description" field.
func (m *FindingHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FindingHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FindingHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[findinghistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FindingHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FindingHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, findinghistory.FieldDescription)
}

// SetRecommendation sets the "recommendation" field.
func (m *FindingHistoryMutation) SetRecommendation(s string) {
	m.recommendation = &s
}

// Recommendation returns the value of the "recommendation" field in the mutation.
func (m *FindingHistoryMutation) Recommendation() (r string, exists bool) {
	v := m.recommendation
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommendation returns the old "recommendation" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldRecommendation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommendation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommendation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommendation: %w", err)
	}
	return oldValue.Recommendation, nil
}

// ClearRecommendation clears the value of the "recommendation" field.
func (m *FindingHistoryMutation) ClearRecommendation() {
	m.recommendation = nil
	m.clearedFields[findinghistory.FieldRecommendation] = struct{}{}
}

// RecommendationCleared returns if the "recommendation" field was cleared in this mutation.
func (m *FindingHistoryMutation) RecommendationCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldRecommendation]
	return ok
}

// ResetRecommendation resets all changes to the "recommendation" field.
func (m *FindingHistoryMutation) ResetRecommendation() {
	m.recommendation = nil
	delete(m.clearedFields, findinghistory.FieldRecommendation)
}

// SetRecommendedActions sets the "recommended_actions" field.
func (m *FindingHistoryMutation) SetRecommendedActions(s string) {
	m.recommended_actions = &s
}

// RecommendedActions returns the value of the "recommended_actions" field in the mutation.
func (m *FindingHistoryMutation) RecommendedActions() (r string, exists bool) {
	v := m.recommended_actions
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommendedActions returns the old "recommended_actions" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldRecommendedActions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommendedActions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommendedActions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommendedActions: %w", err)
	}
	return oldValue.RecommendedActions, nil
}

// ClearRecommendedActions clears the value of the "recommended_actions" field.
func (m *FindingHistoryMutation) ClearRecommendedActions() {
	m.recommended_actions = nil
	m.clearedFields[findinghistory.FieldRecommendedActions] = struct{}{}
}

// RecommendedActionsCleared returns if the "recommended_actions" field was cleared in this mutation.
func (m *FindingHistoryMutation) RecommendedActionsCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldRecommendedActions]
	return ok
}

// ResetRecommendedActions resets all changes to the "recommended_actions" field.
func (m *FindingHistoryMutation) ResetRecommendedActions() {
	m.recommended_actions = nil
	delete(m.clearedFields, findinghistory.FieldRecommendedActions)
}

// SetReferences sets the "references" field.
func (m *FindingHistoryMutation) SetReferences(s []string) {
	m.references = &s
	m.appendreferences = nil
}

// References returns the value of the "references" field in the mutation.
func (m *FindingHistoryMutation) References() (r []string, exists bool) {
	v := m.references
	if v == nil {
		return
	}
	return *v, true
}

// OldReferences returns the old "references" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldReferences(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferences: %w", err)
	}
	return oldValue.References, nil
}

// AppendReferences adds s to the "references" field.
func (m *FindingHistoryMutation) AppendReferences(s []string) {
	m.appendreferences = append(m.appendreferences, s...)
}

// AppendedReferences returns the list of values that were appended to the "references" field in this mutation.
func (m *FindingHistoryMutation) AppendedReferences() ([]string, bool) {
	if len(m.appendreferences) == 0 {
		return nil, false
	}
	return m.appendreferences, true
}

// ClearReferences clears the value of the "references" field.
func (m *FindingHistoryMutation) ClearReferences() {
	m.references = nil
	m.appendreferences = nil
	m.clearedFields[findinghistory.FieldReferences] = struct{}{}
}

// ReferencesCleared returns if the "references" field was cleared in this mutation.
func (m *FindingHistoryMutation) ReferencesCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldReferences]
	return ok
}

// ResetReferences resets all changes to the "references" field.
func (m *FindingHistoryMutation) ResetReferences() {
	m.references = nil
	m.appendreferences = nil
	delete(m.clearedFields, findinghistory.FieldReferences)
}

// SetStepsToReproduce sets the "steps_to_reproduce" field.
func (m *FindingHistoryMutation) SetStepsToReproduce(s []string) {
	m.steps_to_reproduce = &s
	m.appendsteps_to_reproduce = nil
}

// StepsToReproduce returns the value of the "steps_to_reproduce" field in the mutation.
func (m *FindingHistoryMutation) StepsToReproduce() (r []string, exists bool) {
	v := m.steps_to_reproduce
	if v == nil {
		return
	}
	return *v, true
}

// OldStepsToReproduce returns the old "steps_to_reproduce" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldStepsToReproduce(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepsToReproduce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepsToReproduce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepsToReproduce: %w", err)
	}
	return oldValue.StepsToReproduce, nil
}

// AppendStepsToReproduce adds s to the "steps_to_reproduce" field.
func (m *FindingHistoryMutation) AppendStepsToReproduce(s []string) {
	m.appendsteps_to_reproduce = append(m.appendsteps_to_reproduce, s...)
}

// AppendedStepsToReproduce returns the list of values that were appended to the "steps_to_reproduce" field in this mutation.
func (m *FindingHistoryMutation) AppendedStepsToReproduce() ([]string, bool) {
	if len(m.appendsteps_to_reproduce) == 0 {
		return nil, false
	}
	return m.appendsteps_to_reproduce, true
}

// ClearStepsToReproduce clears the value of the "steps_to_reproduce" field.
func (m *FindingHistoryMutation) ClearStepsToReproduce() {
	m.steps_to_reproduce = nil
	m.appendsteps_to_reproduce = nil
	m.clearedFields[findinghistory.FieldStepsToReproduce] = struct{}{}
}

// StepsToReproduceCleared returns if the "steps_to_reproduce" field was cleared in this mutation.
func (m *FindingHistoryMutation) StepsToReproduceCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldStepsToReproduce]
	return ok
}

// ResetStepsToReproduce resets all changes to the "steps_to_reproduce" field.
func (m *FindingHistoryMutation) ResetStepsToReproduce() {
	m.steps_to_reproduce = nil
	m.appendsteps_to_reproduce = nil
	delete(m.clearedFields, findinghistory.FieldStepsToReproduce)
}

// SetTargets sets the "targets" field.
func (m *FindingHistoryMutation) SetTargets(s []string) {
	m.targets = &s
	m.appendtargets = nil
}

// Targets returns the value of the "targets" field in the mutation.
func (m *FindingHistoryMutation) Targets() (r []string, exists bool) {
	v := m.targets
	if v == nil {
		return
	}
	return *v, true
}

// OldTargets returns the old "targets" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldTargets(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargets: %w", err)
	}
	return oldValue.Targets, nil
}

// AppendTargets adds s to the "targets" field.
func (m *FindingHistoryMutation) AppendTargets(s []string) {
	m.appendtargets = append(m.appendtargets, s...)
}

// AppendedTargets returns the list of values that were appended to the "targets" field in this mutation.
func (m *FindingHistoryMutation) AppendedTargets() ([]string, bool) {
	if len(m.appendtargets) == 0 {
		return nil, false
	}
	return m.appendtargets, true
}

// ClearTargets clears the value of the "targets" field.
func (m *FindingHistoryMutation) ClearTargets() {
	m.targets = nil
	m.appendtargets = nil
	m.clearedFields[findinghistory.FieldTargets] = struct{}{}
}

// TargetsCleared returns if the "targets" field was cleared in this mutation.
func (m *FindingHistoryMutation) TargetsCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldTargets]
	return ok
}

// ResetTargets resets all changes to the "targets" field.
func (m *FindingHistoryMutation) ResetTargets() {
	m.targets = nil
	m.appendtargets = nil
	delete(m.clearedFields, findinghistory.FieldTargets)
}

// SetTargetDetails sets the "target_details" field.
func (m *FindingHistoryMutation) SetTargetDetails(value map[string]interface{}) {
	m.target_details = &value
}

// TargetDetails returns the value of the "target_details" field in the mutation.
func (m *FindingHistoryMutation) TargetDetails() (r map[string]interface{}, exists bool) {
	v := m.target_details
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetDetails returns the old "target_details" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldTargetDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetDetails: %w", err)
	}
	return oldValue.TargetDetails, nil
}

// ClearTargetDetails clears the value of the "target_details" field.
func (m *FindingHistoryMutation) ClearTargetDetails() {
	m.target_details = nil
	m.clearedFields[findinghistory.FieldTargetDetails] = struct{}{}
}

// TargetDetailsCleared returns if the "target_details" field was cleared in this mutation.
func (m *FindingHistoryMutation) TargetDetailsCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldTargetDetails]
	return ok
}

// ResetTargetDetails resets all changes to the "target_details" field.
func (m *FindingHistoryMutation) ResetTargetDetails() {
	m.target_details = nil
	delete(m.clearedFields, findinghistory.FieldTargetDetails)
}

// SetVector sets the "vector" field.
func (m *FindingHistoryMutation) SetVector(s string) {
	m.vector = &s
}

// Vector returns the value of the "vector" field in the mutation.
func (m *FindingHistoryMutation) Vector() (r string, exists bool) {
	v := m.vector
	if v == nil {
		return
	}
	return *v, true
}

// OldVector returns the old "vector" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldVector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVector: %w", err)
	}
	return oldValue.Vector, nil
}

// ClearVector clears the value of the "vector" field.
func (m *FindingHistoryMutation) ClearVector() {
	m.vector = nil
	m.clearedFields[findinghistory.FieldVector] = struct{}{}
}

// VectorCleared returns if the "vector" field was cleared in this mutation.
func (m *FindingHistoryMutation) VectorCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldVector]
	return ok
}

// ResetVector resets all changes to the "vector" field.
func (m *FindingHistoryMutation) ResetVector() {
	m.vector = nil
	delete(m.clearedFields, findinghistory.FieldVector)
}

// SetRemediationSLA sets the "remediation_sla" field.
func (m *FindingHistoryMutation) SetRemediationSLA(i int) {
	m.remediation_sla = &i
	m.addremediation_sla = nil
}

// RemediationSLA returns the value of the "remediation_sla" field in the mutation.
func (m *FindingHistoryMutation) RemediationSLA() (r int, exists bool) {
	v := m.remediation_sla
	if v == nil {
		return
	}
	return *v, true
}

// OldRemediationSLA returns the old "remediation_sla" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldRemediationSLA(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemediationSLA is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemediationSLA requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemediationSLA: %w", err)
	}
	return oldValue.RemediationSLA, nil
}

// AddRemediationSLA adds i to the "remediation_sla" field.
func (m *FindingHistoryMutation) AddRemediationSLA(i int) {
	if m.addremediation_sla != nil {
		*m.addremediation_sla += i
	} else {
		m.addremediation_sla = &i
	}
}

// AddedRemediationSLA returns the value that was added to the "remediation_sla" field in this mutation.
func (m *FindingHistoryMutation) AddedRemediationSLA() (r int, exists bool) {
	v := m.addremediation_sla
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemediationSLA clears the value of the "remediation_sla" field.
func (m *FindingHistoryMutation) ClearRemediationSLA() {
	m.remediation_sla = nil
	m.addremediation_sla = nil
	m.clearedFields[findinghistory.FieldRemediationSLA] = struct{}{}
}

// RemediationSLACleared returns if the "remediation_sla" field was cleared in this mutation.
func (m *FindingHistoryMutation) RemediationSLACleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldRemediationSLA]
	return ok
}

// ResetRemediationSLA resets all changes to the "remediation_sla" field.
func (m *FindingHistoryMutation) ResetRemediationSLA() {
	m.remediation_sla = nil
	m.addremediation_sla = nil
	delete(m.clearedFields, findinghistory.FieldRemediationSLA)
}

// SetStatus sets the "status" field.
func (m *FindingHistoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *FindingHistoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *FindingHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[findinghistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *FindingHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *FindingHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, findinghistory.FieldStatus)
}

// SetEventTime sets the "event_time" field.
func (m *FindingHistoryMutation) SetEventTime(mt models.DateTime) {
	m.event_time = &mt
}

// EventTime returns the value of the "event_time" field in the mutation.
func (m *FindingHistoryMutation) EventTime() (r models.DateTime, exists bool) {
	v := m.event_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEventTime returns the old "event_time" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldEventTime(ctx context.Context) (v *models.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventTime: %w", err)
	}
	return oldValue.EventTime, nil
}

// ClearEventTime clears the value of the "event_time" field.
func (m *FindingHistoryMutation) ClearEventTime() {
	m.event_time = nil
	m.clearedFields[findinghistory.FieldEventTime] = struct{}{}
}

// EventTimeCleared returns if the "event_time" field was cleared in this mutation.
func (m *FindingHistoryMutation) EventTimeCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldEventTime]
	return ok
}

// ResetEventTime resets all changes to the "event_time" field.
func (m *FindingHistoryMutation) ResetEventTime() {
	m.event_time = nil
	delete(m.clearedFields, findinghistory.FieldEventTime)
}

// SetReportedAt sets the "reported_at" field.
func (m *FindingHistoryMutation) SetReportedAt(mt models.DateTime) {
	m.reported_at = &mt
}

// ReportedAt returns the value of the "reported_at" field in the mutation.
func (m *FindingHistoryMutation) ReportedAt() (r models.DateTime, exists bool) {
	v := m.reported_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReportedAt returns the old "reported_at" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldReportedAt(ctx context.Context) (v *models.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportedAt: %w", err)
	}
	return oldValue.ReportedAt, nil
}

// ClearReportedAt clears the value of the "reported_at" field.
func (m *FindingHistoryMutation) ClearReportedAt() {
	m.reported_at = nil
	m.clearedFields[findinghistory.FieldReportedAt] = struct{}{}
}

// ReportedAtCleared returns if the "reported_at" field was cleared in this mutation.
func (m *FindingHistoryMutation) ReportedAtCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldReportedAt]
	return ok
}

// ResetReportedAt resets all changes to the "reported_at" field.
func (m *FindingHistoryMutation) ResetReportedAt() {
	m.reported_at = nil
	delete(m.clearedFields, findinghistory.FieldReportedAt)
}

// SetSourceUpdatedAt sets the "source_updated_at" field.
func (m *FindingHistoryMutation) SetSourceUpdatedAt(mt models.DateTime) {
	m.source_updated_at = &mt
}

// SourceUpdatedAt returns the value of the "source_updated_at" field in the mutation.
func (m *FindingHistoryMutation) SourceUpdatedAt() (r models.DateTime, exists bool) {
	v := m.source_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceUpdatedAt returns the old "source_updated_at" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldSourceUpdatedAt(ctx context.Context) (v *models.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceUpdatedAt: %w", err)
	}
	return oldValue.SourceUpdatedAt, nil
}

// ClearSourceUpdatedAt clears the value of the "source_updated_at" field.
func (m *FindingHistoryMutation) ClearSourceUpdatedAt() {
	m.source_updated_at = nil
	m.clearedFields[findinghistory.FieldSourceUpdatedAt] = struct{}{}
}

// SourceUpdatedAtCleared returns if the "source_updated_at" field was cleared in this mutation.
func (m *FindingHistoryMutation) SourceUpdatedAtCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldSourceUpdatedAt]
	return ok
}

// ResetSourceUpdatedAt resets all changes to the "source_updated_at" field.
func (m *FindingHistoryMutation) ResetSourceUpdatedAt() {
	m.source_updated_at = nil
	delete(m.clearedFields, findinghistory.FieldSourceUpdatedAt)
}

// SetExternalURI sets the "external_uri" field.
func (m *FindingHistoryMutation) SetExternalURI(s string) {
	m.external_uri = &s
}

// ExternalURI returns the value of the "external_uri" field in the mutation.
func (m *FindingHistoryMutation) ExternalURI() (r string, exists bool) {
	v := m.external_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalURI returns the old "external_uri" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldExternalURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalURI: %w", err)
	}
	return oldValue.ExternalURI, nil
}

// ClearExternalURI clears the value of the "external_uri" field.
func (m *FindingHistoryMutation) ClearExternalURI() {
	m.external_uri = nil
	m.clearedFields[findinghistory.FieldExternalURI] = struct{}{}
}

// ExternalURICleared returns if the "external_uri" field was cleared in this mutation.
func (m *FindingHistoryMutation) ExternalURICleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldExternalURI]
	return ok
}

// ResetExternalURI resets all changes to the "external_uri" field.
func (m *FindingHistoryMutation) ResetExternalURI() {
	m.external_uri = nil
	delete(m.clearedFields, findinghistory.FieldExternalURI)
}

// SetMetadata sets the "metadata" field.
func (m *FindingHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *FindingHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *FindingHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[findinghistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *FindingHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *FindingHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, findinghistory.FieldMetadata)
}

// SetRawPayload sets the "raw_payload" field.
func (m *FindingHistoryMutation) SetRawPayload(value map[string]interface{}) {
	m.raw_payload = &value
}

// RawPayload returns the value of the "raw_payload" field in the mutation.
func (m *FindingHistoryMutation) RawPayload() (r map[string]interface{}, exists bool) {
	v := m.raw_payload
	if v == nil {
		return
	}
	return *v, true
}

// OldRawPayload returns the old "raw_payload" field's value of the FindingHistory entity.
// If the FindingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingHistoryMutation) OldRawPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawPayload: %w", err)
	}
	return oldValue.RawPayload, nil
}

// ClearRawPayload clears the value of the "raw_payload" field.
func (m *FindingHistoryMutation) ClearRawPayload() {
	m.raw_payload = nil
	m.clearedFields[findinghistory.FieldRawPayload] = struct{}{}
}

// RawPayloadCleared returns if the "raw_payload" field was cleared in this mutation.
func (m *FindingHistoryMutation) RawPayloadCleared() bool {
	_, ok := m.clearedFields[findinghistory.FieldRawPayload]
	return ok
}

// ResetRawPayload resets all changes to the "raw_payload" field.
func (m *FindingHistoryMutation) ResetRawPayload() {
	m.raw_payload = nil
	delete(m.clearedFields, findinghistory.FieldRawPayload)
}

// Where appends a list predicates to the FindingHistoryMutation builder.
func (m *FindingHistoryMutation) Where(ps ...predicate.FindingHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FindingHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FindingHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FindingHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FindingHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FindingHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FindingHistory).
func (m *FindingHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FindingHistoryMutation) Fields() []string {
	fields := make([]string, 0, 52)
	if m.history_time != nil {
		fields = append(fields, findinghistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, findinghistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, findinghistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, findinghistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, findinghistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, findinghistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, findinghistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, findinghistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, findinghistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, findinghistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, findinghistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, findinghistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, findinghistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, findinghistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, findinghistory.FieldSystemInternalID)
	}
	if m.external_id != nil {
		fields = append(fields, findinghistory.FieldExternalID)
	}
	if m.external_owner_id != nil {
		fields = append(fields, findinghistory.FieldExternalOwnerID)
	}
	if m.source != nil {
		fields = append(fields, findinghistory.FieldSource)
	}
	if m.resource_name != nil {
		fields = append(fields, findinghistory.FieldResourceName)
	}
	if m.display_name != nil {
		fields = append(fields, findinghistory.FieldDisplayName)
	}
	if m.state != nil {
		fields = append(fields, findinghistory.FieldState)
	}
	if m.category != nil {
		fields = append(fields, findinghistory.FieldCategory)
	}
	if m.categories != nil {
		fields = append(fields, findinghistory.FieldCategories)
	}
	if m.finding_class != nil {
		fields = append(fields, findinghistory.FieldFindingClass)
	}
	if m.severity != nil {
		fields = append(fields, findinghistory.FieldSeverity)
	}
	if m.numeric_severity != nil {
		fields = append(fields, findinghistory.FieldNumericSeverity)
	}
	if m.score != nil {
		fields = append(fields, findinghistory.FieldScore)
	}
	if m.impact != nil {
		fields = append(fields, findinghistory.FieldImpact)
	}
	if m.exploitability != nil {
		fields = append(fields, findinghistory.FieldExploitability)
	}
	if m.priority != nil {
		fields = append(fields, findinghistory.FieldPriority)
	}
	if m.open != nil {
		fields = append(fields, findinghistory.FieldOpen)
	}
	if m.blocks_production != nil {
		fields = append(fields, findinghistory.FieldBlocksProduction)
	}
	if m.production != nil {
		fields = append(fields, findinghistory.FieldProduction)
	}
	if m.public != nil {
		fields = append(fields, findinghistory.FieldPublic)
	}
	if m.validated != nil {
		fields = append(fields, findinghistory.FieldValidated)
	}
	if m.assessment_id != nil {
		fields = append(fields, findinghistory.FieldAssessmentID)
	}
	if m.description != nil {
		fields = append(fields, findinghistory.FieldDescription)
	}
	if m.recommendation != nil {
		fields = append(fields, findinghistory.FieldRecommendation)
	}
	if m.recommended_actions != nil {
		fields = append(fields, findinghistory.FieldRecommendedActions)
	}
	if m.references != nil {
		fields = append(fields, findinghistory.FieldReferences)
	}
	if m.steps_to_reproduce != nil {
		fields = append(fields, findinghistory.FieldStepsToReproduce)
	}
	if m.targets != nil {
		fields = append(fields, findinghistory.FieldTargets)
	}
	if m.target_details != nil {
		fields = append(fields, findinghistory.FieldTargetDetails)
	}
	if m.vector != nil {
		fields = append(fields, findinghistory.FieldVector)
	}
	if m.remediation_sla != nil {
		fields = append(fields, findinghistory.FieldRemediationSLA)
	}
	if m.status != nil {
		fields = append(fields, findinghistory.FieldStatus)
	}
	if m.event_time != nil {
		fields = append(fields, findinghistory.FieldEventTime)
	}
	if m.reported_at != nil {
		fields = append(fields, findinghistory.FieldReportedAt)
	}
	if m.source_updated_at != nil {
		fields = append(fields, findinghistory.FieldSourceUpdatedAt)
	}
	if m.external_uri != nil {
		fields = append(fields, findinghistory.FieldExternalURI)
	}
	if m.metadata != nil {
		fields = append(fields, findinghistory.FieldMetadata)
	}
	if m.raw_payload != nil {
		fields = append(fields, findinghistory.FieldRawPayload)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FindingHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case findinghistory.FieldHistoryTime:
		return m.HistoryTime()
	case findinghistory.FieldRef:
		return m.Ref()
	case findinghistory.FieldOperation:
		return m.Operation()
	case findinghistory.FieldCreatedAt:
		return m.CreatedAt()
	case findinghistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case findinghistory.FieldCreatedBy:
		return m.CreatedBy()
	case findinghistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case findinghistory.FieldDeletedAt:
		return m.DeletedAt()
	case findinghistory.FieldDeletedBy:
		return m.DeletedBy()
	case findinghistory.FieldDisplayID:
		return m.DisplayID()
	case findinghistory.FieldTags:
		return m.Tags()
	case findinghistory.FieldOwnerID:
		return m.OwnerID()
	case findinghistory.FieldSystemOwned:
		return m.SystemOwned()
	case findinghistory.FieldInternalNotes:
		return m.InternalNotes()
	case findinghistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case findinghistory.FieldExternalID:
		return m.ExternalID()
	case findinghistory.FieldExternalOwnerID:
		return m.ExternalOwnerID()
	case findinghistory.FieldSource:
		return m.Source()
	case findinghistory.FieldResourceName:
		return m.ResourceName()
	case findinghistory.FieldDisplayName:
		return m.DisplayName()
	case findinghistory.FieldState:
		return m.State()
	case findinghistory.FieldCategory:
		return m.Category()
	case findinghistory.FieldCategories:
		return m.Categories()
	case findinghistory.FieldFindingClass:
		return m.FindingClass()
	case findinghistory.FieldSeverity:
		return m.Severity()
	case findinghistory.FieldNumericSeverity:
		return m.NumericSeverity()
	case findinghistory.FieldScore:
		return m.Score()
	case findinghistory.FieldImpact:
		return m.Impact()
	case findinghistory.FieldExploitability:
		return m.Exploitability()
	case findinghistory.FieldPriority:
		return m.Priority()
	case findinghistory.FieldOpen:
		return m.Open()
	case findinghistory.FieldBlocksProduction:
		return m.BlocksProduction()
	case findinghistory.FieldProduction:
		return m.Production()
	case findinghistory.FieldPublic:
		return m.Public()
	case findinghistory.FieldValidated:
		return m.Validated()
	case findinghistory.FieldAssessmentID:
		return m.AssessmentID()
	case findinghistory.FieldDescription:
		return m.Description()
	case findinghistory.FieldRecommendation:
		return m.Recommendation()
	case findinghistory.FieldRecommendedActions:
		return m.RecommendedActions()
	case findinghistory.FieldReferences:
		return m.References()
	case findinghistory.FieldStepsToReproduce:
		return m.StepsToReproduce()
	case findinghistory.FieldTargets:
		return m.Targets()
	case findinghistory.FieldTargetDetails:
		return m.TargetDetails()
	case findinghistory.FieldVector:
		return m.Vector()
	case findinghistory.FieldRemediationSLA:
		return m.RemediationSLA()
	case findinghistory.FieldStatus:
		return m.Status()
	case findinghistory.FieldEventTime:
		return m.EventTime()
	case findinghistory.FieldReportedAt:
		return m.ReportedAt()
	case findinghistory.FieldSourceUpdatedAt:
		return m.SourceUpdatedAt()
	case findinghistory.FieldExternalURI:
		return m.ExternalURI()
	case findinghistory.FieldMetadata:
		return m.Metadata()
	case findinghistory.FieldRawPayload:
		return m.RawPayload()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FindingHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case findinghistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case findinghistory.FieldRef:
		return m.OldRef(ctx)
	case findinghistory.FieldOperation:
		return m.OldOperation(ctx)
	case findinghistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case findinghistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case findinghistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case findinghistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case findinghistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case findinghistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case findinghistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case findinghistory.FieldTags:
		return m.OldTags(ctx)
	case findinghistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case findinghistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case findinghistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case findinghistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case findinghistory.FieldExternalID:
		return m.OldExternalID(ctx)
	case findinghistory.FieldExternalOwnerID:
		return m.OldExternalOwnerID(ctx)
	case findinghistory.FieldSource:
		return m.OldSource(ctx)
	case findinghistory.FieldResourceName:
		return m.OldResourceName(ctx)
	case findinghistory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case findinghistory.FieldState:
		return m.OldState(ctx)
	case findinghistory.FieldCategory:
		return m.OldCategory(ctx)
	case findinghistory.FieldCategories:
		return m.OldCategories(ctx)
	case findinghistory.FieldFindingClass:
		return m.OldFindingClass(ctx)
	case findinghistory.FieldSeverity:
		return m.OldSeverity(ctx)
	case findinghistory.FieldNumericSeverity:
		return m.OldNumericSeverity(ctx)
	case findinghistory.FieldScore:
		return m.OldScore(ctx)
	case findinghistory.FieldImpact:
		return m.OldImpact(ctx)
	case findinghistory.FieldExploitability:
		return m.OldExploitability(ctx)
	case findinghistory.FieldPriority:
		return m.OldPriority(ctx)
	case findinghistory.FieldOpen:
		return m.OldOpen(ctx)
	case findinghistory.FieldBlocksProduction:
		return m.OldBlocksProduction(ctx)
	case findinghistory.FieldProduction:
		return m.OldProduction(ctx)
	case findinghistory.FieldPublic:
		return m.OldPublic(ctx)
	case findinghistory.FieldValidated:
		return m.OldValidated(ctx)
	case findinghistory.FieldAssessmentID:
		return m.OldAssessmentID(ctx)
	case findinghistory.FieldDescription:
		return m.OldDescription(ctx)
	case findinghistory.FieldRecommendation:
		return m.OldRecommendation(ctx)
	case findinghistory.FieldRecommendedActions:
		return m.OldRecommendedActions(ctx)
	case findinghistory.FieldReferences:
		return m.OldReferences(ctx)
	case findinghistory.FieldStepsToReproduce:
		return m.OldStepsToReproduce(ctx)
	case findinghistory.FieldTargets:
		return m.OldTargets(ctx)
	case findinghistory.FieldTargetDetails:
		return m.OldTargetDetails(ctx)
	case findinghistory.FieldVector:
		return m.OldVector(ctx)
	case findinghistory.FieldRemediationSLA:
		return m.OldRemediationSLA(ctx)
	case findinghistory.FieldStatus:
		return m.OldStatus(ctx)
	case findinghistory.FieldEventTime:
		return m.OldEventTime(ctx)
	case findinghistory.FieldReportedAt:
		return m.OldReportedAt(ctx)
	case findinghistory.FieldSourceUpdatedAt:
		return m.OldSourceUpdatedAt(ctx)
	case findinghistory.FieldExternalURI:
		return m.OldExternalURI(ctx)
	case findinghistory.FieldMetadata:
		return m.OldMetadata(ctx)
	case findinghistory.FieldRawPayload:
		return m.OldRawPayload(ctx)
	}
	return nil, fmt.Errorf("unknown FindingHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FindingHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case findinghistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case findinghistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case findinghistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case findinghistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case findinghistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case findinghistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case findinghistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case findinghistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case findinghistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case findinghistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case findinghistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case findinghistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case findinghistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case findinghistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case findinghistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case findinghistory.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case findinghistory.FieldExternalOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalOwnerID(v)
		return nil
	case findinghistory.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case findinghistory.FieldResourceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceName(v)
		return nil
	case findinghistory.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case findinghistory.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case findinghistory.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case findinghistory.FieldCategories:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategories(v)
		return nil
	case findinghistory.FieldFindingClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFindingClass(v)
		return nil
	case findinghistory.FieldSeverity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case findinghistory.FieldNumericSeverity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumericSeverity(v)
		return nil
	case findinghistory.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case findinghistory.FieldImpact:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpact(v)
		return nil
	case findinghistory.FieldExploitability:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExploitability(v)
		return nil
	case findinghistory.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case findinghistory.FieldOpen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpen(v)
		return nil
	case findinghistory.FieldBlocksProduction:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlocksProduction(v)
		return nil
	case findinghistory.FieldProduction:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProduction(v)
		return nil
	case findinghistory.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case findinghistory.FieldValidated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidated(v)
		return nil
	case findinghistory.FieldAssessmentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssessmentID(v)
		return nil
	case findinghistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case findinghistory.FieldRecommendation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommendation(v)
		return nil
	case findinghistory.FieldRecommendedActions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommendedActions(v)
		return nil
	case findinghistory.FieldReferences:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferences(v)
		return nil
	case findinghistory.FieldStepsToReproduce:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepsToReproduce(v)
		return nil
	case findinghistory.FieldTargets:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargets(v)
		return nil
	case findinghistory.FieldTargetDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetDetails(v)
		return nil
	case findinghistory.FieldVector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVector(v)
		return nil
	case findinghistory.FieldRemediationSLA:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemediationSLA(v)
		return nil
	case findinghistory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case findinghistory.FieldEventTime:
		v, ok := value.(models.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventTime(v)
		return nil
	case findinghistory.FieldReportedAt:
		v, ok := value.(models.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportedAt(v)
		return nil
	case findinghistory.FieldSourceUpdatedAt:
		v, ok := value.(models.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceUpdatedAt(v)
		return nil
	case findinghistory.FieldExternalURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalURI(v)
		return nil
	case findinghistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case findinghistory.FieldRawPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawPayload(v)
		return nil
	}
	return fmt.Errorf("unknown FindingHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FindingHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addnumeric_severity != nil {
		fields = append(fields, findinghistory.FieldNumericSeverity)
	}
	if m.addscore != nil {
		fields = append(fields, findinghistory.FieldScore)
	}
	if m.addimpact != nil {
		fields = append(fields, findinghistory.FieldImpact)
	}
	if m.addexploitability != nil {
		fields = append(fields, findinghistory.FieldExploitability)
	}
	if m.addremediation_sla != nil {
		fields = append(fields, findinghistory.FieldRemediationSLA)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FindingHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case findinghistory.FieldNumericSeverity:
		return m.AddedNumericSeverity()
	case findinghistory.FieldScore:
		return m.AddedScore()
	case findinghistory.FieldImpact:
		return m.AddedImpact()
	case findinghistory.FieldExploitability:
		return m.AddedExploitability()
	case findinghistory.FieldRemediationSLA:
		return m.AddedRemediationSLA()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FindingHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case findinghistory.FieldNumericSeverity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumericSeverity(v)
		return nil
	case findinghistory.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case findinghistory.FieldImpact:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImpact(v)
		return nil
	case findinghistory.FieldExploitability:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExploitability(v)
		return nil
	case findinghistory.FieldRemediationSLA:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemediationSLA(v)
		return nil
	}
	return fmt.Errorf("unknown FindingHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FindingHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(findinghistory.FieldRef) {
		fields = append(fields, findinghistory.FieldRef)
	}
	if m.FieldCleared(findinghistory.FieldCreatedAt) {
		fields = append(fields, findinghistory.FieldCreatedAt)
	}
	if m.FieldCleared(findinghistory.FieldUpdatedAt) {
		fields = append(fields, findinghistory.FieldUpdatedAt)
	}
	if m.FieldCleared(findinghistory.FieldCreatedBy) {
		fields = append(fields, findinghistory.FieldCreatedBy)
	}
	if m.FieldCleared(findinghistory.FieldUpdatedBy) {
		fields = append(fields, findinghistory.FieldUpdatedBy)
	}
	if m.FieldCleared(findinghistory.FieldDeletedAt) {
		fields = append(fields, findinghistory.FieldDeletedAt)
	}
	if m.FieldCleared(findinghistory.FieldDeletedBy) {
		fields = append(fields, findinghistory.FieldDeletedBy)
	}
	if m.FieldCleared(findinghistory.FieldTags) {
		fields = append(fields, findinghistory.FieldTags)
	}
	if m.FieldCleared(findinghistory.FieldOwnerID) {
		fields = append(fields, findinghistory.FieldOwnerID)
	}
	if m.FieldCleared(findinghistory.FieldSystemOwned) {
		fields = append(fields, findinghistory.FieldSystemOwned)
	}
	if m.FieldCleared(findinghistory.FieldInternalNotes) {
		fields = append(fields, findinghistory.FieldInternalNotes)
	}
	if m.FieldCleared(findinghistory.FieldSystemInternalID) {
		fields = append(fields, findinghistory.FieldSystemInternalID)
	}
	if m.FieldCleared(findinghistory.FieldExternalID) {
		fields = append(fields, findinghistory.FieldExternalID)
	}
	if m.FieldCleared(findinghistory.FieldExternalOwnerID) {
		fields = append(fields, findinghistory.FieldExternalOwnerID)
	}
	if m.FieldCleared(findinghistory.FieldSource) {
		fields = append(fields, findinghistory.FieldSource)
	}
	if m.FieldCleared(findinghistory.FieldResourceName) {
		fields = append(fields, findinghistory.FieldResourceName)
	}
	if m.FieldCleared(findinghistory.FieldDisplayName) {
		fields = append(fields, findinghistory.FieldDisplayName)
	}
	if m.FieldCleared(findinghistory.FieldState) {
		fields = append(fields, findinghistory.FieldState)
	}
	if m.FieldCleared(findinghistory.FieldCategory) {
		fields = append(fields, findinghistory.FieldCategory)
	}
	if m.FieldCleared(findinghistory.FieldCategories) {
		fields = append(fields, findinghistory.FieldCategories)
	}
	if m.FieldCleared(findinghistory.FieldFindingClass) {
		fields = append(fields, findinghistory.FieldFindingClass)
	}
	if m.FieldCleared(findinghistory.FieldSeverity) {
		fields = append(fields, findinghistory.FieldSeverity)
	}
	if m.FieldCleared(findinghistory.FieldNumericSeverity) {
		fields = append(fields, findinghistory.FieldNumericSeverity)
	}
	if m.FieldCleared(findinghistory.FieldScore) {
		fields = append(fields, findinghistory.FieldScore)
	}
	if m.FieldCleared(findinghistory.FieldImpact) {
		fields = append(fields, findinghistory.FieldImpact)
	}
	if m.FieldCleared(findinghistory.FieldExploitability) {
		fields = append(fields, findinghistory.FieldExploitability)
	}
	if m.FieldCleared(findinghistory.FieldPriority) {
		fields = append(fields, findinghistory.FieldPriority)
	}
	if m.FieldCleared(findinghistory.FieldOpen) {
		fields = append(fields, findinghistory.FieldOpen)
	}
	if m.FieldCleared(findinghistory.FieldBlocksProduction) {
		fields = append(fields, findinghistory.FieldBlocksProduction)
	}
	if m.FieldCleared(findinghistory.FieldProduction) {
		fields = append(fields, findinghistory.FieldProduction)
	}
	if m.FieldCleared(findinghistory.FieldPublic) {
		fields = append(fields, findinghistory.FieldPublic)
	}
	if m.FieldCleared(findinghistory.FieldValidated) {
		fields = append(fields, findinghistory.FieldValidated)
	}
	if m.FieldCleared(findinghistory.FieldAssessmentID) {
		fields = append(fields, findinghistory.FieldAssessmentID)
	}
	if m.FieldCleared(findinghistory.FieldDescription) {
		fields = append(fields, findinghistory.FieldDescription)
	}
	if m.FieldCleared(findinghistory.FieldRecommendation) {
		fields = append(fields, findinghistory.FieldRecommendation)
	}
	if m.FieldCleared(findinghistory.FieldRecommendedActions) {
		fields = append(fields, findinghistory.FieldRecommendedActions)
	}
	if m.FieldCleared(findinghistory.FieldReferences) {
		fields = append(fields, findinghistory.FieldReferences)
	}
	if m.FieldCleared(findinghistory.FieldStepsToReproduce) {
		fields = append(fields, findinghistory.FieldStepsToReproduce)
	}
	if m.FieldCleared(findinghistory.FieldTargets) {
		fields = append(fields, findinghistory.FieldTargets)
	}
	if m.FieldCleared(findinghistory.FieldTargetDetails) {
		fields = append(fields, findinghistory.FieldTargetDetails)
	}
	if m.FieldCleared(findinghistory.FieldVector) {
		fields = append(fields, findinghistory.FieldVector)
	}
	if m.FieldCleared(findinghistory.FieldRemediationSLA) {
		fields = append(fields, findinghistory.FieldRemediationSLA)
	}
	if m.FieldCleared(findinghistory.FieldStatus) {
		fields = append(fields, findinghistory.FieldStatus)
	}
	if m.FieldCleared(findinghistory.FieldEventTime) {
		fields = append(fields, findinghistory.FieldEventTime)
	}
	if m.FieldCleared(findinghistory.FieldReportedAt) {
		fields = append(fields, findinghistory.FieldReportedAt)
	}
	if m.FieldCleared(findinghistory.FieldSourceUpdatedAt) {
		fields = append(fields, findinghistory.FieldSourceUpdatedAt)
	}
	if m.FieldCleared(findinghistory.FieldExternalURI) {
		fields = append(fields, findinghistory.FieldExternalURI)
	}
	if m.FieldCleared(findinghistory.FieldMetadata) {
		fields = append(fields, findinghistory.FieldMetadata)
	}
	if m.FieldCleared(findinghistory.FieldRawPayload) {
		fields = append(fields, findinghistory.FieldRawPayload)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FindingHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FindingHistoryMutation) ClearField(name string) error {
	switch name {
	case findinghistory.FieldRef:
		m.ClearRef()
		return nil
	case findinghistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case findinghistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case findinghistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case findinghistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case findinghistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case findinghistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case findinghistory.FieldTags:
		m.ClearTags()
		return nil
	case findinghistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case findinghistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case findinghistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case findinghistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case findinghistory.FieldExternalID:
		m.ClearExternalID()
		return nil
	case findinghistory.FieldExternalOwnerID:
		m.ClearExternalOwnerID()
		return nil
	case findinghistory.FieldSource:
		m.ClearSource()
		return nil
	case findinghistory.FieldResourceName:
		m.ClearResourceName()
		return nil
	case findinghistory.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case findinghistory.FieldState:
		m.ClearState()
		return nil
	case findinghistory.FieldCategory:
		m.ClearCategory()
		return nil
	case findinghistory.FieldCategories:
		m.ClearCategories()
		return nil
	case findinghistory.FieldFindingClass:
		m.ClearFindingClass()
		return nil
	case findinghistory.FieldSeverity:
		m.ClearSeverity()
		return nil
	case findinghistory.FieldNumericSeverity:
		m.ClearNumericSeverity()
		return nil
	case findinghistory.FieldScore:
		m.ClearScore()
		return nil
	case findinghistory.FieldImpact:
		m.ClearImpact()
		return nil
	case findinghistory.FieldExploitability:
		m.ClearExploitability()
		return nil
	case findinghistory.FieldPriority:
		m.ClearPriority()
		return nil
	case findinghistory.FieldOpen:
		m.ClearOpen()
		return nil
	case findinghistory.FieldBlocksProduction:
		m.ClearBlocksProduction()
		return nil
	case findinghistory.FieldProduction:
		m.ClearProduction()
		return nil
	case findinghistory.FieldPublic:
		m.ClearPublic()
		return nil
	case findinghistory.FieldValidated:
		m.ClearValidated()
		return nil
	case findinghistory.FieldAssessmentID:
		m.ClearAssessmentID()
		return nil
	case findinghistory.FieldDescription:
		m.ClearDescription()
		return nil
	case findinghistory.FieldRecommendation:
		m.ClearRecommendation()
		return nil
	case findinghistory.FieldRecommendedActions:
		m.ClearRecommendedActions()
		return nil
	case findinghistory.FieldReferences:
		m.ClearReferences()
		return nil
	case findinghistory.FieldStepsToReproduce:
		m.ClearStepsToReproduce()
		return nil
	case findinghistory.FieldTargets:
		m.ClearTargets()
		return nil
	case findinghistory.FieldTargetDetails:
		m.ClearTargetDetails()
		return nil
	case findinghistory.FieldVector:
		m.ClearVector()
		return nil
	case findinghistory.FieldRemediationSLA:
		m.ClearRemediationSLA()
		return nil
	case findinghistory.FieldStatus:
		m.ClearStatus()
		return nil
	case findinghistory.FieldEventTime:
		m.ClearEventTime()
		return nil
	case findinghistory.FieldReportedAt:
		m.ClearReportedAt()
		return nil
	case findinghistory.FieldSourceUpdatedAt:
		m.ClearSourceUpdatedAt()
		return nil
	case findinghistory.FieldExternalURI:
		m.ClearExternalURI()
		return nil
	case findinghistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	case findinghistory.FieldRawPayload:
		m.ClearRawPayload()
		return nil
	}
	return fmt.Errorf("unknown FindingHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FindingHistoryMutation) ResetField(name string) error {
	switch name {
	case findinghistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case findinghistory.FieldRef:
		m.ResetRef()
		return nil
	case findinghistory.FieldOperation:
		m.ResetOperation()
		return nil
	case findinghistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case findinghistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case findinghistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case findinghistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case findinghistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case findinghistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case findinghistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case findinghistory.FieldTags:
		m.ResetTags()
		return nil
	case findinghistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case findinghistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case findinghistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case findinghistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case findinghistory.FieldExternalID:
		m.ResetExternalID()
		return nil
	case findinghistory.FieldExternalOwnerID:
		m.ResetExternalOwnerID()
		return nil
	case findinghistory.FieldSource:
		m.ResetSource()
		return nil
	case findinghistory.FieldResourceName:
		m.ResetResourceName()
		return nil
	case findinghistory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case findinghistory.FieldState:
		m.ResetState()
		return nil
	case findinghistory.FieldCategory:
		m.ResetCategory()
		return nil
	case findinghistory.FieldCategories:
		m.ResetCategories()
		return nil
	case findinghistory.FieldFindingClass:
		m.ResetFindingClass()
		return nil
	case findinghistory.FieldSeverity:
		m.ResetSeverity()
		return nil
	case findinghistory.FieldNumericSeverity:
		m.ResetNumericSeverity()
		return nil
	case findinghistory.FieldScore:
		m.ResetScore()
		return nil
	case findinghistory.FieldImpact:
		m.ResetImpact()
		return nil
	case findinghistory.FieldExploitability:
		m.ResetExploitability()
		return nil
	case findinghistory.FieldPriority:
		m.ResetPriority()
		return nil
	case findinghistory.FieldOpen:
		m.ResetOpen()
		return nil
	case findinghistory.FieldBlocksProduction:
		m.ResetBlocksProduction()
		return nil
	case findinghistory.FieldProduction:
		m.ResetProduction()
		return nil
	case findinghistory.FieldPublic:
		m.ResetPublic()
		return nil
	case findinghistory.FieldValidated:
		m.ResetValidated()
		return nil
	case findinghistory.FieldAssessmentID:
		m.ResetAssessmentID()
		return nil
	case findinghistory.FieldDescription:
		m.ResetDescription()
		return nil
	case findinghistory.FieldRecommendation:
		m.ResetRecommendation()
		return nil
	case findinghistory.FieldRecommendedActions:
		m.ResetRecommendedActions()
		return nil
	case findinghistory.FieldReferences:
		m.ResetReferences()
		return nil
	case findinghistory.FieldStepsToReproduce:
		m.ResetStepsToReproduce()
		return nil
	case findinghistory.FieldTargets:
		m.ResetTargets()
		return nil
	case findinghistory.FieldTargetDetails:
		m.ResetTargetDetails()
		return nil
	case findinghistory.FieldVector:
		m.ResetVector()
		return nil
	case findinghistory.FieldRemediationSLA:
		m.ResetRemediationSLA()
		return nil
	case findinghistory.FieldStatus:
		m.ResetStatus()
		return nil
	case findinghistory.FieldEventTime:
		m.ResetEventTime()
		return nil
	case findinghistory.FieldReportedAt:
		m.ResetReportedAt()
		return nil
	case findinghistory.FieldSourceUpdatedAt:
		m.ResetSourceUpdatedAt()
		return nil
	case findinghistory.FieldExternalURI:
		m.ResetExternalURI()
		return nil
	case findinghistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	case findinghistory.FieldRawPayload:
		m.ResetRawPayload()
		return nil
	}
	return fmt.Errorf("unknown FindingHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FindingHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FindingHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FindingHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FindingHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FindingHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FindingHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FindingHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FindingHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FindingHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FindingHistory edge %s", name)
}

// GroupHistoryMutation represents an operation that mutates the GroupHistory nodes in the graph.
type GroupHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	history_time       *time.Time
	ref                *string
	operation          *history.OpType
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	deleted_at         *time.Time
	deleted_by         *string
	display_id         *string
	tags               *[]string
	appendtags         []string
	owner_id           *string
	name               *string
	description        *string
	is_managed         *bool
	gravatar_logo_url  *string
	logo_url           *string
	display_name       *string
	scim_external_id   *string
	scim_display_name  *string
	scim_active        *bool
	scim_group_mailing *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*GroupHistory, error)
	predicates         []predicate.GroupHistory
}

var _ ent.Mutation = (*GroupHistoryMutation)(nil)

// grouphistoryOption allows management of the mutation configuration using functional options.
type grouphistoryOption func(*GroupHistoryMutation)

// newGroupHistoryMutation creates new mutation for the GroupHistory entity.
func newGroupHistoryMutation(c config, op Op, opts ...grouphistoryOption) *GroupHistoryMutation {
	m := &GroupHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupHistoryID sets the ID field of the mutation.
func withGroupHistoryID(id string) grouphistoryOption {
	return func(m *GroupHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupHistory
		)
		m.oldValue = func(ctx context.Context) (*GroupHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupHistory sets the old GroupHistory of the mutation.
func withGroupHistory(node *GroupHistory) grouphistoryOption {
	return func(m *GroupHistoryMutation) {
		m.oldValue = func(context.Context) (*GroupHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GroupHistory entities.
func (m *GroupHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroupHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *GroupHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *GroupHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *GroupHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *GroupHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *GroupHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *GroupHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[grouphistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *GroupHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *GroupHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, grouphistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *GroupHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *GroupHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *GroupHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *GroupHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[grouphistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *GroupHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, grouphistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GroupHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[grouphistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GroupHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, grouphistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *GroupHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GroupHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *GroupHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[grouphistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *GroupHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GroupHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, grouphistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *GroupHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *GroupHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *GroupHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[grouphistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *GroupHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *GroupHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, grouphistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GroupHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GroupHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GroupHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[grouphistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GroupHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GroupHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, grouphistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *GroupHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *GroupHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *GroupHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[grouphistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *GroupHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *GroupHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, grouphistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *GroupHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *GroupHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *GroupHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *GroupHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *GroupHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *GroupHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *GroupHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *GroupHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[grouphistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *GroupHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *GroupHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, grouphistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *GroupHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *GroupHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *GroupHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[grouphistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *GroupHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *GroupHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, grouphistory.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *GroupHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *GroupHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GroupHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GroupHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[grouphistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GroupHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GroupHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, grouphistory.FieldDescription)
}

// SetIsManaged sets the "is_managed" field.
func (m *GroupHistoryMutation) SetIsManaged(b bool) {
	m.is_managed = &b
}

// IsManaged returns the value of the "is_managed" field in the mutation.
func (m *GroupHistoryMutation) IsManaged() (r bool, exists bool) {
	v := m.is_managed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsManaged returns the old "is_managed" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldIsManaged(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsManaged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsManaged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsManaged: %w", err)
	}
	return oldValue.IsManaged, nil
}

// ClearIsManaged clears the value of the "is_managed" field.
func (m *GroupHistoryMutation) ClearIsManaged() {
	m.is_managed = nil
	m.clearedFields[grouphistory.FieldIsManaged] = struct{}{}
}

// IsManagedCleared returns if the "is_managed" field was cleared in this mutation.
func (m *GroupHistoryMutation) IsManagedCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldIsManaged]
	return ok
}

// ResetIsManaged resets all changes to the "is_managed" field.
func (m *GroupHistoryMutation) ResetIsManaged() {
	m.is_managed = nil
	delete(m.clearedFields, grouphistory.FieldIsManaged)
}

// SetGravatarLogoURL sets the "gravatar_logo_url" field.
func (m *GroupHistoryMutation) SetGravatarLogoURL(s string) {
	m.gravatar_logo_url = &s
}

// GravatarLogoURL returns the value of the "gravatar_logo_url" field in the mutation.
func (m *GroupHistoryMutation) GravatarLogoURL() (r string, exists bool) {
	v := m.gravatar_logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGravatarLogoURL returns the old "gravatar_logo_url" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldGravatarLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGravatarLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGravatarLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGravatarLogoURL: %w", err)
	}
	return oldValue.GravatarLogoURL, nil
}

// ClearGravatarLogoURL clears the value of the "gravatar_logo_url" field.
func (m *GroupHistoryMutation) ClearGravatarLogoURL() {
	m.gravatar_logo_url = nil
	m.clearedFields[grouphistory.FieldGravatarLogoURL] = struct{}{}
}

// GravatarLogoURLCleared returns if the "gravatar_logo_url" field was cleared in this mutation.
func (m *GroupHistoryMutation) GravatarLogoURLCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldGravatarLogoURL]
	return ok
}

// ResetGravatarLogoURL resets all changes to the "gravatar_logo_url" field.
func (m *GroupHistoryMutation) ResetGravatarLogoURL() {
	m.gravatar_logo_url = nil
	delete(m.clearedFields, grouphistory.FieldGravatarLogoURL)
}

// SetLogoURL sets the "logo_url" field.
func (m *GroupHistoryMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *GroupHistoryMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *GroupHistoryMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[grouphistory.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *GroupHistoryMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *GroupHistoryMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, grouphistory.FieldLogoURL)
}

// SetDisplayName sets the "display_name" field.
func (m *GroupHistoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *GroupHistoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *GroupHistoryMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetScimExternalID sets the "scim_external_id" field.
func (m *GroupHistoryMutation) SetScimExternalID(s string) {
	m.scim_external_id = &s
}

// ScimExternalID returns the value of the "scim_external_id" field in the mutation.
func (m *GroupHistoryMutation) ScimExternalID() (r string, exists bool) {
	v := m.scim_external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScimExternalID returns the old "scim_external_id" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldScimExternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScimExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScimExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScimExternalID: %w", err)
	}
	return oldValue.ScimExternalID, nil
}

// ClearScimExternalID clears the value of the "scim_external_id" field.
func (m *GroupHistoryMutation) ClearScimExternalID() {
	m.scim_external_id = nil
	m.clearedFields[grouphistory.FieldScimExternalID] = struct{}{}
}

// ScimExternalIDCleared returns if the "scim_external_id" field was cleared in this mutation.
func (m *GroupHistoryMutation) ScimExternalIDCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldScimExternalID]
	return ok
}

// ResetScimExternalID resets all changes to the "scim_external_id" field.
func (m *GroupHistoryMutation) ResetScimExternalID() {
	m.scim_external_id = nil
	delete(m.clearedFields, grouphistory.FieldScimExternalID)
}

// SetScimDisplayName sets the "scim_display_name" field.
func (m *GroupHistoryMutation) SetScimDisplayName(s string) {
	m.scim_display_name = &s
}

// ScimDisplayName returns the value of the "scim_display_name" field in the mutation.
func (m *GroupHistoryMutation) ScimDisplayName() (r string, exists bool) {
	v := m.scim_display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldScimDisplayName returns the old "scim_display_name" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldScimDisplayName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScimDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScimDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScimDisplayName: %w", err)
	}
	return oldValue.ScimDisplayName, nil
}

// ClearScimDisplayName clears the value of the "scim_display_name" field.
func (m *GroupHistoryMutation) ClearScimDisplayName() {
	m.scim_display_name = nil
	m.clearedFields[grouphistory.FieldScimDisplayName] = struct{}{}
}

// ScimDisplayNameCleared returns if the "scim_display_name" field was cleared in this mutation.
func (m *GroupHistoryMutation) ScimDisplayNameCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldScimDisplayName]
	return ok
}

// ResetScimDisplayName resets all changes to the "scim_display_name" field.
func (m *GroupHistoryMutation) ResetScimDisplayName() {
	m.scim_display_name = nil
	delete(m.clearedFields, grouphistory.FieldScimDisplayName)
}

// SetScimActive sets the "scim_active" field.
func (m *GroupHistoryMutation) SetScimActive(b bool) {
	m.scim_active = &b
}

// ScimActive returns the value of the "scim_active" field in the mutation.
func (m *GroupHistoryMutation) ScimActive() (r bool, exists bool) {
	v := m.scim_active
	if v == nil {
		return
	}
	return *v, true
}

// OldScimActive returns the old "scim_active" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldScimActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScimActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScimActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScimActive: %w", err)
	}
	return oldValue.ScimActive, nil
}

// ClearScimActive clears the value of the "scim_active" field.
func (m *GroupHistoryMutation) ClearScimActive() {
	m.scim_active = nil
	m.clearedFields[grouphistory.FieldScimActive] = struct{}{}
}

// ScimActiveCleared returns if the "scim_active" field was cleared in this mutation.
func (m *GroupHistoryMutation) ScimActiveCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldScimActive]
	return ok
}

// ResetScimActive resets all changes to the "scim_active" field.
func (m *GroupHistoryMutation) ResetScimActive() {
	m.scim_active = nil
	delete(m.clearedFields, grouphistory.FieldScimActive)
}

// SetScimGroupMailing sets the "scim_group_mailing" field.
func (m *GroupHistoryMutation) SetScimGroupMailing(s string) {
	m.scim_group_mailing = &s
}

// ScimGroupMailing returns the value of the "scim_group_mailing" field in the mutation.
func (m *GroupHistoryMutation) ScimGroupMailing() (r string, exists bool) {
	v := m.scim_group_mailing
	if v == nil {
		return
	}
	return *v, true
}

// OldScimGroupMailing returns the old "scim_group_mailing" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldScimGroupMailing(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScimGroupMailing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScimGroupMailing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScimGroupMailing: %w", err)
	}
	return oldValue.ScimGroupMailing, nil
}

// ClearScimGroupMailing clears the value of the "scim_group_mailing" field.
func (m *GroupHistoryMutation) ClearScimGroupMailing() {
	m.scim_group_mailing = nil
	m.clearedFields[grouphistory.FieldScimGroupMailing] = struct{}{}
}

// ScimGroupMailingCleared returns if the "scim_group_mailing" field was cleared in this mutation.
func (m *GroupHistoryMutation) ScimGroupMailingCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldScimGroupMailing]
	return ok
}

// ResetScimGroupMailing resets all changes to the "scim_group_mailing" field.
func (m *GroupHistoryMutation) ResetScimGroupMailing() {
	m.scim_group_mailing = nil
	delete(m.clearedFields, grouphistory.FieldScimGroupMailing)
}

// Where appends a list predicates to the GroupHistoryMutation builder.
func (m *GroupHistoryMutation) Where(ps ...predicate.GroupHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroupHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroupHistory).
func (m *GroupHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupHistoryMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.history_time != nil {
		fields = append(fields, grouphistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, grouphistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, grouphistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, grouphistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, grouphistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, grouphistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, grouphistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, grouphistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, grouphistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, grouphistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, grouphistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, grouphistory.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, grouphistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, grouphistory.FieldDescription)
	}
	if m.is_managed != nil {
		fields = append(fields, grouphistory.FieldIsManaged)
	}
	if m.gravatar_logo_url != nil {
		fields = append(fields, grouphistory.FieldGravatarLogoURL)
	}
	if m.logo_url != nil {
		fields = append(fields, grouphistory.FieldLogoURL)
	}
	if m.display_name != nil {
		fields = append(fields, grouphistory.FieldDisplayName)
	}
	if m.scim_external_id != nil {
		fields = append(fields, grouphistory.FieldScimExternalID)
	}
	if m.scim_display_name != nil {
		fields = append(fields, grouphistory.FieldScimDisplayName)
	}
	if m.scim_active != nil {
		fields = append(fields, grouphistory.FieldScimActive)
	}
	if m.scim_group_mailing != nil {
		fields = append(fields, grouphistory.FieldScimGroupMailing)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grouphistory.FieldHistoryTime:
		return m.HistoryTime()
	case grouphistory.FieldRef:
		return m.Ref()
	case grouphistory.FieldOperation:
		return m.Operation()
	case grouphistory.FieldCreatedAt:
		return m.CreatedAt()
	case grouphistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case grouphistory.FieldCreatedBy:
		return m.CreatedBy()
	case grouphistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case grouphistory.FieldDeletedAt:
		return m.DeletedAt()
	case grouphistory.FieldDeletedBy:
		return m.DeletedBy()
	case grouphistory.FieldDisplayID:
		return m.DisplayID()
	case grouphistory.FieldTags:
		return m.Tags()
	case grouphistory.FieldOwnerID:
		return m.OwnerID()
	case grouphistory.FieldName:
		return m.Name()
	case grouphistory.FieldDescription:
		return m.Description()
	case grouphistory.FieldIsManaged:
		return m.IsManaged()
	case grouphistory.FieldGravatarLogoURL:
		return m.GravatarLogoURL()
	case grouphistory.FieldLogoURL:
		return m.LogoURL()
	case grouphistory.FieldDisplayName:
		return m.DisplayName()
	case grouphistory.FieldScimExternalID:
		return m.ScimExternalID()
	case grouphistory.FieldScimDisplayName:
		return m.ScimDisplayName()
	case grouphistory.FieldScimActive:
		return m.ScimActive()
	case grouphistory.FieldScimGroupMailing:
		return m.ScimGroupMailing()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grouphistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case grouphistory.FieldRef:
		return m.OldRef(ctx)
	case grouphistory.FieldOperation:
		return m.OldOperation(ctx)
	case grouphistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case grouphistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case grouphistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case grouphistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case grouphistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case grouphistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case grouphistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case grouphistory.FieldTags:
		return m.OldTags(ctx)
	case grouphistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case grouphistory.FieldName:
		return m.OldName(ctx)
	case grouphistory.FieldDescription:
		return m.OldDescription(ctx)
	case grouphistory.FieldIsManaged:
		return m.OldIsManaged(ctx)
	case grouphistory.FieldGravatarLogoURL:
		return m.OldGravatarLogoURL(ctx)
	case grouphistory.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case grouphistory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case grouphistory.FieldScimExternalID:
		return m.OldScimExternalID(ctx)
	case grouphistory.FieldScimDisplayName:
		return m.OldScimDisplayName(ctx)
	case grouphistory.FieldScimActive:
		return m.OldScimActive(ctx)
	case grouphistory.FieldScimGroupMailing:
		return m.OldScimGroupMailing(ctx)
	}
	return nil, fmt.Errorf("unknown GroupHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grouphistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case grouphistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case grouphistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case grouphistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case grouphistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case grouphistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case grouphistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case grouphistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case grouphistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case grouphistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case grouphistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case grouphistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case grouphistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case grouphistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case grouphistory.FieldIsManaged:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsManaged(v)
		return nil
	case grouphistory.FieldGravatarLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGravatarLogoURL(v)
		return nil
	case grouphistory.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case grouphistory.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case grouphistory.FieldScimExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScimExternalID(v)
		return nil
	case grouphistory.FieldScimDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScimDisplayName(v)
		return nil
	case grouphistory.FieldScimActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScimActive(v)
		return nil
	case grouphistory.FieldScimGroupMailing:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScimGroupMailing(v)
		return nil
	}
	return fmt.Errorf("unknown GroupHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GroupHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(grouphistory.FieldRef) {
		fields = append(fields, grouphistory.FieldRef)
	}
	if m.FieldCleared(grouphistory.FieldCreatedAt) {
		fields = append(fields, grouphistory.FieldCreatedAt)
	}
	if m.FieldCleared(grouphistory.FieldUpdatedAt) {
		fields = append(fields, grouphistory.FieldUpdatedAt)
	}
	if m.FieldCleared(grouphistory.FieldCreatedBy) {
		fields = append(fields, grouphistory.FieldCreatedBy)
	}
	if m.FieldCleared(grouphistory.FieldUpdatedBy) {
		fields = append(fields, grouphistory.FieldUpdatedBy)
	}
	if m.FieldCleared(grouphistory.FieldDeletedAt) {
		fields = append(fields, grouphistory.FieldDeletedAt)
	}
	if m.FieldCleared(grouphistory.FieldDeletedBy) {
		fields = append(fields, grouphistory.FieldDeletedBy)
	}
	if m.FieldCleared(grouphistory.FieldTags) {
		fields = append(fields, grouphistory.FieldTags)
	}
	if m.FieldCleared(grouphistory.FieldOwnerID) {
		fields = append(fields, grouphistory.FieldOwnerID)
	}
	if m.FieldCleared(grouphistory.FieldDescription) {
		fields = append(fields, grouphistory.FieldDescription)
	}
	if m.FieldCleared(grouphistory.FieldIsManaged) {
		fields = append(fields, grouphistory.FieldIsManaged)
	}
	if m.FieldCleared(grouphistory.FieldGravatarLogoURL) {
		fields = append(fields, grouphistory.FieldGravatarLogoURL)
	}
	if m.FieldCleared(grouphistory.FieldLogoURL) {
		fields = append(fields, grouphistory.FieldLogoURL)
	}
	if m.FieldCleared(grouphistory.FieldScimExternalID) {
		fields = append(fields, grouphistory.FieldScimExternalID)
	}
	if m.FieldCleared(grouphistory.FieldScimDisplayName) {
		fields = append(fields, grouphistory.FieldScimDisplayName)
	}
	if m.FieldCleared(grouphistory.FieldScimActive) {
		fields = append(fields, grouphistory.FieldScimActive)
	}
	if m.FieldCleared(grouphistory.FieldScimGroupMailing) {
		fields = append(fields, grouphistory.FieldScimGroupMailing)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupHistoryMutation) ClearField(name string) error {
	switch name {
	case grouphistory.FieldRef:
		m.ClearRef()
		return nil
	case grouphistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case grouphistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case grouphistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case grouphistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case grouphistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case grouphistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case grouphistory.FieldTags:
		m.ClearTags()
		return nil
	case grouphistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case grouphistory.FieldDescription:
		m.ClearDescription()
		return nil
	case grouphistory.FieldIsManaged:
		m.ClearIsManaged()
		return nil
	case grouphistory.FieldGravatarLogoURL:
		m.ClearGravatarLogoURL()
		return nil
	case grouphistory.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	case grouphistory.FieldScimExternalID:
		m.ClearScimExternalID()
		return nil
	case grouphistory.FieldScimDisplayName:
		m.ClearScimDisplayName()
		return nil
	case grouphistory.FieldScimActive:
		m.ClearScimActive()
		return nil
	case grouphistory.FieldScimGroupMailing:
		m.ClearScimGroupMailing()
		return nil
	}
	return fmt.Errorf("unknown GroupHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupHistoryMutation) ResetField(name string) error {
	switch name {
	case grouphistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case grouphistory.FieldRef:
		m.ResetRef()
		return nil
	case grouphistory.FieldOperation:
		m.ResetOperation()
		return nil
	case grouphistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case grouphistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case grouphistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case grouphistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case grouphistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case grouphistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case grouphistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case grouphistory.FieldTags:
		m.ResetTags()
		return nil
	case grouphistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case grouphistory.FieldName:
		m.ResetName()
		return nil
	case grouphistory.FieldDescription:
		m.ResetDescription()
		return nil
	case grouphistory.FieldIsManaged:
		m.ResetIsManaged()
		return nil
	case grouphistory.FieldGravatarLogoURL:
		m.ResetGravatarLogoURL()
		return nil
	case grouphistory.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case grouphistory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case grouphistory.FieldScimExternalID:
		m.ResetScimExternalID()
		return nil
	case grouphistory.FieldScimDisplayName:
		m.ResetScimDisplayName()
		return nil
	case grouphistory.FieldScimActive:
		m.ResetScimActive()
		return nil
	case grouphistory.FieldScimGroupMailing:
		m.ResetScimGroupMailing()
		return nil
	}
	return fmt.Errorf("unknown GroupHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GroupHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GroupHistory edge %s", name)
}

// GroupMembershipHistoryMutation represents an operation that mutates the GroupMembershipHistory nodes in the graph.
type GroupMembershipHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	role          *enums.Role
	group_id      *string
	user_id       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GroupMembershipHistory, error)
	predicates    []predicate.GroupMembershipHistory
}

var _ ent.Mutation = (*GroupMembershipHistoryMutation)(nil)

// groupmembershiphistoryOption allows management of the mutation configuration using functional options.
type groupmembershiphistoryOption func(*GroupMembershipHistoryMutation)

// newGroupMembershipHistoryMutation creates new mutation for the GroupMembershipHistory entity.
func newGroupMembershipHistoryMutation(c config, op Op, opts ...groupmembershiphistoryOption) *GroupMembershipHistoryMutation {
	m := &GroupMembershipHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupMembershipHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupMembershipHistoryID sets the ID field of the mutation.
func withGroupMembershipHistoryID(id string) groupmembershiphistoryOption {
	return func(m *GroupMembershipHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupMembershipHistory
		)
		m.oldValue = func(ctx context.Context) (*GroupMembershipHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupMembershipHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupMembershipHistory sets the old GroupMembershipHistory of the mutation.
func withGroupMembershipHistory(node *GroupMembershipHistory) groupmembershiphistoryOption {
	return func(m *GroupMembershipHistoryMutation) {
		m.oldValue = func(context.Context) (*GroupMembershipHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMembershipHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMembershipHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GroupMembershipHistory entities.
func (m *GroupMembershipHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMembershipHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMembershipHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroupMembershipHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *GroupMembershipHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *GroupMembershipHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *GroupMembershipHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *GroupMembershipHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *GroupMembershipHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *GroupMembershipHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[groupmembershiphistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *GroupMembershipHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[groupmembershiphistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *GroupMembershipHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, groupmembershiphistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *GroupMembershipHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *GroupMembershipHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *GroupMembershipHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMembershipHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMembershipHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *GroupMembershipHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[groupmembershiphistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *GroupMembershipHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[groupmembershiphistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMembershipHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, groupmembershiphistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupMembershipHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupMembershipHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GroupMembershipHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[groupmembershiphistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GroupMembershipHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[groupmembershiphistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupMembershipHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, groupmembershiphistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *GroupMembershipHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GroupMembershipHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *GroupMembershipHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[groupmembershiphistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *GroupMembershipHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[groupmembershiphistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GroupMembershipHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, groupmembershiphistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *GroupMembershipHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *GroupMembershipHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *GroupMembershipHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[groupmembershiphistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *GroupMembershipHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[groupmembershiphistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *GroupMembershipHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, groupmembershiphistory.FieldUpdatedBy)
}

// SetRole sets the "role" field.
func (m *GroupMembershipHistoryMutation) SetRole(e enums.Role) {
	m.role = &e
}

// Role returns the value of the "role" field in the mutation.
func (m *GroupMembershipHistoryMutation) Role() (r enums.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldRole(ctx context.Context) (v enums.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *GroupMembershipHistoryMutation) ResetRole() {
	m.role = nil
}

// SetGroupID sets the "group_id" field.
func (m *GroupMembershipHistoryMutation) SetGroupID(s string) {
	m.group_id = &s
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *GroupMembershipHistoryMutation) GroupID() (r string, exists bool) {
	v := m.group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *GroupMembershipHistoryMutation) ResetGroupID() {
	m.group_id = nil
}

// SetUserID sets the "user_id" field.
func (m *GroupMembershipHistoryMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *GroupMembershipHistoryMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *GroupMembershipHistoryMutation) ResetUserID() {
	m.user_id = nil
}

// Where appends a list predicates to the GroupMembershipHistoryMutation builder.
func (m *GroupMembershipHistoryMutation) Where(ps ...predicate.GroupMembershipHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMembershipHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMembershipHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroupMembershipHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMembershipHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMembershipHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroupMembershipHistory).
func (m *GroupMembershipHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMembershipHistoryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.history_time != nil {
		fields = append(fields, groupmembershiphistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, groupmembershiphistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, groupmembershiphistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, groupmembershiphistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, groupmembershiphistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, groupmembershiphistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, groupmembershiphistory.FieldUpdatedBy)
	}
	if m.role != nil {
		fields = append(fields, groupmembershiphistory.FieldRole)
	}
	if m.group_id != nil {
		fields = append(fields, groupmembershiphistory.FieldGroupID)
	}
	if m.user_id != nil {
		fields = append(fields, groupmembershiphistory.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMembershipHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupmembershiphistory.FieldHistoryTime:
		return m.HistoryTime()
	case groupmembershiphistory.FieldRef:
		return m.Ref()
	case groupmembershiphistory.FieldOperation:
		return m.Operation()
	case groupmembershiphistory.FieldCreatedAt:
		return m.CreatedAt()
	case groupmembershiphistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case groupmembershiphistory.FieldCreatedBy:
		return m.CreatedBy()
	case groupmembershiphistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case groupmembershiphistory.FieldRole:
		return m.Role()
	case groupmembershiphistory.FieldGroupID:
		return m.GroupID()
	case groupmembershiphistory.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMembershipHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupmembershiphistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case groupmembershiphistory.FieldRef:
		return m.OldRef(ctx)
	case groupmembershiphistory.FieldOperation:
		return m.OldOperation(ctx)
	case groupmembershiphistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case groupmembershiphistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case groupmembershiphistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case groupmembershiphistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case groupmembershiphistory.FieldRole:
		return m.OldRole(ctx)
	case groupmembershiphistory.FieldGroupID:
		return m.OldGroupID(ctx)
	case groupmembershiphistory.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown GroupMembershipHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMembershipHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupmembershiphistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case groupmembershiphistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case groupmembershiphistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case groupmembershiphistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case groupmembershiphistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case groupmembershiphistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case groupmembershiphistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case groupmembershiphistory.FieldRole:
		v, ok := value.(enums.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case groupmembershiphistory.FieldGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case groupmembershiphistory.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown GroupMembershipHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMembershipHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMembershipHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMembershipHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GroupMembershipHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMembershipHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(groupmembershiphistory.FieldRef) {
		fields = append(fields, groupmembershiphistory.FieldRef)
	}
	if m.FieldCleared(groupmembershiphistory.FieldCreatedAt) {
		fields = append(fields, groupmembershiphistory.FieldCreatedAt)
	}
	if m.FieldCleared(groupmembershiphistory.FieldUpdatedAt) {
		fields = append(fields, groupmembershiphistory.FieldUpdatedAt)
	}
	if m.FieldCleared(groupmembershiphistory.FieldCreatedBy) {
		fields = append(fields, groupmembershiphistory.FieldCreatedBy)
	}
	if m.FieldCleared(groupmembershiphistory.FieldUpdatedBy) {
		fields = append(fields, groupmembershiphistory.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMembershipHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMembershipHistoryMutation) ClearField(name string) error {
	switch name {
	case groupmembershiphistory.FieldRef:
		m.ClearRef()
		return nil
	case groupmembershiphistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case groupmembershiphistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case groupmembershiphistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case groupmembershiphistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown GroupMembershipHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMembershipHistoryMutation) ResetField(name string) error {
	switch name {
	case groupmembershiphistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case groupmembershiphistory.FieldRef:
		m.ResetRef()
		return nil
	case groupmembershiphistory.FieldOperation:
		m.ResetOperation()
		return nil
	case groupmembershiphistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case groupmembershiphistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case groupmembershiphistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case groupmembershiphistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case groupmembershiphistory.FieldRole:
		m.ResetRole()
		return nil
	case groupmembershiphistory.FieldGroupID:
		m.ResetGroupID()
		return nil
	case groupmembershiphistory.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown GroupMembershipHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMembershipHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMembershipHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMembershipHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMembershipHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMembershipHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMembershipHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMembershipHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GroupMembershipHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMembershipHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GroupMembershipHistory edge %s", name)
}

// GroupSettingHistoryMutation represents an operation that mutates the GroupSettingHistory nodes in the graph.
type GroupSettingHistoryMutation struct {
	config
	op             Op
	typ            string
	id             *string
	history_time   *time.Time
	ref            *string
	operation      *history.OpType
	created_at     *time.Time
	updated_at     *time.Time
	created_by     *string
	updated_by     *string
	deleted_at     *time.Time
	deleted_by     *string
	visibility     *enums.Visibility
	join_policy    *enums.JoinPolicy
	sync_to_slack  *bool
	sync_to_github *bool
	group_id       *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*GroupSettingHistory, error)
	predicates     []predicate.GroupSettingHistory
}

var _ ent.Mutation = (*GroupSettingHistoryMutation)(nil)

// groupsettinghistoryOption allows management of the mutation configuration using functional options.
type groupsettinghistoryOption func(*GroupSettingHistoryMutation)

// newGroupSettingHistoryMutation creates new mutation for the GroupSettingHistory entity.
func newGroupSettingHistoryMutation(c config, op Op, opts ...groupsettinghistoryOption) *GroupSettingHistoryMutation {
	m := &GroupSettingHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupSettingHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupSettingHistoryID sets the ID field of the mutation.
func withGroupSettingHistoryID(id string) groupsettinghistoryOption {
	return func(m *GroupSettingHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupSettingHistory
		)
		m.oldValue = func(ctx context.Context) (*GroupSettingHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupSettingHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupSettingHistory sets the old GroupSettingHistory of the mutation.
func withGroupSettingHistory(node *GroupSettingHistory) groupsettinghistoryOption {
	return func(m *GroupSettingHistoryMutation) {
		m.oldValue = func(context.Context) (*GroupSettingHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupSettingHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupSettingHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GroupSettingHistory entities.
func (m *GroupSettingHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupSettingHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupSettingHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroupSettingHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *GroupSettingHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *GroupSettingHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *GroupSettingHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *GroupSettingHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *GroupSettingHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *GroupSettingHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[groupsettinghistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *GroupSettingHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, groupsettinghistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *GroupSettingHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *GroupSettingHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *GroupSettingHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupSettingHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupSettingHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *GroupSettingHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[groupsettinghistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupSettingHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, groupsettinghistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupSettingHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupSettingHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GroupSettingHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[groupsettinghistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupSettingHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, groupsettinghistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *GroupSettingHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GroupSettingHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *GroupSettingHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[groupsettinghistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GroupSettingHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, groupsettinghistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *GroupSettingHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *GroupSettingHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *GroupSettingHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[groupsettinghistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *GroupSettingHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, groupsettinghistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GroupSettingHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GroupSettingHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GroupSettingHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[groupsettinghistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GroupSettingHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, groupsettinghistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *GroupSettingHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *GroupSettingHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *GroupSettingHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[groupsettinghistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *GroupSettingHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, groupsettinghistory.FieldDeletedBy)
}

// SetVisibility sets the "visibility" field.
func (m *GroupSettingHistoryMutation) SetVisibility(e enums.Visibility) {
	m.visibility = &e
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *GroupSettingHistoryMutation) Visibility() (r enums.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldVisibility(ctx context.Context) (v enums.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *GroupSettingHistoryMutation) ResetVisibility() {
	m.visibility = nil
}

// SetJoinPolicy sets the "join_policy" field.
func (m *GroupSettingHistoryMutation) SetJoinPolicy(ep enums.JoinPolicy) {
	m.join_policy = &ep
}

// JoinPolicy returns the value of the "join_policy" field in the mutation.
func (m *GroupSettingHistoryMutation) JoinPolicy() (r enums.JoinPolicy, exists bool) {
	v := m.join_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinPolicy returns the old "join_policy" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldJoinPolicy(ctx context.Context) (v enums.JoinPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinPolicy: %w", err)
	}
	return oldValue.JoinPolicy, nil
}

// ResetJoinPolicy resets all changes to the "join_policy" field.
func (m *GroupSettingHistoryMutation) ResetJoinPolicy() {
	m.join_policy = nil
}

// SetSyncToSlack sets the "sync_to_slack" field.
func (m *GroupSettingHistoryMutation) SetSyncToSlack(b bool) {
	m.sync_to_slack = &b
}

// SyncToSlack returns the value of the "sync_to_slack" field in the mutation.
func (m *GroupSettingHistoryMutation) SyncToSlack() (r bool, exists bool) {
	v := m.sync_to_slack
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncToSlack returns the old "sync_to_slack" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldSyncToSlack(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncToSlack is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncToSlack requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncToSlack: %w", err)
	}
	return oldValue.SyncToSlack, nil
}

// ClearSyncToSlack clears the value of the "sync_to_slack" field.
func (m *GroupSettingHistoryMutation) ClearSyncToSlack() {
	m.sync_to_slack = nil
	m.clearedFields[groupsettinghistory.FieldSyncToSlack] = struct{}{}
}

// SyncToSlackCleared returns if the "sync_to_slack" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) SyncToSlackCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldSyncToSlack]
	return ok
}

// ResetSyncToSlack resets all changes to the "sync_to_slack" field.
func (m *GroupSettingHistoryMutation) ResetSyncToSlack() {
	m.sync_to_slack = nil
	delete(m.clearedFields, groupsettinghistory.FieldSyncToSlack)
}

// SetSyncToGithub sets the "sync_to_github" field.
func (m *GroupSettingHistoryMutation) SetSyncToGithub(b bool) {
	m.sync_to_github = &b
}

// SyncToGithub returns the value of the "sync_to_github" field in the mutation.
func (m *GroupSettingHistoryMutation) SyncToGithub() (r bool, exists bool) {
	v := m.sync_to_github
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncToGithub returns the old "sync_to_github" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldSyncToGithub(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncToGithub is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncToGithub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncToGithub: %w", err)
	}
	return oldValue.SyncToGithub, nil
}

// ClearSyncToGithub clears the value of the "sync_to_github" field.
func (m *GroupSettingHistoryMutation) ClearSyncToGithub() {
	m.sync_to_github = nil
	m.clearedFields[groupsettinghistory.FieldSyncToGithub] = struct{}{}
}

// SyncToGithubCleared returns if the "sync_to_github" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) SyncToGithubCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldSyncToGithub]
	return ok
}

// ResetSyncToGithub resets all changes to the "sync_to_github" field.
func (m *GroupSettingHistoryMutation) ResetSyncToGithub() {
	m.sync_to_github = nil
	delete(m.clearedFields, groupsettinghistory.FieldSyncToGithub)
}

// SetGroupID sets the "group_id" field.
func (m *GroupSettingHistoryMutation) SetGroupID(s string) {
	m.group_id = &s
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *GroupSettingHistoryMutation) GroupID() (r string, exists bool) {
	v := m.group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *GroupSettingHistoryMutation) ClearGroupID() {
	m.group_id = nil
	m.clearedFields[groupsettinghistory.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *GroupSettingHistoryMutation) ResetGroupID() {
	m.group_id = nil
	delete(m.clearedFields, groupsettinghistory.FieldGroupID)
}

// Where appends a list predicates to the GroupSettingHistoryMutation builder.
func (m *GroupSettingHistoryMutation) Where(ps ...predicate.GroupSettingHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupSettingHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupSettingHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroupSettingHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupSettingHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupSettingHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroupSettingHistory).
func (m *GroupSettingHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupSettingHistoryMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.history_time != nil {
		fields = append(fields, groupsettinghistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, groupsettinghistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, groupsettinghistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, groupsettinghistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, groupsettinghistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, groupsettinghistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, groupsettinghistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, groupsettinghistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, groupsettinghistory.FieldDeletedBy)
	}
	if m.visibility != nil {
		fields = append(fields, groupsettinghistory.FieldVisibility)
	}
	if m.join_policy != nil {
		fields = append(fields, groupsettinghistory.FieldJoinPolicy)
	}
	if m.sync_to_slack != nil {
		fields = append(fields, groupsettinghistory.FieldSyncToSlack)
	}
	if m.sync_to_github != nil {
		fields = append(fields, groupsettinghistory.FieldSyncToGithub)
	}
	if m.group_id != nil {
		fields = append(fields, groupsettinghistory.FieldGroupID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupSettingHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupsettinghistory.FieldHistoryTime:
		return m.HistoryTime()
	case groupsettinghistory.FieldRef:
		return m.Ref()
	case groupsettinghistory.FieldOperation:
		return m.Operation()
	case groupsettinghistory.FieldCreatedAt:
		return m.CreatedAt()
	case groupsettinghistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case groupsettinghistory.FieldCreatedBy:
		return m.CreatedBy()
	case groupsettinghistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case groupsettinghistory.FieldDeletedAt:
		return m.DeletedAt()
	case groupsettinghistory.FieldDeletedBy:
		return m.DeletedBy()
	case groupsettinghistory.FieldVisibility:
		return m.Visibility()
	case groupsettinghistory.FieldJoinPolicy:
		return m.JoinPolicy()
	case groupsettinghistory.FieldSyncToSlack:
		return m.SyncToSlack()
	case groupsettinghistory.FieldSyncToGithub:
		return m.SyncToGithub()
	case groupsettinghistory.FieldGroupID:
		return m.GroupID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupSettingHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupsettinghistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case groupsettinghistory.FieldRef:
		return m.OldRef(ctx)
	case groupsettinghistory.FieldOperation:
		return m.OldOperation(ctx)
	case groupsettinghistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case groupsettinghistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case groupsettinghistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case groupsettinghistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case groupsettinghistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case groupsettinghistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case groupsettinghistory.FieldVisibility:
		return m.OldVisibility(ctx)
	case groupsettinghistory.FieldJoinPolicy:
		return m.OldJoinPolicy(ctx)
	case groupsettinghistory.FieldSyncToSlack:
		return m.OldSyncToSlack(ctx)
	case groupsettinghistory.FieldSyncToGithub:
		return m.OldSyncToGithub(ctx)
	case groupsettinghistory.FieldGroupID:
		return m.OldGroupID(ctx)
	}
	return nil, fmt.Errorf("unknown GroupSettingHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupSettingHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupsettinghistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case groupsettinghistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case groupsettinghistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case groupsettinghistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case groupsettinghistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case groupsettinghistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case groupsettinghistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case groupsettinghistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case groupsettinghistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case groupsettinghistory.FieldVisibility:
		v, ok := value.(enums.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case groupsettinghistory.FieldJoinPolicy:
		v, ok := value.(enums.JoinPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinPolicy(v)
		return nil
	case groupsettinghistory.FieldSyncToSlack:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncToSlack(v)
		return nil
	case groupsettinghistory.FieldSyncToGithub:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncToGithub(v)
		return nil
	case groupsettinghistory.FieldGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	}
	return fmt.Errorf("unknown GroupSettingHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupSettingHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupSettingHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupSettingHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GroupSettingHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupSettingHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(groupsettinghistory.FieldRef) {
		fields = append(fields, groupsettinghistory.FieldRef)
	}
	if m.FieldCleared(groupsettinghistory.FieldCreatedAt) {
		fields = append(fields, groupsettinghistory.FieldCreatedAt)
	}
	if m.FieldCleared(groupsettinghistory.FieldUpdatedAt) {
		fields = append(fields, groupsettinghistory.FieldUpdatedAt)
	}
	if m.FieldCleared(groupsettinghistory.FieldCreatedBy) {
		fields = append(fields, groupsettinghistory.FieldCreatedBy)
	}
	if m.FieldCleared(groupsettinghistory.FieldUpdatedBy) {
		fields = append(fields, groupsettinghistory.FieldUpdatedBy)
	}
	if m.FieldCleared(groupsettinghistory.FieldDeletedAt) {
		fields = append(fields, groupsettinghistory.FieldDeletedAt)
	}
	if m.FieldCleared(groupsettinghistory.FieldDeletedBy) {
		fields = append(fields, groupsettinghistory.FieldDeletedBy)
	}
	if m.FieldCleared(groupsettinghistory.FieldSyncToSlack) {
		fields = append(fields, groupsettinghistory.FieldSyncToSlack)
	}
	if m.FieldCleared(groupsettinghistory.FieldSyncToGithub) {
		fields = append(fields, groupsettinghistory.FieldSyncToGithub)
	}
	if m.FieldCleared(groupsettinghistory.FieldGroupID) {
		fields = append(fields, groupsettinghistory.FieldGroupID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupSettingHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupSettingHistoryMutation) ClearField(name string) error {
	switch name {
	case groupsettinghistory.FieldRef:
		m.ClearRef()
		return nil
	case groupsettinghistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case groupsettinghistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case groupsettinghistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case groupsettinghistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case groupsettinghistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case groupsettinghistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case groupsettinghistory.FieldSyncToSlack:
		m.ClearSyncToSlack()
		return nil
	case groupsettinghistory.FieldSyncToGithub:
		m.ClearSyncToGithub()
		return nil
	case groupsettinghistory.FieldGroupID:
		m.ClearGroupID()
		return nil
	}
	return fmt.Errorf("unknown GroupSettingHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupSettingHistoryMutation) ResetField(name string) error {
	switch name {
	case groupsettinghistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case groupsettinghistory.FieldRef:
		m.ResetRef()
		return nil
	case groupsettinghistory.FieldOperation:
		m.ResetOperation()
		return nil
	case groupsettinghistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case groupsettinghistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case groupsettinghistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case groupsettinghistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case groupsettinghistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case groupsettinghistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case groupsettinghistory.FieldVisibility:
		m.ResetVisibility()
		return nil
	case groupsettinghistory.FieldJoinPolicy:
		m.ResetJoinPolicy()
		return nil
	case groupsettinghistory.FieldSyncToSlack:
		m.ResetSyncToSlack()
		return nil
	case groupsettinghistory.FieldSyncToGithub:
		m.ResetSyncToGithub()
		return nil
	case groupsettinghistory.FieldGroupID:
		m.ResetGroupID()
		return nil
	}
	return fmt.Errorf("unknown GroupSettingHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupSettingHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupSettingHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupSettingHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupSettingHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupSettingHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupSettingHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupSettingHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GroupSettingHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupSettingHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GroupSettingHistory edge %s", name)
}

// HushHistoryMutation represents an operation that mutates the HushHistory nodes in the graph.
type HushHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	history_time       *time.Time
	ref                *string
	operation          *history.OpType
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	deleted_at         *time.Time
	deleted_by         *string
	owner_id           *string
	system_owned       *bool
	internal_notes     *string
	system_internal_id *string
	name               *string
	description        *string
	kind               *string
	secret_name        *string
	secret_value       *string
	credential_set     *models.CredentialSet
	metadata           *map[string]interface{}
	last_used_at       *time.Time
	expires_at         *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*HushHistory, error)
	predicates         []predicate.HushHistory
}

var _ ent.Mutation = (*HushHistoryMutation)(nil)

// hushhistoryOption allows management of the mutation configuration using functional options.
type hushhistoryOption func(*HushHistoryMutation)

// newHushHistoryMutation creates new mutation for the HushHistory entity.
func newHushHistoryMutation(c config, op Op, opts ...hushhistoryOption) *HushHistoryMutation {
	m := &HushHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeHushHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHushHistoryID sets the ID field of the mutation.
func withHushHistoryID(id string) hushhistoryOption {
	return func(m *HushHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *HushHistory
		)
		m.oldValue = func(ctx context.Context) (*HushHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HushHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHushHistory sets the old HushHistory of the mutation.
func withHushHistory(node *HushHistory) hushhistoryOption {
	return func(m *HushHistoryMutation) {
		m.oldValue = func(context.Context) (*HushHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HushHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HushHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HushHistory entities.
func (m *HushHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HushHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HushHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HushHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *HushHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *HushHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *HushHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *HushHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *HushHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *HushHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[hushhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *HushHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *HushHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, hushhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *HushHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *HushHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *HushHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HushHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HushHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HushHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hushhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HushHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HushHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hushhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HushHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HushHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HushHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hushhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HushHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HushHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hushhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *HushHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *HushHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *HushHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[hushhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *HushHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *HushHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, hushhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *HushHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *HushHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *HushHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[hushhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *HushHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *HushHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, hushhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *HushHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *HushHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *HushHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[hushhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *HushHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *HushHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, hushhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *HushHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *HushHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *HushHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[hushhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *HushHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *HushHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, hushhistory.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *HushHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *HushHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *HushHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[hushhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *HushHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *HushHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, hushhistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *HushHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *HushHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *HushHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[hushhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *HushHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *HushHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, hushhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *HushHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *HushHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *HushHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[hushhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *HushHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *HushHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, hushhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *HushHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *HushHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *HushHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[hushhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *HushHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *HushHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, hushhistory.FieldSystemInternalID)
}

// SetName sets the "name" field.
func (m *HushHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HushHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HushHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *HushHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HushHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *HushHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[hushhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *HushHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *HushHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, hushhistory.FieldDescription)
}

// SetKind sets the "kind" field.
func (m *HushHistoryMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *HushHistoryMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ClearKind clears the value of the "kind" field.
func (m *HushHistoryMutation) ClearKind() {
	m.kind = nil
	m.clearedFields[hushhistory.FieldKind] = struct{}{}
}

// KindCleared returns if the "kind" field was cleared in this mutation.
func (m *HushHistoryMutation) KindCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldKind]
	return ok
}

// ResetKind resets all changes to the "kind" field.
func (m *HushHistoryMutation) ResetKind() {
	m.kind = nil
	delete(m.clearedFields, hushhistory.FieldKind)
}

// SetSecretName sets the "secret_name" field.
func (m *HushHistoryMutation) SetSecretName(s string) {
	m.secret_name = &s
}

// SecretName returns the value of the "secret_name" field in the mutation.
func (m *HushHistoryMutation) SecretName() (r string, exists bool) {
	v := m.secret_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretName returns the old "secret_name" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldSecretName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretName: %w", err)
	}
	return oldValue.SecretName, nil
}

// ClearSecretName clears the value of the "secret_name" field.
func (m *HushHistoryMutation) ClearSecretName() {
	m.secret_name = nil
	m.clearedFields[hushhistory.FieldSecretName] = struct{}{}
}

// SecretNameCleared returns if the "secret_name" field was cleared in this mutation.
func (m *HushHistoryMutation) SecretNameCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldSecretName]
	return ok
}

// ResetSecretName resets all changes to the "secret_name" field.
func (m *HushHistoryMutation) ResetSecretName() {
	m.secret_name = nil
	delete(m.clearedFields, hushhistory.FieldSecretName)
}

// SetSecretValue sets the "secret_value" field.
func (m *HushHistoryMutation) SetSecretValue(s string) {
	m.secret_value = &s
}

// SecretValue returns the value of the "secret_value" field in the mutation.
func (m *HushHistoryMutation) SecretValue() (r string, exists bool) {
	v := m.secret_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretValue returns the old "secret_value" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldSecretValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretValue: %w", err)
	}
	return oldValue.SecretValue, nil
}

// ClearSecretValue clears the value of the "secret_value" field.
func (m *HushHistoryMutation) ClearSecretValue() {
	m.secret_value = nil
	m.clearedFields[hushhistory.FieldSecretValue] = struct{}{}
}

// SecretValueCleared returns if the "secret_value" field was cleared in this mutation.
func (m *HushHistoryMutation) SecretValueCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldSecretValue]
	return ok
}

// ResetSecretValue resets all changes to the "secret_value" field.
func (m *HushHistoryMutation) ResetSecretValue() {
	m.secret_value = nil
	delete(m.clearedFields, hushhistory.FieldSecretValue)
}

// SetCredentialSet sets the "credential_set" field.
func (m *HushHistoryMutation) SetCredentialSet(ms models.CredentialSet) {
	m.credential_set = &ms
}

// CredentialSet returns the value of the "credential_set" field in the mutation.
func (m *HushHistoryMutation) CredentialSet() (r models.CredentialSet, exists bool) {
	v := m.credential_set
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialSet returns the old "credential_set" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldCredentialSet(ctx context.Context) (v models.CredentialSet, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialSet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialSet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialSet: %w", err)
	}
	return oldValue.CredentialSet, nil
}

// ClearCredentialSet clears the value of the "credential_set" field.
func (m *HushHistoryMutation) ClearCredentialSet() {
	m.credential_set = nil
	m.clearedFields[hushhistory.FieldCredentialSet] = struct{}{}
}

// CredentialSetCleared returns if the "credential_set" field was cleared in this mutation.
func (m *HushHistoryMutation) CredentialSetCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldCredentialSet]
	return ok
}

// ResetCredentialSet resets all changes to the "credential_set" field.
func (m *HushHistoryMutation) ResetCredentialSet() {
	m.credential_set = nil
	delete(m.clearedFields, hushhistory.FieldCredentialSet)
}

// SetMetadata sets the "metadata" field.
func (m *HushHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *HushHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *HushHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[hushhistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *HushHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *HushHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, hushhistory.FieldMetadata)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *HushHistoryMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *HushHistoryMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *HushHistoryMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[hushhistory.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *HushHistoryMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *HushHistoryMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, hushhistory.FieldLastUsedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *HushHistoryMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *HushHistoryMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *HushHistoryMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[hushhistory.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *HushHistoryMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *HushHistoryMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, hushhistory.FieldExpiresAt)
}

// Where appends a list predicates to the HushHistoryMutation builder.
func (m *HushHistoryMutation) Where(ps ...predicate.HushHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HushHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HushHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HushHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HushHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HushHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HushHistory).
func (m *HushHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HushHistoryMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.history_time != nil {
		fields = append(fields, hushhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, hushhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, hushhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, hushhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hushhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, hushhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, hushhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, hushhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, hushhistory.FieldDeletedBy)
	}
	if m.owner_id != nil {
		fields = append(fields, hushhistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, hushhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, hushhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, hushhistory.FieldSystemInternalID)
	}
	if m.name != nil {
		fields = append(fields, hushhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, hushhistory.FieldDescription)
	}
	if m.kind != nil {
		fields = append(fields, hushhistory.FieldKind)
	}
	if m.secret_name != nil {
		fields = append(fields, hushhistory.FieldSecretName)
	}
	if m.secret_value != nil {
		fields = append(fields, hushhistory.FieldSecretValue)
	}
	if m.credential_set != nil {
		fields = append(fields, hushhistory.FieldCredentialSet)
	}
	if m.metadata != nil {
		fields = append(fields, hushhistory.FieldMetadata)
	}
	if m.last_used_at != nil {
		fields = append(fields, hushhistory.FieldLastUsedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, hushhistory.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HushHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hushhistory.FieldHistoryTime:
		return m.HistoryTime()
	case hushhistory.FieldRef:
		return m.Ref()
	case hushhistory.FieldOperation:
		return m.Operation()
	case hushhistory.FieldCreatedAt:
		return m.CreatedAt()
	case hushhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case hushhistory.FieldCreatedBy:
		return m.CreatedBy()
	case hushhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case hushhistory.FieldDeletedAt:
		return m.DeletedAt()
	case hushhistory.FieldDeletedBy:
		return m.DeletedBy()
	case hushhistory.FieldOwnerID:
		return m.OwnerID()
	case hushhistory.FieldSystemOwned:
		return m.SystemOwned()
	case hushhistory.FieldInternalNotes:
		return m.InternalNotes()
	case hushhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case hushhistory.FieldName:
		return m.Name()
	case hushhistory.FieldDescription:
		return m.Description()
	case hushhistory.FieldKind:
		return m.Kind()
	case hushhistory.FieldSecretName:
		return m.SecretName()
	case hushhistory.FieldSecretValue:
		return m.SecretValue()
	case hushhistory.FieldCredentialSet:
		return m.CredentialSet()
	case hushhistory.FieldMetadata:
		return m.Metadata()
	case hushhistory.FieldLastUsedAt:
		return m.LastUsedAt()
	case hushhistory.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HushHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hushhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case hushhistory.FieldRef:
		return m.OldRef(ctx)
	case hushhistory.FieldOperation:
		return m.OldOperation(ctx)
	case hushhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hushhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hushhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case hushhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case hushhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case hushhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case hushhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case hushhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case hushhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case hushhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case hushhistory.FieldName:
		return m.OldName(ctx)
	case hushhistory.FieldDescription:
		return m.OldDescription(ctx)
	case hushhistory.FieldKind:
		return m.OldKind(ctx)
	case hushhistory.FieldSecretName:
		return m.OldSecretName(ctx)
	case hushhistory.FieldSecretValue:
		return m.OldSecretValue(ctx)
	case hushhistory.FieldCredentialSet:
		return m.OldCredentialSet(ctx)
	case hushhistory.FieldMetadata:
		return m.OldMetadata(ctx)
	case hushhistory.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case hushhistory.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown HushHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HushHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hushhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case hushhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case hushhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case hushhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hushhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hushhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case hushhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case hushhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case hushhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case hushhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case hushhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case hushhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case hushhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case hushhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hushhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case hushhistory.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case hushhistory.FieldSecretName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretName(v)
		return nil
	case hushhistory.FieldSecretValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretValue(v)
		return nil
	case hushhistory.FieldCredentialSet:
		v, ok := value.(models.CredentialSet)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialSet(v)
		return nil
	case hushhistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case hushhistory.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case hushhistory.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown HushHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HushHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HushHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HushHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HushHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HushHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hushhistory.FieldRef) {
		fields = append(fields, hushhistory.FieldRef)
	}
	if m.FieldCleared(hushhistory.FieldCreatedAt) {
		fields = append(fields, hushhistory.FieldCreatedAt)
	}
	if m.FieldCleared(hushhistory.FieldUpdatedAt) {
		fields = append(fields, hushhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(hushhistory.FieldCreatedBy) {
		fields = append(fields, hushhistory.FieldCreatedBy)
	}
	if m.FieldCleared(hushhistory.FieldUpdatedBy) {
		fields = append(fields, hushhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(hushhistory.FieldDeletedAt) {
		fields = append(fields, hushhistory.FieldDeletedAt)
	}
	if m.FieldCleared(hushhistory.FieldDeletedBy) {
		fields = append(fields, hushhistory.FieldDeletedBy)
	}
	if m.FieldCleared(hushhistory.FieldOwnerID) {
		fields = append(fields, hushhistory.FieldOwnerID)
	}
	if m.FieldCleared(hushhistory.FieldSystemOwned) {
		fields = append(fields, hushhistory.FieldSystemOwned)
	}
	if m.FieldCleared(hushhistory.FieldInternalNotes) {
		fields = append(fields, hushhistory.FieldInternalNotes)
	}
	if m.FieldCleared(hushhistory.FieldSystemInternalID) {
		fields = append(fields, hushhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(hushhistory.FieldDescription) {
		fields = append(fields, hushhistory.FieldDescription)
	}
	if m.FieldCleared(hushhistory.FieldKind) {
		fields = append(fields, hushhistory.FieldKind)
	}
	if m.FieldCleared(hushhistory.FieldSecretName) {
		fields = append(fields, hushhistory.FieldSecretName)
	}
	if m.FieldCleared(hushhistory.FieldSecretValue) {
		fields = append(fields, hushhistory.FieldSecretValue)
	}
	if m.FieldCleared(hushhistory.FieldCredentialSet) {
		fields = append(fields, hushhistory.FieldCredentialSet)
	}
	if m.FieldCleared(hushhistory.FieldMetadata) {
		fields = append(fields, hushhistory.FieldMetadata)
	}
	if m.FieldCleared(hushhistory.FieldLastUsedAt) {
		fields = append(fields, hushhistory.FieldLastUsedAt)
	}
	if m.FieldCleared(hushhistory.FieldExpiresAt) {
		fields = append(fields, hushhistory.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HushHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HushHistoryMutation) ClearField(name string) error {
	switch name {
	case hushhistory.FieldRef:
		m.ClearRef()
		return nil
	case hushhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hushhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hushhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case hushhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case hushhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case hushhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case hushhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case hushhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case hushhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case hushhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case hushhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case hushhistory.FieldKind:
		m.ClearKind()
		return nil
	case hushhistory.FieldSecretName:
		m.ClearSecretName()
		return nil
	case hushhistory.FieldSecretValue:
		m.ClearSecretValue()
		return nil
	case hushhistory.FieldCredentialSet:
		m.ClearCredentialSet()
		return nil
	case hushhistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	case hushhistory.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case hushhistory.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown HushHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HushHistoryMutation) ResetField(name string) error {
	switch name {
	case hushhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case hushhistory.FieldRef:
		m.ResetRef()
		return nil
	case hushhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case hushhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hushhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hushhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case hushhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case hushhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case hushhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case hushhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case hushhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case hushhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case hushhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case hushhistory.FieldName:
		m.ResetName()
		return nil
	case hushhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case hushhistory.FieldKind:
		m.ResetKind()
		return nil
	case hushhistory.FieldSecretName:
		m.ResetSecretName()
		return nil
	case hushhistory.FieldSecretValue:
		m.ResetSecretValue()
		return nil
	case hushhistory.FieldCredentialSet:
		m.ResetCredentialSet()
		return nil
	case hushhistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	case hushhistory.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case hushhistory.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown HushHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HushHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HushHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HushHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HushHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HushHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HushHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HushHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown HushHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HushHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown HushHistory edge %s", name)
}

// IntegrationHistoryMutation represents an operation that mutates the IntegrationHistory nodes in the graph.
type IntegrationHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	history_time       *time.Time
	ref                *string
	operation          *history.OpType
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	deleted_at         *time.Time
	deleted_by         *string
	tags               *[]string
	appendtags         []string
	owner_id           *string
	system_owned       *bool
	internal_notes     *string
	system_internal_id *string
	name               *string
	description        *string
	kind               *string
	integration_type   *string
	metadata           *map[string]interface{}
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*IntegrationHistory, error)
	predicates         []predicate.IntegrationHistory
}

var _ ent.Mutation = (*IntegrationHistoryMutation)(nil)

// integrationhistoryOption allows management of the mutation configuration using functional options.
type integrationhistoryOption func(*IntegrationHistoryMutation)

// newIntegrationHistoryMutation creates new mutation for the IntegrationHistory entity.
func newIntegrationHistoryMutation(c config, op Op, opts ...integrationhistoryOption) *IntegrationHistoryMutation {
	m := &IntegrationHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeIntegrationHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIntegrationHistoryID sets the ID field of the mutation.
func withIntegrationHistoryID(id string) integrationhistoryOption {
	return func(m *IntegrationHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *IntegrationHistory
		)
		m.oldValue = func(ctx context.Context) (*IntegrationHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IntegrationHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIntegrationHistory sets the old IntegrationHistory of the mutation.
func withIntegrationHistory(node *IntegrationHistory) integrationhistoryOption {
	return func(m *IntegrationHistoryMutation) {
		m.oldValue = func(context.Context) (*IntegrationHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IntegrationHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IntegrationHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IntegrationHistory entities.
func (m *IntegrationHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IntegrationHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IntegrationHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IntegrationHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *IntegrationHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *IntegrationHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *IntegrationHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *IntegrationHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *IntegrationHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *IntegrationHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[integrationhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *IntegrationHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, integrationhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *IntegrationHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *IntegrationHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *IntegrationHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IntegrationHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IntegrationHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *IntegrationHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[integrationhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IntegrationHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, integrationhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IntegrationHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IntegrationHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *IntegrationHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[integrationhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IntegrationHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, integrationhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *IntegrationHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *IntegrationHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *IntegrationHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[integrationhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *IntegrationHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, integrationhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *IntegrationHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *IntegrationHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *IntegrationHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[integrationhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *IntegrationHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, integrationhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *IntegrationHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *IntegrationHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *IntegrationHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[integrationhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *IntegrationHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, integrationhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *IntegrationHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *IntegrationHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *IntegrationHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[integrationhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *IntegrationHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, integrationhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *IntegrationHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *IntegrationHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *IntegrationHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *IntegrationHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *IntegrationHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[integrationhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *IntegrationHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, integrationhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *IntegrationHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *IntegrationHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *IntegrationHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[integrationhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *IntegrationHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, integrationhistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *IntegrationHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *IntegrationHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *IntegrationHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[integrationhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *IntegrationHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, integrationhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *IntegrationHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *IntegrationHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *IntegrationHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[integrationhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *IntegrationHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, integrationhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *IntegrationHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *IntegrationHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *IntegrationHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[integrationhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *IntegrationHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, integrationhistory.FieldSystemInternalID)
}

// SetName sets the "name" field.
func (m *IntegrationHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IntegrationHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IntegrationHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *IntegrationHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IntegrationHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IntegrationHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[integrationhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IntegrationHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, integrationhistory.FieldDescription)
}

// SetKind sets the "kind" field.
func (m *IntegrationHistoryMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *IntegrationHistoryMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ClearKind clears the value of the "kind" field.
func (m *IntegrationHistoryMutation) ClearKind() {
	m.kind = nil
	m.clearedFields[integrationhistory.FieldKind] = struct{}{}
}

// KindCleared returns if the "kind" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) KindCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldKind]
	return ok
}

// ResetKind resets all changes to the "kind" field.
func (m *IntegrationHistoryMutation) ResetKind() {
	m.kind = nil
	delete(m.clearedFields, integrationhistory.FieldKind)
}

// SetIntegrationType sets the "integration_type" field.
func (m *IntegrationHistoryMutation) SetIntegrationType(s string) {
	m.integration_type = &s
}

// IntegrationType returns the value of the "integration_type" field in the mutation.
func (m *IntegrationHistoryMutation) IntegrationType() (r string, exists bool) {
	v := m.integration_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIntegrationType returns the old "integration_type" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldIntegrationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntegrationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntegrationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntegrationType: %w", err)
	}
	return oldValue.IntegrationType, nil
}

// ClearIntegrationType clears the value of the "integration_type" field.
func (m *IntegrationHistoryMutation) ClearIntegrationType() {
	m.integration_type = nil
	m.clearedFields[integrationhistory.FieldIntegrationType] = struct{}{}
}

// IntegrationTypeCleared returns if the "integration_type" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) IntegrationTypeCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldIntegrationType]
	return ok
}

// ResetIntegrationType resets all changes to the "integration_type" field.
func (m *IntegrationHistoryMutation) ResetIntegrationType() {
	m.integration_type = nil
	delete(m.clearedFields, integrationhistory.FieldIntegrationType)
}

// SetMetadata sets the "metadata" field.
func (m *IntegrationHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *IntegrationHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *IntegrationHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[integrationhistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *IntegrationHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, integrationhistory.FieldMetadata)
}

// Where appends a list predicates to the IntegrationHistoryMutation builder.
func (m *IntegrationHistoryMutation) Where(ps ...predicate.IntegrationHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IntegrationHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IntegrationHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IntegrationHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IntegrationHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IntegrationHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IntegrationHistory).
func (m *IntegrationHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IntegrationHistoryMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.history_time != nil {
		fields = append(fields, integrationhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, integrationhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, integrationhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, integrationhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, integrationhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, integrationhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, integrationhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, integrationhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, integrationhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, integrationhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, integrationhistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, integrationhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, integrationhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, integrationhistory.FieldSystemInternalID)
	}
	if m.name != nil {
		fields = append(fields, integrationhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, integrationhistory.FieldDescription)
	}
	if m.kind != nil {
		fields = append(fields, integrationhistory.FieldKind)
	}
	if m.integration_type != nil {
		fields = append(fields, integrationhistory.FieldIntegrationType)
	}
	if m.metadata != nil {
		fields = append(fields, integrationhistory.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IntegrationHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case integrationhistory.FieldHistoryTime:
		return m.HistoryTime()
	case integrationhistory.FieldRef:
		return m.Ref()
	case integrationhistory.FieldOperation:
		return m.Operation()
	case integrationhistory.FieldCreatedAt:
		return m.CreatedAt()
	case integrationhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case integrationhistory.FieldCreatedBy:
		return m.CreatedBy()
	case integrationhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case integrationhistory.FieldDeletedAt:
		return m.DeletedAt()
	case integrationhistory.FieldDeletedBy:
		return m.DeletedBy()
	case integrationhistory.FieldTags:
		return m.Tags()
	case integrationhistory.FieldOwnerID:
		return m.OwnerID()
	case integrationhistory.FieldSystemOwned:
		return m.SystemOwned()
	case integrationhistory.FieldInternalNotes:
		return m.InternalNotes()
	case integrationhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case integrationhistory.FieldName:
		return m.Name()
	case integrationhistory.FieldDescription:
		return m.Description()
	case integrationhistory.FieldKind:
		return m.Kind()
	case integrationhistory.FieldIntegrationType:
		return m.IntegrationType()
	case integrationhistory.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IntegrationHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case integrationhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case integrationhistory.FieldRef:
		return m.OldRef(ctx)
	case integrationhistory.FieldOperation:
		return m.OldOperation(ctx)
	case integrationhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case integrationhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case integrationhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case integrationhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case integrationhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case integrationhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case integrationhistory.FieldTags:
		return m.OldTags(ctx)
	case integrationhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case integrationhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case integrationhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case integrationhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case integrationhistory.FieldName:
		return m.OldName(ctx)
	case integrationhistory.FieldDescription:
		return m.OldDescription(ctx)
	case integrationhistory.FieldKind:
		return m.OldKind(ctx)
	case integrationhistory.FieldIntegrationType:
		return m.OldIntegrationType(ctx)
	case integrationhistory.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown IntegrationHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntegrationHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case integrationhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case integrationhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case integrationhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case integrationhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case integrationhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case integrationhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case integrationhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case integrationhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case integrationhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case integrationhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case integrationhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case integrationhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case integrationhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case integrationhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case integrationhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case integrationhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case integrationhistory.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case integrationhistory.FieldIntegrationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntegrationType(v)
		return nil
	case integrationhistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown IntegrationHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IntegrationHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IntegrationHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntegrationHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IntegrationHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IntegrationHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(integrationhistory.FieldRef) {
		fields = append(fields, integrationhistory.FieldRef)
	}
	if m.FieldCleared(integrationhistory.FieldCreatedAt) {
		fields = append(fields, integrationhistory.FieldCreatedAt)
	}
	if m.FieldCleared(integrationhistory.FieldUpdatedAt) {
		fields = append(fields, integrationhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(integrationhistory.FieldCreatedBy) {
		fields = append(fields, integrationhistory.FieldCreatedBy)
	}
	if m.FieldCleared(integrationhistory.FieldUpdatedBy) {
		fields = append(fields, integrationhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(integrationhistory.FieldDeletedAt) {
		fields = append(fields, integrationhistory.FieldDeletedAt)
	}
	if m.FieldCleared(integrationhistory.FieldDeletedBy) {
		fields = append(fields, integrationhistory.FieldDeletedBy)
	}
	if m.FieldCleared(integrationhistory.FieldTags) {
		fields = append(fields, integrationhistory.FieldTags)
	}
	if m.FieldCleared(integrationhistory.FieldOwnerID) {
		fields = append(fields, integrationhistory.FieldOwnerID)
	}
	if m.FieldCleared(integrationhistory.FieldSystemOwned) {
		fields = append(fields, integrationhistory.FieldSystemOwned)
	}
	if m.FieldCleared(integrationhistory.FieldInternalNotes) {
		fields = append(fields, integrationhistory.FieldInternalNotes)
	}
	if m.FieldCleared(integrationhistory.FieldSystemInternalID) {
		fields = append(fields, integrationhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(integrationhistory.FieldDescription) {
		fields = append(fields, integrationhistory.FieldDescription)
	}
	if m.FieldCleared(integrationhistory.FieldKind) {
		fields = append(fields, integrationhistory.FieldKind)
	}
	if m.FieldCleared(integrationhistory.FieldIntegrationType) {
		fields = append(fields, integrationhistory.FieldIntegrationType)
	}
	if m.FieldCleared(integrationhistory.FieldMetadata) {
		fields = append(fields, integrationhistory.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IntegrationHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IntegrationHistoryMutation) ClearField(name string) error {
	switch name {
	case integrationhistory.FieldRef:
		m.ClearRef()
		return nil
	case integrationhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case integrationhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case integrationhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case integrationhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case integrationhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case integrationhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case integrationhistory.FieldTags:
		m.ClearTags()
		return nil
	case integrationhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case integrationhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case integrationhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case integrationhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case integrationhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case integrationhistory.FieldKind:
		m.ClearKind()
		return nil
	case integrationhistory.FieldIntegrationType:
		m.ClearIntegrationType()
		return nil
	case integrationhistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown IntegrationHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IntegrationHistoryMutation) ResetField(name string) error {
	switch name {
	case integrationhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case integrationhistory.FieldRef:
		m.ResetRef()
		return nil
	case integrationhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case integrationhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case integrationhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case integrationhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case integrationhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case integrationhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case integrationhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case integrationhistory.FieldTags:
		m.ResetTags()
		return nil
	case integrationhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case integrationhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case integrationhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case integrationhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case integrationhistory.FieldName:
		m.ResetName()
		return nil
	case integrationhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case integrationhistory.FieldKind:
		m.ResetKind()
		return nil
	case integrationhistory.FieldIntegrationType:
		m.ResetIntegrationType()
		return nil
	case integrationhistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown IntegrationHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IntegrationHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IntegrationHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IntegrationHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IntegrationHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IntegrationHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IntegrationHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IntegrationHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IntegrationHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IntegrationHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IntegrationHistory edge %s", name)
}

// InternalPolicyHistoryMutation represents an operation that mutates the InternalPolicyHistory nodes in the graph.
type InternalPolicyHistoryMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *string
	history_time                            *time.Time
	ref                                     *string
	operation                               *history.OpType
	created_at                              *time.Time
	updated_at                              *time.Time
	created_by                              *string
	updated_by                              *string
	deleted_at                              *time.Time
	deleted_by                              *string
	display_id                              *string
	tags                                    *[]string
	appendtags                              []string
	revision                                *string
	owner_id                                *string
	system_owned                            *bool
	internal_notes                          *string
	system_internal_id                      *string
	name                                    *string
	status                                  *enums.DocumentStatus
	policy_type                             *string
	details                                 *string
	approval_required                       *bool
	review_due                              *time.Time
	review_frequency                        *enums.Frequency
	approver_id                             *string
	delegate_id                             *string
	summary                                 *string
	tag_suggestions                         *[]string
	appendtag_suggestions                   []string
	dismissed_tag_suggestions               *[]string
	appenddismissed_tag_suggestions         []string
	control_suggestions                     *[]string
	appendcontrol_suggestions               []string
	dismissed_control_suggestions           *[]string
	appenddismissed_control_suggestions     []string
	improvement_suggestions                 *[]string
	appendimprovement_suggestions           []string
	dismissed_improvement_suggestions       *[]string
	appenddismissed_improvement_suggestions []string
	url                                     *string
	file_id                                 *string
	internal_policy_kind_name               *string
	internal_policy_kind_id                 *string
	clearedFields                           map[string]struct{}
	done                                    bool
	oldValue                                func(context.Context) (*InternalPolicyHistory, error)
	predicates                              []predicate.InternalPolicyHistory
}

var _ ent.Mutation = (*InternalPolicyHistoryMutation)(nil)

// internalpolicyhistoryOption allows management of the mutation configuration using functional options.
type internalpolicyhistoryOption func(*InternalPolicyHistoryMutation)

// newInternalPolicyHistoryMutation creates new mutation for the InternalPolicyHistory entity.
func newInternalPolicyHistoryMutation(c config, op Op, opts ...internalpolicyhistoryOption) *InternalPolicyHistoryMutation {
	m := &InternalPolicyHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeInternalPolicyHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInternalPolicyHistoryID sets the ID field of the mutation.
func withInternalPolicyHistoryID(id string) internalpolicyhistoryOption {
	return func(m *InternalPolicyHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *InternalPolicyHistory
		)
		m.oldValue = func(ctx context.Context) (*InternalPolicyHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InternalPolicyHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInternalPolicyHistory sets the old InternalPolicyHistory of the mutation.
func withInternalPolicyHistory(node *InternalPolicyHistory) internalpolicyhistoryOption {
	return func(m *InternalPolicyHistoryMutation) {
		m.oldValue = func(context.Context) (*InternalPolicyHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InternalPolicyHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InternalPolicyHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InternalPolicyHistory entities.
func (m *InternalPolicyHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InternalPolicyHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InternalPolicyHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InternalPolicyHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *InternalPolicyHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *InternalPolicyHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *InternalPolicyHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *InternalPolicyHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *InternalPolicyHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *InternalPolicyHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[internalpolicyhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *InternalPolicyHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, internalpolicyhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *InternalPolicyHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *InternalPolicyHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *InternalPolicyHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InternalPolicyHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InternalPolicyHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *InternalPolicyHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[internalpolicyhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InternalPolicyHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, internalpolicyhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InternalPolicyHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InternalPolicyHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *InternalPolicyHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[internalpolicyhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InternalPolicyHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, internalpolicyhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *InternalPolicyHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *InternalPolicyHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *InternalPolicyHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[internalpolicyhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *InternalPolicyHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, internalpolicyhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *InternalPolicyHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *InternalPolicyHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *InternalPolicyHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[internalpolicyhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *InternalPolicyHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, internalpolicyhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InternalPolicyHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InternalPolicyHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InternalPolicyHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[internalpolicyhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InternalPolicyHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, internalpolicyhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *InternalPolicyHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *InternalPolicyHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *InternalPolicyHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[internalpolicyhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *InternalPolicyHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, internalpolicyhistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *InternalPolicyHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *InternalPolicyHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *InternalPolicyHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *InternalPolicyHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *InternalPolicyHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *InternalPolicyHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *InternalPolicyHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *InternalPolicyHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[internalpolicyhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *InternalPolicyHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, internalpolicyhistory.FieldTags)
}

// SetRevision sets the "revision" field.
func (m *InternalPolicyHistoryMutation) SetRevision(s string) {
	m.revision = &s
}

// Revision returns the value of the "revision" field in the mutation.
func (m *InternalPolicyHistoryMutation) Revision() (r string, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldRevision(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// ClearRevision clears the value of the "revision" field.
func (m *InternalPolicyHistoryMutation) ClearRevision() {
	m.revision = nil
	m.clearedFields[internalpolicyhistory.FieldRevision] = struct{}{}
}

// RevisionCleared returns if the "revision" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) RevisionCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldRevision]
	return ok
}

// ResetRevision resets all changes to the "revision" field.
func (m *InternalPolicyHistoryMutation) ResetRevision() {
	m.revision = nil
	delete(m.clearedFields, internalpolicyhistory.FieldRevision)
}

// SetOwnerID sets the "owner_id" field.
func (m *InternalPolicyHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *InternalPolicyHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *InternalPolicyHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[internalpolicyhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *InternalPolicyHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, internalpolicyhistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *InternalPolicyHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *InternalPolicyHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *InternalPolicyHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[internalpolicyhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *InternalPolicyHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, internalpolicyhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *InternalPolicyHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *InternalPolicyHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *InternalPolicyHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[internalpolicyhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *InternalPolicyHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, internalpolicyhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *InternalPolicyHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *InternalPolicyHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *InternalPolicyHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[internalpolicyhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *InternalPolicyHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, internalpolicyhistory.FieldSystemInternalID)
}

// SetName sets the "name" field.
func (m *InternalPolicyHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InternalPolicyHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InternalPolicyHistoryMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *InternalPolicyHistoryMutation) SetStatus(es enums.DocumentStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *InternalPolicyHistoryMutation) Status() (r enums.DocumentStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldStatus(ctx context.Context) (v enums.DocumentStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *InternalPolicyHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[internalpolicyhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *InternalPolicyHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, internalpolicyhistory.FieldStatus)
}

// SetPolicyType sets the "policy_type" field.
func (m *InternalPolicyHistoryMutation) SetPolicyType(s string) {
	m.policy_type = &s
}

// PolicyType returns the value of the "policy_type" field in the mutation.
func (m *InternalPolicyHistoryMutation) PolicyType() (r string, exists bool) {
	v := m.policy_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicyType returns the old "policy_type" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldPolicyType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicyType: %w", err)
	}
	return oldValue.PolicyType, nil
}

// ClearPolicyType clears the value of the "policy_type" field.
func (m *InternalPolicyHistoryMutation) ClearPolicyType() {
	m.policy_type = nil
	m.clearedFields[internalpolicyhistory.FieldPolicyType] = struct{}{}
}

// PolicyTypeCleared returns if the "policy_type" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) PolicyTypeCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldPolicyType]
	return ok
}

// ResetPolicyType resets all changes to the "policy_type" field.
func (m *InternalPolicyHistoryMutation) ResetPolicyType() {
	m.policy_type = nil
	delete(m.clearedFields, internalpolicyhistory.FieldPolicyType)
}

// SetDetails sets the "details" field.
func (m *InternalPolicyHistoryMutation) SetDetails(s string) {
	m.details = &s
}

// Details returns the value of the "details" field in the mutation.
func (m *InternalPolicyHistoryMutation) Details() (r string, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *InternalPolicyHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[internalpolicyhistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *InternalPolicyHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, internalpolicyhistory.FieldDetails)
}

// SetApprovalRequired sets the "approval_required" field.
func (m *InternalPolicyHistoryMutation) SetApprovalRequired(b bool) {
	m.approval_required = &b
}

// ApprovalRequired returns the value of the "approval_required" field in the mutation.
func (m *InternalPolicyHistoryMutation) ApprovalRequired() (r bool, exists bool) {
	v := m.approval_required
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalRequired returns the old "approval_required" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldApprovalRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalRequired: %w", err)
	}
	return oldValue.ApprovalRequired, nil
}

// ClearApprovalRequired clears the value of the "approval_required" field.
func (m *InternalPolicyHistoryMutation) ClearApprovalRequired() {
	m.approval_required = nil
	m.clearedFields[internalpolicyhistory.FieldApprovalRequired] = struct{}{}
}

// ApprovalRequiredCleared returns if the "approval_required" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) ApprovalRequiredCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldApprovalRequired]
	return ok
}

// ResetApprovalRequired resets all changes to the "approval_required" field.
func (m *InternalPolicyHistoryMutation) ResetApprovalRequired() {
	m.approval_required = nil
	delete(m.clearedFields, internalpolicyhistory.FieldApprovalRequired)
}

// SetReviewDue sets the "review_due" field.
func (m *InternalPolicyHistoryMutation) SetReviewDue(t time.Time) {
	m.review_due = &t
}

// ReviewDue returns the value of the "review_due" field in the mutation.
func (m *InternalPolicyHistoryMutation) ReviewDue() (r time.Time, exists bool) {
	v := m.review_due
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewDue returns the old "review_due" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldReviewDue(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewDue: %w", err)
	}
	return oldValue.ReviewDue, nil
}

// ClearReviewDue clears the value of the "review_due" field.
func (m *InternalPolicyHistoryMutation) ClearReviewDue() {
	m.review_due = nil
	m.clearedFields[internalpolicyhistory.FieldReviewDue] = struct{}{}
}

// ReviewDueCleared returns if the "review_due" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) ReviewDueCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldReviewDue]
	return ok
}

// ResetReviewDue resets all changes to the "review_due" field.
func (m *InternalPolicyHistoryMutation) ResetReviewDue() {
	m.review_due = nil
	delete(m.clearedFields, internalpolicyhistory.FieldReviewDue)
}

// SetReviewFrequency sets the "review_frequency" field.
func (m *InternalPolicyHistoryMutation) SetReviewFrequency(e enums.Frequency) {
	m.review_frequency = &e
}

// ReviewFrequency returns the value of the "review_frequency" field in the mutation.
func (m *InternalPolicyHistoryMutation) ReviewFrequency() (r enums.Frequency, exists bool) {
	v := m.review_frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewFrequency returns the old "review_frequency" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldReviewFrequency(ctx context.Context) (v enums.Frequency, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewFrequency: %w", err)
	}
	return oldValue.ReviewFrequency, nil
}

// ClearReviewFrequency clears the value of the "review_frequency" field.
func (m *InternalPolicyHistoryMutation) ClearReviewFrequency() {
	m.review_frequency = nil
	m.clearedFields[internalpolicyhistory.FieldReviewFrequency] = struct{}{}
}

// ReviewFrequencyCleared returns if the "review_frequency" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) ReviewFrequencyCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldReviewFrequency]
	return ok
}

// ResetReviewFrequency resets all changes to the "review_frequency" field.
func (m *InternalPolicyHistoryMutation) ResetReviewFrequency() {
	m.review_frequency = nil
	delete(m.clearedFields, internalpolicyhistory.FieldReviewFrequency)
}

// SetApproverID sets the "approver_id" field.
func (m *InternalPolicyHistoryMutation) SetApproverID(s string) {
	m.approver_id = &s
}

// ApproverID returns the value of the "approver_id" field in the mutation.
func (m *InternalPolicyHistoryMutation) ApproverID() (r string, exists bool) {
	v := m.approver_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApproverID returns the old "approver_id" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldApproverID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproverID: %w", err)
	}
	return oldValue.ApproverID, nil
}

// ClearApproverID clears the value of the "approver_id" field.
func (m *InternalPolicyHistoryMutation) ClearApproverID() {
	m.approver_id = nil
	m.clearedFields[internalpolicyhistory.FieldApproverID] = struct{}{}
}

// ApproverIDCleared returns if the "approver_id" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) ApproverIDCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldApproverID]
	return ok
}

// ResetApproverID resets all changes to the "approver_id" field.
func (m *InternalPolicyHistoryMutation) ResetApproverID() {
	m.approver_id = nil
	delete(m.clearedFields, internalpolicyhistory.FieldApproverID)
}

// SetDelegateID sets the "delegate_id" field.
func (m *InternalPolicyHistoryMutation) SetDelegateID(s string) {
	m.delegate_id = &s
}

// DelegateID returns the value of the "delegate_id" field in the mutation.
func (m *InternalPolicyHistoryMutation) DelegateID() (r string, exists bool) {
	v := m.delegate_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegateID returns the old "delegate_id" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldDelegateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelegateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelegateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegateID: %w", err)
	}
	return oldValue.DelegateID, nil
}

// ClearDelegateID clears the value of the "delegate_id" field.
func (m *InternalPolicyHistoryMutation) ClearDelegateID() {
	m.delegate_id = nil
	m.clearedFields[internalpolicyhistory.FieldDelegateID] = struct{}{}
}

// DelegateIDCleared returns if the "delegate_id" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) DelegateIDCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldDelegateID]
	return ok
}

// ResetDelegateID resets all changes to the "delegate_id" field.
func (m *InternalPolicyHistoryMutation) ResetDelegateID() {
	m.delegate_id = nil
	delete(m.clearedFields, internalpolicyhistory.FieldDelegateID)
}

// SetSummary sets the "summary" field.
func (m *InternalPolicyHistoryMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *InternalPolicyHistoryMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *InternalPolicyHistoryMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[internalpolicyhistory.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *InternalPolicyHistoryMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, internalpolicyhistory.FieldSummary)
}

// SetTagSuggestions sets the "tag_suggestions" field.
func (m *InternalPolicyHistoryMutation) SetTagSuggestions(s []string) {
	m.tag_suggestions = &s
	m.appendtag_suggestions = nil
}

// TagSuggestions returns the value of the "tag_suggestions" field in the mutation.
func (m *InternalPolicyHistoryMutation) TagSuggestions() (r []string, exists bool) {
	v := m.tag_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldTagSuggestions returns the old "tag_suggestions" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldTagSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagSuggestions: %w", err)
	}
	return oldValue.TagSuggestions, nil
}

// AppendTagSuggestions adds s to the "tag_suggestions" field.
func (m *InternalPolicyHistoryMutation) AppendTagSuggestions(s []string) {
	m.appendtag_suggestions = append(m.appendtag_suggestions, s...)
}

// AppendedTagSuggestions returns the list of values that were appended to the "tag_suggestions" field in this mutation.
func (m *InternalPolicyHistoryMutation) AppendedTagSuggestions() ([]string, bool) {
	if len(m.appendtag_suggestions) == 0 {
		return nil, false
	}
	return m.appendtag_suggestions, true
}

// ClearTagSuggestions clears the value of the "tag_suggestions" field.
func (m *InternalPolicyHistoryMutation) ClearTagSuggestions() {
	m.tag_suggestions = nil
	m.appendtag_suggestions = nil
	m.clearedFields[internalpolicyhistory.FieldTagSuggestions] = struct{}{}
}

// TagSuggestionsCleared returns if the "tag_suggestions" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) TagSuggestionsCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldTagSuggestions]
	return ok
}

// ResetTagSuggestions resets all changes to the "tag_suggestions" field.
func (m *InternalPolicyHistoryMutation) ResetTagSuggestions() {
	m.tag_suggestions = nil
	m.appendtag_suggestions = nil
	delete(m.clearedFields, internalpolicyhistory.FieldTagSuggestions)
}

// SetDismissedTagSuggestions sets the "dismissed_tag_suggestions" field.
func (m *InternalPolicyHistoryMutation) SetDismissedTagSuggestions(s []string) {
	m.dismissed_tag_suggestions = &s
	m.appenddismissed_tag_suggestions = nil
}

// DismissedTagSuggestions returns the value of the "dismissed_tag_suggestions" field in the mutation.
func (m *InternalPolicyHistoryMutation) DismissedTagSuggestions() (r []string, exists bool) {
	v := m.dismissed_tag_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldDismissedTagSuggestions returns the old "dismissed_tag_suggestions" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldDismissedTagSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDismissedTagSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDismissedTagSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDismissedTagSuggestions: %w", err)
	}
	return oldValue.DismissedTagSuggestions, nil
}

// AppendDismissedTagSuggestions adds s to the "dismissed_tag_suggestions" field.
func (m *InternalPolicyHistoryMutation) AppendDismissedTagSuggestions(s []string) {
	m.appenddismissed_tag_suggestions = append(m.appenddismissed_tag_suggestions, s...)
}

// AppendedDismissedTagSuggestions returns the list of values that were appended to the "dismissed_tag_suggestions" field in this mutation.
func (m *InternalPolicyHistoryMutation) AppendedDismissedTagSuggestions() ([]string, bool) {
	if len(m.appenddismissed_tag_suggestions) == 0 {
		return nil, false
	}
	return m.appenddismissed_tag_suggestions, true
}

// ClearDismissedTagSuggestions clears the value of the "dismissed_tag_suggestions" field.
func (m *InternalPolicyHistoryMutation) ClearDismissedTagSuggestions() {
	m.dismissed_tag_suggestions = nil
	m.appenddismissed_tag_suggestions = nil
	m.clearedFields[internalpolicyhistory.FieldDismissedTagSuggestions] = struct{}{}
}

// DismissedTagSuggestionsCleared returns if the "dismissed_tag_suggestions" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) DismissedTagSuggestionsCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldDismissedTagSuggestions]
	return ok
}

// ResetDismissedTagSuggestions resets all changes to the "dismissed_tag_suggestions" field.
func (m *InternalPolicyHistoryMutation) ResetDismissedTagSuggestions() {
	m.dismissed_tag_suggestions = nil
	m.appenddismissed_tag_suggestions = nil
	delete(m.clearedFields, internalpolicyhistory.FieldDismissedTagSuggestions)
}

// SetControlSuggestions sets the "control_suggestions" field.
func (m *InternalPolicyHistoryMutation) SetControlSuggestions(s []string) {
	m.control_suggestions = &s
	m.appendcontrol_suggestions = nil
}

// ControlSuggestions returns the value of the "control_suggestions" field in the mutation.
func (m *InternalPolicyHistoryMutation) ControlSuggestions() (r []string, exists bool) {
	v := m.control_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldControlSuggestions returns the old "control_suggestions" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldControlSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlSuggestions: %w", err)
	}
	return oldValue.ControlSuggestions, nil
}

// AppendControlSuggestions adds s to the "control_suggestions" field.
func (m *InternalPolicyHistoryMutation) AppendControlSuggestions(s []string) {
	m.appendcontrol_suggestions = append(m.appendcontrol_suggestions, s...)
}

// AppendedControlSuggestions returns the list of values that were appended to the "control_suggestions" field in this mutation.
func (m *InternalPolicyHistoryMutation) AppendedControlSuggestions() ([]string, bool) {
	if len(m.appendcontrol_suggestions) == 0 {
		return nil, false
	}
	return m.appendcontrol_suggestions, true
}

// ClearControlSuggestions clears the value of the "control_suggestions" field.
func (m *InternalPolicyHistoryMutation) ClearControlSuggestions() {
	m.control_suggestions = nil
	m.appendcontrol_suggestions = nil
	m.clearedFields[internalpolicyhistory.FieldControlSuggestions] = struct{}{}
}

// ControlSuggestionsCleared returns if the "control_suggestions" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) ControlSuggestionsCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldControlSuggestions]
	return ok
}

// ResetControlSuggestions resets all changes to the "control_suggestions" field.
func (m *InternalPolicyHistoryMutation) ResetControlSuggestions() {
	m.control_suggestions = nil
	m.appendcontrol_suggestions = nil
	delete(m.clearedFields, internalpolicyhistory.FieldControlSuggestions)
}

// SetDismissedControlSuggestions sets the "dismissed_control_suggestions" field.
func (m *InternalPolicyHistoryMutation) SetDismissedControlSuggestions(s []string) {
	m.dismissed_control_suggestions = &s
	m.appenddismissed_control_suggestions = nil
}

// DismissedControlSuggestions returns the value of the "dismissed_control_suggestions" field in the mutation.
func (m *InternalPolicyHistoryMutation) DismissedControlSuggestions() (r []string, exists bool) {
	v := m.dismissed_control_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldDismissedControlSuggestions returns the old "dismissed_control_suggestions" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldDismissedControlSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDismissedControlSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDismissedControlSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDismissedControlSuggestions: %w", err)
	}
	return oldValue.DismissedControlSuggestions, nil
}

// AppendDismissedControlSuggestions adds s to the "dismissed_control_suggestions" field.
func (m *InternalPolicyHistoryMutation) AppendDismissedControlSuggestions(s []string) {
	m.appenddismissed_control_suggestions = append(m.appenddismissed_control_suggestions, s...)
}

// AppendedDismissedControlSuggestions returns the list of values that were appended to the "dismissed_control_suggestions" field in this mutation.
func (m *InternalPolicyHistoryMutation) AppendedDismissedControlSuggestions() ([]string, bool) {
	if len(m.appenddismissed_control_suggestions) == 0 {
		return nil, false
	}
	return m.appenddismissed_control_suggestions, true
}

// ClearDismissedControlSuggestions clears the value of the "dismissed_control_suggestions" field.
func (m *InternalPolicyHistoryMutation) ClearDismissedControlSuggestions() {
	m.dismissed_control_suggestions = nil
	m.appenddismissed_control_suggestions = nil
	m.clearedFields[internalpolicyhistory.FieldDismissedControlSuggestions] = struct{}{}
}

// DismissedControlSuggestionsCleared returns if the "dismissed_control_suggestions" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) DismissedControlSuggestionsCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldDismissedControlSuggestions]
	return ok
}

// ResetDismissedControlSuggestions resets all changes to the "dismissed_control_suggestions" field.
func (m *InternalPolicyHistoryMutation) ResetDismissedControlSuggestions() {
	m.dismissed_control_suggestions = nil
	m.appenddismissed_control_suggestions = nil
	delete(m.clearedFields, internalpolicyhistory.FieldDismissedControlSuggestions)
}

// SetImprovementSuggestions sets the "improvement_suggestions" field.
func (m *InternalPolicyHistoryMutation) SetImprovementSuggestions(s []string) {
	m.improvement_suggestions = &s
	m.appendimprovement_suggestions = nil
}

// ImprovementSuggestions returns the value of the "improvement_suggestions" field in the mutation.
func (m *InternalPolicyHistoryMutation) ImprovementSuggestions() (r []string, exists bool) {
	v := m.improvement_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldImprovementSuggestions returns the old "improvement_suggestions" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldImprovementSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImprovementSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImprovementSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImprovementSuggestions: %w", err)
	}
	return oldValue.ImprovementSuggestions, nil
}

// AppendImprovementSuggestions adds s to the "improvement_suggestions" field.
func (m *InternalPolicyHistoryMutation) AppendImprovementSuggestions(s []string) {
	m.appendimprovement_suggestions = append(m.appendimprovement_suggestions, s...)
}

// AppendedImprovementSuggestions returns the list of values that were appended to the "improvement_suggestions" field in this mutation.
func (m *InternalPolicyHistoryMutation) AppendedImprovementSuggestions() ([]string, bool) {
	if len(m.appendimprovement_suggestions) == 0 {
		return nil, false
	}
	return m.appendimprovement_suggestions, true
}

// ClearImprovementSuggestions clears the value of the "improvement_suggestions" field.
func (m *InternalPolicyHistoryMutation) ClearImprovementSuggestions() {
	m.improvement_suggestions = nil
	m.appendimprovement_suggestions = nil
	m.clearedFields[internalpolicyhistory.FieldImprovementSuggestions] = struct{}{}
}

// ImprovementSuggestionsCleared returns if the "improvement_suggestions" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) ImprovementSuggestionsCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldImprovementSuggestions]
	return ok
}

// ResetImprovementSuggestions resets all changes to the "improvement_suggestions" field.
func (m *InternalPolicyHistoryMutation) ResetImprovementSuggestions() {
	m.improvement_suggestions = nil
	m.appendimprovement_suggestions = nil
	delete(m.clearedFields, internalpolicyhistory.FieldImprovementSuggestions)
}

// SetDismissedImprovementSuggestions sets the "dismissed_improvement_suggestions" field.
func (m *InternalPolicyHistoryMutation) SetDismissedImprovementSuggestions(s []string) {
	m.dismissed_improvement_suggestions = &s
	m.appenddismissed_improvement_suggestions = nil
}

// DismissedImprovementSuggestions returns the value of the "dismissed_improvement_suggestions" field in the mutation.
func (m *InternalPolicyHistoryMutation) DismissedImprovementSuggestions() (r []string, exists bool) {
	v := m.dismissed_improvement_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldDismissedImprovementSuggestions returns the old "dismissed_improvement_suggestions" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldDismissedImprovementSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDismissedImprovementSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDismissedImprovementSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDismissedImprovementSuggestions: %w", err)
	}
	return oldValue.DismissedImprovementSuggestions, nil
}

// AppendDismissedImprovementSuggestions adds s to the "dismissed_improvement_suggestions" field.
func (m *InternalPolicyHistoryMutation) AppendDismissedImprovementSuggestions(s []string) {
	m.appenddismissed_improvement_suggestions = append(m.appenddismissed_improvement_suggestions, s...)
}

// AppendedDismissedImprovementSuggestions returns the list of values that were appended to the "dismissed_improvement_suggestions" field in this mutation.
func (m *InternalPolicyHistoryMutation) AppendedDismissedImprovementSuggestions() ([]string, bool) {
	if len(m.appenddismissed_improvement_suggestions) == 0 {
		return nil, false
	}
	return m.appenddismissed_improvement_suggestions, true
}

// ClearDismissedImprovementSuggestions clears the value of the "dismissed_improvement_suggestions" field.
func (m *InternalPolicyHistoryMutation) ClearDismissedImprovementSuggestions() {
	m.dismissed_improvement_suggestions = nil
	m.appenddismissed_improvement_suggestions = nil
	m.clearedFields[internalpolicyhistory.FieldDismissedImprovementSuggestions] = struct{}{}
}

// DismissedImprovementSuggestionsCleared returns if the "dismissed_improvement_suggestions" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) DismissedImprovementSuggestionsCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldDismissedImprovementSuggestions]
	return ok
}

// ResetDismissedImprovementSuggestions resets all changes to the "dismissed_improvement_suggestions" field.
func (m *InternalPolicyHistoryMutation) ResetDismissedImprovementSuggestions() {
	m.dismissed_improvement_suggestions = nil
	m.appenddismissed_improvement_suggestions = nil
	delete(m.clearedFields, internalpolicyhistory.FieldDismissedImprovementSuggestions)
}

// SetURL sets the "url" field.
func (m *InternalPolicyHistoryMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *InternalPolicyHistoryMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *InternalPolicyHistoryMutation) ClearURL() {
	m.url = nil
	m.clearedFields[internalpolicyhistory.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) URLCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *InternalPolicyHistoryMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, internalpolicyhistory.FieldURL)
}

// SetFileID sets the "file_id" field.
func (m *InternalPolicyHistoryMutation) SetFileID(s string) {
	m.file_id = &s
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *InternalPolicyHistoryMutation) FileID() (r string, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ClearFileID clears the value of the "file_id" field.
func (m *InternalPolicyHistoryMutation) ClearFileID() {
	m.file_id = nil
	m.clearedFields[internalpolicyhistory.FieldFileID] = struct{}{}
}

// FileIDCleared returns if the "file_id" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) FileIDCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldFileID]
	return ok
}

// ResetFileID resets all changes to the "file_id" field.
func (m *InternalPolicyHistoryMutation) ResetFileID() {
	m.file_id = nil
	delete(m.clearedFields, internalpolicyhistory.FieldFileID)
}

// SetInternalPolicyKindName sets the "internal_policy_kind_name" field.
func (m *InternalPolicyHistoryMutation) SetInternalPolicyKindName(s string) {
	m.internal_policy_kind_name = &s
}

// InternalPolicyKindName returns the value of the "internal_policy_kind_name" field in the mutation.
func (m *InternalPolicyHistoryMutation) InternalPolicyKindName() (r string, exists bool) {
	v := m.internal_policy_kind_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalPolicyKindName returns the old "internal_policy_kind_name" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldInternalPolicyKindName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalPolicyKindName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalPolicyKindName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalPolicyKindName: %w", err)
	}
	return oldValue.InternalPolicyKindName, nil
}

// ClearInternalPolicyKindName clears the value of the "internal_policy_kind_name" field.
func (m *InternalPolicyHistoryMutation) ClearInternalPolicyKindName() {
	m.internal_policy_kind_name = nil
	m.clearedFields[internalpolicyhistory.FieldInternalPolicyKindName] = struct{}{}
}

// InternalPolicyKindNameCleared returns if the "internal_policy_kind_name" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) InternalPolicyKindNameCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldInternalPolicyKindName]
	return ok
}

// ResetInternalPolicyKindName resets all changes to the "internal_policy_kind_name" field.
func (m *InternalPolicyHistoryMutation) ResetInternalPolicyKindName() {
	m.internal_policy_kind_name = nil
	delete(m.clearedFields, internalpolicyhistory.FieldInternalPolicyKindName)
}

// SetInternalPolicyKindID sets the "internal_policy_kind_id" field.
func (m *InternalPolicyHistoryMutation) SetInternalPolicyKindID(s string) {
	m.internal_policy_kind_id = &s
}

// InternalPolicyKindID returns the value of the "internal_policy_kind_id" field in the mutation.
func (m *InternalPolicyHistoryMutation) InternalPolicyKindID() (r string, exists bool) {
	v := m.internal_policy_kind_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalPolicyKindID returns the old "internal_policy_kind_id" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldInternalPolicyKindID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalPolicyKindID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalPolicyKindID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalPolicyKindID: %w", err)
	}
	return oldValue.InternalPolicyKindID, nil
}

// ClearInternalPolicyKindID clears the value of the "internal_policy_kind_id" field.
func (m *InternalPolicyHistoryMutation) ClearInternalPolicyKindID() {
	m.internal_policy_kind_id = nil
	m.clearedFields[internalpolicyhistory.FieldInternalPolicyKindID] = struct{}{}
}

// InternalPolicyKindIDCleared returns if the "internal_policy_kind_id" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) InternalPolicyKindIDCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldInternalPolicyKindID]
	return ok
}

// ResetInternalPolicyKindID resets all changes to the "internal_policy_kind_id" field.
func (m *InternalPolicyHistoryMutation) ResetInternalPolicyKindID() {
	m.internal_policy_kind_id = nil
	delete(m.clearedFields, internalpolicyhistory.FieldInternalPolicyKindID)
}

// Where appends a list predicates to the InternalPolicyHistoryMutation builder.
func (m *InternalPolicyHistoryMutation) Where(ps ...predicate.InternalPolicyHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InternalPolicyHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InternalPolicyHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InternalPolicyHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InternalPolicyHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InternalPolicyHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InternalPolicyHistory).
func (m *InternalPolicyHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InternalPolicyHistoryMutation) Fields() []string {
	fields := make([]string, 0, 36)
	if m.history_time != nil {
		fields = append(fields, internalpolicyhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, internalpolicyhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, internalpolicyhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, internalpolicyhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, internalpolicyhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, internalpolicyhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, internalpolicyhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, internalpolicyhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, internalpolicyhistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, internalpolicyhistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, internalpolicyhistory.FieldTags)
	}
	if m.revision != nil {
		fields = append(fields, internalpolicyhistory.FieldRevision)
	}
	if m.owner_id != nil {
		fields = append(fields, internalpolicyhistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, internalpolicyhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, internalpolicyhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, internalpolicyhistory.FieldSystemInternalID)
	}
	if m.name != nil {
		fields = append(fields, internalpolicyhistory.FieldName)
	}
	if m.status != nil {
		fields = append(fields, internalpolicyhistory.FieldStatus)
	}
	if m.policy_type != nil {
		fields = append(fields, internalpolicyhistory.FieldPolicyType)
	}
	if m.details != nil {
		fields = append(fields, internalpolicyhistory.FieldDetails)
	}
	if m.approval_required != nil {
		fields = append(fields, internalpolicyhistory.FieldApprovalRequired)
	}
	if m.review_due != nil {
		fields = append(fields, internalpolicyhistory.FieldReviewDue)
	}
	if m.review_frequency != nil {
		fields = append(fields, internalpolicyhistory.FieldReviewFrequency)
	}
	if m.approver_id != nil {
		fields = append(fields, internalpolicyhistory.FieldApproverID)
	}
	if m.delegate_id != nil {
		fields = append(fields, internalpolicyhistory.FieldDelegateID)
	}
	if m.summary != nil {
		fields = append(fields, internalpolicyhistory.FieldSummary)
	}
	if m.tag_suggestions != nil {
		fields = append(fields, internalpolicyhistory.FieldTagSuggestions)
	}
	if m.dismissed_tag_suggestions != nil {
		fields = append(fields, internalpolicyhistory.FieldDismissedTagSuggestions)
	}
	if m.control_suggestions != nil {
		fields = append(fields, internalpolicyhistory.FieldControlSuggestions)
	}
	if m.dismissed_control_suggestions != nil {
		fields = append(fields, internalpolicyhistory.FieldDismissedControlSuggestions)
	}
	if m.improvement_suggestions != nil {
		fields = append(fields, internalpolicyhistory.FieldImprovementSuggestions)
	}
	if m.dismissed_improvement_suggestions != nil {
		fields = append(fields, internalpolicyhistory.FieldDismissedImprovementSuggestions)
	}
	if m.url != nil {
		fields = append(fields, internalpolicyhistory.FieldURL)
	}
	if m.file_id != nil {
		fields = append(fields, internalpolicyhistory.FieldFileID)
	}
	if m.internal_policy_kind_name != nil {
		fields = append(fields, internalpolicyhistory.FieldInternalPolicyKindName)
	}
	if m.internal_policy_kind_id != nil {
		fields = append(fields, internalpolicyhistory.FieldInternalPolicyKindID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InternalPolicyHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case internalpolicyhistory.FieldHistoryTime:
		return m.HistoryTime()
	case internalpolicyhistory.FieldRef:
		return m.Ref()
	case internalpolicyhistory.FieldOperation:
		return m.Operation()
	case internalpolicyhistory.FieldCreatedAt:
		return m.CreatedAt()
	case internalpolicyhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case internalpolicyhistory.FieldCreatedBy:
		return m.CreatedBy()
	case internalpolicyhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case internalpolicyhistory.FieldDeletedAt:
		return m.DeletedAt()
	case internalpolicyhistory.FieldDeletedBy:
		return m.DeletedBy()
	case internalpolicyhistory.FieldDisplayID:
		return m.DisplayID()
	case internalpolicyhistory.FieldTags:
		return m.Tags()
	case internalpolicyhistory.FieldRevision:
		return m.Revision()
	case internalpolicyhistory.FieldOwnerID:
		return m.OwnerID()
	case internalpolicyhistory.FieldSystemOwned:
		return m.SystemOwned()
	case internalpolicyhistory.FieldInternalNotes:
		return m.InternalNotes()
	case internalpolicyhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case internalpolicyhistory.FieldName:
		return m.Name()
	case internalpolicyhistory.FieldStatus:
		return m.Status()
	case internalpolicyhistory.FieldPolicyType:
		return m.PolicyType()
	case internalpolicyhistory.FieldDetails:
		return m.Details()
	case internalpolicyhistory.FieldApprovalRequired:
		return m.ApprovalRequired()
	case internalpolicyhistory.FieldReviewDue:
		return m.ReviewDue()
	case internalpolicyhistory.FieldReviewFrequency:
		return m.ReviewFrequency()
	case internalpolicyhistory.FieldApproverID:
		return m.ApproverID()
	case internalpolicyhistory.FieldDelegateID:
		return m.DelegateID()
	case internalpolicyhistory.FieldSummary:
		return m.Summary()
	case internalpolicyhistory.FieldTagSuggestions:
		return m.TagSuggestions()
	case internalpolicyhistory.FieldDismissedTagSuggestions:
		return m.DismissedTagSuggestions()
	case internalpolicyhistory.FieldControlSuggestions:
		return m.ControlSuggestions()
	case internalpolicyhistory.FieldDismissedControlSuggestions:
		return m.DismissedControlSuggestions()
	case internalpolicyhistory.FieldImprovementSuggestions:
		return m.ImprovementSuggestions()
	case internalpolicyhistory.FieldDismissedImprovementSuggestions:
		return m.DismissedImprovementSuggestions()
	case internalpolicyhistory.FieldURL:
		return m.URL()
	case internalpolicyhistory.FieldFileID:
		return m.FileID()
	case internalpolicyhistory.FieldInternalPolicyKindName:
		return m.InternalPolicyKindName()
	case internalpolicyhistory.FieldInternalPolicyKindID:
		return m.InternalPolicyKindID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InternalPolicyHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case internalpolicyhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case internalpolicyhistory.FieldRef:
		return m.OldRef(ctx)
	case internalpolicyhistory.FieldOperation:
		return m.OldOperation(ctx)
	case internalpolicyhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case internalpolicyhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case internalpolicyhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case internalpolicyhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case internalpolicyhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case internalpolicyhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case internalpolicyhistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case internalpolicyhistory.FieldTags:
		return m.OldTags(ctx)
	case internalpolicyhistory.FieldRevision:
		return m.OldRevision(ctx)
	case internalpolicyhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case internalpolicyhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case internalpolicyhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case internalpolicyhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case internalpolicyhistory.FieldName:
		return m.OldName(ctx)
	case internalpolicyhistory.FieldStatus:
		return m.OldStatus(ctx)
	case internalpolicyhistory.FieldPolicyType:
		return m.OldPolicyType(ctx)
	case internalpolicyhistory.FieldDetails:
		return m.OldDetails(ctx)
	case internalpolicyhistory.FieldApprovalRequired:
		return m.OldApprovalRequired(ctx)
	case internalpolicyhistory.FieldReviewDue:
		return m.OldReviewDue(ctx)
	case internalpolicyhistory.FieldReviewFrequency:
		return m.OldReviewFrequency(ctx)
	case internalpolicyhistory.FieldApproverID:
		return m.OldApproverID(ctx)
	case internalpolicyhistory.FieldDelegateID:
		return m.OldDelegateID(ctx)
	case internalpolicyhistory.FieldSummary:
		return m.OldSummary(ctx)
	case internalpolicyhistory.FieldTagSuggestions:
		return m.OldTagSuggestions(ctx)
	case internalpolicyhistory.FieldDismissedTagSuggestions:
		return m.OldDismissedTagSuggestions(ctx)
	case internalpolicyhistory.FieldControlSuggestions:
		return m.OldControlSuggestions(ctx)
	case internalpolicyhistory.FieldDismissedControlSuggestions:
		return m.OldDismissedControlSuggestions(ctx)
	case internalpolicyhistory.FieldImprovementSuggestions:
		return m.OldImprovementSuggestions(ctx)
	case internalpolicyhistory.FieldDismissedImprovementSuggestions:
		return m.OldDismissedImprovementSuggestions(ctx)
	case internalpolicyhistory.FieldURL:
		return m.OldURL(ctx)
	case internalpolicyhistory.FieldFileID:
		return m.OldFileID(ctx)
	case internalpolicyhistory.FieldInternalPolicyKindName:
		return m.OldInternalPolicyKindName(ctx)
	case internalpolicyhistory.FieldInternalPolicyKindID:
		return m.OldInternalPolicyKindID(ctx)
	}
	return nil, fmt.Errorf("unknown InternalPolicyHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternalPolicyHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case internalpolicyhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case internalpolicyhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case internalpolicyhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case internalpolicyhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case internalpolicyhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case internalpolicyhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case internalpolicyhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case internalpolicyhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case internalpolicyhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case internalpolicyhistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case internalpolicyhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case internalpolicyhistory.FieldRevision:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case internalpolicyhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case internalpolicyhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case internalpolicyhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case internalpolicyhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case internalpolicyhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case internalpolicyhistory.FieldStatus:
		v, ok := value.(enums.DocumentStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case internalpolicyhistory.FieldPolicyType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicyType(v)
		return nil
	case internalpolicyhistory.FieldDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case internalpolicyhistory.FieldApprovalRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalRequired(v)
		return nil
	case internalpolicyhistory.FieldReviewDue:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewDue(v)
		return nil
	case internalpolicyhistory.FieldReviewFrequency:
		v, ok := value.(enums.Frequency)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewFrequency(v)
		return nil
	case internalpolicyhistory.FieldApproverID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproverID(v)
		return nil
	case internalpolicyhistory.FieldDelegateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegateID(v)
		return nil
	case internalpolicyhistory.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case internalpolicyhistory.FieldTagSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagSuggestions(v)
		return nil
	case internalpolicyhistory.FieldDismissedTagSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDismissedTagSuggestions(v)
		return nil
	case internalpolicyhistory.FieldControlSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlSuggestions(v)
		return nil
	case internalpolicyhistory.FieldDismissedControlSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDismissedControlSuggestions(v)
		return nil
	case internalpolicyhistory.FieldImprovementSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImprovementSuggestions(v)
		return nil
	case internalpolicyhistory.FieldDismissedImprovementSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDismissedImprovementSuggestions(v)
		return nil
	case internalpolicyhistory.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case internalpolicyhistory.FieldFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case internalpolicyhistory.FieldInternalPolicyKindName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalPolicyKindName(v)
		return nil
	case internalpolicyhistory.FieldInternalPolicyKindID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalPolicyKindID(v)
		return nil
	}
	return fmt.Errorf("unknown InternalPolicyHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InternalPolicyHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InternalPolicyHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternalPolicyHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InternalPolicyHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InternalPolicyHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(internalpolicyhistory.FieldRef) {
		fields = append(fields, internalpolicyhistory.FieldRef)
	}
	if m.FieldCleared(internalpolicyhistory.FieldCreatedAt) {
		fields = append(fields, internalpolicyhistory.FieldCreatedAt)
	}
	if m.FieldCleared(internalpolicyhistory.FieldUpdatedAt) {
		fields = append(fields, internalpolicyhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(internalpolicyhistory.FieldCreatedBy) {
		fields = append(fields, internalpolicyhistory.FieldCreatedBy)
	}
	if m.FieldCleared(internalpolicyhistory.FieldUpdatedBy) {
		fields = append(fields, internalpolicyhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(internalpolicyhistory.FieldDeletedAt) {
		fields = append(fields, internalpolicyhistory.FieldDeletedAt)
	}
	if m.FieldCleared(internalpolicyhistory.FieldDeletedBy) {
		fields = append(fields, internalpolicyhistory.FieldDeletedBy)
	}
	if m.FieldCleared(internalpolicyhistory.FieldTags) {
		fields = append(fields, internalpolicyhistory.FieldTags)
	}
	if m.FieldCleared(internalpolicyhistory.FieldRevision) {
		fields = append(fields, internalpolicyhistory.FieldRevision)
	}
	if m.FieldCleared(internalpolicyhistory.FieldOwnerID) {
		fields = append(fields, internalpolicyhistory.FieldOwnerID)
	}
	if m.FieldCleared(internalpolicyhistory.FieldSystemOwned) {
		fields = append(fields, internalpolicyhistory.FieldSystemOwned)
	}
	if m.FieldCleared(internalpolicyhistory.FieldInternalNotes) {
		fields = append(fields, internalpolicyhistory.FieldInternalNotes)
	}
	if m.FieldCleared(internalpolicyhistory.FieldSystemInternalID) {
		fields = append(fields, internalpolicyhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(internalpolicyhistory.FieldStatus) {
		fields = append(fields, internalpolicyhistory.FieldStatus)
	}
	if m.FieldCleared(internalpolicyhistory.FieldPolicyType) {
		fields = append(fields, internalpolicyhistory.FieldPolicyType)
	}
	if m.FieldCleared(internalpolicyhistory.FieldDetails) {
		fields = append(fields, internalpolicyhistory.FieldDetails)
	}
	if m.FieldCleared(internalpolicyhistory.FieldApprovalRequired) {
		fields = append(fields, internalpolicyhistory.FieldApprovalRequired)
	}
	if m.FieldCleared(internalpolicyhistory.FieldReviewDue) {
		fields = append(fields, internalpolicyhistory.FieldReviewDue)
	}
	if m.FieldCleared(internalpolicyhistory.FieldReviewFrequency) {
		fields = append(fields, internalpolicyhistory.FieldReviewFrequency)
	}
	if m.FieldCleared(internalpolicyhistory.FieldApproverID) {
		fields = append(fields, internalpolicyhistory.FieldApproverID)
	}
	if m.FieldCleared(internalpolicyhistory.FieldDelegateID) {
		fields = append(fields, internalpolicyhistory.FieldDelegateID)
	}
	if m.FieldCleared(internalpolicyhistory.FieldSummary) {
		fields = append(fields, internalpolicyhistory.FieldSummary)
	}
	if m.FieldCleared(internalpolicyhistory.FieldTagSuggestions) {
		fields = append(fields, internalpolicyhistory.FieldTagSuggestions)
	}
	if m.FieldCleared(internalpolicyhistory.FieldDismissedTagSuggestions) {
		fields = append(fields, internalpolicyhistory.FieldDismissedTagSuggestions)
	}
	if m.FieldCleared(internalpolicyhistory.FieldControlSuggestions) {
		fields = append(fields, internalpolicyhistory.FieldControlSuggestions)
	}
	if m.FieldCleared(internalpolicyhistory.FieldDismissedControlSuggestions) {
		fields = append(fields, internalpolicyhistory.FieldDismissedControlSuggestions)
	}
	if m.FieldCleared(internalpolicyhistory.FieldImprovementSuggestions) {
		fields = append(fields, internalpolicyhistory.FieldImprovementSuggestions)
	}
	if m.FieldCleared(internalpolicyhistory.FieldDismissedImprovementSuggestions) {
		fields = append(fields, internalpolicyhistory.FieldDismissedImprovementSuggestions)
	}
	if m.FieldCleared(internalpolicyhistory.FieldURL) {
		fields = append(fields, internalpolicyhistory.FieldURL)
	}
	if m.FieldCleared(internalpolicyhistory.FieldFileID) {
		fields = append(fields, internalpolicyhistory.FieldFileID)
	}
	if m.FieldCleared(internalpolicyhistory.FieldInternalPolicyKindName) {
		fields = append(fields, internalpolicyhistory.FieldInternalPolicyKindName)
	}
	if m.FieldCleared(internalpolicyhistory.FieldInternalPolicyKindID) {
		fields = append(fields, internalpolicyhistory.FieldInternalPolicyKindID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InternalPolicyHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InternalPolicyHistoryMutation) ClearField(name string) error {
	switch name {
	case internalpolicyhistory.FieldRef:
		m.ClearRef()
		return nil
	case internalpolicyhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case internalpolicyhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case internalpolicyhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case internalpolicyhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case internalpolicyhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case internalpolicyhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case internalpolicyhistory.FieldTags:
		m.ClearTags()
		return nil
	case internalpolicyhistory.FieldRevision:
		m.ClearRevision()
		return nil
	case internalpolicyhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case internalpolicyhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case internalpolicyhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case internalpolicyhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case internalpolicyhistory.FieldStatus:
		m.ClearStatus()
		return nil
	case internalpolicyhistory.FieldPolicyType:
		m.ClearPolicyType()
		return nil
	case internalpolicyhistory.FieldDetails:
		m.ClearDetails()
		return nil
	case internalpolicyhistory.FieldApprovalRequired:
		m.ClearApprovalRequired()
		return nil
	case internalpolicyhistory.FieldReviewDue:
		m.ClearReviewDue()
		return nil
	case internalpolicyhistory.FieldReviewFrequency:
		m.ClearReviewFrequency()
		return nil
	case internalpolicyhistory.FieldApproverID:
		m.ClearApproverID()
		return nil
	case internalpolicyhistory.FieldDelegateID:
		m.ClearDelegateID()
		return nil
	case internalpolicyhistory.FieldSummary:
		m.ClearSummary()
		return nil
	case internalpolicyhistory.FieldTagSuggestions:
		m.ClearTagSuggestions()
		return nil
	case internalpolicyhistory.FieldDismissedTagSuggestions:
		m.ClearDismissedTagSuggestions()
		return nil
	case internalpolicyhistory.FieldControlSuggestions:
		m.ClearControlSuggestions()
		return nil
	case internalpolicyhistory.FieldDismissedControlSuggestions:
		m.ClearDismissedControlSuggestions()
		return nil
	case internalpolicyhistory.FieldImprovementSuggestions:
		m.ClearImprovementSuggestions()
		return nil
	case internalpolicyhistory.FieldDismissedImprovementSuggestions:
		m.ClearDismissedImprovementSuggestions()
		return nil
	case internalpolicyhistory.FieldURL:
		m.ClearURL()
		return nil
	case internalpolicyhistory.FieldFileID:
		m.ClearFileID()
		return nil
	case internalpolicyhistory.FieldInternalPolicyKindName:
		m.ClearInternalPolicyKindName()
		return nil
	case internalpolicyhistory.FieldInternalPolicyKindID:
		m.ClearInternalPolicyKindID()
		return nil
	}
	return fmt.Errorf("unknown InternalPolicyHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InternalPolicyHistoryMutation) ResetField(name string) error {
	switch name {
	case internalpolicyhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case internalpolicyhistory.FieldRef:
		m.ResetRef()
		return nil
	case internalpolicyhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case internalpolicyhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case internalpolicyhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case internalpolicyhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case internalpolicyhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case internalpolicyhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case internalpolicyhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case internalpolicyhistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case internalpolicyhistory.FieldTags:
		m.ResetTags()
		return nil
	case internalpolicyhistory.FieldRevision:
		m.ResetRevision()
		return nil
	case internalpolicyhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case internalpolicyhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case internalpolicyhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case internalpolicyhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case internalpolicyhistory.FieldName:
		m.ResetName()
		return nil
	case internalpolicyhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case internalpolicyhistory.FieldPolicyType:
		m.ResetPolicyType()
		return nil
	case internalpolicyhistory.FieldDetails:
		m.ResetDetails()
		return nil
	case internalpolicyhistory.FieldApprovalRequired:
		m.ResetApprovalRequired()
		return nil
	case internalpolicyhistory.FieldReviewDue:
		m.ResetReviewDue()
		return nil
	case internalpolicyhistory.FieldReviewFrequency:
		m.ResetReviewFrequency()
		return nil
	case internalpolicyhistory.FieldApproverID:
		m.ResetApproverID()
		return nil
	case internalpolicyhistory.FieldDelegateID:
		m.ResetDelegateID()
		return nil
	case internalpolicyhistory.FieldSummary:
		m.ResetSummary()
		return nil
	case internalpolicyhistory.FieldTagSuggestions:
		m.ResetTagSuggestions()
		return nil
	case internalpolicyhistory.FieldDismissedTagSuggestions:
		m.ResetDismissedTagSuggestions()
		return nil
	case internalpolicyhistory.FieldControlSuggestions:
		m.ResetControlSuggestions()
		return nil
	case internalpolicyhistory.FieldDismissedControlSuggestions:
		m.ResetDismissedControlSuggestions()
		return nil
	case internalpolicyhistory.FieldImprovementSuggestions:
		m.ResetImprovementSuggestions()
		return nil
	case internalpolicyhistory.FieldDismissedImprovementSuggestions:
		m.ResetDismissedImprovementSuggestions()
		return nil
	case internalpolicyhistory.FieldURL:
		m.ResetURL()
		return nil
	case internalpolicyhistory.FieldFileID:
		m.ResetFileID()
		return nil
	case internalpolicyhistory.FieldInternalPolicyKindName:
		m.ResetInternalPolicyKindName()
		return nil
	case internalpolicyhistory.FieldInternalPolicyKindID:
		m.ResetInternalPolicyKindID()
		return nil
	}
	return fmt.Errorf("unknown InternalPolicyHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InternalPolicyHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InternalPolicyHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InternalPolicyHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InternalPolicyHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InternalPolicyHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InternalPolicyHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InternalPolicyHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InternalPolicyHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InternalPolicyHistory edge %s", name)
}

// JobTemplateHistoryMutation represents an operation that mutates the JobTemplateHistory nodes in the graph.
type JobTemplateHistoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	history_time        *time.Time
	ref                 *string
	operation           *history.OpType
	created_at          *time.Time
	updated_at          *time.Time
	created_by          *string
	updated_by          *string
	deleted_at          *time.Time
	deleted_by          *string
	display_id          *string
	tags                *[]string
	appendtags          []string
	owner_id            *string
	system_owned        *bool
	internal_notes      *string
	system_internal_id  *string
	title               *string
	description         *string
	platform            *enums.JobPlatformType
	windmill_path       *string
	download_url        *string
	configuration       *models.JobConfiguration
	appendconfiguration models.JobConfiguration
	cron                *models.Cron
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*JobTemplateHistory, error)
	predicates          []predicate.JobTemplateHistory
}

var _ ent.Mutation = (*JobTemplateHistoryMutation)(nil)

// jobtemplatehistoryOption allows management of the mutation configuration using functional options.
type jobtemplatehistoryOption func(*JobTemplateHistoryMutation)

// newJobTemplateHistoryMutation creates new mutation for the JobTemplateHistory entity.
func newJobTemplateHistoryMutation(c config, op Op, opts ...jobtemplatehistoryOption) *JobTemplateHistoryMutation {
	m := &JobTemplateHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeJobTemplateHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobTemplateHistoryID sets the ID field of the mutation.
func withJobTemplateHistoryID(id string) jobtemplatehistoryOption {
	return func(m *JobTemplateHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *JobTemplateHistory
		)
		m.oldValue = func(ctx context.Context) (*JobTemplateHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobTemplateHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobTemplateHistory sets the old JobTemplateHistory of the mutation.
func withJobTemplateHistory(node *JobTemplateHistory) jobtemplatehistoryOption {
	return func(m *JobTemplateHistoryMutation) {
		m.oldValue = func(context.Context) (*JobTemplateHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobTemplateHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobTemplateHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobTemplateHistory entities.
func (m *JobTemplateHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobTemplateHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobTemplateHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobTemplateHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *JobTemplateHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *JobTemplateHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *JobTemplateHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *JobTemplateHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *JobTemplateHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *JobTemplateHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[jobtemplatehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *JobTemplateHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, jobtemplatehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *JobTemplateHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *JobTemplateHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *JobTemplateHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JobTemplateHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobTemplateHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *JobTemplateHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[jobtemplatehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobTemplateHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, jobtemplatehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobTemplateHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobTemplateHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *JobTemplateHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[jobtemplatehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobTemplateHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, jobtemplatehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *JobTemplateHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *JobTemplateHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *JobTemplateHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[jobtemplatehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *JobTemplateHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, jobtemplatehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *JobTemplateHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *JobTemplateHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *JobTemplateHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[jobtemplatehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *JobTemplateHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, jobtemplatehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *JobTemplateHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *JobTemplateHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *JobTemplateHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[jobtemplatehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *JobTemplateHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, jobtemplatehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *JobTemplateHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *JobTemplateHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *JobTemplateHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[jobtemplatehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *JobTemplateHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, jobtemplatehistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *JobTemplateHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *JobTemplateHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *JobTemplateHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *JobTemplateHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *JobTemplateHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *JobTemplateHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *JobTemplateHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *JobTemplateHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[jobtemplatehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *JobTemplateHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, jobtemplatehistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *JobTemplateHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *JobTemplateHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *JobTemplateHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[jobtemplatehistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *JobTemplateHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, jobtemplatehistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *JobTemplateHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *JobTemplateHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *JobTemplateHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[jobtemplatehistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *JobTemplateHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, jobtemplatehistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *JobTemplateHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *JobTemplateHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *JobTemplateHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[jobtemplatehistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *JobTemplateHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, jobtemplatehistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *JobTemplateHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *JobTemplateHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *JobTemplateHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[jobtemplatehistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *JobTemplateHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, jobtemplatehistory.FieldSystemInternalID)
}

// SetTitle sets the "title" field.
func (m *JobTemplateHistoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *JobTemplateHistoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *JobTemplateHistoryMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *JobTemplateHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *JobTemplateHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *JobTemplateHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[jobtemplatehistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *JobTemplateHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, jobtemplatehistory.FieldDescription)
}

// SetPlatform sets the "platform" field.
func (m *JobTemplateHistoryMutation) SetPlatform(ept enums.JobPlatformType) {
	m.platform = &ept
}

// Platform returns the value of the "platform" field in the mutation.
func (m *JobTemplateHistoryMutation) Platform() (r enums.JobPlatformType, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldPlatform(ctx context.Context) (v enums.JobPlatformType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *JobTemplateHistoryMutation) ResetPlatform() {
	m.platform = nil
}

// SetWindmillPath sets the "windmill_path" field.
func (m *JobTemplateHistoryMutation) SetWindmillPath(s string) {
	m.windmill_path = &s
}

// WindmillPath returns the value of the "windmill_path" field in the mutation.
func (m *JobTemplateHistoryMutation) WindmillPath() (r string, exists bool) {
	v := m.windmill_path
	if v == nil {
		return
	}
	return *v, true
}

// OldWindmillPath returns the old "windmill_path" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldWindmillPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWindmillPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWindmillPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindmillPath: %w", err)
	}
	return oldValue.WindmillPath, nil
}

// ClearWindmillPath clears the value of the "windmill_path" field.
func (m *JobTemplateHistoryMutation) ClearWindmillPath() {
	m.windmill_path = nil
	m.clearedFields[jobtemplatehistory.FieldWindmillPath] = struct{}{}
}

// WindmillPathCleared returns if the "windmill_path" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) WindmillPathCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldWindmillPath]
	return ok
}

// ResetWindmillPath resets all changes to the "windmill_path" field.
func (m *JobTemplateHistoryMutation) ResetWindmillPath() {
	m.windmill_path = nil
	delete(m.clearedFields, jobtemplatehistory.FieldWindmillPath)
}

// SetDownloadURL sets the "download_url" field.
func (m *JobTemplateHistoryMutation) SetDownloadURL(s string) {
	m.download_url = &s
}

// DownloadURL returns the value of the "download_url" field in the mutation.
func (m *JobTemplateHistoryMutation) DownloadURL() (r string, exists bool) {
	v := m.download_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadURL returns the old "download_url" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldDownloadURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadURL: %w", err)
	}
	return oldValue.DownloadURL, nil
}

// ResetDownloadURL resets all changes to the "download_url" field.
func (m *JobTemplateHistoryMutation) ResetDownloadURL() {
	m.download_url = nil
}

// SetConfiguration sets the "configuration" field.
func (m *JobTemplateHistoryMutation) SetConfiguration(mc models.JobConfiguration) {
	m.configuration = &mc
	m.appendconfiguration = nil
}

// Configuration returns the value of the "configuration" field in the mutation.
func (m *JobTemplateHistoryMutation) Configuration() (r models.JobConfiguration, exists bool) {
	v := m.configuration
	if v == nil {
		return
	}
	return *v, true
}

// OldConfiguration returns the old "configuration" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldConfiguration(ctx context.Context) (v models.JobConfiguration, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfiguration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfiguration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfiguration: %w", err)
	}
	return oldValue.Configuration, nil
}

// AppendConfiguration adds mc to the "configuration" field.
func (m *JobTemplateHistoryMutation) AppendConfiguration(mc models.JobConfiguration) {
	m.appendconfiguration = append(m.appendconfiguration, mc...)
}

// AppendedConfiguration returns the list of values that were appended to the "configuration" field in this mutation.
func (m *JobTemplateHistoryMutation) AppendedConfiguration() (models.JobConfiguration, bool) {
	if len(m.appendconfiguration) == 0 {
		return nil, false
	}
	return m.appendconfiguration, true
}

// ClearConfiguration clears the value of the "configuration" field.
func (m *JobTemplateHistoryMutation) ClearConfiguration() {
	m.configuration = nil
	m.appendconfiguration = nil
	m.clearedFields[jobtemplatehistory.FieldConfiguration] = struct{}{}
}

// ConfigurationCleared returns if the "configuration" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) ConfigurationCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldConfiguration]
	return ok
}

// ResetConfiguration resets all changes to the "configuration" field.
func (m *JobTemplateHistoryMutation) ResetConfiguration() {
	m.configuration = nil
	m.appendconfiguration = nil
	delete(m.clearedFields, jobtemplatehistory.FieldConfiguration)
}

// SetCron sets the "cron" field.
func (m *JobTemplateHistoryMutation) SetCron(value models.Cron) {
	m.cron = &value
}

// Cron returns the value of the "cron" field in the mutation.
func (m *JobTemplateHistoryMutation) Cron() (r models.Cron, exists bool) {
	v := m.cron
	if v == nil {
		return
	}
	return *v, true
}

// OldCron returns the old "cron" field's value of the JobTemplateHistory entity.
// If the JobTemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobTemplateHistoryMutation) OldCron(ctx context.Context) (v *models.Cron, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCron is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCron requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCron: %w", err)
	}
	return oldValue.Cron, nil
}

// ClearCron clears the value of the "cron" field.
func (m *JobTemplateHistoryMutation) ClearCron() {
	m.cron = nil
	m.clearedFields[jobtemplatehistory.FieldCron] = struct{}{}
}

// CronCleared returns if the "cron" field was cleared in this mutation.
func (m *JobTemplateHistoryMutation) CronCleared() bool {
	_, ok := m.clearedFields[jobtemplatehistory.FieldCron]
	return ok
}

// ResetCron resets all changes to the "cron" field.
func (m *JobTemplateHistoryMutation) ResetCron() {
	m.cron = nil
	delete(m.clearedFields, jobtemplatehistory.FieldCron)
}

// Where appends a list predicates to the JobTemplateHistoryMutation builder.
func (m *JobTemplateHistoryMutation) Where(ps ...predicate.JobTemplateHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobTemplateHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobTemplateHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobTemplateHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobTemplateHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobTemplateHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobTemplateHistory).
func (m *JobTemplateHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobTemplateHistoryMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.history_time != nil {
		fields = append(fields, jobtemplatehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, jobtemplatehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, jobtemplatehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, jobtemplatehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jobtemplatehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, jobtemplatehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, jobtemplatehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, jobtemplatehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, jobtemplatehistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, jobtemplatehistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, jobtemplatehistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, jobtemplatehistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, jobtemplatehistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, jobtemplatehistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, jobtemplatehistory.FieldSystemInternalID)
	}
	if m.title != nil {
		fields = append(fields, jobtemplatehistory.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, jobtemplatehistory.FieldDescription)
	}
	if m.platform != nil {
		fields = append(fields, jobtemplatehistory.FieldPlatform)
	}
	if m.windmill_path != nil {
		fields = append(fields, jobtemplatehistory.FieldWindmillPath)
	}
	if m.download_url != nil {
		fields = append(fields, jobtemplatehistory.FieldDownloadURL)
	}
	if m.configuration != nil {
		fields = append(fields, jobtemplatehistory.FieldConfiguration)
	}
	if m.cron != nil {
		fields = append(fields, jobtemplatehistory.FieldCron)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobTemplateHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobtemplatehistory.FieldHistoryTime:
		return m.HistoryTime()
	case jobtemplatehistory.FieldRef:
		return m.Ref()
	case jobtemplatehistory.FieldOperation:
		return m.Operation()
	case jobtemplatehistory.FieldCreatedAt:
		return m.CreatedAt()
	case jobtemplatehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case jobtemplatehistory.FieldCreatedBy:
		return m.CreatedBy()
	case jobtemplatehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case jobtemplatehistory.FieldDeletedAt:
		return m.DeletedAt()
	case jobtemplatehistory.FieldDeletedBy:
		return m.DeletedBy()
	case jobtemplatehistory.FieldDisplayID:
		return m.DisplayID()
	case jobtemplatehistory.FieldTags:
		return m.Tags()
	case jobtemplatehistory.FieldOwnerID:
		return m.OwnerID()
	case jobtemplatehistory.FieldSystemOwned:
		return m.SystemOwned()
	case jobtemplatehistory.FieldInternalNotes:
		return m.InternalNotes()
	case jobtemplatehistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case jobtemplatehistory.FieldTitle:
		return m.Title()
	case jobtemplatehistory.FieldDescription:
		return m.Description()
	case jobtemplatehistory.FieldPlatform:
		return m.Platform()
	case jobtemplatehistory.FieldWindmillPath:
		return m.WindmillPath()
	case jobtemplatehistory.FieldDownloadURL:
		return m.DownloadURL()
	case jobtemplatehistory.FieldConfiguration:
		return m.Configuration()
	case jobtemplatehistory.FieldCron:
		return m.Cron()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobTemplateHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobtemplatehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case jobtemplatehistory.FieldRef:
		return m.OldRef(ctx)
	case jobtemplatehistory.FieldOperation:
		return m.OldOperation(ctx)
	case jobtemplatehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobtemplatehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case jobtemplatehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case jobtemplatehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case jobtemplatehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case jobtemplatehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case jobtemplatehistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case jobtemplatehistory.FieldTags:
		return m.OldTags(ctx)
	case jobtemplatehistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case jobtemplatehistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case jobtemplatehistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case jobtemplatehistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case jobtemplatehistory.FieldTitle:
		return m.OldTitle(ctx)
	case jobtemplatehistory.FieldDescription:
		return m.OldDescription(ctx)
	case jobtemplatehistory.FieldPlatform:
		return m.OldPlatform(ctx)
	case jobtemplatehistory.FieldWindmillPath:
		return m.OldWindmillPath(ctx)
	case jobtemplatehistory.FieldDownloadURL:
		return m.OldDownloadURL(ctx)
	case jobtemplatehistory.FieldConfiguration:
		return m.OldConfiguration(ctx)
	case jobtemplatehistory.FieldCron:
		return m.OldCron(ctx)
	}
	return nil, fmt.Errorf("unknown JobTemplateHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobTemplateHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobtemplatehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case jobtemplatehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case jobtemplatehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case jobtemplatehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobtemplatehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case jobtemplatehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case jobtemplatehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case jobtemplatehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case jobtemplatehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case jobtemplatehistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case jobtemplatehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case jobtemplatehistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case jobtemplatehistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case jobtemplatehistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case jobtemplatehistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case jobtemplatehistory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case jobtemplatehistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case jobtemplatehistory.FieldPlatform:
		v, ok := value.(enums.JobPlatformType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case jobtemplatehistory.FieldWindmillPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindmillPath(v)
		return nil
	case jobtemplatehistory.FieldDownloadURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadURL(v)
		return nil
	case jobtemplatehistory.FieldConfiguration:
		v, ok := value.(models.JobConfiguration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfiguration(v)
		return nil
	case jobtemplatehistory.FieldCron:
		v, ok := value.(models.Cron)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCron(v)
		return nil
	}
	return fmt.Errorf("unknown JobTemplateHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobTemplateHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobTemplateHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobTemplateHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobTemplateHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobTemplateHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobtemplatehistory.FieldRef) {
		fields = append(fields, jobtemplatehistory.FieldRef)
	}
	if m.FieldCleared(jobtemplatehistory.FieldCreatedAt) {
		fields = append(fields, jobtemplatehistory.FieldCreatedAt)
	}
	if m.FieldCleared(jobtemplatehistory.FieldUpdatedAt) {
		fields = append(fields, jobtemplatehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(jobtemplatehistory.FieldCreatedBy) {
		fields = append(fields, jobtemplatehistory.FieldCreatedBy)
	}
	if m.FieldCleared(jobtemplatehistory.FieldUpdatedBy) {
		fields = append(fields, jobtemplatehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(jobtemplatehistory.FieldDeletedAt) {
		fields = append(fields, jobtemplatehistory.FieldDeletedAt)
	}
	if m.FieldCleared(jobtemplatehistory.FieldDeletedBy) {
		fields = append(fields, jobtemplatehistory.FieldDeletedBy)
	}
	if m.FieldCleared(jobtemplatehistory.FieldTags) {
		fields = append(fields, jobtemplatehistory.FieldTags)
	}
	if m.FieldCleared(jobtemplatehistory.FieldOwnerID) {
		fields = append(fields, jobtemplatehistory.FieldOwnerID)
	}
	if m.FieldCleared(jobtemplatehistory.FieldSystemOwned) {
		fields = append(fields, jobtemplatehistory.FieldSystemOwned)
	}
	if m.FieldCleared(jobtemplatehistory.FieldInternalNotes) {
		fields = append(fields, jobtemplatehistory.FieldInternalNotes)
	}
	if m.FieldCleared(jobtemplatehistory.FieldSystemInternalID) {
		fields = append(fields, jobtemplatehistory.FieldSystemInternalID)
	}
	if m.FieldCleared(jobtemplatehistory.FieldDescription) {
		fields = append(fields, jobtemplatehistory.FieldDescription)
	}
	if m.FieldCleared(jobtemplatehistory.FieldWindmillPath) {
		fields = append(fields, jobtemplatehistory.FieldWindmillPath)
	}
	if m.FieldCleared(jobtemplatehistory.FieldConfiguration) {
		fields = append(fields, jobtemplatehistory.FieldConfiguration)
	}
	if m.FieldCleared(jobtemplatehistory.FieldCron) {
		fields = append(fields, jobtemplatehistory.FieldCron)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobTemplateHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobTemplateHistoryMutation) ClearField(name string) error {
	switch name {
	case jobtemplatehistory.FieldRef:
		m.ClearRef()
		return nil
	case jobtemplatehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case jobtemplatehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case jobtemplatehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case jobtemplatehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case jobtemplatehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case jobtemplatehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case jobtemplatehistory.FieldTags:
		m.ClearTags()
		return nil
	case jobtemplatehistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case jobtemplatehistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case jobtemplatehistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case jobtemplatehistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case jobtemplatehistory.FieldDescription:
		m.ClearDescription()
		return nil
	case jobtemplatehistory.FieldWindmillPath:
		m.ClearWindmillPath()
		return nil
	case jobtemplatehistory.FieldConfiguration:
		m.ClearConfiguration()
		return nil
	case jobtemplatehistory.FieldCron:
		m.ClearCron()
		return nil
	}
	return fmt.Errorf("unknown JobTemplateHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobTemplateHistoryMutation) ResetField(name string) error {
	switch name {
	case jobtemplatehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case jobtemplatehistory.FieldRef:
		m.ResetRef()
		return nil
	case jobtemplatehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case jobtemplatehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobtemplatehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case jobtemplatehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case jobtemplatehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case jobtemplatehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case jobtemplatehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case jobtemplatehistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case jobtemplatehistory.FieldTags:
		m.ResetTags()
		return nil
	case jobtemplatehistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case jobtemplatehistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case jobtemplatehistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case jobtemplatehistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case jobtemplatehistory.FieldTitle:
		m.ResetTitle()
		return nil
	case jobtemplatehistory.FieldDescription:
		m.ResetDescription()
		return nil
	case jobtemplatehistory.FieldPlatform:
		m.ResetPlatform()
		return nil
	case jobtemplatehistory.FieldWindmillPath:
		m.ResetWindmillPath()
		return nil
	case jobtemplatehistory.FieldDownloadURL:
		m.ResetDownloadURL()
		return nil
	case jobtemplatehistory.FieldConfiguration:
		m.ResetConfiguration()
		return nil
	case jobtemplatehistory.FieldCron:
		m.ResetCron()
		return nil
	}
	return fmt.Errorf("unknown JobTemplateHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobTemplateHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobTemplateHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobTemplateHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobTemplateHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobTemplateHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobTemplateHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobTemplateHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown JobTemplateHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobTemplateHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown JobTemplateHistory edge %s", name)
}

// MappableDomainHistoryMutation represents an operation that mutates the MappableDomainHistory nodes in the graph.
type MappableDomainHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	deleted_at    *time.Time
	deleted_by    *string
	tags          *[]string
	appendtags    []string
	name          *string
	zone_id       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MappableDomainHistory, error)
	predicates    []predicate.MappableDomainHistory
}

var _ ent.Mutation = (*MappableDomainHistoryMutation)(nil)

// mappabledomainhistoryOption allows management of the mutation configuration using functional options.
type mappabledomainhistoryOption func(*MappableDomainHistoryMutation)

// newMappableDomainHistoryMutation creates new mutation for the MappableDomainHistory entity.
func newMappableDomainHistoryMutation(c config, op Op, opts ...mappabledomainhistoryOption) *MappableDomainHistoryMutation {
	m := &MappableDomainHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeMappableDomainHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMappableDomainHistoryID sets the ID field of the mutation.
func withMappableDomainHistoryID(id string) mappabledomainhistoryOption {
	return func(m *MappableDomainHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *MappableDomainHistory
		)
		m.oldValue = func(ctx context.Context) (*MappableDomainHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MappableDomainHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMappableDomainHistory sets the old MappableDomainHistory of the mutation.
func withMappableDomainHistory(node *MappableDomainHistory) mappabledomainhistoryOption {
	return func(m *MappableDomainHistoryMutation) {
		m.oldValue = func(context.Context) (*MappableDomainHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MappableDomainHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MappableDomainHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MappableDomainHistory entities.
func (m *MappableDomainHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MappableDomainHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MappableDomainHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MappableDomainHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *MappableDomainHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *MappableDomainHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the MappableDomainHistory entity.
// If the MappableDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappableDomainHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *MappableDomainHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *MappableDomainHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *MappableDomainHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the MappableDomainHistory entity.
// If the MappableDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappableDomainHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *MappableDomainHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[mappabledomainhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *MappableDomainHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[mappabledomainhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *MappableDomainHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, mappabledomainhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *MappableDomainHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *MappableDomainHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the MappableDomainHistory entity.
// If the MappableDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappableDomainHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *MappableDomainHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MappableDomainHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MappableDomainHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MappableDomainHistory entity.
// If the MappableDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappableDomainHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MappableDomainHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[mappabledomainhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MappableDomainHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[mappabledomainhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MappableDomainHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, mappabledomainhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MappableDomainHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MappableDomainHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MappableDomainHistory entity.
// If the MappableDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappableDomainHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MappableDomainHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[mappabledomainhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MappableDomainHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[mappabledomainhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MappableDomainHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, mappabledomainhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *MappableDomainHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MappableDomainHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MappableDomainHistory entity.
// If the MappableDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappableDomainHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *MappableDomainHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[mappabledomainhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *MappableDomainHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[mappabledomainhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MappableDomainHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, mappabledomainhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MappableDomainHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MappableDomainHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MappableDomainHistory entity.
// If the MappableDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappableDomainHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *MappableDomainHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[mappabledomainhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *MappableDomainHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[mappabledomainhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MappableDomainHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, mappabledomainhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MappableDomainHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MappableDomainHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MappableDomainHistory entity.
// If the MappableDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappableDomainHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MappableDomainHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[mappabledomainhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MappableDomainHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[mappabledomainhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MappableDomainHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, mappabledomainhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *MappableDomainHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *MappableDomainHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the MappableDomainHistory entity.
// If the MappableDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappableDomainHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *MappableDomainHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[mappabledomainhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *MappableDomainHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[mappabledomainhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *MappableDomainHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, mappabledomainhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *MappableDomainHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *MappableDomainHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the MappableDomainHistory entity.
// If the MappableDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappableDomainHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *MappableDomainHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *MappableDomainHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *MappableDomainHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[mappabledomainhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *MappableDomainHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[mappabledomainhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *MappableDomainHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, mappabledomainhistory.FieldTags)
}

// SetName sets the "name" field.
func (m *MappableDomainHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MappableDomainHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MappableDomainHistory entity.
// If the MappableDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappableDomainHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MappableDomainHistoryMutation) ResetName() {
	m.name = nil
}

// SetZoneID sets the "zone_id" field.
func (m *MappableDomainHistoryMutation) SetZoneID(s string) {
	m.zone_id = &s
}

// ZoneID returns the value of the "zone_id" field in the mutation.
func (m *MappableDomainHistoryMutation) ZoneID() (r string, exists bool) {
	v := m.zone_id
	if v == nil {
		return
	}
	return *v, true
}

// OldZoneID returns the old "zone_id" field's value of the MappableDomainHistory entity.
// If the MappableDomainHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappableDomainHistoryMutation) OldZoneID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZoneID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZoneID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZoneID: %w", err)
	}
	return oldValue.ZoneID, nil
}

// ResetZoneID resets all changes to the "zone_id" field.
func (m *MappableDomainHistoryMutation) ResetZoneID() {
	m.zone_id = nil
}

// Where appends a list predicates to the MappableDomainHistoryMutation builder.
func (m *MappableDomainHistoryMutation) Where(ps ...predicate.MappableDomainHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MappableDomainHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MappableDomainHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MappableDomainHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MappableDomainHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MappableDomainHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MappableDomainHistory).
func (m *MappableDomainHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MappableDomainHistoryMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.history_time != nil {
		fields = append(fields, mappabledomainhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, mappabledomainhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, mappabledomainhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, mappabledomainhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mappabledomainhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, mappabledomainhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, mappabledomainhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, mappabledomainhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, mappabledomainhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, mappabledomainhistory.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, mappabledomainhistory.FieldName)
	}
	if m.zone_id != nil {
		fields = append(fields, mappabledomainhistory.FieldZoneID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MappableDomainHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mappabledomainhistory.FieldHistoryTime:
		return m.HistoryTime()
	case mappabledomainhistory.FieldRef:
		return m.Ref()
	case mappabledomainhistory.FieldOperation:
		return m.Operation()
	case mappabledomainhistory.FieldCreatedAt:
		return m.CreatedAt()
	case mappabledomainhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case mappabledomainhistory.FieldCreatedBy:
		return m.CreatedBy()
	case mappabledomainhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case mappabledomainhistory.FieldDeletedAt:
		return m.DeletedAt()
	case mappabledomainhistory.FieldDeletedBy:
		return m.DeletedBy()
	case mappabledomainhistory.FieldTags:
		return m.Tags()
	case mappabledomainhistory.FieldName:
		return m.Name()
	case mappabledomainhistory.FieldZoneID:
		return m.ZoneID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MappableDomainHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mappabledomainhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case mappabledomainhistory.FieldRef:
		return m.OldRef(ctx)
	case mappabledomainhistory.FieldOperation:
		return m.OldOperation(ctx)
	case mappabledomainhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mappabledomainhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mappabledomainhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case mappabledomainhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case mappabledomainhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case mappabledomainhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case mappabledomainhistory.FieldTags:
		return m.OldTags(ctx)
	case mappabledomainhistory.FieldName:
		return m.OldName(ctx)
	case mappabledomainhistory.FieldZoneID:
		return m.OldZoneID(ctx)
	}
	return nil, fmt.Errorf("unknown MappableDomainHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MappableDomainHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mappabledomainhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case mappabledomainhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case mappabledomainhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case mappabledomainhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mappabledomainhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mappabledomainhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case mappabledomainhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case mappabledomainhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case mappabledomainhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case mappabledomainhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case mappabledomainhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case mappabledomainhistory.FieldZoneID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZoneID(v)
		return nil
	}
	return fmt.Errorf("unknown MappableDomainHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MappableDomainHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MappableDomainHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MappableDomainHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MappableDomainHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MappableDomainHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mappabledomainhistory.FieldRef) {
		fields = append(fields, mappabledomainhistory.FieldRef)
	}
	if m.FieldCleared(mappabledomainhistory.FieldCreatedAt) {
		fields = append(fields, mappabledomainhistory.FieldCreatedAt)
	}
	if m.FieldCleared(mappabledomainhistory.FieldUpdatedAt) {
		fields = append(fields, mappabledomainhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(mappabledomainhistory.FieldCreatedBy) {
		fields = append(fields, mappabledomainhistory.FieldCreatedBy)
	}
	if m.FieldCleared(mappabledomainhistory.FieldUpdatedBy) {
		fields = append(fields, mappabledomainhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(mappabledomainhistory.FieldDeletedAt) {
		fields = append(fields, mappabledomainhistory.FieldDeletedAt)
	}
	if m.FieldCleared(mappabledomainhistory.FieldDeletedBy) {
		fields = append(fields, mappabledomainhistory.FieldDeletedBy)
	}
	if m.FieldCleared(mappabledomainhistory.FieldTags) {
		fields = append(fields, mappabledomainhistory.FieldTags)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MappableDomainHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MappableDomainHistoryMutation) ClearField(name string) error {
	switch name {
	case mappabledomainhistory.FieldRef:
		m.ClearRef()
		return nil
	case mappabledomainhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case mappabledomainhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case mappabledomainhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case mappabledomainhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case mappabledomainhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case mappabledomainhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case mappabledomainhistory.FieldTags:
		m.ClearTags()
		return nil
	}
	return fmt.Errorf("unknown MappableDomainHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MappableDomainHistoryMutation) ResetField(name string) error {
	switch name {
	case mappabledomainhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case mappabledomainhistory.FieldRef:
		m.ResetRef()
		return nil
	case mappabledomainhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case mappabledomainhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mappabledomainhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mappabledomainhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case mappabledomainhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case mappabledomainhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case mappabledomainhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case mappabledomainhistory.FieldTags:
		m.ResetTags()
		return nil
	case mappabledomainhistory.FieldName:
		m.ResetName()
		return nil
	case mappabledomainhistory.FieldZoneID:
		m.ResetZoneID()
		return nil
	}
	return fmt.Errorf("unknown MappableDomainHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MappableDomainHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MappableDomainHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MappableDomainHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MappableDomainHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MappableDomainHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MappableDomainHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MappableDomainHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MappableDomainHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MappableDomainHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MappableDomainHistory edge %s", name)
}

// MappedControlHistoryMutation represents an operation that mutates the MappedControlHistory nodes in the graph.
type MappedControlHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	history_time       *time.Time
	ref                *string
	operation          *history.OpType
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	deleted_at         *time.Time
	deleted_by         *string
	tags               *[]string
	appendtags         []string
	system_owned       *bool
	internal_notes     *string
	system_internal_id *string
	owner_id           *string
	mapping_type       *enums.MappingType
	relation           *string
	confidence         *int
	addconfidence      *int
	source             *enums.MappingSource
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*MappedControlHistory, error)
	predicates         []predicate.MappedControlHistory
}

var _ ent.Mutation = (*MappedControlHistoryMutation)(nil)

// mappedcontrolhistoryOption allows management of the mutation configuration using functional options.
type mappedcontrolhistoryOption func(*MappedControlHistoryMutation)

// newMappedControlHistoryMutation creates new mutation for the MappedControlHistory entity.
func newMappedControlHistoryMutation(c config, op Op, opts ...mappedcontrolhistoryOption) *MappedControlHistoryMutation {
	m := &MappedControlHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeMappedControlHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMappedControlHistoryID sets the ID field of the mutation.
func withMappedControlHistoryID(id string) mappedcontrolhistoryOption {
	return func(m *MappedControlHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *MappedControlHistory
		)
		m.oldValue = func(ctx context.Context) (*MappedControlHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MappedControlHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMappedControlHistory sets the old MappedControlHistory of the mutation.
func withMappedControlHistory(node *MappedControlHistory) mappedcontrolhistoryOption {
	return func(m *MappedControlHistoryMutation) {
		m.oldValue = func(context.Context) (*MappedControlHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MappedControlHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MappedControlHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MappedControlHistory entities.
func (m *MappedControlHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MappedControlHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MappedControlHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MappedControlHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *MappedControlHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *MappedControlHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *MappedControlHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *MappedControlHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *MappedControlHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *MappedControlHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[mappedcontrolhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *MappedControlHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[mappedcontrolhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *MappedControlHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, mappedcontrolhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *MappedControlHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *MappedControlHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *MappedControlHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MappedControlHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MappedControlHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MappedControlHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[mappedcontrolhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MappedControlHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[mappedcontrolhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MappedControlHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, mappedcontrolhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MappedControlHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MappedControlHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MappedControlHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[mappedcontrolhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MappedControlHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[mappedcontrolhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MappedControlHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, mappedcontrolhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *MappedControlHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MappedControlHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *MappedControlHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[mappedcontrolhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *MappedControlHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[mappedcontrolhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MappedControlHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, mappedcontrolhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MappedControlHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MappedControlHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *MappedControlHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[mappedcontrolhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *MappedControlHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[mappedcontrolhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MappedControlHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, mappedcontrolhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MappedControlHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MappedControlHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MappedControlHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[mappedcontrolhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MappedControlHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[mappedcontrolhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MappedControlHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, mappedcontrolhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *MappedControlHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *MappedControlHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *MappedControlHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[mappedcontrolhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *MappedControlHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[mappedcontrolhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *MappedControlHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, mappedcontrolhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *MappedControlHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *MappedControlHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *MappedControlHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *MappedControlHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *MappedControlHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[mappedcontrolhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *MappedControlHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[mappedcontrolhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *MappedControlHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, mappedcontrolhistory.FieldTags)
}

// SetSystemOwned sets the "system_owned" field.
func (m *MappedControlHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *MappedControlHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *MappedControlHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[mappedcontrolhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *MappedControlHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[mappedcontrolhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *MappedControlHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, mappedcontrolhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *MappedControlHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *MappedControlHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *MappedControlHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[mappedcontrolhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *MappedControlHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[mappedcontrolhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *MappedControlHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, mappedcontrolhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *MappedControlHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *MappedControlHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *MappedControlHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[mappedcontrolhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *MappedControlHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[mappedcontrolhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *MappedControlHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, mappedcontrolhistory.FieldSystemInternalID)
}

// SetOwnerID sets the "owner_id" field.
func (m *MappedControlHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *MappedControlHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *MappedControlHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[mappedcontrolhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *MappedControlHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[mappedcontrolhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *MappedControlHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, mappedcontrolhistory.FieldOwnerID)
}

// SetMappingType sets the "mapping_type" field.
func (m *MappedControlHistoryMutation) SetMappingType(et enums.MappingType) {
	m.mapping_type = &et
}

// MappingType returns the value of the "mapping_type" field in the mutation.
func (m *MappedControlHistoryMutation) MappingType() (r enums.MappingType, exists bool) {
	v := m.mapping_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingType returns the old "mapping_type" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldMappingType(ctx context.Context) (v enums.MappingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingType: %w", err)
	}
	return oldValue.MappingType, nil
}

// ResetMappingType resets all changes to the "mapping_type" field.
func (m *MappedControlHistoryMutation) ResetMappingType() {
	m.mapping_type = nil
}

// SetRelation sets the "relation" field.
func (m *MappedControlHistoryMutation) SetRelation(s string) {
	m.relation = &s
}

// Relation returns the value of the "relation" field in the mutation.
func (m *MappedControlHistoryMutation) Relation() (r string, exists bool) {
	v := m.relation
	if v == nil {
		return
	}
	return *v, true
}

// OldRelation returns the old "relation" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldRelation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelation: %w", err)
	}
	return oldValue.Relation, nil
}

// ClearRelation clears the value of the "relation" field.
func (m *MappedControlHistoryMutation) ClearRelation() {
	m.relation = nil
	m.clearedFields[mappedcontrolhistory.FieldRelation] = struct{}{}
}

// RelationCleared returns if the "relation" field was cleared in this mutation.
func (m *MappedControlHistoryMutation) RelationCleared() bool {
	_, ok := m.clearedFields[mappedcontrolhistory.FieldRelation]
	return ok
}

// ResetRelation resets all changes to the "relation" field.
func (m *MappedControlHistoryMutation) ResetRelation() {
	m.relation = nil
	delete(m.clearedFields, mappedcontrolhistory.FieldRelation)
}

// SetConfidence sets the "confidence" field.
func (m *MappedControlHistoryMutation) SetConfidence(i int) {
	m.confidence = &i
	m.addconfidence = nil
}

// Confidence returns the value of the "confidence" field in the mutation.
func (m *MappedControlHistoryMutation) Confidence() (r int, exists bool) {
	v := m.confidence
	if v == nil {
		return
	}
	return *v, true
}

// OldConfidence returns the old "confidence" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldConfidence(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfidence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfidence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfidence: %w", err)
	}
	return oldValue.Confidence, nil
}

// AddConfidence adds i to the "confidence" field.
func (m *MappedControlHistoryMutation) AddConfidence(i int) {
	if m.addconfidence != nil {
		*m.addconfidence += i
	} else {
		m.addconfidence = &i
	}
}

// AddedConfidence returns the value that was added to the "confidence" field in this mutation.
func (m *MappedControlHistoryMutation) AddedConfidence() (r int, exists bool) {
	v := m.addconfidence
	if v == nil {
		return
	}
	return *v, true
}

// ClearConfidence clears the value of the "confidence" field.
func (m *MappedControlHistoryMutation) ClearConfidence() {
	m.confidence = nil
	m.addconfidence = nil
	m.clearedFields[mappedcontrolhistory.FieldConfidence] = struct{}{}
}

// ConfidenceCleared returns if the "confidence" field was cleared in this mutation.
func (m *MappedControlHistoryMutation) ConfidenceCleared() bool {
	_, ok := m.clearedFields[mappedcontrolhistory.FieldConfidence]
	return ok
}

// ResetConfidence resets all changes to the "confidence" field.
func (m *MappedControlHistoryMutation) ResetConfidence() {
	m.confidence = nil
	m.addconfidence = nil
	delete(m.clearedFields, mappedcontrolhistory.FieldConfidence)
}

// SetSource sets the "source" field.
func (m *MappedControlHistoryMutation) SetSource(es enums.MappingSource) {
	m.source = &es
}

// Source returns the value of the "source" field in the mutation.
func (m *MappedControlHistoryMutation) Source() (r enums.MappingSource, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the MappedControlHistory entity.
// If the MappedControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MappedControlHistoryMutation) OldSource(ctx context.Context) (v enums.MappingSource, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *MappedControlHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[mappedcontrolhistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *MappedControlHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[mappedcontrolhistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *MappedControlHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, mappedcontrolhistory.FieldSource)
}

// Where appends a list predicates to the MappedControlHistoryMutation builder.
func (m *MappedControlHistoryMutation) Where(ps ...predicate.MappedControlHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MappedControlHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MappedControlHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MappedControlHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MappedControlHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MappedControlHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MappedControlHistory).
func (m *MappedControlHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MappedControlHistoryMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.history_time != nil {
		fields = append(fields, mappedcontrolhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, mappedcontrolhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, mappedcontrolhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, mappedcontrolhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mappedcontrolhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, mappedcontrolhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, mappedcontrolhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, mappedcontrolhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, mappedcontrolhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, mappedcontrolhistory.FieldTags)
	}
	if m.system_owned != nil {
		fields = append(fields, mappedcontrolhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, mappedcontrolhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, mappedcontrolhistory.FieldSystemInternalID)
	}
	if m.owner_id != nil {
		fields = append(fields, mappedcontrolhistory.FieldOwnerID)
	}
	if m.mapping_type != nil {
		fields = append(fields, mappedcontrolhistory.FieldMappingType)
	}
	if m.relation != nil {
		fields = append(fields, mappedcontrolhistory.FieldRelation)
	}
	if m.confidence != nil {
		fields = append(fields, mappedcontrolhistory.FieldConfidence)
	}
	if m.source != nil {
		fields = append(fields, mappedcontrolhistory.FieldSource)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MappedControlHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mappedcontrolhistory.FieldHistoryTime:
		return m.HistoryTime()
	case mappedcontrolhistory.FieldRef:
		return m.Ref()
	case mappedcontrolhistory.FieldOperation:
		return m.Operation()
	case mappedcontrolhistory.FieldCreatedAt:
		return m.CreatedAt()
	case mappedcontrolhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case mappedcontrolhistory.FieldCreatedBy:
		return m.CreatedBy()
	case mappedcontrolhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case mappedcontrolhistory.FieldDeletedAt:
		return m.DeletedAt()
	case mappedcontrolhistory.FieldDeletedBy:
		return m.DeletedBy()
	case mappedcontrolhistory.FieldTags:
		return m.Tags()
	case mappedcontrolhistory.FieldSystemOwned:
		return m.SystemOwned()
	case mappedcontrolhistory.FieldInternalNotes:
		return m.InternalNotes()
	case mappedcontrolhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case mappedcontrolhistory.FieldOwnerID:
		return m.OwnerID()
	case mappedcontrolhistory.FieldMappingType:
		return m.MappingType()
	case mappedcontrolhistory.FieldRelation:
		return m.Relation()
	case mappedcontrolhistory.FieldConfidence:
		return m.Confidence()
	case mappedcontrolhistory.FieldSource:
		return m.Source()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MappedControlHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mappedcontrolhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case mappedcontrolhistory.FieldRef:
		return m.OldRef(ctx)
	case mappedcontrolhistory.FieldOperation:
		return m.OldOperation(ctx)
	case mappedcontrolhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mappedcontrolhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mappedcontrolhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case mappedcontrolhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case mappedcontrolhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case mappedcontrolhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case mappedcontrolhistory.FieldTags:
		return m.OldTags(ctx)
	case mappedcontrolhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case mappedcontrolhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case mappedcontrolhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case mappedcontrolhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case mappedcontrolhistory.FieldMappingType:
		return m.OldMappingType(ctx)
	case mappedcontrolhistory.FieldRelation:
		return m.OldRelation(ctx)
	case mappedcontrolhistory.FieldConfidence:
		return m.OldConfidence(ctx)
	case mappedcontrolhistory.FieldSource:
		return m.OldSource(ctx)
	}
	return nil, fmt.Errorf("unknown MappedControlHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MappedControlHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mappedcontrolhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case mappedcontrolhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case mappedcontrolhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case mappedcontrolhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mappedcontrolhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mappedcontrolhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case mappedcontrolhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case mappedcontrolhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case mappedcontrolhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case mappedcontrolhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case mappedcontrolhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case mappedcontrolhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case mappedcontrolhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case mappedcontrolhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case mappedcontrolhistory.FieldMappingType:
		v, ok := value.(enums.MappingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingType(v)
		return nil
	case mappedcontrolhistory.FieldRelation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelation(v)
		return nil
	case mappedcontrolhistory.FieldConfidence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfidence(v)
		return nil
	case mappedcontrolhistory.FieldSource:
		v, ok := value.(enums.MappingSource)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	}
	return fmt.Errorf("unknown MappedControlHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MappedControlHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addconfidence != nil {
		fields = append(fields, mappedcontrolhistory.FieldConfidence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MappedControlHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mappedcontrolhistory.FieldConfidence:
		return m.AddedConfidence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MappedControlHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mappedcontrolhistory.FieldConfidence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfidence(v)
		return nil
	}
	return fmt.Errorf("unknown MappedControlHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MappedControlHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mappedcontrolhistory.FieldRef) {
		fields = append(fields, mappedcontrolhistory.FieldRef)
	}
	if m.FieldCleared(mappedcontrolhistory.FieldCreatedAt) {
		fields = append(fields, mappedcontrolhistory.FieldCreatedAt)
	}
	if m.FieldCleared(mappedcontrolhistory.FieldUpdatedAt) {
		fields = append(fields, mappedcontrolhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(mappedcontrolhistory.FieldCreatedBy) {
		fields = append(fields, mappedcontrolhistory.FieldCreatedBy)
	}
	if m.FieldCleared(mappedcontrolhistory.FieldUpdatedBy) {
		fields = append(fields, mappedcontrolhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(mappedcontrolhistory.FieldDeletedAt) {
		fields = append(fields, mappedcontrolhistory.FieldDeletedAt)
	}
	if m.FieldCleared(mappedcontrolhistory.FieldDeletedBy) {
		fields = append(fields, mappedcontrolhistory.FieldDeletedBy)
	}
	if m.FieldCleared(mappedcontrolhistory.FieldTags) {
		fields = append(fields, mappedcontrolhistory.FieldTags)
	}
	if m.FieldCleared(mappedcontrolhistory.FieldSystemOwned) {
		fields = append(fields, mappedcontrolhistory.FieldSystemOwned)
	}
	if m.FieldCleared(mappedcontrolhistory.FieldInternalNotes) {
		fields = append(fields, mappedcontrolhistory.FieldInternalNotes)
	}
	if m.FieldCleared(mappedcontrolhistory.FieldSystemInternalID) {
		fields = append(fields, mappedcontrolhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(mappedcontrolhistory.FieldOwnerID) {
		fields = append(fields, mappedcontrolhistory.FieldOwnerID)
	}
	if m.FieldCleared(mappedcontrolhistory.FieldRelation) {
		fields = append(fields, mappedcontrolhistory.FieldRelation)
	}
	if m.FieldCleared(mappedcontrolhistory.FieldConfidence) {
		fields = append(fields, mappedcontrolhistory.FieldConfidence)
	}
	if m.FieldCleared(mappedcontrolhistory.FieldSource) {
		fields = append(fields, mappedcontrolhistory.FieldSource)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MappedControlHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MappedControlHistoryMutation) ClearField(name string) error {
	switch name {
	case mappedcontrolhistory.FieldRef:
		m.ClearRef()
		return nil
	case mappedcontrolhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case mappedcontrolhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case mappedcontrolhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case mappedcontrolhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case mappedcontrolhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case mappedcontrolhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case mappedcontrolhistory.FieldTags:
		m.ClearTags()
		return nil
	case mappedcontrolhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case mappedcontrolhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case mappedcontrolhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case mappedcontrolhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case mappedcontrolhistory.FieldRelation:
		m.ClearRelation()
		return nil
	case mappedcontrolhistory.FieldConfidence:
		m.ClearConfidence()
		return nil
	case mappedcontrolhistory.FieldSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown MappedControlHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MappedControlHistoryMutation) ResetField(name string) error {
	switch name {
	case mappedcontrolhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case mappedcontrolhistory.FieldRef:
		m.ResetRef()
		return nil
	case mappedcontrolhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case mappedcontrolhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mappedcontrolhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mappedcontrolhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case mappedcontrolhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case mappedcontrolhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case mappedcontrolhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case mappedcontrolhistory.FieldTags:
		m.ResetTags()
		return nil
	case mappedcontrolhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case mappedcontrolhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case mappedcontrolhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case mappedcontrolhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case mappedcontrolhistory.FieldMappingType:
		m.ResetMappingType()
		return nil
	case mappedcontrolhistory.FieldRelation:
		m.ResetRelation()
		return nil
	case mappedcontrolhistory.FieldConfidence:
		m.ResetConfidence()
		return nil
	case mappedcontrolhistory.FieldSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown MappedControlHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MappedControlHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MappedControlHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MappedControlHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MappedControlHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MappedControlHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MappedControlHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MappedControlHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MappedControlHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MappedControlHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MappedControlHistory edge %s", name)
}

// NarrativeHistoryMutation represents an operation that mutates the NarrativeHistory nodes in the graph.
type NarrativeHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	history_time       *time.Time
	ref                *string
	operation          *history.OpType
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	deleted_at         *time.Time
	deleted_by         *string
	display_id         *string
	tags               *[]string
	appendtags         []string
	owner_id           *string
	system_owned       *bool
	internal_notes     *string
	system_internal_id *string
	name               *string
	description        *string
	details            *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*NarrativeHistory, error)
	predicates         []predicate.NarrativeHistory
}

var _ ent.Mutation = (*NarrativeHistoryMutation)(nil)

// narrativehistoryOption allows management of the mutation configuration using functional options.
type narrativehistoryOption func(*NarrativeHistoryMutation)

// newNarrativeHistoryMutation creates new mutation for the NarrativeHistory entity.
func newNarrativeHistoryMutation(c config, op Op, opts ...narrativehistoryOption) *NarrativeHistoryMutation {
	m := &NarrativeHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeNarrativeHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNarrativeHistoryID sets the ID field of the mutation.
func withNarrativeHistoryID(id string) narrativehistoryOption {
	return func(m *NarrativeHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *NarrativeHistory
		)
		m.oldValue = func(ctx context.Context) (*NarrativeHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NarrativeHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNarrativeHistory sets the old NarrativeHistory of the mutation.
func withNarrativeHistory(node *NarrativeHistory) narrativehistoryOption {
	return func(m *NarrativeHistoryMutation) {
		m.oldValue = func(context.Context) (*NarrativeHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NarrativeHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NarrativeHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NarrativeHistory entities.
func (m *NarrativeHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NarrativeHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NarrativeHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NarrativeHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *NarrativeHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *NarrativeHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *NarrativeHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *NarrativeHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *NarrativeHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *NarrativeHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[narrativehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *NarrativeHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, narrativehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *NarrativeHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *NarrativeHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *NarrativeHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NarrativeHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NarrativeHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *NarrativeHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[narrativehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NarrativeHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, narrativehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NarrativeHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NarrativeHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *NarrativeHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[narrativehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NarrativeHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, narrativehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *NarrativeHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *NarrativeHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *NarrativeHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[narrativehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *NarrativeHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, narrativehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *NarrativeHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *NarrativeHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *NarrativeHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[narrativehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *NarrativeHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, narrativehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NarrativeHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NarrativeHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NarrativeHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[narrativehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NarrativeHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, narrativehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *NarrativeHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *NarrativeHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *NarrativeHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[narrativehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *NarrativeHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, narrativehistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *NarrativeHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *NarrativeHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *NarrativeHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *NarrativeHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *NarrativeHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *NarrativeHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *NarrativeHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *NarrativeHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[narrativehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *NarrativeHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, narrativehistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *NarrativeHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *NarrativeHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *NarrativeHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[narrativehistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *NarrativeHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, narrativehistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *NarrativeHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *NarrativeHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *NarrativeHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[narrativehistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *NarrativeHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, narrativehistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *NarrativeHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *NarrativeHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *NarrativeHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[narrativehistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *NarrativeHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, narrativehistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *NarrativeHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *NarrativeHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *NarrativeHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[narrativehistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *NarrativeHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, narrativehistory.FieldSystemInternalID)
}

// SetName sets the "name" field.
func (m *NarrativeHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NarrativeHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NarrativeHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NarrativeHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NarrativeHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NarrativeHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[narrativehistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NarrativeHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, narrativehistory.FieldDescription)
}

// SetDetails sets the "details" field.
func (m *NarrativeHistoryMutation) SetDetails(s string) {
	m.details = &s
}

// Details returns the value of the "details" field in the mutation.
func (m *NarrativeHistoryMutation) Details() (r string, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *NarrativeHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[narrativehistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *NarrativeHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, narrativehistory.FieldDetails)
}

// Where appends a list predicates to the NarrativeHistoryMutation builder.
func (m *NarrativeHistoryMutation) Where(ps ...predicate.NarrativeHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NarrativeHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NarrativeHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NarrativeHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NarrativeHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NarrativeHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NarrativeHistory).
func (m *NarrativeHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NarrativeHistoryMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.history_time != nil {
		fields = append(fields, narrativehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, narrativehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, narrativehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, narrativehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, narrativehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, narrativehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, narrativehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, narrativehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, narrativehistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, narrativehistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, narrativehistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, narrativehistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, narrativehistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, narrativehistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, narrativehistory.FieldSystemInternalID)
	}
	if m.name != nil {
		fields = append(fields, narrativehistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, narrativehistory.FieldDescription)
	}
	if m.details != nil {
		fields = append(fields, narrativehistory.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NarrativeHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case narrativehistory.FieldHistoryTime:
		return m.HistoryTime()
	case narrativehistory.FieldRef:
		return m.Ref()
	case narrativehistory.FieldOperation:
		return m.Operation()
	case narrativehistory.FieldCreatedAt:
		return m.CreatedAt()
	case narrativehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case narrativehistory.FieldCreatedBy:
		return m.CreatedBy()
	case narrativehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case narrativehistory.FieldDeletedAt:
		return m.DeletedAt()
	case narrativehistory.FieldDeletedBy:
		return m.DeletedBy()
	case narrativehistory.FieldDisplayID:
		return m.DisplayID()
	case narrativehistory.FieldTags:
		return m.Tags()
	case narrativehistory.FieldOwnerID:
		return m.OwnerID()
	case narrativehistory.FieldSystemOwned:
		return m.SystemOwned()
	case narrativehistory.FieldInternalNotes:
		return m.InternalNotes()
	case narrativehistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case narrativehistory.FieldName:
		return m.Name()
	case narrativehistory.FieldDescription:
		return m.Description()
	case narrativehistory.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NarrativeHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case narrativehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case narrativehistory.FieldRef:
		return m.OldRef(ctx)
	case narrativehistory.FieldOperation:
		return m.OldOperation(ctx)
	case narrativehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case narrativehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case narrativehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case narrativehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case narrativehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case narrativehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case narrativehistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case narrativehistory.FieldTags:
		return m.OldTags(ctx)
	case narrativehistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case narrativehistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case narrativehistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case narrativehistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case narrativehistory.FieldName:
		return m.OldName(ctx)
	case narrativehistory.FieldDescription:
		return m.OldDescription(ctx)
	case narrativehistory.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown NarrativeHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NarrativeHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case narrativehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case narrativehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case narrativehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case narrativehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case narrativehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case narrativehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case narrativehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case narrativehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case narrativehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case narrativehistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case narrativehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case narrativehistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case narrativehistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case narrativehistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case narrativehistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case narrativehistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case narrativehistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case narrativehistory.FieldDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown NarrativeHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NarrativeHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NarrativeHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NarrativeHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NarrativeHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NarrativeHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(narrativehistory.FieldRef) {
		fields = append(fields, narrativehistory.FieldRef)
	}
	if m.FieldCleared(narrativehistory.FieldCreatedAt) {
		fields = append(fields, narrativehistory.FieldCreatedAt)
	}
	if m.FieldCleared(narrativehistory.FieldUpdatedAt) {
		fields = append(fields, narrativehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(narrativehistory.FieldCreatedBy) {
		fields = append(fields, narrativehistory.FieldCreatedBy)
	}
	if m.FieldCleared(narrativehistory.FieldUpdatedBy) {
		fields = append(fields, narrativehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(narrativehistory.FieldDeletedAt) {
		fields = append(fields, narrativehistory.FieldDeletedAt)
	}
	if m.FieldCleared(narrativehistory.FieldDeletedBy) {
		fields = append(fields, narrativehistory.FieldDeletedBy)
	}
	if m.FieldCleared(narrativehistory.FieldTags) {
		fields = append(fields, narrativehistory.FieldTags)
	}
	if m.FieldCleared(narrativehistory.FieldOwnerID) {
		fields = append(fields, narrativehistory.FieldOwnerID)
	}
	if m.FieldCleared(narrativehistory.FieldSystemOwned) {
		fields = append(fields, narrativehistory.FieldSystemOwned)
	}
	if m.FieldCleared(narrativehistory.FieldInternalNotes) {
		fields = append(fields, narrativehistory.FieldInternalNotes)
	}
	if m.FieldCleared(narrativehistory.FieldSystemInternalID) {
		fields = append(fields, narrativehistory.FieldSystemInternalID)
	}
	if m.FieldCleared(narrativehistory.FieldDescription) {
		fields = append(fields, narrativehistory.FieldDescription)
	}
	if m.FieldCleared(narrativehistory.FieldDetails) {
		fields = append(fields, narrativehistory.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NarrativeHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NarrativeHistoryMutation) ClearField(name string) error {
	switch name {
	case narrativehistory.FieldRef:
		m.ClearRef()
		return nil
	case narrativehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case narrativehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case narrativehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case narrativehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case narrativehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case narrativehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case narrativehistory.FieldTags:
		m.ClearTags()
		return nil
	case narrativehistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case narrativehistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case narrativehistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case narrativehistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case narrativehistory.FieldDescription:
		m.ClearDescription()
		return nil
	case narrativehistory.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown NarrativeHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NarrativeHistoryMutation) ResetField(name string) error {
	switch name {
	case narrativehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case narrativehistory.FieldRef:
		m.ResetRef()
		return nil
	case narrativehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case narrativehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case narrativehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case narrativehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case narrativehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case narrativehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case narrativehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case narrativehistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case narrativehistory.FieldTags:
		m.ResetTags()
		return nil
	case narrativehistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case narrativehistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case narrativehistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case narrativehistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case narrativehistory.FieldName:
		m.ResetName()
		return nil
	case narrativehistory.FieldDescription:
		m.ResetDescription()
		return nil
	case narrativehistory.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown NarrativeHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NarrativeHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NarrativeHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NarrativeHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NarrativeHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NarrativeHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NarrativeHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NarrativeHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NarrativeHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NarrativeHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NarrativeHistory edge %s", name)
}

// NoteHistoryMutation represents an operation that mutates the NoteHistory nodes in the graph.
type NoteHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	deleted_at    *time.Time
	deleted_by    *string
	display_id    *string
	owner_id      *string
	text          *string
	note_ref      *string
	discussion_id *string
	is_edited     *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*NoteHistory, error)
	predicates    []predicate.NoteHistory
}

var _ ent.Mutation = (*NoteHistoryMutation)(nil)

// notehistoryOption allows management of the mutation configuration using functional options.
type notehistoryOption func(*NoteHistoryMutation)

// newNoteHistoryMutation creates new mutation for the NoteHistory entity.
func newNoteHistoryMutation(c config, op Op, opts ...notehistoryOption) *NoteHistoryMutation {
	m := &NoteHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeNoteHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNoteHistoryID sets the ID field of the mutation.
func withNoteHistoryID(id string) notehistoryOption {
	return func(m *NoteHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *NoteHistory
		)
		m.oldValue = func(ctx context.Context) (*NoteHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NoteHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNoteHistory sets the old NoteHistory of the mutation.
func withNoteHistory(node *NoteHistory) notehistoryOption {
	return func(m *NoteHistoryMutation) {
		m.oldValue = func(context.Context) (*NoteHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NoteHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NoteHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NoteHistory entities.
func (m *NoteHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NoteHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NoteHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NoteHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *NoteHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *NoteHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *NoteHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *NoteHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *NoteHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *NoteHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[notehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *NoteHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *NoteHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, notehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *NoteHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *NoteHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *NoteHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NoteHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NoteHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *NoteHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[notehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *NoteHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NoteHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, notehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NoteHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NoteHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *NoteHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[notehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *NoteHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NoteHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, notehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *NoteHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *NoteHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *NoteHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[notehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *NoteHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *NoteHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, notehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *NoteHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *NoteHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *NoteHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[notehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *NoteHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *NoteHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, notehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NoteHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NoteHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NoteHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NoteHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NoteHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *NoteHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *NoteHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *NoteHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[notehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *NoteHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *NoteHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, notehistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *NoteHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *NoteHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *NoteHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *NoteHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *NoteHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *NoteHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[notehistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *NoteHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *NoteHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, notehistory.FieldOwnerID)
}

// SetText sets the "text" field.
func (m *NoteHistoryMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *NoteHistoryMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *NoteHistoryMutation) ResetText() {
	m.text = nil
}

// SetNoteRef sets the "note_ref" field.
func (m *NoteHistoryMutation) SetNoteRef(s string) {
	m.note_ref = &s
}

// NoteRef returns the value of the "note_ref" field in the mutation.
func (m *NoteHistoryMutation) NoteRef() (r string, exists bool) {
	v := m.note_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldNoteRef returns the old "note_ref" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldNoteRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoteRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoteRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoteRef: %w", err)
	}
	return oldValue.NoteRef, nil
}

// ClearNoteRef clears the value of the "note_ref" field.
func (m *NoteHistoryMutation) ClearNoteRef() {
	m.note_ref = nil
	m.clearedFields[notehistory.FieldNoteRef] = struct{}{}
}

// NoteRefCleared returns if the "note_ref" field was cleared in this mutation.
func (m *NoteHistoryMutation) NoteRefCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldNoteRef]
	return ok
}

// ResetNoteRef resets all changes to the "note_ref" field.
func (m *NoteHistoryMutation) ResetNoteRef() {
	m.note_ref = nil
	delete(m.clearedFields, notehistory.FieldNoteRef)
}

// SetDiscussionID sets the "discussion_id" field.
func (m *NoteHistoryMutation) SetDiscussionID(s string) {
	m.discussion_id = &s
}

// DiscussionID returns the value of the "discussion_id" field in the mutation.
func (m *NoteHistoryMutation) DiscussionID() (r string, exists bool) {
	v := m.discussion_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscussionID returns the old "discussion_id" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldDiscussionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscussionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscussionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscussionID: %w", err)
	}
	return oldValue.DiscussionID, nil
}

// ClearDiscussionID clears the value of the "discussion_id" field.
func (m *NoteHistoryMutation) ClearDiscussionID() {
	m.discussion_id = nil
	m.clearedFields[notehistory.FieldDiscussionID] = struct{}{}
}

// DiscussionIDCleared returns if the "discussion_id" field was cleared in this mutation.
func (m *NoteHistoryMutation) DiscussionIDCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldDiscussionID]
	return ok
}

// ResetDiscussionID resets all changes to the "discussion_id" field.
func (m *NoteHistoryMutation) ResetDiscussionID() {
	m.discussion_id = nil
	delete(m.clearedFields, notehistory.FieldDiscussionID)
}

// SetIsEdited sets the "is_edited" field.
func (m *NoteHistoryMutation) SetIsEdited(b bool) {
	m.is_edited = &b
}

// IsEdited returns the value of the "is_edited" field in the mutation.
func (m *NoteHistoryMutation) IsEdited() (r bool, exists bool) {
	v := m.is_edited
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEdited returns the old "is_edited" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldIsEdited(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEdited is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEdited requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEdited: %w", err)
	}
	return oldValue.IsEdited, nil
}

// ResetIsEdited resets all changes to the "is_edited" field.
func (m *NoteHistoryMutation) ResetIsEdited() {
	m.is_edited = nil
}

// Where appends a list predicates to the NoteHistoryMutation builder.
func (m *NoteHistoryMutation) Where(ps ...predicate.NoteHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NoteHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NoteHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NoteHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NoteHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NoteHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NoteHistory).
func (m *NoteHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NoteHistoryMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.history_time != nil {
		fields = append(fields, notehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, notehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, notehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, notehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, notehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, notehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, notehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, notehistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, notehistory.FieldDisplayID)
	}
	if m.owner_id != nil {
		fields = append(fields, notehistory.FieldOwnerID)
	}
	if m.text != nil {
		fields = append(fields, notehistory.FieldText)
	}
	if m.note_ref != nil {
		fields = append(fields, notehistory.FieldNoteRef)
	}
	if m.discussion_id != nil {
		fields = append(fields, notehistory.FieldDiscussionID)
	}
	if m.is_edited != nil {
		fields = append(fields, notehistory.FieldIsEdited)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NoteHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notehistory.FieldHistoryTime:
		return m.HistoryTime()
	case notehistory.FieldRef:
		return m.Ref()
	case notehistory.FieldOperation:
		return m.Operation()
	case notehistory.FieldCreatedAt:
		return m.CreatedAt()
	case notehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case notehistory.FieldCreatedBy:
		return m.CreatedBy()
	case notehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case notehistory.FieldDeletedAt:
		return m.DeletedAt()
	case notehistory.FieldDeletedBy:
		return m.DeletedBy()
	case notehistory.FieldDisplayID:
		return m.DisplayID()
	case notehistory.FieldOwnerID:
		return m.OwnerID()
	case notehistory.FieldText:
		return m.Text()
	case notehistory.FieldNoteRef:
		return m.NoteRef()
	case notehistory.FieldDiscussionID:
		return m.DiscussionID()
	case notehistory.FieldIsEdited:
		return m.IsEdited()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NoteHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case notehistory.FieldRef:
		return m.OldRef(ctx)
	case notehistory.FieldOperation:
		return m.OldOperation(ctx)
	case notehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case notehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case notehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case notehistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case notehistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case notehistory.FieldText:
		return m.OldText(ctx)
	case notehistory.FieldNoteRef:
		return m.OldNoteRef(ctx)
	case notehistory.FieldDiscussionID:
		return m.OldDiscussionID(ctx)
	case notehistory.FieldIsEdited:
		return m.OldIsEdited(ctx)
	}
	return nil, fmt.Errorf("unknown NoteHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NoteHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case notehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case notehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case notehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case notehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case notehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case notehistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case notehistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case notehistory.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case notehistory.FieldNoteRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoteRef(v)
		return nil
	case notehistory.FieldDiscussionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscussionID(v)
		return nil
	case notehistory.FieldIsEdited:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEdited(v)
		return nil
	}
	return fmt.Errorf("unknown NoteHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NoteHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NoteHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NoteHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NoteHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NoteHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notehistory.FieldRef) {
		fields = append(fields, notehistory.FieldRef)
	}
	if m.FieldCleared(notehistory.FieldCreatedAt) {
		fields = append(fields, notehistory.FieldCreatedAt)
	}
	if m.FieldCleared(notehistory.FieldUpdatedAt) {
		fields = append(fields, notehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(notehistory.FieldCreatedBy) {
		fields = append(fields, notehistory.FieldCreatedBy)
	}
	if m.FieldCleared(notehistory.FieldUpdatedBy) {
		fields = append(fields, notehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(notehistory.FieldDeletedAt) {
		fields = append(fields, notehistory.FieldDeletedAt)
	}
	if m.FieldCleared(notehistory.FieldDeletedBy) {
		fields = append(fields, notehistory.FieldDeletedBy)
	}
	if m.FieldCleared(notehistory.FieldOwnerID) {
		fields = append(fields, notehistory.FieldOwnerID)
	}
	if m.FieldCleared(notehistory.FieldNoteRef) {
		fields = append(fields, notehistory.FieldNoteRef)
	}
	if m.FieldCleared(notehistory.FieldDiscussionID) {
		fields = append(fields, notehistory.FieldDiscussionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NoteHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NoteHistoryMutation) ClearField(name string) error {
	switch name {
	case notehistory.FieldRef:
		m.ClearRef()
		return nil
	case notehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case notehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case notehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case notehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case notehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case notehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case notehistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case notehistory.FieldNoteRef:
		m.ClearNoteRef()
		return nil
	case notehistory.FieldDiscussionID:
		m.ClearDiscussionID()
		return nil
	}
	return fmt.Errorf("unknown NoteHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NoteHistoryMutation) ResetField(name string) error {
	switch name {
	case notehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case notehistory.FieldRef:
		m.ResetRef()
		return nil
	case notehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case notehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case notehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case notehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case notehistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case notehistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case notehistory.FieldText:
		m.ResetText()
		return nil
	case notehistory.FieldNoteRef:
		m.ResetNoteRef()
		return nil
	case notehistory.FieldDiscussionID:
		m.ResetDiscussionID()
		return nil
	case notehistory.FieldIsEdited:
		m.ResetIsEdited()
		return nil
	}
	return fmt.Errorf("unknown NoteHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NoteHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NoteHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NoteHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NoteHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NoteHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NoteHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NoteHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NoteHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NoteHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NoteHistory edge %s", name)
}

// OrgMembershipHistoryMutation represents an operation that mutates the OrgMembershipHistory nodes in the graph.
type OrgMembershipHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *string
	history_time    *time.Time
	ref             *string
	operation       *history.OpType
	created_at      *time.Time
	updated_at      *time.Time
	created_by      *string
	updated_by      *string
	role            *enums.Role
	organization_id *string
	user_id         *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*OrgMembershipHistory, error)
	predicates      []predicate.OrgMembershipHistory
}

var _ ent.Mutation = (*OrgMembershipHistoryMutation)(nil)

// orgmembershiphistoryOption allows management of the mutation configuration using functional options.
type orgmembershiphistoryOption func(*OrgMembershipHistoryMutation)

// newOrgMembershipHistoryMutation creates new mutation for the OrgMembershipHistory entity.
func newOrgMembershipHistoryMutation(c config, op Op, opts ...orgmembershiphistoryOption) *OrgMembershipHistoryMutation {
	m := &OrgMembershipHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgMembershipHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgMembershipHistoryID sets the ID field of the mutation.
func withOrgMembershipHistoryID(id string) orgmembershiphistoryOption {
	return func(m *OrgMembershipHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgMembershipHistory
		)
		m.oldValue = func(ctx context.Context) (*OrgMembershipHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgMembershipHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgMembershipHistory sets the old OrgMembershipHistory of the mutation.
func withOrgMembershipHistory(node *OrgMembershipHistory) orgmembershiphistoryOption {
	return func(m *OrgMembershipHistoryMutation) {
		m.oldValue = func(context.Context) (*OrgMembershipHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgMembershipHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgMembershipHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgMembershipHistory entities.
func (m *OrgMembershipHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgMembershipHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgMembershipHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgMembershipHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *OrgMembershipHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *OrgMembershipHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *OrgMembershipHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *OrgMembershipHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *OrgMembershipHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *OrgMembershipHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[orgmembershiphistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *OrgMembershipHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[orgmembershiphistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *OrgMembershipHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, orgmembershiphistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *OrgMembershipHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *OrgMembershipHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *OrgMembershipHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrgMembershipHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrgMembershipHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrgMembershipHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orgmembershiphistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrgMembershipHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orgmembershiphistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrgMembershipHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orgmembershiphistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrgMembershipHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrgMembershipHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrgMembershipHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orgmembershiphistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrgMembershipHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orgmembershiphistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrgMembershipHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orgmembershiphistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *OrgMembershipHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrgMembershipHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrgMembershipHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[orgmembershiphistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrgMembershipHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[orgmembershiphistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrgMembershipHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, orgmembershiphistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrgMembershipHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrgMembershipHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrgMembershipHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[orgmembershiphistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrgMembershipHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[orgmembershiphistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrgMembershipHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, orgmembershiphistory.FieldUpdatedBy)
}

// SetRole sets the "role" field.
func (m *OrgMembershipHistoryMutation) SetRole(e enums.Role) {
	m.role = &e
}

// Role returns the value of the "role" field in the mutation.
func (m *OrgMembershipHistoryMutation) Role() (r enums.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldRole(ctx context.Context) (v enums.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *OrgMembershipHistoryMutation) ResetRole() {
	m.role = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrgMembershipHistoryMutation) SetOrganizationID(s string) {
	m.organization_id = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrgMembershipHistoryMutation) OrganizationID() (r string, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrgMembershipHistoryMutation) ResetOrganizationID() {
	m.organization_id = nil
}

// SetUserID sets the "user_id" field.
func (m *OrgMembershipHistoryMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrgMembershipHistoryMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrgMembershipHistoryMutation) ResetUserID() {
	m.user_id = nil
}

// Where appends a list predicates to the OrgMembershipHistoryMutation builder.
func (m *OrgMembershipHistoryMutation) Where(ps ...predicate.OrgMembershipHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgMembershipHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgMembershipHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgMembershipHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgMembershipHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgMembershipHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgMembershipHistory).
func (m *OrgMembershipHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgMembershipHistoryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.history_time != nil {
		fields = append(fields, orgmembershiphistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, orgmembershiphistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, orgmembershiphistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, orgmembershiphistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orgmembershiphistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, orgmembershiphistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, orgmembershiphistory.FieldUpdatedBy)
	}
	if m.role != nil {
		fields = append(fields, orgmembershiphistory.FieldRole)
	}
	if m.organization_id != nil {
		fields = append(fields, orgmembershiphistory.FieldOrganizationID)
	}
	if m.user_id != nil {
		fields = append(fields, orgmembershiphistory.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgMembershipHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgmembershiphistory.FieldHistoryTime:
		return m.HistoryTime()
	case orgmembershiphistory.FieldRef:
		return m.Ref()
	case orgmembershiphistory.FieldOperation:
		return m.Operation()
	case orgmembershiphistory.FieldCreatedAt:
		return m.CreatedAt()
	case orgmembershiphistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case orgmembershiphistory.FieldCreatedBy:
		return m.CreatedBy()
	case orgmembershiphistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case orgmembershiphistory.FieldRole:
		return m.Role()
	case orgmembershiphistory.FieldOrganizationID:
		return m.OrganizationID()
	case orgmembershiphistory.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgMembershipHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgmembershiphistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case orgmembershiphistory.FieldRef:
		return m.OldRef(ctx)
	case orgmembershiphistory.FieldOperation:
		return m.OldOperation(ctx)
	case orgmembershiphistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orgmembershiphistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orgmembershiphistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case orgmembershiphistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case orgmembershiphistory.FieldRole:
		return m.OldRole(ctx)
	case orgmembershiphistory.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case orgmembershiphistory.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown OrgMembershipHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgMembershipHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgmembershiphistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case orgmembershiphistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case orgmembershiphistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case orgmembershiphistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orgmembershiphistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orgmembershiphistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case orgmembershiphistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case orgmembershiphistory.FieldRole:
		v, ok := value.(enums.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case orgmembershiphistory.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case orgmembershiphistory.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgMembershipHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgMembershipHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgMembershipHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgMembershipHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrgMembershipHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgMembershipHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orgmembershiphistory.FieldRef) {
		fields = append(fields, orgmembershiphistory.FieldRef)
	}
	if m.FieldCleared(orgmembershiphistory.FieldCreatedAt) {
		fields = append(fields, orgmembershiphistory.FieldCreatedAt)
	}
	if m.FieldCleared(orgmembershiphistory.FieldUpdatedAt) {
		fields = append(fields, orgmembershiphistory.FieldUpdatedAt)
	}
	if m.FieldCleared(orgmembershiphistory.FieldCreatedBy) {
		fields = append(fields, orgmembershiphistory.FieldCreatedBy)
	}
	if m.FieldCleared(orgmembershiphistory.FieldUpdatedBy) {
		fields = append(fields, orgmembershiphistory.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgMembershipHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgMembershipHistoryMutation) ClearField(name string) error {
	switch name {
	case orgmembershiphistory.FieldRef:
		m.ClearRef()
		return nil
	case orgmembershiphistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case orgmembershiphistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orgmembershiphistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case orgmembershiphistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown OrgMembershipHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgMembershipHistoryMutation) ResetField(name string) error {
	switch name {
	case orgmembershiphistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case orgmembershiphistory.FieldRef:
		m.ResetRef()
		return nil
	case orgmembershiphistory.FieldOperation:
		m.ResetOperation()
		return nil
	case orgmembershiphistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orgmembershiphistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orgmembershiphistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case orgmembershiphistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case orgmembershiphistory.FieldRole:
		m.ResetRole()
		return nil
	case orgmembershiphistory.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case orgmembershiphistory.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown OrgMembershipHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgMembershipHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgMembershipHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgMembershipHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgMembershipHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgMembershipHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgMembershipHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgMembershipHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrgMembershipHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgMembershipHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrgMembershipHistory edge %s", name)
}

// OrgSubscriptionHistoryMutation represents an operation that mutates the OrgSubscriptionHistory nodes in the graph.
type OrgSubscriptionHistoryMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	history_time               *time.Time
	ref                        *string
	operation                  *history.OpType
	created_at                 *time.Time
	updated_at                 *time.Time
	created_by                 *string
	updated_by                 *string
	deleted_at                 *time.Time
	deleted_by                 *string
	tags                       *[]string
	appendtags                 []string
	owner_id                   *string
	stripe_subscription_id     *string
	stripe_subscription_status *string
	active                     *bool
	expires_at                 *time.Time
	trial_expires_at           *time.Time
	days_until_due             *string
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*OrgSubscriptionHistory, error)
	predicates                 []predicate.OrgSubscriptionHistory
}

var _ ent.Mutation = (*OrgSubscriptionHistoryMutation)(nil)

// orgsubscriptionhistoryOption allows management of the mutation configuration using functional options.
type orgsubscriptionhistoryOption func(*OrgSubscriptionHistoryMutation)

// newOrgSubscriptionHistoryMutation creates new mutation for the OrgSubscriptionHistory entity.
func newOrgSubscriptionHistoryMutation(c config, op Op, opts ...orgsubscriptionhistoryOption) *OrgSubscriptionHistoryMutation {
	m := &OrgSubscriptionHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgSubscriptionHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgSubscriptionHistoryID sets the ID field of the mutation.
func withOrgSubscriptionHistoryID(id string) orgsubscriptionhistoryOption {
	return func(m *OrgSubscriptionHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgSubscriptionHistory
		)
		m.oldValue = func(ctx context.Context) (*OrgSubscriptionHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgSubscriptionHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgSubscriptionHistory sets the old OrgSubscriptionHistory of the mutation.
func withOrgSubscriptionHistory(node *OrgSubscriptionHistory) orgsubscriptionhistoryOption {
	return func(m *OrgSubscriptionHistoryMutation) {
		m.oldValue = func(context.Context) (*OrgSubscriptionHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgSubscriptionHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgSubscriptionHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgSubscriptionHistory entities.
func (m *OrgSubscriptionHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgSubscriptionHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgSubscriptionHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgSubscriptionHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *OrgSubscriptionHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *OrgSubscriptionHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *OrgSubscriptionHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *OrgSubscriptionHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[orgsubscriptionhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[orgsubscriptionhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *OrgSubscriptionHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, orgsubscriptionhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *OrgSubscriptionHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *OrgSubscriptionHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrgSubscriptionHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrgSubscriptionHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orgsubscriptionhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orgsubscriptionhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrgSubscriptionHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orgsubscriptionhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrgSubscriptionHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrgSubscriptionHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orgsubscriptionhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orgsubscriptionhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrgSubscriptionHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orgsubscriptionhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *OrgSubscriptionHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrgSubscriptionHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[orgsubscriptionhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[orgsubscriptionhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrgSubscriptionHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, orgsubscriptionhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrgSubscriptionHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrgSubscriptionHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[orgsubscriptionhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[orgsubscriptionhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrgSubscriptionHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, orgsubscriptionhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrgSubscriptionHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrgSubscriptionHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[orgsubscriptionhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[orgsubscriptionhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrgSubscriptionHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, orgsubscriptionhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *OrgSubscriptionHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *OrgSubscriptionHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[orgsubscriptionhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[orgsubscriptionhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *OrgSubscriptionHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, orgsubscriptionhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *OrgSubscriptionHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *OrgSubscriptionHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *OrgSubscriptionHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *OrgSubscriptionHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[orgsubscriptionhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[orgsubscriptionhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *OrgSubscriptionHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, orgsubscriptionhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *OrgSubscriptionHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *OrgSubscriptionHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[orgsubscriptionhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[orgsubscriptionhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *OrgSubscriptionHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, orgsubscriptionhistory.FieldOwnerID)
}

// SetStripeSubscriptionID sets the "stripe_subscription_id" field.
func (m *OrgSubscriptionHistoryMutation) SetStripeSubscriptionID(s string) {
	m.stripe_subscription_id = &s
}

// StripeSubscriptionID returns the value of the "stripe_subscription_id" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) StripeSubscriptionID() (r string, exists bool) {
	v := m.stripe_subscription_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeSubscriptionID returns the old "stripe_subscription_id" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldStripeSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeSubscriptionID: %w", err)
	}
	return oldValue.StripeSubscriptionID, nil
}

// ClearStripeSubscriptionID clears the value of the "stripe_subscription_id" field.
func (m *OrgSubscriptionHistoryMutation) ClearStripeSubscriptionID() {
	m.stripe_subscription_id = nil
	m.clearedFields[orgsubscriptionhistory.FieldStripeSubscriptionID] = struct{}{}
}

// StripeSubscriptionIDCleared returns if the "stripe_subscription_id" field was cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) StripeSubscriptionIDCleared() bool {
	_, ok := m.clearedFields[orgsubscriptionhistory.FieldStripeSubscriptionID]
	return ok
}

// ResetStripeSubscriptionID resets all changes to the "stripe_subscription_id" field.
func (m *OrgSubscriptionHistoryMutation) ResetStripeSubscriptionID() {
	m.stripe_subscription_id = nil
	delete(m.clearedFields, orgsubscriptionhistory.FieldStripeSubscriptionID)
}

// SetStripeSubscriptionStatus sets the "stripe_subscription_status" field.
func (m *OrgSubscriptionHistoryMutation) SetStripeSubscriptionStatus(s string) {
	m.stripe_subscription_status = &s
}

// StripeSubscriptionStatus returns the value of the "stripe_subscription_status" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) StripeSubscriptionStatus() (r string, exists bool) {
	v := m.stripe_subscription_status
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeSubscriptionStatus returns the old "stripe_subscription_status" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldStripeSubscriptionStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeSubscriptionStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeSubscriptionStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeSubscriptionStatus: %w", err)
	}
	return oldValue.StripeSubscriptionStatus, nil
}

// ClearStripeSubscriptionStatus clears the value of the "stripe_subscription_status" field.
func (m *OrgSubscriptionHistoryMutation) ClearStripeSubscriptionStatus() {
	m.stripe_subscription_status = nil
	m.clearedFields[orgsubscriptionhistory.FieldStripeSubscriptionStatus] = struct{}{}
}

// StripeSubscriptionStatusCleared returns if the "stripe_subscription_status" field was cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) StripeSubscriptionStatusCleared() bool {
	_, ok := m.clearedFields[orgsubscriptionhistory.FieldStripeSubscriptionStatus]
	return ok
}

// ResetStripeSubscriptionStatus resets all changes to the "stripe_subscription_status" field.
func (m *OrgSubscriptionHistoryMutation) ResetStripeSubscriptionStatus() {
	m.stripe_subscription_status = nil
	delete(m.clearedFields, orgsubscriptionhistory.FieldStripeSubscriptionStatus)
}

// SetActive sets the "active" field.
func (m *OrgSubscriptionHistoryMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *OrgSubscriptionHistoryMutation) ResetActive() {
	m.active = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *OrgSubscriptionHistoryMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *OrgSubscriptionHistoryMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[orgsubscriptionhistory.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[orgsubscriptionhistory.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *OrgSubscriptionHistoryMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, orgsubscriptionhistory.FieldExpiresAt)
}

// SetTrialExpiresAt sets the "trial_expires_at" field.
func (m *OrgSubscriptionHistoryMutation) SetTrialExpiresAt(t time.Time) {
	m.trial_expires_at = &t
}

// TrialExpiresAt returns the value of the "trial_expires_at" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) TrialExpiresAt() (r time.Time, exists bool) {
	v := m.trial_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTrialExpiresAt returns the old "trial_expires_at" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldTrialExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrialExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrialExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrialExpiresAt: %w", err)
	}
	return oldValue.TrialExpiresAt, nil
}

// ClearTrialExpiresAt clears the value of the "trial_expires_at" field.
func (m *OrgSubscriptionHistoryMutation) ClearTrialExpiresAt() {
	m.trial_expires_at = nil
	m.clearedFields[orgsubscriptionhistory.FieldTrialExpiresAt] = struct{}{}
}

// TrialExpiresAtCleared returns if the "trial_expires_at" field was cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) TrialExpiresAtCleared() bool {
	_, ok := m.clearedFields[orgsubscriptionhistory.FieldTrialExpiresAt]
	return ok
}

// ResetTrialExpiresAt resets all changes to the "trial_expires_at" field.
func (m *OrgSubscriptionHistoryMutation) ResetTrialExpiresAt() {
	m.trial_expires_at = nil
	delete(m.clearedFields, orgsubscriptionhistory.FieldTrialExpiresAt)
}

// SetDaysUntilDue sets the "days_until_due" field.
func (m *OrgSubscriptionHistoryMutation) SetDaysUntilDue(s string) {
	m.days_until_due = &s
}

// DaysUntilDue returns the value of the "days_until_due" field in the mutation.
func (m *OrgSubscriptionHistoryMutation) DaysUntilDue() (r string, exists bool) {
	v := m.days_until_due
	if v == nil {
		return
	}
	return *v, true
}

// OldDaysUntilDue returns the old "days_until_due" field's value of the OrgSubscriptionHistory entity.
// If the OrgSubscriptionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgSubscriptionHistoryMutation) OldDaysUntilDue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDaysUntilDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDaysUntilDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDaysUntilDue: %w", err)
	}
	return oldValue.DaysUntilDue, nil
}

// ClearDaysUntilDue clears the value of the "days_until_due" field.
func (m *OrgSubscriptionHistoryMutation) ClearDaysUntilDue() {
	m.days_until_due = nil
	m.clearedFields[orgsubscriptionhistory.FieldDaysUntilDue] = struct{}{}
}

// DaysUntilDueCleared returns if the "days_until_due" field was cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) DaysUntilDueCleared() bool {
	_, ok := m.clearedFields[orgsubscriptionhistory.FieldDaysUntilDue]
	return ok
}

// ResetDaysUntilDue resets all changes to the "days_until_due" field.
func (m *OrgSubscriptionHistoryMutation) ResetDaysUntilDue() {
	m.days_until_due = nil
	delete(m.clearedFields, orgsubscriptionhistory.FieldDaysUntilDue)
}

// Where appends a list predicates to the OrgSubscriptionHistoryMutation builder.
func (m *OrgSubscriptionHistoryMutation) Where(ps ...predicate.OrgSubscriptionHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgSubscriptionHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgSubscriptionHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgSubscriptionHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgSubscriptionHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgSubscriptionHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgSubscriptionHistory).
func (m *OrgSubscriptionHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgSubscriptionHistoryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.history_time != nil {
		fields = append(fields, orgsubscriptionhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, orgsubscriptionhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, orgsubscriptionhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, orgsubscriptionhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orgsubscriptionhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, orgsubscriptionhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, orgsubscriptionhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, orgsubscriptionhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, orgsubscriptionhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, orgsubscriptionhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, orgsubscriptionhistory.FieldOwnerID)
	}
	if m.stripe_subscription_id != nil {
		fields = append(fields, orgsubscriptionhistory.FieldStripeSubscriptionID)
	}
	if m.stripe_subscription_status != nil {
		fields = append(fields, orgsubscriptionhistory.FieldStripeSubscriptionStatus)
	}
	if m.active != nil {
		fields = append(fields, orgsubscriptionhistory.FieldActive)
	}
	if m.expires_at != nil {
		fields = append(fields, orgsubscriptionhistory.FieldExpiresAt)
	}
	if m.trial_expires_at != nil {
		fields = append(fields, orgsubscriptionhistory.FieldTrialExpiresAt)
	}
	if m.days_until_due != nil {
		fields = append(fields, orgsubscriptionhistory.FieldDaysUntilDue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgSubscriptionHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgsubscriptionhistory.FieldHistoryTime:
		return m.HistoryTime()
	case orgsubscriptionhistory.FieldRef:
		return m.Ref()
	case orgsubscriptionhistory.FieldOperation:
		return m.Operation()
	case orgsubscriptionhistory.FieldCreatedAt:
		return m.CreatedAt()
	case orgsubscriptionhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case orgsubscriptionhistory.FieldCreatedBy:
		return m.CreatedBy()
	case orgsubscriptionhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case orgsubscriptionhistory.FieldDeletedAt:
		return m.DeletedAt()
	case orgsubscriptionhistory.FieldDeletedBy:
		return m.DeletedBy()
	case orgsubscriptionhistory.FieldTags:
		return m.Tags()
	case orgsubscriptionhistory.FieldOwnerID:
		return m.OwnerID()
	case orgsubscriptionhistory.FieldStripeSubscriptionID:
		return m.StripeSubscriptionID()
	case orgsubscriptionhistory.FieldStripeSubscriptionStatus:
		return m.StripeSubscriptionStatus()
	case orgsubscriptionhistory.FieldActive:
		return m.Active()
	case orgsubscriptionhistory.FieldExpiresAt:
		return m.ExpiresAt()
	case orgsubscriptionhistory.FieldTrialExpiresAt:
		return m.TrialExpiresAt()
	case orgsubscriptionhistory.FieldDaysUntilDue:
		return m.DaysUntilDue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgSubscriptionHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgsubscriptionhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case orgsubscriptionhistory.FieldRef:
		return m.OldRef(ctx)
	case orgsubscriptionhistory.FieldOperation:
		return m.OldOperation(ctx)
	case orgsubscriptionhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orgsubscriptionhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orgsubscriptionhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case orgsubscriptionhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case orgsubscriptionhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orgsubscriptionhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case orgsubscriptionhistory.FieldTags:
		return m.OldTags(ctx)
	case orgsubscriptionhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case orgsubscriptionhistory.FieldStripeSubscriptionID:
		return m.OldStripeSubscriptionID(ctx)
	case orgsubscriptionhistory.FieldStripeSubscriptionStatus:
		return m.OldStripeSubscriptionStatus(ctx)
	case orgsubscriptionhistory.FieldActive:
		return m.OldActive(ctx)
	case orgsubscriptionhistory.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case orgsubscriptionhistory.FieldTrialExpiresAt:
		return m.OldTrialExpiresAt(ctx)
	case orgsubscriptionhistory.FieldDaysUntilDue:
		return m.OldDaysUntilDue(ctx)
	}
	return nil, fmt.Errorf("unknown OrgSubscriptionHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgSubscriptionHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgsubscriptionhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case orgsubscriptionhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case orgsubscriptionhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case orgsubscriptionhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orgsubscriptionhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orgsubscriptionhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case orgsubscriptionhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case orgsubscriptionhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orgsubscriptionhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case orgsubscriptionhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case orgsubscriptionhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case orgsubscriptionhistory.FieldStripeSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeSubscriptionID(v)
		return nil
	case orgsubscriptionhistory.FieldStripeSubscriptionStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeSubscriptionStatus(v)
		return nil
	case orgsubscriptionhistory.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case orgsubscriptionhistory.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case orgsubscriptionhistory.FieldTrialExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrialExpiresAt(v)
		return nil
	case orgsubscriptionhistory.FieldDaysUntilDue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDaysUntilDue(v)
		return nil
	}
	return fmt.Errorf("unknown OrgSubscriptionHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgSubscriptionHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgSubscriptionHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgSubscriptionHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrgSubscriptionHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgSubscriptionHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orgsubscriptionhistory.FieldRef) {
		fields = append(fields, orgsubscriptionhistory.FieldRef)
	}
	if m.FieldCleared(orgsubscriptionhistory.FieldCreatedAt) {
		fields = append(fields, orgsubscriptionhistory.FieldCreatedAt)
	}
	if m.FieldCleared(orgsubscriptionhistory.FieldUpdatedAt) {
		fields = append(fields, orgsubscriptionhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(orgsubscriptionhistory.FieldCreatedBy) {
		fields = append(fields, orgsubscriptionhistory.FieldCreatedBy)
	}
	if m.FieldCleared(orgsubscriptionhistory.FieldUpdatedBy) {
		fields = append(fields, orgsubscriptionhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(orgsubscriptionhistory.FieldDeletedAt) {
		fields = append(fields, orgsubscriptionhistory.FieldDeletedAt)
	}
	if m.FieldCleared(orgsubscriptionhistory.FieldDeletedBy) {
		fields = append(fields, orgsubscriptionhistory.FieldDeletedBy)
	}
	if m.FieldCleared(orgsubscriptionhistory.FieldTags) {
		fields = append(fields, orgsubscriptionhistory.FieldTags)
	}
	if m.FieldCleared(orgsubscriptionhistory.FieldOwnerID) {
		fields = append(fields, orgsubscriptionhistory.FieldOwnerID)
	}
	if m.FieldCleared(orgsubscriptionhistory.FieldStripeSubscriptionID) {
		fields = append(fields, orgsubscriptionhistory.FieldStripeSubscriptionID)
	}
	if m.FieldCleared(orgsubscriptionhistory.FieldStripeSubscriptionStatus) {
		fields = append(fields, orgsubscriptionhistory.FieldStripeSubscriptionStatus)
	}
	if m.FieldCleared(orgsubscriptionhistory.FieldExpiresAt) {
		fields = append(fields, orgsubscriptionhistory.FieldExpiresAt)
	}
	if m.FieldCleared(orgsubscriptionhistory.FieldTrialExpiresAt) {
		fields = append(fields, orgsubscriptionhistory.FieldTrialExpiresAt)
	}
	if m.FieldCleared(orgsubscriptionhistory.FieldDaysUntilDue) {
		fields = append(fields, orgsubscriptionhistory.FieldDaysUntilDue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgSubscriptionHistoryMutation) ClearField(name string) error {
	switch name {
	case orgsubscriptionhistory.FieldRef:
		m.ClearRef()
		return nil
	case orgsubscriptionhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case orgsubscriptionhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orgsubscriptionhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case orgsubscriptionhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case orgsubscriptionhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case orgsubscriptionhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case orgsubscriptionhistory.FieldTags:
		m.ClearTags()
		return nil
	case orgsubscriptionhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case orgsubscriptionhistory.FieldStripeSubscriptionID:
		m.ClearStripeSubscriptionID()
		return nil
	case orgsubscriptionhistory.FieldStripeSubscriptionStatus:
		m.ClearStripeSubscriptionStatus()
		return nil
	case orgsubscriptionhistory.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case orgsubscriptionhistory.FieldTrialExpiresAt:
		m.ClearTrialExpiresAt()
		return nil
	case orgsubscriptionhistory.FieldDaysUntilDue:
		m.ClearDaysUntilDue()
		return nil
	}
	return fmt.Errorf("unknown OrgSubscriptionHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgSubscriptionHistoryMutation) ResetField(name string) error {
	switch name {
	case orgsubscriptionhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case orgsubscriptionhistory.FieldRef:
		m.ResetRef()
		return nil
	case orgsubscriptionhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case orgsubscriptionhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orgsubscriptionhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orgsubscriptionhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case orgsubscriptionhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case orgsubscriptionhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orgsubscriptionhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case orgsubscriptionhistory.FieldTags:
		m.ResetTags()
		return nil
	case orgsubscriptionhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case orgsubscriptionhistory.FieldStripeSubscriptionID:
		m.ResetStripeSubscriptionID()
		return nil
	case orgsubscriptionhistory.FieldStripeSubscriptionStatus:
		m.ResetStripeSubscriptionStatus()
		return nil
	case orgsubscriptionhistory.FieldActive:
		m.ResetActive()
		return nil
	case orgsubscriptionhistory.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case orgsubscriptionhistory.FieldTrialExpiresAt:
		m.ResetTrialExpiresAt()
		return nil
	case orgsubscriptionhistory.FieldDaysUntilDue:
		m.ResetDaysUntilDue()
		return nil
	}
	return fmt.Errorf("unknown OrgSubscriptionHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgSubscriptionHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgSubscriptionHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgSubscriptionHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgSubscriptionHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgSubscriptionHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgSubscriptionHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrgSubscriptionHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgSubscriptionHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrgSubscriptionHistory edge %s", name)
}

// OrganizationHistoryMutation represents an operation that mutates the OrganizationHistory nodes in the graph.
type OrganizationHistoryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	history_time           *time.Time
	ref                    *string
	operation              *history.OpType
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	deleted_at             *time.Time
	deleted_by             *string
	tags                   *[]string
	appendtags             []string
	name                   *string
	display_name           *string
	description            *string
	parent_organization_id *string
	personal_org           *bool
	avatar_remote_url      *string
	avatar_local_file_id   *string
	avatar_updated_at      *time.Time
	dedicated_db           *bool
	stripe_customer_id     *string
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*OrganizationHistory, error)
	predicates             []predicate.OrganizationHistory
}

var _ ent.Mutation = (*OrganizationHistoryMutation)(nil)

// organizationhistoryOption allows management of the mutation configuration using functional options.
type organizationhistoryOption func(*OrganizationHistoryMutation)

// newOrganizationHistoryMutation creates new mutation for the OrganizationHistory entity.
func newOrganizationHistoryMutation(c config, op Op, opts ...organizationhistoryOption) *OrganizationHistoryMutation {
	m := &OrganizationHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationHistoryID sets the ID field of the mutation.
func withOrganizationHistoryID(id string) organizationhistoryOption {
	return func(m *OrganizationHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationHistory
		)
		m.oldValue = func(ctx context.Context) (*OrganizationHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationHistory sets the old OrganizationHistory of the mutation.
func withOrganizationHistory(node *OrganizationHistory) organizationhistoryOption {
	return func(m *OrganizationHistoryMutation) {
		m.oldValue = func(context.Context) (*OrganizationHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationHistory entities.
func (m *OrganizationHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *OrganizationHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *OrganizationHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *OrganizationHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *OrganizationHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *OrganizationHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *OrganizationHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[organizationhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *OrganizationHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, organizationhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *OrganizationHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *OrganizationHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *OrganizationHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrganizationHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[organizationhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, organizationhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrganizationHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[organizationhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, organizationhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrganizationHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[organizationhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, organizationhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[organizationhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, organizationhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organizationhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organizationhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *OrganizationHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *OrganizationHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *OrganizationHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[organizationhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *OrganizationHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, organizationhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *OrganizationHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *OrganizationHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *OrganizationHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *OrganizationHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *OrganizationHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[organizationhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *OrganizationHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, organizationhistory.FieldTags)
}

// SetName sets the "name" field.
func (m *OrganizationHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationHistoryMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *OrganizationHistoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *OrganizationHistoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *OrganizationHistoryMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetDescription sets the "description" field.
func (m *OrganizationHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrganizationHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OrganizationHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[organizationhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OrganizationHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, organizationhistory.FieldDescription)
}

// SetParentOrganizationID sets the "parent_organization_id" field.
func (m *OrganizationHistoryMutation) SetParentOrganizationID(s string) {
	m.parent_organization_id = &s
}

// ParentOrganizationID returns the value of the "parent_organization_id" field in the mutation.
func (m *OrganizationHistoryMutation) ParentOrganizationID() (r string, exists bool) {
	v := m.parent_organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentOrganizationID returns the old "parent_organization_id" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldParentOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentOrganizationID: %w", err)
	}
	return oldValue.ParentOrganizationID, nil
}

// ClearParentOrganizationID clears the value of the "parent_organization_id" field.
func (m *OrganizationHistoryMutation) ClearParentOrganizationID() {
	m.parent_organization_id = nil
	m.clearedFields[organizationhistory.FieldParentOrganizationID] = struct{}{}
}

// ParentOrganizationIDCleared returns if the "parent_organization_id" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) ParentOrganizationIDCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldParentOrganizationID]
	return ok
}

// ResetParentOrganizationID resets all changes to the "parent_organization_id" field.
func (m *OrganizationHistoryMutation) ResetParentOrganizationID() {
	m.parent_organization_id = nil
	delete(m.clearedFields, organizationhistory.FieldParentOrganizationID)
}

// SetPersonalOrg sets the "personal_org" field.
func (m *OrganizationHistoryMutation) SetPersonalOrg(b bool) {
	m.personal_org = &b
}

// PersonalOrg returns the value of the "personal_org" field in the mutation.
func (m *OrganizationHistoryMutation) PersonalOrg() (r bool, exists bool) {
	v := m.personal_org
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalOrg returns the old "personal_org" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldPersonalOrg(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonalOrg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonalOrg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalOrg: %w", err)
	}
	return oldValue.PersonalOrg, nil
}

// ClearPersonalOrg clears the value of the "personal_org" field.
func (m *OrganizationHistoryMutation) ClearPersonalOrg() {
	m.personal_org = nil
	m.clearedFields[organizationhistory.FieldPersonalOrg] = struct{}{}
}

// PersonalOrgCleared returns if the "personal_org" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) PersonalOrgCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldPersonalOrg]
	return ok
}

// ResetPersonalOrg resets all changes to the "personal_org" field.
func (m *OrganizationHistoryMutation) ResetPersonalOrg() {
	m.personal_org = nil
	delete(m.clearedFields, organizationhistory.FieldPersonalOrg)
}

// SetAvatarRemoteURL sets the "avatar_remote_url" field.
func (m *OrganizationHistoryMutation) SetAvatarRemoteURL(s string) {
	m.avatar_remote_url = &s
}

// AvatarRemoteURL returns the value of the "avatar_remote_url" field in the mutation.
func (m *OrganizationHistoryMutation) AvatarRemoteURL() (r string, exists bool) {
	v := m.avatar_remote_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarRemoteURL returns the old "avatar_remote_url" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldAvatarRemoteURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarRemoteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarRemoteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarRemoteURL: %w", err)
	}
	return oldValue.AvatarRemoteURL, nil
}

// ClearAvatarRemoteURL clears the value of the "avatar_remote_url" field.
func (m *OrganizationHistoryMutation) ClearAvatarRemoteURL() {
	m.avatar_remote_url = nil
	m.clearedFields[organizationhistory.FieldAvatarRemoteURL] = struct{}{}
}

// AvatarRemoteURLCleared returns if the "avatar_remote_url" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) AvatarRemoteURLCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldAvatarRemoteURL]
	return ok
}

// ResetAvatarRemoteURL resets all changes to the "avatar_remote_url" field.
func (m *OrganizationHistoryMutation) ResetAvatarRemoteURL() {
	m.avatar_remote_url = nil
	delete(m.clearedFields, organizationhistory.FieldAvatarRemoteURL)
}

// SetAvatarLocalFileID sets the "avatar_local_file_id" field.
func (m *OrganizationHistoryMutation) SetAvatarLocalFileID(s string) {
	m.avatar_local_file_id = &s
}

// AvatarLocalFileID returns the value of the "avatar_local_file_id" field in the mutation.
func (m *OrganizationHistoryMutation) AvatarLocalFileID() (r string, exists bool) {
	v := m.avatar_local_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarLocalFileID returns the old "avatar_local_file_id" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldAvatarLocalFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarLocalFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarLocalFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarLocalFileID: %w", err)
	}
	return oldValue.AvatarLocalFileID, nil
}

// ClearAvatarLocalFileID clears the value of the "avatar_local_file_id" field.
func (m *OrganizationHistoryMutation) ClearAvatarLocalFileID() {
	m.avatar_local_file_id = nil
	m.clearedFields[organizationhistory.FieldAvatarLocalFileID] = struct{}{}
}

// AvatarLocalFileIDCleared returns if the "avatar_local_file_id" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) AvatarLocalFileIDCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldAvatarLocalFileID]
	return ok
}

// ResetAvatarLocalFileID resets all changes to the "avatar_local_file_id" field.
func (m *OrganizationHistoryMutation) ResetAvatarLocalFileID() {
	m.avatar_local_file_id = nil
	delete(m.clearedFields, organizationhistory.FieldAvatarLocalFileID)
}

// SetAvatarUpdatedAt sets the "avatar_updated_at" field.
func (m *OrganizationHistoryMutation) SetAvatarUpdatedAt(t time.Time) {
	m.avatar_updated_at = &t
}

// AvatarUpdatedAt returns the value of the "avatar_updated_at" field in the mutation.
func (m *OrganizationHistoryMutation) AvatarUpdatedAt() (r time.Time, exists bool) {
	v := m.avatar_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarUpdatedAt returns the old "avatar_updated_at" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldAvatarUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarUpdatedAt: %w", err)
	}
	return oldValue.AvatarUpdatedAt, nil
}

// ClearAvatarUpdatedAt clears the value of the "avatar_updated_at" field.
func (m *OrganizationHistoryMutation) ClearAvatarUpdatedAt() {
	m.avatar_updated_at = nil
	m.clearedFields[organizationhistory.FieldAvatarUpdatedAt] = struct{}{}
}

// AvatarUpdatedAtCleared returns if the "avatar_updated_at" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) AvatarUpdatedAtCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldAvatarUpdatedAt]
	return ok
}

// ResetAvatarUpdatedAt resets all changes to the "avatar_updated_at" field.
func (m *OrganizationHistoryMutation) ResetAvatarUpdatedAt() {
	m.avatar_updated_at = nil
	delete(m.clearedFields, organizationhistory.FieldAvatarUpdatedAt)
}

// SetDedicatedDb sets the "dedicated_db" field.
func (m *OrganizationHistoryMutation) SetDedicatedDb(b bool) {
	m.dedicated_db = &b
}

// DedicatedDb returns the value of the "dedicated_db" field in the mutation.
func (m *OrganizationHistoryMutation) DedicatedDb() (r bool, exists bool) {
	v := m.dedicated_db
	if v == nil {
		return
	}
	return *v, true
}

// OldDedicatedDb returns the old "dedicated_db" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldDedicatedDb(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDedicatedDb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDedicatedDb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDedicatedDb: %w", err)
	}
	return oldValue.DedicatedDb, nil
}

// ResetDedicatedDb resets all changes to the "dedicated_db" field.
func (m *OrganizationHistoryMutation) ResetDedicatedDb() {
	m.dedicated_db = nil
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *OrganizationHistoryMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *OrganizationHistoryMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldStripeCustomerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ClearStripeCustomerID clears the value of the "stripe_customer_id" field.
func (m *OrganizationHistoryMutation) ClearStripeCustomerID() {
	m.stripe_customer_id = nil
	m.clearedFields[organizationhistory.FieldStripeCustomerID] = struct{}{}
}

// StripeCustomerIDCleared returns if the "stripe_customer_id" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) StripeCustomerIDCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldStripeCustomerID]
	return ok
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *OrganizationHistoryMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
	delete(m.clearedFields, organizationhistory.FieldStripeCustomerID)
}

// Where appends a list predicates to the OrganizationHistoryMutation builder.
func (m *OrganizationHistoryMutation) Where(ps ...predicate.OrganizationHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationHistory).
func (m *OrganizationHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationHistoryMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.history_time != nil {
		fields = append(fields, organizationhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, organizationhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, organizationhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, organizationhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, organizationhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, organizationhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, organizationhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, organizationhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, organizationhistory.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, organizationhistory.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, organizationhistory.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, organizationhistory.FieldDescription)
	}
	if m.parent_organization_id != nil {
		fields = append(fields, organizationhistory.FieldParentOrganizationID)
	}
	if m.personal_org != nil {
		fields = append(fields, organizationhistory.FieldPersonalOrg)
	}
	if m.avatar_remote_url != nil {
		fields = append(fields, organizationhistory.FieldAvatarRemoteURL)
	}
	if m.avatar_local_file_id != nil {
		fields = append(fields, organizationhistory.FieldAvatarLocalFileID)
	}
	if m.avatar_updated_at != nil {
		fields = append(fields, organizationhistory.FieldAvatarUpdatedAt)
	}
	if m.dedicated_db != nil {
		fields = append(fields, organizationhistory.FieldDedicatedDb)
	}
	if m.stripe_customer_id != nil {
		fields = append(fields, organizationhistory.FieldStripeCustomerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationhistory.FieldHistoryTime:
		return m.HistoryTime()
	case organizationhistory.FieldRef:
		return m.Ref()
	case organizationhistory.FieldOperation:
		return m.Operation()
	case organizationhistory.FieldCreatedAt:
		return m.CreatedAt()
	case organizationhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationhistory.FieldCreatedBy:
		return m.CreatedBy()
	case organizationhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case organizationhistory.FieldDeletedAt:
		return m.DeletedAt()
	case organizationhistory.FieldDeletedBy:
		return m.DeletedBy()
	case organizationhistory.FieldTags:
		return m.Tags()
	case organizationhistory.FieldName:
		return m.Name()
	case organizationhistory.FieldDisplayName:
		return m.DisplayName()
	case organizationhistory.FieldDescription:
		return m.Description()
	case organizationhistory.FieldParentOrganizationID:
		return m.ParentOrganizationID()
	case organizationhistory.FieldPersonalOrg:
		return m.PersonalOrg()
	case organizationhistory.FieldAvatarRemoteURL:
		return m.AvatarRemoteURL()
	case organizationhistory.FieldAvatarLocalFileID:
		return m.AvatarLocalFileID()
	case organizationhistory.FieldAvatarUpdatedAt:
		return m.AvatarUpdatedAt()
	case organizationhistory.FieldDedicatedDb:
		return m.DedicatedDb()
	case organizationhistory.FieldStripeCustomerID:
		return m.StripeCustomerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case organizationhistory.FieldRef:
		return m.OldRef(ctx)
	case organizationhistory.FieldOperation:
		return m.OldOperation(ctx)
	case organizationhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organizationhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organizationhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organizationhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case organizationhistory.FieldTags:
		return m.OldTags(ctx)
	case organizationhistory.FieldName:
		return m.OldName(ctx)
	case organizationhistory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case organizationhistory.FieldDescription:
		return m.OldDescription(ctx)
	case organizationhistory.FieldParentOrganizationID:
		return m.OldParentOrganizationID(ctx)
	case organizationhistory.FieldPersonalOrg:
		return m.OldPersonalOrg(ctx)
	case organizationhistory.FieldAvatarRemoteURL:
		return m.OldAvatarRemoteURL(ctx)
	case organizationhistory.FieldAvatarLocalFileID:
		return m.OldAvatarLocalFileID(ctx)
	case organizationhistory.FieldAvatarUpdatedAt:
		return m.OldAvatarUpdatedAt(ctx)
	case organizationhistory.FieldDedicatedDb:
		return m.OldDedicatedDb(ctx)
	case organizationhistory.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case organizationhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case organizationhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case organizationhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organizationhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organizationhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organizationhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case organizationhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case organizationhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organizationhistory.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case organizationhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case organizationhistory.FieldParentOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentOrganizationID(v)
		return nil
	case organizationhistory.FieldPersonalOrg:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalOrg(v)
		return nil
	case organizationhistory.FieldAvatarRemoteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarRemoteURL(v)
		return nil
	case organizationhistory.FieldAvatarLocalFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarLocalFileID(v)
		return nil
	case organizationhistory.FieldAvatarUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarUpdatedAt(v)
		return nil
	case organizationhistory.FieldDedicatedDb:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDedicatedDb(v)
		return nil
	case organizationhistory.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationhistory.FieldRef) {
		fields = append(fields, organizationhistory.FieldRef)
	}
	if m.FieldCleared(organizationhistory.FieldCreatedAt) {
		fields = append(fields, organizationhistory.FieldCreatedAt)
	}
	if m.FieldCleared(organizationhistory.FieldUpdatedAt) {
		fields = append(fields, organizationhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(organizationhistory.FieldCreatedBy) {
		fields = append(fields, organizationhistory.FieldCreatedBy)
	}
	if m.FieldCleared(organizationhistory.FieldUpdatedBy) {
		fields = append(fields, organizationhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(organizationhistory.FieldDeletedAt) {
		fields = append(fields, organizationhistory.FieldDeletedAt)
	}
	if m.FieldCleared(organizationhistory.FieldDeletedBy) {
		fields = append(fields, organizationhistory.FieldDeletedBy)
	}
	if m.FieldCleared(organizationhistory.FieldTags) {
		fields = append(fields, organizationhistory.FieldTags)
	}
	if m.FieldCleared(organizationhistory.FieldDescription) {
		fields = append(fields, organizationhistory.FieldDescription)
	}
	if m.FieldCleared(organizationhistory.FieldParentOrganizationID) {
		fields = append(fields, organizationhistory.FieldParentOrganizationID)
	}
	if m.FieldCleared(organizationhistory.FieldPersonalOrg) {
		fields = append(fields, organizationhistory.FieldPersonalOrg)
	}
	if m.FieldCleared(organizationhistory.FieldAvatarRemoteURL) {
		fields = append(fields, organizationhistory.FieldAvatarRemoteURL)
	}
	if m.FieldCleared(organizationhistory.FieldAvatarLocalFileID) {
		fields = append(fields, organizationhistory.FieldAvatarLocalFileID)
	}
	if m.FieldCleared(organizationhistory.FieldAvatarUpdatedAt) {
		fields = append(fields, organizationhistory.FieldAvatarUpdatedAt)
	}
	if m.FieldCleared(organizationhistory.FieldStripeCustomerID) {
		fields = append(fields, organizationhistory.FieldStripeCustomerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationHistoryMutation) ClearField(name string) error {
	switch name {
	case organizationhistory.FieldRef:
		m.ClearRef()
		return nil
	case organizationhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case organizationhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case organizationhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case organizationhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organizationhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case organizationhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case organizationhistory.FieldTags:
		m.ClearTags()
		return nil
	case organizationhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case organizationhistory.FieldParentOrganizationID:
		m.ClearParentOrganizationID()
		return nil
	case organizationhistory.FieldPersonalOrg:
		m.ClearPersonalOrg()
		return nil
	case organizationhistory.FieldAvatarRemoteURL:
		m.ClearAvatarRemoteURL()
		return nil
	case organizationhistory.FieldAvatarLocalFileID:
		m.ClearAvatarLocalFileID()
		return nil
	case organizationhistory.FieldAvatarUpdatedAt:
		m.ClearAvatarUpdatedAt()
		return nil
	case organizationhistory.FieldStripeCustomerID:
		m.ClearStripeCustomerID()
		return nil
	}
	return fmt.Errorf("unknown OrganizationHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationHistoryMutation) ResetField(name string) error {
	switch name {
	case organizationhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case organizationhistory.FieldRef:
		m.ResetRef()
		return nil
	case organizationhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case organizationhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organizationhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organizationhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organizationhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case organizationhistory.FieldTags:
		m.ResetTags()
		return nil
	case organizationhistory.FieldName:
		m.ResetName()
		return nil
	case organizationhistory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case organizationhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case organizationhistory.FieldParentOrganizationID:
		m.ResetParentOrganizationID()
		return nil
	case organizationhistory.FieldPersonalOrg:
		m.ResetPersonalOrg()
		return nil
	case organizationhistory.FieldAvatarRemoteURL:
		m.ResetAvatarRemoteURL()
		return nil
	case organizationhistory.FieldAvatarLocalFileID:
		m.ResetAvatarLocalFileID()
		return nil
	case organizationhistory.FieldAvatarUpdatedAt:
		m.ResetAvatarUpdatedAt()
		return nil
	case organizationhistory.FieldDedicatedDb:
		m.ResetDedicatedDb()
		return nil
	case organizationhistory.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	}
	return fmt.Errorf("unknown OrganizationHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrganizationHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrganizationHistory edge %s", name)
}

// OrganizationSettingHistoryMutation represents an operation that mutates the OrganizationSettingHistory nodes in the graph.
type OrganizationSettingHistoryMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *string
	history_time                        *time.Time
	ref                                 *string
	operation                           *history.OpType
	created_at                          *time.Time
	updated_at                          *time.Time
	created_by                          *string
	updated_by                          *string
	deleted_at                          *time.Time
	deleted_by                          *string
	tags                                *[]string
	appendtags                          []string
	domains                             *[]string
	appenddomains                       []string
	billing_contact                     *string
	billing_email                       *string
	billing_phone                       *string
	billing_address                     *models.Address
	tax_identifier                      *string
	geo_location                        *enums.Region
	organization_id                     *string
	billing_notifications_enabled       *bool
	allowed_email_domains               *[]string
	appendallowed_email_domains         []string
	allow_matching_domains_autojoin     *bool
	identity_provider                   *enums.SSOProvider
	identity_provider_client_id         *string
	identity_provider_client_secret     *string
	identity_provider_metadata_endpoint *string
	identity_provider_auth_tested       *bool
	identity_provider_entity_id         *string
	oidc_discovery_endpoint             *string
	saml_signin_url                     *string
	saml_issuer                         *string
	saml_cert                           *string
	identity_provider_login_enforced    *bool
	multifactor_auth_enforced           *bool
	compliance_webhook_token            *string
	payment_method_added                *bool
	clearedFields                       map[string]struct{}
	done                                bool
	oldValue                            func(context.Context) (*OrganizationSettingHistory, error)
	predicates                          []predicate.OrganizationSettingHistory
}

var _ ent.Mutation = (*OrganizationSettingHistoryMutation)(nil)

// organizationsettinghistoryOption allows management of the mutation configuration using functional options.
type organizationsettinghistoryOption func(*OrganizationSettingHistoryMutation)

// newOrganizationSettingHistoryMutation creates new mutation for the OrganizationSettingHistory entity.
func newOrganizationSettingHistoryMutation(c config, op Op, opts ...organizationsettinghistoryOption) *OrganizationSettingHistoryMutation {
	m := &OrganizationSettingHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationSettingHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationSettingHistoryID sets the ID field of the mutation.
func withOrganizationSettingHistoryID(id string) organizationsettinghistoryOption {
	return func(m *OrganizationSettingHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationSettingHistory
		)
		m.oldValue = func(ctx context.Context) (*OrganizationSettingHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationSettingHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationSettingHistory sets the old OrganizationSettingHistory of the mutation.
func withOrganizationSettingHistory(node *OrganizationSettingHistory) organizationsettinghistoryOption {
	return func(m *OrganizationSettingHistoryMutation) {
		m.oldValue = func(context.Context) (*OrganizationSettingHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationSettingHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationSettingHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationSettingHistory entities.
func (m *OrganizationSettingHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationSettingHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationSettingHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationSettingHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *OrganizationSettingHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *OrganizationSettingHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *OrganizationSettingHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *OrganizationSettingHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *OrganizationSettingHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *OrganizationSettingHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[organizationsettinghistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *OrganizationSettingHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, organizationsettinghistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *OrganizationSettingHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *OrganizationSettingHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *OrganizationSettingHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationSettingHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationSettingHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrganizationSettingHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[organizationsettinghistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationSettingHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, organizationsettinghistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationSettingHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationSettingHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrganizationSettingHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[organizationsettinghistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationSettingHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, organizationsettinghistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationSettingHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationSettingHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrganizationSettingHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[organizationsettinghistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationSettingHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, organizationsettinghistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationSettingHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationSettingHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationSettingHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[organizationsettinghistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationSettingHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, organizationsettinghistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationSettingHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationSettingHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationSettingHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organizationsettinghistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationSettingHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organizationsettinghistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *OrganizationSettingHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *OrganizationSettingHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *OrganizationSettingHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[organizationsettinghistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *OrganizationSettingHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, organizationsettinghistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *OrganizationSettingHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *OrganizationSettingHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *OrganizationSettingHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *OrganizationSettingHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *OrganizationSettingHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[organizationsettinghistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *OrganizationSettingHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, organizationsettinghistory.FieldTags)
}

// SetDomains sets the "domains" field.
func (m *OrganizationSettingHistoryMutation) SetDomains(s []string) {
	m.domains = &s
	m.appenddomains = nil
}

// Domains returns the value of the "domains" field in the mutation.
func (m *OrganizationSettingHistoryMutation) Domains() (r []string, exists bool) {
	v := m.domains
	if v == nil {
		return
	}
	return *v, true
}

// OldDomains returns the old "domains" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldDomains(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomains: %w", err)
	}
	return oldValue.Domains, nil
}

// AppendDomains adds s to the "domains" field.
func (m *OrganizationSettingHistoryMutation) AppendDomains(s []string) {
	m.appenddomains = append(m.appenddomains, s...)
}

// AppendedDomains returns the list of values that were appended to the "domains" field in this mutation.
func (m *OrganizationSettingHistoryMutation) AppendedDomains() ([]string, bool) {
	if len(m.appenddomains) == 0 {
		return nil, false
	}
	return m.appenddomains, true
}

// ClearDomains clears the value of the "domains" field.
func (m *OrganizationSettingHistoryMutation) ClearDomains() {
	m.domains = nil
	m.appenddomains = nil
	m.clearedFields[organizationsettinghistory.FieldDomains] = struct{}{}
}

// DomainsCleared returns if the "domains" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) DomainsCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldDomains]
	return ok
}

// ResetDomains resets all changes to the "domains" field.
func (m *OrganizationSettingHistoryMutation) ResetDomains() {
	m.domains = nil
	m.appenddomains = nil
	delete(m.clearedFields, organizationsettinghistory.FieldDomains)
}

// SetBillingContact sets the "billing_contact" field.
func (m *OrganizationSettingHistoryMutation) SetBillingContact(s string) {
	m.billing_contact = &s
}

// BillingContact returns the value of the "billing_contact" field in the mutation.
func (m *OrganizationSettingHistoryMutation) BillingContact() (r string, exists bool) {
	v := m.billing_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingContact returns the old "billing_contact" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldBillingContact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingContact: %w", err)
	}
	return oldValue.BillingContact, nil
}

// ClearBillingContact clears the value of the "billing_contact" field.
func (m *OrganizationSettingHistoryMutation) ClearBillingContact() {
	m.billing_contact = nil
	m.clearedFields[organizationsettinghistory.FieldBillingContact] = struct{}{}
}

// BillingContactCleared returns if the "billing_contact" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) BillingContactCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldBillingContact]
	return ok
}

// ResetBillingContact resets all changes to the "billing_contact" field.
func (m *OrganizationSettingHistoryMutation) ResetBillingContact() {
	m.billing_contact = nil
	delete(m.clearedFields, organizationsettinghistory.FieldBillingContact)
}

// SetBillingEmail sets the "billing_email" field.
func (m *OrganizationSettingHistoryMutation) SetBillingEmail(s string) {
	m.billing_email = &s
}

// BillingEmail returns the value of the "billing_email" field in the mutation.
func (m *OrganizationSettingHistoryMutation) BillingEmail() (r string, exists bool) {
	v := m.billing_email
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingEmail returns the old "billing_email" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldBillingEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingEmail: %w", err)
	}
	return oldValue.BillingEmail, nil
}

// ClearBillingEmail clears the value of the "billing_email" field.
func (m *OrganizationSettingHistoryMutation) ClearBillingEmail() {
	m.billing_email = nil
	m.clearedFields[organizationsettinghistory.FieldBillingEmail] = struct{}{}
}

// BillingEmailCleared returns if the "billing_email" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) BillingEmailCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldBillingEmail]
	return ok
}

// ResetBillingEmail resets all changes to the "billing_email" field.
func (m *OrganizationSettingHistoryMutation) ResetBillingEmail() {
	m.billing_email = nil
	delete(m.clearedFields, organizationsettinghistory.FieldBillingEmail)
}

// SetBillingPhone sets the "billing_phone" field.
func (m *OrganizationSettingHistoryMutation) SetBillingPhone(s string) {
	m.billing_phone = &s
}

// BillingPhone returns the value of the "billing_phone" field in the mutation.
func (m *OrganizationSettingHistoryMutation) BillingPhone() (r string, exists bool) {
	v := m.billing_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingPhone returns the old "billing_phone" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldBillingPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingPhone: %w", err)
	}
	return oldValue.BillingPhone, nil
}

// ClearBillingPhone clears the value of the "billing_phone" field.
func (m *OrganizationSettingHistoryMutation) ClearBillingPhone() {
	m.billing_phone = nil
	m.clearedFields[organizationsettinghistory.FieldBillingPhone] = struct{}{}
}

// BillingPhoneCleared returns if the "billing_phone" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) BillingPhoneCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldBillingPhone]
	return ok
}

// ResetBillingPhone resets all changes to the "billing_phone" field.
func (m *OrganizationSettingHistoryMutation) ResetBillingPhone() {
	m.billing_phone = nil
	delete(m.clearedFields, organizationsettinghistory.FieldBillingPhone)
}

// SetBillingAddress sets the "billing_address" field.
func (m *OrganizationSettingHistoryMutation) SetBillingAddress(value models.Address) {
	m.billing_address = &value
}

// BillingAddress returns the value of the "billing_address" field in the mutation.
func (m *OrganizationSettingHistoryMutation) BillingAddress() (r models.Address, exists bool) {
	v := m.billing_address
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddress returns the old "billing_address" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldBillingAddress(ctx context.Context) (v models.Address, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddress: %w", err)
	}
	return oldValue.BillingAddress, nil
}

// ClearBillingAddress clears the value of the "billing_address" field.
func (m *OrganizationSettingHistoryMutation) ClearBillingAddress() {
	m.billing_address = nil
	m.clearedFields[organizationsettinghistory.FieldBillingAddress] = struct{}{}
}

// BillingAddressCleared returns if the "billing_address" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) BillingAddressCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldBillingAddress]
	return ok
}

// ResetBillingAddress resets all changes to the "billing_address" field.
func (m *OrganizationSettingHistoryMutation) ResetBillingAddress() {
	m.billing_address = nil
	delete(m.clearedFields, organizationsettinghistory.FieldBillingAddress)
}

// SetTaxIdentifier sets the "tax_identifier" field.
func (m *OrganizationSettingHistoryMutation) SetTaxIdentifier(s string) {
	m.tax_identifier = &s
}

// TaxIdentifier returns the value of the "tax_identifier" field in the mutation.
func (m *OrganizationSettingHistoryMutation) TaxIdentifier() (r string, exists bool) {
	v := m.tax_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxIdentifier returns the old "tax_identifier" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldTaxIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxIdentifier: %w", err)
	}
	return oldValue.TaxIdentifier, nil
}

// ClearTaxIdentifier clears the value of the "tax_identifier" field.
func (m *OrganizationSettingHistoryMutation) ClearTaxIdentifier() {
	m.tax_identifier = nil
	m.clearedFields[organizationsettinghistory.FieldTaxIdentifier] = struct{}{}
}

// TaxIdentifierCleared returns if the "tax_identifier" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) TaxIdentifierCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldTaxIdentifier]
	return ok
}

// ResetTaxIdentifier resets all changes to the "tax_identifier" field.
func (m *OrganizationSettingHistoryMutation) ResetTaxIdentifier() {
	m.tax_identifier = nil
	delete(m.clearedFields, organizationsettinghistory.FieldTaxIdentifier)
}

// SetGeoLocation sets the "geo_location" field.
func (m *OrganizationSettingHistoryMutation) SetGeoLocation(e enums.Region) {
	m.geo_location = &e
}

// GeoLocation returns the value of the "geo_location" field in the mutation.
func (m *OrganizationSettingHistoryMutation) GeoLocation() (r enums.Region, exists bool) {
	v := m.geo_location
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoLocation returns the old "geo_location" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldGeoLocation(ctx context.Context) (v enums.Region, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoLocation: %w", err)
	}
	return oldValue.GeoLocation, nil
}

// ClearGeoLocation clears the value of the "geo_location" field.
func (m *OrganizationSettingHistoryMutation) ClearGeoLocation() {
	m.geo_location = nil
	m.clearedFields[organizationsettinghistory.FieldGeoLocation] = struct{}{}
}

// GeoLocationCleared returns if the "geo_location" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) GeoLocationCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldGeoLocation]
	return ok
}

// ResetGeoLocation resets all changes to the "geo_location" field.
func (m *OrganizationSettingHistoryMutation) ResetGeoLocation() {
	m.geo_location = nil
	delete(m.clearedFields, organizationsettinghistory.FieldGeoLocation)
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrganizationSettingHistoryMutation) SetOrganizationID(s string) {
	m.organization_id = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrganizationSettingHistoryMutation) OrganizationID() (r string, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *OrganizationSettingHistoryMutation) ClearOrganizationID() {
	m.organization_id = nil
	m.clearedFields[organizationsettinghistory.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrganizationSettingHistoryMutation) ResetOrganizationID() {
	m.organization_id = nil
	delete(m.clearedFields, organizationsettinghistory.FieldOrganizationID)
}

// SetBillingNotificationsEnabled sets the "billing_notifications_enabled" field.
func (m *OrganizationSettingHistoryMutation) SetBillingNotificationsEnabled(b bool) {
	m.billing_notifications_enabled = &b
}

// BillingNotificationsEnabled returns the value of the "billing_notifications_enabled" field in the mutation.
func (m *OrganizationSettingHistoryMutation) BillingNotificationsEnabled() (r bool, exists bool) {
	v := m.billing_notifications_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingNotificationsEnabled returns the old "billing_notifications_enabled" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldBillingNotificationsEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingNotificationsEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingNotificationsEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingNotificationsEnabled: %w", err)
	}
	return oldValue.BillingNotificationsEnabled, nil
}

// ResetBillingNotificationsEnabled resets all changes to the "billing_notifications_enabled" field.
func (m *OrganizationSettingHistoryMutation) ResetBillingNotificationsEnabled() {
	m.billing_notifications_enabled = nil
}

// SetAllowedEmailDomains sets the "allowed_email_domains" field.
func (m *OrganizationSettingHistoryMutation) SetAllowedEmailDomains(s []string) {
	m.allowed_email_domains = &s
	m.appendallowed_email_domains = nil
}

// AllowedEmailDomains returns the value of the "allowed_email_domains" field in the mutation.
func (m *OrganizationSettingHistoryMutation) AllowedEmailDomains() (r []string, exists bool) {
	v := m.allowed_email_domains
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedEmailDomains returns the old "allowed_email_domains" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldAllowedEmailDomains(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedEmailDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedEmailDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedEmailDomains: %w", err)
	}
	return oldValue.AllowedEmailDomains, nil
}

// AppendAllowedEmailDomains adds s to the "allowed_email_domains" field.
func (m *OrganizationSettingHistoryMutation) AppendAllowedEmailDomains(s []string) {
	m.appendallowed_email_domains = append(m.appendallowed_email_domains, s...)
}

// AppendedAllowedEmailDomains returns the list of values that were appended to the "allowed_email_domains" field in this mutation.
func (m *OrganizationSettingHistoryMutation) AppendedAllowedEmailDomains() ([]string, bool) {
	if len(m.appendallowed_email_domains) == 0 {
		return nil, false
	}
	return m.appendallowed_email_domains, true
}

// ClearAllowedEmailDomains clears the value of the "allowed_email_domains" field.
func (m *OrganizationSettingHistoryMutation) ClearAllowedEmailDomains() {
	m.allowed_email_domains = nil
	m.appendallowed_email_domains = nil
	m.clearedFields[organizationsettinghistory.FieldAllowedEmailDomains] = struct{}{}
}

// AllowedEmailDomainsCleared returns if the "allowed_email_domains" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) AllowedEmailDomainsCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldAllowedEmailDomains]
	return ok
}

// ResetAllowedEmailDomains resets all changes to the "allowed_email_domains" field.
func (m *OrganizationSettingHistoryMutation) ResetAllowedEmailDomains() {
	m.allowed_email_domains = nil
	m.appendallowed_email_domains = nil
	delete(m.clearedFields, organizationsettinghistory.FieldAllowedEmailDomains)
}

// SetAllowMatchingDomainsAutojoin sets the "allow_matching_domains_autojoin" field.
func (m *OrganizationSettingHistoryMutation) SetAllowMatchingDomainsAutojoin(b bool) {
	m.allow_matching_domains_autojoin = &b
}

// AllowMatchingDomainsAutojoin returns the value of the "allow_matching_domains_autojoin" field in the mutation.
func (m *OrganizationSettingHistoryMutation) AllowMatchingDomainsAutojoin() (r bool, exists bool) {
	v := m.allow_matching_domains_autojoin
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowMatchingDomainsAutojoin returns the old "allow_matching_domains_autojoin" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldAllowMatchingDomainsAutojoin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowMatchingDomainsAutojoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowMatchingDomainsAutojoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowMatchingDomainsAutojoin: %w", err)
	}
	return oldValue.AllowMatchingDomainsAutojoin, nil
}

// ClearAllowMatchingDomainsAutojoin clears the value of the "allow_matching_domains_autojoin" field.
func (m *OrganizationSettingHistoryMutation) ClearAllowMatchingDomainsAutojoin() {
	m.allow_matching_domains_autojoin = nil
	m.clearedFields[organizationsettinghistory.FieldAllowMatchingDomainsAutojoin] = struct{}{}
}

// AllowMatchingDomainsAutojoinCleared returns if the "allow_matching_domains_autojoin" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) AllowMatchingDomainsAutojoinCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldAllowMatchingDomainsAutojoin]
	return ok
}

// ResetAllowMatchingDomainsAutojoin resets all changes to the "allow_matching_domains_autojoin" field.
func (m *OrganizationSettingHistoryMutation) ResetAllowMatchingDomainsAutojoin() {
	m.allow_matching_domains_autojoin = nil
	delete(m.clearedFields, organizationsettinghistory.FieldAllowMatchingDomainsAutojoin)
}

// SetIdentityProvider sets the "identity_provider" field.
func (m *OrganizationSettingHistoryMutation) SetIdentityProvider(ep enums.SSOProvider) {
	m.identity_provider = &ep
}

// IdentityProvider returns the value of the "identity_provider" field in the mutation.
func (m *OrganizationSettingHistoryMutation) IdentityProvider() (r enums.SSOProvider, exists bool) {
	v := m.identity_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentityProvider returns the old "identity_provider" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldIdentityProvider(ctx context.Context) (v enums.SSOProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentityProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentityProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentityProvider: %w", err)
	}
	return oldValue.IdentityProvider, nil
}

// ClearIdentityProvider clears the value of the "identity_provider" field.
func (m *OrganizationSettingHistoryMutation) ClearIdentityProvider() {
	m.identity_provider = nil
	m.clearedFields[organizationsettinghistory.FieldIdentityProvider] = struct{}{}
}

// IdentityProviderCleared returns if the "identity_provider" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) IdentityProviderCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldIdentityProvider]
	return ok
}

// ResetIdentityProvider resets all changes to the "identity_provider" field.
func (m *OrganizationSettingHistoryMutation) ResetIdentityProvider() {
	m.identity_provider = nil
	delete(m.clearedFields, organizationsettinghistory.FieldIdentityProvider)
}

// SetIdentityProviderClientID sets the "identity_provider_client_id" field.
func (m *OrganizationSettingHistoryMutation) SetIdentityProviderClientID(s string) {
	m.identity_provider_client_id = &s
}

// IdentityProviderClientID returns the value of the "identity_provider_client_id" field in the mutation.
func (m *OrganizationSettingHistoryMutation) IdentityProviderClientID() (r string, exists bool) {
	v := m.identity_provider_client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentityProviderClientID returns the old "identity_provider_client_id" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldIdentityProviderClientID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentityProviderClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentityProviderClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentityProviderClientID: %w", err)
	}
	return oldValue.IdentityProviderClientID, nil
}

// ClearIdentityProviderClientID clears the value of the "identity_provider_client_id" field.
func (m *OrganizationSettingHistoryMutation) ClearIdentityProviderClientID() {
	m.identity_provider_client_id = nil
	m.clearedFields[organizationsettinghistory.FieldIdentityProviderClientID] = struct{}{}
}

// IdentityProviderClientIDCleared returns if the "identity_provider_client_id" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) IdentityProviderClientIDCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldIdentityProviderClientID]
	return ok
}

// ResetIdentityProviderClientID resets all changes to the "identity_provider_client_id" field.
func (m *OrganizationSettingHistoryMutation) ResetIdentityProviderClientID() {
	m.identity_provider_client_id = nil
	delete(m.clearedFields, organizationsettinghistory.FieldIdentityProviderClientID)
}

// SetIdentityProviderClientSecret sets the "identity_provider_client_secret" field.
func (m *OrganizationSettingHistoryMutation) SetIdentityProviderClientSecret(s string) {
	m.identity_provider_client_secret = &s
}

// IdentityProviderClientSecret returns the value of the "identity_provider_client_secret" field in the mutation.
func (m *OrganizationSettingHistoryMutation) IdentityProviderClientSecret() (r string, exists bool) {
	v := m.identity_provider_client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentityProviderClientSecret returns the old "identity_provider_client_secret" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldIdentityProviderClientSecret(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentityProviderClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentityProviderClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentityProviderClientSecret: %w", err)
	}
	return oldValue.IdentityProviderClientSecret, nil
}

// ClearIdentityProviderClientSecret clears the value of the "identity_provider_client_secret" field.
func (m *OrganizationSettingHistoryMutation) ClearIdentityProviderClientSecret() {
	m.identity_provider_client_secret = nil
	m.clearedFields[organizationsettinghistory.FieldIdentityProviderClientSecret] = struct{}{}
}

// IdentityProviderClientSecretCleared returns if the "identity_provider_client_secret" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) IdentityProviderClientSecretCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldIdentityProviderClientSecret]
	return ok
}

// ResetIdentityProviderClientSecret resets all changes to the "identity_provider_client_secret" field.
func (m *OrganizationSettingHistoryMutation) ResetIdentityProviderClientSecret() {
	m.identity_provider_client_secret = nil
	delete(m.clearedFields, organizationsettinghistory.FieldIdentityProviderClientSecret)
}

// SetIdentityProviderMetadataEndpoint sets the "identity_provider_metadata_endpoint" field.
func (m *OrganizationSettingHistoryMutation) SetIdentityProviderMetadataEndpoint(s string) {
	m.identity_provider_metadata_endpoint = &s
}

// IdentityProviderMetadataEndpoint returns the value of the "identity_provider_metadata_endpoint" field in the mutation.
func (m *OrganizationSettingHistoryMutation) IdentityProviderMetadataEndpoint() (r string, exists bool) {
	v := m.identity_provider_metadata_endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentityProviderMetadataEndpoint returns the old "identity_provider_metadata_endpoint" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldIdentityProviderMetadataEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentityProviderMetadataEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentityProviderMetadataEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentityProviderMetadataEndpoint: %w", err)
	}
	return oldValue.IdentityProviderMetadataEndpoint, nil
}

// ClearIdentityProviderMetadataEndpoint clears the value of the "identity_provider_metadata_endpoint" field.
func (m *OrganizationSettingHistoryMutation) ClearIdentityProviderMetadataEndpoint() {
	m.identity_provider_metadata_endpoint = nil
	m.clearedFields[organizationsettinghistory.FieldIdentityProviderMetadataEndpoint] = struct{}{}
}

// IdentityProviderMetadataEndpointCleared returns if the "identity_provider_metadata_endpoint" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) IdentityProviderMetadataEndpointCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldIdentityProviderMetadataEndpoint]
	return ok
}

// ResetIdentityProviderMetadataEndpoint resets all changes to the "identity_provider_metadata_endpoint" field.
func (m *OrganizationSettingHistoryMutation) ResetIdentityProviderMetadataEndpoint() {
	m.identity_provider_metadata_endpoint = nil
	delete(m.clearedFields, organizationsettinghistory.FieldIdentityProviderMetadataEndpoint)
}

// SetIdentityProviderAuthTested sets the "identity_provider_auth_tested" field.
func (m *OrganizationSettingHistoryMutation) SetIdentityProviderAuthTested(b bool) {
	m.identity_provider_auth_tested = &b
}

// IdentityProviderAuthTested returns the value of the "identity_provider_auth_tested" field in the mutation.
func (m *OrganizationSettingHistoryMutation) IdentityProviderAuthTested() (r bool, exists bool) {
	v := m.identity_provider_auth_tested
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentityProviderAuthTested returns the old "identity_provider_auth_tested" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldIdentityProviderAuthTested(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentityProviderAuthTested is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentityProviderAuthTested requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentityProviderAuthTested: %w", err)
	}
	return oldValue.IdentityProviderAuthTested, nil
}

// ResetIdentityProviderAuthTested resets all changes to the "identity_provider_auth_tested" field.
func (m *OrganizationSettingHistoryMutation) ResetIdentityProviderAuthTested() {
	m.identity_provider_auth_tested = nil
}

// SetIdentityProviderEntityID sets the "identity_provider_entity_id" field.
func (m *OrganizationSettingHistoryMutation) SetIdentityProviderEntityID(s string) {
	m.identity_provider_entity_id = &s
}

// IdentityProviderEntityID returns the value of the "identity_provider_entity_id" field in the mutation.
func (m *OrganizationSettingHistoryMutation) IdentityProviderEntityID() (r string, exists bool) {
	v := m.identity_provider_entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentityProviderEntityID returns the old "identity_provider_entity_id" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldIdentityProviderEntityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentityProviderEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentityProviderEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentityProviderEntityID: %w", err)
	}
	return oldValue.IdentityProviderEntityID, nil
}

// ClearIdentityProviderEntityID clears the value of the "identity_provider_entity_id" field.
func (m *OrganizationSettingHistoryMutation) ClearIdentityProviderEntityID() {
	m.identity_provider_entity_id = nil
	m.clearedFields[organizationsettinghistory.FieldIdentityProviderEntityID] = struct{}{}
}

// IdentityProviderEntityIDCleared returns if the "identity_provider_entity_id" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) IdentityProviderEntityIDCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldIdentityProviderEntityID]
	return ok
}

// ResetIdentityProviderEntityID resets all changes to the "identity_provider_entity_id" field.
func (m *OrganizationSettingHistoryMutation) ResetIdentityProviderEntityID() {
	m.identity_provider_entity_id = nil
	delete(m.clearedFields, organizationsettinghistory.FieldIdentityProviderEntityID)
}

// SetOidcDiscoveryEndpoint sets the "oidc_discovery_endpoint" field.
func (m *OrganizationSettingHistoryMutation) SetOidcDiscoveryEndpoint(s string) {
	m.oidc_discovery_endpoint = &s
}

// OidcDiscoveryEndpoint returns the value of the "oidc_discovery_endpoint" field in the mutation.
func (m *OrganizationSettingHistoryMutation) OidcDiscoveryEndpoint() (r string, exists bool) {
	v := m.oidc_discovery_endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldOidcDiscoveryEndpoint returns the old "oidc_discovery_endpoint" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldOidcDiscoveryEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOidcDiscoveryEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOidcDiscoveryEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOidcDiscoveryEndpoint: %w", err)
	}
	return oldValue.OidcDiscoveryEndpoint, nil
}

// ClearOidcDiscoveryEndpoint clears the value of the "oidc_discovery_endpoint" field.
func (m *OrganizationSettingHistoryMutation) ClearOidcDiscoveryEndpoint() {
	m.oidc_discovery_endpoint = nil
	m.clearedFields[organizationsettinghistory.FieldOidcDiscoveryEndpoint] = struct{}{}
}

// OidcDiscoveryEndpointCleared returns if the "oidc_discovery_endpoint" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) OidcDiscoveryEndpointCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldOidcDiscoveryEndpoint]
	return ok
}

// ResetOidcDiscoveryEndpoint resets all changes to the "oidc_discovery_endpoint" field.
func (m *OrganizationSettingHistoryMutation) ResetOidcDiscoveryEndpoint() {
	m.oidc_discovery_endpoint = nil
	delete(m.clearedFields, organizationsettinghistory.FieldOidcDiscoveryEndpoint)
}

// SetSamlSigninURL sets the "saml_signin_url" field.
func (m *OrganizationSettingHistoryMutation) SetSamlSigninURL(s string) {
	m.saml_signin_url = &s
}

// SamlSigninURL returns the value of the "saml_signin_url" field in the mutation.
func (m *OrganizationSettingHistoryMutation) SamlSigninURL() (r string, exists bool) {
	v := m.saml_signin_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSamlSigninURL returns the old "saml_signin_url" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldSamlSigninURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSamlSigninURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSamlSigninURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSamlSigninURL: %w", err)
	}
	return oldValue.SamlSigninURL, nil
}

// ClearSamlSigninURL clears the value of the "saml_signin_url" field.
func (m *OrganizationSettingHistoryMutation) ClearSamlSigninURL() {
	m.saml_signin_url = nil
	m.clearedFields[organizationsettinghistory.FieldSamlSigninURL] = struct{}{}
}

// SamlSigninURLCleared returns if the "saml_signin_url" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) SamlSigninURLCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldSamlSigninURL]
	return ok
}

// ResetSamlSigninURL resets all changes to the "saml_signin_url" field.
func (m *OrganizationSettingHistoryMutation) ResetSamlSigninURL() {
	m.saml_signin_url = nil
	delete(m.clearedFields, organizationsettinghistory.FieldSamlSigninURL)
}

// SetSamlIssuer sets the "saml_issuer" field.
func (m *OrganizationSettingHistoryMutation) SetSamlIssuer(s string) {
	m.saml_issuer = &s
}

// SamlIssuer returns the value of the "saml_issuer" field in the mutation.
func (m *OrganizationSettingHistoryMutation) SamlIssuer() (r string, exists bool) {
	v := m.saml_issuer
	if v == nil {
		return
	}
	return *v, true
}

// OldSamlIssuer returns the old "saml_issuer" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldSamlIssuer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSamlIssuer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSamlIssuer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSamlIssuer: %w", err)
	}
	return oldValue.SamlIssuer, nil
}

// ClearSamlIssuer clears the value of the "saml_issuer" field.
func (m *OrganizationSettingHistoryMutation) ClearSamlIssuer() {
	m.saml_issuer = nil
	m.clearedFields[organizationsettinghistory.FieldSamlIssuer] = struct{}{}
}

// SamlIssuerCleared returns if the "saml_issuer" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) SamlIssuerCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldSamlIssuer]
	return ok
}

// ResetSamlIssuer resets all changes to the "saml_issuer" field.
func (m *OrganizationSettingHistoryMutation) ResetSamlIssuer() {
	m.saml_issuer = nil
	delete(m.clearedFields, organizationsettinghistory.FieldSamlIssuer)
}

// SetSamlCert sets the "saml_cert" field.
func (m *OrganizationSettingHistoryMutation) SetSamlCert(s string) {
	m.saml_cert = &s
}

// SamlCert returns the value of the "saml_cert" field in the mutation.
func (m *OrganizationSettingHistoryMutation) SamlCert() (r string, exists bool) {
	v := m.saml_cert
	if v == nil {
		return
	}
	return *v, true
}

// OldSamlCert returns the old "saml_cert" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldSamlCert(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSamlCert is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSamlCert requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSamlCert: %w", err)
	}
	return oldValue.SamlCert, nil
}

// ClearSamlCert clears the value of the "saml_cert" field.
func (m *OrganizationSettingHistoryMutation) ClearSamlCert() {
	m.saml_cert = nil
	m.clearedFields[organizationsettinghistory.FieldSamlCert] = struct{}{}
}

// SamlCertCleared returns if the "saml_cert" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) SamlCertCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldSamlCert]
	return ok
}

// ResetSamlCert resets all changes to the "saml_cert" field.
func (m *OrganizationSettingHistoryMutation) ResetSamlCert() {
	m.saml_cert = nil
	delete(m.clearedFields, organizationsettinghistory.FieldSamlCert)
}

// SetIdentityProviderLoginEnforced sets the "identity_provider_login_enforced" field.
func (m *OrganizationSettingHistoryMutation) SetIdentityProviderLoginEnforced(b bool) {
	m.identity_provider_login_enforced = &b
}

// IdentityProviderLoginEnforced returns the value of the "identity_provider_login_enforced" field in the mutation.
func (m *OrganizationSettingHistoryMutation) IdentityProviderLoginEnforced() (r bool, exists bool) {
	v := m.identity_provider_login_enforced
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentityProviderLoginEnforced returns the old "identity_provider_login_enforced" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldIdentityProviderLoginEnforced(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentityProviderLoginEnforced is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentityProviderLoginEnforced requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentityProviderLoginEnforced: %w", err)
	}
	return oldValue.IdentityProviderLoginEnforced, nil
}

// ResetIdentityProviderLoginEnforced resets all changes to the "identity_provider_login_enforced" field.
func (m *OrganizationSettingHistoryMutation) ResetIdentityProviderLoginEnforced() {
	m.identity_provider_login_enforced = nil
}

// SetMultifactorAuthEnforced sets the "multifactor_auth_enforced" field.
func (m *OrganizationSettingHistoryMutation) SetMultifactorAuthEnforced(b bool) {
	m.multifactor_auth_enforced = &b
}

// MultifactorAuthEnforced returns the value of the "multifactor_auth_enforced" field in the mutation.
func (m *OrganizationSettingHistoryMutation) MultifactorAuthEnforced() (r bool, exists bool) {
	v := m.multifactor_auth_enforced
	if v == nil {
		return
	}
	return *v, true
}

// OldMultifactorAuthEnforced returns the old "multifactor_auth_enforced" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldMultifactorAuthEnforced(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMultifactorAuthEnforced is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMultifactorAuthEnforced requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMultifactorAuthEnforced: %w", err)
	}
	return oldValue.MultifactorAuthEnforced, nil
}

// ClearMultifactorAuthEnforced clears the value of the "multifactor_auth_enforced" field.
func (m *OrganizationSettingHistoryMutation) ClearMultifactorAuthEnforced() {
	m.multifactor_auth_enforced = nil
	m.clearedFields[organizationsettinghistory.FieldMultifactorAuthEnforced] = struct{}{}
}

// MultifactorAuthEnforcedCleared returns if the "multifactor_auth_enforced" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) MultifactorAuthEnforcedCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldMultifactorAuthEnforced]
	return ok
}

// ResetMultifactorAuthEnforced resets all changes to the "multifactor_auth_enforced" field.
func (m *OrganizationSettingHistoryMutation) ResetMultifactorAuthEnforced() {
	m.multifactor_auth_enforced = nil
	delete(m.clearedFields, organizationsettinghistory.FieldMultifactorAuthEnforced)
}

// SetComplianceWebhookToken sets the "compliance_webhook_token" field.
func (m *OrganizationSettingHistoryMutation) SetComplianceWebhookToken(s string) {
	m.compliance_webhook_token = &s
}

// ComplianceWebhookToken returns the value of the "compliance_webhook_token" field in the mutation.
func (m *OrganizationSettingHistoryMutation) ComplianceWebhookToken() (r string, exists bool) {
	v := m.compliance_webhook_token
	if v == nil {
		return
	}
	return *v, true
}

// OldComplianceWebhookToken returns the old "compliance_webhook_token" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldComplianceWebhookToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComplianceWebhookToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComplianceWebhookToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComplianceWebhookToken: %w", err)
	}
	return oldValue.ComplianceWebhookToken, nil
}

// ClearComplianceWebhookToken clears the value of the "compliance_webhook_token" field.
func (m *OrganizationSettingHistoryMutation) ClearComplianceWebhookToken() {
	m.compliance_webhook_token = nil
	m.clearedFields[organizationsettinghistory.FieldComplianceWebhookToken] = struct{}{}
}

// ComplianceWebhookTokenCleared returns if the "compliance_webhook_token" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) ComplianceWebhookTokenCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldComplianceWebhookToken]
	return ok
}

// ResetComplianceWebhookToken resets all changes to the "compliance_webhook_token" field.
func (m *OrganizationSettingHistoryMutation) ResetComplianceWebhookToken() {
	m.compliance_webhook_token = nil
	delete(m.clearedFields, organizationsettinghistory.FieldComplianceWebhookToken)
}

// SetPaymentMethodAdded sets the "payment_method_added" field.
func (m *OrganizationSettingHistoryMutation) SetPaymentMethodAdded(b bool) {
	m.payment_method_added = &b
}

// PaymentMethodAdded returns the value of the "payment_method_added" field in the mutation.
func (m *OrganizationSettingHistoryMutation) PaymentMethodAdded() (r bool, exists bool) {
	v := m.payment_method_added
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethodAdded returns the old "payment_method_added" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldPaymentMethodAdded(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethodAdded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethodAdded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethodAdded: %w", err)
	}
	return oldValue.PaymentMethodAdded, nil
}

// ResetPaymentMethodAdded resets all changes to the "payment_method_added" field.
func (m *OrganizationSettingHistoryMutation) ResetPaymentMethodAdded() {
	m.payment_method_added = nil
}

// Where appends a list predicates to the OrganizationSettingHistoryMutation builder.
func (m *OrganizationSettingHistoryMutation) Where(ps ...predicate.OrganizationSettingHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationSettingHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationSettingHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationSettingHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationSettingHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationSettingHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationSettingHistory).
func (m *OrganizationSettingHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationSettingHistoryMutation) Fields() []string {
	fields := make([]string, 0, 35)
	if m.history_time != nil {
		fields = append(fields, organizationsettinghistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, organizationsettinghistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, organizationsettinghistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, organizationsettinghistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationsettinghistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, organizationsettinghistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, organizationsettinghistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, organizationsettinghistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, organizationsettinghistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, organizationsettinghistory.FieldTags)
	}
	if m.domains != nil {
		fields = append(fields, organizationsettinghistory.FieldDomains)
	}
	if m.billing_contact != nil {
		fields = append(fields, organizationsettinghistory.FieldBillingContact)
	}
	if m.billing_email != nil {
		fields = append(fields, organizationsettinghistory.FieldBillingEmail)
	}
	if m.billing_phone != nil {
		fields = append(fields, organizationsettinghistory.FieldBillingPhone)
	}
	if m.billing_address != nil {
		fields = append(fields, organizationsettinghistory.FieldBillingAddress)
	}
	if m.tax_identifier != nil {
		fields = append(fields, organizationsettinghistory.FieldTaxIdentifier)
	}
	if m.geo_location != nil {
		fields = append(fields, organizationsettinghistory.FieldGeoLocation)
	}
	if m.organization_id != nil {
		fields = append(fields, organizationsettinghistory.FieldOrganizationID)
	}
	if m.billing_notifications_enabled != nil {
		fields = append(fields, organizationsettinghistory.FieldBillingNotificationsEnabled)
	}
	if m.allowed_email_domains != nil {
		fields = append(fields, organizationsettinghistory.FieldAllowedEmailDomains)
	}
	if m.allow_matching_domains_autojoin != nil {
		fields = append(fields, organizationsettinghistory.FieldAllowMatchingDomainsAutojoin)
	}
	if m.identity_provider != nil {
		fields = append(fields, organizationsettinghistory.FieldIdentityProvider)
	}
	if m.identity_provider_client_id != nil {
		fields = append(fields, organizationsettinghistory.FieldIdentityProviderClientID)
	}
	if m.identity_provider_client_secret != nil {
		fields = append(fields, organizationsettinghistory.FieldIdentityProviderClientSecret)
	}
	if m.identity_provider_metadata_endpoint != nil {
		fields = append(fields, organizationsettinghistory.FieldIdentityProviderMetadataEndpoint)
	}
	if m.identity_provider_auth_tested != nil {
		fields = append(fields, organizationsettinghistory.FieldIdentityProviderAuthTested)
	}
	if m.identity_provider_entity_id != nil {
		fields = append(fields, organizationsettinghistory.FieldIdentityProviderEntityID)
	}
	if m.oidc_discovery_endpoint != nil {
		fields = append(fields, organizationsettinghistory.FieldOidcDiscoveryEndpoint)
	}
	if m.saml_signin_url != nil {
		fields = append(fields, organizationsettinghistory.FieldSamlSigninURL)
	}
	if m.saml_issuer != nil {
		fields = append(fields, organizationsettinghistory.FieldSamlIssuer)
	}
	if m.saml_cert != nil {
		fields = append(fields, organizationsettinghistory.FieldSamlCert)
	}
	if m.identity_provider_login_enforced != nil {
		fields = append(fields, organizationsettinghistory.FieldIdentityProviderLoginEnforced)
	}
	if m.multifactor_auth_enforced != nil {
		fields = append(fields, organizationsettinghistory.FieldMultifactorAuthEnforced)
	}
	if m.compliance_webhook_token != nil {
		fields = append(fields, organizationsettinghistory.FieldComplianceWebhookToken)
	}
	if m.payment_method_added != nil {
		fields = append(fields, organizationsettinghistory.FieldPaymentMethodAdded)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationSettingHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationsettinghistory.FieldHistoryTime:
		return m.HistoryTime()
	case organizationsettinghistory.FieldRef:
		return m.Ref()
	case organizationsettinghistory.FieldOperation:
		return m.Operation()
	case organizationsettinghistory.FieldCreatedAt:
		return m.CreatedAt()
	case organizationsettinghistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationsettinghistory.FieldCreatedBy:
		return m.CreatedBy()
	case organizationsettinghistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case organizationsettinghistory.FieldDeletedAt:
		return m.DeletedAt()
	case organizationsettinghistory.FieldDeletedBy:
		return m.DeletedBy()
	case organizationsettinghistory.FieldTags:
		return m.Tags()
	case organizationsettinghistory.FieldDomains:
		return m.Domains()
	case organizationsettinghistory.FieldBillingContact:
		return m.BillingContact()
	case organizationsettinghistory.FieldBillingEmail:
		return m.BillingEmail()
	case organizationsettinghistory.FieldBillingPhone:
		return m.BillingPhone()
	case organizationsettinghistory.FieldBillingAddress:
		return m.BillingAddress()
	case organizationsettinghistory.FieldTaxIdentifier:
		return m.TaxIdentifier()
	case organizationsettinghistory.FieldGeoLocation:
		return m.GeoLocation()
	case organizationsettinghistory.FieldOrganizationID:
		return m.OrganizationID()
	case organizationsettinghistory.FieldBillingNotificationsEnabled:
		return m.BillingNotificationsEnabled()
	case organizationsettinghistory.FieldAllowedEmailDomains:
		return m.AllowedEmailDomains()
	case organizationsettinghistory.FieldAllowMatchingDomainsAutojoin:
		return m.AllowMatchingDomainsAutojoin()
	case organizationsettinghistory.FieldIdentityProvider:
		return m.IdentityProvider()
	case organizationsettinghistory.FieldIdentityProviderClientID:
		return m.IdentityProviderClientID()
	case organizationsettinghistory.FieldIdentityProviderClientSecret:
		return m.IdentityProviderClientSecret()
	case organizationsettinghistory.FieldIdentityProviderMetadataEndpoint:
		return m.IdentityProviderMetadataEndpoint()
	case organizationsettinghistory.FieldIdentityProviderAuthTested:
		return m.IdentityProviderAuthTested()
	case organizationsettinghistory.FieldIdentityProviderEntityID:
		return m.IdentityProviderEntityID()
	case organizationsettinghistory.FieldOidcDiscoveryEndpoint:
		return m.OidcDiscoveryEndpoint()
	case organizationsettinghistory.FieldSamlSigninURL:
		return m.SamlSigninURL()
	case organizationsettinghistory.FieldSamlIssuer:
		return m.SamlIssuer()
	case organizationsettinghistory.FieldSamlCert:
		return m.SamlCert()
	case organizationsettinghistory.FieldIdentityProviderLoginEnforced:
		return m.IdentityProviderLoginEnforced()
	case organizationsettinghistory.FieldMultifactorAuthEnforced:
		return m.MultifactorAuthEnforced()
	case organizationsettinghistory.FieldComplianceWebhookToken:
		return m.ComplianceWebhookToken()
	case organizationsettinghistory.FieldPaymentMethodAdded:
		return m.PaymentMethodAdded()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationSettingHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationsettinghistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case organizationsettinghistory.FieldRef:
		return m.OldRef(ctx)
	case organizationsettinghistory.FieldOperation:
		return m.OldOperation(ctx)
	case organizationsettinghistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationsettinghistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationsettinghistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organizationsettinghistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organizationsettinghistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organizationsettinghistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case organizationsettinghistory.FieldTags:
		return m.OldTags(ctx)
	case organizationsettinghistory.FieldDomains:
		return m.OldDomains(ctx)
	case organizationsettinghistory.FieldBillingContact:
		return m.OldBillingContact(ctx)
	case organizationsettinghistory.FieldBillingEmail:
		return m.OldBillingEmail(ctx)
	case organizationsettinghistory.FieldBillingPhone:
		return m.OldBillingPhone(ctx)
	case organizationsettinghistory.FieldBillingAddress:
		return m.OldBillingAddress(ctx)
	case organizationsettinghistory.FieldTaxIdentifier:
		return m.OldTaxIdentifier(ctx)
	case organizationsettinghistory.FieldGeoLocation:
		return m.OldGeoLocation(ctx)
	case organizationsettinghistory.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case organizationsettinghistory.FieldBillingNotificationsEnabled:
		return m.OldBillingNotificationsEnabled(ctx)
	case organizationsettinghistory.FieldAllowedEmailDomains:
		return m.OldAllowedEmailDomains(ctx)
	case organizationsettinghistory.FieldAllowMatchingDomainsAutojoin:
		return m.OldAllowMatchingDomainsAutojoin(ctx)
	case organizationsettinghistory.FieldIdentityProvider:
		return m.OldIdentityProvider(ctx)
	case organizationsettinghistory.FieldIdentityProviderClientID:
		return m.OldIdentityProviderClientID(ctx)
	case organizationsettinghistory.FieldIdentityProviderClientSecret:
		return m.OldIdentityProviderClientSecret(ctx)
	case organizationsettinghistory.FieldIdentityProviderMetadataEndpoint:
		return m.OldIdentityProviderMetadataEndpoint(ctx)
	case organizationsettinghistory.FieldIdentityProviderAuthTested:
		return m.OldIdentityProviderAuthTested(ctx)
	case organizationsettinghistory.FieldIdentityProviderEntityID:
		return m.OldIdentityProviderEntityID(ctx)
	case organizationsettinghistory.FieldOidcDiscoveryEndpoint:
		return m.OldOidcDiscoveryEndpoint(ctx)
	case organizationsettinghistory.FieldSamlSigninURL:
		return m.OldSamlSigninURL(ctx)
	case organizationsettinghistory.FieldSamlIssuer:
		return m.OldSamlIssuer(ctx)
	case organizationsettinghistory.FieldSamlCert:
		return m.OldSamlCert(ctx)
	case organizationsettinghistory.FieldIdentityProviderLoginEnforced:
		return m.OldIdentityProviderLoginEnforced(ctx)
	case organizationsettinghistory.FieldMultifactorAuthEnforced:
		return m.OldMultifactorAuthEnforced(ctx)
	case organizationsettinghistory.FieldComplianceWebhookToken:
		return m.OldComplianceWebhookToken(ctx)
	case organizationsettinghistory.FieldPaymentMethodAdded:
		return m.OldPaymentMethodAdded(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationSettingHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationSettingHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationsettinghistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case organizationsettinghistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case organizationsettinghistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case organizationsettinghistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationsettinghistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationsettinghistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organizationsettinghistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organizationsettinghistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organizationsettinghistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case organizationsettinghistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case organizationsettinghistory.FieldDomains:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomains(v)
		return nil
	case organizationsettinghistory.FieldBillingContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingContact(v)
		return nil
	case organizationsettinghistory.FieldBillingEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingEmail(v)
		return nil
	case organizationsettinghistory.FieldBillingPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingPhone(v)
		return nil
	case organizationsettinghistory.FieldBillingAddress:
		v, ok := value.(models.Address)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddress(v)
		return nil
	case organizationsettinghistory.FieldTaxIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxIdentifier(v)
		return nil
	case organizationsettinghistory.FieldGeoLocation:
		v, ok := value.(enums.Region)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoLocation(v)
		return nil
	case organizationsettinghistory.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case organizationsettinghistory.FieldBillingNotificationsEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingNotificationsEnabled(v)
		return nil
	case organizationsettinghistory.FieldAllowedEmailDomains:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedEmailDomains(v)
		return nil
	case organizationsettinghistory.FieldAllowMatchingDomainsAutojoin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowMatchingDomainsAutojoin(v)
		return nil
	case organizationsettinghistory.FieldIdentityProvider:
		v, ok := value.(enums.SSOProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentityProvider(v)
		return nil
	case organizationsettinghistory.FieldIdentityProviderClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentityProviderClientID(v)
		return nil
	case organizationsettinghistory.FieldIdentityProviderClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentityProviderClientSecret(v)
		return nil
	case organizationsettinghistory.FieldIdentityProviderMetadataEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentityProviderMetadataEndpoint(v)
		return nil
	case organizationsettinghistory.FieldIdentityProviderAuthTested:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentityProviderAuthTested(v)
		return nil
	case organizationsettinghistory.FieldIdentityProviderEntityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentityProviderEntityID(v)
		return nil
	case organizationsettinghistory.FieldOidcDiscoveryEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOidcDiscoveryEndpoint(v)
		return nil
	case organizationsettinghistory.FieldSamlSigninURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSamlSigninURL(v)
		return nil
	case organizationsettinghistory.FieldSamlIssuer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSamlIssuer(v)
		return nil
	case organizationsettinghistory.FieldSamlCert:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSamlCert(v)
		return nil
	case organizationsettinghistory.FieldIdentityProviderLoginEnforced:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentityProviderLoginEnforced(v)
		return nil
	case organizationsettinghistory.FieldMultifactorAuthEnforced:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMultifactorAuthEnforced(v)
		return nil
	case organizationsettinghistory.FieldComplianceWebhookToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComplianceWebhookToken(v)
		return nil
	case organizationsettinghistory.FieldPaymentMethodAdded:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethodAdded(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationSettingHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationSettingHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationSettingHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationSettingHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationSettingHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationSettingHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationsettinghistory.FieldRef) {
		fields = append(fields, organizationsettinghistory.FieldRef)
	}
	if m.FieldCleared(organizationsettinghistory.FieldCreatedAt) {
		fields = append(fields, organizationsettinghistory.FieldCreatedAt)
	}
	if m.FieldCleared(organizationsettinghistory.FieldUpdatedAt) {
		fields = append(fields, organizationsettinghistory.FieldUpdatedAt)
	}
	if m.FieldCleared(organizationsettinghistory.FieldCreatedBy) {
		fields = append(fields, organizationsettinghistory.FieldCreatedBy)
	}
	if m.FieldCleared(organizationsettinghistory.FieldUpdatedBy) {
		fields = append(fields, organizationsettinghistory.FieldUpdatedBy)
	}
	if m.FieldCleared(organizationsettinghistory.FieldDeletedAt) {
		fields = append(fields, organizationsettinghistory.FieldDeletedAt)
	}
	if m.FieldCleared(organizationsettinghistory.FieldDeletedBy) {
		fields = append(fields, organizationsettinghistory.FieldDeletedBy)
	}
	if m.FieldCleared(organizationsettinghistory.FieldTags) {
		fields = append(fields, organizationsettinghistory.FieldTags)
	}
	if m.FieldCleared(organizationsettinghistory.FieldDomains) {
		fields = append(fields, organizationsettinghistory.FieldDomains)
	}
	if m.FieldCleared(organizationsettinghistory.FieldBillingContact) {
		fields = append(fields, organizationsettinghistory.FieldBillingContact)
	}
	if m.FieldCleared(organizationsettinghistory.FieldBillingEmail) {
		fields = append(fields, organizationsettinghistory.FieldBillingEmail)
	}
	if m.FieldCleared(organizationsettinghistory.FieldBillingPhone) {
		fields = append(fields, organizationsettinghistory.FieldBillingPhone)
	}
	if m.FieldCleared(organizationsettinghistory.FieldBillingAddress) {
		fields = append(fields, organizationsettinghistory.FieldBillingAddress)
	}
	if m.FieldCleared(organizationsettinghistory.FieldTaxIdentifier) {
		fields = append(fields, organizationsettinghistory.FieldTaxIdentifier)
	}
	if m.FieldCleared(organizationsettinghistory.FieldGeoLocation) {
		fields = append(fields, organizationsettinghistory.FieldGeoLocation)
	}
	if m.FieldCleared(organizationsettinghistory.FieldOrganizationID) {
		fields = append(fields, organizationsettinghistory.FieldOrganizationID)
	}
	if m.FieldCleared(organizationsettinghistory.FieldAllowedEmailDomains) {
		fields = append(fields, organizationsettinghistory.FieldAllowedEmailDomains)
	}
	if m.FieldCleared(organizationsettinghistory.FieldAllowMatchingDomainsAutojoin) {
		fields = append(fields, organizationsettinghistory.FieldAllowMatchingDomainsAutojoin)
	}
	if m.FieldCleared(organizationsettinghistory.FieldIdentityProvider) {
		fields = append(fields, organizationsettinghistory.FieldIdentityProvider)
	}
	if m.FieldCleared(organizationsettinghistory.FieldIdentityProviderClientID) {
		fields = append(fields, organizationsettinghistory.FieldIdentityProviderClientID)
	}
	if m.FieldCleared(organizationsettinghistory.FieldIdentityProviderClientSecret) {
		fields = append(fields, organizationsettinghistory.FieldIdentityProviderClientSecret)
	}
	if m.FieldCleared(organizationsettinghistory.FieldIdentityProviderMetadataEndpoint) {
		fields = append(fields, organizationsettinghistory.FieldIdentityProviderMetadataEndpoint)
	}
	if m.FieldCleared(organizationsettinghistory.FieldIdentityProviderEntityID) {
		fields = append(fields, organizationsettinghistory.FieldIdentityProviderEntityID)
	}
	if m.FieldCleared(organizationsettinghistory.FieldOidcDiscoveryEndpoint) {
		fields = append(fields, organizationsettinghistory.FieldOidcDiscoveryEndpoint)
	}
	if m.FieldCleared(organizationsettinghistory.FieldSamlSigninURL) {
		fields = append(fields, organizationsettinghistory.FieldSamlSigninURL)
	}
	if m.FieldCleared(organizationsettinghistory.FieldSamlIssuer) {
		fields = append(fields, organizationsettinghistory.FieldSamlIssuer)
	}
	if m.FieldCleared(organizationsettinghistory.FieldSamlCert) {
		fields = append(fields, organizationsettinghistory.FieldSamlCert)
	}
	if m.FieldCleared(organizationsettinghistory.FieldMultifactorAuthEnforced) {
		fields = append(fields, organizationsettinghistory.FieldMultifactorAuthEnforced)
	}
	if m.FieldCleared(organizationsettinghistory.FieldComplianceWebhookToken) {
		fields = append(fields, organizationsettinghistory.FieldComplianceWebhookToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationSettingHistoryMutation) ClearField(name string) error {
	switch name {
	case organizationsettinghistory.FieldRef:
		m.ClearRef()
		return nil
	case organizationsettinghistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case organizationsettinghistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case organizationsettinghistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case organizationsettinghistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organizationsettinghistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case organizationsettinghistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case organizationsettinghistory.FieldTags:
		m.ClearTags()
		return nil
	case organizationsettinghistory.FieldDomains:
		m.ClearDomains()
		return nil
	case organizationsettinghistory.FieldBillingContact:
		m.ClearBillingContact()
		return nil
	case organizationsettinghistory.FieldBillingEmail:
		m.ClearBillingEmail()
		return nil
	case organizationsettinghistory.FieldBillingPhone:
		m.ClearBillingPhone()
		return nil
	case organizationsettinghistory.FieldBillingAddress:
		m.ClearBillingAddress()
		return nil
	case organizationsettinghistory.FieldTaxIdentifier:
		m.ClearTaxIdentifier()
		return nil
	case organizationsettinghistory.FieldGeoLocation:
		m.ClearGeoLocation()
		return nil
	case organizationsettinghistory.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case organizationsettinghistory.FieldAllowedEmailDomains:
		m.ClearAllowedEmailDomains()
		return nil
	case organizationsettinghistory.FieldAllowMatchingDomainsAutojoin:
		m.ClearAllowMatchingDomainsAutojoin()
		return nil
	case organizationsettinghistory.FieldIdentityProvider:
		m.ClearIdentityProvider()
		return nil
	case organizationsettinghistory.FieldIdentityProviderClientID:
		m.ClearIdentityProviderClientID()
		return nil
	case organizationsettinghistory.FieldIdentityProviderClientSecret:
		m.ClearIdentityProviderClientSecret()
		return nil
	case organizationsettinghistory.FieldIdentityProviderMetadataEndpoint:
		m.ClearIdentityProviderMetadataEndpoint()
		return nil
	case organizationsettinghistory.FieldIdentityProviderEntityID:
		m.ClearIdentityProviderEntityID()
		return nil
	case organizationsettinghistory.FieldOidcDiscoveryEndpoint:
		m.ClearOidcDiscoveryEndpoint()
		return nil
	case organizationsettinghistory.FieldSamlSigninURL:
		m.ClearSamlSigninURL()
		return nil
	case organizationsettinghistory.FieldSamlIssuer:
		m.ClearSamlIssuer()
		return nil
	case organizationsettinghistory.FieldSamlCert:
		m.ClearSamlCert()
		return nil
	case organizationsettinghistory.FieldMultifactorAuthEnforced:
		m.ClearMultifactorAuthEnforced()
		return nil
	case organizationsettinghistory.FieldComplianceWebhookToken:
		m.ClearComplianceWebhookToken()
		return nil
	}
	return fmt.Errorf("unknown OrganizationSettingHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationSettingHistoryMutation) ResetField(name string) error {
	switch name {
	case organizationsettinghistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case organizationsettinghistory.FieldRef:
		m.ResetRef()
		return nil
	case organizationsettinghistory.FieldOperation:
		m.ResetOperation()
		return nil
	case organizationsettinghistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationsettinghistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationsettinghistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organizationsettinghistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organizationsettinghistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organizationsettinghistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case organizationsettinghistory.FieldTags:
		m.ResetTags()
		return nil
	case organizationsettinghistory.FieldDomains:
		m.ResetDomains()
		return nil
	case organizationsettinghistory.FieldBillingContact:
		m.ResetBillingContact()
		return nil
	case organizationsettinghistory.FieldBillingEmail:
		m.ResetBillingEmail()
		return nil
	case organizationsettinghistory.FieldBillingPhone:
		m.ResetBillingPhone()
		return nil
	case organizationsettinghistory.FieldBillingAddress:
		m.ResetBillingAddress()
		return nil
	case organizationsettinghistory.FieldTaxIdentifier:
		m.ResetTaxIdentifier()
		return nil
	case organizationsettinghistory.FieldGeoLocation:
		m.ResetGeoLocation()
		return nil
	case organizationsettinghistory.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case organizationsettinghistory.FieldBillingNotificationsEnabled:
		m.ResetBillingNotificationsEnabled()
		return nil
	case organizationsettinghistory.FieldAllowedEmailDomains:
		m.ResetAllowedEmailDomains()
		return nil
	case organizationsettinghistory.FieldAllowMatchingDomainsAutojoin:
		m.ResetAllowMatchingDomainsAutojoin()
		return nil
	case organizationsettinghistory.FieldIdentityProvider:
		m.ResetIdentityProvider()
		return nil
	case organizationsettinghistory.FieldIdentityProviderClientID:
		m.ResetIdentityProviderClientID()
		return nil
	case organizationsettinghistory.FieldIdentityProviderClientSecret:
		m.ResetIdentityProviderClientSecret()
		return nil
	case organizationsettinghistory.FieldIdentityProviderMetadataEndpoint:
		m.ResetIdentityProviderMetadataEndpoint()
		return nil
	case organizationsettinghistory.FieldIdentityProviderAuthTested:
		m.ResetIdentityProviderAuthTested()
		return nil
	case organizationsettinghistory.FieldIdentityProviderEntityID:
		m.ResetIdentityProviderEntityID()
		return nil
	case organizationsettinghistory.FieldOidcDiscoveryEndpoint:
		m.ResetOidcDiscoveryEndpoint()
		return nil
	case organizationsettinghistory.FieldSamlSigninURL:
		m.ResetSamlSigninURL()
		return nil
	case organizationsettinghistory.FieldSamlIssuer:
		m.ResetSamlIssuer()
		return nil
	case organizationsettinghistory.FieldSamlCert:
		m.ResetSamlCert()
		return nil
	case organizationsettinghistory.FieldIdentityProviderLoginEnforced:
		m.ResetIdentityProviderLoginEnforced()
		return nil
	case organizationsettinghistory.FieldMultifactorAuthEnforced:
		m.ResetMultifactorAuthEnforced()
		return nil
	case organizationsettinghistory.FieldComplianceWebhookToken:
		m.ResetComplianceWebhookToken()
		return nil
	case organizationsettinghistory.FieldPaymentMethodAdded:
		m.ResetPaymentMethodAdded()
		return nil
	}
	return fmt.Errorf("unknown OrganizationSettingHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationSettingHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationSettingHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationSettingHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationSettingHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationSettingHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrganizationSettingHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationSettingHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrganizationSettingHistory edge %s", name)
}

// ProcedureHistoryMutation represents an operation that mutates the ProcedureHistory nodes in the graph.
type ProcedureHistoryMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *string
	history_time                            *time.Time
	ref                                     *string
	operation                               *history.OpType
	created_at                              *time.Time
	updated_at                              *time.Time
	created_by                              *string
	updated_by                              *string
	deleted_at                              *time.Time
	deleted_by                              *string
	display_id                              *string
	tags                                    *[]string
	appendtags                              []string
	revision                                *string
	owner_id                                *string
	name                                    *string
	status                                  *enums.DocumentStatus
	procedure_type                          *string
	details                                 *string
	approval_required                       *bool
	review_due                              *time.Time
	review_frequency                        *enums.Frequency
	approver_id                             *string
	delegate_id                             *string
	summary                                 *string
	tag_suggestions                         *[]string
	appendtag_suggestions                   []string
	dismissed_tag_suggestions               *[]string
	appenddismissed_tag_suggestions         []string
	control_suggestions                     *[]string
	appendcontrol_suggestions               []string
	dismissed_control_suggestions           *[]string
	appenddismissed_control_suggestions     []string
	improvement_suggestions                 *[]string
	appendimprovement_suggestions           []string
	dismissed_improvement_suggestions       *[]string
	appenddismissed_improvement_suggestions []string
	url                                     *string
	file_id                                 *string
	system_owned                            *bool
	internal_notes                          *string
	system_internal_id                      *string
	procedure_kind_name                     *string
	procedure_kind_id                       *string
	clearedFields                           map[string]struct{}
	done                                    bool
	oldValue                                func(context.Context) (*ProcedureHistory, error)
	predicates                              []predicate.ProcedureHistory
}

var _ ent.Mutation = (*ProcedureHistoryMutation)(nil)

// procedurehistoryOption allows management of the mutation configuration using functional options.
type procedurehistoryOption func(*ProcedureHistoryMutation)

// newProcedureHistoryMutation creates new mutation for the ProcedureHistory entity.
func newProcedureHistoryMutation(c config, op Op, opts ...procedurehistoryOption) *ProcedureHistoryMutation {
	m := &ProcedureHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProcedureHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcedureHistoryID sets the ID field of the mutation.
func withProcedureHistoryID(id string) procedurehistoryOption {
	return func(m *ProcedureHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcedureHistory
		)
		m.oldValue = func(ctx context.Context) (*ProcedureHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcedureHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcedureHistory sets the old ProcedureHistory of the mutation.
func withProcedureHistory(node *ProcedureHistory) procedurehistoryOption {
	return func(m *ProcedureHistoryMutation) {
		m.oldValue = func(context.Context) (*ProcedureHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcedureHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcedureHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProcedureHistory entities.
func (m *ProcedureHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcedureHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcedureHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcedureHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ProcedureHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ProcedureHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ProcedureHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ProcedureHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ProcedureHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ProcedureHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[procedurehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ProcedureHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, procedurehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ProcedureHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ProcedureHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ProcedureHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcedureHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcedureHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProcedureHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[procedurehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcedureHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, procedurehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcedureHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcedureHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProcedureHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[procedurehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcedureHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, procedurehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ProcedureHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProcedureHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProcedureHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[procedurehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProcedureHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, procedurehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProcedureHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProcedureHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProcedureHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[procedurehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProcedureHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, procedurehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProcedureHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProcedureHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProcedureHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[procedurehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProcedureHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, procedurehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ProcedureHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ProcedureHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ProcedureHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[procedurehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ProcedureHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, procedurehistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *ProcedureHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *ProcedureHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *ProcedureHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *ProcedureHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ProcedureHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ProcedureHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ProcedureHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ProcedureHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[procedurehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ProcedureHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, procedurehistory.FieldTags)
}

// SetRevision sets the "revision" field.
func (m *ProcedureHistoryMutation) SetRevision(s string) {
	m.revision = &s
}

// Revision returns the value of the "revision" field in the mutation.
func (m *ProcedureHistoryMutation) Revision() (r string, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldRevision(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// ClearRevision clears the value of the "revision" field.
func (m *ProcedureHistoryMutation) ClearRevision() {
	m.revision = nil
	m.clearedFields[procedurehistory.FieldRevision] = struct{}{}
}

// RevisionCleared returns if the "revision" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) RevisionCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldRevision]
	return ok
}

// ResetRevision resets all changes to the "revision" field.
func (m *ProcedureHistoryMutation) ResetRevision() {
	m.revision = nil
	delete(m.clearedFields, procedurehistory.FieldRevision)
}

// SetOwnerID sets the "owner_id" field.
func (m *ProcedureHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ProcedureHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *ProcedureHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[procedurehistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ProcedureHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, procedurehistory.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *ProcedureHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProcedureHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProcedureHistoryMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *ProcedureHistoryMutation) SetStatus(es enums.DocumentStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *ProcedureHistoryMutation) Status() (r enums.DocumentStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldStatus(ctx context.Context) (v enums.DocumentStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ProcedureHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[procedurehistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ProcedureHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, procedurehistory.FieldStatus)
}

// SetProcedureType sets the "procedure_type" field.
func (m *ProcedureHistoryMutation) SetProcedureType(s string) {
	m.procedure_type = &s
}

// ProcedureType returns the value of the "procedure_type" field in the mutation.
func (m *ProcedureHistoryMutation) ProcedureType() (r string, exists bool) {
	v := m.procedure_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProcedureType returns the old "procedure_type" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldProcedureType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcedureType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcedureType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcedureType: %w", err)
	}
	return oldValue.ProcedureType, nil
}

// ClearProcedureType clears the value of the "procedure_type" field.
func (m *ProcedureHistoryMutation) ClearProcedureType() {
	m.procedure_type = nil
	m.clearedFields[procedurehistory.FieldProcedureType] = struct{}{}
}

// ProcedureTypeCleared returns if the "procedure_type" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) ProcedureTypeCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldProcedureType]
	return ok
}

// ResetProcedureType resets all changes to the "procedure_type" field.
func (m *ProcedureHistoryMutation) ResetProcedureType() {
	m.procedure_type = nil
	delete(m.clearedFields, procedurehistory.FieldProcedureType)
}

// SetDetails sets the "details" field.
func (m *ProcedureHistoryMutation) SetDetails(s string) {
	m.details = &s
}

// Details returns the value of the "details" field in the mutation.
func (m *ProcedureHistoryMutation) Details() (r string, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *ProcedureHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[procedurehistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *ProcedureHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, procedurehistory.FieldDetails)
}

// SetApprovalRequired sets the "approval_required" field.
func (m *ProcedureHistoryMutation) SetApprovalRequired(b bool) {
	m.approval_required = &b
}

// ApprovalRequired returns the value of the "approval_required" field in the mutation.
func (m *ProcedureHistoryMutation) ApprovalRequired() (r bool, exists bool) {
	v := m.approval_required
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalRequired returns the old "approval_required" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldApprovalRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalRequired: %w", err)
	}
	return oldValue.ApprovalRequired, nil
}

// ClearApprovalRequired clears the value of the "approval_required" field.
func (m *ProcedureHistoryMutation) ClearApprovalRequired() {
	m.approval_required = nil
	m.clearedFields[procedurehistory.FieldApprovalRequired] = struct{}{}
}

// ApprovalRequiredCleared returns if the "approval_required" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) ApprovalRequiredCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldApprovalRequired]
	return ok
}

// ResetApprovalRequired resets all changes to the "approval_required" field.
func (m *ProcedureHistoryMutation) ResetApprovalRequired() {
	m.approval_required = nil
	delete(m.clearedFields, procedurehistory.FieldApprovalRequired)
}

// SetReviewDue sets the "review_due" field.
func (m *ProcedureHistoryMutation) SetReviewDue(t time.Time) {
	m.review_due = &t
}

// ReviewDue returns the value of the "review_due" field in the mutation.
func (m *ProcedureHistoryMutation) ReviewDue() (r time.Time, exists bool) {
	v := m.review_due
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewDue returns the old "review_due" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldReviewDue(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewDue: %w", err)
	}
	return oldValue.ReviewDue, nil
}

// ClearReviewDue clears the value of the "review_due" field.
func (m *ProcedureHistoryMutation) ClearReviewDue() {
	m.review_due = nil
	m.clearedFields[procedurehistory.FieldReviewDue] = struct{}{}
}

// ReviewDueCleared returns if the "review_due" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) ReviewDueCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldReviewDue]
	return ok
}

// ResetReviewDue resets all changes to the "review_due" field.
func (m *ProcedureHistoryMutation) ResetReviewDue() {
	m.review_due = nil
	delete(m.clearedFields, procedurehistory.FieldReviewDue)
}

// SetReviewFrequency sets the "review_frequency" field.
func (m *ProcedureHistoryMutation) SetReviewFrequency(e enums.Frequency) {
	m.review_frequency = &e
}

// ReviewFrequency returns the value of the "review_frequency" field in the mutation.
func (m *ProcedureHistoryMutation) ReviewFrequency() (r enums.Frequency, exists bool) {
	v := m.review_frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewFrequency returns the old "review_frequency" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldReviewFrequency(ctx context.Context) (v enums.Frequency, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewFrequency: %w", err)
	}
	return oldValue.ReviewFrequency, nil
}

// ClearReviewFrequency clears the value of the "review_frequency" field.
func (m *ProcedureHistoryMutation) ClearReviewFrequency() {
	m.review_frequency = nil
	m.clearedFields[procedurehistory.FieldReviewFrequency] = struct{}{}
}

// ReviewFrequencyCleared returns if the "review_frequency" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) ReviewFrequencyCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldReviewFrequency]
	return ok
}

// ResetReviewFrequency resets all changes to the "review_frequency" field.
func (m *ProcedureHistoryMutation) ResetReviewFrequency() {
	m.review_frequency = nil
	delete(m.clearedFields, procedurehistory.FieldReviewFrequency)
}

// SetApproverID sets the "approver_id" field.
func (m *ProcedureHistoryMutation) SetApproverID(s string) {
	m.approver_id = &s
}

// ApproverID returns the value of the "approver_id" field in the mutation.
func (m *ProcedureHistoryMutation) ApproverID() (r string, exists bool) {
	v := m.approver_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApproverID returns the old "approver_id" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldApproverID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproverID: %w", err)
	}
	return oldValue.ApproverID, nil
}

// ClearApproverID clears the value of the "approver_id" field.
func (m *ProcedureHistoryMutation) ClearApproverID() {
	m.approver_id = nil
	m.clearedFields[procedurehistory.FieldApproverID] = struct{}{}
}

// ApproverIDCleared returns if the "approver_id" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) ApproverIDCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldApproverID]
	return ok
}

// ResetApproverID resets all changes to the "approver_id" field.
func (m *ProcedureHistoryMutation) ResetApproverID() {
	m.approver_id = nil
	delete(m.clearedFields, procedurehistory.FieldApproverID)
}

// SetDelegateID sets the "delegate_id" field.
func (m *ProcedureHistoryMutation) SetDelegateID(s string) {
	m.delegate_id = &s
}

// DelegateID returns the value of the "delegate_id" field in the mutation.
func (m *ProcedureHistoryMutation) DelegateID() (r string, exists bool) {
	v := m.delegate_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegateID returns the old "delegate_id" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldDelegateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelegateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelegateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegateID: %w", err)
	}
	return oldValue.DelegateID, nil
}

// ClearDelegateID clears the value of the "delegate_id" field.
func (m *ProcedureHistoryMutation) ClearDelegateID() {
	m.delegate_id = nil
	m.clearedFields[procedurehistory.FieldDelegateID] = struct{}{}
}

// DelegateIDCleared returns if the "delegate_id" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) DelegateIDCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldDelegateID]
	return ok
}

// ResetDelegateID resets all changes to the "delegate_id" field.
func (m *ProcedureHistoryMutation) ResetDelegateID() {
	m.delegate_id = nil
	delete(m.clearedFields, procedurehistory.FieldDelegateID)
}

// SetSummary sets the "summary" field.
func (m *ProcedureHistoryMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *ProcedureHistoryMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *ProcedureHistoryMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[procedurehistory.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *ProcedureHistoryMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, procedurehistory.FieldSummary)
}

// SetTagSuggestions sets the "tag_suggestions" field.
func (m *ProcedureHistoryMutation) SetTagSuggestions(s []string) {
	m.tag_suggestions = &s
	m.appendtag_suggestions = nil
}

// TagSuggestions returns the value of the "tag_suggestions" field in the mutation.
func (m *ProcedureHistoryMutation) TagSuggestions() (r []string, exists bool) {
	v := m.tag_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldTagSuggestions returns the old "tag_suggestions" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldTagSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagSuggestions: %w", err)
	}
	return oldValue.TagSuggestions, nil
}

// AppendTagSuggestions adds s to the "tag_suggestions" field.
func (m *ProcedureHistoryMutation) AppendTagSuggestions(s []string) {
	m.appendtag_suggestions = append(m.appendtag_suggestions, s...)
}

// AppendedTagSuggestions returns the list of values that were appended to the "tag_suggestions" field in this mutation.
func (m *ProcedureHistoryMutation) AppendedTagSuggestions() ([]string, bool) {
	if len(m.appendtag_suggestions) == 0 {
		return nil, false
	}
	return m.appendtag_suggestions, true
}

// ClearTagSuggestions clears the value of the "tag_suggestions" field.
func (m *ProcedureHistoryMutation) ClearTagSuggestions() {
	m.tag_suggestions = nil
	m.appendtag_suggestions = nil
	m.clearedFields[procedurehistory.FieldTagSuggestions] = struct{}{}
}

// TagSuggestionsCleared returns if the "tag_suggestions" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) TagSuggestionsCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldTagSuggestions]
	return ok
}

// ResetTagSuggestions resets all changes to the "tag_suggestions" field.
func (m *ProcedureHistoryMutation) ResetTagSuggestions() {
	m.tag_suggestions = nil
	m.appendtag_suggestions = nil
	delete(m.clearedFields, procedurehistory.FieldTagSuggestions)
}

// SetDismissedTagSuggestions sets the "dismissed_tag_suggestions" field.
func (m *ProcedureHistoryMutation) SetDismissedTagSuggestions(s []string) {
	m.dismissed_tag_suggestions = &s
	m.appenddismissed_tag_suggestions = nil
}

// DismissedTagSuggestions returns the value of the "dismissed_tag_suggestions" field in the mutation.
func (m *ProcedureHistoryMutation) DismissedTagSuggestions() (r []string, exists bool) {
	v := m.dismissed_tag_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldDismissedTagSuggestions returns the old "dismissed_tag_suggestions" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldDismissedTagSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDismissedTagSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDismissedTagSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDismissedTagSuggestions: %w", err)
	}
	return oldValue.DismissedTagSuggestions, nil
}

// AppendDismissedTagSuggestions adds s to the "dismissed_tag_suggestions" field.
func (m *ProcedureHistoryMutation) AppendDismissedTagSuggestions(s []string) {
	m.appenddismissed_tag_suggestions = append(m.appenddismissed_tag_suggestions, s...)
}

// AppendedDismissedTagSuggestions returns the list of values that were appended to the "dismissed_tag_suggestions" field in this mutation.
func (m *ProcedureHistoryMutation) AppendedDismissedTagSuggestions() ([]string, bool) {
	if len(m.appenddismissed_tag_suggestions) == 0 {
		return nil, false
	}
	return m.appenddismissed_tag_suggestions, true
}

// ClearDismissedTagSuggestions clears the value of the "dismissed_tag_suggestions" field.
func (m *ProcedureHistoryMutation) ClearDismissedTagSuggestions() {
	m.dismissed_tag_suggestions = nil
	m.appenddismissed_tag_suggestions = nil
	m.clearedFields[procedurehistory.FieldDismissedTagSuggestions] = struct{}{}
}

// DismissedTagSuggestionsCleared returns if the "dismissed_tag_suggestions" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) DismissedTagSuggestionsCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldDismissedTagSuggestions]
	return ok
}

// ResetDismissedTagSuggestions resets all changes to the "dismissed_tag_suggestions" field.
func (m *ProcedureHistoryMutation) ResetDismissedTagSuggestions() {
	m.dismissed_tag_suggestions = nil
	m.appenddismissed_tag_suggestions = nil
	delete(m.clearedFields, procedurehistory.FieldDismissedTagSuggestions)
}

// SetControlSuggestions sets the "control_suggestions" field.
func (m *ProcedureHistoryMutation) SetControlSuggestions(s []string) {
	m.control_suggestions = &s
	m.appendcontrol_suggestions = nil
}

// ControlSuggestions returns the value of the "control_suggestions" field in the mutation.
func (m *ProcedureHistoryMutation) ControlSuggestions() (r []string, exists bool) {
	v := m.control_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldControlSuggestions returns the old "control_suggestions" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldControlSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlSuggestions: %w", err)
	}
	return oldValue.ControlSuggestions, nil
}

// AppendControlSuggestions adds s to the "control_suggestions" field.
func (m *ProcedureHistoryMutation) AppendControlSuggestions(s []string) {
	m.appendcontrol_suggestions = append(m.appendcontrol_suggestions, s...)
}

// AppendedControlSuggestions returns the list of values that were appended to the "control_suggestions" field in this mutation.
func (m *ProcedureHistoryMutation) AppendedControlSuggestions() ([]string, bool) {
	if len(m.appendcontrol_suggestions) == 0 {
		return nil, false
	}
	return m.appendcontrol_suggestions, true
}

// ClearControlSuggestions clears the value of the "control_suggestions" field.
func (m *ProcedureHistoryMutation) ClearControlSuggestions() {
	m.control_suggestions = nil
	m.appendcontrol_suggestions = nil
	m.clearedFields[procedurehistory.FieldControlSuggestions] = struct{}{}
}

// ControlSuggestionsCleared returns if the "control_suggestions" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) ControlSuggestionsCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldControlSuggestions]
	return ok
}

// ResetControlSuggestions resets all changes to the "control_suggestions" field.
func (m *ProcedureHistoryMutation) ResetControlSuggestions() {
	m.control_suggestions = nil
	m.appendcontrol_suggestions = nil
	delete(m.clearedFields, procedurehistory.FieldControlSuggestions)
}

// SetDismissedControlSuggestions sets the "dismissed_control_suggestions" field.
func (m *ProcedureHistoryMutation) SetDismissedControlSuggestions(s []string) {
	m.dismissed_control_suggestions = &s
	m.appenddismissed_control_suggestions = nil
}

// DismissedControlSuggestions returns the value of the "dismissed_control_suggestions" field in the mutation.
func (m *ProcedureHistoryMutation) DismissedControlSuggestions() (r []string, exists bool) {
	v := m.dismissed_control_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldDismissedControlSuggestions returns the old "dismissed_control_suggestions" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldDismissedControlSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDismissedControlSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDismissedControlSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDismissedControlSuggestions: %w", err)
	}
	return oldValue.DismissedControlSuggestions, nil
}

// AppendDismissedControlSuggestions adds s to the "dismissed_control_suggestions" field.
func (m *ProcedureHistoryMutation) AppendDismissedControlSuggestions(s []string) {
	m.appenddismissed_control_suggestions = append(m.appenddismissed_control_suggestions, s...)
}

// AppendedDismissedControlSuggestions returns the list of values that were appended to the "dismissed_control_suggestions" field in this mutation.
func (m *ProcedureHistoryMutation) AppendedDismissedControlSuggestions() ([]string, bool) {
	if len(m.appenddismissed_control_suggestions) == 0 {
		return nil, false
	}
	return m.appenddismissed_control_suggestions, true
}

// ClearDismissedControlSuggestions clears the value of the "dismissed_control_suggestions" field.
func (m *ProcedureHistoryMutation) ClearDismissedControlSuggestions() {
	m.dismissed_control_suggestions = nil
	m.appenddismissed_control_suggestions = nil
	m.clearedFields[procedurehistory.FieldDismissedControlSuggestions] = struct{}{}
}

// DismissedControlSuggestionsCleared returns if the "dismissed_control_suggestions" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) DismissedControlSuggestionsCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldDismissedControlSuggestions]
	return ok
}

// ResetDismissedControlSuggestions resets all changes to the "dismissed_control_suggestions" field.
func (m *ProcedureHistoryMutation) ResetDismissedControlSuggestions() {
	m.dismissed_control_suggestions = nil
	m.appenddismissed_control_suggestions = nil
	delete(m.clearedFields, procedurehistory.FieldDismissedControlSuggestions)
}

// SetImprovementSuggestions sets the "improvement_suggestions" field.
func (m *ProcedureHistoryMutation) SetImprovementSuggestions(s []string) {
	m.improvement_suggestions = &s
	m.appendimprovement_suggestions = nil
}

// ImprovementSuggestions returns the value of the "improvement_suggestions" field in the mutation.
func (m *ProcedureHistoryMutation) ImprovementSuggestions() (r []string, exists bool) {
	v := m.improvement_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldImprovementSuggestions returns the old "improvement_suggestions" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldImprovementSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImprovementSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImprovementSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImprovementSuggestions: %w", err)
	}
	return oldValue.ImprovementSuggestions, nil
}

// AppendImprovementSuggestions adds s to the "improvement_suggestions" field.
func (m *ProcedureHistoryMutation) AppendImprovementSuggestions(s []string) {
	m.appendimprovement_suggestions = append(m.appendimprovement_suggestions, s...)
}

// AppendedImprovementSuggestions returns the list of values that were appended to the "improvement_suggestions" field in this mutation.
func (m *ProcedureHistoryMutation) AppendedImprovementSuggestions() ([]string, bool) {
	if len(m.appendimprovement_suggestions) == 0 {
		return nil, false
	}
	return m.appendimprovement_suggestions, true
}

// ClearImprovementSuggestions clears the value of the "improvement_suggestions" field.
func (m *ProcedureHistoryMutation) ClearImprovementSuggestions() {
	m.improvement_suggestions = nil
	m.appendimprovement_suggestions = nil
	m.clearedFields[procedurehistory.FieldImprovementSuggestions] = struct{}{}
}

// ImprovementSuggestionsCleared returns if the "improvement_suggestions" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) ImprovementSuggestionsCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldImprovementSuggestions]
	return ok
}

// ResetImprovementSuggestions resets all changes to the "improvement_suggestions" field.
func (m *ProcedureHistoryMutation) ResetImprovementSuggestions() {
	m.improvement_suggestions = nil
	m.appendimprovement_suggestions = nil
	delete(m.clearedFields, procedurehistory.FieldImprovementSuggestions)
}

// SetDismissedImprovementSuggestions sets the "dismissed_improvement_suggestions" field.
func (m *ProcedureHistoryMutation) SetDismissedImprovementSuggestions(s []string) {
	m.dismissed_improvement_suggestions = &s
	m.appenddismissed_improvement_suggestions = nil
}

// DismissedImprovementSuggestions returns the value of the "dismissed_improvement_suggestions" field in the mutation.
func (m *ProcedureHistoryMutation) DismissedImprovementSuggestions() (r []string, exists bool) {
	v := m.dismissed_improvement_suggestions
	if v == nil {
		return
	}
	return *v, true
}

// OldDismissedImprovementSuggestions returns the old "dismissed_improvement_suggestions" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldDismissedImprovementSuggestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDismissedImprovementSuggestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDismissedImprovementSuggestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDismissedImprovementSuggestions: %w", err)
	}
	return oldValue.DismissedImprovementSuggestions, nil
}

// AppendDismissedImprovementSuggestions adds s to the "dismissed_improvement_suggestions" field.
func (m *ProcedureHistoryMutation) AppendDismissedImprovementSuggestions(s []string) {
	m.appenddismissed_improvement_suggestions = append(m.appenddismissed_improvement_suggestions, s...)
}

// AppendedDismissedImprovementSuggestions returns the list of values that were appended to the "dismissed_improvement_suggestions" field in this mutation.
func (m *ProcedureHistoryMutation) AppendedDismissedImprovementSuggestions() ([]string, bool) {
	if len(m.appenddismissed_improvement_suggestions) == 0 {
		return nil, false
	}
	return m.appenddismissed_improvement_suggestions, true
}

// ClearDismissedImprovementSuggestions clears the value of the "dismissed_improvement_suggestions" field.
func (m *ProcedureHistoryMutation) ClearDismissedImprovementSuggestions() {
	m.dismissed_improvement_suggestions = nil
	m.appenddismissed_improvement_suggestions = nil
	m.clearedFields[procedurehistory.FieldDismissedImprovementSuggestions] = struct{}{}
}

// DismissedImprovementSuggestionsCleared returns if the "dismissed_improvement_suggestions" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) DismissedImprovementSuggestionsCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldDismissedImprovementSuggestions]
	return ok
}

// ResetDismissedImprovementSuggestions resets all changes to the "dismissed_improvement_suggestions" field.
func (m *ProcedureHistoryMutation) ResetDismissedImprovementSuggestions() {
	m.dismissed_improvement_suggestions = nil
	m.appenddismissed_improvement_suggestions = nil
	delete(m.clearedFields, procedurehistory.FieldDismissedImprovementSuggestions)
}

// SetURL sets the "url" field.
func (m *ProcedureHistoryMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ProcedureHistoryMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ProcedureHistoryMutation) ClearURL() {
	m.url = nil
	m.clearedFields[procedurehistory.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) URLCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ProcedureHistoryMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, procedurehistory.FieldURL)
}

// SetFileID sets the "file_id" field.
func (m *ProcedureHistoryMutation) SetFileID(s string) {
	m.file_id = &s
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *ProcedureHistoryMutation) FileID() (r string, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ClearFileID clears the value of the "file_id" field.
func (m *ProcedureHistoryMutation) ClearFileID() {
	m.file_id = nil
	m.clearedFields[procedurehistory.FieldFileID] = struct{}{}
}

// FileIDCleared returns if the "file_id" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) FileIDCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldFileID]
	return ok
}

// ResetFileID resets all changes to the "file_id" field.
func (m *ProcedureHistoryMutation) ResetFileID() {
	m.file_id = nil
	delete(m.clearedFields, procedurehistory.FieldFileID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *ProcedureHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *ProcedureHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *ProcedureHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[procedurehistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *ProcedureHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, procedurehistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *ProcedureHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *ProcedureHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *ProcedureHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[procedurehistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *ProcedureHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, procedurehistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *ProcedureHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *ProcedureHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *ProcedureHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[procedurehistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *ProcedureHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, procedurehistory.FieldSystemInternalID)
}

// SetProcedureKindName sets the "procedure_kind_name" field.
func (m *ProcedureHistoryMutation) SetProcedureKindName(s string) {
	m.procedure_kind_name = &s
}

// ProcedureKindName returns the value of the "procedure_kind_name" field in the mutation.
func (m *ProcedureHistoryMutation) ProcedureKindName() (r string, exists bool) {
	v := m.procedure_kind_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProcedureKindName returns the old "procedure_kind_name" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldProcedureKindName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcedureKindName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcedureKindName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcedureKindName: %w", err)
	}
	return oldValue.ProcedureKindName, nil
}

// ClearProcedureKindName clears the value of the "procedure_kind_name" field.
func (m *ProcedureHistoryMutation) ClearProcedureKindName() {
	m.procedure_kind_name = nil
	m.clearedFields[procedurehistory.FieldProcedureKindName] = struct{}{}
}

// ProcedureKindNameCleared returns if the "procedure_kind_name" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) ProcedureKindNameCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldProcedureKindName]
	return ok
}

// ResetProcedureKindName resets all changes to the "procedure_kind_name" field.
func (m *ProcedureHistoryMutation) ResetProcedureKindName() {
	m.procedure_kind_name = nil
	delete(m.clearedFields, procedurehistory.FieldProcedureKindName)
}

// SetProcedureKindID sets the "procedure_kind_id" field.
func (m *ProcedureHistoryMutation) SetProcedureKindID(s string) {
	m.procedure_kind_id = &s
}

// ProcedureKindID returns the value of the "procedure_kind_id" field in the mutation.
func (m *ProcedureHistoryMutation) ProcedureKindID() (r string, exists bool) {
	v := m.procedure_kind_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcedureKindID returns the old "procedure_kind_id" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldProcedureKindID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcedureKindID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcedureKindID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcedureKindID: %w", err)
	}
	return oldValue.ProcedureKindID, nil
}

// ClearProcedureKindID clears the value of the "procedure_kind_id" field.
func (m *ProcedureHistoryMutation) ClearProcedureKindID() {
	m.procedure_kind_id = nil
	m.clearedFields[procedurehistory.FieldProcedureKindID] = struct{}{}
}

// ProcedureKindIDCleared returns if the "procedure_kind_id" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) ProcedureKindIDCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldProcedureKindID]
	return ok
}

// ResetProcedureKindID resets all changes to the "procedure_kind_id" field.
func (m *ProcedureHistoryMutation) ResetProcedureKindID() {
	m.procedure_kind_id = nil
	delete(m.clearedFields, procedurehistory.FieldProcedureKindID)
}

// Where appends a list predicates to the ProcedureHistoryMutation builder.
func (m *ProcedureHistoryMutation) Where(ps ...predicate.ProcedureHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcedureHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcedureHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcedureHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcedureHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcedureHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcedureHistory).
func (m *ProcedureHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcedureHistoryMutation) Fields() []string {
	fields := make([]string, 0, 36)
	if m.history_time != nil {
		fields = append(fields, procedurehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, procedurehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, procedurehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, procedurehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, procedurehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, procedurehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, procedurehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, procedurehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, procedurehistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, procedurehistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, procedurehistory.FieldTags)
	}
	if m.revision != nil {
		fields = append(fields, procedurehistory.FieldRevision)
	}
	if m.owner_id != nil {
		fields = append(fields, procedurehistory.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, procedurehistory.FieldName)
	}
	if m.status != nil {
		fields = append(fields, procedurehistory.FieldStatus)
	}
	if m.procedure_type != nil {
		fields = append(fields, procedurehistory.FieldProcedureType)
	}
	if m.details != nil {
		fields = append(fields, procedurehistory.FieldDetails)
	}
	if m.approval_required != nil {
		fields = append(fields, procedurehistory.FieldApprovalRequired)
	}
	if m.review_due != nil {
		fields = append(fields, procedurehistory.FieldReviewDue)
	}
	if m.review_frequency != nil {
		fields = append(fields, procedurehistory.FieldReviewFrequency)
	}
	if m.approver_id != nil {
		fields = append(fields, procedurehistory.FieldApproverID)
	}
	if m.delegate_id != nil {
		fields = append(fields, procedurehistory.FieldDelegateID)
	}
	if m.summary != nil {
		fields = append(fields, procedurehistory.FieldSummary)
	}
	if m.tag_suggestions != nil {
		fields = append(fields, procedurehistory.FieldTagSuggestions)
	}
	if m.dismissed_tag_suggestions != nil {
		fields = append(fields, procedurehistory.FieldDismissedTagSuggestions)
	}
	if m.control_suggestions != nil {
		fields = append(fields, procedurehistory.FieldControlSuggestions)
	}
	if m.dismissed_control_suggestions != nil {
		fields = append(fields, procedurehistory.FieldDismissedControlSuggestions)
	}
	if m.improvement_suggestions != nil {
		fields = append(fields, procedurehistory.FieldImprovementSuggestions)
	}
	if m.dismissed_improvement_suggestions != nil {
		fields = append(fields, procedurehistory.FieldDismissedImprovementSuggestions)
	}
	if m.url != nil {
		fields = append(fields, procedurehistory.FieldURL)
	}
	if m.file_id != nil {
		fields = append(fields, procedurehistory.FieldFileID)
	}
	if m.system_owned != nil {
		fields = append(fields, procedurehistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, procedurehistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, procedurehistory.FieldSystemInternalID)
	}
	if m.procedure_kind_name != nil {
		fields = append(fields, procedurehistory.FieldProcedureKindName)
	}
	if m.procedure_kind_id != nil {
		fields = append(fields, procedurehistory.FieldProcedureKindID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcedureHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case procedurehistory.FieldHistoryTime:
		return m.HistoryTime()
	case procedurehistory.FieldRef:
		return m.Ref()
	case procedurehistory.FieldOperation:
		return m.Operation()
	case procedurehistory.FieldCreatedAt:
		return m.CreatedAt()
	case procedurehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case procedurehistory.FieldCreatedBy:
		return m.CreatedBy()
	case procedurehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case procedurehistory.FieldDeletedAt:
		return m.DeletedAt()
	case procedurehistory.FieldDeletedBy:
		return m.DeletedBy()
	case procedurehistory.FieldDisplayID:
		return m.DisplayID()
	case procedurehistory.FieldTags:
		return m.Tags()
	case procedurehistory.FieldRevision:
		return m.Revision()
	case procedurehistory.FieldOwnerID:
		return m.OwnerID()
	case procedurehistory.FieldName:
		return m.Name()
	case procedurehistory.FieldStatus:
		return m.Status()
	case procedurehistory.FieldProcedureType:
		return m.ProcedureType()
	case procedurehistory.FieldDetails:
		return m.Details()
	case procedurehistory.FieldApprovalRequired:
		return m.ApprovalRequired()
	case procedurehistory.FieldReviewDue:
		return m.ReviewDue()
	case procedurehistory.FieldReviewFrequency:
		return m.ReviewFrequency()
	case procedurehistory.FieldApproverID:
		return m.ApproverID()
	case procedurehistory.FieldDelegateID:
		return m.DelegateID()
	case procedurehistory.FieldSummary:
		return m.Summary()
	case procedurehistory.FieldTagSuggestions:
		return m.TagSuggestions()
	case procedurehistory.FieldDismissedTagSuggestions:
		return m.DismissedTagSuggestions()
	case procedurehistory.FieldControlSuggestions:
		return m.ControlSuggestions()
	case procedurehistory.FieldDismissedControlSuggestions:
		return m.DismissedControlSuggestions()
	case procedurehistory.FieldImprovementSuggestions:
		return m.ImprovementSuggestions()
	case procedurehistory.FieldDismissedImprovementSuggestions:
		return m.DismissedImprovementSuggestions()
	case procedurehistory.FieldURL:
		return m.URL()
	case procedurehistory.FieldFileID:
		return m.FileID()
	case procedurehistory.FieldSystemOwned:
		return m.SystemOwned()
	case procedurehistory.FieldInternalNotes:
		return m.InternalNotes()
	case procedurehistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case procedurehistory.FieldProcedureKindName:
		return m.ProcedureKindName()
	case procedurehistory.FieldProcedureKindID:
		return m.ProcedureKindID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcedureHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case procedurehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case procedurehistory.FieldRef:
		return m.OldRef(ctx)
	case procedurehistory.FieldOperation:
		return m.OldOperation(ctx)
	case procedurehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case procedurehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case procedurehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case procedurehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case procedurehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case procedurehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case procedurehistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case procedurehistory.FieldTags:
		return m.OldTags(ctx)
	case procedurehistory.FieldRevision:
		return m.OldRevision(ctx)
	case procedurehistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case procedurehistory.FieldName:
		return m.OldName(ctx)
	case procedurehistory.FieldStatus:
		return m.OldStatus(ctx)
	case procedurehistory.FieldProcedureType:
		return m.OldProcedureType(ctx)
	case procedurehistory.FieldDetails:
		return m.OldDetails(ctx)
	case procedurehistory.FieldApprovalRequired:
		return m.OldApprovalRequired(ctx)
	case procedurehistory.FieldReviewDue:
		return m.OldReviewDue(ctx)
	case procedurehistory.FieldReviewFrequency:
		return m.OldReviewFrequency(ctx)
	case procedurehistory.FieldApproverID:
		return m.OldApproverID(ctx)
	case procedurehistory.FieldDelegateID:
		return m.OldDelegateID(ctx)
	case procedurehistory.FieldSummary:
		return m.OldSummary(ctx)
	case procedurehistory.FieldTagSuggestions:
		return m.OldTagSuggestions(ctx)
	case procedurehistory.FieldDismissedTagSuggestions:
		return m.OldDismissedTagSuggestions(ctx)
	case procedurehistory.FieldControlSuggestions:
		return m.OldControlSuggestions(ctx)
	case procedurehistory.FieldDismissedControlSuggestions:
		return m.OldDismissedControlSuggestions(ctx)
	case procedurehistory.FieldImprovementSuggestions:
		return m.OldImprovementSuggestions(ctx)
	case procedurehistory.FieldDismissedImprovementSuggestions:
		return m.OldDismissedImprovementSuggestions(ctx)
	case procedurehistory.FieldURL:
		return m.OldURL(ctx)
	case procedurehistory.FieldFileID:
		return m.OldFileID(ctx)
	case procedurehistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case procedurehistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case procedurehistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case procedurehistory.FieldProcedureKindName:
		return m.OldProcedureKindName(ctx)
	case procedurehistory.FieldProcedureKindID:
		return m.OldProcedureKindID(ctx)
	}
	return nil, fmt.Errorf("unknown ProcedureHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcedureHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case procedurehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case procedurehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case procedurehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case procedurehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case procedurehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case procedurehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case procedurehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case procedurehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case procedurehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case procedurehistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case procedurehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case procedurehistory.FieldRevision:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case procedurehistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case procedurehistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case procedurehistory.FieldStatus:
		v, ok := value.(enums.DocumentStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case procedurehistory.FieldProcedureType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcedureType(v)
		return nil
	case procedurehistory.FieldDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case procedurehistory.FieldApprovalRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalRequired(v)
		return nil
	case procedurehistory.FieldReviewDue:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewDue(v)
		return nil
	case procedurehistory.FieldReviewFrequency:
		v, ok := value.(enums.Frequency)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewFrequency(v)
		return nil
	case procedurehistory.FieldApproverID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproverID(v)
		return nil
	case procedurehistory.FieldDelegateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegateID(v)
		return nil
	case procedurehistory.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case procedurehistory.FieldTagSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagSuggestions(v)
		return nil
	case procedurehistory.FieldDismissedTagSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDismissedTagSuggestions(v)
		return nil
	case procedurehistory.FieldControlSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlSuggestions(v)
		return nil
	case procedurehistory.FieldDismissedControlSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDismissedControlSuggestions(v)
		return nil
	case procedurehistory.FieldImprovementSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImprovementSuggestions(v)
		return nil
	case procedurehistory.FieldDismissedImprovementSuggestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDismissedImprovementSuggestions(v)
		return nil
	case procedurehistory.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case procedurehistory.FieldFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case procedurehistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case procedurehistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case procedurehistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case procedurehistory.FieldProcedureKindName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcedureKindName(v)
		return nil
	case procedurehistory.FieldProcedureKindID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcedureKindID(v)
		return nil
	}
	return fmt.Errorf("unknown ProcedureHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcedureHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcedureHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcedureHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProcedureHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcedureHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(procedurehistory.FieldRef) {
		fields = append(fields, procedurehistory.FieldRef)
	}
	if m.FieldCleared(procedurehistory.FieldCreatedAt) {
		fields = append(fields, procedurehistory.FieldCreatedAt)
	}
	if m.FieldCleared(procedurehistory.FieldUpdatedAt) {
		fields = append(fields, procedurehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(procedurehistory.FieldCreatedBy) {
		fields = append(fields, procedurehistory.FieldCreatedBy)
	}
	if m.FieldCleared(procedurehistory.FieldUpdatedBy) {
		fields = append(fields, procedurehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(procedurehistory.FieldDeletedAt) {
		fields = append(fields, procedurehistory.FieldDeletedAt)
	}
	if m.FieldCleared(procedurehistory.FieldDeletedBy) {
		fields = append(fields, procedurehistory.FieldDeletedBy)
	}
	if m.FieldCleared(procedurehistory.FieldTags) {
		fields = append(fields, procedurehistory.FieldTags)
	}
	if m.FieldCleared(procedurehistory.FieldRevision) {
		fields = append(fields, procedurehistory.FieldRevision)
	}
	if m.FieldCleared(procedurehistory.FieldOwnerID) {
		fields = append(fields, procedurehistory.FieldOwnerID)
	}
	if m.FieldCleared(procedurehistory.FieldStatus) {
		fields = append(fields, procedurehistory.FieldStatus)
	}
	if m.FieldCleared(procedurehistory.FieldProcedureType) {
		fields = append(fields, procedurehistory.FieldProcedureType)
	}
	if m.FieldCleared(procedurehistory.FieldDetails) {
		fields = append(fields, procedurehistory.FieldDetails)
	}
	if m.FieldCleared(procedurehistory.FieldApprovalRequired) {
		fields = append(fields, procedurehistory.FieldApprovalRequired)
	}
	if m.FieldCleared(procedurehistory.FieldReviewDue) {
		fields = append(fields, procedurehistory.FieldReviewDue)
	}
	if m.FieldCleared(procedurehistory.FieldReviewFrequency) {
		fields = append(fields, procedurehistory.FieldReviewFrequency)
	}
	if m.FieldCleared(procedurehistory.FieldApproverID) {
		fields = append(fields, procedurehistory.FieldApproverID)
	}
	if m.FieldCleared(procedurehistory.FieldDelegateID) {
		fields = append(fields, procedurehistory.FieldDelegateID)
	}
	if m.FieldCleared(procedurehistory.FieldSummary) {
		fields = append(fields, procedurehistory.FieldSummary)
	}
	if m.FieldCleared(procedurehistory.FieldTagSuggestions) {
		fields = append(fields, procedurehistory.FieldTagSuggestions)
	}
	if m.FieldCleared(procedurehistory.FieldDismissedTagSuggestions) {
		fields = append(fields, procedurehistory.FieldDismissedTagSuggestions)
	}
	if m.FieldCleared(procedurehistory.FieldControlSuggestions) {
		fields = append(fields, procedurehistory.FieldControlSuggestions)
	}
	if m.FieldCleared(procedurehistory.FieldDismissedControlSuggestions) {
		fields = append(fields, procedurehistory.FieldDismissedControlSuggestions)
	}
	if m.FieldCleared(procedurehistory.FieldImprovementSuggestions) {
		fields = append(fields, procedurehistory.FieldImprovementSuggestions)
	}
	if m.FieldCleared(procedurehistory.FieldDismissedImprovementSuggestions) {
		fields = append(fields, procedurehistory.FieldDismissedImprovementSuggestions)
	}
	if m.FieldCleared(procedurehistory.FieldURL) {
		fields = append(fields, procedurehistory.FieldURL)
	}
	if m.FieldCleared(procedurehistory.FieldFileID) {
		fields = append(fields, procedurehistory.FieldFileID)
	}
	if m.FieldCleared(procedurehistory.FieldSystemOwned) {
		fields = append(fields, procedurehistory.FieldSystemOwned)
	}
	if m.FieldCleared(procedurehistory.FieldInternalNotes) {
		fields = append(fields, procedurehistory.FieldInternalNotes)
	}
	if m.FieldCleared(procedurehistory.FieldSystemInternalID) {
		fields = append(fields, procedurehistory.FieldSystemInternalID)
	}
	if m.FieldCleared(procedurehistory.FieldProcedureKindName) {
		fields = append(fields, procedurehistory.FieldProcedureKindName)
	}
	if m.FieldCleared(procedurehistory.FieldProcedureKindID) {
		fields = append(fields, procedurehistory.FieldProcedureKindID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcedureHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcedureHistoryMutation) ClearField(name string) error {
	switch name {
	case procedurehistory.FieldRef:
		m.ClearRef()
		return nil
	case procedurehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case procedurehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case procedurehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case procedurehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case procedurehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case procedurehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case procedurehistory.FieldTags:
		m.ClearTags()
		return nil
	case procedurehistory.FieldRevision:
		m.ClearRevision()
		return nil
	case procedurehistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case procedurehistory.FieldStatus:
		m.ClearStatus()
		return nil
	case procedurehistory.FieldProcedureType:
		m.ClearProcedureType()
		return nil
	case procedurehistory.FieldDetails:
		m.ClearDetails()
		return nil
	case procedurehistory.FieldApprovalRequired:
		m.ClearApprovalRequired()
		return nil
	case procedurehistory.FieldReviewDue:
		m.ClearReviewDue()
		return nil
	case procedurehistory.FieldReviewFrequency:
		m.ClearReviewFrequency()
		return nil
	case procedurehistory.FieldApproverID:
		m.ClearApproverID()
		return nil
	case procedurehistory.FieldDelegateID:
		m.ClearDelegateID()
		return nil
	case procedurehistory.FieldSummary:
		m.ClearSummary()
		return nil
	case procedurehistory.FieldTagSuggestions:
		m.ClearTagSuggestions()
		return nil
	case procedurehistory.FieldDismissedTagSuggestions:
		m.ClearDismissedTagSuggestions()
		return nil
	case procedurehistory.FieldControlSuggestions:
		m.ClearControlSuggestions()
		return nil
	case procedurehistory.FieldDismissedControlSuggestions:
		m.ClearDismissedControlSuggestions()
		return nil
	case procedurehistory.FieldImprovementSuggestions:
		m.ClearImprovementSuggestions()
		return nil
	case procedurehistory.FieldDismissedImprovementSuggestions:
		m.ClearDismissedImprovementSuggestions()
		return nil
	case procedurehistory.FieldURL:
		m.ClearURL()
		return nil
	case procedurehistory.FieldFileID:
		m.ClearFileID()
		return nil
	case procedurehistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case procedurehistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case procedurehistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case procedurehistory.FieldProcedureKindName:
		m.ClearProcedureKindName()
		return nil
	case procedurehistory.FieldProcedureKindID:
		m.ClearProcedureKindID()
		return nil
	}
	return fmt.Errorf("unknown ProcedureHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcedureHistoryMutation) ResetField(name string) error {
	switch name {
	case procedurehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case procedurehistory.FieldRef:
		m.ResetRef()
		return nil
	case procedurehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case procedurehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case procedurehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case procedurehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case procedurehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case procedurehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case procedurehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case procedurehistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case procedurehistory.FieldTags:
		m.ResetTags()
		return nil
	case procedurehistory.FieldRevision:
		m.ResetRevision()
		return nil
	case procedurehistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case procedurehistory.FieldName:
		m.ResetName()
		return nil
	case procedurehistory.FieldStatus:
		m.ResetStatus()
		return nil
	case procedurehistory.FieldProcedureType:
		m.ResetProcedureType()
		return nil
	case procedurehistory.FieldDetails:
		m.ResetDetails()
		return nil
	case procedurehistory.FieldApprovalRequired:
		m.ResetApprovalRequired()
		return nil
	case procedurehistory.FieldReviewDue:
		m.ResetReviewDue()
		return nil
	case procedurehistory.FieldReviewFrequency:
		m.ResetReviewFrequency()
		return nil
	case procedurehistory.FieldApproverID:
		m.ResetApproverID()
		return nil
	case procedurehistory.FieldDelegateID:
		m.ResetDelegateID()
		return nil
	case procedurehistory.FieldSummary:
		m.ResetSummary()
		return nil
	case procedurehistory.FieldTagSuggestions:
		m.ResetTagSuggestions()
		return nil
	case procedurehistory.FieldDismissedTagSuggestions:
		m.ResetDismissedTagSuggestions()
		return nil
	case procedurehistory.FieldControlSuggestions:
		m.ResetControlSuggestions()
		return nil
	case procedurehistory.FieldDismissedControlSuggestions:
		m.ResetDismissedControlSuggestions()
		return nil
	case procedurehistory.FieldImprovementSuggestions:
		m.ResetImprovementSuggestions()
		return nil
	case procedurehistory.FieldDismissedImprovementSuggestions:
		m.ResetDismissedImprovementSuggestions()
		return nil
	case procedurehistory.FieldURL:
		m.ResetURL()
		return nil
	case procedurehistory.FieldFileID:
		m.ResetFileID()
		return nil
	case procedurehistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case procedurehistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case procedurehistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case procedurehistory.FieldProcedureKindName:
		m.ResetProcedureKindName()
		return nil
	case procedurehistory.FieldProcedureKindID:
		m.ResetProcedureKindID()
		return nil
	}
	return fmt.Errorf("unknown ProcedureHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcedureHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcedureHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcedureHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcedureHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcedureHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcedureHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcedureHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcedureHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcedureHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcedureHistory edge %s", name)
}

// ProgramHistoryMutation represents an operation that mutates the ProgramHistory nodes in the graph.
type ProgramHistoryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	history_time           *time.Time
	ref                    *string
	operation              *history.OpType
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	deleted_at             *time.Time
	deleted_by             *string
	display_id             *string
	tags                   *[]string
	appendtags             []string
	owner_id               *string
	program_kind_name      *string
	program_kind_id        *string
	name                   *string
	description            *string
	status                 *enums.ProgramStatus
	program_type           *enums.ProgramType
	framework_name         *string
	start_date             *time.Time
	end_date               *time.Time
	auditor_ready          *bool
	auditor_write_comments *bool
	auditor_read_comments  *bool
	audit_firm             *string
	auditor                *string
	auditor_email          *string
	program_owner_id       *string
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ProgramHistory, error)
	predicates             []predicate.ProgramHistory
}

var _ ent.Mutation = (*ProgramHistoryMutation)(nil)

// programhistoryOption allows management of the mutation configuration using functional options.
type programhistoryOption func(*ProgramHistoryMutation)

// newProgramHistoryMutation creates new mutation for the ProgramHistory entity.
func newProgramHistoryMutation(c config, op Op, opts ...programhistoryOption) *ProgramHistoryMutation {
	m := &ProgramHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProgramHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProgramHistoryID sets the ID field of the mutation.
func withProgramHistoryID(id string) programhistoryOption {
	return func(m *ProgramHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProgramHistory
		)
		m.oldValue = func(ctx context.Context) (*ProgramHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProgramHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProgramHistory sets the old ProgramHistory of the mutation.
func withProgramHistory(node *ProgramHistory) programhistoryOption {
	return func(m *ProgramHistoryMutation) {
		m.oldValue = func(context.Context) (*ProgramHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProgramHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProgramHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProgramHistory entities.
func (m *ProgramHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProgramHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProgramHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProgramHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ProgramHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ProgramHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ProgramHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ProgramHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ProgramHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ProgramHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[programhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ProgramHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ProgramHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, programhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ProgramHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ProgramHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ProgramHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProgramHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProgramHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProgramHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[programhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProgramHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProgramHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, programhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProgramHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProgramHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProgramHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[programhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProgramHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProgramHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, programhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ProgramHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProgramHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProgramHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[programhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProgramHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProgramHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, programhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProgramHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProgramHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProgramHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[programhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProgramHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProgramHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, programhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProgramHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProgramHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProgramHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[programhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProgramHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProgramHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, programhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ProgramHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ProgramHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ProgramHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[programhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ProgramHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ProgramHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, programhistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *ProgramHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *ProgramHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *ProgramHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *ProgramHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ProgramHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ProgramHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ProgramHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ProgramHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[programhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ProgramHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ProgramHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, programhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *ProgramHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ProgramHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *ProgramHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[programhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *ProgramHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ProgramHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, programhistory.FieldOwnerID)
}

// SetProgramKindName sets the "program_kind_name" field.
func (m *ProgramHistoryMutation) SetProgramKindName(s string) {
	m.program_kind_name = &s
}

// ProgramKindName returns the value of the "program_kind_name" field in the mutation.
func (m *ProgramHistoryMutation) ProgramKindName() (r string, exists bool) {
	v := m.program_kind_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProgramKindName returns the old "program_kind_name" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldProgramKindName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgramKindName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgramKindName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgramKindName: %w", err)
	}
	return oldValue.ProgramKindName, nil
}

// ClearProgramKindName clears the value of the "program_kind_name" field.
func (m *ProgramHistoryMutation) ClearProgramKindName() {
	m.program_kind_name = nil
	m.clearedFields[programhistory.FieldProgramKindName] = struct{}{}
}

// ProgramKindNameCleared returns if the "program_kind_name" field was cleared in this mutation.
func (m *ProgramHistoryMutation) ProgramKindNameCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldProgramKindName]
	return ok
}

// ResetProgramKindName resets all changes to the "program_kind_name" field.
func (m *ProgramHistoryMutation) ResetProgramKindName() {
	m.program_kind_name = nil
	delete(m.clearedFields, programhistory.FieldProgramKindName)
}

// SetProgramKindID sets the "program_kind_id" field.
func (m *ProgramHistoryMutation) SetProgramKindID(s string) {
	m.program_kind_id = &s
}

// ProgramKindID returns the value of the "program_kind_id" field in the mutation.
func (m *ProgramHistoryMutation) ProgramKindID() (r string, exists bool) {
	v := m.program_kind_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProgramKindID returns the old "program_kind_id" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldProgramKindID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgramKindID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgramKindID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgramKindID: %w", err)
	}
	return oldValue.ProgramKindID, nil
}

// ClearProgramKindID clears the value of the "program_kind_id" field.
func (m *ProgramHistoryMutation) ClearProgramKindID() {
	m.program_kind_id = nil
	m.clearedFields[programhistory.FieldProgramKindID] = struct{}{}
}

// ProgramKindIDCleared returns if the "program_kind_id" field was cleared in this mutation.
func (m *ProgramHistoryMutation) ProgramKindIDCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldProgramKindID]
	return ok
}

// ResetProgramKindID resets all changes to the "program_kind_id" field.
func (m *ProgramHistoryMutation) ResetProgramKindID() {
	m.program_kind_id = nil
	delete(m.clearedFields, programhistory.FieldProgramKindID)
}

// SetName sets the "name" field.
func (m *ProgramHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProgramHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProgramHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProgramHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProgramHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProgramHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[programhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProgramHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProgramHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, programhistory.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *ProgramHistoryMutation) SetStatus(es enums.ProgramStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *ProgramHistoryMutation) Status() (r enums.ProgramStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldStatus(ctx context.Context) (v enums.ProgramStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProgramHistoryMutation) ResetStatus() {
	m.status = nil
}

// SetProgramType sets the "program_type" field.
func (m *ProgramHistoryMutation) SetProgramType(et enums.ProgramType) {
	m.program_type = &et
}

// ProgramType returns the value of the "program_type" field in the mutation.
func (m *ProgramHistoryMutation) ProgramType() (r enums.ProgramType, exists bool) {
	v := m.program_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProgramType returns the old "program_type" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldProgramType(ctx context.Context) (v enums.ProgramType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgramType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgramType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgramType: %w", err)
	}
	return oldValue.ProgramType, nil
}

// ResetProgramType resets all changes to the "program_type" field.
func (m *ProgramHistoryMutation) ResetProgramType() {
	m.program_type = nil
}

// SetFrameworkName sets the "framework_name" field.
func (m *ProgramHistoryMutation) SetFrameworkName(s string) {
	m.framework_name = &s
}

// FrameworkName returns the value of the "framework_name" field in the mutation.
func (m *ProgramHistoryMutation) FrameworkName() (r string, exists bool) {
	v := m.framework_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFrameworkName returns the old "framework_name" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldFrameworkName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrameworkName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrameworkName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrameworkName: %w", err)
	}
	return oldValue.FrameworkName, nil
}

// ClearFrameworkName clears the value of the "framework_name" field.
func (m *ProgramHistoryMutation) ClearFrameworkName() {
	m.framework_name = nil
	m.clearedFields[programhistory.FieldFrameworkName] = struct{}{}
}

// FrameworkNameCleared returns if the "framework_name" field was cleared in this mutation.
func (m *ProgramHistoryMutation) FrameworkNameCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldFrameworkName]
	return ok
}

// ResetFrameworkName resets all changes to the "framework_name" field.
func (m *ProgramHistoryMutation) ResetFrameworkName() {
	m.framework_name = nil
	delete(m.clearedFields, programhistory.FieldFrameworkName)
}

// SetStartDate sets the "start_date" field.
func (m *ProgramHistoryMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ProgramHistoryMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *ProgramHistoryMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[programhistory.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *ProgramHistoryMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ProgramHistoryMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, programhistory.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *ProgramHistoryMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ProgramHistoryMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ProgramHistoryMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[programhistory.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ProgramHistoryMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ProgramHistoryMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, programhistory.FieldEndDate)
}

// SetAuditorReady sets the "auditor_ready" field.
func (m *ProgramHistoryMutation) SetAuditorReady(b bool) {
	m.auditor_ready = &b
}

// AuditorReady returns the value of the "auditor_ready" field in the mutation.
func (m *ProgramHistoryMutation) AuditorReady() (r bool, exists bool) {
	v := m.auditor_ready
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditorReady returns the old "auditor_ready" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldAuditorReady(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditorReady is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditorReady requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditorReady: %w", err)
	}
	return oldValue.AuditorReady, nil
}

// ResetAuditorReady resets all changes to the "auditor_ready" field.
func (m *ProgramHistoryMutation) ResetAuditorReady() {
	m.auditor_ready = nil
}

// SetAuditorWriteComments sets the "auditor_write_comments" field.
func (m *ProgramHistoryMutation) SetAuditorWriteComments(b bool) {
	m.auditor_write_comments = &b
}

// AuditorWriteComments returns the value of the "auditor_write_comments" field in the mutation.
func (m *ProgramHistoryMutation) AuditorWriteComments() (r bool, exists bool) {
	v := m.auditor_write_comments
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditorWriteComments returns the old "auditor_write_comments" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldAuditorWriteComments(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditorWriteComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditorWriteComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditorWriteComments: %w", err)
	}
	return oldValue.AuditorWriteComments, nil
}

// ResetAuditorWriteComments resets all changes to the "auditor_write_comments" field.
func (m *ProgramHistoryMutation) ResetAuditorWriteComments() {
	m.auditor_write_comments = nil
}

// SetAuditorReadComments sets the "auditor_read_comments" field.
func (m *ProgramHistoryMutation) SetAuditorReadComments(b bool) {
	m.auditor_read_comments = &b
}

// AuditorReadComments returns the value of the "auditor_read_comments" field in the mutation.
func (m *ProgramHistoryMutation) AuditorReadComments() (r bool, exists bool) {
	v := m.auditor_read_comments
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditorReadComments returns the old "auditor_read_comments" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldAuditorReadComments(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditorReadComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditorReadComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditorReadComments: %w", err)
	}
	return oldValue.AuditorReadComments, nil
}

// ResetAuditorReadComments resets all changes to the "auditor_read_comments" field.
func (m *ProgramHistoryMutation) ResetAuditorReadComments() {
	m.auditor_read_comments = nil
}

// SetAuditFirm sets the "audit_firm" field.
func (m *ProgramHistoryMutation) SetAuditFirm(s string) {
	m.audit_firm = &s
}

// AuditFirm returns the value of the "audit_firm" field in the mutation.
func (m *ProgramHistoryMutation) AuditFirm() (r string, exists bool) {
	v := m.audit_firm
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditFirm returns the old "audit_firm" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldAuditFirm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditFirm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditFirm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditFirm: %w", err)
	}
	return oldValue.AuditFirm, nil
}

// ClearAuditFirm clears the value of the "audit_firm" field.
func (m *ProgramHistoryMutation) ClearAuditFirm() {
	m.audit_firm = nil
	m.clearedFields[programhistory.FieldAuditFirm] = struct{}{}
}

// AuditFirmCleared returns if the "audit_firm" field was cleared in this mutation.
func (m *ProgramHistoryMutation) AuditFirmCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldAuditFirm]
	return ok
}

// ResetAuditFirm resets all changes to the "audit_firm" field.
func (m *ProgramHistoryMutation) ResetAuditFirm() {
	m.audit_firm = nil
	delete(m.clearedFields, programhistory.FieldAuditFirm)
}

// SetAuditor sets the "auditor" field.
func (m *ProgramHistoryMutation) SetAuditor(s string) {
	m.auditor = &s
}

// Auditor returns the value of the "auditor" field in the mutation.
func (m *ProgramHistoryMutation) Auditor() (r string, exists bool) {
	v := m.auditor
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditor returns the old "auditor" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldAuditor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditor: %w", err)
	}
	return oldValue.Auditor, nil
}

// ClearAuditor clears the value of the "auditor" field.
func (m *ProgramHistoryMutation) ClearAuditor() {
	m.auditor = nil
	m.clearedFields[programhistory.FieldAuditor] = struct{}{}
}

// AuditorCleared returns if the "auditor" field was cleared in this mutation.
func (m *ProgramHistoryMutation) AuditorCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldAuditor]
	return ok
}

// ResetAuditor resets all changes to the "auditor" field.
func (m *ProgramHistoryMutation) ResetAuditor() {
	m.auditor = nil
	delete(m.clearedFields, programhistory.FieldAuditor)
}

// SetAuditorEmail sets the "auditor_email" field.
func (m *ProgramHistoryMutation) SetAuditorEmail(s string) {
	m.auditor_email = &s
}

// AuditorEmail returns the value of the "auditor_email" field in the mutation.
func (m *ProgramHistoryMutation) AuditorEmail() (r string, exists bool) {
	v := m.auditor_email
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditorEmail returns the old "auditor_email" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldAuditorEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditorEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditorEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditorEmail: %w", err)
	}
	return oldValue.AuditorEmail, nil
}

// ClearAuditorEmail clears the value of the "auditor_email" field.
func (m *ProgramHistoryMutation) ClearAuditorEmail() {
	m.auditor_email = nil
	m.clearedFields[programhistory.FieldAuditorEmail] = struct{}{}
}

// AuditorEmailCleared returns if the "auditor_email" field was cleared in this mutation.
func (m *ProgramHistoryMutation) AuditorEmailCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldAuditorEmail]
	return ok
}

// ResetAuditorEmail resets all changes to the "auditor_email" field.
func (m *ProgramHistoryMutation) ResetAuditorEmail() {
	m.auditor_email = nil
	delete(m.clearedFields, programhistory.FieldAuditorEmail)
}

// SetProgramOwnerID sets the "program_owner_id" field.
func (m *ProgramHistoryMutation) SetProgramOwnerID(s string) {
	m.program_owner_id = &s
}

// ProgramOwnerID returns the value of the "program_owner_id" field in the mutation.
func (m *ProgramHistoryMutation) ProgramOwnerID() (r string, exists bool) {
	v := m.program_owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProgramOwnerID returns the old "program_owner_id" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldProgramOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgramOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgramOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgramOwnerID: %w", err)
	}
	return oldValue.ProgramOwnerID, nil
}

// ClearProgramOwnerID clears the value of the "program_owner_id" field.
func (m *ProgramHistoryMutation) ClearProgramOwnerID() {
	m.program_owner_id = nil
	m.clearedFields[programhistory.FieldProgramOwnerID] = struct{}{}
}

// ProgramOwnerIDCleared returns if the "program_owner_id" field was cleared in this mutation.
func (m *ProgramHistoryMutation) ProgramOwnerIDCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldProgramOwnerID]
	return ok
}

// ResetProgramOwnerID resets all changes to the "program_owner_id" field.
func (m *ProgramHistoryMutation) ResetProgramOwnerID() {
	m.program_owner_id = nil
	delete(m.clearedFields, programhistory.FieldProgramOwnerID)
}

// Where appends a list predicates to the ProgramHistoryMutation builder.
func (m *ProgramHistoryMutation) Where(ps ...predicate.ProgramHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProgramHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProgramHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProgramHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProgramHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProgramHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProgramHistory).
func (m *ProgramHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProgramHistoryMutation) Fields() []string {
	fields := make([]string, 0, 28)
	if m.history_time != nil {
		fields = append(fields, programhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, programhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, programhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, programhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, programhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, programhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, programhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, programhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, programhistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, programhistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, programhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, programhistory.FieldOwnerID)
	}
	if m.program_kind_name != nil {
		fields = append(fields, programhistory.FieldProgramKindName)
	}
	if m.program_kind_id != nil {
		fields = append(fields, programhistory.FieldProgramKindID)
	}
	if m.name != nil {
		fields = append(fields, programhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, programhistory.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, programhistory.FieldStatus)
	}
	if m.program_type != nil {
		fields = append(fields, programhistory.FieldProgramType)
	}
	if m.framework_name != nil {
		fields = append(fields, programhistory.FieldFrameworkName)
	}
	if m.start_date != nil {
		fields = append(fields, programhistory.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, programhistory.FieldEndDate)
	}
	if m.auditor_ready != nil {
		fields = append(fields, programhistory.FieldAuditorReady)
	}
	if m.auditor_write_comments != nil {
		fields = append(fields, programhistory.FieldAuditorWriteComments)
	}
	if m.auditor_read_comments != nil {
		fields = append(fields, programhistory.FieldAuditorReadComments)
	}
	if m.audit_firm != nil {
		fields = append(fields, programhistory.FieldAuditFirm)
	}
	if m.auditor != nil {
		fields = append(fields, programhistory.FieldAuditor)
	}
	if m.auditor_email != nil {
		fields = append(fields, programhistory.FieldAuditorEmail)
	}
	if m.program_owner_id != nil {
		fields = append(fields, programhistory.FieldProgramOwnerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProgramHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case programhistory.FieldHistoryTime:
		return m.HistoryTime()
	case programhistory.FieldRef:
		return m.Ref()
	case programhistory.FieldOperation:
		return m.Operation()
	case programhistory.FieldCreatedAt:
		return m.CreatedAt()
	case programhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case programhistory.FieldCreatedBy:
		return m.CreatedBy()
	case programhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case programhistory.FieldDeletedAt:
		return m.DeletedAt()
	case programhistory.FieldDeletedBy:
		return m.DeletedBy()
	case programhistory.FieldDisplayID:
		return m.DisplayID()
	case programhistory.FieldTags:
		return m.Tags()
	case programhistory.FieldOwnerID:
		return m.OwnerID()
	case programhistory.FieldProgramKindName:
		return m.ProgramKindName()
	case programhistory.FieldProgramKindID:
		return m.ProgramKindID()
	case programhistory.FieldName:
		return m.Name()
	case programhistory.FieldDescription:
		return m.Description()
	case programhistory.FieldStatus:
		return m.Status()
	case programhistory.FieldProgramType:
		return m.ProgramType()
	case programhistory.FieldFrameworkName:
		return m.FrameworkName()
	case programhistory.FieldStartDate:
		return m.StartDate()
	case programhistory.FieldEndDate:
		return m.EndDate()
	case programhistory.FieldAuditorReady:
		return m.AuditorReady()
	case programhistory.FieldAuditorWriteComments:
		return m.AuditorWriteComments()
	case programhistory.FieldAuditorReadComments:
		return m.AuditorReadComments()
	case programhistory.FieldAuditFirm:
		return m.AuditFirm()
	case programhistory.FieldAuditor:
		return m.Auditor()
	case programhistory.FieldAuditorEmail:
		return m.AuditorEmail()
	case programhistory.FieldProgramOwnerID:
		return m.ProgramOwnerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProgramHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case programhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case programhistory.FieldRef:
		return m.OldRef(ctx)
	case programhistory.FieldOperation:
		return m.OldOperation(ctx)
	case programhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case programhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case programhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case programhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case programhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case programhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case programhistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case programhistory.FieldTags:
		return m.OldTags(ctx)
	case programhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case programhistory.FieldProgramKindName:
		return m.OldProgramKindName(ctx)
	case programhistory.FieldProgramKindID:
		return m.OldProgramKindID(ctx)
	case programhistory.FieldName:
		return m.OldName(ctx)
	case programhistory.FieldDescription:
		return m.OldDescription(ctx)
	case programhistory.FieldStatus:
		return m.OldStatus(ctx)
	case programhistory.FieldProgramType:
		return m.OldProgramType(ctx)
	case programhistory.FieldFrameworkName:
		return m.OldFrameworkName(ctx)
	case programhistory.FieldStartDate:
		return m.OldStartDate(ctx)
	case programhistory.FieldEndDate:
		return m.OldEndDate(ctx)
	case programhistory.FieldAuditorReady:
		return m.OldAuditorReady(ctx)
	case programhistory.FieldAuditorWriteComments:
		return m.OldAuditorWriteComments(ctx)
	case programhistory.FieldAuditorReadComments:
		return m.OldAuditorReadComments(ctx)
	case programhistory.FieldAuditFirm:
		return m.OldAuditFirm(ctx)
	case programhistory.FieldAuditor:
		return m.OldAuditor(ctx)
	case programhistory.FieldAuditorEmail:
		return m.OldAuditorEmail(ctx)
	case programhistory.FieldProgramOwnerID:
		return m.OldProgramOwnerID(ctx)
	}
	return nil, fmt.Errorf("unknown ProgramHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case programhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case programhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case programhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case programhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case programhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case programhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case programhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case programhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case programhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case programhistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case programhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case programhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case programhistory.FieldProgramKindName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgramKindName(v)
		return nil
	case programhistory.FieldProgramKindID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgramKindID(v)
		return nil
	case programhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case programhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case programhistory.FieldStatus:
		v, ok := value.(enums.ProgramStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case programhistory.FieldProgramType:
		v, ok := value.(enums.ProgramType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgramType(v)
		return nil
	case programhistory.FieldFrameworkName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrameworkName(v)
		return nil
	case programhistory.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case programhistory.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case programhistory.FieldAuditorReady:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditorReady(v)
		return nil
	case programhistory.FieldAuditorWriteComments:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditorWriteComments(v)
		return nil
	case programhistory.FieldAuditorReadComments:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditorReadComments(v)
		return nil
	case programhistory.FieldAuditFirm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditFirm(v)
		return nil
	case programhistory.FieldAuditor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditor(v)
		return nil
	case programhistory.FieldAuditorEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditorEmail(v)
		return nil
	case programhistory.FieldProgramOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgramOwnerID(v)
		return nil
	}
	return fmt.Errorf("unknown ProgramHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProgramHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProgramHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProgramHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProgramHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(programhistory.FieldRef) {
		fields = append(fields, programhistory.FieldRef)
	}
	if m.FieldCleared(programhistory.FieldCreatedAt) {
		fields = append(fields, programhistory.FieldCreatedAt)
	}
	if m.FieldCleared(programhistory.FieldUpdatedAt) {
		fields = append(fields, programhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(programhistory.FieldCreatedBy) {
		fields = append(fields, programhistory.FieldCreatedBy)
	}
	if m.FieldCleared(programhistory.FieldUpdatedBy) {
		fields = append(fields, programhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(programhistory.FieldDeletedAt) {
		fields = append(fields, programhistory.FieldDeletedAt)
	}
	if m.FieldCleared(programhistory.FieldDeletedBy) {
		fields = append(fields, programhistory.FieldDeletedBy)
	}
	if m.FieldCleared(programhistory.FieldTags) {
		fields = append(fields, programhistory.FieldTags)
	}
	if m.FieldCleared(programhistory.FieldOwnerID) {
		fields = append(fields, programhistory.FieldOwnerID)
	}
	if m.FieldCleared(programhistory.FieldProgramKindName) {
		fields = append(fields, programhistory.FieldProgramKindName)
	}
	if m.FieldCleared(programhistory.FieldProgramKindID) {
		fields = append(fields, programhistory.FieldProgramKindID)
	}
	if m.FieldCleared(programhistory.FieldDescription) {
		fields = append(fields, programhistory.FieldDescription)
	}
	if m.FieldCleared(programhistory.FieldFrameworkName) {
		fields = append(fields, programhistory.FieldFrameworkName)
	}
	if m.FieldCleared(programhistory.FieldStartDate) {
		fields = append(fields, programhistory.FieldStartDate)
	}
	if m.FieldCleared(programhistory.FieldEndDate) {
		fields = append(fields, programhistory.FieldEndDate)
	}
	if m.FieldCleared(programhistory.FieldAuditFirm) {
		fields = append(fields, programhistory.FieldAuditFirm)
	}
	if m.FieldCleared(programhistory.FieldAuditor) {
		fields = append(fields, programhistory.FieldAuditor)
	}
	if m.FieldCleared(programhistory.FieldAuditorEmail) {
		fields = append(fields, programhistory.FieldAuditorEmail)
	}
	if m.FieldCleared(programhistory.FieldProgramOwnerID) {
		fields = append(fields, programhistory.FieldProgramOwnerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProgramHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProgramHistoryMutation) ClearField(name string) error {
	switch name {
	case programhistory.FieldRef:
		m.ClearRef()
		return nil
	case programhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case programhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case programhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case programhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case programhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case programhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case programhistory.FieldTags:
		m.ClearTags()
		return nil
	case programhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case programhistory.FieldProgramKindName:
		m.ClearProgramKindName()
		return nil
	case programhistory.FieldProgramKindID:
		m.ClearProgramKindID()
		return nil
	case programhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case programhistory.FieldFrameworkName:
		m.ClearFrameworkName()
		return nil
	case programhistory.FieldStartDate:
		m.ClearStartDate()
		return nil
	case programhistory.FieldEndDate:
		m.ClearEndDate()
		return nil
	case programhistory.FieldAuditFirm:
		m.ClearAuditFirm()
		return nil
	case programhistory.FieldAuditor:
		m.ClearAuditor()
		return nil
	case programhistory.FieldAuditorEmail:
		m.ClearAuditorEmail()
		return nil
	case programhistory.FieldProgramOwnerID:
		m.ClearProgramOwnerID()
		return nil
	}
	return fmt.Errorf("unknown ProgramHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProgramHistoryMutation) ResetField(name string) error {
	switch name {
	case programhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case programhistory.FieldRef:
		m.ResetRef()
		return nil
	case programhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case programhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case programhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case programhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case programhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case programhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case programhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case programhistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case programhistory.FieldTags:
		m.ResetTags()
		return nil
	case programhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case programhistory.FieldProgramKindName:
		m.ResetProgramKindName()
		return nil
	case programhistory.FieldProgramKindID:
		m.ResetProgramKindID()
		return nil
	case programhistory.FieldName:
		m.ResetName()
		return nil
	case programhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case programhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case programhistory.FieldProgramType:
		m.ResetProgramType()
		return nil
	case programhistory.FieldFrameworkName:
		m.ResetFrameworkName()
		return nil
	case programhistory.FieldStartDate:
		m.ResetStartDate()
		return nil
	case programhistory.FieldEndDate:
		m.ResetEndDate()
		return nil
	case programhistory.FieldAuditorReady:
		m.ResetAuditorReady()
		return nil
	case programhistory.FieldAuditorWriteComments:
		m.ResetAuditorWriteComments()
		return nil
	case programhistory.FieldAuditorReadComments:
		m.ResetAuditorReadComments()
		return nil
	case programhistory.FieldAuditFirm:
		m.ResetAuditFirm()
		return nil
	case programhistory.FieldAuditor:
		m.ResetAuditor()
		return nil
	case programhistory.FieldAuditorEmail:
		m.ResetAuditorEmail()
		return nil
	case programhistory.FieldProgramOwnerID:
		m.ResetProgramOwnerID()
		return nil
	}
	return fmt.Errorf("unknown ProgramHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProgramHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProgramHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProgramHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProgramHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProgramHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProgramHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProgramHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProgramHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProgramHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProgramHistory edge %s", name)
}

// ProgramMembershipHistoryMutation represents an operation that mutates the ProgramMembershipHistory nodes in the graph.
type ProgramMembershipHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	role          *enums.Role
	program_id    *string
	user_id       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ProgramMembershipHistory, error)
	predicates    []predicate.ProgramMembershipHistory
}

var _ ent.Mutation = (*ProgramMembershipHistoryMutation)(nil)

// programmembershiphistoryOption allows management of the mutation configuration using functional options.
type programmembershiphistoryOption func(*ProgramMembershipHistoryMutation)

// newProgramMembershipHistoryMutation creates new mutation for the ProgramMembershipHistory entity.
func newProgramMembershipHistoryMutation(c config, op Op, opts ...programmembershiphistoryOption) *ProgramMembershipHistoryMutation {
	m := &ProgramMembershipHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProgramMembershipHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProgramMembershipHistoryID sets the ID field of the mutation.
func withProgramMembershipHistoryID(id string) programmembershiphistoryOption {
	return func(m *ProgramMembershipHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProgramMembershipHistory
		)
		m.oldValue = func(ctx context.Context) (*ProgramMembershipHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProgramMembershipHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProgramMembershipHistory sets the old ProgramMembershipHistory of the mutation.
func withProgramMembershipHistory(node *ProgramMembershipHistory) programmembershiphistoryOption {
	return func(m *ProgramMembershipHistoryMutation) {
		m.oldValue = func(context.Context) (*ProgramMembershipHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProgramMembershipHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProgramMembershipHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProgramMembershipHistory entities.
func (m *ProgramMembershipHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProgramMembershipHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProgramMembershipHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProgramMembershipHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ProgramMembershipHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ProgramMembershipHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ProgramMembershipHistory entity.
// If the ProgramMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMembershipHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ProgramMembershipHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ProgramMembershipHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ProgramMembershipHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ProgramMembershipHistory entity.
// If the ProgramMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMembershipHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ProgramMembershipHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[programmembershiphistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ProgramMembershipHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[programmembershiphistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ProgramMembershipHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, programmembershiphistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ProgramMembershipHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ProgramMembershipHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ProgramMembershipHistory entity.
// If the ProgramMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMembershipHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ProgramMembershipHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProgramMembershipHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProgramMembershipHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProgramMembershipHistory entity.
// If the ProgramMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMembershipHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProgramMembershipHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[programmembershiphistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProgramMembershipHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[programmembershiphistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProgramMembershipHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, programmembershiphistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProgramMembershipHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProgramMembershipHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProgramMembershipHistory entity.
// If the ProgramMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMembershipHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProgramMembershipHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[programmembershiphistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProgramMembershipHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[programmembershiphistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProgramMembershipHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, programmembershiphistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ProgramMembershipHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProgramMembershipHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProgramMembershipHistory entity.
// If the ProgramMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMembershipHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProgramMembershipHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[programmembershiphistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProgramMembershipHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[programmembershiphistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProgramMembershipHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, programmembershiphistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProgramMembershipHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProgramMembershipHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProgramMembershipHistory entity.
// If the ProgramMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMembershipHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProgramMembershipHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[programmembershiphistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProgramMembershipHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[programmembershiphistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProgramMembershipHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, programmembershiphistory.FieldUpdatedBy)
}

// SetRole sets the "role" field.
func (m *ProgramMembershipHistoryMutation) SetRole(e enums.Role) {
	m.role = &e
}

// Role returns the value of the "role" field in the mutation.
func (m *ProgramMembershipHistoryMutation) Role() (r enums.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the ProgramMembershipHistory entity.
// If the ProgramMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMembershipHistoryMutation) OldRole(ctx context.Context) (v enums.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *ProgramMembershipHistoryMutation) ResetRole() {
	m.role = nil
}

// SetProgramID sets the "program_id" field.
func (m *ProgramMembershipHistoryMutation) SetProgramID(s string) {
	m.program_id = &s
}

// ProgramID returns the value of the "program_id" field in the mutation.
func (m *ProgramMembershipHistoryMutation) ProgramID() (r string, exists bool) {
	v := m.program_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProgramID returns the old "program_id" field's value of the ProgramMembershipHistory entity.
// If the ProgramMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMembershipHistoryMutation) OldProgramID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgramID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgramID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgramID: %w", err)
	}
	return oldValue.ProgramID, nil
}

// ResetProgramID resets all changes to the "program_id" field.
func (m *ProgramMembershipHistoryMutation) ResetProgramID() {
	m.program_id = nil
}

// SetUserID sets the "user_id" field.
func (m *ProgramMembershipHistoryMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProgramMembershipHistoryMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ProgramMembershipHistory entity.
// If the ProgramMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMembershipHistoryMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProgramMembershipHistoryMutation) ResetUserID() {
	m.user_id = nil
}

// Where appends a list predicates to the ProgramMembershipHistoryMutation builder.
func (m *ProgramMembershipHistoryMutation) Where(ps ...predicate.ProgramMembershipHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProgramMembershipHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProgramMembershipHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProgramMembershipHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProgramMembershipHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProgramMembershipHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProgramMembershipHistory).
func (m *ProgramMembershipHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProgramMembershipHistoryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.history_time != nil {
		fields = append(fields, programmembershiphistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, programmembershiphistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, programmembershiphistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, programmembershiphistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, programmembershiphistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, programmembershiphistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, programmembershiphistory.FieldUpdatedBy)
	}
	if m.role != nil {
		fields = append(fields, programmembershiphistory.FieldRole)
	}
	if m.program_id != nil {
		fields = append(fields, programmembershiphistory.FieldProgramID)
	}
	if m.user_id != nil {
		fields = append(fields, programmembershiphistory.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProgramMembershipHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case programmembershiphistory.FieldHistoryTime:
		return m.HistoryTime()
	case programmembershiphistory.FieldRef:
		return m.Ref()
	case programmembershiphistory.FieldOperation:
		return m.Operation()
	case programmembershiphistory.FieldCreatedAt:
		return m.CreatedAt()
	case programmembershiphistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case programmembershiphistory.FieldCreatedBy:
		return m.CreatedBy()
	case programmembershiphistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case programmembershiphistory.FieldRole:
		return m.Role()
	case programmembershiphistory.FieldProgramID:
		return m.ProgramID()
	case programmembershiphistory.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProgramMembershipHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case programmembershiphistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case programmembershiphistory.FieldRef:
		return m.OldRef(ctx)
	case programmembershiphistory.FieldOperation:
		return m.OldOperation(ctx)
	case programmembershiphistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case programmembershiphistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case programmembershiphistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case programmembershiphistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case programmembershiphistory.FieldRole:
		return m.OldRole(ctx)
	case programmembershiphistory.FieldProgramID:
		return m.OldProgramID(ctx)
	case programmembershiphistory.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown ProgramMembershipHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramMembershipHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case programmembershiphistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case programmembershiphistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case programmembershiphistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case programmembershiphistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case programmembershiphistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case programmembershiphistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case programmembershiphistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case programmembershiphistory.FieldRole:
		v, ok := value.(enums.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case programmembershiphistory.FieldProgramID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgramID(v)
		return nil
	case programmembershiphistory.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown ProgramMembershipHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProgramMembershipHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProgramMembershipHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramMembershipHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProgramMembershipHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProgramMembershipHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(programmembershiphistory.FieldRef) {
		fields = append(fields, programmembershiphistory.FieldRef)
	}
	if m.FieldCleared(programmembershiphistory.FieldCreatedAt) {
		fields = append(fields, programmembershiphistory.FieldCreatedAt)
	}
	if m.FieldCleared(programmembershiphistory.FieldUpdatedAt) {
		fields = append(fields, programmembershiphistory.FieldUpdatedAt)
	}
	if m.FieldCleared(programmembershiphistory.FieldCreatedBy) {
		fields = append(fields, programmembershiphistory.FieldCreatedBy)
	}
	if m.FieldCleared(programmembershiphistory.FieldUpdatedBy) {
		fields = append(fields, programmembershiphistory.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProgramMembershipHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProgramMembershipHistoryMutation) ClearField(name string) error {
	switch name {
	case programmembershiphistory.FieldRef:
		m.ClearRef()
		return nil
	case programmembershiphistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case programmembershiphistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case programmembershiphistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case programmembershiphistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown ProgramMembershipHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProgramMembershipHistoryMutation) ResetField(name string) error {
	switch name {
	case programmembershiphistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case programmembershiphistory.FieldRef:
		m.ResetRef()
		return nil
	case programmembershiphistory.FieldOperation:
		m.ResetOperation()
		return nil
	case programmembershiphistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case programmembershiphistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case programmembershiphistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case programmembershiphistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case programmembershiphistory.FieldRole:
		m.ResetRole()
		return nil
	case programmembershiphistory.FieldProgramID:
		m.ResetProgramID()
		return nil
	case programmembershiphistory.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown ProgramMembershipHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProgramMembershipHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProgramMembershipHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProgramMembershipHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProgramMembershipHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProgramMembershipHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProgramMembershipHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProgramMembershipHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProgramMembershipHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProgramMembershipHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProgramMembershipHistory edge %s", name)
}

// RemediationHistoryMutation represents an operation that mutates the RemediationHistory nodes in the graph.
type RemediationHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	history_time       *time.Time
	ref                *string
	operation          *history.OpType
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	deleted_at         *time.Time
	deleted_by         *string
	display_id         *string
	tags               *[]string
	appendtags         []string
	owner_id           *string
	system_owned       *bool
	internal_notes     *string
	system_internal_id *string
	external_id        *string
	external_owner_id  *string
	title              *string
	state              *string
	intent             *string
	summary            *string
	explanation        *string
	instructions       *string
	owner_reference    *string
	repository_uri     *string
	pull_request_uri   *string
	ticket_reference   *string
	due_at             *models.DateTime
	completed_at       *models.DateTime
	pr_generated_at    *models.DateTime
	error              *string
	source             *string
	external_uri       *string
	metadata           *map[string]interface{}
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*RemediationHistory, error)
	predicates         []predicate.RemediationHistory
}

var _ ent.Mutation = (*RemediationHistoryMutation)(nil)

// remediationhistoryOption allows management of the mutation configuration using functional options.
type remediationhistoryOption func(*RemediationHistoryMutation)

// newRemediationHistoryMutation creates new mutation for the RemediationHistory entity.
func newRemediationHistoryMutation(c config, op Op, opts ...remediationhistoryOption) *RemediationHistoryMutation {
	m := &RemediationHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRemediationHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRemediationHistoryID sets the ID field of the mutation.
func withRemediationHistoryID(id string) remediationhistoryOption {
	return func(m *RemediationHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *RemediationHistory
		)
		m.oldValue = func(ctx context.Context) (*RemediationHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RemediationHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRemediationHistory sets the old RemediationHistory of the mutation.
func withRemediationHistory(node *RemediationHistory) remediationhistoryOption {
	return func(m *RemediationHistoryMutation) {
		m.oldValue = func(context.Context) (*RemediationHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RemediationHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RemediationHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RemediationHistory entities.
func (m *RemediationHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RemediationHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RemediationHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RemediationHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *RemediationHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *RemediationHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *RemediationHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *RemediationHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *RemediationHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *RemediationHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[remediationhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *RemediationHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *RemediationHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, remediationhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *RemediationHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *RemediationHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *RemediationHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RemediationHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RemediationHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RemediationHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[remediationhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RemediationHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RemediationHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, remediationhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RemediationHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RemediationHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RemediationHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[remediationhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RemediationHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RemediationHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, remediationhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *RemediationHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RemediationHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RemediationHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[remediationhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RemediationHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RemediationHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, remediationhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RemediationHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RemediationHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *RemediationHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[remediationhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *RemediationHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RemediationHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, remediationhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RemediationHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RemediationHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RemediationHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[remediationhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RemediationHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RemediationHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, remediationhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *RemediationHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *RemediationHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *RemediationHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[remediationhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *RemediationHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *RemediationHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, remediationhistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *RemediationHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *RemediationHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *RemediationHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *RemediationHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *RemediationHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *RemediationHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *RemediationHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *RemediationHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[remediationhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *RemediationHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *RemediationHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, remediationhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *RemediationHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *RemediationHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *RemediationHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[remediationhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *RemediationHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *RemediationHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, remediationhistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *RemediationHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *RemediationHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *RemediationHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[remediationhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *RemediationHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *RemediationHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, remediationhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *RemediationHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *RemediationHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *RemediationHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[remediationhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *RemediationHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *RemediationHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, remediationhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *RemediationHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *RemediationHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *RemediationHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[remediationhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *RemediationHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *RemediationHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, remediationhistory.FieldSystemInternalID)
}

// SetExternalID sets the "external_id" field.
func (m *RemediationHistoryMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *RemediationHistoryMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *RemediationHistoryMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[remediationhistory.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *RemediationHistoryMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *RemediationHistoryMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, remediationhistory.FieldExternalID)
}

// SetExternalOwnerID sets the "external_owner_id" field.
func (m *RemediationHistoryMutation) SetExternalOwnerID(s string) {
	m.external_owner_id = &s
}

// ExternalOwnerID returns the value of the "external_owner_id" field in the mutation.
func (m *RemediationHistoryMutation) ExternalOwnerID() (r string, exists bool) {
	v := m.external_owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalOwnerID returns the old "external_owner_id" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldExternalOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalOwnerID: %w", err)
	}
	return oldValue.ExternalOwnerID, nil
}

// ClearExternalOwnerID clears the value of the "external_owner_id" field.
func (m *RemediationHistoryMutation) ClearExternalOwnerID() {
	m.external_owner_id = nil
	m.clearedFields[remediationhistory.FieldExternalOwnerID] = struct{}{}
}

// ExternalOwnerIDCleared returns if the "external_owner_id" field was cleared in this mutation.
func (m *RemediationHistoryMutation) ExternalOwnerIDCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldExternalOwnerID]
	return ok
}

// ResetExternalOwnerID resets all changes to the "external_owner_id" field.
func (m *RemediationHistoryMutation) ResetExternalOwnerID() {
	m.external_owner_id = nil
	delete(m.clearedFields, remediationhistory.FieldExternalOwnerID)
}

// SetTitle sets the "title" field.
func (m *RemediationHistoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *RemediationHistoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *RemediationHistoryMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[remediationhistory.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *RemediationHistoryMutation) TitleCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *RemediationHistoryMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, remediationhistory.FieldTitle)
}

// SetState sets the "state" field.
func (m *RemediationHistoryMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *RemediationHistoryMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *RemediationHistoryMutation) ClearState() {
	m.state = nil
	m.clearedFields[remediationhistory.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *RemediationHistoryMutation) StateCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *RemediationHistoryMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, remediationhistory.FieldState)
}

// SetIntent sets the "intent" field.
func (m *RemediationHistoryMutation) SetIntent(s string) {
	m.intent = &s
}

// Intent returns the value of the "intent" field in the mutation.
func (m *RemediationHistoryMutation) Intent() (r string, exists bool) {
	v := m.intent
	if v == nil {
		return
	}
	return *v, true
}

// OldIntent returns the old "intent" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldIntent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntent: %w", err)
	}
	return oldValue.Intent, nil
}

// ClearIntent clears the value of the "intent" field.
func (m *RemediationHistoryMutation) ClearIntent() {
	m.intent = nil
	m.clearedFields[remediationhistory.FieldIntent] = struct{}{}
}

// IntentCleared returns if the "intent" field was cleared in this mutation.
func (m *RemediationHistoryMutation) IntentCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldIntent]
	return ok
}

// ResetIntent resets all changes to the "intent" field.
func (m *RemediationHistoryMutation) ResetIntent() {
	m.intent = nil
	delete(m.clearedFields, remediationhistory.FieldIntent)
}

// SetSummary sets the "summary" field.
func (m *RemediationHistoryMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *RemediationHistoryMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *RemediationHistoryMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[remediationhistory.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *RemediationHistoryMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *RemediationHistoryMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, remediationhistory.FieldSummary)
}

// SetExplanation sets the "explanation" field.
func (m *RemediationHistoryMutation) SetExplanation(s string) {
	m.explanation = &s
}

// Explanation returns the value of the "explanation" field in the mutation.
func (m *RemediationHistoryMutation) Explanation() (r string, exists bool) {
	v := m.explanation
	if v == nil {
		return
	}
	return *v, true
}

// OldExplanation returns the old "explanation" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldExplanation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExplanation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExplanation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExplanation: %w", err)
	}
	return oldValue.Explanation, nil
}

// ClearExplanation clears the value of the "explanation" field.
func (m *RemediationHistoryMutation) ClearExplanation() {
	m.explanation = nil
	m.clearedFields[remediationhistory.FieldExplanation] = struct{}{}
}

// ExplanationCleared returns if the "explanation" field was cleared in this mutation.
func (m *RemediationHistoryMutation) ExplanationCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldExplanation]
	return ok
}

// ResetExplanation resets all changes to the "explanation" field.
func (m *RemediationHistoryMutation) ResetExplanation() {
	m.explanation = nil
	delete(m.clearedFields, remediationhistory.FieldExplanation)
}

// SetInstructions sets the "instructions" field.
func (m *RemediationHistoryMutation) SetInstructions(s string) {
	m.instructions = &s
}

// Instructions returns the value of the "instructions" field in the mutation.
func (m *RemediationHistoryMutation) Instructions() (r string, exists bool) {
	v := m.instructions
	if v == nil {
		return
	}
	return *v, true
}

// OldInstructions returns the old "instructions" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldInstructions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstructions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstructions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstructions: %w", err)
	}
	return oldValue.Instructions, nil
}

// ClearInstructions clears the value of the "instructions" field.
func (m *RemediationHistoryMutation) ClearInstructions() {
	m.instructions = nil
	m.clearedFields[remediationhistory.FieldInstructions] = struct{}{}
}

// InstructionsCleared returns if the "instructions" field was cleared in this mutation.
func (m *RemediationHistoryMutation) InstructionsCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldInstructions]
	return ok
}

// ResetInstructions resets all changes to the "instructions" field.
func (m *RemediationHistoryMutation) ResetInstructions() {
	m.instructions = nil
	delete(m.clearedFields, remediationhistory.FieldInstructions)
}

// SetOwnerReference sets the "owner_reference" field.
func (m *RemediationHistoryMutation) SetOwnerReference(s string) {
	m.owner_reference = &s
}

// OwnerReference returns the value of the "owner_reference" field in the mutation.
func (m *RemediationHistoryMutation) OwnerReference() (r string, exists bool) {
	v := m.owner_reference
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerReference returns the old "owner_reference" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldOwnerReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerReference: %w", err)
	}
	return oldValue.OwnerReference, nil
}

// ClearOwnerReference clears the value of the "owner_reference" field.
func (m *RemediationHistoryMutation) ClearOwnerReference() {
	m.owner_reference = nil
	m.clearedFields[remediationhistory.FieldOwnerReference] = struct{}{}
}

// OwnerReferenceCleared returns if the "owner_reference" field was cleared in this mutation.
func (m *RemediationHistoryMutation) OwnerReferenceCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldOwnerReference]
	return ok
}

// ResetOwnerReference resets all changes to the "owner_reference" field.
func (m *RemediationHistoryMutation) ResetOwnerReference() {
	m.owner_reference = nil
	delete(m.clearedFields, remediationhistory.FieldOwnerReference)
}

// SetRepositoryURI sets the "repository_uri" field.
func (m *RemediationHistoryMutation) SetRepositoryURI(s string) {
	m.repository_uri = &s
}

// RepositoryURI returns the value of the "repository_uri" field in the mutation.
func (m *RemediationHistoryMutation) RepositoryURI() (r string, exists bool) {
	v := m.repository_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRepositoryURI returns the old "repository_uri" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldRepositoryURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepositoryURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepositoryURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepositoryURI: %w", err)
	}
	return oldValue.RepositoryURI, nil
}

// ClearRepositoryURI clears the value of the "repository_uri" field.
func (m *RemediationHistoryMutation) ClearRepositoryURI() {
	m.repository_uri = nil
	m.clearedFields[remediationhistory.FieldRepositoryURI] = struct{}{}
}

// RepositoryURICleared returns if the "repository_uri" field was cleared in this mutation.
func (m *RemediationHistoryMutation) RepositoryURICleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldRepositoryURI]
	return ok
}

// ResetRepositoryURI resets all changes to the "repository_uri" field.
func (m *RemediationHistoryMutation) ResetRepositoryURI() {
	m.repository_uri = nil
	delete(m.clearedFields, remediationhistory.FieldRepositoryURI)
}

// SetPullRequestURI sets the "pull_request_uri" field.
func (m *RemediationHistoryMutation) SetPullRequestURI(s string) {
	m.pull_request_uri = &s
}

// PullRequestURI returns the value of the "pull_request_uri" field in the mutation.
func (m *RemediationHistoryMutation) PullRequestURI() (r string, exists bool) {
	v := m.pull_request_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldPullRequestURI returns the old "pull_request_uri" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldPullRequestURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPullRequestURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPullRequestURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPullRequestURI: %w", err)
	}
	return oldValue.PullRequestURI, nil
}

// ClearPullRequestURI clears the value of the "pull_request_uri" field.
func (m *RemediationHistoryMutation) ClearPullRequestURI() {
	m.pull_request_uri = nil
	m.clearedFields[remediationhistory.FieldPullRequestURI] = struct{}{}
}

// PullRequestURICleared returns if the "pull_request_uri" field was cleared in this mutation.
func (m *RemediationHistoryMutation) PullRequestURICleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldPullRequestURI]
	return ok
}

// ResetPullRequestURI resets all changes to the "pull_request_uri" field.
func (m *RemediationHistoryMutation) ResetPullRequestURI() {
	m.pull_request_uri = nil
	delete(m.clearedFields, remediationhistory.FieldPullRequestURI)
}

// SetTicketReference sets the "ticket_reference" field.
func (m *RemediationHistoryMutation) SetTicketReference(s string) {
	m.ticket_reference = &s
}

// TicketReference returns the value of the "ticket_reference" field in the mutation.
func (m *RemediationHistoryMutation) TicketReference() (r string, exists bool) {
	v := m.ticket_reference
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketReference returns the old "ticket_reference" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldTicketReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketReference: %w", err)
	}
	return oldValue.TicketReference, nil
}

// ClearTicketReference clears the value of the "ticket_reference" field.
func (m *RemediationHistoryMutation) ClearTicketReference() {
	m.ticket_reference = nil
	m.clearedFields[remediationhistory.FieldTicketReference] = struct{}{}
}

// TicketReferenceCleared returns if the "ticket_reference" field was cleared in this mutation.
func (m *RemediationHistoryMutation) TicketReferenceCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldTicketReference]
	return ok
}

// ResetTicketReference resets all changes to the "ticket_reference" field.
func (m *RemediationHistoryMutation) ResetTicketReference() {
	m.ticket_reference = nil
	delete(m.clearedFields, remediationhistory.FieldTicketReference)
}

// SetDueAt sets the "due_at" field.
func (m *RemediationHistoryMutation) SetDueAt(mt models.DateTime) {
	m.due_at = &mt
}

// DueAt returns the value of the "due_at" field in the mutation.
func (m *RemediationHistoryMutation) DueAt() (r models.DateTime, exists bool) {
	v := m.due_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDueAt returns the old "due_at" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldDueAt(ctx context.Context) (v *models.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueAt: %w", err)
	}
	return oldValue.DueAt, nil
}

// ClearDueAt clears the value of the "due_at" field.
func (m *RemediationHistoryMutation) ClearDueAt() {
	m.due_at = nil
	m.clearedFields[remediationhistory.FieldDueAt] = struct{}{}
}

// DueAtCleared returns if the "due_at" field was cleared in this mutation.
func (m *RemediationHistoryMutation) DueAtCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldDueAt]
	return ok
}

// ResetDueAt resets all changes to the "due_at" field.
func (m *RemediationHistoryMutation) ResetDueAt() {
	m.due_at = nil
	delete(m.clearedFields, remediationhistory.FieldDueAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *RemediationHistoryMutation) SetCompletedAt(mt models.DateTime) {
	m.completed_at = &mt
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *RemediationHistoryMutation) CompletedAt() (r models.DateTime, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldCompletedAt(ctx context.Context) (v *models.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *RemediationHistoryMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[remediationhistory.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *RemediationHistoryMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *RemediationHistoryMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, remediationhistory.FieldCompletedAt)
}

// SetPrGeneratedAt sets the "pr_generated_at" field.
func (m *RemediationHistoryMutation) SetPrGeneratedAt(mt models.DateTime) {
	m.pr_generated_at = &mt
}

// PrGeneratedAt returns the value of the "pr_generated_at" field in the mutation.
func (m *RemediationHistoryMutation) PrGeneratedAt() (r models.DateTime, exists bool) {
	v := m.pr_generated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPrGeneratedAt returns the old "pr_generated_at" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldPrGeneratedAt(ctx context.Context) (v *models.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrGeneratedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrGeneratedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrGeneratedAt: %w", err)
	}
	return oldValue.PrGeneratedAt, nil
}

// ClearPrGeneratedAt clears the value of the "pr_generated_at" field.
func (m *RemediationHistoryMutation) ClearPrGeneratedAt() {
	m.pr_generated_at = nil
	m.clearedFields[remediationhistory.FieldPrGeneratedAt] = struct{}{}
}

// PrGeneratedAtCleared returns if the "pr_generated_at" field was cleared in this mutation.
func (m *RemediationHistoryMutation) PrGeneratedAtCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldPrGeneratedAt]
	return ok
}

// ResetPrGeneratedAt resets all changes to the "pr_generated_at" field.
func (m *RemediationHistoryMutation) ResetPrGeneratedAt() {
	m.pr_generated_at = nil
	delete(m.clearedFields, remediationhistory.FieldPrGeneratedAt)
}

// SetError sets the "error" field.
func (m *RemediationHistoryMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *RemediationHistoryMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *RemediationHistoryMutation) ClearError() {
	m.error = nil
	m.clearedFields[remediationhistory.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *RemediationHistoryMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *RemediationHistoryMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, remediationhistory.FieldError)
}

// SetSource sets the "source" field.
func (m *RemediationHistoryMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *RemediationHistoryMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *RemediationHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[remediationhistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *RemediationHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *RemediationHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, remediationhistory.FieldSource)
}

// SetExternalURI sets the "external_uri" field.
func (m *RemediationHistoryMutation) SetExternalURI(s string) {
	m.external_uri = &s
}

// ExternalURI returns the value of the "external_uri" field in the mutation.
func (m *RemediationHistoryMutation) ExternalURI() (r string, exists bool) {
	v := m.external_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalURI returns the old "external_uri" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldExternalURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalURI: %w", err)
	}
	return oldValue.ExternalURI, nil
}

// ClearExternalURI clears the value of the "external_uri" field.
func (m *RemediationHistoryMutation) ClearExternalURI() {
	m.external_uri = nil
	m.clearedFields[remediationhistory.FieldExternalURI] = struct{}{}
}

// ExternalURICleared returns if the "external_uri" field was cleared in this mutation.
func (m *RemediationHistoryMutation) ExternalURICleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldExternalURI]
	return ok
}

// ResetExternalURI resets all changes to the "external_uri" field.
func (m *RemediationHistoryMutation) ResetExternalURI() {
	m.external_uri = nil
	delete(m.clearedFields, remediationhistory.FieldExternalURI)
}

// SetMetadata sets the "metadata" field.
func (m *RemediationHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *RemediationHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the RemediationHistory entity.
// If the RemediationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *RemediationHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[remediationhistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *RemediationHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[remediationhistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *RemediationHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, remediationhistory.FieldMetadata)
}

// Where appends a list predicates to the RemediationHistoryMutation builder.
func (m *RemediationHistoryMutation) Where(ps ...predicate.RemediationHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RemediationHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RemediationHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RemediationHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RemediationHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RemediationHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RemediationHistory).
func (m *RemediationHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RemediationHistoryMutation) Fields() []string {
	fields := make([]string, 0, 34)
	if m.history_time != nil {
		fields = append(fields, remediationhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, remediationhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, remediationhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, remediationhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, remediationhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, remediationhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, remediationhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, remediationhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, remediationhistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, remediationhistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, remediationhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, remediationhistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, remediationhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, remediationhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, remediationhistory.FieldSystemInternalID)
	}
	if m.external_id != nil {
		fields = append(fields, remediationhistory.FieldExternalID)
	}
	if m.external_owner_id != nil {
		fields = append(fields, remediationhistory.FieldExternalOwnerID)
	}
	if m.title != nil {
		fields = append(fields, remediationhistory.FieldTitle)
	}
	if m.state != nil {
		fields = append(fields, remediationhistory.FieldState)
	}
	if m.intent != nil {
		fields = append(fields, remediationhistory.FieldIntent)
	}
	if m.summary != nil {
		fields = append(fields, remediationhistory.FieldSummary)
	}
	if m.explanation != nil {
		fields = append(fields, remediationhistory.FieldExplanation)
	}
	if m.instructions != nil {
		fields = append(fields, remediationhistory.FieldInstructions)
	}
	if m.owner_reference != nil {
		fields = append(fields, remediationhistory.FieldOwnerReference)
	}
	if m.repository_uri != nil {
		fields = append(fields, remediationhistory.FieldRepositoryURI)
	}
	if m.pull_request_uri != nil {
		fields = append(fields, remediationhistory.FieldPullRequestURI)
	}
	if m.ticket_reference != nil {
		fields = append(fields, remediationhistory.FieldTicketReference)
	}
	if m.due_at != nil {
		fields = append(fields, remediationhistory.FieldDueAt)
	}
	if m.completed_at != nil {
		fields = append(fields, remediationhistory.FieldCompletedAt)
	}
	if m.pr_generated_at != nil {
		fields = append(fields, remediationhistory.FieldPrGeneratedAt)
	}
	if m.error != nil {
		fields = append(fields, remediationhistory.FieldError)
	}
	if m.source != nil {
		fields = append(fields, remediationhistory.FieldSource)
	}
	if m.external_uri != nil {
		fields = append(fields, remediationhistory.FieldExternalURI)
	}
	if m.metadata != nil {
		fields = append(fields, remediationhistory.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RemediationHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case remediationhistory.FieldHistoryTime:
		return m.HistoryTime()
	case remediationhistory.FieldRef:
		return m.Ref()
	case remediationhistory.FieldOperation:
		return m.Operation()
	case remediationhistory.FieldCreatedAt:
		return m.CreatedAt()
	case remediationhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case remediationhistory.FieldCreatedBy:
		return m.CreatedBy()
	case remediationhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case remediationhistory.FieldDeletedAt:
		return m.DeletedAt()
	case remediationhistory.FieldDeletedBy:
		return m.DeletedBy()
	case remediationhistory.FieldDisplayID:
		return m.DisplayID()
	case remediationhistory.FieldTags:
		return m.Tags()
	case remediationhistory.FieldOwnerID:
		return m.OwnerID()
	case remediationhistory.FieldSystemOwned:
		return m.SystemOwned()
	case remediationhistory.FieldInternalNotes:
		return m.InternalNotes()
	case remediationhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case remediationhistory.FieldExternalID:
		return m.ExternalID()
	case remediationhistory.FieldExternalOwnerID:
		return m.ExternalOwnerID()
	case remediationhistory.FieldTitle:
		return m.Title()
	case remediationhistory.FieldState:
		return m.State()
	case remediationhistory.FieldIntent:
		return m.Intent()
	case remediationhistory.FieldSummary:
		return m.Summary()
	case remediationhistory.FieldExplanation:
		return m.Explanation()
	case remediationhistory.FieldInstructions:
		return m.Instructions()
	case remediationhistory.FieldOwnerReference:
		return m.OwnerReference()
	case remediationhistory.FieldRepositoryURI:
		return m.RepositoryURI()
	case remediationhistory.FieldPullRequestURI:
		return m.PullRequestURI()
	case remediationhistory.FieldTicketReference:
		return m.TicketReference()
	case remediationhistory.FieldDueAt:
		return m.DueAt()
	case remediationhistory.FieldCompletedAt:
		return m.CompletedAt()
	case remediationhistory.FieldPrGeneratedAt:
		return m.PrGeneratedAt()
	case remediationhistory.FieldError:
		return m.Error()
	case remediationhistory.FieldSource:
		return m.Source()
	case remediationhistory.FieldExternalURI:
		return m.ExternalURI()
	case remediationhistory.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RemediationHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case remediationhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case remediationhistory.FieldRef:
		return m.OldRef(ctx)
	case remediationhistory.FieldOperation:
		return m.OldOperation(ctx)
	case remediationhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case remediationhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case remediationhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case remediationhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case remediationhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case remediationhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case remediationhistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case remediationhistory.FieldTags:
		return m.OldTags(ctx)
	case remediationhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case remediationhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case remediationhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case remediationhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case remediationhistory.FieldExternalID:
		return m.OldExternalID(ctx)
	case remediationhistory.FieldExternalOwnerID:
		return m.OldExternalOwnerID(ctx)
	case remediationhistory.FieldTitle:
		return m.OldTitle(ctx)
	case remediationhistory.FieldState:
		return m.OldState(ctx)
	case remediationhistory.FieldIntent:
		return m.OldIntent(ctx)
	case remediationhistory.FieldSummary:
		return m.OldSummary(ctx)
	case remediationhistory.FieldExplanation:
		return m.OldExplanation(ctx)
	case remediationhistory.FieldInstructions:
		return m.OldInstructions(ctx)
	case remediationhistory.FieldOwnerReference:
		return m.OldOwnerReference(ctx)
	case remediationhistory.FieldRepositoryURI:
		return m.OldRepositoryURI(ctx)
	case remediationhistory.FieldPullRequestURI:
		return m.OldPullRequestURI(ctx)
	case remediationhistory.FieldTicketReference:
		return m.OldTicketReference(ctx)
	case remediationhistory.FieldDueAt:
		return m.OldDueAt(ctx)
	case remediationhistory.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case remediationhistory.FieldPrGeneratedAt:
		return m.OldPrGeneratedAt(ctx)
	case remediationhistory.FieldError:
		return m.OldError(ctx)
	case remediationhistory.FieldSource:
		return m.OldSource(ctx)
	case remediationhistory.FieldExternalURI:
		return m.OldExternalURI(ctx)
	case remediationhistory.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown RemediationHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RemediationHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case remediationhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case remediationhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case remediationhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case remediationhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case remediationhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case remediationhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case remediationhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case remediationhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case remediationhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case remediationhistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case remediationhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case remediationhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case remediationhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case remediationhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case remediationhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case remediationhistory.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case remediationhistory.FieldExternalOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalOwnerID(v)
		return nil
	case remediationhistory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case remediationhistory.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case remediationhistory.FieldIntent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntent(v)
		return nil
	case remediationhistory.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case remediationhistory.FieldExplanation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExplanation(v)
		return nil
	case remediationhistory.FieldInstructions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstructions(v)
		return nil
	case remediationhistory.FieldOwnerReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerReference(v)
		return nil
	case remediationhistory.FieldRepositoryURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepositoryURI(v)
		return nil
	case remediationhistory.FieldPullRequestURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPullRequestURI(v)
		return nil
	case remediationhistory.FieldTicketReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketReference(v)
		return nil
	case remediationhistory.FieldDueAt:
		v, ok := value.(models.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueAt(v)
		return nil
	case remediationhistory.FieldCompletedAt:
		v, ok := value.(models.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case remediationhistory.FieldPrGeneratedAt:
		v, ok := value.(models.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrGeneratedAt(v)
		return nil
	case remediationhistory.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case remediationhistory.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case remediationhistory.FieldExternalURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalURI(v)
		return nil
	case remediationhistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown RemediationHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RemediationHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RemediationHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RemediationHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RemediationHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RemediationHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(remediationhistory.FieldRef) {
		fields = append(fields, remediationhistory.FieldRef)
	}
	if m.FieldCleared(remediationhistory.FieldCreatedAt) {
		fields = append(fields, remediationhistory.FieldCreatedAt)
	}
	if m.FieldCleared(remediationhistory.FieldUpdatedAt) {
		fields = append(fields, remediationhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(remediationhistory.FieldCreatedBy) {
		fields = append(fields, remediationhistory.FieldCreatedBy)
	}
	if m.FieldCleared(remediationhistory.FieldUpdatedBy) {
		fields = append(fields, remediationhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(remediationhistory.FieldDeletedAt) {
		fields = append(fields, remediationhistory.FieldDeletedAt)
	}
	if m.FieldCleared(remediationhistory.FieldDeletedBy) {
		fields = append(fields, remediationhistory.FieldDeletedBy)
	}
	if m.FieldCleared(remediationhistory.FieldTags) {
		fields = append(fields, remediationhistory.FieldTags)
	}
	if m.FieldCleared(remediationhistory.FieldOwnerID) {
		fields = append(fields, remediationhistory.FieldOwnerID)
	}
	if m.FieldCleared(remediationhistory.FieldSystemOwned) {
		fields = append(fields, remediationhistory.FieldSystemOwned)
	}
	if m.FieldCleared(remediationhistory.FieldInternalNotes) {
		fields = append(fields, remediationhistory.FieldInternalNotes)
	}
	if m.FieldCleared(remediationhistory.FieldSystemInternalID) {
		fields = append(fields, remediationhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(remediationhistory.FieldExternalID) {
		fields = append(fields, remediationhistory.FieldExternalID)
	}
	if m.FieldCleared(remediationhistory.FieldExternalOwnerID) {
		fields = append(fields, remediationhistory.FieldExternalOwnerID)
	}
	if m.FieldCleared(remediationhistory.FieldTitle) {
		fields = append(fields, remediationhistory.FieldTitle)
	}
	if m.FieldCleared(remediationhistory.FieldState) {
		fields = append(fields, remediationhistory.FieldState)
	}
	if m.FieldCleared(remediationhistory.FieldIntent) {
		fields = append(fields, remediationhistory.FieldIntent)
	}
	if m.FieldCleared(remediationhistory.FieldSummary) {
		fields = append(fields, remediationhistory.FieldSummary)
	}
	if m.FieldCleared(remediationhistory.FieldExplanation) {
		fields = append(fields, remediationhistory.FieldExplanation)
	}
	if m.FieldCleared(remediationhistory.FieldInstructions) {
		fields = append(fields, remediationhistory.FieldInstructions)
	}
	if m.FieldCleared(remediationhistory.FieldOwnerReference) {
		fields = append(fields, remediationhistory.FieldOwnerReference)
	}
	if m.FieldCleared(remediationhistory.FieldRepositoryURI) {
		fields = append(fields, remediationhistory.FieldRepositoryURI)
	}
	if m.FieldCleared(remediationhistory.FieldPullRequestURI) {
		fields = append(fields, remediationhistory.FieldPullRequestURI)
	}
	if m.FieldCleared(remediationhistory.FieldTicketReference) {
		fields = append(fields, remediationhistory.FieldTicketReference)
	}
	if m.FieldCleared(remediationhistory.FieldDueAt) {
		fields = append(fields, remediationhistory.FieldDueAt)
	}
	if m.FieldCleared(remediationhistory.FieldCompletedAt) {
		fields = append(fields, remediationhistory.FieldCompletedAt)
	}
	if m.FieldCleared(remediationhistory.FieldPrGeneratedAt) {
		fields = append(fields, remediationhistory.FieldPrGeneratedAt)
	}
	if m.FieldCleared(remediationhistory.FieldError) {
		fields = append(fields, remediationhistory.FieldError)
	}
	if m.FieldCleared(remediationhistory.FieldSource) {
		fields = append(fields, remediationhistory.FieldSource)
	}
	if m.FieldCleared(remediationhistory.FieldExternalURI) {
		fields = append(fields, remediationhistory.FieldExternalURI)
	}
	if m.FieldCleared(remediationhistory.FieldMetadata) {
		fields = append(fields, remediationhistory.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RemediationHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RemediationHistoryMutation) ClearField(name string) error {
	switch name {
	case remediationhistory.FieldRef:
		m.ClearRef()
		return nil
	case remediationhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case remediationhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case remediationhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case remediationhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case remediationhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case remediationhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case remediationhistory.FieldTags:
		m.ClearTags()
		return nil
	case remediationhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case remediationhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case remediationhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case remediationhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case remediationhistory.FieldExternalID:
		m.ClearExternalID()
		return nil
	case remediationhistory.FieldExternalOwnerID:
		m.ClearExternalOwnerID()
		return nil
	case remediationhistory.FieldTitle:
		m.ClearTitle()
		return nil
	case remediationhistory.FieldState:
		m.ClearState()
		return nil
	case remediationhistory.FieldIntent:
		m.ClearIntent()
		return nil
	case remediationhistory.FieldSummary:
		m.ClearSummary()
		return nil
	case remediationhistory.FieldExplanation:
		m.ClearExplanation()
		return nil
	case remediationhistory.FieldInstructions:
		m.ClearInstructions()
		return nil
	case remediationhistory.FieldOwnerReference:
		m.ClearOwnerReference()
		return nil
	case remediationhistory.FieldRepositoryURI:
		m.ClearRepositoryURI()
		return nil
	case remediationhistory.FieldPullRequestURI:
		m.ClearPullRequestURI()
		return nil
	case remediationhistory.FieldTicketReference:
		m.ClearTicketReference()
		return nil
	case remediationhistory.FieldDueAt:
		m.ClearDueAt()
		return nil
	case remediationhistory.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case remediationhistory.FieldPrGeneratedAt:
		m.ClearPrGeneratedAt()
		return nil
	case remediationhistory.FieldError:
		m.ClearError()
		return nil
	case remediationhistory.FieldSource:
		m.ClearSource()
		return nil
	case remediationhistory.FieldExternalURI:
		m.ClearExternalURI()
		return nil
	case remediationhistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown RemediationHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RemediationHistoryMutation) ResetField(name string) error {
	switch name {
	case remediationhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case remediationhistory.FieldRef:
		m.ResetRef()
		return nil
	case remediationhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case remediationhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case remediationhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case remediationhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case remediationhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case remediationhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case remediationhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case remediationhistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case remediationhistory.FieldTags:
		m.ResetTags()
		return nil
	case remediationhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case remediationhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case remediationhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case remediationhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case remediationhistory.FieldExternalID:
		m.ResetExternalID()
		return nil
	case remediationhistory.FieldExternalOwnerID:
		m.ResetExternalOwnerID()
		return nil
	case remediationhistory.FieldTitle:
		m.ResetTitle()
		return nil
	case remediationhistory.FieldState:
		m.ResetState()
		return nil
	case remediationhistory.FieldIntent:
		m.ResetIntent()
		return nil
	case remediationhistory.FieldSummary:
		m.ResetSummary()
		return nil
	case remediationhistory.FieldExplanation:
		m.ResetExplanation()
		return nil
	case remediationhistory.FieldInstructions:
		m.ResetInstructions()
		return nil
	case remediationhistory.FieldOwnerReference:
		m.ResetOwnerReference()
		return nil
	case remediationhistory.FieldRepositoryURI:
		m.ResetRepositoryURI()
		return nil
	case remediationhistory.FieldPullRequestURI:
		m.ResetPullRequestURI()
		return nil
	case remediationhistory.FieldTicketReference:
		m.ResetTicketReference()
		return nil
	case remediationhistory.FieldDueAt:
		m.ResetDueAt()
		return nil
	case remediationhistory.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case remediationhistory.FieldPrGeneratedAt:
		m.ResetPrGeneratedAt()
		return nil
	case remediationhistory.FieldError:
		m.ResetError()
		return nil
	case remediationhistory.FieldSource:
		m.ResetSource()
		return nil
	case remediationhistory.FieldExternalURI:
		m.ResetExternalURI()
		return nil
	case remediationhistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown RemediationHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RemediationHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RemediationHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RemediationHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RemediationHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RemediationHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RemediationHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RemediationHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RemediationHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RemediationHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RemediationHistory edge %s", name)
}

// ReviewHistoryMutation represents an operation that mutates the ReviewHistory nodes in the graph.
type ReviewHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	history_time       *time.Time
	ref                *string
	operation          *history.OpType
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	deleted_at         *time.Time
	deleted_by         *string
	tags               *[]string
	appendtags         []string
	owner_id           *string
	system_owned       *bool
	internal_notes     *string
	system_internal_id *string
	external_id        *string
	external_owner_id  *string
	title              *string
	state              *string
	category           *string
	classification     *string
	summary            *string
	details            *string
	reporter           *string
	approved           *bool
	reviewed_at        *models.DateTime
	reported_at        *models.DateTime
	approved_at        *models.DateTime
	reviewer_id        *string
	source             *string
	external_uri       *string
	metadata           *map[string]interface{}
	raw_payload        *map[string]interface{}
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*ReviewHistory, error)
	predicates         []predicate.ReviewHistory
}

var _ ent.Mutation = (*ReviewHistoryMutation)(nil)

// reviewhistoryOption allows management of the mutation configuration using functional options.
type reviewhistoryOption func(*ReviewHistoryMutation)

// newReviewHistoryMutation creates new mutation for the ReviewHistory entity.
func newReviewHistoryMutation(c config, op Op, opts ...reviewhistoryOption) *ReviewHistoryMutation {
	m := &ReviewHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeReviewHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewHistoryID sets the ID field of the mutation.
func withReviewHistoryID(id string) reviewhistoryOption {
	return func(m *ReviewHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ReviewHistory
		)
		m.oldValue = func(ctx context.Context) (*ReviewHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReviewHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReviewHistory sets the old ReviewHistory of the mutation.
func withReviewHistory(node *ReviewHistory) reviewhistoryOption {
	return func(m *ReviewHistoryMutation) {
		m.oldValue = func(context.Context) (*ReviewHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ReviewHistory entities.
func (m *ReviewHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReviewHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ReviewHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ReviewHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ReviewHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ReviewHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ReviewHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ReviewHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[reviewhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ReviewHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ReviewHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, reviewhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ReviewHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ReviewHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ReviewHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ReviewHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReviewHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ReviewHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[reviewhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ReviewHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReviewHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, reviewhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReviewHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReviewHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ReviewHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[reviewhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ReviewHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReviewHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, reviewhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ReviewHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ReviewHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ReviewHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[reviewhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ReviewHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ReviewHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, reviewhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ReviewHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ReviewHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ReviewHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[reviewhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ReviewHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ReviewHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, reviewhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ReviewHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ReviewHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ReviewHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[reviewhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ReviewHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ReviewHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, reviewhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ReviewHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ReviewHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ReviewHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[reviewhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ReviewHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ReviewHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, reviewhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *ReviewHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ReviewHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ReviewHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ReviewHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ReviewHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[reviewhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ReviewHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ReviewHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, reviewhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *ReviewHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ReviewHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *ReviewHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[reviewhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *ReviewHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ReviewHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, reviewhistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *ReviewHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *ReviewHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *ReviewHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[reviewhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *ReviewHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *ReviewHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, reviewhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *ReviewHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *ReviewHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *ReviewHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[reviewhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *ReviewHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *ReviewHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, reviewhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *ReviewHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *ReviewHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *ReviewHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[reviewhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *ReviewHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *ReviewHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, reviewhistory.FieldSystemInternalID)
}

// SetExternalID sets the "external_id" field.
func (m *ReviewHistoryMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *ReviewHistoryMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *ReviewHistoryMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[reviewhistory.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *ReviewHistoryMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *ReviewHistoryMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, reviewhistory.FieldExternalID)
}

// SetExternalOwnerID sets the "external_owner_id" field.
func (m *ReviewHistoryMutation) SetExternalOwnerID(s string) {
	m.external_owner_id = &s
}

// ExternalOwnerID returns the value of the "external_owner_id" field in the mutation.
func (m *ReviewHistoryMutation) ExternalOwnerID() (r string, exists bool) {
	v := m.external_owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalOwnerID returns the old "external_owner_id" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldExternalOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalOwnerID: %w", err)
	}
	return oldValue.ExternalOwnerID, nil
}

// ClearExternalOwnerID clears the value of the "external_owner_id" field.
func (m *ReviewHistoryMutation) ClearExternalOwnerID() {
	m.external_owner_id = nil
	m.clearedFields[reviewhistory.FieldExternalOwnerID] = struct{}{}
}

// ExternalOwnerIDCleared returns if the "external_owner_id" field was cleared in this mutation.
func (m *ReviewHistoryMutation) ExternalOwnerIDCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldExternalOwnerID]
	return ok
}

// ResetExternalOwnerID resets all changes to the "external_owner_id" field.
func (m *ReviewHistoryMutation) ResetExternalOwnerID() {
	m.external_owner_id = nil
	delete(m.clearedFields, reviewhistory.FieldExternalOwnerID)
}

// SetTitle sets the "title" field.
func (m *ReviewHistoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ReviewHistoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ReviewHistoryMutation) ResetTitle() {
	m.title = nil
}

// SetState sets the "state" field.
func (m *ReviewHistoryMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *ReviewHistoryMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *ReviewHistoryMutation) ClearState() {
	m.state = nil
	m.clearedFields[reviewhistory.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *ReviewHistoryMutation) StateCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *ReviewHistoryMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, reviewhistory.FieldState)
}

// SetCategory sets the "category" field.
func (m *ReviewHistoryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ReviewHistoryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ReviewHistoryMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[reviewhistory.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ReviewHistoryMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ReviewHistoryMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, reviewhistory.FieldCategory)
}

// SetClassification sets the "classification" field.
func (m *ReviewHistoryMutation) SetClassification(s string) {
	m.classification = &s
}

// Classification returns the value of the "classification" field in the mutation.
func (m *ReviewHistoryMutation) Classification() (r string, exists bool) {
	v := m.classification
	if v == nil {
		return
	}
	return *v, true
}

// OldClassification returns the old "classification" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldClassification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassification: %w", err)
	}
	return oldValue.Classification, nil
}

// ClearClassification clears the value of the "classification" field.
func (m *ReviewHistoryMutation) ClearClassification() {
	m.classification = nil
	m.clearedFields[reviewhistory.FieldClassification] = struct{}{}
}

// ClassificationCleared returns if the "classification" field was cleared in this mutation.
func (m *ReviewHistoryMutation) ClassificationCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldClassification]
	return ok
}

// ResetClassification resets all changes to the "classification" field.
func (m *ReviewHistoryMutation) ResetClassification() {
	m.classification = nil
	delete(m.clearedFields, reviewhistory.FieldClassification)
}

// SetSummary sets the "summary" field.
func (m *ReviewHistoryMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *ReviewHistoryMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *ReviewHistoryMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[reviewhistory.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *ReviewHistoryMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *ReviewHistoryMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, reviewhistory.FieldSummary)
}

// SetDetails sets the "details" field.
func (m *ReviewHistoryMutation) SetDetails(s string) {
	m.details = &s
}

// Details returns the value of the "details" field in the mutation.
func (m *ReviewHistoryMutation) Details() (r string, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *ReviewHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[reviewhistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *ReviewHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *ReviewHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, reviewhistory.FieldDetails)
}

// SetReporter sets the "reporter" field.
func (m *ReviewHistoryMutation) SetReporter(s string) {
	m.reporter = &s
}

// Reporter returns the value of the "reporter" field in the mutation.
func (m *ReviewHistoryMutation) Reporter() (r string, exists bool) {
	v := m.reporter
	if v == nil {
		return
	}
	return *v, true
}

// OldReporter returns the old "reporter" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldReporter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReporter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReporter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReporter: %w", err)
	}
	return oldValue.Reporter, nil
}

// ClearReporter clears the value of the "reporter" field.
func (m *ReviewHistoryMutation) ClearReporter() {
	m.reporter = nil
	m.clearedFields[reviewhistory.FieldReporter] = struct{}{}
}

// ReporterCleared returns if the "reporter" field was cleared in this mutation.
func (m *ReviewHistoryMutation) ReporterCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldReporter]
	return ok
}

// ResetReporter resets all changes to the "reporter" field.
func (m *ReviewHistoryMutation) ResetReporter() {
	m.reporter = nil
	delete(m.clearedFields, reviewhistory.FieldReporter)
}

// SetApproved sets the "approved" field.
func (m *ReviewHistoryMutation) SetApproved(b bool) {
	m.approved = &b
}

// Approved returns the value of the "approved" field in the mutation.
func (m *ReviewHistoryMutation) Approved() (r bool, exists bool) {
	v := m.approved
	if v == nil {
		return
	}
	return *v, true
}

// OldApproved returns the old "approved" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldApproved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproved: %w", err)
	}
	return oldValue.Approved, nil
}

// ClearApproved clears the value of the "approved" field.
func (m *ReviewHistoryMutation) ClearApproved() {
	m.approved = nil
	m.clearedFields[reviewhistory.FieldApproved] = struct{}{}
}

// ApprovedCleared returns if the "approved" field was cleared in this mutation.
func (m *ReviewHistoryMutation) ApprovedCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldApproved]
	return ok
}

// ResetApproved resets all changes to the "approved" field.
func (m *ReviewHistoryMutation) ResetApproved() {
	m.approved = nil
	delete(m.clearedFields, reviewhistory.FieldApproved)
}

// SetReviewedAt sets the "reviewed_at" field.
func (m *ReviewHistoryMutation) SetReviewedAt(mt models.DateTime) {
	m.reviewed_at = &mt
}

// ReviewedAt returns the value of the "reviewed_at" field in the mutation.
func (m *ReviewHistoryMutation) ReviewedAt() (r models.DateTime, exists bool) {
	v := m.reviewed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedAt returns the old "reviewed_at" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldReviewedAt(ctx context.Context) (v *models.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedAt: %w", err)
	}
	return oldValue.ReviewedAt, nil
}

// ClearReviewedAt clears the value of the "reviewed_at" field.
func (m *ReviewHistoryMutation) ClearReviewedAt() {
	m.reviewed_at = nil
	m.clearedFields[reviewhistory.FieldReviewedAt] = struct{}{}
}

// ReviewedAtCleared returns if the "reviewed_at" field was cleared in this mutation.
func (m *ReviewHistoryMutation) ReviewedAtCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldReviewedAt]
	return ok
}

// ResetReviewedAt resets all changes to the "reviewed_at" field.
func (m *ReviewHistoryMutation) ResetReviewedAt() {
	m.reviewed_at = nil
	delete(m.clearedFields, reviewhistory.FieldReviewedAt)
}

// SetReportedAt sets the "reported_at" field.
func (m *ReviewHistoryMutation) SetReportedAt(mt models.DateTime) {
	m.reported_at = &mt
}

// ReportedAt returns the value of the "reported_at" field in the mutation.
func (m *ReviewHistoryMutation) ReportedAt() (r models.DateTime, exists bool) {
	v := m.reported_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReportedAt returns the old "reported_at" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldReportedAt(ctx context.Context) (v *models.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportedAt: %w", err)
	}
	return oldValue.ReportedAt, nil
}

// ClearReportedAt clears the value of the "reported_at" field.
func (m *ReviewHistoryMutation) ClearReportedAt() {
	m.reported_at = nil
	m.clearedFields[reviewhistory.FieldReportedAt] = struct{}{}
}

// ReportedAtCleared returns if the "reported_at" field was cleared in this mutation.
func (m *ReviewHistoryMutation) ReportedAtCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldReportedAt]
	return ok
}

// ResetReportedAt resets all changes to the "reported_at" field.
func (m *ReviewHistoryMutation) ResetReportedAt() {
	m.reported_at = nil
	delete(m.clearedFields, reviewhistory.FieldReportedAt)
}

// SetApprovedAt sets the "approved_at" field.
func (m *ReviewHistoryMutation) SetApprovedAt(mt models.DateTime) {
	m.approved_at = &mt
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *ReviewHistoryMutation) ApprovedAt() (r models.DateTime, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldApprovedAt(ctx context.Context) (v *models.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *ReviewHistoryMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[reviewhistory.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *ReviewHistoryMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *ReviewHistoryMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, reviewhistory.FieldApprovedAt)
}

// SetReviewerID sets the "reviewer_id" field.
func (m *ReviewHistoryMutation) SetReviewerID(s string) {
	m.reviewer_id = &s
}

// ReviewerID returns the value of the "reviewer_id" field in the mutation.
func (m *ReviewHistoryMutation) ReviewerID() (r string, exists bool) {
	v := m.reviewer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewerID returns the old "reviewer_id" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldReviewerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewerID: %w", err)
	}
	return oldValue.ReviewerID, nil
}

// ClearReviewerID clears the value of the "reviewer_id" field.
func (m *ReviewHistoryMutation) ClearReviewerID() {
	m.reviewer_id = nil
	m.clearedFields[reviewhistory.FieldReviewerID] = struct{}{}
}

// ReviewerIDCleared returns if the "reviewer_id" field was cleared in this mutation.
func (m *ReviewHistoryMutation) ReviewerIDCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldReviewerID]
	return ok
}

// ResetReviewerID resets all changes to the "reviewer_id" field.
func (m *ReviewHistoryMutation) ResetReviewerID() {
	m.reviewer_id = nil
	delete(m.clearedFields, reviewhistory.FieldReviewerID)
}

// SetSource sets the "source" field.
func (m *ReviewHistoryMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ReviewHistoryMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *ReviewHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[reviewhistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *ReviewHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *ReviewHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, reviewhistory.FieldSource)
}

// SetExternalURI sets the "external_uri" field.
func (m *ReviewHistoryMutation) SetExternalURI(s string) {
	m.external_uri = &s
}

// ExternalURI returns the value of the "external_uri" field in the mutation.
func (m *ReviewHistoryMutation) ExternalURI() (r string, exists bool) {
	v := m.external_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalURI returns the old "external_uri" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldExternalURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalURI: %w", err)
	}
	return oldValue.ExternalURI, nil
}

// ClearExternalURI clears the value of the "external_uri" field.
func (m *ReviewHistoryMutation) ClearExternalURI() {
	m.external_uri = nil
	m.clearedFields[reviewhistory.FieldExternalURI] = struct{}{}
}

// ExternalURICleared returns if the "external_uri" field was cleared in this mutation.
func (m *ReviewHistoryMutation) ExternalURICleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldExternalURI]
	return ok
}

// ResetExternalURI resets all changes to the "external_uri" field.
func (m *ReviewHistoryMutation) ResetExternalURI() {
	m.external_uri = nil
	delete(m.clearedFields, reviewhistory.FieldExternalURI)
}

// SetMetadata sets the "metadata" field.
func (m *ReviewHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ReviewHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ReviewHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[reviewhistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ReviewHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ReviewHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, reviewhistory.FieldMetadata)
}

// SetRawPayload sets the "raw_payload" field.
func (m *ReviewHistoryMutation) SetRawPayload(value map[string]interface{}) {
	m.raw_payload = &value
}

// RawPayload returns the value of the "raw_payload" field in the mutation.
func (m *ReviewHistoryMutation) RawPayload() (r map[string]interface{}, exists bool) {
	v := m.raw_payload
	if v == nil {
		return
	}
	return *v, true
}

// OldRawPayload returns the old "raw_payload" field's value of the ReviewHistory entity.
// If the ReviewHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewHistoryMutation) OldRawPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawPayload: %w", err)
	}
	return oldValue.RawPayload, nil
}

// ClearRawPayload clears the value of the "raw_payload" field.
func (m *ReviewHistoryMutation) ClearRawPayload() {
	m.raw_payload = nil
	m.clearedFields[reviewhistory.FieldRawPayload] = struct{}{}
}

// RawPayloadCleared returns if the "raw_payload" field was cleared in this mutation.
func (m *ReviewHistoryMutation) RawPayloadCleared() bool {
	_, ok := m.clearedFields[reviewhistory.FieldRawPayload]
	return ok
}

// ResetRawPayload resets all changes to the "raw_payload" field.
func (m *ReviewHistoryMutation) ResetRawPayload() {
	m.raw_payload = nil
	delete(m.clearedFields, reviewhistory.FieldRawPayload)
}

// Where appends a list predicates to the ReviewHistoryMutation builder.
func (m *ReviewHistoryMutation) Where(ps ...predicate.ReviewHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReviewHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReviewHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReviewHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReviewHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReviewHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReviewHistory).
func (m *ReviewHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewHistoryMutation) Fields() []string {
	fields := make([]string, 0, 32)
	if m.history_time != nil {
		fields = append(fields, reviewhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, reviewhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, reviewhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, reviewhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, reviewhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, reviewhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, reviewhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, reviewhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, reviewhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, reviewhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, reviewhistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, reviewhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, reviewhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, reviewhistory.FieldSystemInternalID)
	}
	if m.external_id != nil {
		fields = append(fields, reviewhistory.FieldExternalID)
	}
	if m.external_owner_id != nil {
		fields = append(fields, reviewhistory.FieldExternalOwnerID)
	}
	if m.title != nil {
		fields = append(fields, reviewhistory.FieldTitle)
	}
	if m.state != nil {
		fields = append(fields, reviewhistory.FieldState)
	}
	if m.category != nil {
		fields = append(fields, reviewhistory.FieldCategory)
	}
	if m.classification != nil {
		fields = append(fields, reviewhistory.FieldClassification)
	}
	if m.summary != nil {
		fields = append(fields, reviewhistory.FieldSummary)
	}
	if m.details != nil {
		fields = append(fields, reviewhistory.FieldDetails)
	}
	if m.reporter != nil {
		fields = append(fields, reviewhistory.FieldReporter)
	}
	if m.approved != nil {
		fields = append(fields, reviewhistory.FieldApproved)
	}
	if m.reviewed_at != nil {
		fields = append(fields, reviewhistory.FieldReviewedAt)
	}
	if m.reported_at != nil {
		fields = append(fields, reviewhistory.FieldReportedAt)
	}
	if m.approved_at != nil {
		fields = append(fields, reviewhistory.FieldApprovedAt)
	}
	if m.reviewer_id != nil {
		fields = append(fields, reviewhistory.FieldReviewerID)
	}
	if m.source != nil {
		fields = append(fields, reviewhistory.FieldSource)
	}
	if m.external_uri != nil {
		fields = append(fields, reviewhistory.FieldExternalURI)
	}
	if m.metadata != nil {
		fields = append(fields, reviewhistory.FieldMetadata)
	}
	if m.raw_payload != nil {
		fields = append(fields, reviewhistory.FieldRawPayload)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reviewhistory.FieldHistoryTime:
		return m.HistoryTime()
	case reviewhistory.FieldRef:
		return m.Ref()
	case reviewhistory.FieldOperation:
		return m.Operation()
	case reviewhistory.FieldCreatedAt:
		return m.CreatedAt()
	case reviewhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case reviewhistory.FieldCreatedBy:
		return m.CreatedBy()
	case reviewhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case reviewhistory.FieldDeletedAt:
		return m.DeletedAt()
	case reviewhistory.FieldDeletedBy:
		return m.DeletedBy()
	case reviewhistory.FieldTags:
		return m.Tags()
	case reviewhistory.FieldOwnerID:
		return m.OwnerID()
	case reviewhistory.FieldSystemOwned:
		return m.SystemOwned()
	case reviewhistory.FieldInternalNotes:
		return m.InternalNotes()
	case reviewhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case reviewhistory.FieldExternalID:
		return m.ExternalID()
	case reviewhistory.FieldExternalOwnerID:
		return m.ExternalOwnerID()
	case reviewhistory.FieldTitle:
		return m.Title()
	case reviewhistory.FieldState:
		return m.State()
	case reviewhistory.FieldCategory:
		return m.Category()
	case reviewhistory.FieldClassification:
		return m.Classification()
	case reviewhistory.FieldSummary:
		return m.Summary()
	case reviewhistory.FieldDetails:
		return m.Details()
	case reviewhistory.FieldReporter:
		return m.Reporter()
	case reviewhistory.FieldApproved:
		return m.Approved()
	case reviewhistory.FieldReviewedAt:
		return m.ReviewedAt()
	case reviewhistory.FieldReportedAt:
		return m.ReportedAt()
	case reviewhistory.FieldApprovedAt:
		return m.ApprovedAt()
	case reviewhistory.FieldReviewerID:
		return m.ReviewerID()
	case reviewhistory.FieldSource:
		return m.Source()
	case reviewhistory.FieldExternalURI:
		return m.ExternalURI()
	case reviewhistory.FieldMetadata:
		return m.Metadata()
	case reviewhistory.FieldRawPayload:
		return m.RawPayload()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reviewhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case reviewhistory.FieldRef:
		return m.OldRef(ctx)
	case reviewhistory.FieldOperation:
		return m.OldOperation(ctx)
	case reviewhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case reviewhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case reviewhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case reviewhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case reviewhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case reviewhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case reviewhistory.FieldTags:
		return m.OldTags(ctx)
	case reviewhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case reviewhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case reviewhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case reviewhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case reviewhistory.FieldExternalID:
		return m.OldExternalID(ctx)
	case reviewhistory.FieldExternalOwnerID:
		return m.OldExternalOwnerID(ctx)
	case reviewhistory.FieldTitle:
		return m.OldTitle(ctx)
	case reviewhistory.FieldState:
		return m.OldState(ctx)
	case reviewhistory.FieldCategory:
		return m.OldCategory(ctx)
	case reviewhistory.FieldClassification:
		return m.OldClassification(ctx)
	case reviewhistory.FieldSummary:
		return m.OldSummary(ctx)
	case reviewhistory.FieldDetails:
		return m.OldDetails(ctx)
	case reviewhistory.FieldReporter:
		return m.OldReporter(ctx)
	case reviewhistory.FieldApproved:
		return m.OldApproved(ctx)
	case reviewhistory.FieldReviewedAt:
		return m.OldReviewedAt(ctx)
	case reviewhistory.FieldReportedAt:
		return m.OldReportedAt(ctx)
	case reviewhistory.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case reviewhistory.FieldReviewerID:
		return m.OldReviewerID(ctx)
	case reviewhistory.FieldSource:
		return m.OldSource(ctx)
	case reviewhistory.FieldExternalURI:
		return m.OldExternalURI(ctx)
	case reviewhistory.FieldMetadata:
		return m.OldMetadata(ctx)
	case reviewhistory.FieldRawPayload:
		return m.OldRawPayload(ctx)
	}
	return nil, fmt.Errorf("unknown ReviewHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reviewhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case reviewhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case reviewhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case reviewhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case reviewhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case reviewhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case reviewhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case reviewhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case reviewhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case reviewhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case reviewhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case reviewhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case reviewhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case reviewhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case reviewhistory.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case reviewhistory.FieldExternalOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalOwnerID(v)
		return nil
	case reviewhistory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case reviewhistory.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case reviewhistory.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case reviewhistory.FieldClassification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassification(v)
		return nil
	case reviewhistory.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case reviewhistory.FieldDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case reviewhistory.FieldReporter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReporter(v)
		return nil
	case reviewhistory.FieldApproved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproved(v)
		return nil
	case reviewhistory.FieldReviewedAt:
		v, ok := value.(models.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedAt(v)
		return nil
	case reviewhistory.FieldReportedAt:
		v, ok := value.(models.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportedAt(v)
		return nil
	case reviewhistory.FieldApprovedAt:
		v, ok := value.(models.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case reviewhistory.FieldReviewerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewerID(v)
		return nil
	case reviewhistory.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case reviewhistory.FieldExternalURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalURI(v)
		return nil
	case reviewhistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case reviewhistory.FieldRawPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawPayload(v)
		return nil
	}
	return fmt.Errorf("unknown ReviewHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReviewHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reviewhistory.FieldRef) {
		fields = append(fields, reviewhistory.FieldRef)
	}
	if m.FieldCleared(reviewhistory.FieldCreatedAt) {
		fields = append(fields, reviewhistory.FieldCreatedAt)
	}
	if m.FieldCleared(reviewhistory.FieldUpdatedAt) {
		fields = append(fields, reviewhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(reviewhistory.FieldCreatedBy) {
		fields = append(fields, reviewhistory.FieldCreatedBy)
	}
	if m.FieldCleared(reviewhistory.FieldUpdatedBy) {
		fields = append(fields, reviewhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(reviewhistory.FieldDeletedAt) {
		fields = append(fields, reviewhistory.FieldDeletedAt)
	}
	if m.FieldCleared(reviewhistory.FieldDeletedBy) {
		fields = append(fields, reviewhistory.FieldDeletedBy)
	}
	if m.FieldCleared(reviewhistory.FieldTags) {
		fields = append(fields, reviewhistory.FieldTags)
	}
	if m.FieldCleared(reviewhistory.FieldOwnerID) {
		fields = append(fields, reviewhistory.FieldOwnerID)
	}
	if m.FieldCleared(reviewhistory.FieldSystemOwned) {
		fields = append(fields, reviewhistory.FieldSystemOwned)
	}
	if m.FieldCleared(reviewhistory.FieldInternalNotes) {
		fields = append(fields, reviewhistory.FieldInternalNotes)
	}
	if m.FieldCleared(reviewhistory.FieldSystemInternalID) {
		fields = append(fields, reviewhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(reviewhistory.FieldExternalID) {
		fields = append(fields, reviewhistory.FieldExternalID)
	}
	if m.FieldCleared(reviewhistory.FieldExternalOwnerID) {
		fields = append(fields, reviewhistory.FieldExternalOwnerID)
	}
	if m.FieldCleared(reviewhistory.FieldState) {
		fields = append(fields, reviewhistory.FieldState)
	}
	if m.FieldCleared(reviewhistory.FieldCategory) {
		fields = append(fields, reviewhistory.FieldCategory)
	}
	if m.FieldCleared(reviewhistory.FieldClassification) {
		fields = append(fields, reviewhistory.FieldClassification)
	}
	if m.FieldCleared(reviewhistory.FieldSummary) {
		fields = append(fields, reviewhistory.FieldSummary)
	}
	if m.FieldCleared(reviewhistory.FieldDetails) {
		fields = append(fields, reviewhistory.FieldDetails)
	}
	if m.FieldCleared(reviewhistory.FieldReporter) {
		fields = append(fields, reviewhistory.FieldReporter)
	}
	if m.FieldCleared(reviewhistory.FieldApproved) {
		fields = append(fields, reviewhistory.FieldApproved)
	}
	if m.FieldCleared(reviewhistory.FieldReviewedAt) {
		fields = append(fields, reviewhistory.FieldReviewedAt)
	}
	if m.FieldCleared(reviewhistory.FieldReportedAt) {
		fields = append(fields, reviewhistory.FieldReportedAt)
	}
	if m.FieldCleared(reviewhistory.FieldApprovedAt) {
		fields = append(fields, reviewhistory.FieldApprovedAt)
	}
	if m.FieldCleared(reviewhistory.FieldReviewerID) {
		fields = append(fields, reviewhistory.FieldReviewerID)
	}
	if m.FieldCleared(reviewhistory.FieldSource) {
		fields = append(fields, reviewhistory.FieldSource)
	}
	if m.FieldCleared(reviewhistory.FieldExternalURI) {
		fields = append(fields, reviewhistory.FieldExternalURI)
	}
	if m.FieldCleared(reviewhistory.FieldMetadata) {
		fields = append(fields, reviewhistory.FieldMetadata)
	}
	if m.FieldCleared(reviewhistory.FieldRawPayload) {
		fields = append(fields, reviewhistory.FieldRawPayload)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewHistoryMutation) ClearField(name string) error {
	switch name {
	case reviewhistory.FieldRef:
		m.ClearRef()
		return nil
	case reviewhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case reviewhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case reviewhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case reviewhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case reviewhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case reviewhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case reviewhistory.FieldTags:
		m.ClearTags()
		return nil
	case reviewhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case reviewhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case reviewhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case reviewhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case reviewhistory.FieldExternalID:
		m.ClearExternalID()
		return nil
	case reviewhistory.FieldExternalOwnerID:
		m.ClearExternalOwnerID()
		return nil
	case reviewhistory.FieldState:
		m.ClearState()
		return nil
	case reviewhistory.FieldCategory:
		m.ClearCategory()
		return nil
	case reviewhistory.FieldClassification:
		m.ClearClassification()
		return nil
	case reviewhistory.FieldSummary:
		m.ClearSummary()
		return nil
	case reviewhistory.FieldDetails:
		m.ClearDetails()
		return nil
	case reviewhistory.FieldReporter:
		m.ClearReporter()
		return nil
	case reviewhistory.FieldApproved:
		m.ClearApproved()
		return nil
	case reviewhistory.FieldReviewedAt:
		m.ClearReviewedAt()
		return nil
	case reviewhistory.FieldReportedAt:
		m.ClearReportedAt()
		return nil
	case reviewhistory.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case reviewhistory.FieldReviewerID:
		m.ClearReviewerID()
		return nil
	case reviewhistory.FieldSource:
		m.ClearSource()
		return nil
	case reviewhistory.FieldExternalURI:
		m.ClearExternalURI()
		return nil
	case reviewhistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	case reviewhistory.FieldRawPayload:
		m.ClearRawPayload()
		return nil
	}
	return fmt.Errorf("unknown ReviewHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewHistoryMutation) ResetField(name string) error {
	switch name {
	case reviewhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case reviewhistory.FieldRef:
		m.ResetRef()
		return nil
	case reviewhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case reviewhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case reviewhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case reviewhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case reviewhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case reviewhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case reviewhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case reviewhistory.FieldTags:
		m.ResetTags()
		return nil
	case reviewhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case reviewhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case reviewhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case reviewhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case reviewhistory.FieldExternalID:
		m.ResetExternalID()
		return nil
	case reviewhistory.FieldExternalOwnerID:
		m.ResetExternalOwnerID()
		return nil
	case reviewhistory.FieldTitle:
		m.ResetTitle()
		return nil
	case reviewhistory.FieldState:
		m.ResetState()
		return nil
	case reviewhistory.FieldCategory:
		m.ResetCategory()
		return nil
	case reviewhistory.FieldClassification:
		m.ResetClassification()
		return nil
	case reviewhistory.FieldSummary:
		m.ResetSummary()
		return nil
	case reviewhistory.FieldDetails:
		m.ResetDetails()
		return nil
	case reviewhistory.FieldReporter:
		m.ResetReporter()
		return nil
	case reviewhistory.FieldApproved:
		m.ResetApproved()
		return nil
	case reviewhistory.FieldReviewedAt:
		m.ResetReviewedAt()
		return nil
	case reviewhistory.FieldReportedAt:
		m.ResetReportedAt()
		return nil
	case reviewhistory.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case reviewhistory.FieldReviewerID:
		m.ResetReviewerID()
		return nil
	case reviewhistory.FieldSource:
		m.ResetSource()
		return nil
	case reviewhistory.FieldExternalURI:
		m.ResetExternalURI()
		return nil
	case reviewhistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	case reviewhistory.FieldRawPayload:
		m.ResetRawPayload()
		return nil
	}
	return fmt.Errorf("unknown ReviewHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ReviewHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ReviewHistory edge %s", name)
}

// RiskHistoryMutation represents an operation that mutates the RiskHistory nodes in the graph.
type RiskHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	history_time       *time.Time
	ref                *string
	operation          *history.OpType
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	deleted_at         *time.Time
	deleted_by         *string
	display_id         *string
	tags               *[]string
	appendtags         []string
	owner_id           *string
	risk_kind_name     *string
	risk_kind_id       *string
	risk_category_name *string
	risk_category_id   *string
	name               *string
	status             *enums.RiskStatus
	risk_type          *string
	category           *string
	impact             *enums.RiskImpact
	likelihood         *enums.RiskLikelihood
	score              *int
	addscore           *int
	mitigation         *string
	details            *string
	business_costs     *string
	stakeholder_id     *string
	delegate_id        *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*RiskHistory, error)
	predicates         []predicate.RiskHistory
}

var _ ent.Mutation = (*RiskHistoryMutation)(nil)

// riskhistoryOption allows management of the mutation configuration using functional options.
type riskhistoryOption func(*RiskHistoryMutation)

// newRiskHistoryMutation creates new mutation for the RiskHistory entity.
func newRiskHistoryMutation(c config, op Op, opts ...riskhistoryOption) *RiskHistoryMutation {
	m := &RiskHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRiskHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiskHistoryID sets the ID field of the mutation.
func withRiskHistoryID(id string) riskhistoryOption {
	return func(m *RiskHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *RiskHistory
		)
		m.oldValue = func(ctx context.Context) (*RiskHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RiskHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRiskHistory sets the old RiskHistory of the mutation.
func withRiskHistory(node *RiskHistory) riskhistoryOption {
	return func(m *RiskHistoryMutation) {
		m.oldValue = func(context.Context) (*RiskHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiskHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiskHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RiskHistory entities.
func (m *RiskHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiskHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiskHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RiskHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *RiskHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *RiskHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *RiskHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *RiskHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *RiskHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *RiskHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[riskhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *RiskHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *RiskHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, riskhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *RiskHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *RiskHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *RiskHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RiskHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiskHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RiskHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[riskhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RiskHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiskHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, riskhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiskHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiskHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RiskHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[riskhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RiskHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiskHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, riskhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *RiskHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RiskHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RiskHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[riskhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RiskHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RiskHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, riskhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RiskHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RiskHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *RiskHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[riskhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *RiskHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RiskHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, riskhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiskHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiskHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiskHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[riskhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiskHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiskHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, riskhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *RiskHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *RiskHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *RiskHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[riskhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *RiskHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *RiskHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, riskhistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *RiskHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *RiskHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *RiskHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *RiskHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *RiskHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *RiskHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *RiskHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *RiskHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[riskhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *RiskHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *RiskHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, riskhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *RiskHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *RiskHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *RiskHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[riskhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *RiskHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *RiskHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, riskhistory.FieldOwnerID)
}

// SetRiskKindName sets the "risk_kind_name" field.
func (m *RiskHistoryMutation) SetRiskKindName(s string) {
	m.risk_kind_name = &s
}

// RiskKindName returns the value of the "risk_kind_name" field in the mutation.
func (m *RiskHistoryMutation) RiskKindName() (r string, exists bool) {
	v := m.risk_kind_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskKindName returns the old "risk_kind_name" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldRiskKindName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskKindName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskKindName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskKindName: %w", err)
	}
	return oldValue.RiskKindName, nil
}

// ClearRiskKindName clears the value of the "risk_kind_name" field.
func (m *RiskHistoryMutation) ClearRiskKindName() {
	m.risk_kind_name = nil
	m.clearedFields[riskhistory.FieldRiskKindName] = struct{}{}
}

// RiskKindNameCleared returns if the "risk_kind_name" field was cleared in this mutation.
func (m *RiskHistoryMutation) RiskKindNameCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldRiskKindName]
	return ok
}

// ResetRiskKindName resets all changes to the "risk_kind_name" field.
func (m *RiskHistoryMutation) ResetRiskKindName() {
	m.risk_kind_name = nil
	delete(m.clearedFields, riskhistory.FieldRiskKindName)
}

// SetRiskKindID sets the "risk_kind_id" field.
func (m *RiskHistoryMutation) SetRiskKindID(s string) {
	m.risk_kind_id = &s
}

// RiskKindID returns the value of the "risk_kind_id" field in the mutation.
func (m *RiskHistoryMutation) RiskKindID() (r string, exists bool) {
	v := m.risk_kind_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskKindID returns the old "risk_kind_id" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldRiskKindID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskKindID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskKindID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskKindID: %w", err)
	}
	return oldValue.RiskKindID, nil
}

// ClearRiskKindID clears the value of the "risk_kind_id" field.
func (m *RiskHistoryMutation) ClearRiskKindID() {
	m.risk_kind_id = nil
	m.clearedFields[riskhistory.FieldRiskKindID] = struct{}{}
}

// RiskKindIDCleared returns if the "risk_kind_id" field was cleared in this mutation.
func (m *RiskHistoryMutation) RiskKindIDCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldRiskKindID]
	return ok
}

// ResetRiskKindID resets all changes to the "risk_kind_id" field.
func (m *RiskHistoryMutation) ResetRiskKindID() {
	m.risk_kind_id = nil
	delete(m.clearedFields, riskhistory.FieldRiskKindID)
}

// SetRiskCategoryName sets the "risk_category_name" field.
func (m *RiskHistoryMutation) SetRiskCategoryName(s string) {
	m.risk_category_name = &s
}

// RiskCategoryName returns the value of the "risk_category_name" field in the mutation.
func (m *RiskHistoryMutation) RiskCategoryName() (r string, exists bool) {
	v := m.risk_category_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskCategoryName returns the old "risk_category_name" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldRiskCategoryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskCategoryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskCategoryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskCategoryName: %w", err)
	}
	return oldValue.RiskCategoryName, nil
}

// ClearRiskCategoryName clears the value of the "risk_category_name" field.
func (m *RiskHistoryMutation) ClearRiskCategoryName() {
	m.risk_category_name = nil
	m.clearedFields[riskhistory.FieldRiskCategoryName] = struct{}{}
}

// RiskCategoryNameCleared returns if the "risk_category_name" field was cleared in this mutation.
func (m *RiskHistoryMutation) RiskCategoryNameCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldRiskCategoryName]
	return ok
}

// ResetRiskCategoryName resets all changes to the "risk_category_name" field.
func (m *RiskHistoryMutation) ResetRiskCategoryName() {
	m.risk_category_name = nil
	delete(m.clearedFields, riskhistory.FieldRiskCategoryName)
}

// SetRiskCategoryID sets the "risk_category_id" field.
func (m *RiskHistoryMutation) SetRiskCategoryID(s string) {
	m.risk_category_id = &s
}

// RiskCategoryID returns the value of the "risk_category_id" field in the mutation.
func (m *RiskHistoryMutation) RiskCategoryID() (r string, exists bool) {
	v := m.risk_category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskCategoryID returns the old "risk_category_id" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldRiskCategoryID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskCategoryID: %w", err)
	}
	return oldValue.RiskCategoryID, nil
}

// ClearRiskCategoryID clears the value of the "risk_category_id" field.
func (m *RiskHistoryMutation) ClearRiskCategoryID() {
	m.risk_category_id = nil
	m.clearedFields[riskhistory.FieldRiskCategoryID] = struct{}{}
}

// RiskCategoryIDCleared returns if the "risk_category_id" field was cleared in this mutation.
func (m *RiskHistoryMutation) RiskCategoryIDCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldRiskCategoryID]
	return ok
}

// ResetRiskCategoryID resets all changes to the "risk_category_id" field.
func (m *RiskHistoryMutation) ResetRiskCategoryID() {
	m.risk_category_id = nil
	delete(m.clearedFields, riskhistory.FieldRiskCategoryID)
}

// SetName sets the "name" field.
func (m *RiskHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RiskHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RiskHistoryMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *RiskHistoryMutation) SetStatus(es enums.RiskStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *RiskHistoryMutation) Status() (r enums.RiskStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldStatus(ctx context.Context) (v enums.RiskStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *RiskHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[riskhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RiskHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RiskHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, riskhistory.FieldStatus)
}

// SetRiskType sets the "risk_type" field.
func (m *RiskHistoryMutation) SetRiskType(s string) {
	m.risk_type = &s
}

// RiskType returns the value of the "risk_type" field in the mutation.
func (m *RiskHistoryMutation) RiskType() (r string, exists bool) {
	v := m.risk_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskType returns the old "risk_type" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldRiskType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskType: %w", err)
	}
	return oldValue.RiskType, nil
}

// ClearRiskType clears the value of the "risk_type" field.
func (m *RiskHistoryMutation) ClearRiskType() {
	m.risk_type = nil
	m.clearedFields[riskhistory.FieldRiskType] = struct{}{}
}

// RiskTypeCleared returns if the "risk_type" field was cleared in this mutation.
func (m *RiskHistoryMutation) RiskTypeCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldRiskType]
	return ok
}

// ResetRiskType resets all changes to the "risk_type" field.
func (m *RiskHistoryMutation) ResetRiskType() {
	m.risk_type = nil
	delete(m.clearedFields, riskhistory.FieldRiskType)
}

// SetCategory sets the "category" field.
func (m *RiskHistoryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *RiskHistoryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *RiskHistoryMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[riskhistory.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *RiskHistoryMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *RiskHistoryMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, riskhistory.FieldCategory)
}

// SetImpact sets the "impact" field.
func (m *RiskHistoryMutation) SetImpact(ei enums.RiskImpact) {
	m.impact = &ei
}

// Impact returns the value of the "impact" field in the mutation.
func (m *RiskHistoryMutation) Impact() (r enums.RiskImpact, exists bool) {
	v := m.impact
	if v == nil {
		return
	}
	return *v, true
}

// OldImpact returns the old "impact" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldImpact(ctx context.Context) (v enums.RiskImpact, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpact: %w", err)
	}
	return oldValue.Impact, nil
}

// ClearImpact clears the value of the "impact" field.
func (m *RiskHistoryMutation) ClearImpact() {
	m.impact = nil
	m.clearedFields[riskhistory.FieldImpact] = struct{}{}
}

// ImpactCleared returns if the "impact" field was cleared in this mutation.
func (m *RiskHistoryMutation) ImpactCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldImpact]
	return ok
}

// ResetImpact resets all changes to the "impact" field.
func (m *RiskHistoryMutation) ResetImpact() {
	m.impact = nil
	delete(m.clearedFields, riskhistory.FieldImpact)
}

// SetLikelihood sets the "likelihood" field.
func (m *RiskHistoryMutation) SetLikelihood(el enums.RiskLikelihood) {
	m.likelihood = &el
}

// Likelihood returns the value of the "likelihood" field in the mutation.
func (m *RiskHistoryMutation) Likelihood() (r enums.RiskLikelihood, exists bool) {
	v := m.likelihood
	if v == nil {
		return
	}
	return *v, true
}

// OldLikelihood returns the old "likelihood" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldLikelihood(ctx context.Context) (v enums.RiskLikelihood, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikelihood is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikelihood requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikelihood: %w", err)
	}
	return oldValue.Likelihood, nil
}

// ClearLikelihood clears the value of the "likelihood" field.
func (m *RiskHistoryMutation) ClearLikelihood() {
	m.likelihood = nil
	m.clearedFields[riskhistory.FieldLikelihood] = struct{}{}
}

// LikelihoodCleared returns if the "likelihood" field was cleared in this mutation.
func (m *RiskHistoryMutation) LikelihoodCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldLikelihood]
	return ok
}

// ResetLikelihood resets all changes to the "likelihood" field.
func (m *RiskHistoryMutation) ResetLikelihood() {
	m.likelihood = nil
	delete(m.clearedFields, riskhistory.FieldLikelihood)
}

// SetScore sets the "score" field.
func (m *RiskHistoryMutation) SetScore(i int) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *RiskHistoryMutation) Score() (r int, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *RiskHistoryMutation) AddScore(i int) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *RiskHistoryMutation) AddedScore() (r int, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *RiskHistoryMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[riskhistory.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *RiskHistoryMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *RiskHistoryMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, riskhistory.FieldScore)
}

// SetMitigation sets the "mitigation" field.
func (m *RiskHistoryMutation) SetMitigation(s string) {
	m.mitigation = &s
}

// Mitigation returns the value of the "mitigation" field in the mutation.
func (m *RiskHistoryMutation) Mitigation() (r string, exists bool) {
	v := m.mitigation
	if v == nil {
		return
	}
	return *v, true
}

// OldMitigation returns the old "mitigation" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldMitigation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMitigation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMitigation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMitigation: %w", err)
	}
	return oldValue.Mitigation, nil
}

// ClearMitigation clears the value of the "mitigation" field.
func (m *RiskHistoryMutation) ClearMitigation() {
	m.mitigation = nil
	m.clearedFields[riskhistory.FieldMitigation] = struct{}{}
}

// MitigationCleared returns if the "mitigation" field was cleared in this mutation.
func (m *RiskHistoryMutation) MitigationCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldMitigation]
	return ok
}

// ResetMitigation resets all changes to the "mitigation" field.
func (m *RiskHistoryMutation) ResetMitigation() {
	m.mitigation = nil
	delete(m.clearedFields, riskhistory.FieldMitigation)
}

// SetDetails sets the "details" field.
func (m *RiskHistoryMutation) SetDetails(s string) {
	m.details = &s
}

// Details returns the value of the "details" field in the mutation.
func (m *RiskHistoryMutation) Details() (r string, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *RiskHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[riskhistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *RiskHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *RiskHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, riskhistory.FieldDetails)
}

// SetBusinessCosts sets the "business_costs" field.
func (m *RiskHistoryMutation) SetBusinessCosts(s string) {
	m.business_costs = &s
}

// BusinessCosts returns the value of the "business_costs" field in the mutation.
func (m *RiskHistoryMutation) BusinessCosts() (r string, exists bool) {
	v := m.business_costs
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessCosts returns the old "business_costs" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldBusinessCosts(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessCosts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessCosts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessCosts: %w", err)
	}
	return oldValue.BusinessCosts, nil
}

// ClearBusinessCosts clears the value of the "business_costs" field.
func (m *RiskHistoryMutation) ClearBusinessCosts() {
	m.business_costs = nil
	m.clearedFields[riskhistory.FieldBusinessCosts] = struct{}{}
}

// BusinessCostsCleared returns if the "business_costs" field was cleared in this mutation.
func (m *RiskHistoryMutation) BusinessCostsCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldBusinessCosts]
	return ok
}

// ResetBusinessCosts resets all changes to the "business_costs" field.
func (m *RiskHistoryMutation) ResetBusinessCosts() {
	m.business_costs = nil
	delete(m.clearedFields, riskhistory.FieldBusinessCosts)
}

// SetStakeholderID sets the "stakeholder_id" field.
func (m *RiskHistoryMutation) SetStakeholderID(s string) {
	m.stakeholder_id = &s
}

// StakeholderID returns the value of the "stakeholder_id" field in the mutation.
func (m *RiskHistoryMutation) StakeholderID() (r string, exists bool) {
	v := m.stakeholder_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStakeholderID returns the old "stakeholder_id" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldStakeholderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStakeholderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStakeholderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStakeholderID: %w", err)
	}
	return oldValue.StakeholderID, nil
}

// ClearStakeholderID clears the value of the "stakeholder_id" field.
func (m *RiskHistoryMutation) ClearStakeholderID() {
	m.stakeholder_id = nil
	m.clearedFields[riskhistory.FieldStakeholderID] = struct{}{}
}

// StakeholderIDCleared returns if the "stakeholder_id" field was cleared in this mutation.
func (m *RiskHistoryMutation) StakeholderIDCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldStakeholderID]
	return ok
}

// ResetStakeholderID resets all changes to the "stakeholder_id" field.
func (m *RiskHistoryMutation) ResetStakeholderID() {
	m.stakeholder_id = nil
	delete(m.clearedFields, riskhistory.FieldStakeholderID)
}

// SetDelegateID sets the "delegate_id" field.
func (m *RiskHistoryMutation) SetDelegateID(s string) {
	m.delegate_id = &s
}

// DelegateID returns the value of the "delegate_id" field in the mutation.
func (m *RiskHistoryMutation) DelegateID() (r string, exists bool) {
	v := m.delegate_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegateID returns the old "delegate_id" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldDelegateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelegateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelegateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegateID: %w", err)
	}
	return oldValue.DelegateID, nil
}

// ClearDelegateID clears the value of the "delegate_id" field.
func (m *RiskHistoryMutation) ClearDelegateID() {
	m.delegate_id = nil
	m.clearedFields[riskhistory.FieldDelegateID] = struct{}{}
}

// DelegateIDCleared returns if the "delegate_id" field was cleared in this mutation.
func (m *RiskHistoryMutation) DelegateIDCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldDelegateID]
	return ok
}

// ResetDelegateID resets all changes to the "delegate_id" field.
func (m *RiskHistoryMutation) ResetDelegateID() {
	m.delegate_id = nil
	delete(m.clearedFields, riskhistory.FieldDelegateID)
}

// Where appends a list predicates to the RiskHistoryMutation builder.
func (m *RiskHistoryMutation) Where(ps ...predicate.RiskHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiskHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiskHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RiskHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiskHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiskHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RiskHistory).
func (m *RiskHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiskHistoryMutation) Fields() []string {
	fields := make([]string, 0, 28)
	if m.history_time != nil {
		fields = append(fields, riskhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, riskhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, riskhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, riskhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, riskhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, riskhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, riskhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, riskhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, riskhistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, riskhistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, riskhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, riskhistory.FieldOwnerID)
	}
	if m.risk_kind_name != nil {
		fields = append(fields, riskhistory.FieldRiskKindName)
	}
	if m.risk_kind_id != nil {
		fields = append(fields, riskhistory.FieldRiskKindID)
	}
	if m.risk_category_name != nil {
		fields = append(fields, riskhistory.FieldRiskCategoryName)
	}
	if m.risk_category_id != nil {
		fields = append(fields, riskhistory.FieldRiskCategoryID)
	}
	if m.name != nil {
		fields = append(fields, riskhistory.FieldName)
	}
	if m.status != nil {
		fields = append(fields, riskhistory.FieldStatus)
	}
	if m.risk_type != nil {
		fields = append(fields, riskhistory.FieldRiskType)
	}
	if m.category != nil {
		fields = append(fields, riskhistory.FieldCategory)
	}
	if m.impact != nil {
		fields = append(fields, riskhistory.FieldImpact)
	}
	if m.likelihood != nil {
		fields = append(fields, riskhistory.FieldLikelihood)
	}
	if m.score != nil {
		fields = append(fields, riskhistory.FieldScore)
	}
	if m.mitigation != nil {
		fields = append(fields, riskhistory.FieldMitigation)
	}
	if m.details != nil {
		fields = append(fields, riskhistory.FieldDetails)
	}
	if m.business_costs != nil {
		fields = append(fields, riskhistory.FieldBusinessCosts)
	}
	if m.stakeholder_id != nil {
		fields = append(fields, riskhistory.FieldStakeholderID)
	}
	if m.delegate_id != nil {
		fields = append(fields, riskhistory.FieldDelegateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiskHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case riskhistory.FieldHistoryTime:
		return m.HistoryTime()
	case riskhistory.FieldRef:
		return m.Ref()
	case riskhistory.FieldOperation:
		return m.Operation()
	case riskhistory.FieldCreatedAt:
		return m.CreatedAt()
	case riskhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case riskhistory.FieldCreatedBy:
		return m.CreatedBy()
	case riskhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case riskhistory.FieldDeletedAt:
		return m.DeletedAt()
	case riskhistory.FieldDeletedBy:
		return m.DeletedBy()
	case riskhistory.FieldDisplayID:
		return m.DisplayID()
	case riskhistory.FieldTags:
		return m.Tags()
	case riskhistory.FieldOwnerID:
		return m.OwnerID()
	case riskhistory.FieldRiskKindName:
		return m.RiskKindName()
	case riskhistory.FieldRiskKindID:
		return m.RiskKindID()
	case riskhistory.FieldRiskCategoryName:
		return m.RiskCategoryName()
	case riskhistory.FieldRiskCategoryID:
		return m.RiskCategoryID()
	case riskhistory.FieldName:
		return m.Name()
	case riskhistory.FieldStatus:
		return m.Status()
	case riskhistory.FieldRiskType:
		return m.RiskType()
	case riskhistory.FieldCategory:
		return m.Category()
	case riskhistory.FieldImpact:
		return m.Impact()
	case riskhistory.FieldLikelihood:
		return m.Likelihood()
	case riskhistory.FieldScore:
		return m.Score()
	case riskhistory.FieldMitigation:
		return m.Mitigation()
	case riskhistory.FieldDetails:
		return m.Details()
	case riskhistory.FieldBusinessCosts:
		return m.BusinessCosts()
	case riskhistory.FieldStakeholderID:
		return m.StakeholderID()
	case riskhistory.FieldDelegateID:
		return m.DelegateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiskHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case riskhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case riskhistory.FieldRef:
		return m.OldRef(ctx)
	case riskhistory.FieldOperation:
		return m.OldOperation(ctx)
	case riskhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case riskhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case riskhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case riskhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case riskhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case riskhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case riskhistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case riskhistory.FieldTags:
		return m.OldTags(ctx)
	case riskhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case riskhistory.FieldRiskKindName:
		return m.OldRiskKindName(ctx)
	case riskhistory.FieldRiskKindID:
		return m.OldRiskKindID(ctx)
	case riskhistory.FieldRiskCategoryName:
		return m.OldRiskCategoryName(ctx)
	case riskhistory.FieldRiskCategoryID:
		return m.OldRiskCategoryID(ctx)
	case riskhistory.FieldName:
		return m.OldName(ctx)
	case riskhistory.FieldStatus:
		return m.OldStatus(ctx)
	case riskhistory.FieldRiskType:
		return m.OldRiskType(ctx)
	case riskhistory.FieldCategory:
		return m.OldCategory(ctx)
	case riskhistory.FieldImpact:
		return m.OldImpact(ctx)
	case riskhistory.FieldLikelihood:
		return m.OldLikelihood(ctx)
	case riskhistory.FieldScore:
		return m.OldScore(ctx)
	case riskhistory.FieldMitigation:
		return m.OldMitigation(ctx)
	case riskhistory.FieldDetails:
		return m.OldDetails(ctx)
	case riskhistory.FieldBusinessCosts:
		return m.OldBusinessCosts(ctx)
	case riskhistory.FieldStakeholderID:
		return m.OldStakeholderID(ctx)
	case riskhistory.FieldDelegateID:
		return m.OldDelegateID(ctx)
	}
	return nil, fmt.Errorf("unknown RiskHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case riskhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case riskhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case riskhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case riskhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case riskhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case riskhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case riskhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case riskhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case riskhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case riskhistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case riskhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case riskhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case riskhistory.FieldRiskKindName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskKindName(v)
		return nil
	case riskhistory.FieldRiskKindID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskKindID(v)
		return nil
	case riskhistory.FieldRiskCategoryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskCategoryName(v)
		return nil
	case riskhistory.FieldRiskCategoryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskCategoryID(v)
		return nil
	case riskhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case riskhistory.FieldStatus:
		v, ok := value.(enums.RiskStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case riskhistory.FieldRiskType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskType(v)
		return nil
	case riskhistory.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case riskhistory.FieldImpact:
		v, ok := value.(enums.RiskImpact)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpact(v)
		return nil
	case riskhistory.FieldLikelihood:
		v, ok := value.(enums.RiskLikelihood)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikelihood(v)
		return nil
	case riskhistory.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case riskhistory.FieldMitigation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMitigation(v)
		return nil
	case riskhistory.FieldDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case riskhistory.FieldBusinessCosts:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessCosts(v)
		return nil
	case riskhistory.FieldStakeholderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStakeholderID(v)
		return nil
	case riskhistory.FieldDelegateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegateID(v)
		return nil
	}
	return fmt.Errorf("unknown RiskHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiskHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, riskhistory.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiskHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case riskhistory.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case riskhistory.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown RiskHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiskHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(riskhistory.FieldRef) {
		fields = append(fields, riskhistory.FieldRef)
	}
	if m.FieldCleared(riskhistory.FieldCreatedAt) {
		fields = append(fields, riskhistory.FieldCreatedAt)
	}
	if m.FieldCleared(riskhistory.FieldUpdatedAt) {
		fields = append(fields, riskhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(riskhistory.FieldCreatedBy) {
		fields = append(fields, riskhistory.FieldCreatedBy)
	}
	if m.FieldCleared(riskhistory.FieldUpdatedBy) {
		fields = append(fields, riskhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(riskhistory.FieldDeletedAt) {
		fields = append(fields, riskhistory.FieldDeletedAt)
	}
	if m.FieldCleared(riskhistory.FieldDeletedBy) {
		fields = append(fields, riskhistory.FieldDeletedBy)
	}
	if m.FieldCleared(riskhistory.FieldTags) {
		fields = append(fields, riskhistory.FieldTags)
	}
	if m.FieldCleared(riskhistory.FieldOwnerID) {
		fields = append(fields, riskhistory.FieldOwnerID)
	}
	if m.FieldCleared(riskhistory.FieldRiskKindName) {
		fields = append(fields, riskhistory.FieldRiskKindName)
	}
	if m.FieldCleared(riskhistory.FieldRiskKindID) {
		fields = append(fields, riskhistory.FieldRiskKindID)
	}
	if m.FieldCleared(riskhistory.FieldRiskCategoryName) {
		fields = append(fields, riskhistory.FieldRiskCategoryName)
	}
	if m.FieldCleared(riskhistory.FieldRiskCategoryID) {
		fields = append(fields, riskhistory.FieldRiskCategoryID)
	}
	if m.FieldCleared(riskhistory.FieldStatus) {
		fields = append(fields, riskhistory.FieldStatus)
	}
	if m.FieldCleared(riskhistory.FieldRiskType) {
		fields = append(fields, riskhistory.FieldRiskType)
	}
	if m.FieldCleared(riskhistory.FieldCategory) {
		fields = append(fields, riskhistory.FieldCategory)
	}
	if m.FieldCleared(riskhistory.FieldImpact) {
		fields = append(fields, riskhistory.FieldImpact)
	}
	if m.FieldCleared(riskhistory.FieldLikelihood) {
		fields = append(fields, riskhistory.FieldLikelihood)
	}
	if m.FieldCleared(riskhistory.FieldScore) {
		fields = append(fields, riskhistory.FieldScore)
	}
	if m.FieldCleared(riskhistory.FieldMitigation) {
		fields = append(fields, riskhistory.FieldMitigation)
	}
	if m.FieldCleared(riskhistory.FieldDetails) {
		fields = append(fields, riskhistory.FieldDetails)
	}
	if m.FieldCleared(riskhistory.FieldBusinessCosts) {
		fields = append(fields, riskhistory.FieldBusinessCosts)
	}
	if m.FieldCleared(riskhistory.FieldStakeholderID) {
		fields = append(fields, riskhistory.FieldStakeholderID)
	}
	if m.FieldCleared(riskhistory.FieldDelegateID) {
		fields = append(fields, riskhistory.FieldDelegateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiskHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiskHistoryMutation) ClearField(name string) error {
	switch name {
	case riskhistory.FieldRef:
		m.ClearRef()
		return nil
	case riskhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case riskhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case riskhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case riskhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case riskhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case riskhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case riskhistory.FieldTags:
		m.ClearTags()
		return nil
	case riskhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case riskhistory.FieldRiskKindName:
		m.ClearRiskKindName()
		return nil
	case riskhistory.FieldRiskKindID:
		m.ClearRiskKindID()
		return nil
	case riskhistory.FieldRiskCategoryName:
		m.ClearRiskCategoryName()
		return nil
	case riskhistory.FieldRiskCategoryID:
		m.ClearRiskCategoryID()
		return nil
	case riskhistory.FieldStatus:
		m.ClearStatus()
		return nil
	case riskhistory.FieldRiskType:
		m.ClearRiskType()
		return nil
	case riskhistory.FieldCategory:
		m.ClearCategory()
		return nil
	case riskhistory.FieldImpact:
		m.ClearImpact()
		return nil
	case riskhistory.FieldLikelihood:
		m.ClearLikelihood()
		return nil
	case riskhistory.FieldScore:
		m.ClearScore()
		return nil
	case riskhistory.FieldMitigation:
		m.ClearMitigation()
		return nil
	case riskhistory.FieldDetails:
		m.ClearDetails()
		return nil
	case riskhistory.FieldBusinessCosts:
		m.ClearBusinessCosts()
		return nil
	case riskhistory.FieldStakeholderID:
		m.ClearStakeholderID()
		return nil
	case riskhistory.FieldDelegateID:
		m.ClearDelegateID()
		return nil
	}
	return fmt.Errorf("unknown RiskHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiskHistoryMutation) ResetField(name string) error {
	switch name {
	case riskhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case riskhistory.FieldRef:
		m.ResetRef()
		return nil
	case riskhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case riskhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case riskhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case riskhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case riskhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case riskhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case riskhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case riskhistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case riskhistory.FieldTags:
		m.ResetTags()
		return nil
	case riskhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case riskhistory.FieldRiskKindName:
		m.ResetRiskKindName()
		return nil
	case riskhistory.FieldRiskKindID:
		m.ResetRiskKindID()
		return nil
	case riskhistory.FieldRiskCategoryName:
		m.ResetRiskCategoryName()
		return nil
	case riskhistory.FieldRiskCategoryID:
		m.ResetRiskCategoryID()
		return nil
	case riskhistory.FieldName:
		m.ResetName()
		return nil
	case riskhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case riskhistory.FieldRiskType:
		m.ResetRiskType()
		return nil
	case riskhistory.FieldCategory:
		m.ResetCategory()
		return nil
	case riskhistory.FieldImpact:
		m.ResetImpact()
		return nil
	case riskhistory.FieldLikelihood:
		m.ResetLikelihood()
		return nil
	case riskhistory.FieldScore:
		m.ResetScore()
		return nil
	case riskhistory.FieldMitigation:
		m.ResetMitigation()
		return nil
	case riskhistory.FieldDetails:
		m.ResetDetails()
		return nil
	case riskhistory.FieldBusinessCosts:
		m.ResetBusinessCosts()
		return nil
	case riskhistory.FieldStakeholderID:
		m.ResetStakeholderID()
		return nil
	case riskhistory.FieldDelegateID:
		m.ResetDelegateID()
		return nil
	}
	return fmt.Errorf("unknown RiskHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiskHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiskHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiskHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiskHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiskHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiskHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiskHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RiskHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiskHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RiskHistory edge %s", name)
}

// ScanHistoryMutation represents an operation that mutates the ScanHistory nodes in the graph.
type ScanHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	deleted_at    *time.Time
	deleted_by    *string
	tags          *[]string
	appendtags    []string
	owner_id      *string
	target        *string
	scan_type     *enums.ScanType
	metadata      *map[string]interface{}
	status        *enums.ScanStatus
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ScanHistory, error)
	predicates    []predicate.ScanHistory
}

var _ ent.Mutation = (*ScanHistoryMutation)(nil)

// scanhistoryOption allows management of the mutation configuration using functional options.
type scanhistoryOption func(*ScanHistoryMutation)

// newScanHistoryMutation creates new mutation for the ScanHistory entity.
func newScanHistoryMutation(c config, op Op, opts ...scanhistoryOption) *ScanHistoryMutation {
	m := &ScanHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeScanHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScanHistoryID sets the ID field of the mutation.
func withScanHistoryID(id string) scanhistoryOption {
	return func(m *ScanHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ScanHistory
		)
		m.oldValue = func(ctx context.Context) (*ScanHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScanHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScanHistory sets the old ScanHistory of the mutation.
func withScanHistory(node *ScanHistory) scanhistoryOption {
	return func(m *ScanHistoryMutation) {
		m.oldValue = func(context.Context) (*ScanHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScanHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScanHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScanHistory entities.
func (m *ScanHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScanHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScanHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScanHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ScanHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ScanHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ScanHistory entity.
// If the ScanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ScanHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ScanHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ScanHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ScanHistory entity.
// If the ScanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ScanHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[scanhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ScanHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[scanhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ScanHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, scanhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ScanHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ScanHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ScanHistory entity.
// If the ScanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ScanHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ScanHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScanHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ScanHistory entity.
// If the ScanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ScanHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[scanhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ScanHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[scanhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScanHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, scanhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScanHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScanHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ScanHistory entity.
// If the ScanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ScanHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[scanhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ScanHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[scanhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScanHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, scanhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ScanHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ScanHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ScanHistory entity.
// If the ScanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ScanHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[scanhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ScanHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[scanhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ScanHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, scanhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ScanHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ScanHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ScanHistory entity.
// If the ScanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ScanHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[scanhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ScanHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[scanhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ScanHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, scanhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ScanHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ScanHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ScanHistory entity.
// If the ScanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ScanHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[scanhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ScanHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[scanhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ScanHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, scanhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ScanHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ScanHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ScanHistory entity.
// If the ScanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ScanHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[scanhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ScanHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[scanhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ScanHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, scanhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *ScanHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ScanHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ScanHistory entity.
// If the ScanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ScanHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ScanHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ScanHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[scanhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ScanHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[scanhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ScanHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, scanhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *ScanHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ScanHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ScanHistory entity.
// If the ScanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *ScanHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[scanhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *ScanHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[scanhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ScanHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, scanhistory.FieldOwnerID)
}

// SetTarget sets the "target" field.
func (m *ScanHistoryMutation) SetTarget(s string) {
	m.target = &s
}

// Target returns the value of the "target" field in the mutation.
func (m *ScanHistoryMutation) Target() (r string, exists bool) {
	v := m.target
	if v == nil {
		return
	}
	return *v, true
}

// OldTarget returns the old "target" field's value of the ScanHistory entity.
// If the ScanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanHistoryMutation) OldTarget(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTarget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTarget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTarget: %w", err)
	}
	return oldValue.Target, nil
}

// ResetTarget resets all changes to the "target" field.
func (m *ScanHistoryMutation) ResetTarget() {
	m.target = nil
}

// SetScanType sets the "scan_type" field.
func (m *ScanHistoryMutation) SetScanType(et enums.ScanType) {
	m.scan_type = &et
}

// ScanType returns the value of the "scan_type" field in the mutation.
func (m *ScanHistoryMutation) ScanType() (r enums.ScanType, exists bool) {
	v := m.scan_type
	if v == nil {
		return
	}
	return *v, true
}

// OldScanType returns the old "scan_type" field's value of the ScanHistory entity.
// If the ScanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanHistoryMutation) OldScanType(ctx context.Context) (v enums.ScanType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScanType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScanType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScanType: %w", err)
	}
	return oldValue.ScanType, nil
}

// ResetScanType resets all changes to the "scan_type" field.
func (m *ScanHistoryMutation) ResetScanType() {
	m.scan_type = nil
}

// SetMetadata sets the "metadata" field.
func (m *ScanHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ScanHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ScanHistory entity.
// If the ScanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ScanHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[scanhistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ScanHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[scanhistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ScanHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, scanhistory.FieldMetadata)
}

// SetStatus sets the "status" field.
func (m *ScanHistoryMutation) SetStatus(es enums.ScanStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *ScanHistoryMutation) Status() (r enums.ScanStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ScanHistory entity.
// If the ScanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanHistoryMutation) OldStatus(ctx context.Context) (v enums.ScanStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ScanHistoryMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the ScanHistoryMutation builder.
func (m *ScanHistoryMutation) Where(ps ...predicate.ScanHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScanHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScanHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScanHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScanHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScanHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScanHistory).
func (m *ScanHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScanHistoryMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.history_time != nil {
		fields = append(fields, scanhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, scanhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, scanhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, scanhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, scanhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, scanhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, scanhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, scanhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, scanhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, scanhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, scanhistory.FieldOwnerID)
	}
	if m.target != nil {
		fields = append(fields, scanhistory.FieldTarget)
	}
	if m.scan_type != nil {
		fields = append(fields, scanhistory.FieldScanType)
	}
	if m.metadata != nil {
		fields = append(fields, scanhistory.FieldMetadata)
	}
	if m.status != nil {
		fields = append(fields, scanhistory.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScanHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scanhistory.FieldHistoryTime:
		return m.HistoryTime()
	case scanhistory.FieldRef:
		return m.Ref()
	case scanhistory.FieldOperation:
		return m.Operation()
	case scanhistory.FieldCreatedAt:
		return m.CreatedAt()
	case scanhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case scanhistory.FieldCreatedBy:
		return m.CreatedBy()
	case scanhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case scanhistory.FieldDeletedAt:
		return m.DeletedAt()
	case scanhistory.FieldDeletedBy:
		return m.DeletedBy()
	case scanhistory.FieldTags:
		return m.Tags()
	case scanhistory.FieldOwnerID:
		return m.OwnerID()
	case scanhistory.FieldTarget:
		return m.Target()
	case scanhistory.FieldScanType:
		return m.ScanType()
	case scanhistory.FieldMetadata:
		return m.Metadata()
	case scanhistory.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScanHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scanhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case scanhistory.FieldRef:
		return m.OldRef(ctx)
	case scanhistory.FieldOperation:
		return m.OldOperation(ctx)
	case scanhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case scanhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case scanhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case scanhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case scanhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case scanhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case scanhistory.FieldTags:
		return m.OldTags(ctx)
	case scanhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case scanhistory.FieldTarget:
		return m.OldTarget(ctx)
	case scanhistory.FieldScanType:
		return m.OldScanType(ctx)
	case scanhistory.FieldMetadata:
		return m.OldMetadata(ctx)
	case scanhistory.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ScanHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScanHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scanhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case scanhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case scanhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case scanhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case scanhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case scanhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case scanhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case scanhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case scanhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case scanhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case scanhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case scanhistory.FieldTarget:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTarget(v)
		return nil
	case scanhistory.FieldScanType:
		v, ok := value.(enums.ScanType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScanType(v)
		return nil
	case scanhistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case scanhistory.FieldStatus:
		v, ok := value.(enums.ScanStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ScanHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScanHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScanHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScanHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ScanHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScanHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(scanhistory.FieldRef) {
		fields = append(fields, scanhistory.FieldRef)
	}
	if m.FieldCleared(scanhistory.FieldCreatedAt) {
		fields = append(fields, scanhistory.FieldCreatedAt)
	}
	if m.FieldCleared(scanhistory.FieldUpdatedAt) {
		fields = append(fields, scanhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(scanhistory.FieldCreatedBy) {
		fields = append(fields, scanhistory.FieldCreatedBy)
	}
	if m.FieldCleared(scanhistory.FieldUpdatedBy) {
		fields = append(fields, scanhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(scanhistory.FieldDeletedAt) {
		fields = append(fields, scanhistory.FieldDeletedAt)
	}
	if m.FieldCleared(scanhistory.FieldDeletedBy) {
		fields = append(fields, scanhistory.FieldDeletedBy)
	}
	if m.FieldCleared(scanhistory.FieldTags) {
		fields = append(fields, scanhistory.FieldTags)
	}
	if m.FieldCleared(scanhistory.FieldOwnerID) {
		fields = append(fields, scanhistory.FieldOwnerID)
	}
	if m.FieldCleared(scanhistory.FieldMetadata) {
		fields = append(fields, scanhistory.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScanHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScanHistoryMutation) ClearField(name string) error {
	switch name {
	case scanhistory.FieldRef:
		m.ClearRef()
		return nil
	case scanhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case scanhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case scanhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case scanhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case scanhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case scanhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case scanhistory.FieldTags:
		m.ClearTags()
		return nil
	case scanhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case scanhistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown ScanHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScanHistoryMutation) ResetField(name string) error {
	switch name {
	case scanhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case scanhistory.FieldRef:
		m.ResetRef()
		return nil
	case scanhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case scanhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case scanhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case scanhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case scanhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case scanhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case scanhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case scanhistory.FieldTags:
		m.ResetTags()
		return nil
	case scanhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case scanhistory.FieldTarget:
		m.ResetTarget()
		return nil
	case scanhistory.FieldScanType:
		m.ResetScanType()
		return nil
	case scanhistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	case scanhistory.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ScanHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScanHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScanHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScanHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScanHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScanHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScanHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScanHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ScanHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScanHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ScanHistory edge %s", name)
}

// ScheduledJobHistoryMutation represents an operation that mutates the ScheduledJobHistory nodes in the graph.
type ScheduledJobHistoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	history_time        *time.Time
	ref                 *string
	operation           *history.OpType
	created_at          *time.Time
	updated_at          *time.Time
	created_by          *string
	updated_by          *string
	deleted_at          *time.Time
	deleted_by          *string
	display_id          *string
	owner_id            *string
	job_id              *string
	active              *bool
	configuration       *models.JobConfiguration
	appendconfiguration models.JobConfiguration
	cron                *models.Cron
	job_runner_id       *string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*ScheduledJobHistory, error)
	predicates          []predicate.ScheduledJobHistory
}

var _ ent.Mutation = (*ScheduledJobHistoryMutation)(nil)

// scheduledjobhistoryOption allows management of the mutation configuration using functional options.
type scheduledjobhistoryOption func(*ScheduledJobHistoryMutation)

// newScheduledJobHistoryMutation creates new mutation for the ScheduledJobHistory entity.
func newScheduledJobHistoryMutation(c config, op Op, opts ...scheduledjobhistoryOption) *ScheduledJobHistoryMutation {
	m := &ScheduledJobHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeScheduledJobHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduledJobHistoryID sets the ID field of the mutation.
func withScheduledJobHistoryID(id string) scheduledjobhistoryOption {
	return func(m *ScheduledJobHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ScheduledJobHistory
		)
		m.oldValue = func(ctx context.Context) (*ScheduledJobHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScheduledJobHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScheduledJobHistory sets the old ScheduledJobHistory of the mutation.
func withScheduledJobHistory(node *ScheduledJobHistory) scheduledjobhistoryOption {
	return func(m *ScheduledJobHistoryMutation) {
		m.oldValue = func(context.Context) (*ScheduledJobHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduledJobHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduledJobHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScheduledJobHistory entities.
func (m *ScheduledJobHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduledJobHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheduledJobHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScheduledJobHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ScheduledJobHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ScheduledJobHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ScheduledJobHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ScheduledJobHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ScheduledJobHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ScheduledJobHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[scheduledjobhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ScheduledJobHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[scheduledjobhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ScheduledJobHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, scheduledjobhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ScheduledJobHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ScheduledJobHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ScheduledJobHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ScheduledJobHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScheduledJobHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ScheduledJobHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[scheduledjobhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ScheduledJobHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[scheduledjobhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScheduledJobHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, scheduledjobhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScheduledJobHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScheduledJobHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ScheduledJobHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[scheduledjobhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ScheduledJobHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[scheduledjobhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScheduledJobHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, scheduledjobhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ScheduledJobHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ScheduledJobHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ScheduledJobHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[scheduledjobhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ScheduledJobHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[scheduledjobhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ScheduledJobHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, scheduledjobhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ScheduledJobHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ScheduledJobHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ScheduledJobHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[scheduledjobhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ScheduledJobHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[scheduledjobhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ScheduledJobHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, scheduledjobhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ScheduledJobHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ScheduledJobHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ScheduledJobHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[scheduledjobhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ScheduledJobHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[scheduledjobhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ScheduledJobHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, scheduledjobhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ScheduledJobHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ScheduledJobHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ScheduledJobHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[scheduledjobhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ScheduledJobHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[scheduledjobhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ScheduledJobHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, scheduledjobhistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *ScheduledJobHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *ScheduledJobHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *ScheduledJobHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *ScheduledJobHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ScheduledJobHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *ScheduledJobHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[scheduledjobhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *ScheduledJobHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[scheduledjobhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ScheduledJobHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, scheduledjobhistory.FieldOwnerID)
}

// SetJobID sets the "job_id" field.
func (m *ScheduledJobHistoryMutation) SetJobID(s string) {
	m.job_id = &s
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *ScheduledJobHistoryMutation) JobID() (r string, exists bool) {
	v := m.job_id
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldJobID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ResetJobID resets all changes to the "job_id" field.
func (m *ScheduledJobHistoryMutation) ResetJobID() {
	m.job_id = nil
}

// SetActive sets the "active" field.
func (m *ScheduledJobHistoryMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *ScheduledJobHistoryMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *ScheduledJobHistoryMutation) ResetActive() {
	m.active = nil
}

// SetConfiguration sets the "configuration" field.
func (m *ScheduledJobHistoryMutation) SetConfiguration(mc models.JobConfiguration) {
	m.configuration = &mc
	m.appendconfiguration = nil
}

// Configuration returns the value of the "configuration" field in the mutation.
func (m *ScheduledJobHistoryMutation) Configuration() (r models.JobConfiguration, exists bool) {
	v := m.configuration
	if v == nil {
		return
	}
	return *v, true
}

// OldConfiguration returns the old "configuration" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldConfiguration(ctx context.Context) (v models.JobConfiguration, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfiguration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfiguration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfiguration: %w", err)
	}
	return oldValue.Configuration, nil
}

// AppendConfiguration adds mc to the "configuration" field.
func (m *ScheduledJobHistoryMutation) AppendConfiguration(mc models.JobConfiguration) {
	m.appendconfiguration = append(m.appendconfiguration, mc...)
}

// AppendedConfiguration returns the list of values that were appended to the "configuration" field in this mutation.
func (m *ScheduledJobHistoryMutation) AppendedConfiguration() (models.JobConfiguration, bool) {
	if len(m.appendconfiguration) == 0 {
		return nil, false
	}
	return m.appendconfiguration, true
}

// ClearConfiguration clears the value of the "configuration" field.
func (m *ScheduledJobHistoryMutation) ClearConfiguration() {
	m.configuration = nil
	m.appendconfiguration = nil
	m.clearedFields[scheduledjobhistory.FieldConfiguration] = struct{}{}
}

// ConfigurationCleared returns if the "configuration" field was cleared in this mutation.
func (m *ScheduledJobHistoryMutation) ConfigurationCleared() bool {
	_, ok := m.clearedFields[scheduledjobhistory.FieldConfiguration]
	return ok
}

// ResetConfiguration resets all changes to the "configuration" field.
func (m *ScheduledJobHistoryMutation) ResetConfiguration() {
	m.configuration = nil
	m.appendconfiguration = nil
	delete(m.clearedFields, scheduledjobhistory.FieldConfiguration)
}

// SetCron sets the "cron" field.
func (m *ScheduledJobHistoryMutation) SetCron(value models.Cron) {
	m.cron = &value
}

// Cron returns the value of the "cron" field in the mutation.
func (m *ScheduledJobHistoryMutation) Cron() (r models.Cron, exists bool) {
	v := m.cron
	if v == nil {
		return
	}
	return *v, true
}

// OldCron returns the old "cron" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldCron(ctx context.Context) (v *models.Cron, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCron is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCron requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCron: %w", err)
	}
	return oldValue.Cron, nil
}

// ClearCron clears the value of the "cron" field.
func (m *ScheduledJobHistoryMutation) ClearCron() {
	m.cron = nil
	m.clearedFields[scheduledjobhistory.FieldCron] = struct{}{}
}

// CronCleared returns if the "cron" field was cleared in this mutation.
func (m *ScheduledJobHistoryMutation) CronCleared() bool {
	_, ok := m.clearedFields[scheduledjobhistory.FieldCron]
	return ok
}

// ResetCron resets all changes to the "cron" field.
func (m *ScheduledJobHistoryMutation) ResetCron() {
	m.cron = nil
	delete(m.clearedFields, scheduledjobhistory.FieldCron)
}

// SetJobRunnerID sets the "job_runner_id" field.
func (m *ScheduledJobHistoryMutation) SetJobRunnerID(s string) {
	m.job_runner_id = &s
}

// JobRunnerID returns the value of the "job_runner_id" field in the mutation.
func (m *ScheduledJobHistoryMutation) JobRunnerID() (r string, exists bool) {
	v := m.job_runner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldJobRunnerID returns the old "job_runner_id" field's value of the ScheduledJobHistory entity.
// If the ScheduledJobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledJobHistoryMutation) OldJobRunnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobRunnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobRunnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobRunnerID: %w", err)
	}
	return oldValue.JobRunnerID, nil
}

// ClearJobRunnerID clears the value of the "job_runner_id" field.
func (m *ScheduledJobHistoryMutation) ClearJobRunnerID() {
	m.job_runner_id = nil
	m.clearedFields[scheduledjobhistory.FieldJobRunnerID] = struct{}{}
}

// JobRunnerIDCleared returns if the "job_runner_id" field was cleared in this mutation.
func (m *ScheduledJobHistoryMutation) JobRunnerIDCleared() bool {
	_, ok := m.clearedFields[scheduledjobhistory.FieldJobRunnerID]
	return ok
}

// ResetJobRunnerID resets all changes to the "job_runner_id" field.
func (m *ScheduledJobHistoryMutation) ResetJobRunnerID() {
	m.job_runner_id = nil
	delete(m.clearedFields, scheduledjobhistory.FieldJobRunnerID)
}

// Where appends a list predicates to the ScheduledJobHistoryMutation builder.
func (m *ScheduledJobHistoryMutation) Where(ps ...predicate.ScheduledJobHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScheduledJobHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScheduledJobHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScheduledJobHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScheduledJobHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScheduledJobHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScheduledJobHistory).
func (m *ScheduledJobHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduledJobHistoryMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.history_time != nil {
		fields = append(fields, scheduledjobhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, scheduledjobhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, scheduledjobhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, scheduledjobhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, scheduledjobhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, scheduledjobhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, scheduledjobhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, scheduledjobhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, scheduledjobhistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, scheduledjobhistory.FieldDisplayID)
	}
	if m.owner_id != nil {
		fields = append(fields, scheduledjobhistory.FieldOwnerID)
	}
	if m.job_id != nil {
		fields = append(fields, scheduledjobhistory.FieldJobID)
	}
	if m.active != nil {
		fields = append(fields, scheduledjobhistory.FieldActive)
	}
	if m.configuration != nil {
		fields = append(fields, scheduledjobhistory.FieldConfiguration)
	}
	if m.cron != nil {
		fields = append(fields, scheduledjobhistory.FieldCron)
	}
	if m.job_runner_id != nil {
		fields = append(fields, scheduledjobhistory.FieldJobRunnerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduledJobHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scheduledjobhistory.FieldHistoryTime:
		return m.HistoryTime()
	case scheduledjobhistory.FieldRef:
		return m.Ref()
	case scheduledjobhistory.FieldOperation:
		return m.Operation()
	case scheduledjobhistory.FieldCreatedAt:
		return m.CreatedAt()
	case scheduledjobhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case scheduledjobhistory.FieldCreatedBy:
		return m.CreatedBy()
	case scheduledjobhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case scheduledjobhistory.FieldDeletedAt:
		return m.DeletedAt()
	case scheduledjobhistory.FieldDeletedBy:
		return m.DeletedBy()
	case scheduledjobhistory.FieldDisplayID:
		return m.DisplayID()
	case scheduledjobhistory.FieldOwnerID:
		return m.OwnerID()
	case scheduledjobhistory.FieldJobID:
		return m.JobID()
	case scheduledjobhistory.FieldActive:
		return m.Active()
	case scheduledjobhistory.FieldConfiguration:
		return m.Configuration()
	case scheduledjobhistory.FieldCron:
		return m.Cron()
	case scheduledjobhistory.FieldJobRunnerID:
		return m.JobRunnerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduledJobHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scheduledjobhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case scheduledjobhistory.FieldRef:
		return m.OldRef(ctx)
	case scheduledjobhistory.FieldOperation:
		return m.OldOperation(ctx)
	case scheduledjobhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case scheduledjobhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case scheduledjobhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case scheduledjobhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case scheduledjobhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case scheduledjobhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case scheduledjobhistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case scheduledjobhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case scheduledjobhistory.FieldJobID:
		return m.OldJobID(ctx)
	case scheduledjobhistory.FieldActive:
		return m.OldActive(ctx)
	case scheduledjobhistory.FieldConfiguration:
		return m.OldConfiguration(ctx)
	case scheduledjobhistory.FieldCron:
		return m.OldCron(ctx)
	case scheduledjobhistory.FieldJobRunnerID:
		return m.OldJobRunnerID(ctx)
	}
	return nil, fmt.Errorf("unknown ScheduledJobHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduledJobHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scheduledjobhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case scheduledjobhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case scheduledjobhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case scheduledjobhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case scheduledjobhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case scheduledjobhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case scheduledjobhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case scheduledjobhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case scheduledjobhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case scheduledjobhistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case scheduledjobhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case scheduledjobhistory.FieldJobID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case scheduledjobhistory.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case scheduledjobhistory.FieldConfiguration:
		v, ok := value.(models.JobConfiguration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfiguration(v)
		return nil
	case scheduledjobhistory.FieldCron:
		v, ok := value.(models.Cron)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCron(v)
		return nil
	case scheduledjobhistory.FieldJobRunnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobRunnerID(v)
		return nil
	}
	return fmt.Errorf("unknown ScheduledJobHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduledJobHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduledJobHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduledJobHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ScheduledJobHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduledJobHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(scheduledjobhistory.FieldRef) {
		fields = append(fields, scheduledjobhistory.FieldRef)
	}
	if m.FieldCleared(scheduledjobhistory.FieldCreatedAt) {
		fields = append(fields, scheduledjobhistory.FieldCreatedAt)
	}
	if m.FieldCleared(scheduledjobhistory.FieldUpdatedAt) {
		fields = append(fields, scheduledjobhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(scheduledjobhistory.FieldCreatedBy) {
		fields = append(fields, scheduledjobhistory.FieldCreatedBy)
	}
	if m.FieldCleared(scheduledjobhistory.FieldUpdatedBy) {
		fields = append(fields, scheduledjobhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(scheduledjobhistory.FieldDeletedAt) {
		fields = append(fields, scheduledjobhistory.FieldDeletedAt)
	}
	if m.FieldCleared(scheduledjobhistory.FieldDeletedBy) {
		fields = append(fields, scheduledjobhistory.FieldDeletedBy)
	}
	if m.FieldCleared(scheduledjobhistory.FieldOwnerID) {
		fields = append(fields, scheduledjobhistory.FieldOwnerID)
	}
	if m.FieldCleared(scheduledjobhistory.FieldConfiguration) {
		fields = append(fields, scheduledjobhistory.FieldConfiguration)
	}
	if m.FieldCleared(scheduledjobhistory.FieldCron) {
		fields = append(fields, scheduledjobhistory.FieldCron)
	}
	if m.FieldCleared(scheduledjobhistory.FieldJobRunnerID) {
		fields = append(fields, scheduledjobhistory.FieldJobRunnerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduledJobHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduledJobHistoryMutation) ClearField(name string) error {
	switch name {
	case scheduledjobhistory.FieldRef:
		m.ClearRef()
		return nil
	case scheduledjobhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case scheduledjobhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case scheduledjobhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case scheduledjobhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case scheduledjobhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case scheduledjobhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case scheduledjobhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case scheduledjobhistory.FieldConfiguration:
		m.ClearConfiguration()
		return nil
	case scheduledjobhistory.FieldCron:
		m.ClearCron()
		return nil
	case scheduledjobhistory.FieldJobRunnerID:
		m.ClearJobRunnerID()
		return nil
	}
	return fmt.Errorf("unknown ScheduledJobHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduledJobHistoryMutation) ResetField(name string) error {
	switch name {
	case scheduledjobhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case scheduledjobhistory.FieldRef:
		m.ResetRef()
		return nil
	case scheduledjobhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case scheduledjobhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case scheduledjobhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case scheduledjobhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case scheduledjobhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case scheduledjobhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case scheduledjobhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case scheduledjobhistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case scheduledjobhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case scheduledjobhistory.FieldJobID:
		m.ResetJobID()
		return nil
	case scheduledjobhistory.FieldActive:
		m.ResetActive()
		return nil
	case scheduledjobhistory.FieldConfiguration:
		m.ResetConfiguration()
		return nil
	case scheduledjobhistory.FieldCron:
		m.ResetCron()
		return nil
	case scheduledjobhistory.FieldJobRunnerID:
		m.ResetJobRunnerID()
		return nil
	}
	return fmt.Errorf("unknown ScheduledJobHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduledJobHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduledJobHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduledJobHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduledJobHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduledJobHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduledJobHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduledJobHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ScheduledJobHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduledJobHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ScheduledJobHistory edge %s", name)
}

// StandardHistoryMutation represents an operation that mutates the StandardHistory nodes in the graph.
type StandardHistoryMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	history_time            *time.Time
	ref                     *string
	operation               *history.OpType
	created_at              *time.Time
	updated_at              *time.Time
	created_by              *string
	updated_by              *string
	deleted_at              *time.Time
	deleted_by              *string
	tags                    *[]string
	appendtags              []string
	revision                *string
	owner_id                *string
	system_owned            *bool
	internal_notes          *string
	system_internal_id      *string
	name                    *string
	short_name              *string
	framework               *string
	description             *string
	governing_body_logo_url *string
	governing_body          *string
	domains                 *[]string
	appenddomains           []string
	link                    *string
	status                  *enums.StandardStatus
	is_public               *bool
	free_to_use             *bool
	standard_type           *string
	version                 *string
	logo_file_id            *string
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*StandardHistory, error)
	predicates              []predicate.StandardHistory
}

var _ ent.Mutation = (*StandardHistoryMutation)(nil)

// standardhistoryOption allows management of the mutation configuration using functional options.
type standardhistoryOption func(*StandardHistoryMutation)

// newStandardHistoryMutation creates new mutation for the StandardHistory entity.
func newStandardHistoryMutation(c config, op Op, opts ...standardhistoryOption) *StandardHistoryMutation {
	m := &StandardHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeStandardHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStandardHistoryID sets the ID field of the mutation.
func withStandardHistoryID(id string) standardhistoryOption {
	return func(m *StandardHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *StandardHistory
		)
		m.oldValue = func(ctx context.Context) (*StandardHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StandardHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStandardHistory sets the old StandardHistory of the mutation.
func withStandardHistory(node *StandardHistory) standardhistoryOption {
	return func(m *StandardHistoryMutation) {
		m.oldValue = func(context.Context) (*StandardHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StandardHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StandardHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StandardHistory entities.
func (m *StandardHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StandardHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StandardHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StandardHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *StandardHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *StandardHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *StandardHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *StandardHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *StandardHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *StandardHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[standardhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *StandardHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *StandardHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, standardhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *StandardHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *StandardHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *StandardHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StandardHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StandardHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *StandardHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[standardhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *StandardHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StandardHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, standardhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StandardHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StandardHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *StandardHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[standardhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *StandardHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StandardHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, standardhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *StandardHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *StandardHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *StandardHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[standardhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *StandardHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *StandardHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, standardhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *StandardHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *StandardHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *StandardHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[standardhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *StandardHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *StandardHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, standardhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StandardHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StandardHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StandardHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[standardhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StandardHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StandardHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, standardhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *StandardHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *StandardHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *StandardHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[standardhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *StandardHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *StandardHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, standardhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *StandardHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *StandardHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *StandardHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *StandardHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *StandardHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[standardhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *StandardHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *StandardHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, standardhistory.FieldTags)
}

// SetRevision sets the "revision" field.
func (m *StandardHistoryMutation) SetRevision(s string) {
	m.revision = &s
}

// Revision returns the value of the "revision" field in the mutation.
func (m *StandardHistoryMutation) Revision() (r string, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldRevision(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// ClearRevision clears the value of the "revision" field.
func (m *StandardHistoryMutation) ClearRevision() {
	m.revision = nil
	m.clearedFields[standardhistory.FieldRevision] = struct{}{}
}

// RevisionCleared returns if the "revision" field was cleared in this mutation.
func (m *StandardHistoryMutation) RevisionCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldRevision]
	return ok
}

// ResetRevision resets all changes to the "revision" field.
func (m *StandardHistoryMutation) ResetRevision() {
	m.revision = nil
	delete(m.clearedFields, standardhistory.FieldRevision)
}

// SetOwnerID sets the "owner_id" field.
func (m *StandardHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *StandardHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *StandardHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[standardhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *StandardHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *StandardHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, standardhistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *StandardHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *StandardHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *StandardHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[standardhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *StandardHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *StandardHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, standardhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *StandardHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *StandardHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *StandardHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[standardhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *StandardHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *StandardHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, standardhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *StandardHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *StandardHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *StandardHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[standardhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *StandardHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *StandardHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, standardhistory.FieldSystemInternalID)
}

// SetName sets the "name" field.
func (m *StandardHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StandardHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StandardHistoryMutation) ResetName() {
	m.name = nil
}

// SetShortName sets the "short_name" field.
func (m *StandardHistoryMutation) SetShortName(s string) {
	m.short_name = &s
}

// ShortName returns the value of the "short_name" field in the mutation.
func (m *StandardHistoryMutation) ShortName() (r string, exists bool) {
	v := m.short_name
	if v == nil {
		return
	}
	return *v, true
}

// OldShortName returns the old "short_name" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldShortName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortName: %w", err)
	}
	return oldValue.ShortName, nil
}

// ClearShortName clears the value of the "short_name" field.
func (m *StandardHistoryMutation) ClearShortName() {
	m.short_name = nil
	m.clearedFields[standardhistory.FieldShortName] = struct{}{}
}

// ShortNameCleared returns if the "short_name" field was cleared in this mutation.
func (m *StandardHistoryMutation) ShortNameCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldShortName]
	return ok
}

// ResetShortName resets all changes to the "short_name" field.
func (m *StandardHistoryMutation) ResetShortName() {
	m.short_name = nil
	delete(m.clearedFields, standardhistory.FieldShortName)
}

// SetFramework sets the "framework" field.
func (m *StandardHistoryMutation) SetFramework(s string) {
	m.framework = &s
}

// Framework returns the value of the "framework" field in the mutation.
func (m *StandardHistoryMutation) Framework() (r string, exists bool) {
	v := m.framework
	if v == nil {
		return
	}
	return *v, true
}

// OldFramework returns the old "framework" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldFramework(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFramework is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFramework requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFramework: %w", err)
	}
	return oldValue.Framework, nil
}

// ClearFramework clears the value of the "framework" field.
func (m *StandardHistoryMutation) ClearFramework() {
	m.framework = nil
	m.clearedFields[standardhistory.FieldFramework] = struct{}{}
}

// FrameworkCleared returns if the "framework" field was cleared in this mutation.
func (m *StandardHistoryMutation) FrameworkCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldFramework]
	return ok
}

// ResetFramework resets all changes to the "framework" field.
func (m *StandardHistoryMutation) ResetFramework() {
	m.framework = nil
	delete(m.clearedFields, standardhistory.FieldFramework)
}

// SetDescription sets the "description" field.
func (m *StandardHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StandardHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StandardHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[standardhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StandardHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StandardHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, standardhistory.FieldDescription)
}

// SetGoverningBodyLogoURL sets the "governing_body_logo_url" field.
func (m *StandardHistoryMutation) SetGoverningBodyLogoURL(s string) {
	m.governing_body_logo_url = &s
}

// GoverningBodyLogoURL returns the value of the "governing_body_logo_url" field in the mutation.
func (m *StandardHistoryMutation) GoverningBodyLogoURL() (r string, exists bool) {
	v := m.governing_body_logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGoverningBodyLogoURL returns the old "governing_body_logo_url" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldGoverningBodyLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoverningBodyLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoverningBodyLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoverningBodyLogoURL: %w", err)
	}
	return oldValue.GoverningBodyLogoURL, nil
}

// ClearGoverningBodyLogoURL clears the value of the "governing_body_logo_url" field.
func (m *StandardHistoryMutation) ClearGoverningBodyLogoURL() {
	m.governing_body_logo_url = nil
	m.clearedFields[standardhistory.FieldGoverningBodyLogoURL] = struct{}{}
}

// GoverningBodyLogoURLCleared returns if the "governing_body_logo_url" field was cleared in this mutation.
func (m *StandardHistoryMutation) GoverningBodyLogoURLCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldGoverningBodyLogoURL]
	return ok
}

// ResetGoverningBodyLogoURL resets all changes to the "governing_body_logo_url" field.
func (m *StandardHistoryMutation) ResetGoverningBodyLogoURL() {
	m.governing_body_logo_url = nil
	delete(m.clearedFields, standardhistory.FieldGoverningBodyLogoURL)
}

// SetGoverningBody sets the "governing_body" field.
func (m *StandardHistoryMutation) SetGoverningBody(s string) {
	m.governing_body = &s
}

// GoverningBody returns the value of the "governing_body" field in the mutation.
func (m *StandardHistoryMutation) GoverningBody() (r string, exists bool) {
	v := m.governing_body
	if v == nil {
		return
	}
	return *v, true
}

// OldGoverningBody returns the old "governing_body" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldGoverningBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoverningBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoverningBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoverningBody: %w", err)
	}
	return oldValue.GoverningBody, nil
}

// ClearGoverningBody clears the value of the "governing_body" field.
func (m *StandardHistoryMutation) ClearGoverningBody() {
	m.governing_body = nil
	m.clearedFields[standardhistory.FieldGoverningBody] = struct{}{}
}

// GoverningBodyCleared returns if the "governing_body" field was cleared in this mutation.
func (m *StandardHistoryMutation) GoverningBodyCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldGoverningBody]
	return ok
}

// ResetGoverningBody resets all changes to the "governing_body" field.
func (m *StandardHistoryMutation) ResetGoverningBody() {
	m.governing_body = nil
	delete(m.clearedFields, standardhistory.FieldGoverningBody)
}

// SetDomains sets the "domains" field.
func (m *StandardHistoryMutation) SetDomains(s []string) {
	m.domains = &s
	m.appenddomains = nil
}

// Domains returns the value of the "domains" field in the mutation.
func (m *StandardHistoryMutation) Domains() (r []string, exists bool) {
	v := m.domains
	if v == nil {
		return
	}
	return *v, true
}

// OldDomains returns the old "domains" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldDomains(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomains: %w", err)
	}
	return oldValue.Domains, nil
}

// AppendDomains adds s to the "domains" field.
func (m *StandardHistoryMutation) AppendDomains(s []string) {
	m.appenddomains = append(m.appenddomains, s...)
}

// AppendedDomains returns the list of values that were appended to the "domains" field in this mutation.
func (m *StandardHistoryMutation) AppendedDomains() ([]string, bool) {
	if len(m.appenddomains) == 0 {
		return nil, false
	}
	return m.appenddomains, true
}

// ClearDomains clears the value of the "domains" field.
func (m *StandardHistoryMutation) ClearDomains() {
	m.domains = nil
	m.appenddomains = nil
	m.clearedFields[standardhistory.FieldDomains] = struct{}{}
}

// DomainsCleared returns if the "domains" field was cleared in this mutation.
func (m *StandardHistoryMutation) DomainsCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldDomains]
	return ok
}

// ResetDomains resets all changes to the "domains" field.
func (m *StandardHistoryMutation) ResetDomains() {
	m.domains = nil
	m.appenddomains = nil
	delete(m.clearedFields, standardhistory.FieldDomains)
}

// SetLink sets the "link" field.
func (m *StandardHistoryMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *StandardHistoryMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *StandardHistoryMutation) ClearLink() {
	m.link = nil
	m.clearedFields[standardhistory.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *StandardHistoryMutation) LinkCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *StandardHistoryMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, standardhistory.FieldLink)
}

// SetStatus sets the "status" field.
func (m *StandardHistoryMutation) SetStatus(es enums.StandardStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *StandardHistoryMutation) Status() (r enums.StandardStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldStatus(ctx context.Context) (v enums.StandardStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *StandardHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[standardhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *StandardHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *StandardHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, standardhistory.FieldStatus)
}

// SetIsPublic sets the "is_public" field.
func (m *StandardHistoryMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *StandardHistoryMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ClearIsPublic clears the value of the "is_public" field.
func (m *StandardHistoryMutation) ClearIsPublic() {
	m.is_public = nil
	m.clearedFields[standardhistory.FieldIsPublic] = struct{}{}
}

// IsPublicCleared returns if the "is_public" field was cleared in this mutation.
func (m *StandardHistoryMutation) IsPublicCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldIsPublic]
	return ok
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *StandardHistoryMutation) ResetIsPublic() {
	m.is_public = nil
	delete(m.clearedFields, standardhistory.FieldIsPublic)
}

// SetFreeToUse sets the "free_to_use" field.
func (m *StandardHistoryMutation) SetFreeToUse(b bool) {
	m.free_to_use = &b
}

// FreeToUse returns the value of the "free_to_use" field in the mutation.
func (m *StandardHistoryMutation) FreeToUse() (r bool, exists bool) {
	v := m.free_to_use
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeToUse returns the old "free_to_use" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldFreeToUse(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeToUse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeToUse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeToUse: %w", err)
	}
	return oldValue.FreeToUse, nil
}

// ClearFreeToUse clears the value of the "free_to_use" field.
func (m *StandardHistoryMutation) ClearFreeToUse() {
	m.free_to_use = nil
	m.clearedFields[standardhistory.FieldFreeToUse] = struct{}{}
}

// FreeToUseCleared returns if the "free_to_use" field was cleared in this mutation.
func (m *StandardHistoryMutation) FreeToUseCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldFreeToUse]
	return ok
}

// ResetFreeToUse resets all changes to the "free_to_use" field.
func (m *StandardHistoryMutation) ResetFreeToUse() {
	m.free_to_use = nil
	delete(m.clearedFields, standardhistory.FieldFreeToUse)
}

// SetStandardType sets the "standard_type" field.
func (m *StandardHistoryMutation) SetStandardType(s string) {
	m.standard_type = &s
}

// StandardType returns the value of the "standard_type" field in the mutation.
func (m *StandardHistoryMutation) StandardType() (r string, exists bool) {
	v := m.standard_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStandardType returns the old "standard_type" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldStandardType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStandardType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStandardType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStandardType: %w", err)
	}
	return oldValue.StandardType, nil
}

// ClearStandardType clears the value of the "standard_type" field.
func (m *StandardHistoryMutation) ClearStandardType() {
	m.standard_type = nil
	m.clearedFields[standardhistory.FieldStandardType] = struct{}{}
}

// StandardTypeCleared returns if the "standard_type" field was cleared in this mutation.
func (m *StandardHistoryMutation) StandardTypeCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldStandardType]
	return ok
}

// ResetStandardType resets all changes to the "standard_type" field.
func (m *StandardHistoryMutation) ResetStandardType() {
	m.standard_type = nil
	delete(m.clearedFields, standardhistory.FieldStandardType)
}

// SetVersion sets the "version" field.
func (m *StandardHistoryMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *StandardHistoryMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *StandardHistoryMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[standardhistory.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *StandardHistoryMutation) VersionCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *StandardHistoryMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, standardhistory.FieldVersion)
}

// SetLogoFileID sets the "logo_file_id" field.
func (m *StandardHistoryMutation) SetLogoFileID(s string) {
	m.logo_file_id = &s
}

// LogoFileID returns the value of the "logo_file_id" field in the mutation.
func (m *StandardHistoryMutation) LogoFileID() (r string, exists bool) {
	v := m.logo_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoFileID returns the old "logo_file_id" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldLogoFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoFileID: %w", err)
	}
	return oldValue.LogoFileID, nil
}

// ClearLogoFileID clears the value of the "logo_file_id" field.
func (m *StandardHistoryMutation) ClearLogoFileID() {
	m.logo_file_id = nil
	m.clearedFields[standardhistory.FieldLogoFileID] = struct{}{}
}

// LogoFileIDCleared returns if the "logo_file_id" field was cleared in this mutation.
func (m *StandardHistoryMutation) LogoFileIDCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldLogoFileID]
	return ok
}

// ResetLogoFileID resets all changes to the "logo_file_id" field.
func (m *StandardHistoryMutation) ResetLogoFileID() {
	m.logo_file_id = nil
	delete(m.clearedFields, standardhistory.FieldLogoFileID)
}

// Where appends a list predicates to the StandardHistoryMutation builder.
func (m *StandardHistoryMutation) Where(ps ...predicate.StandardHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StandardHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StandardHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StandardHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StandardHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StandardHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StandardHistory).
func (m *StandardHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StandardHistoryMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.history_time != nil {
		fields = append(fields, standardhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, standardhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, standardhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, standardhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, standardhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, standardhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, standardhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, standardhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, standardhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, standardhistory.FieldTags)
	}
	if m.revision != nil {
		fields = append(fields, standardhistory.FieldRevision)
	}
	if m.owner_id != nil {
		fields = append(fields, standardhistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, standardhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, standardhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, standardhistory.FieldSystemInternalID)
	}
	if m.name != nil {
		fields = append(fields, standardhistory.FieldName)
	}
	if m.short_name != nil {
		fields = append(fields, standardhistory.FieldShortName)
	}
	if m.framework != nil {
		fields = append(fields, standardhistory.FieldFramework)
	}
	if m.description != nil {
		fields = append(fields, standardhistory.FieldDescription)
	}
	if m.governing_body_logo_url != nil {
		fields = append(fields, standardhistory.FieldGoverningBodyLogoURL)
	}
	if m.governing_body != nil {
		fields = append(fields, standardhistory.FieldGoverningBody)
	}
	if m.domains != nil {
		fields = append(fields, standardhistory.FieldDomains)
	}
	if m.link != nil {
		fields = append(fields, standardhistory.FieldLink)
	}
	if m.status != nil {
		fields = append(fields, standardhistory.FieldStatus)
	}
	if m.is_public != nil {
		fields = append(fields, standardhistory.FieldIsPublic)
	}
	if m.free_to_use != nil {
		fields = append(fields, standardhistory.FieldFreeToUse)
	}
	if m.standard_type != nil {
		fields = append(fields, standardhistory.FieldStandardType)
	}
	if m.version != nil {
		fields = append(fields, standardhistory.FieldVersion)
	}
	if m.logo_file_id != nil {
		fields = append(fields, standardhistory.FieldLogoFileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StandardHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case standardhistory.FieldHistoryTime:
		return m.HistoryTime()
	case standardhistory.FieldRef:
		return m.Ref()
	case standardhistory.FieldOperation:
		return m.Operation()
	case standardhistory.FieldCreatedAt:
		return m.CreatedAt()
	case standardhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case standardhistory.FieldCreatedBy:
		return m.CreatedBy()
	case standardhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case standardhistory.FieldDeletedAt:
		return m.DeletedAt()
	case standardhistory.FieldDeletedBy:
		return m.DeletedBy()
	case standardhistory.FieldTags:
		return m.Tags()
	case standardhistory.FieldRevision:
		return m.Revision()
	case standardhistory.FieldOwnerID:
		return m.OwnerID()
	case standardhistory.FieldSystemOwned:
		return m.SystemOwned()
	case standardhistory.FieldInternalNotes:
		return m.InternalNotes()
	case standardhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case standardhistory.FieldName:
		return m.Name()
	case standardhistory.FieldShortName:
		return m.ShortName()
	case standardhistory.FieldFramework:
		return m.Framework()
	case standardhistory.FieldDescription:
		return m.Description()
	case standardhistory.FieldGoverningBodyLogoURL:
		return m.GoverningBodyLogoURL()
	case standardhistory.FieldGoverningBody:
		return m.GoverningBody()
	case standardhistory.FieldDomains:
		return m.Domains()
	case standardhistory.FieldLink:
		return m.Link()
	case standardhistory.FieldStatus:
		return m.Status()
	case standardhistory.FieldIsPublic:
		return m.IsPublic()
	case standardhistory.FieldFreeToUse:
		return m.FreeToUse()
	case standardhistory.FieldStandardType:
		return m.StandardType()
	case standardhistory.FieldVersion:
		return m.Version()
	case standardhistory.FieldLogoFileID:
		return m.LogoFileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StandardHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case standardhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case standardhistory.FieldRef:
		return m.OldRef(ctx)
	case standardhistory.FieldOperation:
		return m.OldOperation(ctx)
	case standardhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case standardhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case standardhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case standardhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case standardhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case standardhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case standardhistory.FieldTags:
		return m.OldTags(ctx)
	case standardhistory.FieldRevision:
		return m.OldRevision(ctx)
	case standardhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case standardhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case standardhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case standardhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case standardhistory.FieldName:
		return m.OldName(ctx)
	case standardhistory.FieldShortName:
		return m.OldShortName(ctx)
	case standardhistory.FieldFramework:
		return m.OldFramework(ctx)
	case standardhistory.FieldDescription:
		return m.OldDescription(ctx)
	case standardhistory.FieldGoverningBodyLogoURL:
		return m.OldGoverningBodyLogoURL(ctx)
	case standardhistory.FieldGoverningBody:
		return m.OldGoverningBody(ctx)
	case standardhistory.FieldDomains:
		return m.OldDomains(ctx)
	case standardhistory.FieldLink:
		return m.OldLink(ctx)
	case standardhistory.FieldStatus:
		return m.OldStatus(ctx)
	case standardhistory.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case standardhistory.FieldFreeToUse:
		return m.OldFreeToUse(ctx)
	case standardhistory.FieldStandardType:
		return m.OldStandardType(ctx)
	case standardhistory.FieldVersion:
		return m.OldVersion(ctx)
	case standardhistory.FieldLogoFileID:
		return m.OldLogoFileID(ctx)
	}
	return nil, fmt.Errorf("unknown StandardHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandardHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case standardhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case standardhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case standardhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case standardhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case standardhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case standardhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case standardhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case standardhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case standardhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case standardhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case standardhistory.FieldRevision:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case standardhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case standardhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case standardhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case standardhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case standardhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case standardhistory.FieldShortName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortName(v)
		return nil
	case standardhistory.FieldFramework:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFramework(v)
		return nil
	case standardhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case standardhistory.FieldGoverningBodyLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoverningBodyLogoURL(v)
		return nil
	case standardhistory.FieldGoverningBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoverningBody(v)
		return nil
	case standardhistory.FieldDomains:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomains(v)
		return nil
	case standardhistory.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case standardhistory.FieldStatus:
		v, ok := value.(enums.StandardStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case standardhistory.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case standardhistory.FieldFreeToUse:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeToUse(v)
		return nil
	case standardhistory.FieldStandardType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStandardType(v)
		return nil
	case standardhistory.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case standardhistory.FieldLogoFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoFileID(v)
		return nil
	}
	return fmt.Errorf("unknown StandardHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StandardHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StandardHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandardHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StandardHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StandardHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(standardhistory.FieldRef) {
		fields = append(fields, standardhistory.FieldRef)
	}
	if m.FieldCleared(standardhistory.FieldCreatedAt) {
		fields = append(fields, standardhistory.FieldCreatedAt)
	}
	if m.FieldCleared(standardhistory.FieldUpdatedAt) {
		fields = append(fields, standardhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(standardhistory.FieldCreatedBy) {
		fields = append(fields, standardhistory.FieldCreatedBy)
	}
	if m.FieldCleared(standardhistory.FieldUpdatedBy) {
		fields = append(fields, standardhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(standardhistory.FieldDeletedAt) {
		fields = append(fields, standardhistory.FieldDeletedAt)
	}
	if m.FieldCleared(standardhistory.FieldDeletedBy) {
		fields = append(fields, standardhistory.FieldDeletedBy)
	}
	if m.FieldCleared(standardhistory.FieldTags) {
		fields = append(fields, standardhistory.FieldTags)
	}
	if m.FieldCleared(standardhistory.FieldRevision) {
		fields = append(fields, standardhistory.FieldRevision)
	}
	if m.FieldCleared(standardhistory.FieldOwnerID) {
		fields = append(fields, standardhistory.FieldOwnerID)
	}
	if m.FieldCleared(standardhistory.FieldSystemOwned) {
		fields = append(fields, standardhistory.FieldSystemOwned)
	}
	if m.FieldCleared(standardhistory.FieldInternalNotes) {
		fields = append(fields, standardhistory.FieldInternalNotes)
	}
	if m.FieldCleared(standardhistory.FieldSystemInternalID) {
		fields = append(fields, standardhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(standardhistory.FieldShortName) {
		fields = append(fields, standardhistory.FieldShortName)
	}
	if m.FieldCleared(standardhistory.FieldFramework) {
		fields = append(fields, standardhistory.FieldFramework)
	}
	if m.FieldCleared(standardhistory.FieldDescription) {
		fields = append(fields, standardhistory.FieldDescription)
	}
	if m.FieldCleared(standardhistory.FieldGoverningBodyLogoURL) {
		fields = append(fields, standardhistory.FieldGoverningBodyLogoURL)
	}
	if m.FieldCleared(standardhistory.FieldGoverningBody) {
		fields = append(fields, standardhistory.FieldGoverningBody)
	}
	if m.FieldCleared(standardhistory.FieldDomains) {
		fields = append(fields, standardhistory.FieldDomains)
	}
	if m.FieldCleared(standardhistory.FieldLink) {
		fields = append(fields, standardhistory.FieldLink)
	}
	if m.FieldCleared(standardhistory.FieldStatus) {
		fields = append(fields, standardhistory.FieldStatus)
	}
	if m.FieldCleared(standardhistory.FieldIsPublic) {
		fields = append(fields, standardhistory.FieldIsPublic)
	}
	if m.FieldCleared(standardhistory.FieldFreeToUse) {
		fields = append(fields, standardhistory.FieldFreeToUse)
	}
	if m.FieldCleared(standardhistory.FieldStandardType) {
		fields = append(fields, standardhistory.FieldStandardType)
	}
	if m.FieldCleared(standardhistory.FieldVersion) {
		fields = append(fields, standardhistory.FieldVersion)
	}
	if m.FieldCleared(standardhistory.FieldLogoFileID) {
		fields = append(fields, standardhistory.FieldLogoFileID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StandardHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StandardHistoryMutation) ClearField(name string) error {
	switch name {
	case standardhistory.FieldRef:
		m.ClearRef()
		return nil
	case standardhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case standardhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case standardhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case standardhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case standardhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case standardhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case standardhistory.FieldTags:
		m.ClearTags()
		return nil
	case standardhistory.FieldRevision:
		m.ClearRevision()
		return nil
	case standardhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case standardhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case standardhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case standardhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case standardhistory.FieldShortName:
		m.ClearShortName()
		return nil
	case standardhistory.FieldFramework:
		m.ClearFramework()
		return nil
	case standardhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case standardhistory.FieldGoverningBodyLogoURL:
		m.ClearGoverningBodyLogoURL()
		return nil
	case standardhistory.FieldGoverningBody:
		m.ClearGoverningBody()
		return nil
	case standardhistory.FieldDomains:
		m.ClearDomains()
		return nil
	case standardhistory.FieldLink:
		m.ClearLink()
		return nil
	case standardhistory.FieldStatus:
		m.ClearStatus()
		return nil
	case standardhistory.FieldIsPublic:
		m.ClearIsPublic()
		return nil
	case standardhistory.FieldFreeToUse:
		m.ClearFreeToUse()
		return nil
	case standardhistory.FieldStandardType:
		m.ClearStandardType()
		return nil
	case standardhistory.FieldVersion:
		m.ClearVersion()
		return nil
	case standardhistory.FieldLogoFileID:
		m.ClearLogoFileID()
		return nil
	}
	return fmt.Errorf("unknown StandardHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StandardHistoryMutation) ResetField(name string) error {
	switch name {
	case standardhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case standardhistory.FieldRef:
		m.ResetRef()
		return nil
	case standardhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case standardhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case standardhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case standardhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case standardhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case standardhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case standardhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case standardhistory.FieldTags:
		m.ResetTags()
		return nil
	case standardhistory.FieldRevision:
		m.ResetRevision()
		return nil
	case standardhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case standardhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case standardhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case standardhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case standardhistory.FieldName:
		m.ResetName()
		return nil
	case standardhistory.FieldShortName:
		m.ResetShortName()
		return nil
	case standardhistory.FieldFramework:
		m.ResetFramework()
		return nil
	case standardhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case standardhistory.FieldGoverningBodyLogoURL:
		m.ResetGoverningBodyLogoURL()
		return nil
	case standardhistory.FieldGoverningBody:
		m.ResetGoverningBody()
		return nil
	case standardhistory.FieldDomains:
		m.ResetDomains()
		return nil
	case standardhistory.FieldLink:
		m.ResetLink()
		return nil
	case standardhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case standardhistory.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case standardhistory.FieldFreeToUse:
		m.ResetFreeToUse()
		return nil
	case standardhistory.FieldStandardType:
		m.ResetStandardType()
		return nil
	case standardhistory.FieldVersion:
		m.ResetVersion()
		return nil
	case standardhistory.FieldLogoFileID:
		m.ResetLogoFileID()
		return nil
	}
	return fmt.Errorf("unknown StandardHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StandardHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StandardHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StandardHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StandardHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StandardHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StandardHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StandardHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StandardHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StandardHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StandardHistory edge %s", name)
}

// SubcontrolHistoryMutation represents an operation that mutates the SubcontrolHistory nodes in the graph.
type SubcontrolHistoryMutation struct {
	config
	op                            Op
	typ                           string
	id                            *string
	history_time                  *time.Time
	ref                           *string
	operation                     *history.OpType
	created_at                    *time.Time
	updated_at                    *time.Time
	created_by                    *string
	updated_by                    *string
	deleted_at                    *time.Time
	deleted_by                    *string
	display_id                    *string
	tags                          *[]string
	appendtags                    []string
	title                         *string
	description                   *string
	aliases                       *[]string
	appendaliases                 []string
	reference_id                  *string
	auditor_reference_id          *string
	responsible_party_id          *string
	status                        *enums.ControlStatus
	source                        *enums.ControlSource
	reference_framework           *string
	reference_framework_revision  *string
	control_type                  *enums.ControlType
	category                      *string
	category_id                   *string
	subcategory                   *string
	mapped_categories             *[]string
	appendmapped_categories       []string
	assessment_objectives         *[]models.AssessmentObjective
	appendassessment_objectives   []models.AssessmentObjective
	assessment_methods            *[]models.AssessmentMethod
	appendassessment_methods      []models.AssessmentMethod
	control_questions             *[]string
	appendcontrol_questions       []string
	implementation_guidance       *[]models.ImplementationGuidance
	appendimplementation_guidance []models.ImplementationGuidance
	example_evidence              *[]models.ExampleEvidence
	appendexample_evidence        []models.ExampleEvidence
	references                    *[]models.Reference
	appendreferences              []models.Reference
	control_owner_id              *string
	delegate_id                   *string
	owner_id                      *string
	system_owned                  *bool
	internal_notes                *string
	system_internal_id            *string
	subcontrol_kind_name          *string
	subcontrol_kind_id            *string
	ref_code                      *string
	control_id                    *string
	clearedFields                 map[string]struct{}
	done                          bool
	oldValue                      func(context.Context) (*SubcontrolHistory, error)
	predicates                    []predicate.SubcontrolHistory
}

var _ ent.Mutation = (*SubcontrolHistoryMutation)(nil)

// subcontrolhistoryOption allows management of the mutation configuration using functional options.
type subcontrolhistoryOption func(*SubcontrolHistoryMutation)

// newSubcontrolHistoryMutation creates new mutation for the SubcontrolHistory entity.
func newSubcontrolHistoryMutation(c config, op Op, opts ...subcontrolhistoryOption) *SubcontrolHistoryMutation {
	m := &SubcontrolHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeSubcontrolHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubcontrolHistoryID sets the ID field of the mutation.
func withSubcontrolHistoryID(id string) subcontrolhistoryOption {
	return func(m *SubcontrolHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *SubcontrolHistory
		)
		m.oldValue = func(ctx context.Context) (*SubcontrolHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubcontrolHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubcontrolHistory sets the old SubcontrolHistory of the mutation.
func withSubcontrolHistory(node *SubcontrolHistory) subcontrolhistoryOption {
	return func(m *SubcontrolHistoryMutation) {
		m.oldValue = func(context.Context) (*SubcontrolHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubcontrolHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubcontrolHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubcontrolHistory entities.
func (m *SubcontrolHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubcontrolHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubcontrolHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubcontrolHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *SubcontrolHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *SubcontrolHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *SubcontrolHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *SubcontrolHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *SubcontrolHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *SubcontrolHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[subcontrolhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *SubcontrolHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, subcontrolhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *SubcontrolHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *SubcontrolHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *SubcontrolHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SubcontrolHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubcontrolHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SubcontrolHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[subcontrolhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubcontrolHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, subcontrolhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubcontrolHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubcontrolHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SubcontrolHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[subcontrolhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubcontrolHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, subcontrolhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *SubcontrolHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SubcontrolHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *SubcontrolHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[subcontrolhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SubcontrolHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, subcontrolhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SubcontrolHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SubcontrolHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *SubcontrolHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[subcontrolhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SubcontrolHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, subcontrolhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubcontrolHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubcontrolHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubcontrolHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subcontrolhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubcontrolHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subcontrolhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *SubcontrolHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *SubcontrolHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *SubcontrolHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[subcontrolhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *SubcontrolHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, subcontrolhistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *SubcontrolHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *SubcontrolHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *SubcontrolHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *SubcontrolHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *SubcontrolHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *SubcontrolHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *SubcontrolHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *SubcontrolHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[subcontrolhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *SubcontrolHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, subcontrolhistory.FieldTags)
}

// SetTitle sets the "title" field.
func (m *SubcontrolHistoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SubcontrolHistoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *SubcontrolHistoryMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[subcontrolhistory.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) TitleCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *SubcontrolHistoryMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, subcontrolhistory.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *SubcontrolHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SubcontrolHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SubcontrolHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[subcontrolhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SubcontrolHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, subcontrolhistory.FieldDescription)
}

// SetAliases sets the "aliases" field.
func (m *SubcontrolHistoryMutation) SetAliases(s []string) {
	m.aliases = &s
	m.appendaliases = nil
}

// Aliases returns the value of the "aliases" field in the mutation.
func (m *SubcontrolHistoryMutation) Aliases() (r []string, exists bool) {
	v := m.aliases
	if v == nil {
		return
	}
	return *v, true
}

// OldAliases returns the old "aliases" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldAliases(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAliases is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAliases requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAliases: %w", err)
	}
	return oldValue.Aliases, nil
}

// AppendAliases adds s to the "aliases" field.
func (m *SubcontrolHistoryMutation) AppendAliases(s []string) {
	m.appendaliases = append(m.appendaliases, s...)
}

// AppendedAliases returns the list of values that were appended to the "aliases" field in this mutation.
func (m *SubcontrolHistoryMutation) AppendedAliases() ([]string, bool) {
	if len(m.appendaliases) == 0 {
		return nil, false
	}
	return m.appendaliases, true
}

// ClearAliases clears the value of the "aliases" field.
func (m *SubcontrolHistoryMutation) ClearAliases() {
	m.aliases = nil
	m.appendaliases = nil
	m.clearedFields[subcontrolhistory.FieldAliases] = struct{}{}
}

// AliasesCleared returns if the "aliases" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) AliasesCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldAliases]
	return ok
}

// ResetAliases resets all changes to the "aliases" field.
func (m *SubcontrolHistoryMutation) ResetAliases() {
	m.aliases = nil
	m.appendaliases = nil
	delete(m.clearedFields, subcontrolhistory.FieldAliases)
}

// SetReferenceID sets the "reference_id" field.
func (m *SubcontrolHistoryMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *SubcontrolHistoryMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ClearReferenceID clears the value of the "reference_id" field.
func (m *SubcontrolHistoryMutation) ClearReferenceID() {
	m.reference_id = nil
	m.clearedFields[subcontrolhistory.FieldReferenceID] = struct{}{}
}

// ReferenceIDCleared returns if the "reference_id" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ReferenceIDCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldReferenceID]
	return ok
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *SubcontrolHistoryMutation) ResetReferenceID() {
	m.reference_id = nil
	delete(m.clearedFields, subcontrolhistory.FieldReferenceID)
}

// SetAuditorReferenceID sets the "auditor_reference_id" field.
func (m *SubcontrolHistoryMutation) SetAuditorReferenceID(s string) {
	m.auditor_reference_id = &s
}

// AuditorReferenceID returns the value of the "auditor_reference_id" field in the mutation.
func (m *SubcontrolHistoryMutation) AuditorReferenceID() (r string, exists bool) {
	v := m.auditor_reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditorReferenceID returns the old "auditor_reference_id" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldAuditorReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditorReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditorReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditorReferenceID: %w", err)
	}
	return oldValue.AuditorReferenceID, nil
}

// ClearAuditorReferenceID clears the value of the "auditor_reference_id" field.
func (m *SubcontrolHistoryMutation) ClearAuditorReferenceID() {
	m.auditor_reference_id = nil
	m.clearedFields[subcontrolhistory.FieldAuditorReferenceID] = struct{}{}
}

// AuditorReferenceIDCleared returns if the "auditor_reference_id" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) AuditorReferenceIDCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldAuditorReferenceID]
	return ok
}

// ResetAuditorReferenceID resets all changes to the "auditor_reference_id" field.
func (m *SubcontrolHistoryMutation) ResetAuditorReferenceID() {
	m.auditor_reference_id = nil
	delete(m.clearedFields, subcontrolhistory.FieldAuditorReferenceID)
}

// SetResponsiblePartyID sets the "responsible_party_id" field.
func (m *SubcontrolHistoryMutation) SetResponsiblePartyID(s string) {
	m.responsible_party_id = &s
}

// ResponsiblePartyID returns the value of the "responsible_party_id" field in the mutation.
func (m *SubcontrolHistoryMutation) ResponsiblePartyID() (r string, exists bool) {
	v := m.responsible_party_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResponsiblePartyID returns the old "responsible_party_id" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldResponsiblePartyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponsiblePartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponsiblePartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponsiblePartyID: %w", err)
	}
	return oldValue.ResponsiblePartyID, nil
}

// ClearResponsiblePartyID clears the value of the "responsible_party_id" field.
func (m *SubcontrolHistoryMutation) ClearResponsiblePartyID() {
	m.responsible_party_id = nil
	m.clearedFields[subcontrolhistory.FieldResponsiblePartyID] = struct{}{}
}

// ResponsiblePartyIDCleared returns if the "responsible_party_id" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ResponsiblePartyIDCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldResponsiblePartyID]
	return ok
}

// ResetResponsiblePartyID resets all changes to the "responsible_party_id" field.
func (m *SubcontrolHistoryMutation) ResetResponsiblePartyID() {
	m.responsible_party_id = nil
	delete(m.clearedFields, subcontrolhistory.FieldResponsiblePartyID)
}

// SetStatus sets the "status" field.
func (m *SubcontrolHistoryMutation) SetStatus(es enums.ControlStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *SubcontrolHistoryMutation) Status() (r enums.ControlStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldStatus(ctx context.Context) (v enums.ControlStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *SubcontrolHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[subcontrolhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *SubcontrolHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, subcontrolhistory.FieldStatus)
}

// SetSource sets the "source" field.
func (m *SubcontrolHistoryMutation) SetSource(es enums.ControlSource) {
	m.source = &es
}

// Source returns the value of the "source" field in the mutation.
func (m *SubcontrolHistoryMutation) Source() (r enums.ControlSource, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldSource(ctx context.Context) (v enums.ControlSource, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *SubcontrolHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[subcontrolhistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *SubcontrolHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, subcontrolhistory.FieldSource)
}

// SetReferenceFramework sets the "reference_framework" field.
func (m *SubcontrolHistoryMutation) SetReferenceFramework(s string) {
	m.reference_framework = &s
}

// ReferenceFramework returns the value of the "reference_framework" field in the mutation.
func (m *SubcontrolHistoryMutation) ReferenceFramework() (r string, exists bool) {
	v := m.reference_framework
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceFramework returns the old "reference_framework" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldReferenceFramework(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceFramework is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceFramework requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceFramework: %w", err)
	}
	return oldValue.ReferenceFramework, nil
}

// ClearReferenceFramework clears the value of the "reference_framework" field.
func (m *SubcontrolHistoryMutation) ClearReferenceFramework() {
	m.reference_framework = nil
	m.clearedFields[subcontrolhistory.FieldReferenceFramework] = struct{}{}
}

// ReferenceFrameworkCleared returns if the "reference_framework" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ReferenceFrameworkCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldReferenceFramework]
	return ok
}

// ResetReferenceFramework resets all changes to the "reference_framework" field.
func (m *SubcontrolHistoryMutation) ResetReferenceFramework() {
	m.reference_framework = nil
	delete(m.clearedFields, subcontrolhistory.FieldReferenceFramework)
}

// SetReferenceFrameworkRevision sets the "reference_framework_revision" field.
func (m *SubcontrolHistoryMutation) SetReferenceFrameworkRevision(s string) {
	m.reference_framework_revision = &s
}

// ReferenceFrameworkRevision returns the value of the "reference_framework_revision" field in the mutation.
func (m *SubcontrolHistoryMutation) ReferenceFrameworkRevision() (r string, exists bool) {
	v := m.reference_framework_revision
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceFrameworkRevision returns the old "reference_framework_revision" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldReferenceFrameworkRevision(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceFrameworkRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceFrameworkRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceFrameworkRevision: %w", err)
	}
	return oldValue.ReferenceFrameworkRevision, nil
}

// ClearReferenceFrameworkRevision clears the value of the "reference_framework_revision" field.
func (m *SubcontrolHistoryMutation) ClearReferenceFrameworkRevision() {
	m.reference_framework_revision = nil
	m.clearedFields[subcontrolhistory.FieldReferenceFrameworkRevision] = struct{}{}
}

// ReferenceFrameworkRevisionCleared returns if the "reference_framework_revision" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ReferenceFrameworkRevisionCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldReferenceFrameworkRevision]
	return ok
}

// ResetReferenceFrameworkRevision resets all changes to the "reference_framework_revision" field.
func (m *SubcontrolHistoryMutation) ResetReferenceFrameworkRevision() {
	m.reference_framework_revision = nil
	delete(m.clearedFields, subcontrolhistory.FieldReferenceFrameworkRevision)
}

// SetControlType sets the "control_type" field.
func (m *SubcontrolHistoryMutation) SetControlType(et enums.ControlType) {
	m.control_type = &et
}

// ControlType returns the value of the "control_type" field in the mutation.
func (m *SubcontrolHistoryMutation) ControlType() (r enums.ControlType, exists bool) {
	v := m.control_type
	if v == nil {
		return
	}
	return *v, true
}

// OldControlType returns the old "control_type" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldControlType(ctx context.Context) (v enums.ControlType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlType: %w", err)
	}
	return oldValue.ControlType, nil
}

// ClearControlType clears the value of the "control_type" field.
func (m *SubcontrolHistoryMutation) ClearControlType() {
	m.control_type = nil
	m.clearedFields[subcontrolhistory.FieldControlType] = struct{}{}
}

// ControlTypeCleared returns if the "control_type" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ControlTypeCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldControlType]
	return ok
}

// ResetControlType resets all changes to the "control_type" field.
func (m *SubcontrolHistoryMutation) ResetControlType() {
	m.control_type = nil
	delete(m.clearedFields, subcontrolhistory.FieldControlType)
}

// SetCategory sets the "category" field.
func (m *SubcontrolHistoryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *SubcontrolHistoryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *SubcontrolHistoryMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[subcontrolhistory.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *SubcontrolHistoryMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, subcontrolhistory.FieldCategory)
}

// SetCategoryID sets the "category_id" field.
func (m *SubcontrolHistoryMutation) SetCategoryID(s string) {
	m.category_id = &s
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *SubcontrolHistoryMutation) CategoryID() (r string, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldCategoryID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *SubcontrolHistoryMutation) ClearCategoryID() {
	m.category_id = nil
	m.clearedFields[subcontrolhistory.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *SubcontrolHistoryMutation) ResetCategoryID() {
	m.category_id = nil
	delete(m.clearedFields, subcontrolhistory.FieldCategoryID)
}

// SetSubcategory sets the "subcategory" field.
func (m *SubcontrolHistoryMutation) SetSubcategory(s string) {
	m.subcategory = &s
}

// Subcategory returns the value of the "subcategory" field in the mutation.
func (m *SubcontrolHistoryMutation) Subcategory() (r string, exists bool) {
	v := m.subcategory
	if v == nil {
		return
	}
	return *v, true
}

// OldSubcategory returns the old "subcategory" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldSubcategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubcategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubcategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubcategory: %w", err)
	}
	return oldValue.Subcategory, nil
}

// ClearSubcategory clears the value of the "subcategory" field.
func (m *SubcontrolHistoryMutation) ClearSubcategory() {
	m.subcategory = nil
	m.clearedFields[subcontrolhistory.FieldSubcategory] = struct{}{}
}

// SubcategoryCleared returns if the "subcategory" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) SubcategoryCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldSubcategory]
	return ok
}

// ResetSubcategory resets all changes to the "subcategory" field.
func (m *SubcontrolHistoryMutation) ResetSubcategory() {
	m.subcategory = nil
	delete(m.clearedFields, subcontrolhistory.FieldSubcategory)
}

// SetMappedCategories sets the "mapped_categories" field.
func (m *SubcontrolHistoryMutation) SetMappedCategories(s []string) {
	m.mapped_categories = &s
	m.appendmapped_categories = nil
}

// MappedCategories returns the value of the "mapped_categories" field in the mutation.
func (m *SubcontrolHistoryMutation) MappedCategories() (r []string, exists bool) {
	v := m.mapped_categories
	if v == nil {
		return
	}
	return *v, true
}

// OldMappedCategories returns the old "mapped_categories" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldMappedCategories(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappedCategories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappedCategories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappedCategories: %w", err)
	}
	return oldValue.MappedCategories, nil
}

// AppendMappedCategories adds s to the "mapped_categories" field.
func (m *SubcontrolHistoryMutation) AppendMappedCategories(s []string) {
	m.appendmapped_categories = append(m.appendmapped_categories, s...)
}

// AppendedMappedCategories returns the list of values that were appended to the "mapped_categories" field in this mutation.
func (m *SubcontrolHistoryMutation) AppendedMappedCategories() ([]string, bool) {
	if len(m.appendmapped_categories) == 0 {
		return nil, false
	}
	return m.appendmapped_categories, true
}

// ClearMappedCategories clears the value of the "mapped_categories" field.
func (m *SubcontrolHistoryMutation) ClearMappedCategories() {
	m.mapped_categories = nil
	m.appendmapped_categories = nil
	m.clearedFields[subcontrolhistory.FieldMappedCategories] = struct{}{}
}

// MappedCategoriesCleared returns if the "mapped_categories" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) MappedCategoriesCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldMappedCategories]
	return ok
}

// ResetMappedCategories resets all changes to the "mapped_categories" field.
func (m *SubcontrolHistoryMutation) ResetMappedCategories() {
	m.mapped_categories = nil
	m.appendmapped_categories = nil
	delete(m.clearedFields, subcontrolhistory.FieldMappedCategories)
}

// SetAssessmentObjectives sets the "assessment_objectives" field.
func (m *SubcontrolHistoryMutation) SetAssessmentObjectives(mo []models.AssessmentObjective) {
	m.assessment_objectives = &mo
	m.appendassessment_objectives = nil
}

// AssessmentObjectives returns the value of the "assessment_objectives" field in the mutation.
func (m *SubcontrolHistoryMutation) AssessmentObjectives() (r []models.AssessmentObjective, exists bool) {
	v := m.assessment_objectives
	if v == nil {
		return
	}
	return *v, true
}

// OldAssessmentObjectives returns the old "assessment_objectives" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldAssessmentObjectives(ctx context.Context) (v []models.AssessmentObjective, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssessmentObjectives is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssessmentObjectives requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssessmentObjectives: %w", err)
	}
	return oldValue.AssessmentObjectives, nil
}

// AppendAssessmentObjectives adds mo to the "assessment_objectives" field.
func (m *SubcontrolHistoryMutation) AppendAssessmentObjectives(mo []models.AssessmentObjective) {
	m.appendassessment_objectives = append(m.appendassessment_objectives, mo...)
}

// AppendedAssessmentObjectives returns the list of values that were appended to the "assessment_objectives" field in this mutation.
func (m *SubcontrolHistoryMutation) AppendedAssessmentObjectives() ([]models.AssessmentObjective, bool) {
	if len(m.appendassessment_objectives) == 0 {
		return nil, false
	}
	return m.appendassessment_objectives, true
}

// ClearAssessmentObjectives clears the value of the "assessment_objectives" field.
func (m *SubcontrolHistoryMutation) ClearAssessmentObjectives() {
	m.assessment_objectives = nil
	m.appendassessment_objectives = nil
	m.clearedFields[subcontrolhistory.FieldAssessmentObjectives] = struct{}{}
}

// AssessmentObjectivesCleared returns if the "assessment_objectives" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) AssessmentObjectivesCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldAssessmentObjectives]
	return ok
}

// ResetAssessmentObjectives resets all changes to the "assessment_objectives" field.
func (m *SubcontrolHistoryMutation) ResetAssessmentObjectives() {
	m.assessment_objectives = nil
	m.appendassessment_objectives = nil
	delete(m.clearedFields, subcontrolhistory.FieldAssessmentObjectives)
}

// SetAssessmentMethods sets the "assessment_methods" field.
func (m *SubcontrolHistoryMutation) SetAssessmentMethods(mm []models.AssessmentMethod) {
	m.assessment_methods = &mm
	m.appendassessment_methods = nil
}

// AssessmentMethods returns the value of the "assessment_methods" field in the mutation.
func (m *SubcontrolHistoryMutation) AssessmentMethods() (r []models.AssessmentMethod, exists bool) {
	v := m.assessment_methods
	if v == nil {
		return
	}
	return *v, true
}

// OldAssessmentMethods returns the old "assessment_methods" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldAssessmentMethods(ctx context.Context) (v []models.AssessmentMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssessmentMethods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssessmentMethods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssessmentMethods: %w", err)
	}
	return oldValue.AssessmentMethods, nil
}

// AppendAssessmentMethods adds mm to the "assessment_methods" field.
func (m *SubcontrolHistoryMutation) AppendAssessmentMethods(mm []models.AssessmentMethod) {
	m.appendassessment_methods = append(m.appendassessment_methods, mm...)
}

// AppendedAssessmentMethods returns the list of values that were appended to the "assessment_methods" field in this mutation.
func (m *SubcontrolHistoryMutation) AppendedAssessmentMethods() ([]models.AssessmentMethod, bool) {
	if len(m.appendassessment_methods) == 0 {
		return nil, false
	}
	return m.appendassessment_methods, true
}

// ClearAssessmentMethods clears the value of the "assessment_methods" field.
func (m *SubcontrolHistoryMutation) ClearAssessmentMethods() {
	m.assessment_methods = nil
	m.appendassessment_methods = nil
	m.clearedFields[subcontrolhistory.FieldAssessmentMethods] = struct{}{}
}

// AssessmentMethodsCleared returns if the "assessment_methods" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) AssessmentMethodsCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldAssessmentMethods]
	return ok
}

// ResetAssessmentMethods resets all changes to the "assessment_methods" field.
func (m *SubcontrolHistoryMutation) ResetAssessmentMethods() {
	m.assessment_methods = nil
	m.appendassessment_methods = nil
	delete(m.clearedFields, subcontrolhistory.FieldAssessmentMethods)
}

// SetControlQuestions sets the "control_questions" field.
func (m *SubcontrolHistoryMutation) SetControlQuestions(s []string) {
	m.control_questions = &s
	m.appendcontrol_questions = nil
}

// ControlQuestions returns the value of the "control_questions" field in the mutation.
func (m *SubcontrolHistoryMutation) ControlQuestions() (r []string, exists bool) {
	v := m.control_questions
	if v == nil {
		return
	}
	return *v, true
}

// OldControlQuestions returns the old "control_questions" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldControlQuestions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlQuestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlQuestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlQuestions: %w", err)
	}
	return oldValue.ControlQuestions, nil
}

// AppendControlQuestions adds s to the "control_questions" field.
func (m *SubcontrolHistoryMutation) AppendControlQuestions(s []string) {
	m.appendcontrol_questions = append(m.appendcontrol_questions, s...)
}

// AppendedControlQuestions returns the list of values that were appended to the "control_questions" field in this mutation.
func (m *SubcontrolHistoryMutation) AppendedControlQuestions() ([]string, bool) {
	if len(m.appendcontrol_questions) == 0 {
		return nil, false
	}
	return m.appendcontrol_questions, true
}

// ClearControlQuestions clears the value of the "control_questions" field.
func (m *SubcontrolHistoryMutation) ClearControlQuestions() {
	m.control_questions = nil
	m.appendcontrol_questions = nil
	m.clearedFields[subcontrolhistory.FieldControlQuestions] = struct{}{}
}

// ControlQuestionsCleared returns if the "control_questions" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ControlQuestionsCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldControlQuestions]
	return ok
}

// ResetControlQuestions resets all changes to the "control_questions" field.
func (m *SubcontrolHistoryMutation) ResetControlQuestions() {
	m.control_questions = nil
	m.appendcontrol_questions = nil
	delete(m.clearedFields, subcontrolhistory.FieldControlQuestions)
}

// SetImplementationGuidance sets the "implementation_guidance" field.
func (m *SubcontrolHistoryMutation) SetImplementationGuidance(mg []models.ImplementationGuidance) {
	m.implementation_guidance = &mg
	m.appendimplementation_guidance = nil
}

// ImplementationGuidance returns the value of the "implementation_guidance" field in the mutation.
func (m *SubcontrolHistoryMutation) ImplementationGuidance() (r []models.ImplementationGuidance, exists bool) {
	v := m.implementation_guidance
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementationGuidance returns the old "implementation_guidance" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldImplementationGuidance(ctx context.Context) (v []models.ImplementationGuidance, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementationGuidance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementationGuidance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementationGuidance: %w", err)
	}
	return oldValue.ImplementationGuidance, nil
}

// AppendImplementationGuidance adds mg to the "implementation_guidance" field.
func (m *SubcontrolHistoryMutation) AppendImplementationGuidance(mg []models.ImplementationGuidance) {
	m.appendimplementation_guidance = append(m.appendimplementation_guidance, mg...)
}

// AppendedImplementationGuidance returns the list of values that were appended to the "implementation_guidance" field in this mutation.
func (m *SubcontrolHistoryMutation) AppendedImplementationGuidance() ([]models.ImplementationGuidance, bool) {
	if len(m.appendimplementation_guidance) == 0 {
		return nil, false
	}
	return m.appendimplementation_guidance, true
}

// ClearImplementationGuidance clears the value of the "implementation_guidance" field.
func (m *SubcontrolHistoryMutation) ClearImplementationGuidance() {
	m.implementation_guidance = nil
	m.appendimplementation_guidance = nil
	m.clearedFields[subcontrolhistory.FieldImplementationGuidance] = struct{}{}
}

// ImplementationGuidanceCleared returns if the "implementation_guidance" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ImplementationGuidanceCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldImplementationGuidance]
	return ok
}

// ResetImplementationGuidance resets all changes to the "implementation_guidance" field.
func (m *SubcontrolHistoryMutation) ResetImplementationGuidance() {
	m.implementation_guidance = nil
	m.appendimplementation_guidance = nil
	delete(m.clearedFields, subcontrolhistory.FieldImplementationGuidance)
}

// SetExampleEvidence sets the "example_evidence" field.
func (m *SubcontrolHistoryMutation) SetExampleEvidence(me []models.ExampleEvidence) {
	m.example_evidence = &me
	m.appendexample_evidence = nil
}

// ExampleEvidence returns the value of the "example_evidence" field in the mutation.
func (m *SubcontrolHistoryMutation) ExampleEvidence() (r []models.ExampleEvidence, exists bool) {
	v := m.example_evidence
	if v == nil {
		return
	}
	return *v, true
}

// OldExampleEvidence returns the old "example_evidence" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldExampleEvidence(ctx context.Context) (v []models.ExampleEvidence, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExampleEvidence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExampleEvidence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExampleEvidence: %w", err)
	}
	return oldValue.ExampleEvidence, nil
}

// AppendExampleEvidence adds me to the "example_evidence" field.
func (m *SubcontrolHistoryMutation) AppendExampleEvidence(me []models.ExampleEvidence) {
	m.appendexample_evidence = append(m.appendexample_evidence, me...)
}

// AppendedExampleEvidence returns the list of values that were appended to the "example_evidence" field in this mutation.
func (m *SubcontrolHistoryMutation) AppendedExampleEvidence() ([]models.ExampleEvidence, bool) {
	if len(m.appendexample_evidence) == 0 {
		return nil, false
	}
	return m.appendexample_evidence, true
}

// ClearExampleEvidence clears the value of the "example_evidence" field.
func (m *SubcontrolHistoryMutation) ClearExampleEvidence() {
	m.example_evidence = nil
	m.appendexample_evidence = nil
	m.clearedFields[subcontrolhistory.FieldExampleEvidence] = struct{}{}
}

// ExampleEvidenceCleared returns if the "example_evidence" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ExampleEvidenceCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldExampleEvidence]
	return ok
}

// ResetExampleEvidence resets all changes to the "example_evidence" field.
func (m *SubcontrolHistoryMutation) ResetExampleEvidence() {
	m.example_evidence = nil
	m.appendexample_evidence = nil
	delete(m.clearedFields, subcontrolhistory.FieldExampleEvidence)
}

// SetReferences sets the "references" field.
func (m *SubcontrolHistoryMutation) SetReferences(value []models.Reference) {
	m.references = &value
	m.appendreferences = nil
}

// References returns the value of the "references" field in the mutation.
func (m *SubcontrolHistoryMutation) References() (r []models.Reference, exists bool) {
	v := m.references
	if v == nil {
		return
	}
	return *v, true
}

// OldReferences returns the old "references" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldReferences(ctx context.Context) (v []models.Reference, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferences: %w", err)
	}
	return oldValue.References, nil
}

// AppendReferences adds value to the "references" field.
func (m *SubcontrolHistoryMutation) AppendReferences(value []models.Reference) {
	m.appendreferences = append(m.appendreferences, value...)
}

// AppendedReferences returns the list of values that were appended to the "references" field in this mutation.
func (m *SubcontrolHistoryMutation) AppendedReferences() ([]models.Reference, bool) {
	if len(m.appendreferences) == 0 {
		return nil, false
	}
	return m.appendreferences, true
}

// ClearReferences clears the value of the "references" field.
func (m *SubcontrolHistoryMutation) ClearReferences() {
	m.references = nil
	m.appendreferences = nil
	m.clearedFields[subcontrolhistory.FieldReferences] = struct{}{}
}

// ReferencesCleared returns if the "references" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ReferencesCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldReferences]
	return ok
}

// ResetReferences resets all changes to the "references" field.
func (m *SubcontrolHistoryMutation) ResetReferences() {
	m.references = nil
	m.appendreferences = nil
	delete(m.clearedFields, subcontrolhistory.FieldReferences)
}

// SetControlOwnerID sets the "control_owner_id" field.
func (m *SubcontrolHistoryMutation) SetControlOwnerID(s string) {
	m.control_owner_id = &s
}

// ControlOwnerID returns the value of the "control_owner_id" field in the mutation.
func (m *SubcontrolHistoryMutation) ControlOwnerID() (r string, exists bool) {
	v := m.control_owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldControlOwnerID returns the old "control_owner_id" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldControlOwnerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlOwnerID: %w", err)
	}
	return oldValue.ControlOwnerID, nil
}

// ClearControlOwnerID clears the value of the "control_owner_id" field.
func (m *SubcontrolHistoryMutation) ClearControlOwnerID() {
	m.control_owner_id = nil
	m.clearedFields[subcontrolhistory.FieldControlOwnerID] = struct{}{}
}

// ControlOwnerIDCleared returns if the "control_owner_id" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ControlOwnerIDCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldControlOwnerID]
	return ok
}

// ResetControlOwnerID resets all changes to the "control_owner_id" field.
func (m *SubcontrolHistoryMutation) ResetControlOwnerID() {
	m.control_owner_id = nil
	delete(m.clearedFields, subcontrolhistory.FieldControlOwnerID)
}

// SetDelegateID sets the "delegate_id" field.
func (m *SubcontrolHistoryMutation) SetDelegateID(s string) {
	m.delegate_id = &s
}

// DelegateID returns the value of the "delegate_id" field in the mutation.
func (m *SubcontrolHistoryMutation) DelegateID() (r string, exists bool) {
	v := m.delegate_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegateID returns the old "delegate_id" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldDelegateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelegateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelegateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegateID: %w", err)
	}
	return oldValue.DelegateID, nil
}

// ClearDelegateID clears the value of the "delegate_id" field.
func (m *SubcontrolHistoryMutation) ClearDelegateID() {
	m.delegate_id = nil
	m.clearedFields[subcontrolhistory.FieldDelegateID] = struct{}{}
}

// DelegateIDCleared returns if the "delegate_id" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) DelegateIDCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldDelegateID]
	return ok
}

// ResetDelegateID resets all changes to the "delegate_id" field.
func (m *SubcontrolHistoryMutation) ResetDelegateID() {
	m.delegate_id = nil
	delete(m.clearedFields, subcontrolhistory.FieldDelegateID)
}

// SetOwnerID sets the "owner_id" field.
func (m *SubcontrolHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *SubcontrolHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *SubcontrolHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[subcontrolhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *SubcontrolHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, subcontrolhistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *SubcontrolHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *SubcontrolHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *SubcontrolHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[subcontrolhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *SubcontrolHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, subcontrolhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *SubcontrolHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *SubcontrolHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *SubcontrolHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[subcontrolhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *SubcontrolHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, subcontrolhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *SubcontrolHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *SubcontrolHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *SubcontrolHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[subcontrolhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *SubcontrolHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, subcontrolhistory.FieldSystemInternalID)
}

// SetSubcontrolKindName sets the "subcontrol_kind_name" field.
func (m *SubcontrolHistoryMutation) SetSubcontrolKindName(s string) {
	m.subcontrol_kind_name = &s
}

// SubcontrolKindName returns the value of the "subcontrol_kind_name" field in the mutation.
func (m *SubcontrolHistoryMutation) SubcontrolKindName() (r string, exists bool) {
	v := m.subcontrol_kind_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSubcontrolKindName returns the old "subcontrol_kind_name" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldSubcontrolKindName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubcontrolKindName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubcontrolKindName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubcontrolKindName: %w", err)
	}
	return oldValue.SubcontrolKindName, nil
}

// ClearSubcontrolKindName clears the value of the "subcontrol_kind_name" field.
func (m *SubcontrolHistoryMutation) ClearSubcontrolKindName() {
	m.subcontrol_kind_name = nil
	m.clearedFields[subcontrolhistory.FieldSubcontrolKindName] = struct{}{}
}

// SubcontrolKindNameCleared returns if the "subcontrol_kind_name" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) SubcontrolKindNameCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldSubcontrolKindName]
	return ok
}

// ResetSubcontrolKindName resets all changes to the "subcontrol_kind_name" field.
func (m *SubcontrolHistoryMutation) ResetSubcontrolKindName() {
	m.subcontrol_kind_name = nil
	delete(m.clearedFields, subcontrolhistory.FieldSubcontrolKindName)
}

// SetSubcontrolKindID sets the "subcontrol_kind_id" field.
func (m *SubcontrolHistoryMutation) SetSubcontrolKindID(s string) {
	m.subcontrol_kind_id = &s
}

// SubcontrolKindID returns the value of the "subcontrol_kind_id" field in the mutation.
func (m *SubcontrolHistoryMutation) SubcontrolKindID() (r string, exists bool) {
	v := m.subcontrol_kind_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSubcontrolKindID returns the old "subcontrol_kind_id" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldSubcontrolKindID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubcontrolKindID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubcontrolKindID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubcontrolKindID: %w", err)
	}
	return oldValue.SubcontrolKindID, nil
}

// ClearSubcontrolKindID clears the value of the "subcontrol_kind_id" field.
func (m *SubcontrolHistoryMutation) ClearSubcontrolKindID() {
	m.subcontrol_kind_id = nil
	m.clearedFields[subcontrolhistory.FieldSubcontrolKindID] = struct{}{}
}

// SubcontrolKindIDCleared returns if the "subcontrol_kind_id" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) SubcontrolKindIDCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldSubcontrolKindID]
	return ok
}

// ResetSubcontrolKindID resets all changes to the "subcontrol_kind_id" field.
func (m *SubcontrolHistoryMutation) ResetSubcontrolKindID() {
	m.subcontrol_kind_id = nil
	delete(m.clearedFields, subcontrolhistory.FieldSubcontrolKindID)
}

// SetRefCode sets the "ref_code" field.
func (m *SubcontrolHistoryMutation) SetRefCode(s string) {
	m.ref_code = &s
}

// RefCode returns the value of the "ref_code" field in the mutation.
func (m *SubcontrolHistoryMutation) RefCode() (r string, exists bool) {
	v := m.ref_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRefCode returns the old "ref_code" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldRefCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefCode: %w", err)
	}
	return oldValue.RefCode, nil
}

// ResetRefCode resets all changes to the "ref_code" field.
func (m *SubcontrolHistoryMutation) ResetRefCode() {
	m.ref_code = nil
}

// SetControlID sets the "control_id" field.
func (m *SubcontrolHistoryMutation) SetControlID(s string) {
	m.control_id = &s
}

// ControlID returns the value of the "control_id" field in the mutation.
func (m *SubcontrolHistoryMutation) ControlID() (r string, exists bool) {
	v := m.control_id
	if v == nil {
		return
	}
	return *v, true
}

// OldControlID returns the old "control_id" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldControlID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlID: %w", err)
	}
	return oldValue.ControlID, nil
}

// ResetControlID resets all changes to the "control_id" field.
func (m *SubcontrolHistoryMutation) ResetControlID() {
	m.control_id = nil
}

// Where appends a list predicates to the SubcontrolHistoryMutation builder.
func (m *SubcontrolHistoryMutation) Where(ps ...predicate.SubcontrolHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubcontrolHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubcontrolHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubcontrolHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubcontrolHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubcontrolHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubcontrolHistory).
func (m *SubcontrolHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubcontrolHistoryMutation) Fields() []string {
	fields := make([]string, 0, 42)
	if m.history_time != nil {
		fields = append(fields, subcontrolhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, subcontrolhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, subcontrolhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, subcontrolhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subcontrolhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, subcontrolhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, subcontrolhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, subcontrolhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, subcontrolhistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, subcontrolhistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, subcontrolhistory.FieldTags)
	}
	if m.title != nil {
		fields = append(fields, subcontrolhistory.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, subcontrolhistory.FieldDescription)
	}
	if m.aliases != nil {
		fields = append(fields, subcontrolhistory.FieldAliases)
	}
	if m.reference_id != nil {
		fields = append(fields, subcontrolhistory.FieldReferenceID)
	}
	if m.auditor_reference_id != nil {
		fields = append(fields, subcontrolhistory.FieldAuditorReferenceID)
	}
	if m.responsible_party_id != nil {
		fields = append(fields, subcontrolhistory.FieldResponsiblePartyID)
	}
	if m.status != nil {
		fields = append(fields, subcontrolhistory.FieldStatus)
	}
	if m.source != nil {
		fields = append(fields, subcontrolhistory.FieldSource)
	}
	if m.reference_framework != nil {
		fields = append(fields, subcontrolhistory.FieldReferenceFramework)
	}
	if m.reference_framework_revision != nil {
		fields = append(fields, subcontrolhistory.FieldReferenceFrameworkRevision)
	}
	if m.control_type != nil {
		fields = append(fields, subcontrolhistory.FieldControlType)
	}
	if m.category != nil {
		fields = append(fields, subcontrolhistory.FieldCategory)
	}
	if m.category_id != nil {
		fields = append(fields, subcontrolhistory.FieldCategoryID)
	}
	if m.subcategory != nil {
		fields = append(fields, subcontrolhistory.FieldSubcategory)
	}
	if m.mapped_categories != nil {
		fields = append(fields, subcontrolhistory.FieldMappedCategories)
	}
	if m.assessment_objectives != nil {
		fields = append(fields, subcontrolhistory.FieldAssessmentObjectives)
	}
	if m.assessment_methods != nil {
		fields = append(fields, subcontrolhistory.FieldAssessmentMethods)
	}
	if m.control_questions != nil {
		fields = append(fields, subcontrolhistory.FieldControlQuestions)
	}
	if m.implementation_guidance != nil {
		fields = append(fields, subcontrolhistory.FieldImplementationGuidance)
	}
	if m.example_evidence != nil {
		fields = append(fields, subcontrolhistory.FieldExampleEvidence)
	}
	if m.references != nil {
		fields = append(fields, subcontrolhistory.FieldReferences)
	}
	if m.control_owner_id != nil {
		fields = append(fields, subcontrolhistory.FieldControlOwnerID)
	}
	if m.delegate_id != nil {
		fields = append(fields, subcontrolhistory.FieldDelegateID)
	}
	if m.owner_id != nil {
		fields = append(fields, subcontrolhistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, subcontrolhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, subcontrolhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, subcontrolhistory.FieldSystemInternalID)
	}
	if m.subcontrol_kind_name != nil {
		fields = append(fields, subcontrolhistory.FieldSubcontrolKindName)
	}
	if m.subcontrol_kind_id != nil {
		fields = append(fields, subcontrolhistory.FieldSubcontrolKindID)
	}
	if m.ref_code != nil {
		fields = append(fields, subcontrolhistory.FieldRefCode)
	}
	if m.control_id != nil {
		fields = append(fields, subcontrolhistory.FieldControlID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubcontrolHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subcontrolhistory.FieldHistoryTime:
		return m.HistoryTime()
	case subcontrolhistory.FieldRef:
		return m.Ref()
	case subcontrolhistory.FieldOperation:
		return m.Operation()
	case subcontrolhistory.FieldCreatedAt:
		return m.CreatedAt()
	case subcontrolhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case subcontrolhistory.FieldCreatedBy:
		return m.CreatedBy()
	case subcontrolhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case subcontrolhistory.FieldDeletedAt:
		return m.DeletedAt()
	case subcontrolhistory.FieldDeletedBy:
		return m.DeletedBy()
	case subcontrolhistory.FieldDisplayID:
		return m.DisplayID()
	case subcontrolhistory.FieldTags:
		return m.Tags()
	case subcontrolhistory.FieldTitle:
		return m.Title()
	case subcontrolhistory.FieldDescription:
		return m.Description()
	case subcontrolhistory.FieldAliases:
		return m.Aliases()
	case subcontrolhistory.FieldReferenceID:
		return m.ReferenceID()
	case subcontrolhistory.FieldAuditorReferenceID:
		return m.AuditorReferenceID()
	case subcontrolhistory.FieldResponsiblePartyID:
		return m.ResponsiblePartyID()
	case subcontrolhistory.FieldStatus:
		return m.Status()
	case subcontrolhistory.FieldSource:
		return m.Source()
	case subcontrolhistory.FieldReferenceFramework:
		return m.ReferenceFramework()
	case subcontrolhistory.FieldReferenceFrameworkRevision:
		return m.ReferenceFrameworkRevision()
	case subcontrolhistory.FieldControlType:
		return m.ControlType()
	case subcontrolhistory.FieldCategory:
		return m.Category()
	case subcontrolhistory.FieldCategoryID:
		return m.CategoryID()
	case subcontrolhistory.FieldSubcategory:
		return m.Subcategory()
	case subcontrolhistory.FieldMappedCategories:
		return m.MappedCategories()
	case subcontrolhistory.FieldAssessmentObjectives:
		return m.AssessmentObjectives()
	case subcontrolhistory.FieldAssessmentMethods:
		return m.AssessmentMethods()
	case subcontrolhistory.FieldControlQuestions:
		return m.ControlQuestions()
	case subcontrolhistory.FieldImplementationGuidance:
		return m.ImplementationGuidance()
	case subcontrolhistory.FieldExampleEvidence:
		return m.ExampleEvidence()
	case subcontrolhistory.FieldReferences:
		return m.References()
	case subcontrolhistory.FieldControlOwnerID:
		return m.ControlOwnerID()
	case subcontrolhistory.FieldDelegateID:
		return m.DelegateID()
	case subcontrolhistory.FieldOwnerID:
		return m.OwnerID()
	case subcontrolhistory.FieldSystemOwned:
		return m.SystemOwned()
	case subcontrolhistory.FieldInternalNotes:
		return m.InternalNotes()
	case subcontrolhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case subcontrolhistory.FieldSubcontrolKindName:
		return m.SubcontrolKindName()
	case subcontrolhistory.FieldSubcontrolKindID:
		return m.SubcontrolKindID()
	case subcontrolhistory.FieldRefCode:
		return m.RefCode()
	case subcontrolhistory.FieldControlID:
		return m.ControlID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubcontrolHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subcontrolhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case subcontrolhistory.FieldRef:
		return m.OldRef(ctx)
	case subcontrolhistory.FieldOperation:
		return m.OldOperation(ctx)
	case subcontrolhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subcontrolhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subcontrolhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case subcontrolhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case subcontrolhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subcontrolhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case subcontrolhistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case subcontrolhistory.FieldTags:
		return m.OldTags(ctx)
	case subcontrolhistory.FieldTitle:
		return m.OldTitle(ctx)
	case subcontrolhistory.FieldDescription:
		return m.OldDescription(ctx)
	case subcontrolhistory.FieldAliases:
		return m.OldAliases(ctx)
	case subcontrolhistory.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case subcontrolhistory.FieldAuditorReferenceID:
		return m.OldAuditorReferenceID(ctx)
	case subcontrolhistory.FieldResponsiblePartyID:
		return m.OldResponsiblePartyID(ctx)
	case subcontrolhistory.FieldStatus:
		return m.OldStatus(ctx)
	case subcontrolhistory.FieldSource:
		return m.OldSource(ctx)
	case subcontrolhistory.FieldReferenceFramework:
		return m.OldReferenceFramework(ctx)
	case subcontrolhistory.FieldReferenceFrameworkRevision:
		return m.OldReferenceFrameworkRevision(ctx)
	case subcontrolhistory.FieldControlType:
		return m.OldControlType(ctx)
	case subcontrolhistory.FieldCategory:
		return m.OldCategory(ctx)
	case subcontrolhistory.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case subcontrolhistory.FieldSubcategory:
		return m.OldSubcategory(ctx)
	case subcontrolhistory.FieldMappedCategories:
		return m.OldMappedCategories(ctx)
	case subcontrolhistory.FieldAssessmentObjectives:
		return m.OldAssessmentObjectives(ctx)
	case subcontrolhistory.FieldAssessmentMethods:
		return m.OldAssessmentMethods(ctx)
	case subcontrolhistory.FieldControlQuestions:
		return m.OldControlQuestions(ctx)
	case subcontrolhistory.FieldImplementationGuidance:
		return m.OldImplementationGuidance(ctx)
	case subcontrolhistory.FieldExampleEvidence:
		return m.OldExampleEvidence(ctx)
	case subcontrolhistory.FieldReferences:
		return m.OldReferences(ctx)
	case subcontrolhistory.FieldControlOwnerID:
		return m.OldControlOwnerID(ctx)
	case subcontrolhistory.FieldDelegateID:
		return m.OldDelegateID(ctx)
	case subcontrolhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case subcontrolhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case subcontrolhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case subcontrolhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case subcontrolhistory.FieldSubcontrolKindName:
		return m.OldSubcontrolKindName(ctx)
	case subcontrolhistory.FieldSubcontrolKindID:
		return m.OldSubcontrolKindID(ctx)
	case subcontrolhistory.FieldRefCode:
		return m.OldRefCode(ctx)
	case subcontrolhistory.FieldControlID:
		return m.OldControlID(ctx)
	}
	return nil, fmt.Errorf("unknown SubcontrolHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubcontrolHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subcontrolhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case subcontrolhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case subcontrolhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case subcontrolhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subcontrolhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subcontrolhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case subcontrolhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case subcontrolhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subcontrolhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case subcontrolhistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case subcontrolhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case subcontrolhistory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case subcontrolhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case subcontrolhistory.FieldAliases:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAliases(v)
		return nil
	case subcontrolhistory.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case subcontrolhistory.FieldAuditorReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditorReferenceID(v)
		return nil
	case subcontrolhistory.FieldResponsiblePartyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponsiblePartyID(v)
		return nil
	case subcontrolhistory.FieldStatus:
		v, ok := value.(enums.ControlStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case subcontrolhistory.FieldSource:
		v, ok := value.(enums.ControlSource)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case subcontrolhistory.FieldReferenceFramework:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceFramework(v)
		return nil
	case subcontrolhistory.FieldReferenceFrameworkRevision:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceFrameworkRevision(v)
		return nil
	case subcontrolhistory.FieldControlType:
		v, ok := value.(enums.ControlType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlType(v)
		return nil
	case subcontrolhistory.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case subcontrolhistory.FieldCategoryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case subcontrolhistory.FieldSubcategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubcategory(v)
		return nil
	case subcontrolhistory.FieldMappedCategories:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappedCategories(v)
		return nil
	case subcontrolhistory.FieldAssessmentObjectives:
		v, ok := value.([]models.AssessmentObjective)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssessmentObjectives(v)
		return nil
	case subcontrolhistory.FieldAssessmentMethods:
		v, ok := value.([]models.AssessmentMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssessmentMethods(v)
		return nil
	case subcontrolhistory.FieldControlQuestions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlQuestions(v)
		return nil
	case subcontrolhistory.FieldImplementationGuidance:
		v, ok := value.([]models.ImplementationGuidance)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementationGuidance(v)
		return nil
	case subcontrolhistory.FieldExampleEvidence:
		v, ok := value.([]models.ExampleEvidence)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExampleEvidence(v)
		return nil
	case subcontrolhistory.FieldReferences:
		v, ok := value.([]models.Reference)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferences(v)
		return nil
	case subcontrolhistory.FieldControlOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlOwnerID(v)
		return nil
	case subcontrolhistory.FieldDelegateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegateID(v)
		return nil
	case subcontrolhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case subcontrolhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case subcontrolhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case subcontrolhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case subcontrolhistory.FieldSubcontrolKindName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubcontrolKindName(v)
		return nil
	case subcontrolhistory.FieldSubcontrolKindID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubcontrolKindID(v)
		return nil
	case subcontrolhistory.FieldRefCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefCode(v)
		return nil
	case subcontrolhistory.FieldControlID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlID(v)
		return nil
	}
	return fmt.Errorf("unknown SubcontrolHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubcontrolHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubcontrolHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubcontrolHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubcontrolHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubcontrolHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subcontrolhistory.FieldRef) {
		fields = append(fields, subcontrolhistory.FieldRef)
	}
	if m.FieldCleared(subcontrolhistory.FieldCreatedAt) {
		fields = append(fields, subcontrolhistory.FieldCreatedAt)
	}
	if m.FieldCleared(subcontrolhistory.FieldUpdatedAt) {
		fields = append(fields, subcontrolhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(subcontrolhistory.FieldCreatedBy) {
		fields = append(fields, subcontrolhistory.FieldCreatedBy)
	}
	if m.FieldCleared(subcontrolhistory.FieldUpdatedBy) {
		fields = append(fields, subcontrolhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(subcontrolhistory.FieldDeletedAt) {
		fields = append(fields, subcontrolhistory.FieldDeletedAt)
	}
	if m.FieldCleared(subcontrolhistory.FieldDeletedBy) {
		fields = append(fields, subcontrolhistory.FieldDeletedBy)
	}
	if m.FieldCleared(subcontrolhistory.FieldTags) {
		fields = append(fields, subcontrolhistory.FieldTags)
	}
	if m.FieldCleared(subcontrolhistory.FieldTitle) {
		fields = append(fields, subcontrolhistory.FieldTitle)
	}
	if m.FieldCleared(subcontrolhistory.FieldDescription) {
		fields = append(fields, subcontrolhistory.FieldDescription)
	}
	if m.FieldCleared(subcontrolhistory.FieldAliases) {
		fields = append(fields, subcontrolhistory.FieldAliases)
	}
	if m.FieldCleared(subcontrolhistory.FieldReferenceID) {
		fields = append(fields, subcontrolhistory.FieldReferenceID)
	}
	if m.FieldCleared(subcontrolhistory.FieldAuditorReferenceID) {
		fields = append(fields, subcontrolhistory.FieldAuditorReferenceID)
	}
	if m.FieldCleared(subcontrolhistory.FieldResponsiblePartyID) {
		fields = append(fields, subcontrolhistory.FieldResponsiblePartyID)
	}
	if m.FieldCleared(subcontrolhistory.FieldStatus) {
		fields = append(fields, subcontrolhistory.FieldStatus)
	}
	if m.FieldCleared(subcontrolhistory.FieldSource) {
		fields = append(fields, subcontrolhistory.FieldSource)
	}
	if m.FieldCleared(subcontrolhistory.FieldReferenceFramework) {
		fields = append(fields, subcontrolhistory.FieldReferenceFramework)
	}
	if m.FieldCleared(subcontrolhistory.FieldReferenceFrameworkRevision) {
		fields = append(fields, subcontrolhistory.FieldReferenceFrameworkRevision)
	}
	if m.FieldCleared(subcontrolhistory.FieldControlType) {
		fields = append(fields, subcontrolhistory.FieldControlType)
	}
	if m.FieldCleared(subcontrolhistory.FieldCategory) {
		fields = append(fields, subcontrolhistory.FieldCategory)
	}
	if m.FieldCleared(subcontrolhistory.FieldCategoryID) {
		fields = append(fields, subcontrolhistory.FieldCategoryID)
	}
	if m.FieldCleared(subcontrolhistory.FieldSubcategory) {
		fields = append(fields, subcontrolhistory.FieldSubcategory)
	}
	if m.FieldCleared(subcontrolhistory.FieldMappedCategories) {
		fields = append(fields, subcontrolhistory.FieldMappedCategories)
	}
	if m.FieldCleared(subcontrolhistory.FieldAssessmentObjectives) {
		fields = append(fields, subcontrolhistory.FieldAssessmentObjectives)
	}
	if m.FieldCleared(subcontrolhistory.FieldAssessmentMethods) {
		fields = append(fields, subcontrolhistory.FieldAssessmentMethods)
	}
	if m.FieldCleared(subcontrolhistory.FieldControlQuestions) {
		fields = append(fields, subcontrolhistory.FieldControlQuestions)
	}
	if m.FieldCleared(subcontrolhistory.FieldImplementationGuidance) {
		fields = append(fields, subcontrolhistory.FieldImplementationGuidance)
	}
	if m.FieldCleared(subcontrolhistory.FieldExampleEvidence) {
		fields = append(fields, subcontrolhistory.FieldExampleEvidence)
	}
	if m.FieldCleared(subcontrolhistory.FieldReferences) {
		fields = append(fields, subcontrolhistory.FieldReferences)
	}
	if m.FieldCleared(subcontrolhistory.FieldControlOwnerID) {
		fields = append(fields, subcontrolhistory.FieldControlOwnerID)
	}
	if m.FieldCleared(subcontrolhistory.FieldDelegateID) {
		fields = append(fields, subcontrolhistory.FieldDelegateID)
	}
	if m.FieldCleared(subcontrolhistory.FieldOwnerID) {
		fields = append(fields, subcontrolhistory.FieldOwnerID)
	}
	if m.FieldCleared(subcontrolhistory.FieldSystemOwned) {
		fields = append(fields, subcontrolhistory.FieldSystemOwned)
	}
	if m.FieldCleared(subcontrolhistory.FieldInternalNotes) {
		fields = append(fields, subcontrolhistory.FieldInternalNotes)
	}
	if m.FieldCleared(subcontrolhistory.FieldSystemInternalID) {
		fields = append(fields, subcontrolhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(subcontrolhistory.FieldSubcontrolKindName) {
		fields = append(fields, subcontrolhistory.FieldSubcontrolKindName)
	}
	if m.FieldCleared(subcontrolhistory.FieldSubcontrolKindID) {
		fields = append(fields, subcontrolhistory.FieldSubcontrolKindID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubcontrolHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubcontrolHistoryMutation) ClearField(name string) error {
	switch name {
	case subcontrolhistory.FieldRef:
		m.ClearRef()
		return nil
	case subcontrolhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case subcontrolhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case subcontrolhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case subcontrolhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case subcontrolhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subcontrolhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case subcontrolhistory.FieldTags:
		m.ClearTags()
		return nil
	case subcontrolhistory.FieldTitle:
		m.ClearTitle()
		return nil
	case subcontrolhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case subcontrolhistory.FieldAliases:
		m.ClearAliases()
		return nil
	case subcontrolhistory.FieldReferenceID:
		m.ClearReferenceID()
		return nil
	case subcontrolhistory.FieldAuditorReferenceID:
		m.ClearAuditorReferenceID()
		return nil
	case subcontrolhistory.FieldResponsiblePartyID:
		m.ClearResponsiblePartyID()
		return nil
	case subcontrolhistory.FieldStatus:
		m.ClearStatus()
		return nil
	case subcontrolhistory.FieldSource:
		m.ClearSource()
		return nil
	case subcontrolhistory.FieldReferenceFramework:
		m.ClearReferenceFramework()
		return nil
	case subcontrolhistory.FieldReferenceFrameworkRevision:
		m.ClearReferenceFrameworkRevision()
		return nil
	case subcontrolhistory.FieldControlType:
		m.ClearControlType()
		return nil
	case subcontrolhistory.FieldCategory:
		m.ClearCategory()
		return nil
	case subcontrolhistory.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case subcontrolhistory.FieldSubcategory:
		m.ClearSubcategory()
		return nil
	case subcontrolhistory.FieldMappedCategories:
		m.ClearMappedCategories()
		return nil
	case subcontrolhistory.FieldAssessmentObjectives:
		m.ClearAssessmentObjectives()
		return nil
	case subcontrolhistory.FieldAssessmentMethods:
		m.ClearAssessmentMethods()
		return nil
	case subcontrolhistory.FieldControlQuestions:
		m.ClearControlQuestions()
		return nil
	case subcontrolhistory.FieldImplementationGuidance:
		m.ClearImplementationGuidance()
		return nil
	case subcontrolhistory.FieldExampleEvidence:
		m.ClearExampleEvidence()
		return nil
	case subcontrolhistory.FieldReferences:
		m.ClearReferences()
		return nil
	case subcontrolhistory.FieldControlOwnerID:
		m.ClearControlOwnerID()
		return nil
	case subcontrolhistory.FieldDelegateID:
		m.ClearDelegateID()
		return nil
	case subcontrolhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case subcontrolhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case subcontrolhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case subcontrolhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case subcontrolhistory.FieldSubcontrolKindName:
		m.ClearSubcontrolKindName()
		return nil
	case subcontrolhistory.FieldSubcontrolKindID:
		m.ClearSubcontrolKindID()
		return nil
	}
	return fmt.Errorf("unknown SubcontrolHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubcontrolHistoryMutation) ResetField(name string) error {
	switch name {
	case subcontrolhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case subcontrolhistory.FieldRef:
		m.ResetRef()
		return nil
	case subcontrolhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case subcontrolhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subcontrolhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subcontrolhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case subcontrolhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case subcontrolhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subcontrolhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case subcontrolhistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case subcontrolhistory.FieldTags:
		m.ResetTags()
		return nil
	case subcontrolhistory.FieldTitle:
		m.ResetTitle()
		return nil
	case subcontrolhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case subcontrolhistory.FieldAliases:
		m.ResetAliases()
		return nil
	case subcontrolhistory.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case subcontrolhistory.FieldAuditorReferenceID:
		m.ResetAuditorReferenceID()
		return nil
	case subcontrolhistory.FieldResponsiblePartyID:
		m.ResetResponsiblePartyID()
		return nil
	case subcontrolhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case subcontrolhistory.FieldSource:
		m.ResetSource()
		return nil
	case subcontrolhistory.FieldReferenceFramework:
		m.ResetReferenceFramework()
		return nil
	case subcontrolhistory.FieldReferenceFrameworkRevision:
		m.ResetReferenceFrameworkRevision()
		return nil
	case subcontrolhistory.FieldControlType:
		m.ResetControlType()
		return nil
	case subcontrolhistory.FieldCategory:
		m.ResetCategory()
		return nil
	case subcontrolhistory.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case subcontrolhistory.FieldSubcategory:
		m.ResetSubcategory()
		return nil
	case subcontrolhistory.FieldMappedCategories:
		m.ResetMappedCategories()
		return nil
	case subcontrolhistory.FieldAssessmentObjectives:
		m.ResetAssessmentObjectives()
		return nil
	case subcontrolhistory.FieldAssessmentMethods:
		m.ResetAssessmentMethods()
		return nil
	case subcontrolhistory.FieldControlQuestions:
		m.ResetControlQuestions()
		return nil
	case subcontrolhistory.FieldImplementationGuidance:
		m.ResetImplementationGuidance()
		return nil
	case subcontrolhistory.FieldExampleEvidence:
		m.ResetExampleEvidence()
		return nil
	case subcontrolhistory.FieldReferences:
		m.ResetReferences()
		return nil
	case subcontrolhistory.FieldControlOwnerID:
		m.ResetControlOwnerID()
		return nil
	case subcontrolhistory.FieldDelegateID:
		m.ResetDelegateID()
		return nil
	case subcontrolhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case subcontrolhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case subcontrolhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case subcontrolhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case subcontrolhistory.FieldSubcontrolKindName:
		m.ResetSubcontrolKindName()
		return nil
	case subcontrolhistory.FieldSubcontrolKindID:
		m.ResetSubcontrolKindID()
		return nil
	case subcontrolhistory.FieldRefCode:
		m.ResetRefCode()
		return nil
	case subcontrolhistory.FieldControlID:
		m.ResetControlID()
		return nil
	}
	return fmt.Errorf("unknown SubcontrolHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubcontrolHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubcontrolHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubcontrolHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubcontrolHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubcontrolHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubcontrolHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubcontrolHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SubcontrolHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubcontrolHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SubcontrolHistory edge %s", name)
}

// SubprocessorHistoryMutation represents an operation that mutates the SubprocessorHistory nodes in the graph.
type SubprocessorHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	history_time       *time.Time
	ref                *string
	operation          *history.OpType
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	deleted_at         *time.Time
	deleted_by         *string
	tags               *[]string
	appendtags         []string
	owner_id           *string
	system_owned       *bool
	internal_notes     *string
	system_internal_id *string
	name               *string
	description        *string
	logo_remote_url    *string
	logo_file_id       *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*SubprocessorHistory, error)
	predicates         []predicate.SubprocessorHistory
}

var _ ent.Mutation = (*SubprocessorHistoryMutation)(nil)

// subprocessorhistoryOption allows management of the mutation configuration using functional options.
type subprocessorhistoryOption func(*SubprocessorHistoryMutation)

// newSubprocessorHistoryMutation creates new mutation for the SubprocessorHistory entity.
func newSubprocessorHistoryMutation(c config, op Op, opts ...subprocessorhistoryOption) *SubprocessorHistoryMutation {
	m := &SubprocessorHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeSubprocessorHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubprocessorHistoryID sets the ID field of the mutation.
func withSubprocessorHistoryID(id string) subprocessorhistoryOption {
	return func(m *SubprocessorHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *SubprocessorHistory
		)
		m.oldValue = func(ctx context.Context) (*SubprocessorHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubprocessorHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubprocessorHistory sets the old SubprocessorHistory of the mutation.
func withSubprocessorHistory(node *SubprocessorHistory) subprocessorhistoryOption {
	return func(m *SubprocessorHistoryMutation) {
		m.oldValue = func(context.Context) (*SubprocessorHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubprocessorHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubprocessorHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubprocessorHistory entities.
func (m *SubprocessorHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubprocessorHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubprocessorHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubprocessorHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *SubprocessorHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *SubprocessorHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *SubprocessorHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *SubprocessorHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *SubprocessorHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *SubprocessorHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[subprocessorhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *SubprocessorHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[subprocessorhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *SubprocessorHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, subprocessorhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *SubprocessorHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *SubprocessorHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *SubprocessorHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SubprocessorHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubprocessorHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SubprocessorHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[subprocessorhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SubprocessorHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[subprocessorhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubprocessorHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, subprocessorhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubprocessorHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubprocessorHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SubprocessorHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[subprocessorhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SubprocessorHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[subprocessorhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubprocessorHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, subprocessorhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *SubprocessorHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SubprocessorHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *SubprocessorHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[subprocessorhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *SubprocessorHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[subprocessorhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SubprocessorHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, subprocessorhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SubprocessorHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SubprocessorHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *SubprocessorHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[subprocessorhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *SubprocessorHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[subprocessorhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SubprocessorHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, subprocessorhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubprocessorHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubprocessorHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubprocessorHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subprocessorhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubprocessorHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subprocessorhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubprocessorHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subprocessorhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *SubprocessorHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *SubprocessorHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *SubprocessorHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[subprocessorhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *SubprocessorHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[subprocessorhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *SubprocessorHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, subprocessorhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *SubprocessorHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *SubprocessorHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *SubprocessorHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *SubprocessorHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *SubprocessorHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[subprocessorhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *SubprocessorHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[subprocessorhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *SubprocessorHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, subprocessorhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *SubprocessorHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *SubprocessorHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *SubprocessorHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[subprocessorhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *SubprocessorHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[subprocessorhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *SubprocessorHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, subprocessorhistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *SubprocessorHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *SubprocessorHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *SubprocessorHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[subprocessorhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *SubprocessorHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[subprocessorhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *SubprocessorHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, subprocessorhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *SubprocessorHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *SubprocessorHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *SubprocessorHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[subprocessorhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *SubprocessorHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[subprocessorhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *SubprocessorHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, subprocessorhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *SubprocessorHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *SubprocessorHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *SubprocessorHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[subprocessorhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *SubprocessorHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[subprocessorhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *SubprocessorHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, subprocessorhistory.FieldSystemInternalID)
}

// SetName sets the "name" field.
func (m *SubprocessorHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubprocessorHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubprocessorHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SubprocessorHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SubprocessorHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SubprocessorHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[subprocessorhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SubprocessorHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[subprocessorhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SubprocessorHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, subprocessorhistory.FieldDescription)
}

// SetLogoRemoteURL sets the "logo_remote_url" field.
func (m *SubprocessorHistoryMutation) SetLogoRemoteURL(s string) {
	m.logo_remote_url = &s
}

// LogoRemoteURL returns the value of the "logo_remote_url" field in the mutation.
func (m *SubprocessorHistoryMutation) LogoRemoteURL() (r string, exists bool) {
	v := m.logo_remote_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoRemoteURL returns the old "logo_remote_url" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldLogoRemoteURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoRemoteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoRemoteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoRemoteURL: %w", err)
	}
	return oldValue.LogoRemoteURL, nil
}

// ClearLogoRemoteURL clears the value of the "logo_remote_url" field.
func (m *SubprocessorHistoryMutation) ClearLogoRemoteURL() {
	m.logo_remote_url = nil
	m.clearedFields[subprocessorhistory.FieldLogoRemoteURL] = struct{}{}
}

// LogoRemoteURLCleared returns if the "logo_remote_url" field was cleared in this mutation.
func (m *SubprocessorHistoryMutation) LogoRemoteURLCleared() bool {
	_, ok := m.clearedFields[subprocessorhistory.FieldLogoRemoteURL]
	return ok
}

// ResetLogoRemoteURL resets all changes to the "logo_remote_url" field.
func (m *SubprocessorHistoryMutation) ResetLogoRemoteURL() {
	m.logo_remote_url = nil
	delete(m.clearedFields, subprocessorhistory.FieldLogoRemoteURL)
}

// SetLogoFileID sets the "logo_file_id" field.
func (m *SubprocessorHistoryMutation) SetLogoFileID(s string) {
	m.logo_file_id = &s
}

// LogoFileID returns the value of the "logo_file_id" field in the mutation.
func (m *SubprocessorHistoryMutation) LogoFileID() (r string, exists bool) {
	v := m.logo_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoFileID returns the old "logo_file_id" field's value of the SubprocessorHistory entity.
// If the SubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubprocessorHistoryMutation) OldLogoFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoFileID: %w", err)
	}
	return oldValue.LogoFileID, nil
}

// ClearLogoFileID clears the value of the "logo_file_id" field.
func (m *SubprocessorHistoryMutation) ClearLogoFileID() {
	m.logo_file_id = nil
	m.clearedFields[subprocessorhistory.FieldLogoFileID] = struct{}{}
}

// LogoFileIDCleared returns if the "logo_file_id" field was cleared in this mutation.
func (m *SubprocessorHistoryMutation) LogoFileIDCleared() bool {
	_, ok := m.clearedFields[subprocessorhistory.FieldLogoFileID]
	return ok
}

// ResetLogoFileID resets all changes to the "logo_file_id" field.
func (m *SubprocessorHistoryMutation) ResetLogoFileID() {
	m.logo_file_id = nil
	delete(m.clearedFields, subprocessorhistory.FieldLogoFileID)
}

// Where appends a list predicates to the SubprocessorHistoryMutation builder.
func (m *SubprocessorHistoryMutation) Where(ps ...predicate.SubprocessorHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubprocessorHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubprocessorHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubprocessorHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubprocessorHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubprocessorHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubprocessorHistory).
func (m *SubprocessorHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubprocessorHistoryMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.history_time != nil {
		fields = append(fields, subprocessorhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, subprocessorhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, subprocessorhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, subprocessorhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subprocessorhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, subprocessorhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, subprocessorhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, subprocessorhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, subprocessorhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, subprocessorhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, subprocessorhistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, subprocessorhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, subprocessorhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, subprocessorhistory.FieldSystemInternalID)
	}
	if m.name != nil {
		fields = append(fields, subprocessorhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, subprocessorhistory.FieldDescription)
	}
	if m.logo_remote_url != nil {
		fields = append(fields, subprocessorhistory.FieldLogoRemoteURL)
	}
	if m.logo_file_id != nil {
		fields = append(fields, subprocessorhistory.FieldLogoFileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubprocessorHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subprocessorhistory.FieldHistoryTime:
		return m.HistoryTime()
	case subprocessorhistory.FieldRef:
		return m.Ref()
	case subprocessorhistory.FieldOperation:
		return m.Operation()
	case subprocessorhistory.FieldCreatedAt:
		return m.CreatedAt()
	case subprocessorhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case subprocessorhistory.FieldCreatedBy:
		return m.CreatedBy()
	case subprocessorhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case subprocessorhistory.FieldDeletedAt:
		return m.DeletedAt()
	case subprocessorhistory.FieldDeletedBy:
		return m.DeletedBy()
	case subprocessorhistory.FieldTags:
		return m.Tags()
	case subprocessorhistory.FieldOwnerID:
		return m.OwnerID()
	case subprocessorhistory.FieldSystemOwned:
		return m.SystemOwned()
	case subprocessorhistory.FieldInternalNotes:
		return m.InternalNotes()
	case subprocessorhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case subprocessorhistory.FieldName:
		return m.Name()
	case subprocessorhistory.FieldDescription:
		return m.Description()
	case subprocessorhistory.FieldLogoRemoteURL:
		return m.LogoRemoteURL()
	case subprocessorhistory.FieldLogoFileID:
		return m.LogoFileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubprocessorHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subprocessorhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case subprocessorhistory.FieldRef:
		return m.OldRef(ctx)
	case subprocessorhistory.FieldOperation:
		return m.OldOperation(ctx)
	case subprocessorhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subprocessorhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subprocessorhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case subprocessorhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case subprocessorhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subprocessorhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case subprocessorhistory.FieldTags:
		return m.OldTags(ctx)
	case subprocessorhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case subprocessorhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case subprocessorhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case subprocessorhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case subprocessorhistory.FieldName:
		return m.OldName(ctx)
	case subprocessorhistory.FieldDescription:
		return m.OldDescription(ctx)
	case subprocessorhistory.FieldLogoRemoteURL:
		return m.OldLogoRemoteURL(ctx)
	case subprocessorhistory.FieldLogoFileID:
		return m.OldLogoFileID(ctx)
	}
	return nil, fmt.Errorf("unknown SubprocessorHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubprocessorHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subprocessorhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case subprocessorhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case subprocessorhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case subprocessorhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subprocessorhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subprocessorhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case subprocessorhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case subprocessorhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subprocessorhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case subprocessorhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case subprocessorhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case subprocessorhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case subprocessorhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case subprocessorhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case subprocessorhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subprocessorhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case subprocessorhistory.FieldLogoRemoteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoRemoteURL(v)
		return nil
	case subprocessorhistory.FieldLogoFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoFileID(v)
		return nil
	}
	return fmt.Errorf("unknown SubprocessorHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubprocessorHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubprocessorHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubprocessorHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubprocessorHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubprocessorHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subprocessorhistory.FieldRef) {
		fields = append(fields, subprocessorhistory.FieldRef)
	}
	if m.FieldCleared(subprocessorhistory.FieldCreatedAt) {
		fields = append(fields, subprocessorhistory.FieldCreatedAt)
	}
	if m.FieldCleared(subprocessorhistory.FieldUpdatedAt) {
		fields = append(fields, subprocessorhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(subprocessorhistory.FieldCreatedBy) {
		fields = append(fields, subprocessorhistory.FieldCreatedBy)
	}
	if m.FieldCleared(subprocessorhistory.FieldUpdatedBy) {
		fields = append(fields, subprocessorhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(subprocessorhistory.FieldDeletedAt) {
		fields = append(fields, subprocessorhistory.FieldDeletedAt)
	}
	if m.FieldCleared(subprocessorhistory.FieldDeletedBy) {
		fields = append(fields, subprocessorhistory.FieldDeletedBy)
	}
	if m.FieldCleared(subprocessorhistory.FieldTags) {
		fields = append(fields, subprocessorhistory.FieldTags)
	}
	if m.FieldCleared(subprocessorhistory.FieldOwnerID) {
		fields = append(fields, subprocessorhistory.FieldOwnerID)
	}
	if m.FieldCleared(subprocessorhistory.FieldSystemOwned) {
		fields = append(fields, subprocessorhistory.FieldSystemOwned)
	}
	if m.FieldCleared(subprocessorhistory.FieldInternalNotes) {
		fields = append(fields, subprocessorhistory.FieldInternalNotes)
	}
	if m.FieldCleared(subprocessorhistory.FieldSystemInternalID) {
		fields = append(fields, subprocessorhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(subprocessorhistory.FieldDescription) {
		fields = append(fields, subprocessorhistory.FieldDescription)
	}
	if m.FieldCleared(subprocessorhistory.FieldLogoRemoteURL) {
		fields = append(fields, subprocessorhistory.FieldLogoRemoteURL)
	}
	if m.FieldCleared(subprocessorhistory.FieldLogoFileID) {
		fields = append(fields, subprocessorhistory.FieldLogoFileID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubprocessorHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubprocessorHistoryMutation) ClearField(name string) error {
	switch name {
	case subprocessorhistory.FieldRef:
		m.ClearRef()
		return nil
	case subprocessorhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case subprocessorhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case subprocessorhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case subprocessorhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case subprocessorhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subprocessorhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case subprocessorhistory.FieldTags:
		m.ClearTags()
		return nil
	case subprocessorhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case subprocessorhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case subprocessorhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case subprocessorhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case subprocessorhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case subprocessorhistory.FieldLogoRemoteURL:
		m.ClearLogoRemoteURL()
		return nil
	case subprocessorhistory.FieldLogoFileID:
		m.ClearLogoFileID()
		return nil
	}
	return fmt.Errorf("unknown SubprocessorHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubprocessorHistoryMutation) ResetField(name string) error {
	switch name {
	case subprocessorhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case subprocessorhistory.FieldRef:
		m.ResetRef()
		return nil
	case subprocessorhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case subprocessorhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subprocessorhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subprocessorhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case subprocessorhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case subprocessorhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subprocessorhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case subprocessorhistory.FieldTags:
		m.ResetTags()
		return nil
	case subprocessorhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case subprocessorhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case subprocessorhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case subprocessorhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case subprocessorhistory.FieldName:
		m.ResetName()
		return nil
	case subprocessorhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case subprocessorhistory.FieldLogoRemoteURL:
		m.ResetLogoRemoteURL()
		return nil
	case subprocessorhistory.FieldLogoFileID:
		m.ResetLogoFileID()
		return nil
	}
	return fmt.Errorf("unknown SubprocessorHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubprocessorHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubprocessorHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubprocessorHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubprocessorHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubprocessorHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubprocessorHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubprocessorHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SubprocessorHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubprocessorHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SubprocessorHistory edge %s", name)
}

// TaskHistoryMutation represents an operation that mutates the TaskHistory nodes in the graph.
type TaskHistoryMutation struct {
	config
	op                           Op
	typ                          string
	id                           *string
	history_time                 *time.Time
	ref                          *string
	operation                    *history.OpType
	created_at                   *time.Time
	updated_at                   *time.Time
	created_by                   *string
	updated_by                   *string
	deleted_at                   *time.Time
	deleted_by                   *string
	display_id                   *string
	tags                         *[]string
	appendtags                   []string
	owner_id                     *string
	task_kind_name               *string
	task_kind_id                 *string
	title                        *string
	details                      *string
	status                       *enums.TaskStatus
	category                     *string
	due                          *models.DateTime
	completed                    *models.DateTime
	assignee_id                  *string
	assigner_id                  *string
	system_generated             *bool
	idempotency_key              *string
	external_reference_url       *[]string
	appendexternal_reference_url []string
	parent_task_id               *string
	clearedFields                map[string]struct{}
	done                         bool
	oldValue                     func(context.Context) (*TaskHistory, error)
	predicates                   []predicate.TaskHistory
}

var _ ent.Mutation = (*TaskHistoryMutation)(nil)

// taskhistoryOption allows management of the mutation configuration using functional options.
type taskhistoryOption func(*TaskHistoryMutation)

// newTaskHistoryMutation creates new mutation for the TaskHistory entity.
func newTaskHistoryMutation(c config, op Op, opts ...taskhistoryOption) *TaskHistoryMutation {
	m := &TaskHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskHistoryID sets the ID field of the mutation.
func withTaskHistoryID(id string) taskhistoryOption {
	return func(m *TaskHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskHistory
		)
		m.oldValue = func(ctx context.Context) (*TaskHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskHistory sets the old TaskHistory of the mutation.
func withTaskHistory(node *TaskHistory) taskhistoryOption {
	return func(m *TaskHistoryMutation) {
		m.oldValue = func(context.Context) (*TaskHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskHistory entities.
func (m *TaskHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *TaskHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *TaskHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *TaskHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *TaskHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *TaskHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *TaskHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[taskhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *TaskHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *TaskHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, taskhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *TaskHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *TaskHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *TaskHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TaskHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[taskhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TaskHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, taskhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TaskHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[taskhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TaskHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, taskhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TaskHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TaskHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TaskHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[taskhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TaskHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TaskHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, taskhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TaskHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TaskHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TaskHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[taskhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TaskHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TaskHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, taskhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TaskHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TaskHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TaskHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[taskhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TaskHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TaskHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, taskhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TaskHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TaskHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TaskHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[taskhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TaskHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TaskHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, taskhistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *TaskHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *TaskHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *TaskHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *TaskHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *TaskHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *TaskHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *TaskHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *TaskHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[taskhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *TaskHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *TaskHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, taskhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *TaskHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *TaskHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *TaskHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[taskhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *TaskHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *TaskHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, taskhistory.FieldOwnerID)
}

// SetTaskKindName sets the "task_kind_name" field.
func (m *TaskHistoryMutation) SetTaskKindName(s string) {
	m.task_kind_name = &s
}

// TaskKindName returns the value of the "task_kind_name" field in the mutation.
func (m *TaskHistoryMutation) TaskKindName() (r string, exists bool) {
	v := m.task_kind_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskKindName returns the old "task_kind_name" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldTaskKindName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskKindName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskKindName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskKindName: %w", err)
	}
	return oldValue.TaskKindName, nil
}

// ClearTaskKindName clears the value of the "task_kind_name" field.
func (m *TaskHistoryMutation) ClearTaskKindName() {
	m.task_kind_name = nil
	m.clearedFields[taskhistory.FieldTaskKindName] = struct{}{}
}

// TaskKindNameCleared returns if the "task_kind_name" field was cleared in this mutation.
func (m *TaskHistoryMutation) TaskKindNameCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldTaskKindName]
	return ok
}

// ResetTaskKindName resets all changes to the "task_kind_name" field.
func (m *TaskHistoryMutation) ResetTaskKindName() {
	m.task_kind_name = nil
	delete(m.clearedFields, taskhistory.FieldTaskKindName)
}

// SetTaskKindID sets the "task_kind_id" field.
func (m *TaskHistoryMutation) SetTaskKindID(s string) {
	m.task_kind_id = &s
}

// TaskKindID returns the value of the "task_kind_id" field in the mutation.
func (m *TaskHistoryMutation) TaskKindID() (r string, exists bool) {
	v := m.task_kind_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskKindID returns the old "task_kind_id" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldTaskKindID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskKindID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskKindID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskKindID: %w", err)
	}
	return oldValue.TaskKindID, nil
}

// ClearTaskKindID clears the value of the "task_kind_id" field.
func (m *TaskHistoryMutation) ClearTaskKindID() {
	m.task_kind_id = nil
	m.clearedFields[taskhistory.FieldTaskKindID] = struct{}{}
}

// TaskKindIDCleared returns if the "task_kind_id" field was cleared in this mutation.
func (m *TaskHistoryMutation) TaskKindIDCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldTaskKindID]
	return ok
}

// ResetTaskKindID resets all changes to the "task_kind_id" field.
func (m *TaskHistoryMutation) ResetTaskKindID() {
	m.task_kind_id = nil
	delete(m.clearedFields, taskhistory.FieldTaskKindID)
}

// SetTitle sets the "title" field.
func (m *TaskHistoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TaskHistoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TaskHistoryMutation) ResetTitle() {
	m.title = nil
}

// SetDetails sets the "details" field.
func (m *TaskHistoryMutation) SetDetails(s string) {
	m.details = &s
}

// Details returns the value of the "details" field in the mutation.
func (m *TaskHistoryMutation) Details() (r string, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *TaskHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[taskhistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *TaskHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *TaskHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, taskhistory.FieldDetails)
}

// SetStatus sets the "status" field.
func (m *TaskHistoryMutation) SetStatus(es enums.TaskStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskHistoryMutation) Status() (r enums.TaskStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldStatus(ctx context.Context) (v enums.TaskStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskHistoryMutation) ResetStatus() {
	m.status = nil
}

// SetCategory sets the "category" field.
func (m *TaskHistoryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *TaskHistoryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *TaskHistoryMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[taskhistory.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *TaskHistoryMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *TaskHistoryMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, taskhistory.FieldCategory)
}

// SetDue sets the "due" field.
func (m *TaskHistoryMutation) SetDue(mt models.DateTime) {
	m.due = &mt
}

// Due returns the value of the "due" field in the mutation.
func (m *TaskHistoryMutation) Due() (r models.DateTime, exists bool) {
	v := m.due
	if v == nil {
		return
	}
	return *v, true
}

// OldDue returns the old "due" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldDue(ctx context.Context) (v *models.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDue: %w", err)
	}
	return oldValue.Due, nil
}

// ClearDue clears the value of the "due" field.
func (m *TaskHistoryMutation) ClearDue() {
	m.due = nil
	m.clearedFields[taskhistory.FieldDue] = struct{}{}
}

// DueCleared returns if the "due" field was cleared in this mutation.
func (m *TaskHistoryMutation) DueCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldDue]
	return ok
}

// ResetDue resets all changes to the "due" field.
func (m *TaskHistoryMutation) ResetDue() {
	m.due = nil
	delete(m.clearedFields, taskhistory.FieldDue)
}

// SetCompleted sets the "completed" field.
func (m *TaskHistoryMutation) SetCompleted(mt models.DateTime) {
	m.completed = &mt
}

// Completed returns the value of the "completed" field in the mutation.
func (m *TaskHistoryMutation) Completed() (r models.DateTime, exists bool) {
	v := m.completed
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleted returns the old "completed" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldCompleted(ctx context.Context) (v *models.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleted: %w", err)
	}
	return oldValue.Completed, nil
}

// ClearCompleted clears the value of the "completed" field.
func (m *TaskHistoryMutation) ClearCompleted() {
	m.completed = nil
	m.clearedFields[taskhistory.FieldCompleted] = struct{}{}
}

// CompletedCleared returns if the "completed" field was cleared in this mutation.
func (m *TaskHistoryMutation) CompletedCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldCompleted]
	return ok
}

// ResetCompleted resets all changes to the "completed" field.
func (m *TaskHistoryMutation) ResetCompleted() {
	m.completed = nil
	delete(m.clearedFields, taskhistory.FieldCompleted)
}

// SetAssigneeID sets the "assignee_id" field.
func (m *TaskHistoryMutation) SetAssigneeID(s string) {
	m.assignee_id = &s
}

// AssigneeID returns the value of the "assignee_id" field in the mutation.
func (m *TaskHistoryMutation) AssigneeID() (r string, exists bool) {
	v := m.assignee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeID returns the old "assignee_id" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldAssigneeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeID: %w", err)
	}
	return oldValue.AssigneeID, nil
}

// ClearAssigneeID clears the value of the "assignee_id" field.
func (m *TaskHistoryMutation) ClearAssigneeID() {
	m.assignee_id = nil
	m.clearedFields[taskhistory.FieldAssigneeID] = struct{}{}
}

// AssigneeIDCleared returns if the "assignee_id" field was cleared in this mutation.
func (m *TaskHistoryMutation) AssigneeIDCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldAssigneeID]
	return ok
}

// ResetAssigneeID resets all changes to the "assignee_id" field.
func (m *TaskHistoryMutation) ResetAssigneeID() {
	m.assignee_id = nil
	delete(m.clearedFields, taskhistory.FieldAssigneeID)
}

// SetAssignerID sets the "assigner_id" field.
func (m *TaskHistoryMutation) SetAssignerID(s string) {
	m.assigner_id = &s
}

// AssignerID returns the value of the "assigner_id" field in the mutation.
func (m *TaskHistoryMutation) AssignerID() (r string, exists bool) {
	v := m.assigner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignerID returns the old "assigner_id" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldAssignerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignerID: %w", err)
	}
	return oldValue.AssignerID, nil
}

// ClearAssignerID clears the value of the "assigner_id" field.
func (m *TaskHistoryMutation) ClearAssignerID() {
	m.assigner_id = nil
	m.clearedFields[taskhistory.FieldAssignerID] = struct{}{}
}

// AssignerIDCleared returns if the "assigner_id" field was cleared in this mutation.
func (m *TaskHistoryMutation) AssignerIDCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldAssignerID]
	return ok
}

// ResetAssignerID resets all changes to the "assigner_id" field.
func (m *TaskHistoryMutation) ResetAssignerID() {
	m.assigner_id = nil
	delete(m.clearedFields, taskhistory.FieldAssignerID)
}

// SetSystemGenerated sets the "system_generated" field.
func (m *TaskHistoryMutation) SetSystemGenerated(b bool) {
	m.system_generated = &b
}

// SystemGenerated returns the value of the "system_generated" field in the mutation.
func (m *TaskHistoryMutation) SystemGenerated() (r bool, exists bool) {
	v := m.system_generated
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemGenerated returns the old "system_generated" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldSystemGenerated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemGenerated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemGenerated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemGenerated: %w", err)
	}
	return oldValue.SystemGenerated, nil
}

// ResetSystemGenerated resets all changes to the "system_generated" field.
func (m *TaskHistoryMutation) ResetSystemGenerated() {
	m.system_generated = nil
}

// SetIdempotencyKey sets the "idempotency_key" field.
func (m *TaskHistoryMutation) SetIdempotencyKey(s string) {
	m.idempotency_key = &s
}

// IdempotencyKey returns the value of the "idempotency_key" field in the mutation.
func (m *TaskHistoryMutation) IdempotencyKey() (r string, exists bool) {
	v := m.idempotency_key
	if v == nil {
		return
	}
	return *v, true
}

// OldIdempotencyKey returns the old "idempotency_key" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldIdempotencyKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdempotencyKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdempotencyKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdempotencyKey: %w", err)
	}
	return oldValue.IdempotencyKey, nil
}

// ClearIdempotencyKey clears the value of the "idempotency_key" field.
func (m *TaskHistoryMutation) ClearIdempotencyKey() {
	m.idempotency_key = nil
	m.clearedFields[taskhistory.FieldIdempotencyKey] = struct{}{}
}

// IdempotencyKeyCleared returns if the "idempotency_key" field was cleared in this mutation.
func (m *TaskHistoryMutation) IdempotencyKeyCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldIdempotencyKey]
	return ok
}

// ResetIdempotencyKey resets all changes to the "idempotency_key" field.
func (m *TaskHistoryMutation) ResetIdempotencyKey() {
	m.idempotency_key = nil
	delete(m.clearedFields, taskhistory.FieldIdempotencyKey)
}

// SetExternalReferenceURL sets the "external_reference_url" field.
func (m *TaskHistoryMutation) SetExternalReferenceURL(s []string) {
	m.external_reference_url = &s
	m.appendexternal_reference_url = nil
}

// ExternalReferenceURL returns the value of the "external_reference_url" field in the mutation.
func (m *TaskHistoryMutation) ExternalReferenceURL() (r []string, exists bool) {
	v := m.external_reference_url
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalReferenceURL returns the old "external_reference_url" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldExternalReferenceURL(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalReferenceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalReferenceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalReferenceURL: %w", err)
	}
	return oldValue.ExternalReferenceURL, nil
}

// AppendExternalReferenceURL adds s to the "external_reference_url" field.
func (m *TaskHistoryMutation) AppendExternalReferenceURL(s []string) {
	m.appendexternal_reference_url = append(m.appendexternal_reference_url, s...)
}

// AppendedExternalReferenceURL returns the list of values that were appended to the "external_reference_url" field in this mutation.
func (m *TaskHistoryMutation) AppendedExternalReferenceURL() ([]string, bool) {
	if len(m.appendexternal_reference_url) == 0 {
		return nil, false
	}
	return m.appendexternal_reference_url, true
}

// ClearExternalReferenceURL clears the value of the "external_reference_url" field.
func (m *TaskHistoryMutation) ClearExternalReferenceURL() {
	m.external_reference_url = nil
	m.appendexternal_reference_url = nil
	m.clearedFields[taskhistory.FieldExternalReferenceURL] = struct{}{}
}

// ExternalReferenceURLCleared returns if the "external_reference_url" field was cleared in this mutation.
func (m *TaskHistoryMutation) ExternalReferenceURLCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldExternalReferenceURL]
	return ok
}

// ResetExternalReferenceURL resets all changes to the "external_reference_url" field.
func (m *TaskHistoryMutation) ResetExternalReferenceURL() {
	m.external_reference_url = nil
	m.appendexternal_reference_url = nil
	delete(m.clearedFields, taskhistory.FieldExternalReferenceURL)
}

// SetParentTaskID sets the "parent_task_id" field.
func (m *TaskHistoryMutation) SetParentTaskID(s string) {
	m.parent_task_id = &s
}

// ParentTaskID returns the value of the "parent_task_id" field in the mutation.
func (m *TaskHistoryMutation) ParentTaskID() (r string, exists bool) {
	v := m.parent_task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentTaskID returns the old "parent_task_id" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldParentTaskID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentTaskID: %w", err)
	}
	return oldValue.ParentTaskID, nil
}

// ClearParentTaskID clears the value of the "parent_task_id" field.
func (m *TaskHistoryMutation) ClearParentTaskID() {
	m.parent_task_id = nil
	m.clearedFields[taskhistory.FieldParentTaskID] = struct{}{}
}

// ParentTaskIDCleared returns if the "parent_task_id" field was cleared in this mutation.
func (m *TaskHistoryMutation) ParentTaskIDCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldParentTaskID]
	return ok
}

// ResetParentTaskID resets all changes to the "parent_task_id" field.
func (m *TaskHistoryMutation) ResetParentTaskID() {
	m.parent_task_id = nil
	delete(m.clearedFields, taskhistory.FieldParentTaskID)
}

// Where appends a list predicates to the TaskHistoryMutation builder.
func (m *TaskHistoryMutation) Where(ps ...predicate.TaskHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TaskHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TaskHistory).
func (m *TaskHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskHistoryMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.history_time != nil {
		fields = append(fields, taskhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, taskhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, taskhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, taskhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, taskhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, taskhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, taskhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, taskhistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, taskhistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, taskhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, taskhistory.FieldOwnerID)
	}
	if m.task_kind_name != nil {
		fields = append(fields, taskhistory.FieldTaskKindName)
	}
	if m.task_kind_id != nil {
		fields = append(fields, taskhistory.FieldTaskKindID)
	}
	if m.title != nil {
		fields = append(fields, taskhistory.FieldTitle)
	}
	if m.details != nil {
		fields = append(fields, taskhistory.FieldDetails)
	}
	if m.status != nil {
		fields = append(fields, taskhistory.FieldStatus)
	}
	if m.category != nil {
		fields = append(fields, taskhistory.FieldCategory)
	}
	if m.due != nil {
		fields = append(fields, taskhistory.FieldDue)
	}
	if m.completed != nil {
		fields = append(fields, taskhistory.FieldCompleted)
	}
	if m.assignee_id != nil {
		fields = append(fields, taskhistory.FieldAssigneeID)
	}
	if m.assigner_id != nil {
		fields = append(fields, taskhistory.FieldAssignerID)
	}
	if m.system_generated != nil {
		fields = append(fields, taskhistory.FieldSystemGenerated)
	}
	if m.idempotency_key != nil {
		fields = append(fields, taskhistory.FieldIdempotencyKey)
	}
	if m.external_reference_url != nil {
		fields = append(fields, taskhistory.FieldExternalReferenceURL)
	}
	if m.parent_task_id != nil {
		fields = append(fields, taskhistory.FieldParentTaskID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskhistory.FieldHistoryTime:
		return m.HistoryTime()
	case taskhistory.FieldRef:
		return m.Ref()
	case taskhistory.FieldOperation:
		return m.Operation()
	case taskhistory.FieldCreatedAt:
		return m.CreatedAt()
	case taskhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case taskhistory.FieldCreatedBy:
		return m.CreatedBy()
	case taskhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case taskhistory.FieldDeletedAt:
		return m.DeletedAt()
	case taskhistory.FieldDeletedBy:
		return m.DeletedBy()
	case taskhistory.FieldDisplayID:
		return m.DisplayID()
	case taskhistory.FieldTags:
		return m.Tags()
	case taskhistory.FieldOwnerID:
		return m.OwnerID()
	case taskhistory.FieldTaskKindName:
		return m.TaskKindName()
	case taskhistory.FieldTaskKindID:
		return m.TaskKindID()
	case taskhistory.FieldTitle:
		return m.Title()
	case taskhistory.FieldDetails:
		return m.Details()
	case taskhistory.FieldStatus:
		return m.Status()
	case taskhistory.FieldCategory:
		return m.Category()
	case taskhistory.FieldDue:
		return m.Due()
	case taskhistory.FieldCompleted:
		return m.Completed()
	case taskhistory.FieldAssigneeID:
		return m.AssigneeID()
	case taskhistory.FieldAssignerID:
		return m.AssignerID()
	case taskhistory.FieldSystemGenerated:
		return m.SystemGenerated()
	case taskhistory.FieldIdempotencyKey:
		return m.IdempotencyKey()
	case taskhistory.FieldExternalReferenceURL:
		return m.ExternalReferenceURL()
	case taskhistory.FieldParentTaskID:
		return m.ParentTaskID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case taskhistory.FieldRef:
		return m.OldRef(ctx)
	case taskhistory.FieldOperation:
		return m.OldOperation(ctx)
	case taskhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case taskhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case taskhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case taskhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case taskhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case taskhistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case taskhistory.FieldTags:
		return m.OldTags(ctx)
	case taskhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case taskhistory.FieldTaskKindName:
		return m.OldTaskKindName(ctx)
	case taskhistory.FieldTaskKindID:
		return m.OldTaskKindID(ctx)
	case taskhistory.FieldTitle:
		return m.OldTitle(ctx)
	case taskhistory.FieldDetails:
		return m.OldDetails(ctx)
	case taskhistory.FieldStatus:
		return m.OldStatus(ctx)
	case taskhistory.FieldCategory:
		return m.OldCategory(ctx)
	case taskhistory.FieldDue:
		return m.OldDue(ctx)
	case taskhistory.FieldCompleted:
		return m.OldCompleted(ctx)
	case taskhistory.FieldAssigneeID:
		return m.OldAssigneeID(ctx)
	case taskhistory.FieldAssignerID:
		return m.OldAssignerID(ctx)
	case taskhistory.FieldSystemGenerated:
		return m.OldSystemGenerated(ctx)
	case taskhistory.FieldIdempotencyKey:
		return m.OldIdempotencyKey(ctx)
	case taskhistory.FieldExternalReferenceURL:
		return m.OldExternalReferenceURL(ctx)
	case taskhistory.FieldParentTaskID:
		return m.OldParentTaskID(ctx)
	}
	return nil, fmt.Errorf("unknown TaskHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case taskhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case taskhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case taskhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case taskhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case taskhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case taskhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case taskhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case taskhistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case taskhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case taskhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case taskhistory.FieldTaskKindName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskKindName(v)
		return nil
	case taskhistory.FieldTaskKindID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskKindID(v)
		return nil
	case taskhistory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case taskhistory.FieldDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case taskhistory.FieldStatus:
		v, ok := value.(enums.TaskStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case taskhistory.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case taskhistory.FieldDue:
		v, ok := value.(models.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDue(v)
		return nil
	case taskhistory.FieldCompleted:
		v, ok := value.(models.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleted(v)
		return nil
	case taskhistory.FieldAssigneeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeID(v)
		return nil
	case taskhistory.FieldAssignerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignerID(v)
		return nil
	case taskhistory.FieldSystemGenerated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemGenerated(v)
		return nil
	case taskhistory.FieldIdempotencyKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdempotencyKey(v)
		return nil
	case taskhistory.FieldExternalReferenceURL:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalReferenceURL(v)
		return nil
	case taskhistory.FieldParentTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentTaskID(v)
		return nil
	}
	return fmt.Errorf("unknown TaskHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(taskhistory.FieldRef) {
		fields = append(fields, taskhistory.FieldRef)
	}
	if m.FieldCleared(taskhistory.FieldCreatedAt) {
		fields = append(fields, taskhistory.FieldCreatedAt)
	}
	if m.FieldCleared(taskhistory.FieldUpdatedAt) {
		fields = append(fields, taskhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(taskhistory.FieldCreatedBy) {
		fields = append(fields, taskhistory.FieldCreatedBy)
	}
	if m.FieldCleared(taskhistory.FieldUpdatedBy) {
		fields = append(fields, taskhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(taskhistory.FieldDeletedAt) {
		fields = append(fields, taskhistory.FieldDeletedAt)
	}
	if m.FieldCleared(taskhistory.FieldDeletedBy) {
		fields = append(fields, taskhistory.FieldDeletedBy)
	}
	if m.FieldCleared(taskhistory.FieldTags) {
		fields = append(fields, taskhistory.FieldTags)
	}
	if m.FieldCleared(taskhistory.FieldOwnerID) {
		fields = append(fields, taskhistory.FieldOwnerID)
	}
	if m.FieldCleared(taskhistory.FieldTaskKindName) {
		fields = append(fields, taskhistory.FieldTaskKindName)
	}
	if m.FieldCleared(taskhistory.FieldTaskKindID) {
		fields = append(fields, taskhistory.FieldTaskKindID)
	}
	if m.FieldCleared(taskhistory.FieldDetails) {
		fields = append(fields, taskhistory.FieldDetails)
	}
	if m.FieldCleared(taskhistory.FieldCategory) {
		fields = append(fields, taskhistory.FieldCategory)
	}
	if m.FieldCleared(taskhistory.FieldDue) {
		fields = append(fields, taskhistory.FieldDue)
	}
	if m.FieldCleared(taskhistory.FieldCompleted) {
		fields = append(fields, taskhistory.FieldCompleted)
	}
	if m.FieldCleared(taskhistory.FieldAssigneeID) {
		fields = append(fields, taskhistory.FieldAssigneeID)
	}
	if m.FieldCleared(taskhistory.FieldAssignerID) {
		fields = append(fields, taskhistory.FieldAssignerID)
	}
	if m.FieldCleared(taskhistory.FieldIdempotencyKey) {
		fields = append(fields, taskhistory.FieldIdempotencyKey)
	}
	if m.FieldCleared(taskhistory.FieldExternalReferenceURL) {
		fields = append(fields, taskhistory.FieldExternalReferenceURL)
	}
	if m.FieldCleared(taskhistory.FieldParentTaskID) {
		fields = append(fields, taskhistory.FieldParentTaskID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskHistoryMutation) ClearField(name string) error {
	switch name {
	case taskhistory.FieldRef:
		m.ClearRef()
		return nil
	case taskhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case taskhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case taskhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case taskhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case taskhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case taskhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case taskhistory.FieldTags:
		m.ClearTags()
		return nil
	case taskhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case taskhistory.FieldTaskKindName:
		m.ClearTaskKindName()
		return nil
	case taskhistory.FieldTaskKindID:
		m.ClearTaskKindID()
		return nil
	case taskhistory.FieldDetails:
		m.ClearDetails()
		return nil
	case taskhistory.FieldCategory:
		m.ClearCategory()
		return nil
	case taskhistory.FieldDue:
		m.ClearDue()
		return nil
	case taskhistory.FieldCompleted:
		m.ClearCompleted()
		return nil
	case taskhistory.FieldAssigneeID:
		m.ClearAssigneeID()
		return nil
	case taskhistory.FieldAssignerID:
		m.ClearAssignerID()
		return nil
	case taskhistory.FieldIdempotencyKey:
		m.ClearIdempotencyKey()
		return nil
	case taskhistory.FieldExternalReferenceURL:
		m.ClearExternalReferenceURL()
		return nil
	case taskhistory.FieldParentTaskID:
		m.ClearParentTaskID()
		return nil
	}
	return fmt.Errorf("unknown TaskHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskHistoryMutation) ResetField(name string) error {
	switch name {
	case taskhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case taskhistory.FieldRef:
		m.ResetRef()
		return nil
	case taskhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case taskhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case taskhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case taskhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case taskhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case taskhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case taskhistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case taskhistory.FieldTags:
		m.ResetTags()
		return nil
	case taskhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case taskhistory.FieldTaskKindName:
		m.ResetTaskKindName()
		return nil
	case taskhistory.FieldTaskKindID:
		m.ResetTaskKindID()
		return nil
	case taskhistory.FieldTitle:
		m.ResetTitle()
		return nil
	case taskhistory.FieldDetails:
		m.ResetDetails()
		return nil
	case taskhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case taskhistory.FieldCategory:
		m.ResetCategory()
		return nil
	case taskhistory.FieldDue:
		m.ResetDue()
		return nil
	case taskhistory.FieldCompleted:
		m.ResetCompleted()
		return nil
	case taskhistory.FieldAssigneeID:
		m.ResetAssigneeID()
		return nil
	case taskhistory.FieldAssignerID:
		m.ResetAssignerID()
		return nil
	case taskhistory.FieldSystemGenerated:
		m.ResetSystemGenerated()
		return nil
	case taskhistory.FieldIdempotencyKey:
		m.ResetIdempotencyKey()
		return nil
	case taskhistory.FieldExternalReferenceURL:
		m.ResetExternalReferenceURL()
		return nil
	case taskhistory.FieldParentTaskID:
		m.ResetParentTaskID()
		return nil
	}
	return fmt.Errorf("unknown TaskHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TaskHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TaskHistory edge %s", name)
}

// TemplateHistoryMutation represents an operation that mutates the TemplateHistory nodes in the graph.
type TemplateHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	history_time       *time.Time
	ref                *string
	operation          *history.OpType
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	deleted_at         *time.Time
	deleted_by         *string
	tags               *[]string
	appendtags         []string
	owner_id           *string
	system_owned       *bool
	internal_notes     *string
	system_internal_id *string
	name               *string
	template_type      *enums.DocumentType
	description        *string
	kind               *enums.TemplateKind
	jsonconfig         *map[string]interface{}
	uischema           *map[string]interface{}
	trust_center_id    *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*TemplateHistory, error)
	predicates         []predicate.TemplateHistory
}

var _ ent.Mutation = (*TemplateHistoryMutation)(nil)

// templatehistoryOption allows management of the mutation configuration using functional options.
type templatehistoryOption func(*TemplateHistoryMutation)

// newTemplateHistoryMutation creates new mutation for the TemplateHistory entity.
func newTemplateHistoryMutation(c config, op Op, opts ...templatehistoryOption) *TemplateHistoryMutation {
	m := &TemplateHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplateHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateHistoryID sets the ID field of the mutation.
func withTemplateHistoryID(id string) templatehistoryOption {
	return func(m *TemplateHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TemplateHistory
		)
		m.oldValue = func(ctx context.Context) (*TemplateHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TemplateHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplateHistory sets the old TemplateHistory of the mutation.
func withTemplateHistory(node *TemplateHistory) templatehistoryOption {
	return func(m *TemplateHistoryMutation) {
		m.oldValue = func(context.Context) (*TemplateHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TemplateHistory entities.
func (m *TemplateHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplateHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplateHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TemplateHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *TemplateHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *TemplateHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *TemplateHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *TemplateHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *TemplateHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *TemplateHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[templatehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *TemplateHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *TemplateHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, templatehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *TemplateHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *TemplateHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *TemplateHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TemplateHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TemplateHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TemplateHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[templatehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TemplateHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TemplateHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, templatehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TemplateHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TemplateHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TemplateHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[templatehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TemplateHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TemplateHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, templatehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TemplateHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TemplateHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TemplateHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[templatehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TemplateHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TemplateHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, templatehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TemplateHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TemplateHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TemplateHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[templatehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TemplateHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TemplateHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, templatehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TemplateHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TemplateHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TemplateHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[templatehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TemplateHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TemplateHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, templatehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TemplateHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TemplateHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TemplateHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[templatehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TemplateHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TemplateHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, templatehistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *TemplateHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *TemplateHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *TemplateHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *TemplateHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *TemplateHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[templatehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *TemplateHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *TemplateHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, templatehistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *TemplateHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *TemplateHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *TemplateHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[templatehistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *TemplateHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *TemplateHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, templatehistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *TemplateHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *TemplateHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *TemplateHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[templatehistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *TemplateHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *TemplateHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, templatehistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *TemplateHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *TemplateHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *TemplateHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[templatehistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *TemplateHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *TemplateHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, templatehistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *TemplateHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *TemplateHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *TemplateHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[templatehistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *TemplateHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *TemplateHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, templatehistory.FieldSystemInternalID)
}

// SetName sets the "name" field.
func (m *TemplateHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TemplateHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TemplateHistoryMutation) ResetName() {
	m.name = nil
}

// SetTemplateType sets the "template_type" field.
func (m *TemplateHistoryMutation) SetTemplateType(et enums.DocumentType) {
	m.template_type = &et
}

// TemplateType returns the value of the "template_type" field in the mutation.
func (m *TemplateHistoryMutation) TemplateType() (r enums.DocumentType, exists bool) {
	v := m.template_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateType returns the old "template_type" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldTemplateType(ctx context.Context) (v enums.DocumentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateType: %w", err)
	}
	return oldValue.TemplateType, nil
}

// ResetTemplateType resets all changes to the "template_type" field.
func (m *TemplateHistoryMutation) ResetTemplateType() {
	m.template_type = nil
}

// SetDescription sets the "description" field.
func (m *TemplateHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TemplateHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TemplateHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[templatehistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TemplateHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TemplateHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, templatehistory.FieldDescription)
}

// SetKind sets the "kind" field.
func (m *TemplateHistoryMutation) SetKind(ek enums.TemplateKind) {
	m.kind = &ek
}

// Kind returns the value of the "kind" field in the mutation.
func (m *TemplateHistoryMutation) Kind() (r enums.TemplateKind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldKind(ctx context.Context) (v enums.TemplateKind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ClearKind clears the value of the "kind" field.
func (m *TemplateHistoryMutation) ClearKind() {
	m.kind = nil
	m.clearedFields[templatehistory.FieldKind] = struct{}{}
}

// KindCleared returns if the "kind" field was cleared in this mutation.
func (m *TemplateHistoryMutation) KindCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldKind]
	return ok
}

// ResetKind resets all changes to the "kind" field.
func (m *TemplateHistoryMutation) ResetKind() {
	m.kind = nil
	delete(m.clearedFields, templatehistory.FieldKind)
}

// SetJsonconfig sets the "jsonconfig" field.
func (m *TemplateHistoryMutation) SetJsonconfig(value map[string]interface{}) {
	m.jsonconfig = &value
}

// Jsonconfig returns the value of the "jsonconfig" field in the mutation.
func (m *TemplateHistoryMutation) Jsonconfig() (r map[string]interface{}, exists bool) {
	v := m.jsonconfig
	if v == nil {
		return
	}
	return *v, true
}

// OldJsonconfig returns the old "jsonconfig" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldJsonconfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJsonconfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJsonconfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJsonconfig: %w", err)
	}
	return oldValue.Jsonconfig, nil
}

// ResetJsonconfig resets all changes to the "jsonconfig" field.
func (m *TemplateHistoryMutation) ResetJsonconfig() {
	m.jsonconfig = nil
}

// SetUischema sets the "uischema" field.
func (m *TemplateHistoryMutation) SetUischema(value map[string]interface{}) {
	m.uischema = &value
}

// Uischema returns the value of the "uischema" field in the mutation.
func (m *TemplateHistoryMutation) Uischema() (r map[string]interface{}, exists bool) {
	v := m.uischema
	if v == nil {
		return
	}
	return *v, true
}

// OldUischema returns the old "uischema" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldUischema(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUischema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUischema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUischema: %w", err)
	}
	return oldValue.Uischema, nil
}

// ClearUischema clears the value of the "uischema" field.
func (m *TemplateHistoryMutation) ClearUischema() {
	m.uischema = nil
	m.clearedFields[templatehistory.FieldUischema] = struct{}{}
}

// UischemaCleared returns if the "uischema" field was cleared in this mutation.
func (m *TemplateHistoryMutation) UischemaCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldUischema]
	return ok
}

// ResetUischema resets all changes to the "uischema" field.
func (m *TemplateHistoryMutation) ResetUischema() {
	m.uischema = nil
	delete(m.clearedFields, templatehistory.FieldUischema)
}

// SetTrustCenterID sets the "trust_center_id" field.
func (m *TemplateHistoryMutation) SetTrustCenterID(s string) {
	m.trust_center_id = &s
}

// TrustCenterID returns the value of the "trust_center_id" field in the mutation.
func (m *TemplateHistoryMutation) TrustCenterID() (r string, exists bool) {
	v := m.trust_center_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTrustCenterID returns the old "trust_center_id" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldTrustCenterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrustCenterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrustCenterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrustCenterID: %w", err)
	}
	return oldValue.TrustCenterID, nil
}

// ClearTrustCenterID clears the value of the "trust_center_id" field.
func (m *TemplateHistoryMutation) ClearTrustCenterID() {
	m.trust_center_id = nil
	m.clearedFields[templatehistory.FieldTrustCenterID] = struct{}{}
}

// TrustCenterIDCleared returns if the "trust_center_id" field was cleared in this mutation.
func (m *TemplateHistoryMutation) TrustCenterIDCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldTrustCenterID]
	return ok
}

// ResetTrustCenterID resets all changes to the "trust_center_id" field.
func (m *TemplateHistoryMutation) ResetTrustCenterID() {
	m.trust_center_id = nil
	delete(m.clearedFields, templatehistory.FieldTrustCenterID)
}

// Where appends a list predicates to the TemplateHistoryMutation builder.
func (m *TemplateHistoryMutation) Where(ps ...predicate.TemplateHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplateHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplateHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TemplateHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplateHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplateHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TemplateHistory).
func (m *TemplateHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplateHistoryMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.history_time != nil {
		fields = append(fields, templatehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, templatehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, templatehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, templatehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, templatehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, templatehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, templatehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, templatehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, templatehistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, templatehistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, templatehistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, templatehistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, templatehistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, templatehistory.FieldSystemInternalID)
	}
	if m.name != nil {
		fields = append(fields, templatehistory.FieldName)
	}
	if m.template_type != nil {
		fields = append(fields, templatehistory.FieldTemplateType)
	}
	if m.description != nil {
		fields = append(fields, templatehistory.FieldDescription)
	}
	if m.kind != nil {
		fields = append(fields, templatehistory.FieldKind)
	}
	if m.jsonconfig != nil {
		fields = append(fields, templatehistory.FieldJsonconfig)
	}
	if m.uischema != nil {
		fields = append(fields, templatehistory.FieldUischema)
	}
	if m.trust_center_id != nil {
		fields = append(fields, templatehistory.FieldTrustCenterID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplateHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case templatehistory.FieldHistoryTime:
		return m.HistoryTime()
	case templatehistory.FieldRef:
		return m.Ref()
	case templatehistory.FieldOperation:
		return m.Operation()
	case templatehistory.FieldCreatedAt:
		return m.CreatedAt()
	case templatehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case templatehistory.FieldCreatedBy:
		return m.CreatedBy()
	case templatehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case templatehistory.FieldDeletedAt:
		return m.DeletedAt()
	case templatehistory.FieldDeletedBy:
		return m.DeletedBy()
	case templatehistory.FieldTags:
		return m.Tags()
	case templatehistory.FieldOwnerID:
		return m.OwnerID()
	case templatehistory.FieldSystemOwned:
		return m.SystemOwned()
	case templatehistory.FieldInternalNotes:
		return m.InternalNotes()
	case templatehistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case templatehistory.FieldName:
		return m.Name()
	case templatehistory.FieldTemplateType:
		return m.TemplateType()
	case templatehistory.FieldDescription:
		return m.Description()
	case templatehistory.FieldKind:
		return m.Kind()
	case templatehistory.FieldJsonconfig:
		return m.Jsonconfig()
	case templatehistory.FieldUischema:
		return m.Uischema()
	case templatehistory.FieldTrustCenterID:
		return m.TrustCenterID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplateHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case templatehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case templatehistory.FieldRef:
		return m.OldRef(ctx)
	case templatehistory.FieldOperation:
		return m.OldOperation(ctx)
	case templatehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case templatehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case templatehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case templatehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case templatehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case templatehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case templatehistory.FieldTags:
		return m.OldTags(ctx)
	case templatehistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case templatehistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case templatehistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case templatehistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case templatehistory.FieldName:
		return m.OldName(ctx)
	case templatehistory.FieldTemplateType:
		return m.OldTemplateType(ctx)
	case templatehistory.FieldDescription:
		return m.OldDescription(ctx)
	case templatehistory.FieldKind:
		return m.OldKind(ctx)
	case templatehistory.FieldJsonconfig:
		return m.OldJsonconfig(ctx)
	case templatehistory.FieldUischema:
		return m.OldUischema(ctx)
	case templatehistory.FieldTrustCenterID:
		return m.OldTrustCenterID(ctx)
	}
	return nil, fmt.Errorf("unknown TemplateHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case templatehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case templatehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case templatehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case templatehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case templatehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case templatehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case templatehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case templatehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case templatehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case templatehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case templatehistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case templatehistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case templatehistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case templatehistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case templatehistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case templatehistory.FieldTemplateType:
		v, ok := value.(enums.DocumentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateType(v)
		return nil
	case templatehistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case templatehistory.FieldKind:
		v, ok := value.(enums.TemplateKind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case templatehistory.FieldJsonconfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJsonconfig(v)
		return nil
	case templatehistory.FieldUischema:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUischema(v)
		return nil
	case templatehistory.FieldTrustCenterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrustCenterID(v)
		return nil
	}
	return fmt.Errorf("unknown TemplateHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplateHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplateHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TemplateHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplateHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(templatehistory.FieldRef) {
		fields = append(fields, templatehistory.FieldRef)
	}
	if m.FieldCleared(templatehistory.FieldCreatedAt) {
		fields = append(fields, templatehistory.FieldCreatedAt)
	}
	if m.FieldCleared(templatehistory.FieldUpdatedAt) {
		fields = append(fields, templatehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(templatehistory.FieldCreatedBy) {
		fields = append(fields, templatehistory.FieldCreatedBy)
	}
	if m.FieldCleared(templatehistory.FieldUpdatedBy) {
		fields = append(fields, templatehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(templatehistory.FieldDeletedAt) {
		fields = append(fields, templatehistory.FieldDeletedAt)
	}
	if m.FieldCleared(templatehistory.FieldDeletedBy) {
		fields = append(fields, templatehistory.FieldDeletedBy)
	}
	if m.FieldCleared(templatehistory.FieldTags) {
		fields = append(fields, templatehistory.FieldTags)
	}
	if m.FieldCleared(templatehistory.FieldOwnerID) {
		fields = append(fields, templatehistory.FieldOwnerID)
	}
	if m.FieldCleared(templatehistory.FieldSystemOwned) {
		fields = append(fields, templatehistory.FieldSystemOwned)
	}
	if m.FieldCleared(templatehistory.FieldInternalNotes) {
		fields = append(fields, templatehistory.FieldInternalNotes)
	}
	if m.FieldCleared(templatehistory.FieldSystemInternalID) {
		fields = append(fields, templatehistory.FieldSystemInternalID)
	}
	if m.FieldCleared(templatehistory.FieldDescription) {
		fields = append(fields, templatehistory.FieldDescription)
	}
	if m.FieldCleared(templatehistory.FieldKind) {
		fields = append(fields, templatehistory.FieldKind)
	}
	if m.FieldCleared(templatehistory.FieldUischema) {
		fields = append(fields, templatehistory.FieldUischema)
	}
	if m.FieldCleared(templatehistory.FieldTrustCenterID) {
		fields = append(fields, templatehistory.FieldTrustCenterID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplateHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateHistoryMutation) ClearField(name string) error {
	switch name {
	case templatehistory.FieldRef:
		m.ClearRef()
		return nil
	case templatehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case templatehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case templatehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case templatehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case templatehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case templatehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case templatehistory.FieldTags:
		m.ClearTags()
		return nil
	case templatehistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case templatehistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case templatehistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case templatehistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case templatehistory.FieldDescription:
		m.ClearDescription()
		return nil
	case templatehistory.FieldKind:
		m.ClearKind()
		return nil
	case templatehistory.FieldUischema:
		m.ClearUischema()
		return nil
	case templatehistory.FieldTrustCenterID:
		m.ClearTrustCenterID()
		return nil
	}
	return fmt.Errorf("unknown TemplateHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplateHistoryMutation) ResetField(name string) error {
	switch name {
	case templatehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case templatehistory.FieldRef:
		m.ResetRef()
		return nil
	case templatehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case templatehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case templatehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case templatehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case templatehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case templatehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case templatehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case templatehistory.FieldTags:
		m.ResetTags()
		return nil
	case templatehistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case templatehistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case templatehistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case templatehistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case templatehistory.FieldName:
		m.ResetName()
		return nil
	case templatehistory.FieldTemplateType:
		m.ResetTemplateType()
		return nil
	case templatehistory.FieldDescription:
		m.ResetDescription()
		return nil
	case templatehistory.FieldKind:
		m.ResetKind()
		return nil
	case templatehistory.FieldJsonconfig:
		m.ResetJsonconfig()
		return nil
	case templatehistory.FieldUischema:
		m.ResetUischema()
		return nil
	case templatehistory.FieldTrustCenterID:
		m.ResetTrustCenterID()
		return nil
	}
	return fmt.Errorf("unknown TemplateHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplateHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplateHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplateHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplateHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplateHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplateHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplateHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TemplateHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplateHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TemplateHistory edge %s", name)
}

// TrustCenterComplianceHistoryMutation represents an operation that mutates the TrustCenterComplianceHistory nodes in the graph.
type TrustCenterComplianceHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *string
	history_time    *time.Time
	ref             *string
	operation       *history.OpType
	created_at      *time.Time
	updated_at      *time.Time
	created_by      *string
	updated_by      *string
	deleted_at      *time.Time
	deleted_by      *string
	tags            *[]string
	appendtags      []string
	standard_id     *string
	trust_center_id *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*TrustCenterComplianceHistory, error)
	predicates      []predicate.TrustCenterComplianceHistory
}

var _ ent.Mutation = (*TrustCenterComplianceHistoryMutation)(nil)

// trustcentercompliancehistoryOption allows management of the mutation configuration using functional options.
type trustcentercompliancehistoryOption func(*TrustCenterComplianceHistoryMutation)

// newTrustCenterComplianceHistoryMutation creates new mutation for the TrustCenterComplianceHistory entity.
func newTrustCenterComplianceHistoryMutation(c config, op Op, opts ...trustcentercompliancehistoryOption) *TrustCenterComplianceHistoryMutation {
	m := &TrustCenterComplianceHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTrustCenterComplianceHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrustCenterComplianceHistoryID sets the ID field of the mutation.
func withTrustCenterComplianceHistoryID(id string) trustcentercompliancehistoryOption {
	return func(m *TrustCenterComplianceHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TrustCenterComplianceHistory
		)
		m.oldValue = func(ctx context.Context) (*TrustCenterComplianceHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TrustCenterComplianceHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrustCenterComplianceHistory sets the old TrustCenterComplianceHistory of the mutation.
func withTrustCenterComplianceHistory(node *TrustCenterComplianceHistory) trustcentercompliancehistoryOption {
	return func(m *TrustCenterComplianceHistoryMutation) {
		m.oldValue = func(context.Context) (*TrustCenterComplianceHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrustCenterComplianceHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrustCenterComplianceHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TrustCenterComplianceHistory entities.
func (m *TrustCenterComplianceHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrustCenterComplianceHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrustCenterComplianceHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TrustCenterComplianceHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *TrustCenterComplianceHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *TrustCenterComplianceHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the TrustCenterComplianceHistory entity.
// If the TrustCenterComplianceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterComplianceHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *TrustCenterComplianceHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *TrustCenterComplianceHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *TrustCenterComplianceHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the TrustCenterComplianceHistory entity.
// If the TrustCenterComplianceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterComplianceHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *TrustCenterComplianceHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[trustcentercompliancehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *TrustCenterComplianceHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[trustcentercompliancehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *TrustCenterComplianceHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, trustcentercompliancehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *TrustCenterComplianceHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *TrustCenterComplianceHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the TrustCenterComplianceHistory entity.
// If the TrustCenterComplianceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterComplianceHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *TrustCenterComplianceHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TrustCenterComplianceHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrustCenterComplianceHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TrustCenterComplianceHistory entity.
// If the TrustCenterComplianceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterComplianceHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TrustCenterComplianceHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[trustcentercompliancehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TrustCenterComplianceHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[trustcentercompliancehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrustCenterComplianceHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, trustcentercompliancehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TrustCenterComplianceHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TrustCenterComplianceHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TrustCenterComplianceHistory entity.
// If the TrustCenterComplianceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterComplianceHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TrustCenterComplianceHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[trustcentercompliancehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TrustCenterComplianceHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[trustcentercompliancehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TrustCenterComplianceHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, trustcentercompliancehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TrustCenterComplianceHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TrustCenterComplianceHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TrustCenterComplianceHistory entity.
// If the TrustCenterComplianceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterComplianceHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TrustCenterComplianceHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[trustcentercompliancehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TrustCenterComplianceHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[trustcentercompliancehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TrustCenterComplianceHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, trustcentercompliancehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TrustCenterComplianceHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TrustCenterComplianceHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TrustCenterComplianceHistory entity.
// If the TrustCenterComplianceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterComplianceHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TrustCenterComplianceHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[trustcentercompliancehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TrustCenterComplianceHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[trustcentercompliancehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TrustCenterComplianceHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, trustcentercompliancehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TrustCenterComplianceHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TrustCenterComplianceHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TrustCenterComplianceHistory entity.
// If the TrustCenterComplianceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterComplianceHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TrustCenterComplianceHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[trustcentercompliancehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TrustCenterComplianceHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[trustcentercompliancehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TrustCenterComplianceHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, trustcentercompliancehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TrustCenterComplianceHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TrustCenterComplianceHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TrustCenterComplianceHistory entity.
// If the TrustCenterComplianceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterComplianceHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TrustCenterComplianceHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[trustcentercompliancehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TrustCenterComplianceHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[trustcentercompliancehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TrustCenterComplianceHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, trustcentercompliancehistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *TrustCenterComplianceHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *TrustCenterComplianceHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the TrustCenterComplianceHistory entity.
// If the TrustCenterComplianceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterComplianceHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *TrustCenterComplianceHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *TrustCenterComplianceHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *TrustCenterComplianceHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[trustcentercompliancehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *TrustCenterComplianceHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[trustcentercompliancehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *TrustCenterComplianceHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, trustcentercompliancehistory.FieldTags)
}

// SetStandardID sets the "standard_id" field.
func (m *TrustCenterComplianceHistoryMutation) SetStandardID(s string) {
	m.standard_id = &s
}

// StandardID returns the value of the "standard_id" field in the mutation.
func (m *TrustCenterComplianceHistoryMutation) StandardID() (r string, exists bool) {
	v := m.standard_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStandardID returns the old "standard_id" field's value of the TrustCenterComplianceHistory entity.
// If the TrustCenterComplianceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterComplianceHistoryMutation) OldStandardID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStandardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStandardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStandardID: %w", err)
	}
	return oldValue.StandardID, nil
}

// ResetStandardID resets all changes to the "standard_id" field.
func (m *TrustCenterComplianceHistoryMutation) ResetStandardID() {
	m.standard_id = nil
}

// SetTrustCenterID sets the "trust_center_id" field.
func (m *TrustCenterComplianceHistoryMutation) SetTrustCenterID(s string) {
	m.trust_center_id = &s
}

// TrustCenterID returns the value of the "trust_center_id" field in the mutation.
func (m *TrustCenterComplianceHistoryMutation) TrustCenterID() (r string, exists bool) {
	v := m.trust_center_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTrustCenterID returns the old "trust_center_id" field's value of the TrustCenterComplianceHistory entity.
// If the TrustCenterComplianceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterComplianceHistoryMutation) OldTrustCenterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrustCenterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrustCenterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrustCenterID: %w", err)
	}
	return oldValue.TrustCenterID, nil
}

// ClearTrustCenterID clears the value of the "trust_center_id" field.
func (m *TrustCenterComplianceHistoryMutation) ClearTrustCenterID() {
	m.trust_center_id = nil
	m.clearedFields[trustcentercompliancehistory.FieldTrustCenterID] = struct{}{}
}

// TrustCenterIDCleared returns if the "trust_center_id" field was cleared in this mutation.
func (m *TrustCenterComplianceHistoryMutation) TrustCenterIDCleared() bool {
	_, ok := m.clearedFields[trustcentercompliancehistory.FieldTrustCenterID]
	return ok
}

// ResetTrustCenterID resets all changes to the "trust_center_id" field.
func (m *TrustCenterComplianceHistoryMutation) ResetTrustCenterID() {
	m.trust_center_id = nil
	delete(m.clearedFields, trustcentercompliancehistory.FieldTrustCenterID)
}

// Where appends a list predicates to the TrustCenterComplianceHistoryMutation builder.
func (m *TrustCenterComplianceHistoryMutation) Where(ps ...predicate.TrustCenterComplianceHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TrustCenterComplianceHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TrustCenterComplianceHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TrustCenterComplianceHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TrustCenterComplianceHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TrustCenterComplianceHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TrustCenterComplianceHistory).
func (m *TrustCenterComplianceHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrustCenterComplianceHistoryMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.history_time != nil {
		fields = append(fields, trustcentercompliancehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, trustcentercompliancehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, trustcentercompliancehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, trustcentercompliancehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trustcentercompliancehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, trustcentercompliancehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, trustcentercompliancehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, trustcentercompliancehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, trustcentercompliancehistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, trustcentercompliancehistory.FieldTags)
	}
	if m.standard_id != nil {
		fields = append(fields, trustcentercompliancehistory.FieldStandardID)
	}
	if m.trust_center_id != nil {
		fields = append(fields, trustcentercompliancehistory.FieldTrustCenterID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrustCenterComplianceHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trustcentercompliancehistory.FieldHistoryTime:
		return m.HistoryTime()
	case trustcentercompliancehistory.FieldRef:
		return m.Ref()
	case trustcentercompliancehistory.FieldOperation:
		return m.Operation()
	case trustcentercompliancehistory.FieldCreatedAt:
		return m.CreatedAt()
	case trustcentercompliancehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case trustcentercompliancehistory.FieldCreatedBy:
		return m.CreatedBy()
	case trustcentercompliancehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case trustcentercompliancehistory.FieldDeletedAt:
		return m.DeletedAt()
	case trustcentercompliancehistory.FieldDeletedBy:
		return m.DeletedBy()
	case trustcentercompliancehistory.FieldTags:
		return m.Tags()
	case trustcentercompliancehistory.FieldStandardID:
		return m.StandardID()
	case trustcentercompliancehistory.FieldTrustCenterID:
		return m.TrustCenterID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrustCenterComplianceHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trustcentercompliancehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case trustcentercompliancehistory.FieldRef:
		return m.OldRef(ctx)
	case trustcentercompliancehistory.FieldOperation:
		return m.OldOperation(ctx)
	case trustcentercompliancehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trustcentercompliancehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trustcentercompliancehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case trustcentercompliancehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case trustcentercompliancehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case trustcentercompliancehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case trustcentercompliancehistory.FieldTags:
		return m.OldTags(ctx)
	case trustcentercompliancehistory.FieldStandardID:
		return m.OldStandardID(ctx)
	case trustcentercompliancehistory.FieldTrustCenterID:
		return m.OldTrustCenterID(ctx)
	}
	return nil, fmt.Errorf("unknown TrustCenterComplianceHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustCenterComplianceHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trustcentercompliancehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case trustcentercompliancehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case trustcentercompliancehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case trustcentercompliancehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trustcentercompliancehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trustcentercompliancehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case trustcentercompliancehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case trustcentercompliancehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case trustcentercompliancehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case trustcentercompliancehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case trustcentercompliancehistory.FieldStandardID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStandardID(v)
		return nil
	case trustcentercompliancehistory.FieldTrustCenterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrustCenterID(v)
		return nil
	}
	return fmt.Errorf("unknown TrustCenterComplianceHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrustCenterComplianceHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrustCenterComplianceHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustCenterComplianceHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TrustCenterComplianceHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrustCenterComplianceHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trustcentercompliancehistory.FieldRef) {
		fields = append(fields, trustcentercompliancehistory.FieldRef)
	}
	if m.FieldCleared(trustcentercompliancehistory.FieldCreatedAt) {
		fields = append(fields, trustcentercompliancehistory.FieldCreatedAt)
	}
	if m.FieldCleared(trustcentercompliancehistory.FieldUpdatedAt) {
		fields = append(fields, trustcentercompliancehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(trustcentercompliancehistory.FieldCreatedBy) {
		fields = append(fields, trustcentercompliancehistory.FieldCreatedBy)
	}
	if m.FieldCleared(trustcentercompliancehistory.FieldUpdatedBy) {
		fields = append(fields, trustcentercompliancehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(trustcentercompliancehistory.FieldDeletedAt) {
		fields = append(fields, trustcentercompliancehistory.FieldDeletedAt)
	}
	if m.FieldCleared(trustcentercompliancehistory.FieldDeletedBy) {
		fields = append(fields, trustcentercompliancehistory.FieldDeletedBy)
	}
	if m.FieldCleared(trustcentercompliancehistory.FieldTags) {
		fields = append(fields, trustcentercompliancehistory.FieldTags)
	}
	if m.FieldCleared(trustcentercompliancehistory.FieldTrustCenterID) {
		fields = append(fields, trustcentercompliancehistory.FieldTrustCenterID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrustCenterComplianceHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrustCenterComplianceHistoryMutation) ClearField(name string) error {
	switch name {
	case trustcentercompliancehistory.FieldRef:
		m.ClearRef()
		return nil
	case trustcentercompliancehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case trustcentercompliancehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case trustcentercompliancehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case trustcentercompliancehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case trustcentercompliancehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case trustcentercompliancehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case trustcentercompliancehistory.FieldTags:
		m.ClearTags()
		return nil
	case trustcentercompliancehistory.FieldTrustCenterID:
		m.ClearTrustCenterID()
		return nil
	}
	return fmt.Errorf("unknown TrustCenterComplianceHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrustCenterComplianceHistoryMutation) ResetField(name string) error {
	switch name {
	case trustcentercompliancehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case trustcentercompliancehistory.FieldRef:
		m.ResetRef()
		return nil
	case trustcentercompliancehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case trustcentercompliancehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trustcentercompliancehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trustcentercompliancehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case trustcentercompliancehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case trustcentercompliancehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case trustcentercompliancehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case trustcentercompliancehistory.FieldTags:
		m.ResetTags()
		return nil
	case trustcentercompliancehistory.FieldStandardID:
		m.ResetStandardID()
		return nil
	case trustcentercompliancehistory.FieldTrustCenterID:
		m.ResetTrustCenterID()
		return nil
	}
	return fmt.Errorf("unknown TrustCenterComplianceHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrustCenterComplianceHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrustCenterComplianceHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrustCenterComplianceHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrustCenterComplianceHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrustCenterComplianceHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrustCenterComplianceHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrustCenterComplianceHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TrustCenterComplianceHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrustCenterComplianceHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TrustCenterComplianceHistory edge %s", name)
}

// TrustCenterDocHistoryMutation represents an operation that mutates the TrustCenterDocHistory nodes in the graph.
type TrustCenterDocHistoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	history_time         *time.Time
	ref                  *string
	operation            *history.OpType
	created_at           *time.Time
	updated_at           *time.Time
	created_by           *string
	updated_by           *string
	deleted_at           *time.Time
	deleted_by           *string
	tags                 *[]string
	appendtags           []string
	trust_center_id      *string
	title                *string
	category             *string
	file_id              *string
	original_file_id     *string
	watermarking_enabled *bool
	watermark_status     *enums.WatermarkStatus
	visibility           *enums.TrustCenterDocumentVisibility
	standard_id          *string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*TrustCenterDocHistory, error)
	predicates           []predicate.TrustCenterDocHistory
}

var _ ent.Mutation = (*TrustCenterDocHistoryMutation)(nil)

// trustcenterdochistoryOption allows management of the mutation configuration using functional options.
type trustcenterdochistoryOption func(*TrustCenterDocHistoryMutation)

// newTrustCenterDocHistoryMutation creates new mutation for the TrustCenterDocHistory entity.
func newTrustCenterDocHistoryMutation(c config, op Op, opts ...trustcenterdochistoryOption) *TrustCenterDocHistoryMutation {
	m := &TrustCenterDocHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTrustCenterDocHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrustCenterDocHistoryID sets the ID field of the mutation.
func withTrustCenterDocHistoryID(id string) trustcenterdochistoryOption {
	return func(m *TrustCenterDocHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TrustCenterDocHistory
		)
		m.oldValue = func(ctx context.Context) (*TrustCenterDocHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TrustCenterDocHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrustCenterDocHistory sets the old TrustCenterDocHistory of the mutation.
func withTrustCenterDocHistory(node *TrustCenterDocHistory) trustcenterdochistoryOption {
	return func(m *TrustCenterDocHistoryMutation) {
		m.oldValue = func(context.Context) (*TrustCenterDocHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrustCenterDocHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrustCenterDocHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TrustCenterDocHistory entities.
func (m *TrustCenterDocHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrustCenterDocHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrustCenterDocHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TrustCenterDocHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *TrustCenterDocHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *TrustCenterDocHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *TrustCenterDocHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *TrustCenterDocHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *TrustCenterDocHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *TrustCenterDocHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[trustcenterdochistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[trustcenterdochistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *TrustCenterDocHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, trustcenterdochistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *TrustCenterDocHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *TrustCenterDocHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *TrustCenterDocHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TrustCenterDocHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrustCenterDocHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TrustCenterDocHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[trustcenterdochistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[trustcenterdochistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrustCenterDocHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, trustcenterdochistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TrustCenterDocHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TrustCenterDocHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TrustCenterDocHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[trustcenterdochistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[trustcenterdochistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TrustCenterDocHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, trustcenterdochistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TrustCenterDocHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TrustCenterDocHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TrustCenterDocHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[trustcenterdochistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[trustcenterdochistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TrustCenterDocHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, trustcenterdochistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TrustCenterDocHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TrustCenterDocHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TrustCenterDocHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[trustcenterdochistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[trustcenterdochistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TrustCenterDocHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, trustcenterdochistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TrustCenterDocHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TrustCenterDocHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TrustCenterDocHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[trustcenterdochistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[trustcenterdochistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TrustCenterDocHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, trustcenterdochistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TrustCenterDocHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TrustCenterDocHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TrustCenterDocHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[trustcenterdochistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[trustcenterdochistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TrustCenterDocHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, trustcenterdochistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *TrustCenterDocHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *TrustCenterDocHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *TrustCenterDocHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *TrustCenterDocHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *TrustCenterDocHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[trustcenterdochistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[trustcenterdochistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *TrustCenterDocHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, trustcenterdochistory.FieldTags)
}

// SetTrustCenterID sets the "trust_center_id" field.
func (m *TrustCenterDocHistoryMutation) SetTrustCenterID(s string) {
	m.trust_center_id = &s
}

// TrustCenterID returns the value of the "trust_center_id" field in the mutation.
func (m *TrustCenterDocHistoryMutation) TrustCenterID() (r string, exists bool) {
	v := m.trust_center_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTrustCenterID returns the old "trust_center_id" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldTrustCenterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrustCenterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrustCenterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrustCenterID: %w", err)
	}
	return oldValue.TrustCenterID, nil
}

// ClearTrustCenterID clears the value of the "trust_center_id" field.
func (m *TrustCenterDocHistoryMutation) ClearTrustCenterID() {
	m.trust_center_id = nil
	m.clearedFields[trustcenterdochistory.FieldTrustCenterID] = struct{}{}
}

// TrustCenterIDCleared returns if the "trust_center_id" field was cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) TrustCenterIDCleared() bool {
	_, ok := m.clearedFields[trustcenterdochistory.FieldTrustCenterID]
	return ok
}

// ResetTrustCenterID resets all changes to the "trust_center_id" field.
func (m *TrustCenterDocHistoryMutation) ResetTrustCenterID() {
	m.trust_center_id = nil
	delete(m.clearedFields, trustcenterdochistory.FieldTrustCenterID)
}

// SetTitle sets the "title" field.
func (m *TrustCenterDocHistoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TrustCenterDocHistoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TrustCenterDocHistoryMutation) ResetTitle() {
	m.title = nil
}

// SetCategory sets the "category" field.
func (m *TrustCenterDocHistoryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *TrustCenterDocHistoryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *TrustCenterDocHistoryMutation) ResetCategory() {
	m.category = nil
}

// SetFileID sets the "file_id" field.
func (m *TrustCenterDocHistoryMutation) SetFileID(s string) {
	m.file_id = &s
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *TrustCenterDocHistoryMutation) FileID() (r string, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ClearFileID clears the value of the "file_id" field.
func (m *TrustCenterDocHistoryMutation) ClearFileID() {
	m.file_id = nil
	m.clearedFields[trustcenterdochistory.FieldFileID] = struct{}{}
}

// FileIDCleared returns if the "file_id" field was cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) FileIDCleared() bool {
	_, ok := m.clearedFields[trustcenterdochistory.FieldFileID]
	return ok
}

// ResetFileID resets all changes to the "file_id" field.
func (m *TrustCenterDocHistoryMutation) ResetFileID() {
	m.file_id = nil
	delete(m.clearedFields, trustcenterdochistory.FieldFileID)
}

// SetOriginalFileID sets the "original_file_id" field.
func (m *TrustCenterDocHistoryMutation) SetOriginalFileID(s string) {
	m.original_file_id = &s
}

// OriginalFileID returns the value of the "original_file_id" field in the mutation.
func (m *TrustCenterDocHistoryMutation) OriginalFileID() (r string, exists bool) {
	v := m.original_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalFileID returns the old "original_file_id" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldOriginalFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalFileID: %w", err)
	}
	return oldValue.OriginalFileID, nil
}

// ClearOriginalFileID clears the value of the "original_file_id" field.
func (m *TrustCenterDocHistoryMutation) ClearOriginalFileID() {
	m.original_file_id = nil
	m.clearedFields[trustcenterdochistory.FieldOriginalFileID] = struct{}{}
}

// OriginalFileIDCleared returns if the "original_file_id" field was cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) OriginalFileIDCleared() bool {
	_, ok := m.clearedFields[trustcenterdochistory.FieldOriginalFileID]
	return ok
}

// ResetOriginalFileID resets all changes to the "original_file_id" field.
func (m *TrustCenterDocHistoryMutation) ResetOriginalFileID() {
	m.original_file_id = nil
	delete(m.clearedFields, trustcenterdochistory.FieldOriginalFileID)
}

// SetWatermarkingEnabled sets the "watermarking_enabled" field.
func (m *TrustCenterDocHistoryMutation) SetWatermarkingEnabled(b bool) {
	m.watermarking_enabled = &b
}

// WatermarkingEnabled returns the value of the "watermarking_enabled" field in the mutation.
func (m *TrustCenterDocHistoryMutation) WatermarkingEnabled() (r bool, exists bool) {
	v := m.watermarking_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldWatermarkingEnabled returns the old "watermarking_enabled" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldWatermarkingEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWatermarkingEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWatermarkingEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWatermarkingEnabled: %w", err)
	}
	return oldValue.WatermarkingEnabled, nil
}

// ResetWatermarkingEnabled resets all changes to the "watermarking_enabled" field.
func (m *TrustCenterDocHistoryMutation) ResetWatermarkingEnabled() {
	m.watermarking_enabled = nil
}

// SetWatermarkStatus sets the "watermark_status" field.
func (m *TrustCenterDocHistoryMutation) SetWatermarkStatus(es enums.WatermarkStatus) {
	m.watermark_status = &es
}

// WatermarkStatus returns the value of the "watermark_status" field in the mutation.
func (m *TrustCenterDocHistoryMutation) WatermarkStatus() (r enums.WatermarkStatus, exists bool) {
	v := m.watermark_status
	if v == nil {
		return
	}
	return *v, true
}

// OldWatermarkStatus returns the old "watermark_status" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldWatermarkStatus(ctx context.Context) (v enums.WatermarkStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWatermarkStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWatermarkStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWatermarkStatus: %w", err)
	}
	return oldValue.WatermarkStatus, nil
}

// ClearWatermarkStatus clears the value of the "watermark_status" field.
func (m *TrustCenterDocHistoryMutation) ClearWatermarkStatus() {
	m.watermark_status = nil
	m.clearedFields[trustcenterdochistory.FieldWatermarkStatus] = struct{}{}
}

// WatermarkStatusCleared returns if the "watermark_status" field was cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) WatermarkStatusCleared() bool {
	_, ok := m.clearedFields[trustcenterdochistory.FieldWatermarkStatus]
	return ok
}

// ResetWatermarkStatus resets all changes to the "watermark_status" field.
func (m *TrustCenterDocHistoryMutation) ResetWatermarkStatus() {
	m.watermark_status = nil
	delete(m.clearedFields, trustcenterdochistory.FieldWatermarkStatus)
}

// SetVisibility sets the "visibility" field.
func (m *TrustCenterDocHistoryMutation) SetVisibility(ecdv enums.TrustCenterDocumentVisibility) {
	m.visibility = &ecdv
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *TrustCenterDocHistoryMutation) Visibility() (r enums.TrustCenterDocumentVisibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldVisibility(ctx context.Context) (v enums.TrustCenterDocumentVisibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ClearVisibility clears the value of the "visibility" field.
func (m *TrustCenterDocHistoryMutation) ClearVisibility() {
	m.visibility = nil
	m.clearedFields[trustcenterdochistory.FieldVisibility] = struct{}{}
}

// VisibilityCleared returns if the "visibility" field was cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) VisibilityCleared() bool {
	_, ok := m.clearedFields[trustcenterdochistory.FieldVisibility]
	return ok
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *TrustCenterDocHistoryMutation) ResetVisibility() {
	m.visibility = nil
	delete(m.clearedFields, trustcenterdochistory.FieldVisibility)
}

// SetStandardID sets the "standard_id" field.
func (m *TrustCenterDocHistoryMutation) SetStandardID(s string) {
	m.standard_id = &s
}

// StandardID returns the value of the "standard_id" field in the mutation.
func (m *TrustCenterDocHistoryMutation) StandardID() (r string, exists bool) {
	v := m.standard_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStandardID returns the old "standard_id" field's value of the TrustCenterDocHistory entity.
// If the TrustCenterDocHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterDocHistoryMutation) OldStandardID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStandardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStandardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStandardID: %w", err)
	}
	return oldValue.StandardID, nil
}

// ClearStandardID clears the value of the "standard_id" field.
func (m *TrustCenterDocHistoryMutation) ClearStandardID() {
	m.standard_id = nil
	m.clearedFields[trustcenterdochistory.FieldStandardID] = struct{}{}
}

// StandardIDCleared returns if the "standard_id" field was cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) StandardIDCleared() bool {
	_, ok := m.clearedFields[trustcenterdochistory.FieldStandardID]
	return ok
}

// ResetStandardID resets all changes to the "standard_id" field.
func (m *TrustCenterDocHistoryMutation) ResetStandardID() {
	m.standard_id = nil
	delete(m.clearedFields, trustcenterdochistory.FieldStandardID)
}

// Where appends a list predicates to the TrustCenterDocHistoryMutation builder.
func (m *TrustCenterDocHistoryMutation) Where(ps ...predicate.TrustCenterDocHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TrustCenterDocHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TrustCenterDocHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TrustCenterDocHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TrustCenterDocHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TrustCenterDocHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TrustCenterDocHistory).
func (m *TrustCenterDocHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrustCenterDocHistoryMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.history_time != nil {
		fields = append(fields, trustcenterdochistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, trustcenterdochistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, trustcenterdochistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, trustcenterdochistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trustcenterdochistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, trustcenterdochistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, trustcenterdochistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, trustcenterdochistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, trustcenterdochistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, trustcenterdochistory.FieldTags)
	}
	if m.trust_center_id != nil {
		fields = append(fields, trustcenterdochistory.FieldTrustCenterID)
	}
	if m.title != nil {
		fields = append(fields, trustcenterdochistory.FieldTitle)
	}
	if m.category != nil {
		fields = append(fields, trustcenterdochistory.FieldCategory)
	}
	if m.file_id != nil {
		fields = append(fields, trustcenterdochistory.FieldFileID)
	}
	if m.original_file_id != nil {
		fields = append(fields, trustcenterdochistory.FieldOriginalFileID)
	}
	if m.watermarking_enabled != nil {
		fields = append(fields, trustcenterdochistory.FieldWatermarkingEnabled)
	}
	if m.watermark_status != nil {
		fields = append(fields, trustcenterdochistory.FieldWatermarkStatus)
	}
	if m.visibility != nil {
		fields = append(fields, trustcenterdochistory.FieldVisibility)
	}
	if m.standard_id != nil {
		fields = append(fields, trustcenterdochistory.FieldStandardID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrustCenterDocHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trustcenterdochistory.FieldHistoryTime:
		return m.HistoryTime()
	case trustcenterdochistory.FieldRef:
		return m.Ref()
	case trustcenterdochistory.FieldOperation:
		return m.Operation()
	case trustcenterdochistory.FieldCreatedAt:
		return m.CreatedAt()
	case trustcenterdochistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case trustcenterdochistory.FieldCreatedBy:
		return m.CreatedBy()
	case trustcenterdochistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case trustcenterdochistory.FieldDeletedAt:
		return m.DeletedAt()
	case trustcenterdochistory.FieldDeletedBy:
		return m.DeletedBy()
	case trustcenterdochistory.FieldTags:
		return m.Tags()
	case trustcenterdochistory.FieldTrustCenterID:
		return m.TrustCenterID()
	case trustcenterdochistory.FieldTitle:
		return m.Title()
	case trustcenterdochistory.FieldCategory:
		return m.Category()
	case trustcenterdochistory.FieldFileID:
		return m.FileID()
	case trustcenterdochistory.FieldOriginalFileID:
		return m.OriginalFileID()
	case trustcenterdochistory.FieldWatermarkingEnabled:
		return m.WatermarkingEnabled()
	case trustcenterdochistory.FieldWatermarkStatus:
		return m.WatermarkStatus()
	case trustcenterdochistory.FieldVisibility:
		return m.Visibility()
	case trustcenterdochistory.FieldStandardID:
		return m.StandardID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrustCenterDocHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trustcenterdochistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case trustcenterdochistory.FieldRef:
		return m.OldRef(ctx)
	case trustcenterdochistory.FieldOperation:
		return m.OldOperation(ctx)
	case trustcenterdochistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trustcenterdochistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trustcenterdochistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case trustcenterdochistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case trustcenterdochistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case trustcenterdochistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case trustcenterdochistory.FieldTags:
		return m.OldTags(ctx)
	case trustcenterdochistory.FieldTrustCenterID:
		return m.OldTrustCenterID(ctx)
	case trustcenterdochistory.FieldTitle:
		return m.OldTitle(ctx)
	case trustcenterdochistory.FieldCategory:
		return m.OldCategory(ctx)
	case trustcenterdochistory.FieldFileID:
		return m.OldFileID(ctx)
	case trustcenterdochistory.FieldOriginalFileID:
		return m.OldOriginalFileID(ctx)
	case trustcenterdochistory.FieldWatermarkingEnabled:
		return m.OldWatermarkingEnabled(ctx)
	case trustcenterdochistory.FieldWatermarkStatus:
		return m.OldWatermarkStatus(ctx)
	case trustcenterdochistory.FieldVisibility:
		return m.OldVisibility(ctx)
	case trustcenterdochistory.FieldStandardID:
		return m.OldStandardID(ctx)
	}
	return nil, fmt.Errorf("unknown TrustCenterDocHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustCenterDocHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trustcenterdochistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case trustcenterdochistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case trustcenterdochistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case trustcenterdochistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trustcenterdochistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trustcenterdochistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case trustcenterdochistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case trustcenterdochistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case trustcenterdochistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case trustcenterdochistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case trustcenterdochistory.FieldTrustCenterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrustCenterID(v)
		return nil
	case trustcenterdochistory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case trustcenterdochistory.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case trustcenterdochistory.FieldFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case trustcenterdochistory.FieldOriginalFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalFileID(v)
		return nil
	case trustcenterdochistory.FieldWatermarkingEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWatermarkingEnabled(v)
		return nil
	case trustcenterdochistory.FieldWatermarkStatus:
		v, ok := value.(enums.WatermarkStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWatermarkStatus(v)
		return nil
	case trustcenterdochistory.FieldVisibility:
		v, ok := value.(enums.TrustCenterDocumentVisibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case trustcenterdochistory.FieldStandardID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStandardID(v)
		return nil
	}
	return fmt.Errorf("unknown TrustCenterDocHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrustCenterDocHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrustCenterDocHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustCenterDocHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TrustCenterDocHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrustCenterDocHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trustcenterdochistory.FieldRef) {
		fields = append(fields, trustcenterdochistory.FieldRef)
	}
	if m.FieldCleared(trustcenterdochistory.FieldCreatedAt) {
		fields = append(fields, trustcenterdochistory.FieldCreatedAt)
	}
	if m.FieldCleared(trustcenterdochistory.FieldUpdatedAt) {
		fields = append(fields, trustcenterdochistory.FieldUpdatedAt)
	}
	if m.FieldCleared(trustcenterdochistory.FieldCreatedBy) {
		fields = append(fields, trustcenterdochistory.FieldCreatedBy)
	}
	if m.FieldCleared(trustcenterdochistory.FieldUpdatedBy) {
		fields = append(fields, trustcenterdochistory.FieldUpdatedBy)
	}
	if m.FieldCleared(trustcenterdochistory.FieldDeletedAt) {
		fields = append(fields, trustcenterdochistory.FieldDeletedAt)
	}
	if m.FieldCleared(trustcenterdochistory.FieldDeletedBy) {
		fields = append(fields, trustcenterdochistory.FieldDeletedBy)
	}
	if m.FieldCleared(trustcenterdochistory.FieldTags) {
		fields = append(fields, trustcenterdochistory.FieldTags)
	}
	if m.FieldCleared(trustcenterdochistory.FieldTrustCenterID) {
		fields = append(fields, trustcenterdochistory.FieldTrustCenterID)
	}
	if m.FieldCleared(trustcenterdochistory.FieldFileID) {
		fields = append(fields, trustcenterdochistory.FieldFileID)
	}
	if m.FieldCleared(trustcenterdochistory.FieldOriginalFileID) {
		fields = append(fields, trustcenterdochistory.FieldOriginalFileID)
	}
	if m.FieldCleared(trustcenterdochistory.FieldWatermarkStatus) {
		fields = append(fields, trustcenterdochistory.FieldWatermarkStatus)
	}
	if m.FieldCleared(trustcenterdochistory.FieldVisibility) {
		fields = append(fields, trustcenterdochistory.FieldVisibility)
	}
	if m.FieldCleared(trustcenterdochistory.FieldStandardID) {
		fields = append(fields, trustcenterdochistory.FieldStandardID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrustCenterDocHistoryMutation) ClearField(name string) error {
	switch name {
	case trustcenterdochistory.FieldRef:
		m.ClearRef()
		return nil
	case trustcenterdochistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case trustcenterdochistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case trustcenterdochistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case trustcenterdochistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case trustcenterdochistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case trustcenterdochistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case trustcenterdochistory.FieldTags:
		m.ClearTags()
		return nil
	case trustcenterdochistory.FieldTrustCenterID:
		m.ClearTrustCenterID()
		return nil
	case trustcenterdochistory.FieldFileID:
		m.ClearFileID()
		return nil
	case trustcenterdochistory.FieldOriginalFileID:
		m.ClearOriginalFileID()
		return nil
	case trustcenterdochistory.FieldWatermarkStatus:
		m.ClearWatermarkStatus()
		return nil
	case trustcenterdochistory.FieldVisibility:
		m.ClearVisibility()
		return nil
	case trustcenterdochistory.FieldStandardID:
		m.ClearStandardID()
		return nil
	}
	return fmt.Errorf("unknown TrustCenterDocHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrustCenterDocHistoryMutation) ResetField(name string) error {
	switch name {
	case trustcenterdochistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case trustcenterdochistory.FieldRef:
		m.ResetRef()
		return nil
	case trustcenterdochistory.FieldOperation:
		m.ResetOperation()
		return nil
	case trustcenterdochistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trustcenterdochistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trustcenterdochistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case trustcenterdochistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case trustcenterdochistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case trustcenterdochistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case trustcenterdochistory.FieldTags:
		m.ResetTags()
		return nil
	case trustcenterdochistory.FieldTrustCenterID:
		m.ResetTrustCenterID()
		return nil
	case trustcenterdochistory.FieldTitle:
		m.ResetTitle()
		return nil
	case trustcenterdochistory.FieldCategory:
		m.ResetCategory()
		return nil
	case trustcenterdochistory.FieldFileID:
		m.ResetFileID()
		return nil
	case trustcenterdochistory.FieldOriginalFileID:
		m.ResetOriginalFileID()
		return nil
	case trustcenterdochistory.FieldWatermarkingEnabled:
		m.ResetWatermarkingEnabled()
		return nil
	case trustcenterdochistory.FieldWatermarkStatus:
		m.ResetWatermarkStatus()
		return nil
	case trustcenterdochistory.FieldVisibility:
		m.ResetVisibility()
		return nil
	case trustcenterdochistory.FieldStandardID:
		m.ResetStandardID()
		return nil
	}
	return fmt.Errorf("unknown TrustCenterDocHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrustCenterDocHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrustCenterDocHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrustCenterDocHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrustCenterDocHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrustCenterDocHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrustCenterDocHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TrustCenterDocHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrustCenterDocHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TrustCenterDocHistory edge %s", name)
}

// TrustCenterHistoryMutation represents an operation that mutates the TrustCenterHistory nodes in the graph.
type TrustCenterHistoryMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	history_time               *time.Time
	ref                        *string
	operation                  *history.OpType
	created_at                 *time.Time
	updated_at                 *time.Time
	created_by                 *string
	updated_by                 *string
	deleted_at                 *time.Time
	deleted_by                 *string
	tags                       *[]string
	appendtags                 []string
	owner_id                   *string
	slug                       *string
	custom_domain_id           *string
	preview_domain_id          *string
	pirsch_domain_id           *string
	pirsch_identification_code *string
	preview_status             *enums.TrustCenterPreviewStatus
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*TrustCenterHistory, error)
	predicates                 []predicate.TrustCenterHistory
}

var _ ent.Mutation = (*TrustCenterHistoryMutation)(nil)

// trustcenterhistoryOption allows management of the mutation configuration using functional options.
type trustcenterhistoryOption func(*TrustCenterHistoryMutation)

// newTrustCenterHistoryMutation creates new mutation for the TrustCenterHistory entity.
func newTrustCenterHistoryMutation(c config, op Op, opts ...trustcenterhistoryOption) *TrustCenterHistoryMutation {
	m := &TrustCenterHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTrustCenterHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrustCenterHistoryID sets the ID field of the mutation.
func withTrustCenterHistoryID(id string) trustcenterhistoryOption {
	return func(m *TrustCenterHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TrustCenterHistory
		)
		m.oldValue = func(ctx context.Context) (*TrustCenterHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TrustCenterHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrustCenterHistory sets the old TrustCenterHistory of the mutation.
func withTrustCenterHistory(node *TrustCenterHistory) trustcenterhistoryOption {
	return func(m *TrustCenterHistoryMutation) {
		m.oldValue = func(context.Context) (*TrustCenterHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrustCenterHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrustCenterHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TrustCenterHistory entities.
func (m *TrustCenterHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrustCenterHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrustCenterHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TrustCenterHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *TrustCenterHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *TrustCenterHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *TrustCenterHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *TrustCenterHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *TrustCenterHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *TrustCenterHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[trustcenterhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *TrustCenterHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[trustcenterhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *TrustCenterHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, trustcenterhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *TrustCenterHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *TrustCenterHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *TrustCenterHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TrustCenterHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrustCenterHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TrustCenterHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[trustcenterhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TrustCenterHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[trustcenterhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrustCenterHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, trustcenterhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TrustCenterHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TrustCenterHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TrustCenterHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[trustcenterhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TrustCenterHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[trustcenterhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TrustCenterHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, trustcenterhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TrustCenterHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TrustCenterHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TrustCenterHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[trustcenterhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TrustCenterHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[trustcenterhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TrustCenterHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, trustcenterhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TrustCenterHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TrustCenterHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TrustCenterHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[trustcenterhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TrustCenterHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[trustcenterhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TrustCenterHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, trustcenterhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TrustCenterHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TrustCenterHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TrustCenterHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[trustcenterhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TrustCenterHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[trustcenterhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TrustCenterHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, trustcenterhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TrustCenterHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TrustCenterHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TrustCenterHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[trustcenterhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TrustCenterHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[trustcenterhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TrustCenterHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, trustcenterhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *TrustCenterHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *TrustCenterHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *TrustCenterHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *TrustCenterHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *TrustCenterHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[trustcenterhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *TrustCenterHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[trustcenterhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *TrustCenterHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, trustcenterhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *TrustCenterHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *TrustCenterHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *TrustCenterHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[trustcenterhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *TrustCenterHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[trustcenterhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *TrustCenterHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, trustcenterhistory.FieldOwnerID)
}

// SetSlug sets the "slug" field.
func (m *TrustCenterHistoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TrustCenterHistoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *TrustCenterHistoryMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[trustcenterhistory.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *TrustCenterHistoryMutation) SlugCleared() bool {
	_, ok := m.clearedFields[trustcenterhistory.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *TrustCenterHistoryMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, trustcenterhistory.FieldSlug)
}

// SetCustomDomainID sets the "custom_domain_id" field.
func (m *TrustCenterHistoryMutation) SetCustomDomainID(s string) {
	m.custom_domain_id = &s
}

// CustomDomainID returns the value of the "custom_domain_id" field in the mutation.
func (m *TrustCenterHistoryMutation) CustomDomainID() (r string, exists bool) {
	v := m.custom_domain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomDomainID returns the old "custom_domain_id" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldCustomDomainID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomDomainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomDomainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomDomainID: %w", err)
	}
	return oldValue.CustomDomainID, nil
}

// ClearCustomDomainID clears the value of the "custom_domain_id" field.
func (m *TrustCenterHistoryMutation) ClearCustomDomainID() {
	m.custom_domain_id = nil
	m.clearedFields[trustcenterhistory.FieldCustomDomainID] = struct{}{}
}

// CustomDomainIDCleared returns if the "custom_domain_id" field was cleared in this mutation.
func (m *TrustCenterHistoryMutation) CustomDomainIDCleared() bool {
	_, ok := m.clearedFields[trustcenterhistory.FieldCustomDomainID]
	return ok
}

// ResetCustomDomainID resets all changes to the "custom_domain_id" field.
func (m *TrustCenterHistoryMutation) ResetCustomDomainID() {
	m.custom_domain_id = nil
	delete(m.clearedFields, trustcenterhistory.FieldCustomDomainID)
}

// SetPreviewDomainID sets the "preview_domain_id" field.
func (m *TrustCenterHistoryMutation) SetPreviewDomainID(s string) {
	m.preview_domain_id = &s
}

// PreviewDomainID returns the value of the "preview_domain_id" field in the mutation.
func (m *TrustCenterHistoryMutation) PreviewDomainID() (r string, exists bool) {
	v := m.preview_domain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviewDomainID returns the old "preview_domain_id" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldPreviewDomainID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviewDomainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviewDomainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviewDomainID: %w", err)
	}
	return oldValue.PreviewDomainID, nil
}

// ClearPreviewDomainID clears the value of the "preview_domain_id" field.
func (m *TrustCenterHistoryMutation) ClearPreviewDomainID() {
	m.preview_domain_id = nil
	m.clearedFields[trustcenterhistory.FieldPreviewDomainID] = struct{}{}
}

// PreviewDomainIDCleared returns if the "preview_domain_id" field was cleared in this mutation.
func (m *TrustCenterHistoryMutation) PreviewDomainIDCleared() bool {
	_, ok := m.clearedFields[trustcenterhistory.FieldPreviewDomainID]
	return ok
}

// ResetPreviewDomainID resets all changes to the "preview_domain_id" field.
func (m *TrustCenterHistoryMutation) ResetPreviewDomainID() {
	m.preview_domain_id = nil
	delete(m.clearedFields, trustcenterhistory.FieldPreviewDomainID)
}

// SetPirschDomainID sets the "pirsch_domain_id" field.
func (m *TrustCenterHistoryMutation) SetPirschDomainID(s string) {
	m.pirsch_domain_id = &s
}

// PirschDomainID returns the value of the "pirsch_domain_id" field in the mutation.
func (m *TrustCenterHistoryMutation) PirschDomainID() (r string, exists bool) {
	v := m.pirsch_domain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPirschDomainID returns the old "pirsch_domain_id" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldPirschDomainID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPirschDomainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPirschDomainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPirschDomainID: %w", err)
	}
	return oldValue.PirschDomainID, nil
}

// ClearPirschDomainID clears the value of the "pirsch_domain_id" field.
func (m *TrustCenterHistoryMutation) ClearPirschDomainID() {
	m.pirsch_domain_id = nil
	m.clearedFields[trustcenterhistory.FieldPirschDomainID] = struct{}{}
}

// PirschDomainIDCleared returns if the "pirsch_domain_id" field was cleared in this mutation.
func (m *TrustCenterHistoryMutation) PirschDomainIDCleared() bool {
	_, ok := m.clearedFields[trustcenterhistory.FieldPirschDomainID]
	return ok
}

// ResetPirschDomainID resets all changes to the "pirsch_domain_id" field.
func (m *TrustCenterHistoryMutation) ResetPirschDomainID() {
	m.pirsch_domain_id = nil
	delete(m.clearedFields, trustcenterhistory.FieldPirschDomainID)
}

// SetPirschIdentificationCode sets the "pirsch_identification_code" field.
func (m *TrustCenterHistoryMutation) SetPirschIdentificationCode(s string) {
	m.pirsch_identification_code = &s
}

// PirschIdentificationCode returns the value of the "pirsch_identification_code" field in the mutation.
func (m *TrustCenterHistoryMutation) PirschIdentificationCode() (r string, exists bool) {
	v := m.pirsch_identification_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPirschIdentificationCode returns the old "pirsch_identification_code" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldPirschIdentificationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPirschIdentificationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPirschIdentificationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPirschIdentificationCode: %w", err)
	}
	return oldValue.PirschIdentificationCode, nil
}

// ClearPirschIdentificationCode clears the value of the "pirsch_identification_code" field.
func (m *TrustCenterHistoryMutation) ClearPirschIdentificationCode() {
	m.pirsch_identification_code = nil
	m.clearedFields[trustcenterhistory.FieldPirschIdentificationCode] = struct{}{}
}

// PirschIdentificationCodeCleared returns if the "pirsch_identification_code" field was cleared in this mutation.
func (m *TrustCenterHistoryMutation) PirschIdentificationCodeCleared() bool {
	_, ok := m.clearedFields[trustcenterhistory.FieldPirschIdentificationCode]
	return ok
}

// ResetPirschIdentificationCode resets all changes to the "pirsch_identification_code" field.
func (m *TrustCenterHistoryMutation) ResetPirschIdentificationCode() {
	m.pirsch_identification_code = nil
	delete(m.clearedFields, trustcenterhistory.FieldPirschIdentificationCode)
}

// SetPreviewStatus sets the "preview_status" field.
func (m *TrustCenterHistoryMutation) SetPreviewStatus(ecps enums.TrustCenterPreviewStatus) {
	m.preview_status = &ecps
}

// PreviewStatus returns the value of the "preview_status" field in the mutation.
func (m *TrustCenterHistoryMutation) PreviewStatus() (r enums.TrustCenterPreviewStatus, exists bool) {
	v := m.preview_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviewStatus returns the old "preview_status" field's value of the TrustCenterHistory entity.
// If the TrustCenterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterHistoryMutation) OldPreviewStatus(ctx context.Context) (v enums.TrustCenterPreviewStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviewStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviewStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviewStatus: %w", err)
	}
	return oldValue.PreviewStatus, nil
}

// ClearPreviewStatus clears the value of the "preview_status" field.
func (m *TrustCenterHistoryMutation) ClearPreviewStatus() {
	m.preview_status = nil
	m.clearedFields[trustcenterhistory.FieldPreviewStatus] = struct{}{}
}

// PreviewStatusCleared returns if the "preview_status" field was cleared in this mutation.
func (m *TrustCenterHistoryMutation) PreviewStatusCleared() bool {
	_, ok := m.clearedFields[trustcenterhistory.FieldPreviewStatus]
	return ok
}

// ResetPreviewStatus resets all changes to the "preview_status" field.
func (m *TrustCenterHistoryMutation) ResetPreviewStatus() {
	m.preview_status = nil
	delete(m.clearedFields, trustcenterhistory.FieldPreviewStatus)
}

// Where appends a list predicates to the TrustCenterHistoryMutation builder.
func (m *TrustCenterHistoryMutation) Where(ps ...predicate.TrustCenterHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TrustCenterHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TrustCenterHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TrustCenterHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TrustCenterHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TrustCenterHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TrustCenterHistory).
func (m *TrustCenterHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrustCenterHistoryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.history_time != nil {
		fields = append(fields, trustcenterhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, trustcenterhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, trustcenterhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, trustcenterhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trustcenterhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, trustcenterhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, trustcenterhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, trustcenterhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, trustcenterhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, trustcenterhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, trustcenterhistory.FieldOwnerID)
	}
	if m.slug != nil {
		fields = append(fields, trustcenterhistory.FieldSlug)
	}
	if m.custom_domain_id != nil {
		fields = append(fields, trustcenterhistory.FieldCustomDomainID)
	}
	if m.preview_domain_id != nil {
		fields = append(fields, trustcenterhistory.FieldPreviewDomainID)
	}
	if m.pirsch_domain_id != nil {
		fields = append(fields, trustcenterhistory.FieldPirschDomainID)
	}
	if m.pirsch_identification_code != nil {
		fields = append(fields, trustcenterhistory.FieldPirschIdentificationCode)
	}
	if m.preview_status != nil {
		fields = append(fields, trustcenterhistory.FieldPreviewStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrustCenterHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trustcenterhistory.FieldHistoryTime:
		return m.HistoryTime()
	case trustcenterhistory.FieldRef:
		return m.Ref()
	case trustcenterhistory.FieldOperation:
		return m.Operation()
	case trustcenterhistory.FieldCreatedAt:
		return m.CreatedAt()
	case trustcenterhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case trustcenterhistory.FieldCreatedBy:
		return m.CreatedBy()
	case trustcenterhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case trustcenterhistory.FieldDeletedAt:
		return m.DeletedAt()
	case trustcenterhistory.FieldDeletedBy:
		return m.DeletedBy()
	case trustcenterhistory.FieldTags:
		return m.Tags()
	case trustcenterhistory.FieldOwnerID:
		return m.OwnerID()
	case trustcenterhistory.FieldSlug:
		return m.Slug()
	case trustcenterhistory.FieldCustomDomainID:
		return m.CustomDomainID()
	case trustcenterhistory.FieldPreviewDomainID:
		return m.PreviewDomainID()
	case trustcenterhistory.FieldPirschDomainID:
		return m.PirschDomainID()
	case trustcenterhistory.FieldPirschIdentificationCode:
		return m.PirschIdentificationCode()
	case trustcenterhistory.FieldPreviewStatus:
		return m.PreviewStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrustCenterHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trustcenterhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case trustcenterhistory.FieldRef:
		return m.OldRef(ctx)
	case trustcenterhistory.FieldOperation:
		return m.OldOperation(ctx)
	case trustcenterhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trustcenterhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trustcenterhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case trustcenterhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case trustcenterhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case trustcenterhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case trustcenterhistory.FieldTags:
		return m.OldTags(ctx)
	case trustcenterhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case trustcenterhistory.FieldSlug:
		return m.OldSlug(ctx)
	case trustcenterhistory.FieldCustomDomainID:
		return m.OldCustomDomainID(ctx)
	case trustcenterhistory.FieldPreviewDomainID:
		return m.OldPreviewDomainID(ctx)
	case trustcenterhistory.FieldPirschDomainID:
		return m.OldPirschDomainID(ctx)
	case trustcenterhistory.FieldPirschIdentificationCode:
		return m.OldPirschIdentificationCode(ctx)
	case trustcenterhistory.FieldPreviewStatus:
		return m.OldPreviewStatus(ctx)
	}
	return nil, fmt.Errorf("unknown TrustCenterHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustCenterHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trustcenterhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case trustcenterhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case trustcenterhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case trustcenterhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trustcenterhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trustcenterhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case trustcenterhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case trustcenterhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case trustcenterhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case trustcenterhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case trustcenterhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case trustcenterhistory.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case trustcenterhistory.FieldCustomDomainID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomDomainID(v)
		return nil
	case trustcenterhistory.FieldPreviewDomainID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviewDomainID(v)
		return nil
	case trustcenterhistory.FieldPirschDomainID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPirschDomainID(v)
		return nil
	case trustcenterhistory.FieldPirschIdentificationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPirschIdentificationCode(v)
		return nil
	case trustcenterhistory.FieldPreviewStatus:
		v, ok := value.(enums.TrustCenterPreviewStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviewStatus(v)
		return nil
	}
	return fmt.Errorf("unknown TrustCenterHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrustCenterHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrustCenterHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustCenterHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TrustCenterHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrustCenterHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trustcenterhistory.FieldRef) {
		fields = append(fields, trustcenterhistory.FieldRef)
	}
	if m.FieldCleared(trustcenterhistory.FieldCreatedAt) {
		fields = append(fields, trustcenterhistory.FieldCreatedAt)
	}
	if m.FieldCleared(trustcenterhistory.FieldUpdatedAt) {
		fields = append(fields, trustcenterhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(trustcenterhistory.FieldCreatedBy) {
		fields = append(fields, trustcenterhistory.FieldCreatedBy)
	}
	if m.FieldCleared(trustcenterhistory.FieldUpdatedBy) {
		fields = append(fields, trustcenterhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(trustcenterhistory.FieldDeletedAt) {
		fields = append(fields, trustcenterhistory.FieldDeletedAt)
	}
	if m.FieldCleared(trustcenterhistory.FieldDeletedBy) {
		fields = append(fields, trustcenterhistory.FieldDeletedBy)
	}
	if m.FieldCleared(trustcenterhistory.FieldTags) {
		fields = append(fields, trustcenterhistory.FieldTags)
	}
	if m.FieldCleared(trustcenterhistory.FieldOwnerID) {
		fields = append(fields, trustcenterhistory.FieldOwnerID)
	}
	if m.FieldCleared(trustcenterhistory.FieldSlug) {
		fields = append(fields, trustcenterhistory.FieldSlug)
	}
	if m.FieldCleared(trustcenterhistory.FieldCustomDomainID) {
		fields = append(fields, trustcenterhistory.FieldCustomDomainID)
	}
	if m.FieldCleared(trustcenterhistory.FieldPreviewDomainID) {
		fields = append(fields, trustcenterhistory.FieldPreviewDomainID)
	}
	if m.FieldCleared(trustcenterhistory.FieldPirschDomainID) {
		fields = append(fields, trustcenterhistory.FieldPirschDomainID)
	}
	if m.FieldCleared(trustcenterhistory.FieldPirschIdentificationCode) {
		fields = append(fields, trustcenterhistory.FieldPirschIdentificationCode)
	}
	if m.FieldCleared(trustcenterhistory.FieldPreviewStatus) {
		fields = append(fields, trustcenterhistory.FieldPreviewStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrustCenterHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrustCenterHistoryMutation) ClearField(name string) error {
	switch name {
	case trustcenterhistory.FieldRef:
		m.ClearRef()
		return nil
	case trustcenterhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case trustcenterhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case trustcenterhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case trustcenterhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case trustcenterhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case trustcenterhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case trustcenterhistory.FieldTags:
		m.ClearTags()
		return nil
	case trustcenterhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case trustcenterhistory.FieldSlug:
		m.ClearSlug()
		return nil
	case trustcenterhistory.FieldCustomDomainID:
		m.ClearCustomDomainID()
		return nil
	case trustcenterhistory.FieldPreviewDomainID:
		m.ClearPreviewDomainID()
		return nil
	case trustcenterhistory.FieldPirschDomainID:
		m.ClearPirschDomainID()
		return nil
	case trustcenterhistory.FieldPirschIdentificationCode:
		m.ClearPirschIdentificationCode()
		return nil
	case trustcenterhistory.FieldPreviewStatus:
		m.ClearPreviewStatus()
		return nil
	}
	return fmt.Errorf("unknown TrustCenterHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrustCenterHistoryMutation) ResetField(name string) error {
	switch name {
	case trustcenterhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case trustcenterhistory.FieldRef:
		m.ResetRef()
		return nil
	case trustcenterhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case trustcenterhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trustcenterhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trustcenterhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case trustcenterhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case trustcenterhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case trustcenterhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case trustcenterhistory.FieldTags:
		m.ResetTags()
		return nil
	case trustcenterhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case trustcenterhistory.FieldSlug:
		m.ResetSlug()
		return nil
	case trustcenterhistory.FieldCustomDomainID:
		m.ResetCustomDomainID()
		return nil
	case trustcenterhistory.FieldPreviewDomainID:
		m.ResetPreviewDomainID()
		return nil
	case trustcenterhistory.FieldPirschDomainID:
		m.ResetPirschDomainID()
		return nil
	case trustcenterhistory.FieldPirschIdentificationCode:
		m.ResetPirschIdentificationCode()
		return nil
	case trustcenterhistory.FieldPreviewStatus:
		m.ResetPreviewStatus()
		return nil
	}
	return fmt.Errorf("unknown TrustCenterHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrustCenterHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrustCenterHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrustCenterHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrustCenterHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrustCenterHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrustCenterHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrustCenterHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TrustCenterHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrustCenterHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TrustCenterHistory edge %s", name)
}

// TrustCenterSettingHistoryMutation represents an operation that mutates the TrustCenterSettingHistory nodes in the graph.
type TrustCenterSettingHistoryMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	history_time               *time.Time
	ref                        *string
	operation                  *history.OpType
	created_at                 *time.Time
	updated_at                 *time.Time
	created_by                 *string
	updated_by                 *string
	deleted_at                 *time.Time
	deleted_by                 *string
	trust_center_id            *string
	title                      *string
	overview                   *string
	logo_remote_url            *string
	logo_local_file_id         *string
	favicon_remote_url         *string
	favicon_local_file_id      *string
	theme_mode                 *enums.TrustCenterThemeMode
	primary_color              *string
	font                       *string
	foreground_color           *string
	background_color           *string
	accent_color               *string
	secondary_background_color *string
	secondary_foreground_color *string
	environment                *enums.TrustCenterEnvironment
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*TrustCenterSettingHistory, error)
	predicates                 []predicate.TrustCenterSettingHistory
}

var _ ent.Mutation = (*TrustCenterSettingHistoryMutation)(nil)

// trustcentersettinghistoryOption allows management of the mutation configuration using functional options.
type trustcentersettinghistoryOption func(*TrustCenterSettingHistoryMutation)

// newTrustCenterSettingHistoryMutation creates new mutation for the TrustCenterSettingHistory entity.
func newTrustCenterSettingHistoryMutation(c config, op Op, opts ...trustcentersettinghistoryOption) *TrustCenterSettingHistoryMutation {
	m := &TrustCenterSettingHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTrustCenterSettingHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrustCenterSettingHistoryID sets the ID field of the mutation.
func withTrustCenterSettingHistoryID(id string) trustcentersettinghistoryOption {
	return func(m *TrustCenterSettingHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TrustCenterSettingHistory
		)
		m.oldValue = func(ctx context.Context) (*TrustCenterSettingHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TrustCenterSettingHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrustCenterSettingHistory sets the old TrustCenterSettingHistory of the mutation.
func withTrustCenterSettingHistory(node *TrustCenterSettingHistory) trustcentersettinghistoryOption {
	return func(m *TrustCenterSettingHistoryMutation) {
		m.oldValue = func(context.Context) (*TrustCenterSettingHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrustCenterSettingHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrustCenterSettingHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TrustCenterSettingHistory entities.
func (m *TrustCenterSettingHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrustCenterSettingHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrustCenterSettingHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TrustCenterSettingHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *TrustCenterSettingHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *TrustCenterSettingHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *TrustCenterSettingHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *TrustCenterSettingHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[trustcentersettinghistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *TrustCenterSettingHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *TrustCenterSettingHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *TrustCenterSettingHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TrustCenterSettingHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TrustCenterSettingHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[trustcentersettinghistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrustCenterSettingHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TrustCenterSettingHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TrustCenterSettingHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[trustcentersettinghistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TrustCenterSettingHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TrustCenterSettingHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TrustCenterSettingHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[trustcentersettinghistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TrustCenterSettingHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TrustCenterSettingHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TrustCenterSettingHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[trustcentersettinghistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TrustCenterSettingHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TrustCenterSettingHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TrustCenterSettingHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[trustcentersettinghistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TrustCenterSettingHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TrustCenterSettingHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TrustCenterSettingHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[trustcentersettinghistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TrustCenterSettingHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldDeletedBy)
}

// SetTrustCenterID sets the "trust_center_id" field.
func (m *TrustCenterSettingHistoryMutation) SetTrustCenterID(s string) {
	m.trust_center_id = &s
}

// TrustCenterID returns the value of the "trust_center_id" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) TrustCenterID() (r string, exists bool) {
	v := m.trust_center_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTrustCenterID returns the old "trust_center_id" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldTrustCenterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrustCenterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrustCenterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrustCenterID: %w", err)
	}
	return oldValue.TrustCenterID, nil
}

// ClearTrustCenterID clears the value of the "trust_center_id" field.
func (m *TrustCenterSettingHistoryMutation) ClearTrustCenterID() {
	m.trust_center_id = nil
	m.clearedFields[trustcentersettinghistory.FieldTrustCenterID] = struct{}{}
}

// TrustCenterIDCleared returns if the "trust_center_id" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) TrustCenterIDCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldTrustCenterID]
	return ok
}

// ResetTrustCenterID resets all changes to the "trust_center_id" field.
func (m *TrustCenterSettingHistoryMutation) ResetTrustCenterID() {
	m.trust_center_id = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldTrustCenterID)
}

// SetTitle sets the "title" field.
func (m *TrustCenterSettingHistoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *TrustCenterSettingHistoryMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[trustcentersettinghistory.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) TitleCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *TrustCenterSettingHistoryMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldTitle)
}

// SetOverview sets the "overview" field.
func (m *TrustCenterSettingHistoryMutation) SetOverview(s string) {
	m.overview = &s
}

// Overview returns the value of the "overview" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) Overview() (r string, exists bool) {
	v := m.overview
	if v == nil {
		return
	}
	return *v, true
}

// OldOverview returns the old "overview" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldOverview(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverview: %w", err)
	}
	return oldValue.Overview, nil
}

// ClearOverview clears the value of the "overview" field.
func (m *TrustCenterSettingHistoryMutation) ClearOverview() {
	m.overview = nil
	m.clearedFields[trustcentersettinghistory.FieldOverview] = struct{}{}
}

// OverviewCleared returns if the "overview" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) OverviewCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldOverview]
	return ok
}

// ResetOverview resets all changes to the "overview" field.
func (m *TrustCenterSettingHistoryMutation) ResetOverview() {
	m.overview = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldOverview)
}

// SetLogoRemoteURL sets the "logo_remote_url" field.
func (m *TrustCenterSettingHistoryMutation) SetLogoRemoteURL(s string) {
	m.logo_remote_url = &s
}

// LogoRemoteURL returns the value of the "logo_remote_url" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) LogoRemoteURL() (r string, exists bool) {
	v := m.logo_remote_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoRemoteURL returns the old "logo_remote_url" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldLogoRemoteURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoRemoteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoRemoteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoRemoteURL: %w", err)
	}
	return oldValue.LogoRemoteURL, nil
}

// ClearLogoRemoteURL clears the value of the "logo_remote_url" field.
func (m *TrustCenterSettingHistoryMutation) ClearLogoRemoteURL() {
	m.logo_remote_url = nil
	m.clearedFields[trustcentersettinghistory.FieldLogoRemoteURL] = struct{}{}
}

// LogoRemoteURLCleared returns if the "logo_remote_url" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) LogoRemoteURLCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldLogoRemoteURL]
	return ok
}

// ResetLogoRemoteURL resets all changes to the "logo_remote_url" field.
func (m *TrustCenterSettingHistoryMutation) ResetLogoRemoteURL() {
	m.logo_remote_url = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldLogoRemoteURL)
}

// SetLogoLocalFileID sets the "logo_local_file_id" field.
func (m *TrustCenterSettingHistoryMutation) SetLogoLocalFileID(s string) {
	m.logo_local_file_id = &s
}

// LogoLocalFileID returns the value of the "logo_local_file_id" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) LogoLocalFileID() (r string, exists bool) {
	v := m.logo_local_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoLocalFileID returns the old "logo_local_file_id" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldLogoLocalFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoLocalFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoLocalFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoLocalFileID: %w", err)
	}
	return oldValue.LogoLocalFileID, nil
}

// ClearLogoLocalFileID clears the value of the "logo_local_file_id" field.
func (m *TrustCenterSettingHistoryMutation) ClearLogoLocalFileID() {
	m.logo_local_file_id = nil
	m.clearedFields[trustcentersettinghistory.FieldLogoLocalFileID] = struct{}{}
}

// LogoLocalFileIDCleared returns if the "logo_local_file_id" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) LogoLocalFileIDCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldLogoLocalFileID]
	return ok
}

// ResetLogoLocalFileID resets all changes to the "logo_local_file_id" field.
func (m *TrustCenterSettingHistoryMutation) ResetLogoLocalFileID() {
	m.logo_local_file_id = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldLogoLocalFileID)
}

// SetFaviconRemoteURL sets the "favicon_remote_url" field.
func (m *TrustCenterSettingHistoryMutation) SetFaviconRemoteURL(s string) {
	m.favicon_remote_url = &s
}

// FaviconRemoteURL returns the value of the "favicon_remote_url" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) FaviconRemoteURL() (r string, exists bool) {
	v := m.favicon_remote_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFaviconRemoteURL returns the old "favicon_remote_url" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldFaviconRemoteURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaviconRemoteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaviconRemoteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaviconRemoteURL: %w", err)
	}
	return oldValue.FaviconRemoteURL, nil
}

// ClearFaviconRemoteURL clears the value of the "favicon_remote_url" field.
func (m *TrustCenterSettingHistoryMutation) ClearFaviconRemoteURL() {
	m.favicon_remote_url = nil
	m.clearedFields[trustcentersettinghistory.FieldFaviconRemoteURL] = struct{}{}
}

// FaviconRemoteURLCleared returns if the "favicon_remote_url" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) FaviconRemoteURLCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldFaviconRemoteURL]
	return ok
}

// ResetFaviconRemoteURL resets all changes to the "favicon_remote_url" field.
func (m *TrustCenterSettingHistoryMutation) ResetFaviconRemoteURL() {
	m.favicon_remote_url = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldFaviconRemoteURL)
}

// SetFaviconLocalFileID sets the "favicon_local_file_id" field.
func (m *TrustCenterSettingHistoryMutation) SetFaviconLocalFileID(s string) {
	m.favicon_local_file_id = &s
}

// FaviconLocalFileID returns the value of the "favicon_local_file_id" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) FaviconLocalFileID() (r string, exists bool) {
	v := m.favicon_local_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFaviconLocalFileID returns the old "favicon_local_file_id" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldFaviconLocalFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaviconLocalFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaviconLocalFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaviconLocalFileID: %w", err)
	}
	return oldValue.FaviconLocalFileID, nil
}

// ClearFaviconLocalFileID clears the value of the "favicon_local_file_id" field.
func (m *TrustCenterSettingHistoryMutation) ClearFaviconLocalFileID() {
	m.favicon_local_file_id = nil
	m.clearedFields[trustcentersettinghistory.FieldFaviconLocalFileID] = struct{}{}
}

// FaviconLocalFileIDCleared returns if the "favicon_local_file_id" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) FaviconLocalFileIDCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldFaviconLocalFileID]
	return ok
}

// ResetFaviconLocalFileID resets all changes to the "favicon_local_file_id" field.
func (m *TrustCenterSettingHistoryMutation) ResetFaviconLocalFileID() {
	m.favicon_local_file_id = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldFaviconLocalFileID)
}

// SetThemeMode sets the "theme_mode" field.
func (m *TrustCenterSettingHistoryMutation) SetThemeMode(ectm enums.TrustCenterThemeMode) {
	m.theme_mode = &ectm
}

// ThemeMode returns the value of the "theme_mode" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) ThemeMode() (r enums.TrustCenterThemeMode, exists bool) {
	v := m.theme_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldThemeMode returns the old "theme_mode" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldThemeMode(ctx context.Context) (v enums.TrustCenterThemeMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThemeMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThemeMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThemeMode: %w", err)
	}
	return oldValue.ThemeMode, nil
}

// ClearThemeMode clears the value of the "theme_mode" field.
func (m *TrustCenterSettingHistoryMutation) ClearThemeMode() {
	m.theme_mode = nil
	m.clearedFields[trustcentersettinghistory.FieldThemeMode] = struct{}{}
}

// ThemeModeCleared returns if the "theme_mode" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) ThemeModeCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldThemeMode]
	return ok
}

// ResetThemeMode resets all changes to the "theme_mode" field.
func (m *TrustCenterSettingHistoryMutation) ResetThemeMode() {
	m.theme_mode = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldThemeMode)
}

// SetPrimaryColor sets the "primary_color" field.
func (m *TrustCenterSettingHistoryMutation) SetPrimaryColor(s string) {
	m.primary_color = &s
}

// PrimaryColor returns the value of the "primary_color" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) PrimaryColor() (r string, exists bool) {
	v := m.primary_color
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryColor returns the old "primary_color" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldPrimaryColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryColor: %w", err)
	}
	return oldValue.PrimaryColor, nil
}

// ClearPrimaryColor clears the value of the "primary_color" field.
func (m *TrustCenterSettingHistoryMutation) ClearPrimaryColor() {
	m.primary_color = nil
	m.clearedFields[trustcentersettinghistory.FieldPrimaryColor] = struct{}{}
}

// PrimaryColorCleared returns if the "primary_color" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) PrimaryColorCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldPrimaryColor]
	return ok
}

// ResetPrimaryColor resets all changes to the "primary_color" field.
func (m *TrustCenterSettingHistoryMutation) ResetPrimaryColor() {
	m.primary_color = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldPrimaryColor)
}

// SetFont sets the "font" field.
func (m *TrustCenterSettingHistoryMutation) SetFont(s string) {
	m.font = &s
}

// Font returns the value of the "font" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) Font() (r string, exists bool) {
	v := m.font
	if v == nil {
		return
	}
	return *v, true
}

// OldFont returns the old "font" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldFont(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFont is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFont requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFont: %w", err)
	}
	return oldValue.Font, nil
}

// ClearFont clears the value of the "font" field.
func (m *TrustCenterSettingHistoryMutation) ClearFont() {
	m.font = nil
	m.clearedFields[trustcentersettinghistory.FieldFont] = struct{}{}
}

// FontCleared returns if the "font" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) FontCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldFont]
	return ok
}

// ResetFont resets all changes to the "font" field.
func (m *TrustCenterSettingHistoryMutation) ResetFont() {
	m.font = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldFont)
}

// SetForegroundColor sets the "foreground_color" field.
func (m *TrustCenterSettingHistoryMutation) SetForegroundColor(s string) {
	m.foreground_color = &s
}

// ForegroundColor returns the value of the "foreground_color" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) ForegroundColor() (r string, exists bool) {
	v := m.foreground_color
	if v == nil {
		return
	}
	return *v, true
}

// OldForegroundColor returns the old "foreground_color" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldForegroundColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForegroundColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForegroundColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForegroundColor: %w", err)
	}
	return oldValue.ForegroundColor, nil
}

// ClearForegroundColor clears the value of the "foreground_color" field.
func (m *TrustCenterSettingHistoryMutation) ClearForegroundColor() {
	m.foreground_color = nil
	m.clearedFields[trustcentersettinghistory.FieldForegroundColor] = struct{}{}
}

// ForegroundColorCleared returns if the "foreground_color" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) ForegroundColorCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldForegroundColor]
	return ok
}

// ResetForegroundColor resets all changes to the "foreground_color" field.
func (m *TrustCenterSettingHistoryMutation) ResetForegroundColor() {
	m.foreground_color = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldForegroundColor)
}

// SetBackgroundColor sets the "background_color" field.
func (m *TrustCenterSettingHistoryMutation) SetBackgroundColor(s string) {
	m.background_color = &s
}

// BackgroundColor returns the value of the "background_color" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) BackgroundColor() (r string, exists bool) {
	v := m.background_color
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundColor returns the old "background_color" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldBackgroundColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundColor: %w", err)
	}
	return oldValue.BackgroundColor, nil
}

// ClearBackgroundColor clears the value of the "background_color" field.
func (m *TrustCenterSettingHistoryMutation) ClearBackgroundColor() {
	m.background_color = nil
	m.clearedFields[trustcentersettinghistory.FieldBackgroundColor] = struct{}{}
}

// BackgroundColorCleared returns if the "background_color" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) BackgroundColorCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldBackgroundColor]
	return ok
}

// ResetBackgroundColor resets all changes to the "background_color" field.
func (m *TrustCenterSettingHistoryMutation) ResetBackgroundColor() {
	m.background_color = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldBackgroundColor)
}

// SetAccentColor sets the "accent_color" field.
func (m *TrustCenterSettingHistoryMutation) SetAccentColor(s string) {
	m.accent_color = &s
}

// AccentColor returns the value of the "accent_color" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) AccentColor() (r string, exists bool) {
	v := m.accent_color
	if v == nil {
		return
	}
	return *v, true
}

// OldAccentColor returns the old "accent_color" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldAccentColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccentColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccentColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccentColor: %w", err)
	}
	return oldValue.AccentColor, nil
}

// ClearAccentColor clears the value of the "accent_color" field.
func (m *TrustCenterSettingHistoryMutation) ClearAccentColor() {
	m.accent_color = nil
	m.clearedFields[trustcentersettinghistory.FieldAccentColor] = struct{}{}
}

// AccentColorCleared returns if the "accent_color" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) AccentColorCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldAccentColor]
	return ok
}

// ResetAccentColor resets all changes to the "accent_color" field.
func (m *TrustCenterSettingHistoryMutation) ResetAccentColor() {
	m.accent_color = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldAccentColor)
}

// SetSecondaryBackgroundColor sets the "secondary_background_color" field.
func (m *TrustCenterSettingHistoryMutation) SetSecondaryBackgroundColor(s string) {
	m.secondary_background_color = &s
}

// SecondaryBackgroundColor returns the value of the "secondary_background_color" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) SecondaryBackgroundColor() (r string, exists bool) {
	v := m.secondary_background_color
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondaryBackgroundColor returns the old "secondary_background_color" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldSecondaryBackgroundColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondaryBackgroundColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondaryBackgroundColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondaryBackgroundColor: %w", err)
	}
	return oldValue.SecondaryBackgroundColor, nil
}

// ClearSecondaryBackgroundColor clears the value of the "secondary_background_color" field.
func (m *TrustCenterSettingHistoryMutation) ClearSecondaryBackgroundColor() {
	m.secondary_background_color = nil
	m.clearedFields[trustcentersettinghistory.FieldSecondaryBackgroundColor] = struct{}{}
}

// SecondaryBackgroundColorCleared returns if the "secondary_background_color" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) SecondaryBackgroundColorCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldSecondaryBackgroundColor]
	return ok
}

// ResetSecondaryBackgroundColor resets all changes to the "secondary_background_color" field.
func (m *TrustCenterSettingHistoryMutation) ResetSecondaryBackgroundColor() {
	m.secondary_background_color = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldSecondaryBackgroundColor)
}

// SetSecondaryForegroundColor sets the "secondary_foreground_color" field.
func (m *TrustCenterSettingHistoryMutation) SetSecondaryForegroundColor(s string) {
	m.secondary_foreground_color = &s
}

// SecondaryForegroundColor returns the value of the "secondary_foreground_color" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) SecondaryForegroundColor() (r string, exists bool) {
	v := m.secondary_foreground_color
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondaryForegroundColor returns the old "secondary_foreground_color" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldSecondaryForegroundColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondaryForegroundColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondaryForegroundColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondaryForegroundColor: %w", err)
	}
	return oldValue.SecondaryForegroundColor, nil
}

// ClearSecondaryForegroundColor clears the value of the "secondary_foreground_color" field.
func (m *TrustCenterSettingHistoryMutation) ClearSecondaryForegroundColor() {
	m.secondary_foreground_color = nil
	m.clearedFields[trustcentersettinghistory.FieldSecondaryForegroundColor] = struct{}{}
}

// SecondaryForegroundColorCleared returns if the "secondary_foreground_color" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) SecondaryForegroundColorCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldSecondaryForegroundColor]
	return ok
}

// ResetSecondaryForegroundColor resets all changes to the "secondary_foreground_color" field.
func (m *TrustCenterSettingHistoryMutation) ResetSecondaryForegroundColor() {
	m.secondary_foreground_color = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldSecondaryForegroundColor)
}

// SetEnvironment sets the "environment" field.
func (m *TrustCenterSettingHistoryMutation) SetEnvironment(ece enums.TrustCenterEnvironment) {
	m.environment = &ece
}

// Environment returns the value of the "environment" field in the mutation.
func (m *TrustCenterSettingHistoryMutation) Environment() (r enums.TrustCenterEnvironment, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironment returns the old "environment" field's value of the TrustCenterSettingHistory entity.
// If the TrustCenterSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSettingHistoryMutation) OldEnvironment(ctx context.Context) (v enums.TrustCenterEnvironment, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironment: %w", err)
	}
	return oldValue.Environment, nil
}

// ClearEnvironment clears the value of the "environment" field.
func (m *TrustCenterSettingHistoryMutation) ClearEnvironment() {
	m.environment = nil
	m.clearedFields[trustcentersettinghistory.FieldEnvironment] = struct{}{}
}

// EnvironmentCleared returns if the "environment" field was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) EnvironmentCleared() bool {
	_, ok := m.clearedFields[trustcentersettinghistory.FieldEnvironment]
	return ok
}

// ResetEnvironment resets all changes to the "environment" field.
func (m *TrustCenterSettingHistoryMutation) ResetEnvironment() {
	m.environment = nil
	delete(m.clearedFields, trustcentersettinghistory.FieldEnvironment)
}

// Where appends a list predicates to the TrustCenterSettingHistoryMutation builder.
func (m *TrustCenterSettingHistoryMutation) Where(ps ...predicate.TrustCenterSettingHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TrustCenterSettingHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TrustCenterSettingHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TrustCenterSettingHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TrustCenterSettingHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TrustCenterSettingHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TrustCenterSettingHistory).
func (m *TrustCenterSettingHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrustCenterSettingHistoryMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.history_time != nil {
		fields = append(fields, trustcentersettinghistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, trustcentersettinghistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, trustcentersettinghistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, trustcentersettinghistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trustcentersettinghistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, trustcentersettinghistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, trustcentersettinghistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, trustcentersettinghistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, trustcentersettinghistory.FieldDeletedBy)
	}
	if m.trust_center_id != nil {
		fields = append(fields, trustcentersettinghistory.FieldTrustCenterID)
	}
	if m.title != nil {
		fields = append(fields, trustcentersettinghistory.FieldTitle)
	}
	if m.overview != nil {
		fields = append(fields, trustcentersettinghistory.FieldOverview)
	}
	if m.logo_remote_url != nil {
		fields = append(fields, trustcentersettinghistory.FieldLogoRemoteURL)
	}
	if m.logo_local_file_id != nil {
		fields = append(fields, trustcentersettinghistory.FieldLogoLocalFileID)
	}
	if m.favicon_remote_url != nil {
		fields = append(fields, trustcentersettinghistory.FieldFaviconRemoteURL)
	}
	if m.favicon_local_file_id != nil {
		fields = append(fields, trustcentersettinghistory.FieldFaviconLocalFileID)
	}
	if m.theme_mode != nil {
		fields = append(fields, trustcentersettinghistory.FieldThemeMode)
	}
	if m.primary_color != nil {
		fields = append(fields, trustcentersettinghistory.FieldPrimaryColor)
	}
	if m.font != nil {
		fields = append(fields, trustcentersettinghistory.FieldFont)
	}
	if m.foreground_color != nil {
		fields = append(fields, trustcentersettinghistory.FieldForegroundColor)
	}
	if m.background_color != nil {
		fields = append(fields, trustcentersettinghistory.FieldBackgroundColor)
	}
	if m.accent_color != nil {
		fields = append(fields, trustcentersettinghistory.FieldAccentColor)
	}
	if m.secondary_background_color != nil {
		fields = append(fields, trustcentersettinghistory.FieldSecondaryBackgroundColor)
	}
	if m.secondary_foreground_color != nil {
		fields = append(fields, trustcentersettinghistory.FieldSecondaryForegroundColor)
	}
	if m.environment != nil {
		fields = append(fields, trustcentersettinghistory.FieldEnvironment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrustCenterSettingHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trustcentersettinghistory.FieldHistoryTime:
		return m.HistoryTime()
	case trustcentersettinghistory.FieldRef:
		return m.Ref()
	case trustcentersettinghistory.FieldOperation:
		return m.Operation()
	case trustcentersettinghistory.FieldCreatedAt:
		return m.CreatedAt()
	case trustcentersettinghistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case trustcentersettinghistory.FieldCreatedBy:
		return m.CreatedBy()
	case trustcentersettinghistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case trustcentersettinghistory.FieldDeletedAt:
		return m.DeletedAt()
	case trustcentersettinghistory.FieldDeletedBy:
		return m.DeletedBy()
	case trustcentersettinghistory.FieldTrustCenterID:
		return m.TrustCenterID()
	case trustcentersettinghistory.FieldTitle:
		return m.Title()
	case trustcentersettinghistory.FieldOverview:
		return m.Overview()
	case trustcentersettinghistory.FieldLogoRemoteURL:
		return m.LogoRemoteURL()
	case trustcentersettinghistory.FieldLogoLocalFileID:
		return m.LogoLocalFileID()
	case trustcentersettinghistory.FieldFaviconRemoteURL:
		return m.FaviconRemoteURL()
	case trustcentersettinghistory.FieldFaviconLocalFileID:
		return m.FaviconLocalFileID()
	case trustcentersettinghistory.FieldThemeMode:
		return m.ThemeMode()
	case trustcentersettinghistory.FieldPrimaryColor:
		return m.PrimaryColor()
	case trustcentersettinghistory.FieldFont:
		return m.Font()
	case trustcentersettinghistory.FieldForegroundColor:
		return m.ForegroundColor()
	case trustcentersettinghistory.FieldBackgroundColor:
		return m.BackgroundColor()
	case trustcentersettinghistory.FieldAccentColor:
		return m.AccentColor()
	case trustcentersettinghistory.FieldSecondaryBackgroundColor:
		return m.SecondaryBackgroundColor()
	case trustcentersettinghistory.FieldSecondaryForegroundColor:
		return m.SecondaryForegroundColor()
	case trustcentersettinghistory.FieldEnvironment:
		return m.Environment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrustCenterSettingHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trustcentersettinghistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case trustcentersettinghistory.FieldRef:
		return m.OldRef(ctx)
	case trustcentersettinghistory.FieldOperation:
		return m.OldOperation(ctx)
	case trustcentersettinghistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trustcentersettinghistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trustcentersettinghistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case trustcentersettinghistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case trustcentersettinghistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case trustcentersettinghistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case trustcentersettinghistory.FieldTrustCenterID:
		return m.OldTrustCenterID(ctx)
	case trustcentersettinghistory.FieldTitle:
		return m.OldTitle(ctx)
	case trustcentersettinghistory.FieldOverview:
		return m.OldOverview(ctx)
	case trustcentersettinghistory.FieldLogoRemoteURL:
		return m.OldLogoRemoteURL(ctx)
	case trustcentersettinghistory.FieldLogoLocalFileID:
		return m.OldLogoLocalFileID(ctx)
	case trustcentersettinghistory.FieldFaviconRemoteURL:
		return m.OldFaviconRemoteURL(ctx)
	case trustcentersettinghistory.FieldFaviconLocalFileID:
		return m.OldFaviconLocalFileID(ctx)
	case trustcentersettinghistory.FieldThemeMode:
		return m.OldThemeMode(ctx)
	case trustcentersettinghistory.FieldPrimaryColor:
		return m.OldPrimaryColor(ctx)
	case trustcentersettinghistory.FieldFont:
		return m.OldFont(ctx)
	case trustcentersettinghistory.FieldForegroundColor:
		return m.OldForegroundColor(ctx)
	case trustcentersettinghistory.FieldBackgroundColor:
		return m.OldBackgroundColor(ctx)
	case trustcentersettinghistory.FieldAccentColor:
		return m.OldAccentColor(ctx)
	case trustcentersettinghistory.FieldSecondaryBackgroundColor:
		return m.OldSecondaryBackgroundColor(ctx)
	case trustcentersettinghistory.FieldSecondaryForegroundColor:
		return m.OldSecondaryForegroundColor(ctx)
	case trustcentersettinghistory.FieldEnvironment:
		return m.OldEnvironment(ctx)
	}
	return nil, fmt.Errorf("unknown TrustCenterSettingHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustCenterSettingHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trustcentersettinghistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case trustcentersettinghistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case trustcentersettinghistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case trustcentersettinghistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trustcentersettinghistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trustcentersettinghistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case trustcentersettinghistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case trustcentersettinghistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case trustcentersettinghistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case trustcentersettinghistory.FieldTrustCenterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrustCenterID(v)
		return nil
	case trustcentersettinghistory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case trustcentersettinghistory.FieldOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverview(v)
		return nil
	case trustcentersettinghistory.FieldLogoRemoteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoRemoteURL(v)
		return nil
	case trustcentersettinghistory.FieldLogoLocalFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoLocalFileID(v)
		return nil
	case trustcentersettinghistory.FieldFaviconRemoteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaviconRemoteURL(v)
		return nil
	case trustcentersettinghistory.FieldFaviconLocalFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaviconLocalFileID(v)
		return nil
	case trustcentersettinghistory.FieldThemeMode:
		v, ok := value.(enums.TrustCenterThemeMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThemeMode(v)
		return nil
	case trustcentersettinghistory.FieldPrimaryColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryColor(v)
		return nil
	case trustcentersettinghistory.FieldFont:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFont(v)
		return nil
	case trustcentersettinghistory.FieldForegroundColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForegroundColor(v)
		return nil
	case trustcentersettinghistory.FieldBackgroundColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundColor(v)
		return nil
	case trustcentersettinghistory.FieldAccentColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccentColor(v)
		return nil
	case trustcentersettinghistory.FieldSecondaryBackgroundColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondaryBackgroundColor(v)
		return nil
	case trustcentersettinghistory.FieldSecondaryForegroundColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondaryForegroundColor(v)
		return nil
	case trustcentersettinghistory.FieldEnvironment:
		v, ok := value.(enums.TrustCenterEnvironment)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironment(v)
		return nil
	}
	return fmt.Errorf("unknown TrustCenterSettingHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrustCenterSettingHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrustCenterSettingHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustCenterSettingHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TrustCenterSettingHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrustCenterSettingHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trustcentersettinghistory.FieldRef) {
		fields = append(fields, trustcentersettinghistory.FieldRef)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldCreatedAt) {
		fields = append(fields, trustcentersettinghistory.FieldCreatedAt)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldUpdatedAt) {
		fields = append(fields, trustcentersettinghistory.FieldUpdatedAt)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldCreatedBy) {
		fields = append(fields, trustcentersettinghistory.FieldCreatedBy)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldUpdatedBy) {
		fields = append(fields, trustcentersettinghistory.FieldUpdatedBy)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldDeletedAt) {
		fields = append(fields, trustcentersettinghistory.FieldDeletedAt)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldDeletedBy) {
		fields = append(fields, trustcentersettinghistory.FieldDeletedBy)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldTrustCenterID) {
		fields = append(fields, trustcentersettinghistory.FieldTrustCenterID)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldTitle) {
		fields = append(fields, trustcentersettinghistory.FieldTitle)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldOverview) {
		fields = append(fields, trustcentersettinghistory.FieldOverview)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldLogoRemoteURL) {
		fields = append(fields, trustcentersettinghistory.FieldLogoRemoteURL)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldLogoLocalFileID) {
		fields = append(fields, trustcentersettinghistory.FieldLogoLocalFileID)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldFaviconRemoteURL) {
		fields = append(fields, trustcentersettinghistory.FieldFaviconRemoteURL)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldFaviconLocalFileID) {
		fields = append(fields, trustcentersettinghistory.FieldFaviconLocalFileID)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldThemeMode) {
		fields = append(fields, trustcentersettinghistory.FieldThemeMode)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldPrimaryColor) {
		fields = append(fields, trustcentersettinghistory.FieldPrimaryColor)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldFont) {
		fields = append(fields, trustcentersettinghistory.FieldFont)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldForegroundColor) {
		fields = append(fields, trustcentersettinghistory.FieldForegroundColor)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldBackgroundColor) {
		fields = append(fields, trustcentersettinghistory.FieldBackgroundColor)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldAccentColor) {
		fields = append(fields, trustcentersettinghistory.FieldAccentColor)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldSecondaryBackgroundColor) {
		fields = append(fields, trustcentersettinghistory.FieldSecondaryBackgroundColor)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldSecondaryForegroundColor) {
		fields = append(fields, trustcentersettinghistory.FieldSecondaryForegroundColor)
	}
	if m.FieldCleared(trustcentersettinghistory.FieldEnvironment) {
		fields = append(fields, trustcentersettinghistory.FieldEnvironment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrustCenterSettingHistoryMutation) ClearField(name string) error {
	switch name {
	case trustcentersettinghistory.FieldRef:
		m.ClearRef()
		return nil
	case trustcentersettinghistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case trustcentersettinghistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case trustcentersettinghistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case trustcentersettinghistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case trustcentersettinghistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case trustcentersettinghistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case trustcentersettinghistory.FieldTrustCenterID:
		m.ClearTrustCenterID()
		return nil
	case trustcentersettinghistory.FieldTitle:
		m.ClearTitle()
		return nil
	case trustcentersettinghistory.FieldOverview:
		m.ClearOverview()
		return nil
	case trustcentersettinghistory.FieldLogoRemoteURL:
		m.ClearLogoRemoteURL()
		return nil
	case trustcentersettinghistory.FieldLogoLocalFileID:
		m.ClearLogoLocalFileID()
		return nil
	case trustcentersettinghistory.FieldFaviconRemoteURL:
		m.ClearFaviconRemoteURL()
		return nil
	case trustcentersettinghistory.FieldFaviconLocalFileID:
		m.ClearFaviconLocalFileID()
		return nil
	case trustcentersettinghistory.FieldThemeMode:
		m.ClearThemeMode()
		return nil
	case trustcentersettinghistory.FieldPrimaryColor:
		m.ClearPrimaryColor()
		return nil
	case trustcentersettinghistory.FieldFont:
		m.ClearFont()
		return nil
	case trustcentersettinghistory.FieldForegroundColor:
		m.ClearForegroundColor()
		return nil
	case trustcentersettinghistory.FieldBackgroundColor:
		m.ClearBackgroundColor()
		return nil
	case trustcentersettinghistory.FieldAccentColor:
		m.ClearAccentColor()
		return nil
	case trustcentersettinghistory.FieldSecondaryBackgroundColor:
		m.ClearSecondaryBackgroundColor()
		return nil
	case trustcentersettinghistory.FieldSecondaryForegroundColor:
		m.ClearSecondaryForegroundColor()
		return nil
	case trustcentersettinghistory.FieldEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown TrustCenterSettingHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrustCenterSettingHistoryMutation) ResetField(name string) error {
	switch name {
	case trustcentersettinghistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case trustcentersettinghistory.FieldRef:
		m.ResetRef()
		return nil
	case trustcentersettinghistory.FieldOperation:
		m.ResetOperation()
		return nil
	case trustcentersettinghistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trustcentersettinghistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trustcentersettinghistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case trustcentersettinghistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case trustcentersettinghistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case trustcentersettinghistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case trustcentersettinghistory.FieldTrustCenterID:
		m.ResetTrustCenterID()
		return nil
	case trustcentersettinghistory.FieldTitle:
		m.ResetTitle()
		return nil
	case trustcentersettinghistory.FieldOverview:
		m.ResetOverview()
		return nil
	case trustcentersettinghistory.FieldLogoRemoteURL:
		m.ResetLogoRemoteURL()
		return nil
	case trustcentersettinghistory.FieldLogoLocalFileID:
		m.ResetLogoLocalFileID()
		return nil
	case trustcentersettinghistory.FieldFaviconRemoteURL:
		m.ResetFaviconRemoteURL()
		return nil
	case trustcentersettinghistory.FieldFaviconLocalFileID:
		m.ResetFaviconLocalFileID()
		return nil
	case trustcentersettinghistory.FieldThemeMode:
		m.ResetThemeMode()
		return nil
	case trustcentersettinghistory.FieldPrimaryColor:
		m.ResetPrimaryColor()
		return nil
	case trustcentersettinghistory.FieldFont:
		m.ResetFont()
		return nil
	case trustcentersettinghistory.FieldForegroundColor:
		m.ResetForegroundColor()
		return nil
	case trustcentersettinghistory.FieldBackgroundColor:
		m.ResetBackgroundColor()
		return nil
	case trustcentersettinghistory.FieldAccentColor:
		m.ResetAccentColor()
		return nil
	case trustcentersettinghistory.FieldSecondaryBackgroundColor:
		m.ResetSecondaryBackgroundColor()
		return nil
	case trustcentersettinghistory.FieldSecondaryForegroundColor:
		m.ResetSecondaryForegroundColor()
		return nil
	case trustcentersettinghistory.FieldEnvironment:
		m.ResetEnvironment()
		return nil
	}
	return fmt.Errorf("unknown TrustCenterSettingHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrustCenterSettingHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrustCenterSettingHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrustCenterSettingHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrustCenterSettingHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrustCenterSettingHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrustCenterSettingHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TrustCenterSettingHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrustCenterSettingHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TrustCenterSettingHistory edge %s", name)
}

// TrustCenterSubprocessorHistoryMutation represents an operation that mutates the TrustCenterSubprocessorHistory nodes in the graph.
type TrustCenterSubprocessorHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *string
	history_time    *time.Time
	ref             *string
	operation       *history.OpType
	created_at      *time.Time
	updated_at      *time.Time
	created_by      *string
	updated_by      *string
	deleted_at      *time.Time
	deleted_by      *string
	subprocessor_id *string
	trust_center_id *string
	countries       *[]string
	appendcountries []string
	category        *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*TrustCenterSubprocessorHistory, error)
	predicates      []predicate.TrustCenterSubprocessorHistory
}

var _ ent.Mutation = (*TrustCenterSubprocessorHistoryMutation)(nil)

// trustcentersubprocessorhistoryOption allows management of the mutation configuration using functional options.
type trustcentersubprocessorhistoryOption func(*TrustCenterSubprocessorHistoryMutation)

// newTrustCenterSubprocessorHistoryMutation creates new mutation for the TrustCenterSubprocessorHistory entity.
func newTrustCenterSubprocessorHistoryMutation(c config, op Op, opts ...trustcentersubprocessorhistoryOption) *TrustCenterSubprocessorHistoryMutation {
	m := &TrustCenterSubprocessorHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTrustCenterSubprocessorHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrustCenterSubprocessorHistoryID sets the ID field of the mutation.
func withTrustCenterSubprocessorHistoryID(id string) trustcentersubprocessorhistoryOption {
	return func(m *TrustCenterSubprocessorHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TrustCenterSubprocessorHistory
		)
		m.oldValue = func(ctx context.Context) (*TrustCenterSubprocessorHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TrustCenterSubprocessorHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrustCenterSubprocessorHistory sets the old TrustCenterSubprocessorHistory of the mutation.
func withTrustCenterSubprocessorHistory(node *TrustCenterSubprocessorHistory) trustcentersubprocessorhistoryOption {
	return func(m *TrustCenterSubprocessorHistoryMutation) {
		m.oldValue = func(context.Context) (*TrustCenterSubprocessorHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrustCenterSubprocessorHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrustCenterSubprocessorHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TrustCenterSubprocessorHistory entities.
func (m *TrustCenterSubprocessorHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrustCenterSubprocessorHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrustCenterSubprocessorHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TrustCenterSubprocessorHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *TrustCenterSubprocessorHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *TrustCenterSubprocessorHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the TrustCenterSubprocessorHistory entity.
// If the TrustCenterSubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSubprocessorHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *TrustCenterSubprocessorHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *TrustCenterSubprocessorHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *TrustCenterSubprocessorHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the TrustCenterSubprocessorHistory entity.
// If the TrustCenterSubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSubprocessorHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *TrustCenterSubprocessorHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[trustcentersubprocessorhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[trustcentersubprocessorhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *TrustCenterSubprocessorHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, trustcentersubprocessorhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *TrustCenterSubprocessorHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *TrustCenterSubprocessorHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the TrustCenterSubprocessorHistory entity.
// If the TrustCenterSubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSubprocessorHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *TrustCenterSubprocessorHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TrustCenterSubprocessorHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrustCenterSubprocessorHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TrustCenterSubprocessorHistory entity.
// If the TrustCenterSubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSubprocessorHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TrustCenterSubprocessorHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[trustcentersubprocessorhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[trustcentersubprocessorhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrustCenterSubprocessorHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, trustcentersubprocessorhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TrustCenterSubprocessorHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TrustCenterSubprocessorHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TrustCenterSubprocessorHistory entity.
// If the TrustCenterSubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSubprocessorHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TrustCenterSubprocessorHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[trustcentersubprocessorhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[trustcentersubprocessorhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TrustCenterSubprocessorHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, trustcentersubprocessorhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TrustCenterSubprocessorHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TrustCenterSubprocessorHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TrustCenterSubprocessorHistory entity.
// If the TrustCenterSubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSubprocessorHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TrustCenterSubprocessorHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[trustcentersubprocessorhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[trustcentersubprocessorhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TrustCenterSubprocessorHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, trustcentersubprocessorhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TrustCenterSubprocessorHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TrustCenterSubprocessorHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TrustCenterSubprocessorHistory entity.
// If the TrustCenterSubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSubprocessorHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TrustCenterSubprocessorHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[trustcentersubprocessorhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[trustcentersubprocessorhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TrustCenterSubprocessorHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, trustcentersubprocessorhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TrustCenterSubprocessorHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TrustCenterSubprocessorHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TrustCenterSubprocessorHistory entity.
// If the TrustCenterSubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSubprocessorHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TrustCenterSubprocessorHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[trustcentersubprocessorhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[trustcentersubprocessorhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TrustCenterSubprocessorHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, trustcentersubprocessorhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TrustCenterSubprocessorHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TrustCenterSubprocessorHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TrustCenterSubprocessorHistory entity.
// If the TrustCenterSubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSubprocessorHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TrustCenterSubprocessorHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[trustcentersubprocessorhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[trustcentersubprocessorhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TrustCenterSubprocessorHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, trustcentersubprocessorhistory.FieldDeletedBy)
}

// SetSubprocessorID sets the "subprocessor_id" field.
func (m *TrustCenterSubprocessorHistoryMutation) SetSubprocessorID(s string) {
	m.subprocessor_id = &s
}

// SubprocessorID returns the value of the "subprocessor_id" field in the mutation.
func (m *TrustCenterSubprocessorHistoryMutation) SubprocessorID() (r string, exists bool) {
	v := m.subprocessor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSubprocessorID returns the old "subprocessor_id" field's value of the TrustCenterSubprocessorHistory entity.
// If the TrustCenterSubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSubprocessorHistoryMutation) OldSubprocessorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubprocessorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubprocessorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubprocessorID: %w", err)
	}
	return oldValue.SubprocessorID, nil
}

// ResetSubprocessorID resets all changes to the "subprocessor_id" field.
func (m *TrustCenterSubprocessorHistoryMutation) ResetSubprocessorID() {
	m.subprocessor_id = nil
}

// SetTrustCenterID sets the "trust_center_id" field.
func (m *TrustCenterSubprocessorHistoryMutation) SetTrustCenterID(s string) {
	m.trust_center_id = &s
}

// TrustCenterID returns the value of the "trust_center_id" field in the mutation.
func (m *TrustCenterSubprocessorHistoryMutation) TrustCenterID() (r string, exists bool) {
	v := m.trust_center_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTrustCenterID returns the old "trust_center_id" field's value of the TrustCenterSubprocessorHistory entity.
// If the TrustCenterSubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSubprocessorHistoryMutation) OldTrustCenterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrustCenterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrustCenterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrustCenterID: %w", err)
	}
	return oldValue.TrustCenterID, nil
}

// ClearTrustCenterID clears the value of the "trust_center_id" field.
func (m *TrustCenterSubprocessorHistoryMutation) ClearTrustCenterID() {
	m.trust_center_id = nil
	m.clearedFields[trustcentersubprocessorhistory.FieldTrustCenterID] = struct{}{}
}

// TrustCenterIDCleared returns if the "trust_center_id" field was cleared in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) TrustCenterIDCleared() bool {
	_, ok := m.clearedFields[trustcentersubprocessorhistory.FieldTrustCenterID]
	return ok
}

// ResetTrustCenterID resets all changes to the "trust_center_id" field.
func (m *TrustCenterSubprocessorHistoryMutation) ResetTrustCenterID() {
	m.trust_center_id = nil
	delete(m.clearedFields, trustcentersubprocessorhistory.FieldTrustCenterID)
}

// SetCountries sets the "countries" field.
func (m *TrustCenterSubprocessorHistoryMutation) SetCountries(s []string) {
	m.countries = &s
	m.appendcountries = nil
}

// Countries returns the value of the "countries" field in the mutation.
func (m *TrustCenterSubprocessorHistoryMutation) Countries() (r []string, exists bool) {
	v := m.countries
	if v == nil {
		return
	}
	return *v, true
}

// OldCountries returns the old "countries" field's value of the TrustCenterSubprocessorHistory entity.
// If the TrustCenterSubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSubprocessorHistoryMutation) OldCountries(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountries: %w", err)
	}
	return oldValue.Countries, nil
}

// AppendCountries adds s to the "countries" field.
func (m *TrustCenterSubprocessorHistoryMutation) AppendCountries(s []string) {
	m.appendcountries = append(m.appendcountries, s...)
}

// AppendedCountries returns the list of values that were appended to the "countries" field in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) AppendedCountries() ([]string, bool) {
	if len(m.appendcountries) == 0 {
		return nil, false
	}
	return m.appendcountries, true
}

// ClearCountries clears the value of the "countries" field.
func (m *TrustCenterSubprocessorHistoryMutation) ClearCountries() {
	m.countries = nil
	m.appendcountries = nil
	m.clearedFields[trustcentersubprocessorhistory.FieldCountries] = struct{}{}
}

// CountriesCleared returns if the "countries" field was cleared in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) CountriesCleared() bool {
	_, ok := m.clearedFields[trustcentersubprocessorhistory.FieldCountries]
	return ok
}

// ResetCountries resets all changes to the "countries" field.
func (m *TrustCenterSubprocessorHistoryMutation) ResetCountries() {
	m.countries = nil
	m.appendcountries = nil
	delete(m.clearedFields, trustcentersubprocessorhistory.FieldCountries)
}

// SetCategory sets the "category" field.
func (m *TrustCenterSubprocessorHistoryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *TrustCenterSubprocessorHistoryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the TrustCenterSubprocessorHistory entity.
// If the TrustCenterSubprocessorHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterSubprocessorHistoryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *TrustCenterSubprocessorHistoryMutation) ResetCategory() {
	m.category = nil
}

// Where appends a list predicates to the TrustCenterSubprocessorHistoryMutation builder.
func (m *TrustCenterSubprocessorHistoryMutation) Where(ps ...predicate.TrustCenterSubprocessorHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TrustCenterSubprocessorHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TrustCenterSubprocessorHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TrustCenterSubprocessorHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TrustCenterSubprocessorHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TrustCenterSubprocessorHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TrustCenterSubprocessorHistory).
func (m *TrustCenterSubprocessorHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrustCenterSubprocessorHistoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.history_time != nil {
		fields = append(fields, trustcentersubprocessorhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, trustcentersubprocessorhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, trustcentersubprocessorhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, trustcentersubprocessorhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trustcentersubprocessorhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, trustcentersubprocessorhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, trustcentersubprocessorhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, trustcentersubprocessorhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, trustcentersubprocessorhistory.FieldDeletedBy)
	}
	if m.subprocessor_id != nil {
		fields = append(fields, trustcentersubprocessorhistory.FieldSubprocessorID)
	}
	if m.trust_center_id != nil {
		fields = append(fields, trustcentersubprocessorhistory.FieldTrustCenterID)
	}
	if m.countries != nil {
		fields = append(fields, trustcentersubprocessorhistory.FieldCountries)
	}
	if m.category != nil {
		fields = append(fields, trustcentersubprocessorhistory.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrustCenterSubprocessorHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trustcentersubprocessorhistory.FieldHistoryTime:
		return m.HistoryTime()
	case trustcentersubprocessorhistory.FieldRef:
		return m.Ref()
	case trustcentersubprocessorhistory.FieldOperation:
		return m.Operation()
	case trustcentersubprocessorhistory.FieldCreatedAt:
		return m.CreatedAt()
	case trustcentersubprocessorhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case trustcentersubprocessorhistory.FieldCreatedBy:
		return m.CreatedBy()
	case trustcentersubprocessorhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case trustcentersubprocessorhistory.FieldDeletedAt:
		return m.DeletedAt()
	case trustcentersubprocessorhistory.FieldDeletedBy:
		return m.DeletedBy()
	case trustcentersubprocessorhistory.FieldSubprocessorID:
		return m.SubprocessorID()
	case trustcentersubprocessorhistory.FieldTrustCenterID:
		return m.TrustCenterID()
	case trustcentersubprocessorhistory.FieldCountries:
		return m.Countries()
	case trustcentersubprocessorhistory.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrustCenterSubprocessorHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trustcentersubprocessorhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case trustcentersubprocessorhistory.FieldRef:
		return m.OldRef(ctx)
	case trustcentersubprocessorhistory.FieldOperation:
		return m.OldOperation(ctx)
	case trustcentersubprocessorhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trustcentersubprocessorhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trustcentersubprocessorhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case trustcentersubprocessorhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case trustcentersubprocessorhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case trustcentersubprocessorhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case trustcentersubprocessorhistory.FieldSubprocessorID:
		return m.OldSubprocessorID(ctx)
	case trustcentersubprocessorhistory.FieldTrustCenterID:
		return m.OldTrustCenterID(ctx)
	case trustcentersubprocessorhistory.FieldCountries:
		return m.OldCountries(ctx)
	case trustcentersubprocessorhistory.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown TrustCenterSubprocessorHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustCenterSubprocessorHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trustcentersubprocessorhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case trustcentersubprocessorhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case trustcentersubprocessorhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case trustcentersubprocessorhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trustcentersubprocessorhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trustcentersubprocessorhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case trustcentersubprocessorhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case trustcentersubprocessorhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case trustcentersubprocessorhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case trustcentersubprocessorhistory.FieldSubprocessorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubprocessorID(v)
		return nil
	case trustcentersubprocessorhistory.FieldTrustCenterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrustCenterID(v)
		return nil
	case trustcentersubprocessorhistory.FieldCountries:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountries(v)
		return nil
	case trustcentersubprocessorhistory.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown TrustCenterSubprocessorHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrustCenterSubprocessorHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustCenterSubprocessorHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TrustCenterSubprocessorHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrustCenterSubprocessorHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trustcentersubprocessorhistory.FieldRef) {
		fields = append(fields, trustcentersubprocessorhistory.FieldRef)
	}
	if m.FieldCleared(trustcentersubprocessorhistory.FieldCreatedAt) {
		fields = append(fields, trustcentersubprocessorhistory.FieldCreatedAt)
	}
	if m.FieldCleared(trustcentersubprocessorhistory.FieldUpdatedAt) {
		fields = append(fields, trustcentersubprocessorhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(trustcentersubprocessorhistory.FieldCreatedBy) {
		fields = append(fields, trustcentersubprocessorhistory.FieldCreatedBy)
	}
	if m.FieldCleared(trustcentersubprocessorhistory.FieldUpdatedBy) {
		fields = append(fields, trustcentersubprocessorhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(trustcentersubprocessorhistory.FieldDeletedAt) {
		fields = append(fields, trustcentersubprocessorhistory.FieldDeletedAt)
	}
	if m.FieldCleared(trustcentersubprocessorhistory.FieldDeletedBy) {
		fields = append(fields, trustcentersubprocessorhistory.FieldDeletedBy)
	}
	if m.FieldCleared(trustcentersubprocessorhistory.FieldTrustCenterID) {
		fields = append(fields, trustcentersubprocessorhistory.FieldTrustCenterID)
	}
	if m.FieldCleared(trustcentersubprocessorhistory.FieldCountries) {
		fields = append(fields, trustcentersubprocessorhistory.FieldCountries)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrustCenterSubprocessorHistoryMutation) ClearField(name string) error {
	switch name {
	case trustcentersubprocessorhistory.FieldRef:
		m.ClearRef()
		return nil
	case trustcentersubprocessorhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case trustcentersubprocessorhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case trustcentersubprocessorhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case trustcentersubprocessorhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case trustcentersubprocessorhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case trustcentersubprocessorhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case trustcentersubprocessorhistory.FieldTrustCenterID:
		m.ClearTrustCenterID()
		return nil
	case trustcentersubprocessorhistory.FieldCountries:
		m.ClearCountries()
		return nil
	}
	return fmt.Errorf("unknown TrustCenterSubprocessorHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrustCenterSubprocessorHistoryMutation) ResetField(name string) error {
	switch name {
	case trustcentersubprocessorhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case trustcentersubprocessorhistory.FieldRef:
		m.ResetRef()
		return nil
	case trustcentersubprocessorhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case trustcentersubprocessorhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trustcentersubprocessorhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trustcentersubprocessorhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case trustcentersubprocessorhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case trustcentersubprocessorhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case trustcentersubprocessorhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case trustcentersubprocessorhistory.FieldSubprocessorID:
		m.ResetSubprocessorID()
		return nil
	case trustcentersubprocessorhistory.FieldTrustCenterID:
		m.ResetTrustCenterID()
		return nil
	case trustcentersubprocessorhistory.FieldCountries:
		m.ResetCountries()
		return nil
	case trustcentersubprocessorhistory.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown TrustCenterSubprocessorHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrustCenterSubprocessorHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrustCenterSubprocessorHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TrustCenterSubprocessorHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrustCenterSubprocessorHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TrustCenterSubprocessorHistory edge %s", name)
}

// TrustCenterWatermarkConfigHistoryMutation represents an operation that mutates the TrustCenterWatermarkConfigHistory nodes in the graph.
type TrustCenterWatermarkConfigHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *string
	history_time    *time.Time
	ref             *string
	operation       *history.OpType
	created_at      *time.Time
	updated_at      *time.Time
	created_by      *string
	updated_by      *string
	deleted_at      *time.Time
	deleted_by      *string
	owner_id        *string
	trust_center_id *string
	is_enabled      *bool
	logo_id         *string
	text            *string
	font_size       *float64
	addfont_size    *float64
	opacity         *float64
	addopacity      *float64
	rotation        *float64
	addrotation     *float64
	color           *string
	font            *enums.Font
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*TrustCenterWatermarkConfigHistory, error)
	predicates      []predicate.TrustCenterWatermarkConfigHistory
}

var _ ent.Mutation = (*TrustCenterWatermarkConfigHistoryMutation)(nil)

// trustcenterwatermarkconfighistoryOption allows management of the mutation configuration using functional options.
type trustcenterwatermarkconfighistoryOption func(*TrustCenterWatermarkConfigHistoryMutation)

// newTrustCenterWatermarkConfigHistoryMutation creates new mutation for the TrustCenterWatermarkConfigHistory entity.
func newTrustCenterWatermarkConfigHistoryMutation(c config, op Op, opts ...trustcenterwatermarkconfighistoryOption) *TrustCenterWatermarkConfigHistoryMutation {
	m := &TrustCenterWatermarkConfigHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTrustCenterWatermarkConfigHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrustCenterWatermarkConfigHistoryID sets the ID field of the mutation.
func withTrustCenterWatermarkConfigHistoryID(id string) trustcenterwatermarkconfighistoryOption {
	return func(m *TrustCenterWatermarkConfigHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TrustCenterWatermarkConfigHistory
		)
		m.oldValue = func(ctx context.Context) (*TrustCenterWatermarkConfigHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TrustCenterWatermarkConfigHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrustCenterWatermarkConfigHistory sets the old TrustCenterWatermarkConfigHistory of the mutation.
func withTrustCenterWatermarkConfigHistory(node *TrustCenterWatermarkConfigHistory) trustcenterwatermarkconfighistoryOption {
	return func(m *TrustCenterWatermarkConfigHistoryMutation) {
		m.oldValue = func(context.Context) (*TrustCenterWatermarkConfigHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrustCenterWatermarkConfigHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrustCenterWatermarkConfigHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TrustCenterWatermarkConfigHistory entities.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrustCenterWatermarkConfigHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TrustCenterWatermarkConfigHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldOwnerID)
}

// SetTrustCenterID sets the "trust_center_id" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetTrustCenterID(s string) {
	m.trust_center_id = &s
}

// TrustCenterID returns the value of the "trust_center_id" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) TrustCenterID() (r string, exists bool) {
	v := m.trust_center_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTrustCenterID returns the old "trust_center_id" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldTrustCenterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrustCenterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrustCenterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrustCenterID: %w", err)
	}
	return oldValue.TrustCenterID, nil
}

// ClearTrustCenterID clears the value of the "trust_center_id" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearTrustCenterID() {
	m.trust_center_id = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldTrustCenterID] = struct{}{}
}

// TrustCenterIDCleared returns if the "trust_center_id" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) TrustCenterIDCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldTrustCenterID]
	return ok
}

// ResetTrustCenterID resets all changes to the "trust_center_id" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetTrustCenterID() {
	m.trust_center_id = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldTrustCenterID)
}

// SetIsEnabled sets the "is_enabled" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetIsEnabled(b bool) {
	m.is_enabled = &b
}

// IsEnabled returns the value of the "is_enabled" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) IsEnabled() (r bool, exists bool) {
	v := m.is_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnabled returns the old "is_enabled" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldIsEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnabled: %w", err)
	}
	return oldValue.IsEnabled, nil
}

// ClearIsEnabled clears the value of the "is_enabled" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearIsEnabled() {
	m.is_enabled = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldIsEnabled] = struct{}{}
}

// IsEnabledCleared returns if the "is_enabled" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) IsEnabledCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldIsEnabled]
	return ok
}

// ResetIsEnabled resets all changes to the "is_enabled" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetIsEnabled() {
	m.is_enabled = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldIsEnabled)
}

// SetLogoID sets the "logo_id" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetLogoID(s string) {
	m.logo_id = &s
}

// LogoID returns the value of the "logo_id" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) LogoID() (r string, exists bool) {
	v := m.logo_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoID returns the old "logo_id" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldLogoID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoID: %w", err)
	}
	return oldValue.LogoID, nil
}

// ClearLogoID clears the value of the "logo_id" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearLogoID() {
	m.logo_id = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldLogoID] = struct{}{}
}

// LogoIDCleared returns if the "logo_id" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) LogoIDCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldLogoID]
	return ok
}

// ResetLogoID resets all changes to the "logo_id" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetLogoID() {
	m.logo_id = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldLogoID)
}

// SetText sets the "text" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ClearText clears the value of the "text" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearText() {
	m.text = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldText] = struct{}{}
}

// TextCleared returns if the "text" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) TextCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldText]
	return ok
}

// ResetText resets all changes to the "text" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetText() {
	m.text = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldText)
}

// SetFontSize sets the "font_size" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetFontSize(f float64) {
	m.font_size = &f
	m.addfont_size = nil
}

// FontSize returns the value of the "font_size" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) FontSize() (r float64, exists bool) {
	v := m.font_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFontSize returns the old "font_size" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldFontSize(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFontSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFontSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFontSize: %w", err)
	}
	return oldValue.FontSize, nil
}

// AddFontSize adds f to the "font_size" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) AddFontSize(f float64) {
	if m.addfont_size != nil {
		*m.addfont_size += f
	} else {
		m.addfont_size = &f
	}
}

// AddedFontSize returns the value that was added to the "font_size" field in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) AddedFontSize() (r float64, exists bool) {
	v := m.addfont_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearFontSize clears the value of the "font_size" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearFontSize() {
	m.font_size = nil
	m.addfont_size = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldFontSize] = struct{}{}
}

// FontSizeCleared returns if the "font_size" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) FontSizeCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldFontSize]
	return ok
}

// ResetFontSize resets all changes to the "font_size" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetFontSize() {
	m.font_size = nil
	m.addfont_size = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldFontSize)
}

// SetOpacity sets the "opacity" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetOpacity(f float64) {
	m.opacity = &f
	m.addopacity = nil
}

// Opacity returns the value of the "opacity" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) Opacity() (r float64, exists bool) {
	v := m.opacity
	if v == nil {
		return
	}
	return *v, true
}

// OldOpacity returns the old "opacity" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldOpacity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpacity: %w", err)
	}
	return oldValue.Opacity, nil
}

// AddOpacity adds f to the "opacity" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) AddOpacity(f float64) {
	if m.addopacity != nil {
		*m.addopacity += f
	} else {
		m.addopacity = &f
	}
}

// AddedOpacity returns the value that was added to the "opacity" field in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) AddedOpacity() (r float64, exists bool) {
	v := m.addopacity
	if v == nil {
		return
	}
	return *v, true
}

// ClearOpacity clears the value of the "opacity" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearOpacity() {
	m.opacity = nil
	m.addopacity = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldOpacity] = struct{}{}
}

// OpacityCleared returns if the "opacity" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) OpacityCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldOpacity]
	return ok
}

// ResetOpacity resets all changes to the "opacity" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetOpacity() {
	m.opacity = nil
	m.addopacity = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldOpacity)
}

// SetRotation sets the "rotation" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetRotation(f float64) {
	m.rotation = &f
	m.addrotation = nil
}

// Rotation returns the value of the "rotation" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) Rotation() (r float64, exists bool) {
	v := m.rotation
	if v == nil {
		return
	}
	return *v, true
}

// OldRotation returns the old "rotation" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldRotation(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRotation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRotation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRotation: %w", err)
	}
	return oldValue.Rotation, nil
}

// AddRotation adds f to the "rotation" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) AddRotation(f float64) {
	if m.addrotation != nil {
		*m.addrotation += f
	} else {
		m.addrotation = &f
	}
}

// AddedRotation returns the value that was added to the "rotation" field in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) AddedRotation() (r float64, exists bool) {
	v := m.addrotation
	if v == nil {
		return
	}
	return *v, true
}

// ClearRotation clears the value of the "rotation" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearRotation() {
	m.rotation = nil
	m.addrotation = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldRotation] = struct{}{}
}

// RotationCleared returns if the "rotation" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) RotationCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldRotation]
	return ok
}

// ResetRotation resets all changes to the "rotation" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetRotation() {
	m.rotation = nil
	m.addrotation = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldRotation)
}

// SetColor sets the "color" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearColor() {
	m.color = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) ColorCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldColor)
}

// SetFont sets the "font" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetFont(e enums.Font) {
	m.font = &e
}

// Font returns the value of the "font" field in the mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) Font() (r enums.Font, exists bool) {
	v := m.font
	if v == nil {
		return
	}
	return *v, true
}

// OldFont returns the old "font" field's value of the TrustCenterWatermarkConfigHistory entity.
// If the TrustCenterWatermarkConfigHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldFont(ctx context.Context) (v enums.Font, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFont is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFont requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFont: %w", err)
	}
	return oldValue.Font, nil
}

// ClearFont clears the value of the "font" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearFont() {
	m.font = nil
	m.clearedFields[trustcenterwatermarkconfighistory.FieldFont] = struct{}{}
}

// FontCleared returns if the "font" field was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) FontCleared() bool {
	_, ok := m.clearedFields[trustcenterwatermarkconfighistory.FieldFont]
	return ok
}

// ResetFont resets all changes to the "font" field.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetFont() {
	m.font = nil
	delete(m.clearedFields, trustcenterwatermarkconfighistory.FieldFont)
}

// Where appends a list predicates to the TrustCenterWatermarkConfigHistoryMutation builder.
func (m *TrustCenterWatermarkConfigHistoryMutation) Where(ps ...predicate.TrustCenterWatermarkConfigHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TrustCenterWatermarkConfigHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TrustCenterWatermarkConfigHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TrustCenterWatermarkConfigHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TrustCenterWatermarkConfigHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TrustCenterWatermarkConfigHistory).
func (m *TrustCenterWatermarkConfigHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrustCenterWatermarkConfigHistoryMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.history_time != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldDeletedBy)
	}
	if m.owner_id != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldOwnerID)
	}
	if m.trust_center_id != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldTrustCenterID)
	}
	if m.is_enabled != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldIsEnabled)
	}
	if m.logo_id != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldLogoID)
	}
	if m.text != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldText)
	}
	if m.font_size != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldFontSize)
	}
	if m.opacity != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldOpacity)
	}
	if m.rotation != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldRotation)
	}
	if m.color != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldColor)
	}
	if m.font != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldFont)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrustCenterWatermarkConfigHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trustcenterwatermarkconfighistory.FieldHistoryTime:
		return m.HistoryTime()
	case trustcenterwatermarkconfighistory.FieldRef:
		return m.Ref()
	case trustcenterwatermarkconfighistory.FieldOperation:
		return m.Operation()
	case trustcenterwatermarkconfighistory.FieldCreatedAt:
		return m.CreatedAt()
	case trustcenterwatermarkconfighistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case trustcenterwatermarkconfighistory.FieldCreatedBy:
		return m.CreatedBy()
	case trustcenterwatermarkconfighistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case trustcenterwatermarkconfighistory.FieldDeletedAt:
		return m.DeletedAt()
	case trustcenterwatermarkconfighistory.FieldDeletedBy:
		return m.DeletedBy()
	case trustcenterwatermarkconfighistory.FieldOwnerID:
		return m.OwnerID()
	case trustcenterwatermarkconfighistory.FieldTrustCenterID:
		return m.TrustCenterID()
	case trustcenterwatermarkconfighistory.FieldIsEnabled:
		return m.IsEnabled()
	case trustcenterwatermarkconfighistory.FieldLogoID:
		return m.LogoID()
	case trustcenterwatermarkconfighistory.FieldText:
		return m.Text()
	case trustcenterwatermarkconfighistory.FieldFontSize:
		return m.FontSize()
	case trustcenterwatermarkconfighistory.FieldOpacity:
		return m.Opacity()
	case trustcenterwatermarkconfighistory.FieldRotation:
		return m.Rotation()
	case trustcenterwatermarkconfighistory.FieldColor:
		return m.Color()
	case trustcenterwatermarkconfighistory.FieldFont:
		return m.Font()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrustCenterWatermarkConfigHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trustcenterwatermarkconfighistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case trustcenterwatermarkconfighistory.FieldRef:
		return m.OldRef(ctx)
	case trustcenterwatermarkconfighistory.FieldOperation:
		return m.OldOperation(ctx)
	case trustcenterwatermarkconfighistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trustcenterwatermarkconfighistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trustcenterwatermarkconfighistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case trustcenterwatermarkconfighistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case trustcenterwatermarkconfighistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case trustcenterwatermarkconfighistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case trustcenterwatermarkconfighistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case trustcenterwatermarkconfighistory.FieldTrustCenterID:
		return m.OldTrustCenterID(ctx)
	case trustcenterwatermarkconfighistory.FieldIsEnabled:
		return m.OldIsEnabled(ctx)
	case trustcenterwatermarkconfighistory.FieldLogoID:
		return m.OldLogoID(ctx)
	case trustcenterwatermarkconfighistory.FieldText:
		return m.OldText(ctx)
	case trustcenterwatermarkconfighistory.FieldFontSize:
		return m.OldFontSize(ctx)
	case trustcenterwatermarkconfighistory.FieldOpacity:
		return m.OldOpacity(ctx)
	case trustcenterwatermarkconfighistory.FieldRotation:
		return m.OldRotation(ctx)
	case trustcenterwatermarkconfighistory.FieldColor:
		return m.OldColor(ctx)
	case trustcenterwatermarkconfighistory.FieldFont:
		return m.OldFont(ctx)
	}
	return nil, fmt.Errorf("unknown TrustCenterWatermarkConfigHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustCenterWatermarkConfigHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trustcenterwatermarkconfighistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldTrustCenterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrustCenterID(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldIsEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnabled(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldLogoID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoID(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldFontSize:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFontSize(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldOpacity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpacity(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldRotation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRotation(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldFont:
		v, ok := value.(enums.Font)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFont(v)
		return nil
	}
	return fmt.Errorf("unknown TrustCenterWatermarkConfigHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addfont_size != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldFontSize)
	}
	if m.addopacity != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldOpacity)
	}
	if m.addrotation != nil {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldRotation)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrustCenterWatermarkConfigHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case trustcenterwatermarkconfighistory.FieldFontSize:
		return m.AddedFontSize()
	case trustcenterwatermarkconfighistory.FieldOpacity:
		return m.AddedOpacity()
	case trustcenterwatermarkconfighistory.FieldRotation:
		return m.AddedRotation()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustCenterWatermarkConfigHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case trustcenterwatermarkconfighistory.FieldFontSize:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFontSize(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldOpacity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpacity(v)
		return nil
	case trustcenterwatermarkconfighistory.FieldRotation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRotation(v)
		return nil
	}
	return fmt.Errorf("unknown TrustCenterWatermarkConfigHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldRef) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldRef)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldCreatedAt) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldCreatedAt)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldUpdatedAt) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldUpdatedAt)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldCreatedBy) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldCreatedBy)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldUpdatedBy) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldUpdatedBy)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldDeletedAt) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldDeletedAt)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldDeletedBy) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldDeletedBy)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldOwnerID) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldOwnerID)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldTrustCenterID) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldTrustCenterID)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldIsEnabled) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldIsEnabled)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldLogoID) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldLogoID)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldText) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldText)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldFontSize) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldFontSize)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldOpacity) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldOpacity)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldRotation) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldRotation)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldColor) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldColor)
	}
	if m.FieldCleared(trustcenterwatermarkconfighistory.FieldFont) {
		fields = append(fields, trustcenterwatermarkconfighistory.FieldFont)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearField(name string) error {
	switch name {
	case trustcenterwatermarkconfighistory.FieldRef:
		m.ClearRef()
		return nil
	case trustcenterwatermarkconfighistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case trustcenterwatermarkconfighistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case trustcenterwatermarkconfighistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case trustcenterwatermarkconfighistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case trustcenterwatermarkconfighistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case trustcenterwatermarkconfighistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case trustcenterwatermarkconfighistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case trustcenterwatermarkconfighistory.FieldTrustCenterID:
		m.ClearTrustCenterID()
		return nil
	case trustcenterwatermarkconfighistory.FieldIsEnabled:
		m.ClearIsEnabled()
		return nil
	case trustcenterwatermarkconfighistory.FieldLogoID:
		m.ClearLogoID()
		return nil
	case trustcenterwatermarkconfighistory.FieldText:
		m.ClearText()
		return nil
	case trustcenterwatermarkconfighistory.FieldFontSize:
		m.ClearFontSize()
		return nil
	case trustcenterwatermarkconfighistory.FieldOpacity:
		m.ClearOpacity()
		return nil
	case trustcenterwatermarkconfighistory.FieldRotation:
		m.ClearRotation()
		return nil
	case trustcenterwatermarkconfighistory.FieldColor:
		m.ClearColor()
		return nil
	case trustcenterwatermarkconfighistory.FieldFont:
		m.ClearFont()
		return nil
	}
	return fmt.Errorf("unknown TrustCenterWatermarkConfigHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetField(name string) error {
	switch name {
	case trustcenterwatermarkconfighistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case trustcenterwatermarkconfighistory.FieldRef:
		m.ResetRef()
		return nil
	case trustcenterwatermarkconfighistory.FieldOperation:
		m.ResetOperation()
		return nil
	case trustcenterwatermarkconfighistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trustcenterwatermarkconfighistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trustcenterwatermarkconfighistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case trustcenterwatermarkconfighistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case trustcenterwatermarkconfighistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case trustcenterwatermarkconfighistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case trustcenterwatermarkconfighistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case trustcenterwatermarkconfighistory.FieldTrustCenterID:
		m.ResetTrustCenterID()
		return nil
	case trustcenterwatermarkconfighistory.FieldIsEnabled:
		m.ResetIsEnabled()
		return nil
	case trustcenterwatermarkconfighistory.FieldLogoID:
		m.ResetLogoID()
		return nil
	case trustcenterwatermarkconfighistory.FieldText:
		m.ResetText()
		return nil
	case trustcenterwatermarkconfighistory.FieldFontSize:
		m.ResetFontSize()
		return nil
	case trustcenterwatermarkconfighistory.FieldOpacity:
		m.ResetOpacity()
		return nil
	case trustcenterwatermarkconfighistory.FieldRotation:
		m.ResetRotation()
		return nil
	case trustcenterwatermarkconfighistory.FieldColor:
		m.ResetColor()
		return nil
	case trustcenterwatermarkconfighistory.FieldFont:
		m.ResetFont()
		return nil
	}
	return fmt.Errorf("unknown TrustCenterWatermarkConfigHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrustCenterWatermarkConfigHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrustCenterWatermarkConfigHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TrustCenterWatermarkConfigHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrustCenterWatermarkConfigHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TrustCenterWatermarkConfigHistory edge %s", name)
}

// TrustcenterEntityHistoryMutation represents an operation that mutates the TrustcenterEntityHistory nodes in the graph.
type TrustcenterEntityHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *string
	history_time    *time.Time
	ref             *string
	operation       *history.OpType
	created_at      *time.Time
	updated_at      *time.Time
	created_by      *string
	updated_by      *string
	deleted_at      *time.Time
	deleted_by      *string
	logo_file_id    *string
	url             *string
	trust_center_id *string
	name            *string
	entity_type_id  *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*TrustcenterEntityHistory, error)
	predicates      []predicate.TrustcenterEntityHistory
}

var _ ent.Mutation = (*TrustcenterEntityHistoryMutation)(nil)

// trustcenterentityhistoryOption allows management of the mutation configuration using functional options.
type trustcenterentityhistoryOption func(*TrustcenterEntityHistoryMutation)

// newTrustcenterEntityHistoryMutation creates new mutation for the TrustcenterEntityHistory entity.
func newTrustcenterEntityHistoryMutation(c config, op Op, opts ...trustcenterentityhistoryOption) *TrustcenterEntityHistoryMutation {
	m := &TrustcenterEntityHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTrustcenterEntityHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrustcenterEntityHistoryID sets the ID field of the mutation.
func withTrustcenterEntityHistoryID(id string) trustcenterentityhistoryOption {
	return func(m *TrustcenterEntityHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TrustcenterEntityHistory
		)
		m.oldValue = func(ctx context.Context) (*TrustcenterEntityHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TrustcenterEntityHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrustcenterEntityHistory sets the old TrustcenterEntityHistory of the mutation.
func withTrustcenterEntityHistory(node *TrustcenterEntityHistory) trustcenterentityhistoryOption {
	return func(m *TrustcenterEntityHistoryMutation) {
		m.oldValue = func(context.Context) (*TrustcenterEntityHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrustcenterEntityHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrustcenterEntityHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TrustcenterEntityHistory entities.
func (m *TrustcenterEntityHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrustcenterEntityHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrustcenterEntityHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TrustcenterEntityHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *TrustcenterEntityHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *TrustcenterEntityHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the TrustcenterEntityHistory entity.
// If the TrustcenterEntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustcenterEntityHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *TrustcenterEntityHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *TrustcenterEntityHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *TrustcenterEntityHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the TrustcenterEntityHistory entity.
// If the TrustcenterEntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustcenterEntityHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *TrustcenterEntityHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[trustcenterentityhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *TrustcenterEntityHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[trustcenterentityhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *TrustcenterEntityHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, trustcenterentityhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *TrustcenterEntityHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *TrustcenterEntityHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the TrustcenterEntityHistory entity.
// If the TrustcenterEntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustcenterEntityHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *TrustcenterEntityHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TrustcenterEntityHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrustcenterEntityHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TrustcenterEntityHistory entity.
// If the TrustcenterEntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustcenterEntityHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TrustcenterEntityHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[trustcenterentityhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TrustcenterEntityHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[trustcenterentityhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrustcenterEntityHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, trustcenterentityhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TrustcenterEntityHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TrustcenterEntityHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TrustcenterEntityHistory entity.
// If the TrustcenterEntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustcenterEntityHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TrustcenterEntityHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[trustcenterentityhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TrustcenterEntityHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[trustcenterentityhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TrustcenterEntityHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, trustcenterentityhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TrustcenterEntityHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TrustcenterEntityHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TrustcenterEntityHistory entity.
// If the TrustcenterEntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustcenterEntityHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TrustcenterEntityHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[trustcenterentityhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TrustcenterEntityHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[trustcenterentityhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TrustcenterEntityHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, trustcenterentityhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TrustcenterEntityHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TrustcenterEntityHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TrustcenterEntityHistory entity.
// If the TrustcenterEntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustcenterEntityHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TrustcenterEntityHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[trustcenterentityhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TrustcenterEntityHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[trustcenterentityhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TrustcenterEntityHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, trustcenterentityhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TrustcenterEntityHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TrustcenterEntityHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TrustcenterEntityHistory entity.
// If the TrustcenterEntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustcenterEntityHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TrustcenterEntityHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[trustcenterentityhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TrustcenterEntityHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[trustcenterentityhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TrustcenterEntityHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, trustcenterentityhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TrustcenterEntityHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TrustcenterEntityHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TrustcenterEntityHistory entity.
// If the TrustcenterEntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustcenterEntityHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TrustcenterEntityHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[trustcenterentityhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TrustcenterEntityHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[trustcenterentityhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TrustcenterEntityHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, trustcenterentityhistory.FieldDeletedBy)
}

// SetLogoFileID sets the "logo_file_id" field.
func (m *TrustcenterEntityHistoryMutation) SetLogoFileID(s string) {
	m.logo_file_id = &s
}

// LogoFileID returns the value of the "logo_file_id" field in the mutation.
func (m *TrustcenterEntityHistoryMutation) LogoFileID() (r string, exists bool) {
	v := m.logo_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoFileID returns the old "logo_file_id" field's value of the TrustcenterEntityHistory entity.
// If the TrustcenterEntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustcenterEntityHistoryMutation) OldLogoFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoFileID: %w", err)
	}
	return oldValue.LogoFileID, nil
}

// ClearLogoFileID clears the value of the "logo_file_id" field.
func (m *TrustcenterEntityHistoryMutation) ClearLogoFileID() {
	m.logo_file_id = nil
	m.clearedFields[trustcenterentityhistory.FieldLogoFileID] = struct{}{}
}

// LogoFileIDCleared returns if the "logo_file_id" field was cleared in this mutation.
func (m *TrustcenterEntityHistoryMutation) LogoFileIDCleared() bool {
	_, ok := m.clearedFields[trustcenterentityhistory.FieldLogoFileID]
	return ok
}

// ResetLogoFileID resets all changes to the "logo_file_id" field.
func (m *TrustcenterEntityHistoryMutation) ResetLogoFileID() {
	m.logo_file_id = nil
	delete(m.clearedFields, trustcenterentityhistory.FieldLogoFileID)
}

// SetURL sets the "url" field.
func (m *TrustcenterEntityHistoryMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *TrustcenterEntityHistoryMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the TrustcenterEntityHistory entity.
// If the TrustcenterEntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustcenterEntityHistoryMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *TrustcenterEntityHistoryMutation) ClearURL() {
	m.url = nil
	m.clearedFields[trustcenterentityhistory.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *TrustcenterEntityHistoryMutation) URLCleared() bool {
	_, ok := m.clearedFields[trustcenterentityhistory.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *TrustcenterEntityHistoryMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, trustcenterentityhistory.FieldURL)
}

// SetTrustCenterID sets the "trust_center_id" field.
func (m *TrustcenterEntityHistoryMutation) SetTrustCenterID(s string) {
	m.trust_center_id = &s
}

// TrustCenterID returns the value of the "trust_center_id" field in the mutation.
func (m *TrustcenterEntityHistoryMutation) TrustCenterID() (r string, exists bool) {
	v := m.trust_center_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTrustCenterID returns the old "trust_center_id" field's value of the TrustcenterEntityHistory entity.
// If the TrustcenterEntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustcenterEntityHistoryMutation) OldTrustCenterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrustCenterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrustCenterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrustCenterID: %w", err)
	}
	return oldValue.TrustCenterID, nil
}

// ClearTrustCenterID clears the value of the "trust_center_id" field.
func (m *TrustcenterEntityHistoryMutation) ClearTrustCenterID() {
	m.trust_center_id = nil
	m.clearedFields[trustcenterentityhistory.FieldTrustCenterID] = struct{}{}
}

// TrustCenterIDCleared returns if the "trust_center_id" field was cleared in this mutation.
func (m *TrustcenterEntityHistoryMutation) TrustCenterIDCleared() bool {
	_, ok := m.clearedFields[trustcenterentityhistory.FieldTrustCenterID]
	return ok
}

// ResetTrustCenterID resets all changes to the "trust_center_id" field.
func (m *TrustcenterEntityHistoryMutation) ResetTrustCenterID() {
	m.trust_center_id = nil
	delete(m.clearedFields, trustcenterentityhistory.FieldTrustCenterID)
}

// SetName sets the "name" field.
func (m *TrustcenterEntityHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TrustcenterEntityHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TrustcenterEntityHistory entity.
// If the TrustcenterEntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustcenterEntityHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TrustcenterEntityHistoryMutation) ResetName() {
	m.name = nil
}

// SetEntityTypeID sets the "entity_type_id" field.
func (m *TrustcenterEntityHistoryMutation) SetEntityTypeID(s string) {
	m.entity_type_id = &s
}

// EntityTypeID returns the value of the "entity_type_id" field in the mutation.
func (m *TrustcenterEntityHistoryMutation) EntityTypeID() (r string, exists bool) {
	v := m.entity_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityTypeID returns the old "entity_type_id" field's value of the TrustcenterEntityHistory entity.
// If the TrustcenterEntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustcenterEntityHistoryMutation) OldEntityTypeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityTypeID: %w", err)
	}
	return oldValue.EntityTypeID, nil
}

// ClearEntityTypeID clears the value of the "entity_type_id" field.
func (m *TrustcenterEntityHistoryMutation) ClearEntityTypeID() {
	m.entity_type_id = nil
	m.clearedFields[trustcenterentityhistory.FieldEntityTypeID] = struct{}{}
}

// EntityTypeIDCleared returns if the "entity_type_id" field was cleared in this mutation.
func (m *TrustcenterEntityHistoryMutation) EntityTypeIDCleared() bool {
	_, ok := m.clearedFields[trustcenterentityhistory.FieldEntityTypeID]
	return ok
}

// ResetEntityTypeID resets all changes to the "entity_type_id" field.
func (m *TrustcenterEntityHistoryMutation) ResetEntityTypeID() {
	m.entity_type_id = nil
	delete(m.clearedFields, trustcenterentityhistory.FieldEntityTypeID)
}

// Where appends a list predicates to the TrustcenterEntityHistoryMutation builder.
func (m *TrustcenterEntityHistoryMutation) Where(ps ...predicate.TrustcenterEntityHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TrustcenterEntityHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TrustcenterEntityHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TrustcenterEntityHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TrustcenterEntityHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TrustcenterEntityHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TrustcenterEntityHistory).
func (m *TrustcenterEntityHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrustcenterEntityHistoryMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.history_time != nil {
		fields = append(fields, trustcenterentityhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, trustcenterentityhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, trustcenterentityhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, trustcenterentityhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trustcenterentityhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, trustcenterentityhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, trustcenterentityhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, trustcenterentityhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, trustcenterentityhistory.FieldDeletedBy)
	}
	if m.logo_file_id != nil {
		fields = append(fields, trustcenterentityhistory.FieldLogoFileID)
	}
	if m.url != nil {
		fields = append(fields, trustcenterentityhistory.FieldURL)
	}
	if m.trust_center_id != nil {
		fields = append(fields, trustcenterentityhistory.FieldTrustCenterID)
	}
	if m.name != nil {
		fields = append(fields, trustcenterentityhistory.FieldName)
	}
	if m.entity_type_id != nil {
		fields = append(fields, trustcenterentityhistory.FieldEntityTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrustcenterEntityHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trustcenterentityhistory.FieldHistoryTime:
		return m.HistoryTime()
	case trustcenterentityhistory.FieldRef:
		return m.Ref()
	case trustcenterentityhistory.FieldOperation:
		return m.Operation()
	case trustcenterentityhistory.FieldCreatedAt:
		return m.CreatedAt()
	case trustcenterentityhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case trustcenterentityhistory.FieldCreatedBy:
		return m.CreatedBy()
	case trustcenterentityhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case trustcenterentityhistory.FieldDeletedAt:
		return m.DeletedAt()
	case trustcenterentityhistory.FieldDeletedBy:
		return m.DeletedBy()
	case trustcenterentityhistory.FieldLogoFileID:
		return m.LogoFileID()
	case trustcenterentityhistory.FieldURL:
		return m.URL()
	case trustcenterentityhistory.FieldTrustCenterID:
		return m.TrustCenterID()
	case trustcenterentityhistory.FieldName:
		return m.Name()
	case trustcenterentityhistory.FieldEntityTypeID:
		return m.EntityTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrustcenterEntityHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trustcenterentityhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case trustcenterentityhistory.FieldRef:
		return m.OldRef(ctx)
	case trustcenterentityhistory.FieldOperation:
		return m.OldOperation(ctx)
	case trustcenterentityhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trustcenterentityhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trustcenterentityhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case trustcenterentityhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case trustcenterentityhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case trustcenterentityhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case trustcenterentityhistory.FieldLogoFileID:
		return m.OldLogoFileID(ctx)
	case trustcenterentityhistory.FieldURL:
		return m.OldURL(ctx)
	case trustcenterentityhistory.FieldTrustCenterID:
		return m.OldTrustCenterID(ctx)
	case trustcenterentityhistory.FieldName:
		return m.OldName(ctx)
	case trustcenterentityhistory.FieldEntityTypeID:
		return m.OldEntityTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown TrustcenterEntityHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustcenterEntityHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trustcenterentityhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case trustcenterentityhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case trustcenterentityhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case trustcenterentityhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trustcenterentityhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trustcenterentityhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case trustcenterentityhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case trustcenterentityhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case trustcenterentityhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case trustcenterentityhistory.FieldLogoFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoFileID(v)
		return nil
	case trustcenterentityhistory.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case trustcenterentityhistory.FieldTrustCenterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrustCenterID(v)
		return nil
	case trustcenterentityhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case trustcenterentityhistory.FieldEntityTypeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown TrustcenterEntityHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrustcenterEntityHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrustcenterEntityHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustcenterEntityHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TrustcenterEntityHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrustcenterEntityHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trustcenterentityhistory.FieldRef) {
		fields = append(fields, trustcenterentityhistory.FieldRef)
	}
	if m.FieldCleared(trustcenterentityhistory.FieldCreatedAt) {
		fields = append(fields, trustcenterentityhistory.FieldCreatedAt)
	}
	if m.FieldCleared(trustcenterentityhistory.FieldUpdatedAt) {
		fields = append(fields, trustcenterentityhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(trustcenterentityhistory.FieldCreatedBy) {
		fields = append(fields, trustcenterentityhistory.FieldCreatedBy)
	}
	if m.FieldCleared(trustcenterentityhistory.FieldUpdatedBy) {
		fields = append(fields, trustcenterentityhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(trustcenterentityhistory.FieldDeletedAt) {
		fields = append(fields, trustcenterentityhistory.FieldDeletedAt)
	}
	if m.FieldCleared(trustcenterentityhistory.FieldDeletedBy) {
		fields = append(fields, trustcenterentityhistory.FieldDeletedBy)
	}
	if m.FieldCleared(trustcenterentityhistory.FieldLogoFileID) {
		fields = append(fields, trustcenterentityhistory.FieldLogoFileID)
	}
	if m.FieldCleared(trustcenterentityhistory.FieldURL) {
		fields = append(fields, trustcenterentityhistory.FieldURL)
	}
	if m.FieldCleared(trustcenterentityhistory.FieldTrustCenterID) {
		fields = append(fields, trustcenterentityhistory.FieldTrustCenterID)
	}
	if m.FieldCleared(trustcenterentityhistory.FieldEntityTypeID) {
		fields = append(fields, trustcenterentityhistory.FieldEntityTypeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrustcenterEntityHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrustcenterEntityHistoryMutation) ClearField(name string) error {
	switch name {
	case trustcenterentityhistory.FieldRef:
		m.ClearRef()
		return nil
	case trustcenterentityhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case trustcenterentityhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case trustcenterentityhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case trustcenterentityhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case trustcenterentityhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case trustcenterentityhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case trustcenterentityhistory.FieldLogoFileID:
		m.ClearLogoFileID()
		return nil
	case trustcenterentityhistory.FieldURL:
		m.ClearURL()
		return nil
	case trustcenterentityhistory.FieldTrustCenterID:
		m.ClearTrustCenterID()
		return nil
	case trustcenterentityhistory.FieldEntityTypeID:
		m.ClearEntityTypeID()
		return nil
	}
	return fmt.Errorf("unknown TrustcenterEntityHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrustcenterEntityHistoryMutation) ResetField(name string) error {
	switch name {
	case trustcenterentityhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case trustcenterentityhistory.FieldRef:
		m.ResetRef()
		return nil
	case trustcenterentityhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case trustcenterentityhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trustcenterentityhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trustcenterentityhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case trustcenterentityhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case trustcenterentityhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case trustcenterentityhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case trustcenterentityhistory.FieldLogoFileID:
		m.ResetLogoFileID()
		return nil
	case trustcenterentityhistory.FieldURL:
		m.ResetURL()
		return nil
	case trustcenterentityhistory.FieldTrustCenterID:
		m.ResetTrustCenterID()
		return nil
	case trustcenterentityhistory.FieldName:
		m.ResetName()
		return nil
	case trustcenterentityhistory.FieldEntityTypeID:
		m.ResetEntityTypeID()
		return nil
	}
	return fmt.Errorf("unknown TrustcenterEntityHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrustcenterEntityHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrustcenterEntityHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrustcenterEntityHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrustcenterEntityHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrustcenterEntityHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrustcenterEntityHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrustcenterEntityHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TrustcenterEntityHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrustcenterEntityHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TrustcenterEntityHistory edge %s", name)
}

// UserHistoryMutation represents an operation that mutates the UserHistory nodes in the graph.
type UserHistoryMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	history_time            *time.Time
	ref                     *string
	operation               *history.OpType
	created_at              *time.Time
	updated_at              *time.Time
	created_by              *string
	updated_by              *string
	deleted_at              *time.Time
	deleted_by              *string
	display_id              *string
	tags                    *[]string
	appendtags              []string
	email                   *string
	first_name              *string
	last_name               *string
	display_name            *string
	avatar_remote_url       *string
	avatar_local_file_id    *string
	avatar_updated_at       *time.Time
	last_seen               *time.Time
	last_login_provider     *enums.AuthProvider
	password                *string
	sub                     *string
	auth_provider           *enums.AuthProvider
	role                    *enums.Role
	scim_external_id        *string
	scim_username           *string
	scim_active             *bool
	scim_preferred_language *string
	scim_locale             *string
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*UserHistory, error)
	predicates              []predicate.UserHistory
}

var _ ent.Mutation = (*UserHistoryMutation)(nil)

// userhistoryOption allows management of the mutation configuration using functional options.
type userhistoryOption func(*UserHistoryMutation)

// newUserHistoryMutation creates new mutation for the UserHistory entity.
func newUserHistoryMutation(c config, op Op, opts ...userhistoryOption) *UserHistoryMutation {
	m := &UserHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeUserHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserHistoryID sets the ID field of the mutation.
func withUserHistoryID(id string) userhistoryOption {
	return func(m *UserHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *UserHistory
		)
		m.oldValue = func(ctx context.Context) (*UserHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserHistory sets the old UserHistory of the mutation.
func withUserHistory(node *UserHistory) userhistoryOption {
	return func(m *UserHistoryMutation) {
		m.oldValue = func(context.Context) (*UserHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserHistory entities.
func (m *UserHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *UserHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *UserHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *UserHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *UserHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *UserHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *UserHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[userhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *UserHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *UserHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, userhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *UserHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *UserHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *UserHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *UserHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[userhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, userhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[userhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, userhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[userhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, userhistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *UserHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *UserHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *UserHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *UserHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *UserHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *UserHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *UserHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *UserHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[userhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *UserHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *UserHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, userhistory.FieldTags)
}

// SetEmail sets the "email" field.
func (m *UserHistoryMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserHistoryMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserHistoryMutation) ResetEmail() {
	m.email = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserHistoryMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserHistoryMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserHistoryMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[userhistory.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserHistoryMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserHistoryMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, userhistory.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserHistoryMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserHistoryMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserHistoryMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[userhistory.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserHistoryMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserHistoryMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, userhistory.FieldLastName)
}

// SetDisplayName sets the "display_name" field.
func (m *UserHistoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserHistoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserHistoryMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetAvatarRemoteURL sets the "avatar_remote_url" field.
func (m *UserHistoryMutation) SetAvatarRemoteURL(s string) {
	m.avatar_remote_url = &s
}

// AvatarRemoteURL returns the value of the "avatar_remote_url" field in the mutation.
func (m *UserHistoryMutation) AvatarRemoteURL() (r string, exists bool) {
	v := m.avatar_remote_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarRemoteURL returns the old "avatar_remote_url" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldAvatarRemoteURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarRemoteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarRemoteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarRemoteURL: %w", err)
	}
	return oldValue.AvatarRemoteURL, nil
}

// ClearAvatarRemoteURL clears the value of the "avatar_remote_url" field.
func (m *UserHistoryMutation) ClearAvatarRemoteURL() {
	m.avatar_remote_url = nil
	m.clearedFields[userhistory.FieldAvatarRemoteURL] = struct{}{}
}

// AvatarRemoteURLCleared returns if the "avatar_remote_url" field was cleared in this mutation.
func (m *UserHistoryMutation) AvatarRemoteURLCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldAvatarRemoteURL]
	return ok
}

// ResetAvatarRemoteURL resets all changes to the "avatar_remote_url" field.
func (m *UserHistoryMutation) ResetAvatarRemoteURL() {
	m.avatar_remote_url = nil
	delete(m.clearedFields, userhistory.FieldAvatarRemoteURL)
}

// SetAvatarLocalFileID sets the "avatar_local_file_id" field.
func (m *UserHistoryMutation) SetAvatarLocalFileID(s string) {
	m.avatar_local_file_id = &s
}

// AvatarLocalFileID returns the value of the "avatar_local_file_id" field in the mutation.
func (m *UserHistoryMutation) AvatarLocalFileID() (r string, exists bool) {
	v := m.avatar_local_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarLocalFileID returns the old "avatar_local_file_id" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldAvatarLocalFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarLocalFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarLocalFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarLocalFileID: %w", err)
	}
	return oldValue.AvatarLocalFileID, nil
}

// ClearAvatarLocalFileID clears the value of the "avatar_local_file_id" field.
func (m *UserHistoryMutation) ClearAvatarLocalFileID() {
	m.avatar_local_file_id = nil
	m.clearedFields[userhistory.FieldAvatarLocalFileID] = struct{}{}
}

// AvatarLocalFileIDCleared returns if the "avatar_local_file_id" field was cleared in this mutation.
func (m *UserHistoryMutation) AvatarLocalFileIDCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldAvatarLocalFileID]
	return ok
}

// ResetAvatarLocalFileID resets all changes to the "avatar_local_file_id" field.
func (m *UserHistoryMutation) ResetAvatarLocalFileID() {
	m.avatar_local_file_id = nil
	delete(m.clearedFields, userhistory.FieldAvatarLocalFileID)
}

// SetAvatarUpdatedAt sets the "avatar_updated_at" field.
func (m *UserHistoryMutation) SetAvatarUpdatedAt(t time.Time) {
	m.avatar_updated_at = &t
}

// AvatarUpdatedAt returns the value of the "avatar_updated_at" field in the mutation.
func (m *UserHistoryMutation) AvatarUpdatedAt() (r time.Time, exists bool) {
	v := m.avatar_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarUpdatedAt returns the old "avatar_updated_at" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldAvatarUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarUpdatedAt: %w", err)
	}
	return oldValue.AvatarUpdatedAt, nil
}

// ClearAvatarUpdatedAt clears the value of the "avatar_updated_at" field.
func (m *UserHistoryMutation) ClearAvatarUpdatedAt() {
	m.avatar_updated_at = nil
	m.clearedFields[userhistory.FieldAvatarUpdatedAt] = struct{}{}
}

// AvatarUpdatedAtCleared returns if the "avatar_updated_at" field was cleared in this mutation.
func (m *UserHistoryMutation) AvatarUpdatedAtCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldAvatarUpdatedAt]
	return ok
}

// ResetAvatarUpdatedAt resets all changes to the "avatar_updated_at" field.
func (m *UserHistoryMutation) ResetAvatarUpdatedAt() {
	m.avatar_updated_at = nil
	delete(m.clearedFields, userhistory.FieldAvatarUpdatedAt)
}

// SetLastSeen sets the "last_seen" field.
func (m *UserHistoryMutation) SetLastSeen(t time.Time) {
	m.last_seen = &t
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *UserHistoryMutation) LastSeen() (r time.Time, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldLastSeen(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ClearLastSeen clears the value of the "last_seen" field.
func (m *UserHistoryMutation) ClearLastSeen() {
	m.last_seen = nil
	m.clearedFields[userhistory.FieldLastSeen] = struct{}{}
}

// LastSeenCleared returns if the "last_seen" field was cleared in this mutation.
func (m *UserHistoryMutation) LastSeenCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldLastSeen]
	return ok
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *UserHistoryMutation) ResetLastSeen() {
	m.last_seen = nil
	delete(m.clearedFields, userhistory.FieldLastSeen)
}

// SetLastLoginProvider sets the "last_login_provider" field.
func (m *UserHistoryMutation) SetLastLoginProvider(ep enums.AuthProvider) {
	m.last_login_provider = &ep
}

// LastLoginProvider returns the value of the "last_login_provider" field in the mutation.
func (m *UserHistoryMutation) LastLoginProvider() (r enums.AuthProvider, exists bool) {
	v := m.last_login_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginProvider returns the old "last_login_provider" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldLastLoginProvider(ctx context.Context) (v enums.AuthProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginProvider: %w", err)
	}
	return oldValue.LastLoginProvider, nil
}

// ClearLastLoginProvider clears the value of the "last_login_provider" field.
func (m *UserHistoryMutation) ClearLastLoginProvider() {
	m.last_login_provider = nil
	m.clearedFields[userhistory.FieldLastLoginProvider] = struct{}{}
}

// LastLoginProviderCleared returns if the "last_login_provider" field was cleared in this mutation.
func (m *UserHistoryMutation) LastLoginProviderCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldLastLoginProvider]
	return ok
}

// ResetLastLoginProvider resets all changes to the "last_login_provider" field.
func (m *UserHistoryMutation) ResetLastLoginProvider() {
	m.last_login_provider = nil
	delete(m.clearedFields, userhistory.FieldLastLoginProvider)
}

// SetPassword sets the "password" field.
func (m *UserHistoryMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserHistoryMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserHistoryMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[userhistory.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserHistoryMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserHistoryMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, userhistory.FieldPassword)
}

// SetSub sets the "sub" field.
func (m *UserHistoryMutation) SetSub(s string) {
	m.sub = &s
}

// Sub returns the value of the "sub" field in the mutation.
func (m *UserHistoryMutation) Sub() (r string, exists bool) {
	v := m.sub
	if v == nil {
		return
	}
	return *v, true
}

// OldSub returns the old "sub" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldSub(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSub is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSub: %w", err)
	}
	return oldValue.Sub, nil
}

// ClearSub clears the value of the "sub" field.
func (m *UserHistoryMutation) ClearSub() {
	m.sub = nil
	m.clearedFields[userhistory.FieldSub] = struct{}{}
}

// SubCleared returns if the "sub" field was cleared in this mutation.
func (m *UserHistoryMutation) SubCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldSub]
	return ok
}

// ResetSub resets all changes to the "sub" field.
func (m *UserHistoryMutation) ResetSub() {
	m.sub = nil
	delete(m.clearedFields, userhistory.FieldSub)
}

// SetAuthProvider sets the "auth_provider" field.
func (m *UserHistoryMutation) SetAuthProvider(ep enums.AuthProvider) {
	m.auth_provider = &ep
}

// AuthProvider returns the value of the "auth_provider" field in the mutation.
func (m *UserHistoryMutation) AuthProvider() (r enums.AuthProvider, exists bool) {
	v := m.auth_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthProvider returns the old "auth_provider" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldAuthProvider(ctx context.Context) (v enums.AuthProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthProvider: %w", err)
	}
	return oldValue.AuthProvider, nil
}

// ResetAuthProvider resets all changes to the "auth_provider" field.
func (m *UserHistoryMutation) ResetAuthProvider() {
	m.auth_provider = nil
}

// SetRole sets the "role" field.
func (m *UserHistoryMutation) SetRole(e enums.Role) {
	m.role = &e
}

// Role returns the value of the "role" field in the mutation.
func (m *UserHistoryMutation) Role() (r enums.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldRole(ctx context.Context) (v enums.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of the "role" field.
func (m *UserHistoryMutation) ClearRole() {
	m.role = nil
	m.clearedFields[userhistory.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *UserHistoryMutation) RoleCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *UserHistoryMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, userhistory.FieldRole)
}

// SetScimExternalID sets the "scim_external_id" field.
func (m *UserHistoryMutation) SetScimExternalID(s string) {
	m.scim_external_id = &s
}

// ScimExternalID returns the value of the "scim_external_id" field in the mutation.
func (m *UserHistoryMutation) ScimExternalID() (r string, exists bool) {
	v := m.scim_external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScimExternalID returns the old "scim_external_id" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldScimExternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScimExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScimExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScimExternalID: %w", err)
	}
	return oldValue.ScimExternalID, nil
}

// ClearScimExternalID clears the value of the "scim_external_id" field.
func (m *UserHistoryMutation) ClearScimExternalID() {
	m.scim_external_id = nil
	m.clearedFields[userhistory.FieldScimExternalID] = struct{}{}
}

// ScimExternalIDCleared returns if the "scim_external_id" field was cleared in this mutation.
func (m *UserHistoryMutation) ScimExternalIDCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldScimExternalID]
	return ok
}

// ResetScimExternalID resets all changes to the "scim_external_id" field.
func (m *UserHistoryMutation) ResetScimExternalID() {
	m.scim_external_id = nil
	delete(m.clearedFields, userhistory.FieldScimExternalID)
}

// SetScimUsername sets the "scim_username" field.
func (m *UserHistoryMutation) SetScimUsername(s string) {
	m.scim_username = &s
}

// ScimUsername returns the value of the "scim_username" field in the mutation.
func (m *UserHistoryMutation) ScimUsername() (r string, exists bool) {
	v := m.scim_username
	if v == nil {
		return
	}
	return *v, true
}

// OldScimUsername returns the old "scim_username" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldScimUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScimUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScimUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScimUsername: %w", err)
	}
	return oldValue.ScimUsername, nil
}

// ClearScimUsername clears the value of the "scim_username" field.
func (m *UserHistoryMutation) ClearScimUsername() {
	m.scim_username = nil
	m.clearedFields[userhistory.FieldScimUsername] = struct{}{}
}

// ScimUsernameCleared returns if the "scim_username" field was cleared in this mutation.
func (m *UserHistoryMutation) ScimUsernameCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldScimUsername]
	return ok
}

// ResetScimUsername resets all changes to the "scim_username" field.
func (m *UserHistoryMutation) ResetScimUsername() {
	m.scim_username = nil
	delete(m.clearedFields, userhistory.FieldScimUsername)
}

// SetScimActive sets the "scim_active" field.
func (m *UserHistoryMutation) SetScimActive(b bool) {
	m.scim_active = &b
}

// ScimActive returns the value of the "scim_active" field in the mutation.
func (m *UserHistoryMutation) ScimActive() (r bool, exists bool) {
	v := m.scim_active
	if v == nil {
		return
	}
	return *v, true
}

// OldScimActive returns the old "scim_active" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldScimActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScimActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScimActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScimActive: %w", err)
	}
	return oldValue.ScimActive, nil
}

// ClearScimActive clears the value of the "scim_active" field.
func (m *UserHistoryMutation) ClearScimActive() {
	m.scim_active = nil
	m.clearedFields[userhistory.FieldScimActive] = struct{}{}
}

// ScimActiveCleared returns if the "scim_active" field was cleared in this mutation.
func (m *UserHistoryMutation) ScimActiveCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldScimActive]
	return ok
}

// ResetScimActive resets all changes to the "scim_active" field.
func (m *UserHistoryMutation) ResetScimActive() {
	m.scim_active = nil
	delete(m.clearedFields, userhistory.FieldScimActive)
}

// SetScimPreferredLanguage sets the "scim_preferred_language" field.
func (m *UserHistoryMutation) SetScimPreferredLanguage(s string) {
	m.scim_preferred_language = &s
}

// ScimPreferredLanguage returns the value of the "scim_preferred_language" field in the mutation.
func (m *UserHistoryMutation) ScimPreferredLanguage() (r string, exists bool) {
	v := m.scim_preferred_language
	if v == nil {
		return
	}
	return *v, true
}

// OldScimPreferredLanguage returns the old "scim_preferred_language" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldScimPreferredLanguage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScimPreferredLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScimPreferredLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScimPreferredLanguage: %w", err)
	}
	return oldValue.ScimPreferredLanguage, nil
}

// ClearScimPreferredLanguage clears the value of the "scim_preferred_language" field.
func (m *UserHistoryMutation) ClearScimPreferredLanguage() {
	m.scim_preferred_language = nil
	m.clearedFields[userhistory.FieldScimPreferredLanguage] = struct{}{}
}

// ScimPreferredLanguageCleared returns if the "scim_preferred_language" field was cleared in this mutation.
func (m *UserHistoryMutation) ScimPreferredLanguageCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldScimPreferredLanguage]
	return ok
}

// ResetScimPreferredLanguage resets all changes to the "scim_preferred_language" field.
func (m *UserHistoryMutation) ResetScimPreferredLanguage() {
	m.scim_preferred_language = nil
	delete(m.clearedFields, userhistory.FieldScimPreferredLanguage)
}

// SetScimLocale sets the "scim_locale" field.
func (m *UserHistoryMutation) SetScimLocale(s string) {
	m.scim_locale = &s
}

// ScimLocale returns the value of the "scim_locale" field in the mutation.
func (m *UserHistoryMutation) ScimLocale() (r string, exists bool) {
	v := m.scim_locale
	if v == nil {
		return
	}
	return *v, true
}

// OldScimLocale returns the old "scim_locale" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldScimLocale(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScimLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScimLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScimLocale: %w", err)
	}
	return oldValue.ScimLocale, nil
}

// ClearScimLocale clears the value of the "scim_locale" field.
func (m *UserHistoryMutation) ClearScimLocale() {
	m.scim_locale = nil
	m.clearedFields[userhistory.FieldScimLocale] = struct{}{}
}

// ScimLocaleCleared returns if the "scim_locale" field was cleared in this mutation.
func (m *UserHistoryMutation) ScimLocaleCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldScimLocale]
	return ok
}

// ResetScimLocale resets all changes to the "scim_locale" field.
func (m *UserHistoryMutation) ResetScimLocale() {
	m.scim_locale = nil
	delete(m.clearedFields, userhistory.FieldScimLocale)
}

// Where appends a list predicates to the UserHistoryMutation builder.
func (m *UserHistoryMutation) Where(ps ...predicate.UserHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserHistory).
func (m *UserHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserHistoryMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.history_time != nil {
		fields = append(fields, userhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, userhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, userhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, userhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, userhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, userhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, userhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, userhistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, userhistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, userhistory.FieldTags)
	}
	if m.email != nil {
		fields = append(fields, userhistory.FieldEmail)
	}
	if m.first_name != nil {
		fields = append(fields, userhistory.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, userhistory.FieldLastName)
	}
	if m.display_name != nil {
		fields = append(fields, userhistory.FieldDisplayName)
	}
	if m.avatar_remote_url != nil {
		fields = append(fields, userhistory.FieldAvatarRemoteURL)
	}
	if m.avatar_local_file_id != nil {
		fields = append(fields, userhistory.FieldAvatarLocalFileID)
	}
	if m.avatar_updated_at != nil {
		fields = append(fields, userhistory.FieldAvatarUpdatedAt)
	}
	if m.last_seen != nil {
		fields = append(fields, userhistory.FieldLastSeen)
	}
	if m.last_login_provider != nil {
		fields = append(fields, userhistory.FieldLastLoginProvider)
	}
	if m.password != nil {
		fields = append(fields, userhistory.FieldPassword)
	}
	if m.sub != nil {
		fields = append(fields, userhistory.FieldSub)
	}
	if m.auth_provider != nil {
		fields = append(fields, userhistory.FieldAuthProvider)
	}
	if m.role != nil {
		fields = append(fields, userhistory.FieldRole)
	}
	if m.scim_external_id != nil {
		fields = append(fields, userhistory.FieldScimExternalID)
	}
	if m.scim_username != nil {
		fields = append(fields, userhistory.FieldScimUsername)
	}
	if m.scim_active != nil {
		fields = append(fields, userhistory.FieldScimActive)
	}
	if m.scim_preferred_language != nil {
		fields = append(fields, userhistory.FieldScimPreferredLanguage)
	}
	if m.scim_locale != nil {
		fields = append(fields, userhistory.FieldScimLocale)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userhistory.FieldHistoryTime:
		return m.HistoryTime()
	case userhistory.FieldRef:
		return m.Ref()
	case userhistory.FieldOperation:
		return m.Operation()
	case userhistory.FieldCreatedAt:
		return m.CreatedAt()
	case userhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case userhistory.FieldCreatedBy:
		return m.CreatedBy()
	case userhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case userhistory.FieldDeletedAt:
		return m.DeletedAt()
	case userhistory.FieldDeletedBy:
		return m.DeletedBy()
	case userhistory.FieldDisplayID:
		return m.DisplayID()
	case userhistory.FieldTags:
		return m.Tags()
	case userhistory.FieldEmail:
		return m.Email()
	case userhistory.FieldFirstName:
		return m.FirstName()
	case userhistory.FieldLastName:
		return m.LastName()
	case userhistory.FieldDisplayName:
		return m.DisplayName()
	case userhistory.FieldAvatarRemoteURL:
		return m.AvatarRemoteURL()
	case userhistory.FieldAvatarLocalFileID:
		return m.AvatarLocalFileID()
	case userhistory.FieldAvatarUpdatedAt:
		return m.AvatarUpdatedAt()
	case userhistory.FieldLastSeen:
		return m.LastSeen()
	case userhistory.FieldLastLoginProvider:
		return m.LastLoginProvider()
	case userhistory.FieldPassword:
		return m.Password()
	case userhistory.FieldSub:
		return m.Sub()
	case userhistory.FieldAuthProvider:
		return m.AuthProvider()
	case userhistory.FieldRole:
		return m.Role()
	case userhistory.FieldScimExternalID:
		return m.ScimExternalID()
	case userhistory.FieldScimUsername:
		return m.ScimUsername()
	case userhistory.FieldScimActive:
		return m.ScimActive()
	case userhistory.FieldScimPreferredLanguage:
		return m.ScimPreferredLanguage()
	case userhistory.FieldScimLocale:
		return m.ScimLocale()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case userhistory.FieldRef:
		return m.OldRef(ctx)
	case userhistory.FieldOperation:
		return m.OldOperation(ctx)
	case userhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case userhistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case userhistory.FieldTags:
		return m.OldTags(ctx)
	case userhistory.FieldEmail:
		return m.OldEmail(ctx)
	case userhistory.FieldFirstName:
		return m.OldFirstName(ctx)
	case userhistory.FieldLastName:
		return m.OldLastName(ctx)
	case userhistory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case userhistory.FieldAvatarRemoteURL:
		return m.OldAvatarRemoteURL(ctx)
	case userhistory.FieldAvatarLocalFileID:
		return m.OldAvatarLocalFileID(ctx)
	case userhistory.FieldAvatarUpdatedAt:
		return m.OldAvatarUpdatedAt(ctx)
	case userhistory.FieldLastSeen:
		return m.OldLastSeen(ctx)
	case userhistory.FieldLastLoginProvider:
		return m.OldLastLoginProvider(ctx)
	case userhistory.FieldPassword:
		return m.OldPassword(ctx)
	case userhistory.FieldSub:
		return m.OldSub(ctx)
	case userhistory.FieldAuthProvider:
		return m.OldAuthProvider(ctx)
	case userhistory.FieldRole:
		return m.OldRole(ctx)
	case userhistory.FieldScimExternalID:
		return m.OldScimExternalID(ctx)
	case userhistory.FieldScimUsername:
		return m.OldScimUsername(ctx)
	case userhistory.FieldScimActive:
		return m.OldScimActive(ctx)
	case userhistory.FieldScimPreferredLanguage:
		return m.OldScimPreferredLanguage(ctx)
	case userhistory.FieldScimLocale:
		return m.OldScimLocale(ctx)
	}
	return nil, fmt.Errorf("unknown UserHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case userhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case userhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case userhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case userhistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case userhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case userhistory.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case userhistory.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case userhistory.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case userhistory.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case userhistory.FieldAvatarRemoteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarRemoteURL(v)
		return nil
	case userhistory.FieldAvatarLocalFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarLocalFileID(v)
		return nil
	case userhistory.FieldAvatarUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarUpdatedAt(v)
		return nil
	case userhistory.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	case userhistory.FieldLastLoginProvider:
		v, ok := value.(enums.AuthProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginProvider(v)
		return nil
	case userhistory.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case userhistory.FieldSub:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSub(v)
		return nil
	case userhistory.FieldAuthProvider:
		v, ok := value.(enums.AuthProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthProvider(v)
		return nil
	case userhistory.FieldRole:
		v, ok := value.(enums.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case userhistory.FieldScimExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScimExternalID(v)
		return nil
	case userhistory.FieldScimUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScimUsername(v)
		return nil
	case userhistory.FieldScimActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScimActive(v)
		return nil
	case userhistory.FieldScimPreferredLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScimPreferredLanguage(v)
		return nil
	case userhistory.FieldScimLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScimLocale(v)
		return nil
	}
	return fmt.Errorf("unknown UserHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userhistory.FieldRef) {
		fields = append(fields, userhistory.FieldRef)
	}
	if m.FieldCleared(userhistory.FieldCreatedAt) {
		fields = append(fields, userhistory.FieldCreatedAt)
	}
	if m.FieldCleared(userhistory.FieldUpdatedAt) {
		fields = append(fields, userhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(userhistory.FieldCreatedBy) {
		fields = append(fields, userhistory.FieldCreatedBy)
	}
	if m.FieldCleared(userhistory.FieldUpdatedBy) {
		fields = append(fields, userhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(userhistory.FieldDeletedAt) {
		fields = append(fields, userhistory.FieldDeletedAt)
	}
	if m.FieldCleared(userhistory.FieldDeletedBy) {
		fields = append(fields, userhistory.FieldDeletedBy)
	}
	if m.FieldCleared(userhistory.FieldTags) {
		fields = append(fields, userhistory.FieldTags)
	}
	if m.FieldCleared(userhistory.FieldFirstName) {
		fields = append(fields, userhistory.FieldFirstName)
	}
	if m.FieldCleared(userhistory.FieldLastName) {
		fields = append(fields, userhistory.FieldLastName)
	}
	if m.FieldCleared(userhistory.FieldAvatarRemoteURL) {
		fields = append(fields, userhistory.FieldAvatarRemoteURL)
	}
	if m.FieldCleared(userhistory.FieldAvatarLocalFileID) {
		fields = append(fields, userhistory.FieldAvatarLocalFileID)
	}
	if m.FieldCleared(userhistory.FieldAvatarUpdatedAt) {
		fields = append(fields, userhistory.FieldAvatarUpdatedAt)
	}
	if m.FieldCleared(userhistory.FieldLastSeen) {
		fields = append(fields, userhistory.FieldLastSeen)
	}
	if m.FieldCleared(userhistory.FieldLastLoginProvider) {
		fields = append(fields, userhistory.FieldLastLoginProvider)
	}
	if m.FieldCleared(userhistory.FieldPassword) {
		fields = append(fields, userhistory.FieldPassword)
	}
	if m.FieldCleared(userhistory.FieldSub) {
		fields = append(fields, userhistory.FieldSub)
	}
	if m.FieldCleared(userhistory.FieldRole) {
		fields = append(fields, userhistory.FieldRole)
	}
	if m.FieldCleared(userhistory.FieldScimExternalID) {
		fields = append(fields, userhistory.FieldScimExternalID)
	}
	if m.FieldCleared(userhistory.FieldScimUsername) {
		fields = append(fields, userhistory.FieldScimUsername)
	}
	if m.FieldCleared(userhistory.FieldScimActive) {
		fields = append(fields, userhistory.FieldScimActive)
	}
	if m.FieldCleared(userhistory.FieldScimPreferredLanguage) {
		fields = append(fields, userhistory.FieldScimPreferredLanguage)
	}
	if m.FieldCleared(userhistory.FieldScimLocale) {
		fields = append(fields, userhistory.FieldScimLocale)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserHistoryMutation) ClearField(name string) error {
	switch name {
	case userhistory.FieldRef:
		m.ClearRef()
		return nil
	case userhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case userhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case userhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case userhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case userhistory.FieldTags:
		m.ClearTags()
		return nil
	case userhistory.FieldFirstName:
		m.ClearFirstName()
		return nil
	case userhistory.FieldLastName:
		m.ClearLastName()
		return nil
	case userhistory.FieldAvatarRemoteURL:
		m.ClearAvatarRemoteURL()
		return nil
	case userhistory.FieldAvatarLocalFileID:
		m.ClearAvatarLocalFileID()
		return nil
	case userhistory.FieldAvatarUpdatedAt:
		m.ClearAvatarUpdatedAt()
		return nil
	case userhistory.FieldLastSeen:
		m.ClearLastSeen()
		return nil
	case userhistory.FieldLastLoginProvider:
		m.ClearLastLoginProvider()
		return nil
	case userhistory.FieldPassword:
		m.ClearPassword()
		return nil
	case userhistory.FieldSub:
		m.ClearSub()
		return nil
	case userhistory.FieldRole:
		m.ClearRole()
		return nil
	case userhistory.FieldScimExternalID:
		m.ClearScimExternalID()
		return nil
	case userhistory.FieldScimUsername:
		m.ClearScimUsername()
		return nil
	case userhistory.FieldScimActive:
		m.ClearScimActive()
		return nil
	case userhistory.FieldScimPreferredLanguage:
		m.ClearScimPreferredLanguage()
		return nil
	case userhistory.FieldScimLocale:
		m.ClearScimLocale()
		return nil
	}
	return fmt.Errorf("unknown UserHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserHistoryMutation) ResetField(name string) error {
	switch name {
	case userhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case userhistory.FieldRef:
		m.ResetRef()
		return nil
	case userhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case userhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case userhistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case userhistory.FieldTags:
		m.ResetTags()
		return nil
	case userhistory.FieldEmail:
		m.ResetEmail()
		return nil
	case userhistory.FieldFirstName:
		m.ResetFirstName()
		return nil
	case userhistory.FieldLastName:
		m.ResetLastName()
		return nil
	case userhistory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case userhistory.FieldAvatarRemoteURL:
		m.ResetAvatarRemoteURL()
		return nil
	case userhistory.FieldAvatarLocalFileID:
		m.ResetAvatarLocalFileID()
		return nil
	case userhistory.FieldAvatarUpdatedAt:
		m.ResetAvatarUpdatedAt()
		return nil
	case userhistory.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	case userhistory.FieldLastLoginProvider:
		m.ResetLastLoginProvider()
		return nil
	case userhistory.FieldPassword:
		m.ResetPassword()
		return nil
	case userhistory.FieldSub:
		m.ResetSub()
		return nil
	case userhistory.FieldAuthProvider:
		m.ResetAuthProvider()
		return nil
	case userhistory.FieldRole:
		m.ResetRole()
		return nil
	case userhistory.FieldScimExternalID:
		m.ResetScimExternalID()
		return nil
	case userhistory.FieldScimUsername:
		m.ResetScimUsername()
		return nil
	case userhistory.FieldScimActive:
		m.ResetScimActive()
		return nil
	case userhistory.FieldScimPreferredLanguage:
		m.ResetScimPreferredLanguage()
		return nil
	case userhistory.FieldScimLocale:
		m.ResetScimLocale()
		return nil
	}
	return fmt.Errorf("unknown UserHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserHistory edge %s", name)
}

// UserSettingHistoryMutation represents an operation that mutates the UserSettingHistory nodes in the graph.
type UserSettingHistoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	history_time        *time.Time
	ref                 *string
	operation           *history.OpType
	created_at          *time.Time
	updated_at          *time.Time
	created_by          *string
	updated_by          *string
	deleted_at          *time.Time
	deleted_by          *string
	tags                *[]string
	appendtags          []string
	user_id             *string
	locked              *bool
	silenced_at         *time.Time
	suspended_at        *time.Time
	status              *enums.UserStatus
	email_confirmed     *bool
	is_webauthn_allowed *bool
	is_tfa_enabled      *bool
	phone_number        *string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*UserSettingHistory, error)
	predicates          []predicate.UserSettingHistory
}

var _ ent.Mutation = (*UserSettingHistoryMutation)(nil)

// usersettinghistoryOption allows management of the mutation configuration using functional options.
type usersettinghistoryOption func(*UserSettingHistoryMutation)

// newUserSettingHistoryMutation creates new mutation for the UserSettingHistory entity.
func newUserSettingHistoryMutation(c config, op Op, opts ...usersettinghistoryOption) *UserSettingHistoryMutation {
	m := &UserSettingHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSettingHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSettingHistoryID sets the ID field of the mutation.
func withUserSettingHistoryID(id string) usersettinghistoryOption {
	return func(m *UserSettingHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSettingHistory
		)
		m.oldValue = func(ctx context.Context) (*UserSettingHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSettingHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSettingHistory sets the old UserSettingHistory of the mutation.
func withUserSettingHistory(node *UserSettingHistory) usersettinghistoryOption {
	return func(m *UserSettingHistoryMutation) {
		m.oldValue = func(context.Context) (*UserSettingHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSettingHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSettingHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSettingHistory entities.
func (m *UserSettingHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSettingHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSettingHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSettingHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *UserSettingHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *UserSettingHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *UserSettingHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *UserSettingHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *UserSettingHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *UserSettingHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[usersettinghistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *UserSettingHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, usersettinghistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *UserSettingHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *UserSettingHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *UserSettingHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSettingHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSettingHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserSettingHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[usersettinghistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSettingHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, usersettinghistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSettingHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSettingHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserSettingHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[usersettinghistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSettingHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, usersettinghistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *UserSettingHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserSettingHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserSettingHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[usersettinghistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserSettingHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, usersettinghistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserSettingHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserSettingHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserSettingHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[usersettinghistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserSettingHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, usersettinghistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserSettingHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserSettingHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserSettingHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[usersettinghistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserSettingHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, usersettinghistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserSettingHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserSettingHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserSettingHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[usersettinghistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserSettingHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, usersettinghistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *UserSettingHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *UserSettingHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *UserSettingHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *UserSettingHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *UserSettingHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[usersettinghistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *UserSettingHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, usersettinghistory.FieldTags)
}

// SetUserID sets the "user_id" field.
func (m *UserSettingHistoryMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserSettingHistoryMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserSettingHistoryMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[usersettinghistory.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserSettingHistoryMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, usersettinghistory.FieldUserID)
}

// SetLocked sets the "locked" field.
func (m *UserSettingHistoryMutation) SetLocked(b bool) {
	m.locked = &b
}

// Locked returns the value of the "locked" field in the mutation.
func (m *UserSettingHistoryMutation) Locked() (r bool, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldLocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ResetLocked resets all changes to the "locked" field.
func (m *UserSettingHistoryMutation) ResetLocked() {
	m.locked = nil
}

// SetSilencedAt sets the "silenced_at" field.
func (m *UserSettingHistoryMutation) SetSilencedAt(t time.Time) {
	m.silenced_at = &t
}

// SilencedAt returns the value of the "silenced_at" field in the mutation.
func (m *UserSettingHistoryMutation) SilencedAt() (r time.Time, exists bool) {
	v := m.silenced_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSilencedAt returns the old "silenced_at" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldSilencedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSilencedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSilencedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSilencedAt: %w", err)
	}
	return oldValue.SilencedAt, nil
}

// ClearSilencedAt clears the value of the "silenced_at" field.
func (m *UserSettingHistoryMutation) ClearSilencedAt() {
	m.silenced_at = nil
	m.clearedFields[usersettinghistory.FieldSilencedAt] = struct{}{}
}

// SilencedAtCleared returns if the "silenced_at" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) SilencedAtCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldSilencedAt]
	return ok
}

// ResetSilencedAt resets all changes to the "silenced_at" field.
func (m *UserSettingHistoryMutation) ResetSilencedAt() {
	m.silenced_at = nil
	delete(m.clearedFields, usersettinghistory.FieldSilencedAt)
}

// SetSuspendedAt sets the "suspended_at" field.
func (m *UserSettingHistoryMutation) SetSuspendedAt(t time.Time) {
	m.suspended_at = &t
}

// SuspendedAt returns the value of the "suspended_at" field in the mutation.
func (m *UserSettingHistoryMutation) SuspendedAt() (r time.Time, exists bool) {
	v := m.suspended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspendedAt returns the old "suspended_at" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldSuspendedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspendedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspendedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspendedAt: %w", err)
	}
	return oldValue.SuspendedAt, nil
}

// ClearSuspendedAt clears the value of the "suspended_at" field.
func (m *UserSettingHistoryMutation) ClearSuspendedAt() {
	m.suspended_at = nil
	m.clearedFields[usersettinghistory.FieldSuspendedAt] = struct{}{}
}

// SuspendedAtCleared returns if the "suspended_at" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) SuspendedAtCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldSuspendedAt]
	return ok
}

// ResetSuspendedAt resets all changes to the "suspended_at" field.
func (m *UserSettingHistoryMutation) ResetSuspendedAt() {
	m.suspended_at = nil
	delete(m.clearedFields, usersettinghistory.FieldSuspendedAt)
}

// SetStatus sets the "status" field.
func (m *UserSettingHistoryMutation) SetStatus(es enums.UserStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *UserSettingHistoryMutation) Status() (r enums.UserStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldStatus(ctx context.Context) (v enums.UserStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserSettingHistoryMutation) ResetStatus() {
	m.status = nil
}

// SetEmailConfirmed sets the "email_confirmed" field.
func (m *UserSettingHistoryMutation) SetEmailConfirmed(b bool) {
	m.email_confirmed = &b
}

// EmailConfirmed returns the value of the "email_confirmed" field in the mutation.
func (m *UserSettingHistoryMutation) EmailConfirmed() (r bool, exists bool) {
	v := m.email_confirmed
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailConfirmed returns the old "email_confirmed" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldEmailConfirmed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailConfirmed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailConfirmed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailConfirmed: %w", err)
	}
	return oldValue.EmailConfirmed, nil
}

// ResetEmailConfirmed resets all changes to the "email_confirmed" field.
func (m *UserSettingHistoryMutation) ResetEmailConfirmed() {
	m.email_confirmed = nil
}

// SetIsWebauthnAllowed sets the "is_webauthn_allowed" field.
func (m *UserSettingHistoryMutation) SetIsWebauthnAllowed(b bool) {
	m.is_webauthn_allowed = &b
}

// IsWebauthnAllowed returns the value of the "is_webauthn_allowed" field in the mutation.
func (m *UserSettingHistoryMutation) IsWebauthnAllowed() (r bool, exists bool) {
	v := m.is_webauthn_allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsWebauthnAllowed returns the old "is_webauthn_allowed" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldIsWebauthnAllowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsWebauthnAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsWebauthnAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsWebauthnAllowed: %w", err)
	}
	return oldValue.IsWebauthnAllowed, nil
}

// ClearIsWebauthnAllowed clears the value of the "is_webauthn_allowed" field.
func (m *UserSettingHistoryMutation) ClearIsWebauthnAllowed() {
	m.is_webauthn_allowed = nil
	m.clearedFields[usersettinghistory.FieldIsWebauthnAllowed] = struct{}{}
}

// IsWebauthnAllowedCleared returns if the "is_webauthn_allowed" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) IsWebauthnAllowedCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldIsWebauthnAllowed]
	return ok
}

// ResetIsWebauthnAllowed resets all changes to the "is_webauthn_allowed" field.
func (m *UserSettingHistoryMutation) ResetIsWebauthnAllowed() {
	m.is_webauthn_allowed = nil
	delete(m.clearedFields, usersettinghistory.FieldIsWebauthnAllowed)
}

// SetIsTfaEnabled sets the "is_tfa_enabled" field.
func (m *UserSettingHistoryMutation) SetIsTfaEnabled(b bool) {
	m.is_tfa_enabled = &b
}

// IsTfaEnabled returns the value of the "is_tfa_enabled" field in the mutation.
func (m *UserSettingHistoryMutation) IsTfaEnabled() (r bool, exists bool) {
	v := m.is_tfa_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTfaEnabled returns the old "is_tfa_enabled" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldIsTfaEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTfaEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTfaEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTfaEnabled: %w", err)
	}
	return oldValue.IsTfaEnabled, nil
}

// ClearIsTfaEnabled clears the value of the "is_tfa_enabled" field.
func (m *UserSettingHistoryMutation) ClearIsTfaEnabled() {
	m.is_tfa_enabled = nil
	m.clearedFields[usersettinghistory.FieldIsTfaEnabled] = struct{}{}
}

// IsTfaEnabledCleared returns if the "is_tfa_enabled" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) IsTfaEnabledCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldIsTfaEnabled]
	return ok
}

// ResetIsTfaEnabled resets all changes to the "is_tfa_enabled" field.
func (m *UserSettingHistoryMutation) ResetIsTfaEnabled() {
	m.is_tfa_enabled = nil
	delete(m.clearedFields, usersettinghistory.FieldIsTfaEnabled)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserSettingHistoryMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserSettingHistoryMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *UserSettingHistoryMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[usersettinghistory.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserSettingHistoryMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, usersettinghistory.FieldPhoneNumber)
}

// Where appends a list predicates to the UserSettingHistoryMutation builder.
func (m *UserSettingHistoryMutation) Where(ps ...predicate.UserSettingHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSettingHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSettingHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSettingHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSettingHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSettingHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSettingHistory).
func (m *UserSettingHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSettingHistoryMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.history_time != nil {
		fields = append(fields, usersettinghistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, usersettinghistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, usersettinghistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, usersettinghistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usersettinghistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, usersettinghistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, usersettinghistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, usersettinghistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, usersettinghistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, usersettinghistory.FieldTags)
	}
	if m.user_id != nil {
		fields = append(fields, usersettinghistory.FieldUserID)
	}
	if m.locked != nil {
		fields = append(fields, usersettinghistory.FieldLocked)
	}
	if m.silenced_at != nil {
		fields = append(fields, usersettinghistory.FieldSilencedAt)
	}
	if m.suspended_at != nil {
		fields = append(fields, usersettinghistory.FieldSuspendedAt)
	}
	if m.status != nil {
		fields = append(fields, usersettinghistory.FieldStatus)
	}
	if m.email_confirmed != nil {
		fields = append(fields, usersettinghistory.FieldEmailConfirmed)
	}
	if m.is_webauthn_allowed != nil {
		fields = append(fields, usersettinghistory.FieldIsWebauthnAllowed)
	}
	if m.is_tfa_enabled != nil {
		fields = append(fields, usersettinghistory.FieldIsTfaEnabled)
	}
	if m.phone_number != nil {
		fields = append(fields, usersettinghistory.FieldPhoneNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSettingHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersettinghistory.FieldHistoryTime:
		return m.HistoryTime()
	case usersettinghistory.FieldRef:
		return m.Ref()
	case usersettinghistory.FieldOperation:
		return m.Operation()
	case usersettinghistory.FieldCreatedAt:
		return m.CreatedAt()
	case usersettinghistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case usersettinghistory.FieldCreatedBy:
		return m.CreatedBy()
	case usersettinghistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case usersettinghistory.FieldDeletedAt:
		return m.DeletedAt()
	case usersettinghistory.FieldDeletedBy:
		return m.DeletedBy()
	case usersettinghistory.FieldTags:
		return m.Tags()
	case usersettinghistory.FieldUserID:
		return m.UserID()
	case usersettinghistory.FieldLocked:
		return m.Locked()
	case usersettinghistory.FieldSilencedAt:
		return m.SilencedAt()
	case usersettinghistory.FieldSuspendedAt:
		return m.SuspendedAt()
	case usersettinghistory.FieldStatus:
		return m.Status()
	case usersettinghistory.FieldEmailConfirmed:
		return m.EmailConfirmed()
	case usersettinghistory.FieldIsWebauthnAllowed:
		return m.IsWebauthnAllowed()
	case usersettinghistory.FieldIsTfaEnabled:
		return m.IsTfaEnabled()
	case usersettinghistory.FieldPhoneNumber:
		return m.PhoneNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSettingHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersettinghistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case usersettinghistory.FieldRef:
		return m.OldRef(ctx)
	case usersettinghistory.FieldOperation:
		return m.OldOperation(ctx)
	case usersettinghistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usersettinghistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usersettinghistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case usersettinghistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case usersettinghistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usersettinghistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case usersettinghistory.FieldTags:
		return m.OldTags(ctx)
	case usersettinghistory.FieldUserID:
		return m.OldUserID(ctx)
	case usersettinghistory.FieldLocked:
		return m.OldLocked(ctx)
	case usersettinghistory.FieldSilencedAt:
		return m.OldSilencedAt(ctx)
	case usersettinghistory.FieldSuspendedAt:
		return m.OldSuspendedAt(ctx)
	case usersettinghistory.FieldStatus:
		return m.OldStatus(ctx)
	case usersettinghistory.FieldEmailConfirmed:
		return m.OldEmailConfirmed(ctx)
	case usersettinghistory.FieldIsWebauthnAllowed:
		return m.OldIsWebauthnAllowed(ctx)
	case usersettinghistory.FieldIsTfaEnabled:
		return m.OldIsTfaEnabled(ctx)
	case usersettinghistory.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	}
	return nil, fmt.Errorf("unknown UserSettingHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSettingHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersettinghistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case usersettinghistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case usersettinghistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case usersettinghistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usersettinghistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usersettinghistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case usersettinghistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case usersettinghistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usersettinghistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case usersettinghistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case usersettinghistory.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usersettinghistory.FieldLocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case usersettinghistory.FieldSilencedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSilencedAt(v)
		return nil
	case usersettinghistory.FieldSuspendedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspendedAt(v)
		return nil
	case usersettinghistory.FieldStatus:
		v, ok := value.(enums.UserStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case usersettinghistory.FieldEmailConfirmed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailConfirmed(v)
		return nil
	case usersettinghistory.FieldIsWebauthnAllowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsWebauthnAllowed(v)
		return nil
	case usersettinghistory.FieldIsTfaEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTfaEnabled(v)
		return nil
	case usersettinghistory.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	}
	return fmt.Errorf("unknown UserSettingHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSettingHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSettingHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSettingHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSettingHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSettingHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersettinghistory.FieldRef) {
		fields = append(fields, usersettinghistory.FieldRef)
	}
	if m.FieldCleared(usersettinghistory.FieldCreatedAt) {
		fields = append(fields, usersettinghistory.FieldCreatedAt)
	}
	if m.FieldCleared(usersettinghistory.FieldUpdatedAt) {
		fields = append(fields, usersettinghistory.FieldUpdatedAt)
	}
	if m.FieldCleared(usersettinghistory.FieldCreatedBy) {
		fields = append(fields, usersettinghistory.FieldCreatedBy)
	}
	if m.FieldCleared(usersettinghistory.FieldUpdatedBy) {
		fields = append(fields, usersettinghistory.FieldUpdatedBy)
	}
	if m.FieldCleared(usersettinghistory.FieldDeletedAt) {
		fields = append(fields, usersettinghistory.FieldDeletedAt)
	}
	if m.FieldCleared(usersettinghistory.FieldDeletedBy) {
		fields = append(fields, usersettinghistory.FieldDeletedBy)
	}
	if m.FieldCleared(usersettinghistory.FieldTags) {
		fields = append(fields, usersettinghistory.FieldTags)
	}
	if m.FieldCleared(usersettinghistory.FieldUserID) {
		fields = append(fields, usersettinghistory.FieldUserID)
	}
	if m.FieldCleared(usersettinghistory.FieldSilencedAt) {
		fields = append(fields, usersettinghistory.FieldSilencedAt)
	}
	if m.FieldCleared(usersettinghistory.FieldSuspendedAt) {
		fields = append(fields, usersettinghistory.FieldSuspendedAt)
	}
	if m.FieldCleared(usersettinghistory.FieldIsWebauthnAllowed) {
		fields = append(fields, usersettinghistory.FieldIsWebauthnAllowed)
	}
	if m.FieldCleared(usersettinghistory.FieldIsTfaEnabled) {
		fields = append(fields, usersettinghistory.FieldIsTfaEnabled)
	}
	if m.FieldCleared(usersettinghistory.FieldPhoneNumber) {
		fields = append(fields, usersettinghistory.FieldPhoneNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSettingHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSettingHistoryMutation) ClearField(name string) error {
	switch name {
	case usersettinghistory.FieldRef:
		m.ClearRef()
		return nil
	case usersettinghistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case usersettinghistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case usersettinghistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case usersettinghistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case usersettinghistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case usersettinghistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case usersettinghistory.FieldTags:
		m.ClearTags()
		return nil
	case usersettinghistory.FieldUserID:
		m.ClearUserID()
		return nil
	case usersettinghistory.FieldSilencedAt:
		m.ClearSilencedAt()
		return nil
	case usersettinghistory.FieldSuspendedAt:
		m.ClearSuspendedAt()
		return nil
	case usersettinghistory.FieldIsWebauthnAllowed:
		m.ClearIsWebauthnAllowed()
		return nil
	case usersettinghistory.FieldIsTfaEnabled:
		m.ClearIsTfaEnabled()
		return nil
	case usersettinghistory.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	}
	return fmt.Errorf("unknown UserSettingHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSettingHistoryMutation) ResetField(name string) error {
	switch name {
	case usersettinghistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case usersettinghistory.FieldRef:
		m.ResetRef()
		return nil
	case usersettinghistory.FieldOperation:
		m.ResetOperation()
		return nil
	case usersettinghistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usersettinghistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usersettinghistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case usersettinghistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case usersettinghistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usersettinghistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case usersettinghistory.FieldTags:
		m.ResetTags()
		return nil
	case usersettinghistory.FieldUserID:
		m.ResetUserID()
		return nil
	case usersettinghistory.FieldLocked:
		m.ResetLocked()
		return nil
	case usersettinghistory.FieldSilencedAt:
		m.ResetSilencedAt()
		return nil
	case usersettinghistory.FieldSuspendedAt:
		m.ResetSuspendedAt()
		return nil
	case usersettinghistory.FieldStatus:
		m.ResetStatus()
		return nil
	case usersettinghistory.FieldEmailConfirmed:
		m.ResetEmailConfirmed()
		return nil
	case usersettinghistory.FieldIsWebauthnAllowed:
		m.ResetIsWebauthnAllowed()
		return nil
	case usersettinghistory.FieldIsTfaEnabled:
		m.ResetIsTfaEnabled()
		return nil
	case usersettinghistory.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	}
	return fmt.Errorf("unknown UserSettingHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSettingHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSettingHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSettingHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSettingHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSettingHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSettingHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSettingHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserSettingHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSettingHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserSettingHistory edge %s", name)
}

// VulnerabilityHistoryMutation represents an operation that mutates the VulnerabilityHistory nodes in the graph.
type VulnerabilityHistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	history_time       *time.Time
	ref                *string
	operation          *history.OpType
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	deleted_at         *time.Time
	deleted_by         *string
	display_id         *string
	tags               *[]string
	appendtags         []string
	owner_id           *string
	system_owned       *bool
	internal_notes     *string
	system_internal_id *string
	external_owner_id  *string
	external_id        *string
	cve_id             *string
	source             *string
	display_name       *string
	category           *string
	severity           *string
	score              *float64
	addscore           *float64
	impact             *float64
	addimpact          *float64
	exploitability     *float64
	addexploitability  *float64
	priority           *string
	status             *string
	summary            *string
	description        *string
	vector             *string
	remediation_sla    *int
	addremediation_sla *int
	open               *bool
	blocking           *bool
	production         *bool
	public             *bool
	validated          *bool
	references         *[]string
	appendreferences   []string
	impacts            *[]string
	appendimpacts      []string
	published_at       *models.DateTime
	discovered_at      *models.DateTime
	source_updated_at  *models.DateTime
	external_uri       *string
	metadata           *map[string]interface{}
	raw_payload        *map[string]interface{}
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*VulnerabilityHistory, error)
	predicates         []predicate.VulnerabilityHistory
}

var _ ent.Mutation = (*VulnerabilityHistoryMutation)(nil)

// vulnerabilityhistoryOption allows management of the mutation configuration using functional options.
type vulnerabilityhistoryOption func(*VulnerabilityHistoryMutation)

// newVulnerabilityHistoryMutation creates new mutation for the VulnerabilityHistory entity.
func newVulnerabilityHistoryMutation(c config, op Op, opts ...vulnerabilityhistoryOption) *VulnerabilityHistoryMutation {
	m := &VulnerabilityHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnerabilityHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnerabilityHistoryID sets the ID field of the mutation.
func withVulnerabilityHistoryID(id string) vulnerabilityhistoryOption {
	return func(m *VulnerabilityHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *VulnerabilityHistory
		)
		m.oldValue = func(ctx context.Context) (*VulnerabilityHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VulnerabilityHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnerabilityHistory sets the old VulnerabilityHistory of the mutation.
func withVulnerabilityHistory(node *VulnerabilityHistory) vulnerabilityhistoryOption {
	return func(m *VulnerabilityHistoryMutation) {
		m.oldValue = func(context.Context) (*VulnerabilityHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnerabilityHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnerabilityHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VulnerabilityHistory entities.
func (m *VulnerabilityHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnerabilityHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VulnerabilityHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VulnerabilityHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *VulnerabilityHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *VulnerabilityHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *VulnerabilityHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *VulnerabilityHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *VulnerabilityHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *VulnerabilityHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[vulnerabilityhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *VulnerabilityHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *VulnerabilityHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *VulnerabilityHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *VulnerabilityHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VulnerabilityHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VulnerabilityHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *VulnerabilityHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[vulnerabilityhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VulnerabilityHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VulnerabilityHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VulnerabilityHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *VulnerabilityHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[vulnerabilityhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VulnerabilityHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *VulnerabilityHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VulnerabilityHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *VulnerabilityHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[vulnerabilityhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VulnerabilityHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VulnerabilityHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VulnerabilityHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *VulnerabilityHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[vulnerabilityhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VulnerabilityHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VulnerabilityHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VulnerabilityHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VulnerabilityHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[vulnerabilityhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VulnerabilityHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *VulnerabilityHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *VulnerabilityHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *VulnerabilityHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[vulnerabilityhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *VulnerabilityHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *VulnerabilityHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *VulnerabilityHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *VulnerabilityHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *VulnerabilityHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *VulnerabilityHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *VulnerabilityHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *VulnerabilityHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *VulnerabilityHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[vulnerabilityhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *VulnerabilityHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *VulnerabilityHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *VulnerabilityHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *VulnerabilityHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[vulnerabilityhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *VulnerabilityHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *VulnerabilityHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *VulnerabilityHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *VulnerabilityHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[vulnerabilityhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *VulnerabilityHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *VulnerabilityHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *VulnerabilityHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *VulnerabilityHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[vulnerabilityhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *VulnerabilityHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *VulnerabilityHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *VulnerabilityHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *VulnerabilityHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[vulnerabilityhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *VulnerabilityHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldSystemInternalID)
}

// SetExternalOwnerID sets the "external_owner_id" field.
func (m *VulnerabilityHistoryMutation) SetExternalOwnerID(s string) {
	m.external_owner_id = &s
}

// ExternalOwnerID returns the value of the "external_owner_id" field in the mutation.
func (m *VulnerabilityHistoryMutation) ExternalOwnerID() (r string, exists bool) {
	v := m.external_owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalOwnerID returns the old "external_owner_id" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldExternalOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalOwnerID: %w", err)
	}
	return oldValue.ExternalOwnerID, nil
}

// ClearExternalOwnerID clears the value of the "external_owner_id" field.
func (m *VulnerabilityHistoryMutation) ClearExternalOwnerID() {
	m.external_owner_id = nil
	m.clearedFields[vulnerabilityhistory.FieldExternalOwnerID] = struct{}{}
}

// ExternalOwnerIDCleared returns if the "external_owner_id" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) ExternalOwnerIDCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldExternalOwnerID]
	return ok
}

// ResetExternalOwnerID resets all changes to the "external_owner_id" field.
func (m *VulnerabilityHistoryMutation) ResetExternalOwnerID() {
	m.external_owner_id = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldExternalOwnerID)
}

// SetExternalID sets the "external_id" field.
func (m *VulnerabilityHistoryMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *VulnerabilityHistoryMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *VulnerabilityHistoryMutation) ResetExternalID() {
	m.external_id = nil
}

// SetCveID sets the "cve_id" field.
func (m *VulnerabilityHistoryMutation) SetCveID(s string) {
	m.cve_id = &s
}

// CveID returns the value of the "cve_id" field in the mutation.
func (m *VulnerabilityHistoryMutation) CveID() (r string, exists bool) {
	v := m.cve_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCveID returns the old "cve_id" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldCveID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCveID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCveID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCveID: %w", err)
	}
	return oldValue.CveID, nil
}

// ClearCveID clears the value of the "cve_id" field.
func (m *VulnerabilityHistoryMutation) ClearCveID() {
	m.cve_id = nil
	m.clearedFields[vulnerabilityhistory.FieldCveID] = struct{}{}
}

// CveIDCleared returns if the "cve_id" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) CveIDCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldCveID]
	return ok
}

// ResetCveID resets all changes to the "cve_id" field.
func (m *VulnerabilityHistoryMutation) ResetCveID() {
	m.cve_id = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldCveID)
}

// SetSource sets the "source" field.
func (m *VulnerabilityHistoryMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *VulnerabilityHistoryMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *VulnerabilityHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[vulnerabilityhistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *VulnerabilityHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldSource)
}

// SetDisplayName sets the "display_name" field.
func (m *VulnerabilityHistoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *VulnerabilityHistoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *VulnerabilityHistoryMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[vulnerabilityhistory.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *VulnerabilityHistoryMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldDisplayName)
}

// SetCategory sets the "category" field.
func (m *VulnerabilityHistoryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *VulnerabilityHistoryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *VulnerabilityHistoryMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[vulnerabilityhistory.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *VulnerabilityHistoryMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldCategory)
}

// SetSeverity sets the "severity" field.
func (m *VulnerabilityHistoryMutation) SetSeverity(s string) {
	m.severity = &s
}

// Severity returns the value of the "severity" field in the mutation.
func (m *VulnerabilityHistoryMutation) Severity() (r string, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldSeverity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ClearSeverity clears the value of the "severity" field.
func (m *VulnerabilityHistoryMutation) ClearSeverity() {
	m.severity = nil
	m.clearedFields[vulnerabilityhistory.FieldSeverity] = struct{}{}
}

// SeverityCleared returns if the "severity" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) SeverityCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldSeverity]
	return ok
}

// ResetSeverity resets all changes to the "severity" field.
func (m *VulnerabilityHistoryMutation) ResetSeverity() {
	m.severity = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldSeverity)
}

// SetScore sets the "score" field.
func (m *VulnerabilityHistoryMutation) SetScore(f float64) {
	m.score = &f
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *VulnerabilityHistoryMutation) Score() (r float64, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds f to the "score" field.
func (m *VulnerabilityHistoryMutation) AddScore(f float64) {
	if m.addscore != nil {
		*m.addscore += f
	} else {
		m.addscore = &f
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *VulnerabilityHistoryMutation) AddedScore() (r float64, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *VulnerabilityHistoryMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[vulnerabilityhistory.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *VulnerabilityHistoryMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldScore)
}

// SetImpact sets the "impact" field.
func (m *VulnerabilityHistoryMutation) SetImpact(f float64) {
	m.impact = &f
	m.addimpact = nil
}

// Impact returns the value of the "impact" field in the mutation.
func (m *VulnerabilityHistoryMutation) Impact() (r float64, exists bool) {
	v := m.impact
	if v == nil {
		return
	}
	return *v, true
}

// OldImpact returns the old "impact" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldImpact(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpact: %w", err)
	}
	return oldValue.Impact, nil
}

// AddImpact adds f to the "impact" field.
func (m *VulnerabilityHistoryMutation) AddImpact(f float64) {
	if m.addimpact != nil {
		*m.addimpact += f
	} else {
		m.addimpact = &f
	}
}

// AddedImpact returns the value that was added to the "impact" field in this mutation.
func (m *VulnerabilityHistoryMutation) AddedImpact() (r float64, exists bool) {
	v := m.addimpact
	if v == nil {
		return
	}
	return *v, true
}

// ClearImpact clears the value of the "impact" field.
func (m *VulnerabilityHistoryMutation) ClearImpact() {
	m.impact = nil
	m.addimpact = nil
	m.clearedFields[vulnerabilityhistory.FieldImpact] = struct{}{}
}

// ImpactCleared returns if the "impact" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) ImpactCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldImpact]
	return ok
}

// ResetImpact resets all changes to the "impact" field.
func (m *VulnerabilityHistoryMutation) ResetImpact() {
	m.impact = nil
	m.addimpact = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldImpact)
}

// SetExploitability sets the "exploitability" field.
func (m *VulnerabilityHistoryMutation) SetExploitability(f float64) {
	m.exploitability = &f
	m.addexploitability = nil
}

// Exploitability returns the value of the "exploitability" field in the mutation.
func (m *VulnerabilityHistoryMutation) Exploitability() (r float64, exists bool) {
	v := m.exploitability
	if v == nil {
		return
	}
	return *v, true
}

// OldExploitability returns the old "exploitability" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldExploitability(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExploitability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExploitability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExploitability: %w", err)
	}
	return oldValue.Exploitability, nil
}

// AddExploitability adds f to the "exploitability" field.
func (m *VulnerabilityHistoryMutation) AddExploitability(f float64) {
	if m.addexploitability != nil {
		*m.addexploitability += f
	} else {
		m.addexploitability = &f
	}
}

// AddedExploitability returns the value that was added to the "exploitability" field in this mutation.
func (m *VulnerabilityHistoryMutation) AddedExploitability() (r float64, exists bool) {
	v := m.addexploitability
	if v == nil {
		return
	}
	return *v, true
}

// ClearExploitability clears the value of the "exploitability" field.
func (m *VulnerabilityHistoryMutation) ClearExploitability() {
	m.exploitability = nil
	m.addexploitability = nil
	m.clearedFields[vulnerabilityhistory.FieldExploitability] = struct{}{}
}

// ExploitabilityCleared returns if the "exploitability" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) ExploitabilityCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldExploitability]
	return ok
}

// ResetExploitability resets all changes to the "exploitability" field.
func (m *VulnerabilityHistoryMutation) ResetExploitability() {
	m.exploitability = nil
	m.addexploitability = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldExploitability)
}

// SetPriority sets the "priority" field.
func (m *VulnerabilityHistoryMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *VulnerabilityHistoryMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ClearPriority clears the value of the "priority" field.
func (m *VulnerabilityHistoryMutation) ClearPriority() {
	m.priority = nil
	m.clearedFields[vulnerabilityhistory.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *VulnerabilityHistoryMutation) ResetPriority() {
	m.priority = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldPriority)
}

// SetStatus sets the "status" field.
func (m *VulnerabilityHistoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *VulnerabilityHistoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *VulnerabilityHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[vulnerabilityhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *VulnerabilityHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldStatus)
}

// SetSummary sets the "summary" field.
func (m *VulnerabilityHistoryMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *VulnerabilityHistoryMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *VulnerabilityHistoryMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[vulnerabilityhistory.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *VulnerabilityHistoryMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldSummary)
}

// SetDescription sets the "description" field.
func (m *VulnerabilityHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VulnerabilityHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VulnerabilityHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[vulnerabilityhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VulnerabilityHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldDescription)
}

// SetVector sets the "vector" field.
func (m *VulnerabilityHistoryMutation) SetVector(s string) {
	m.vector = &s
}

// Vector returns the value of the "vector" field in the mutation.
func (m *VulnerabilityHistoryMutation) Vector() (r string, exists bool) {
	v := m.vector
	if v == nil {
		return
	}
	return *v, true
}

// OldVector returns the old "vector" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldVector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVector: %w", err)
	}
	return oldValue.Vector, nil
}

// ClearVector clears the value of the "vector" field.
func (m *VulnerabilityHistoryMutation) ClearVector() {
	m.vector = nil
	m.clearedFields[vulnerabilityhistory.FieldVector] = struct{}{}
}

// VectorCleared returns if the "vector" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) VectorCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldVector]
	return ok
}

// ResetVector resets all changes to the "vector" field.
func (m *VulnerabilityHistoryMutation) ResetVector() {
	m.vector = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldVector)
}

// SetRemediationSLA sets the "remediation_sla" field.
func (m *VulnerabilityHistoryMutation) SetRemediationSLA(i int) {
	m.remediation_sla = &i
	m.addremediation_sla = nil
}

// RemediationSLA returns the value of the "remediation_sla" field in the mutation.
func (m *VulnerabilityHistoryMutation) RemediationSLA() (r int, exists bool) {
	v := m.remediation_sla
	if v == nil {
		return
	}
	return *v, true
}

// OldRemediationSLA returns the old "remediation_sla" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldRemediationSLA(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemediationSLA is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemediationSLA requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemediationSLA: %w", err)
	}
	return oldValue.RemediationSLA, nil
}

// AddRemediationSLA adds i to the "remediation_sla" field.
func (m *VulnerabilityHistoryMutation) AddRemediationSLA(i int) {
	if m.addremediation_sla != nil {
		*m.addremediation_sla += i
	} else {
		m.addremediation_sla = &i
	}
}

// AddedRemediationSLA returns the value that was added to the "remediation_sla" field in this mutation.
func (m *VulnerabilityHistoryMutation) AddedRemediationSLA() (r int, exists bool) {
	v := m.addremediation_sla
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemediationSLA clears the value of the "remediation_sla" field.
func (m *VulnerabilityHistoryMutation) ClearRemediationSLA() {
	m.remediation_sla = nil
	m.addremediation_sla = nil
	m.clearedFields[vulnerabilityhistory.FieldRemediationSLA] = struct{}{}
}

// RemediationSLACleared returns if the "remediation_sla" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) RemediationSLACleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldRemediationSLA]
	return ok
}

// ResetRemediationSLA resets all changes to the "remediation_sla" field.
func (m *VulnerabilityHistoryMutation) ResetRemediationSLA() {
	m.remediation_sla = nil
	m.addremediation_sla = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldRemediationSLA)
}

// SetOpen sets the "open" field.
func (m *VulnerabilityHistoryMutation) SetOpen(b bool) {
	m.open = &b
}

// Open returns the value of the "open" field in the mutation.
func (m *VulnerabilityHistoryMutation) Open() (r bool, exists bool) {
	v := m.open
	if v == nil {
		return
	}
	return *v, true
}

// OldOpen returns the old "open" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldOpen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpen: %w", err)
	}
	return oldValue.Open, nil
}

// ClearOpen clears the value of the "open" field.
func (m *VulnerabilityHistoryMutation) ClearOpen() {
	m.open = nil
	m.clearedFields[vulnerabilityhistory.FieldOpen] = struct{}{}
}

// OpenCleared returns if the "open" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) OpenCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldOpen]
	return ok
}

// ResetOpen resets all changes to the "open" field.
func (m *VulnerabilityHistoryMutation) ResetOpen() {
	m.open = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldOpen)
}

// SetBlocking sets the "blocking" field.
func (m *VulnerabilityHistoryMutation) SetBlocking(b bool) {
	m.blocking = &b
}

// Blocking returns the value of the "blocking" field in the mutation.
func (m *VulnerabilityHistoryMutation) Blocking() (r bool, exists bool) {
	v := m.blocking
	if v == nil {
		return
	}
	return *v, true
}

// OldBlocking returns the old "blocking" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldBlocking(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlocking is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlocking requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlocking: %w", err)
	}
	return oldValue.Blocking, nil
}

// ClearBlocking clears the value of the "blocking" field.
func (m *VulnerabilityHistoryMutation) ClearBlocking() {
	m.blocking = nil
	m.clearedFields[vulnerabilityhistory.FieldBlocking] = struct{}{}
}

// BlockingCleared returns if the "blocking" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) BlockingCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldBlocking]
	return ok
}

// ResetBlocking resets all changes to the "blocking" field.
func (m *VulnerabilityHistoryMutation) ResetBlocking() {
	m.blocking = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldBlocking)
}

// SetProduction sets the "production" field.
func (m *VulnerabilityHistoryMutation) SetProduction(b bool) {
	m.production = &b
}

// Production returns the value of the "production" field in the mutation.
func (m *VulnerabilityHistoryMutation) Production() (r bool, exists bool) {
	v := m.production
	if v == nil {
		return
	}
	return *v, true
}

// OldProduction returns the old "production" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldProduction(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProduction: %w", err)
	}
	return oldValue.Production, nil
}

// ClearProduction clears the value of the "production" field.
func (m *VulnerabilityHistoryMutation) ClearProduction() {
	m.production = nil
	m.clearedFields[vulnerabilityhistory.FieldProduction] = struct{}{}
}

// ProductionCleared returns if the "production" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) ProductionCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldProduction]
	return ok
}

// ResetProduction resets all changes to the "production" field.
func (m *VulnerabilityHistoryMutation) ResetProduction() {
	m.production = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldProduction)
}

// SetPublic sets the "public" field.
func (m *VulnerabilityHistoryMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *VulnerabilityHistoryMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ClearPublic clears the value of the "public" field.
func (m *VulnerabilityHistoryMutation) ClearPublic() {
	m.public = nil
	m.clearedFields[vulnerabilityhistory.FieldPublic] = struct{}{}
}

// PublicCleared returns if the "public" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) PublicCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldPublic]
	return ok
}

// ResetPublic resets all changes to the "public" field.
func (m *VulnerabilityHistoryMutation) ResetPublic() {
	m.public = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldPublic)
}

// SetValidated sets the "validated" field.
func (m *VulnerabilityHistoryMutation) SetValidated(b bool) {
	m.validated = &b
}

// Validated returns the value of the "validated" field in the mutation.
func (m *VulnerabilityHistoryMutation) Validated() (r bool, exists bool) {
	v := m.validated
	if v == nil {
		return
	}
	return *v, true
}

// OldValidated returns the old "validated" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldValidated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidated: %w", err)
	}
	return oldValue.Validated, nil
}

// ClearValidated clears the value of the "validated" field.
func (m *VulnerabilityHistoryMutation) ClearValidated() {
	m.validated = nil
	m.clearedFields[vulnerabilityhistory.FieldValidated] = struct{}{}
}

// ValidatedCleared returns if the "validated" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) ValidatedCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldValidated]
	return ok
}

// ResetValidated resets all changes to the "validated" field.
func (m *VulnerabilityHistoryMutation) ResetValidated() {
	m.validated = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldValidated)
}

// SetReferences sets the "references" field.
func (m *VulnerabilityHistoryMutation) SetReferences(s []string) {
	m.references = &s
	m.appendreferences = nil
}

// References returns the value of the "references" field in the mutation.
func (m *VulnerabilityHistoryMutation) References() (r []string, exists bool) {
	v := m.references
	if v == nil {
		return
	}
	return *v, true
}

// OldReferences returns the old "references" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldReferences(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferences: %w", err)
	}
	return oldValue.References, nil
}

// AppendReferences adds s to the "references" field.
func (m *VulnerabilityHistoryMutation) AppendReferences(s []string) {
	m.appendreferences = append(m.appendreferences, s...)
}

// AppendedReferences returns the list of values that were appended to the "references" field in this mutation.
func (m *VulnerabilityHistoryMutation) AppendedReferences() ([]string, bool) {
	if len(m.appendreferences) == 0 {
		return nil, false
	}
	return m.appendreferences, true
}

// ClearReferences clears the value of the "references" field.
func (m *VulnerabilityHistoryMutation) ClearReferences() {
	m.references = nil
	m.appendreferences = nil
	m.clearedFields[vulnerabilityhistory.FieldReferences] = struct{}{}
}

// ReferencesCleared returns if the "references" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) ReferencesCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldReferences]
	return ok
}

// ResetReferences resets all changes to the "references" field.
func (m *VulnerabilityHistoryMutation) ResetReferences() {
	m.references = nil
	m.appendreferences = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldReferences)
}

// SetImpacts sets the "impacts" field.
func (m *VulnerabilityHistoryMutation) SetImpacts(s []string) {
	m.impacts = &s
	m.appendimpacts = nil
}

// Impacts returns the value of the "impacts" field in the mutation.
func (m *VulnerabilityHistoryMutation) Impacts() (r []string, exists bool) {
	v := m.impacts
	if v == nil {
		return
	}
	return *v, true
}

// OldImpacts returns the old "impacts" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldImpacts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpacts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpacts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpacts: %w", err)
	}
	return oldValue.Impacts, nil
}

// AppendImpacts adds s to the "impacts" field.
func (m *VulnerabilityHistoryMutation) AppendImpacts(s []string) {
	m.appendimpacts = append(m.appendimpacts, s...)
}

// AppendedImpacts returns the list of values that were appended to the "impacts" field in this mutation.
func (m *VulnerabilityHistoryMutation) AppendedImpacts() ([]string, bool) {
	if len(m.appendimpacts) == 0 {
		return nil, false
	}
	return m.appendimpacts, true
}

// ClearImpacts clears the value of the "impacts" field.
func (m *VulnerabilityHistoryMutation) ClearImpacts() {
	m.impacts = nil
	m.appendimpacts = nil
	m.clearedFields[vulnerabilityhistory.FieldImpacts] = struct{}{}
}

// ImpactsCleared returns if the "impacts" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) ImpactsCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldImpacts]
	return ok
}

// ResetImpacts resets all changes to the "impacts" field.
func (m *VulnerabilityHistoryMutation) ResetImpacts() {
	m.impacts = nil
	m.appendimpacts = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldImpacts)
}

// SetPublishedAt sets the "published_at" field.
func (m *VulnerabilityHistoryMutation) SetPublishedAt(mt models.DateTime) {
	m.published_at = &mt
}

// PublishedAt returns the value of the "published_at" field in the mutation.
func (m *VulnerabilityHistoryMutation) PublishedAt() (r models.DateTime, exists bool) {
	v := m.published_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "published_at" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldPublishedAt(ctx context.Context) (v *models.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ClearPublishedAt clears the value of the "published_at" field.
func (m *VulnerabilityHistoryMutation) ClearPublishedAt() {
	m.published_at = nil
	m.clearedFields[vulnerabilityhistory.FieldPublishedAt] = struct{}{}
}

// PublishedAtCleared returns if the "published_at" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) PublishedAtCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldPublishedAt]
	return ok
}

// ResetPublishedAt resets all changes to the "published_at" field.
func (m *VulnerabilityHistoryMutation) ResetPublishedAt() {
	m.published_at = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldPublishedAt)
}

// SetDiscoveredAt sets the "discovered_at" field.
func (m *VulnerabilityHistoryMutation) SetDiscoveredAt(mt models.DateTime) {
	m.discovered_at = &mt
}

// DiscoveredAt returns the value of the "discovered_at" field in the mutation.
func (m *VulnerabilityHistoryMutation) DiscoveredAt() (r models.DateTime, exists bool) {
	v := m.discovered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveredAt returns the old "discovered_at" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldDiscoveredAt(ctx context.Context) (v *models.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveredAt: %w", err)
	}
	return oldValue.DiscoveredAt, nil
}

// ClearDiscoveredAt clears the value of the "discovered_at" field.
func (m *VulnerabilityHistoryMutation) ClearDiscoveredAt() {
	m.discovered_at = nil
	m.clearedFields[vulnerabilityhistory.FieldDiscoveredAt] = struct{}{}
}

// DiscoveredAtCleared returns if the "discovered_at" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) DiscoveredAtCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldDiscoveredAt]
	return ok
}

// ResetDiscoveredAt resets all changes to the "discovered_at" field.
func (m *VulnerabilityHistoryMutation) ResetDiscoveredAt() {
	m.discovered_at = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldDiscoveredAt)
}

// SetSourceUpdatedAt sets the "source_updated_at" field.
func (m *VulnerabilityHistoryMutation) SetSourceUpdatedAt(mt models.DateTime) {
	m.source_updated_at = &mt
}

// SourceUpdatedAt returns the value of the "source_updated_at" field in the mutation.
func (m *VulnerabilityHistoryMutation) SourceUpdatedAt() (r models.DateTime, exists bool) {
	v := m.source_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceUpdatedAt returns the old "source_updated_at" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldSourceUpdatedAt(ctx context.Context) (v *models.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceUpdatedAt: %w", err)
	}
	return oldValue.SourceUpdatedAt, nil
}

// ClearSourceUpdatedAt clears the value of the "source_updated_at" field.
func (m *VulnerabilityHistoryMutation) ClearSourceUpdatedAt() {
	m.source_updated_at = nil
	m.clearedFields[vulnerabilityhistory.FieldSourceUpdatedAt] = struct{}{}
}

// SourceUpdatedAtCleared returns if the "source_updated_at" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) SourceUpdatedAtCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldSourceUpdatedAt]
	return ok
}

// ResetSourceUpdatedAt resets all changes to the "source_updated_at" field.
func (m *VulnerabilityHistoryMutation) ResetSourceUpdatedAt() {
	m.source_updated_at = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldSourceUpdatedAt)
}

// SetExternalURI sets the "external_uri" field.
func (m *VulnerabilityHistoryMutation) SetExternalURI(s string) {
	m.external_uri = &s
}

// ExternalURI returns the value of the "external_uri" field in the mutation.
func (m *VulnerabilityHistoryMutation) ExternalURI() (r string, exists bool) {
	v := m.external_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalURI returns the old "external_uri" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldExternalURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalURI: %w", err)
	}
	return oldValue.ExternalURI, nil
}

// ClearExternalURI clears the value of the "external_uri" field.
func (m *VulnerabilityHistoryMutation) ClearExternalURI() {
	m.external_uri = nil
	m.clearedFields[vulnerabilityhistory.FieldExternalURI] = struct{}{}
}

// ExternalURICleared returns if the "external_uri" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) ExternalURICleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldExternalURI]
	return ok
}

// ResetExternalURI resets all changes to the "external_uri" field.
func (m *VulnerabilityHistoryMutation) ResetExternalURI() {
	m.external_uri = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldExternalURI)
}

// SetMetadata sets the "metadata" field.
func (m *VulnerabilityHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *VulnerabilityHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *VulnerabilityHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[vulnerabilityhistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *VulnerabilityHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldMetadata)
}

// SetRawPayload sets the "raw_payload" field.
func (m *VulnerabilityHistoryMutation) SetRawPayload(value map[string]interface{}) {
	m.raw_payload = &value
}

// RawPayload returns the value of the "raw_payload" field in the mutation.
func (m *VulnerabilityHistoryMutation) RawPayload() (r map[string]interface{}, exists bool) {
	v := m.raw_payload
	if v == nil {
		return
	}
	return *v, true
}

// OldRawPayload returns the old "raw_payload" field's value of the VulnerabilityHistory entity.
// If the VulnerabilityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityHistoryMutation) OldRawPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawPayload: %w", err)
	}
	return oldValue.RawPayload, nil
}

// ClearRawPayload clears the value of the "raw_payload" field.
func (m *VulnerabilityHistoryMutation) ClearRawPayload() {
	m.raw_payload = nil
	m.clearedFields[vulnerabilityhistory.FieldRawPayload] = struct{}{}
}

// RawPayloadCleared returns if the "raw_payload" field was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) RawPayloadCleared() bool {
	_, ok := m.clearedFields[vulnerabilityhistory.FieldRawPayload]
	return ok
}

// ResetRawPayload resets all changes to the "raw_payload" field.
func (m *VulnerabilityHistoryMutation) ResetRawPayload() {
	m.raw_payload = nil
	delete(m.clearedFields, vulnerabilityhistory.FieldRawPayload)
}

// Where appends a list predicates to the VulnerabilityHistoryMutation builder.
func (m *VulnerabilityHistoryMutation) Where(ps ...predicate.VulnerabilityHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VulnerabilityHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VulnerabilityHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VulnerabilityHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VulnerabilityHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VulnerabilityHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VulnerabilityHistory).
func (m *VulnerabilityHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnerabilityHistoryMutation) Fields() []string {
	fields := make([]string, 0, 44)
	if m.history_time != nil {
		fields = append(fields, vulnerabilityhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, vulnerabilityhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, vulnerabilityhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, vulnerabilityhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vulnerabilityhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, vulnerabilityhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, vulnerabilityhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, vulnerabilityhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, vulnerabilityhistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, vulnerabilityhistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, vulnerabilityhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, vulnerabilityhistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, vulnerabilityhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, vulnerabilityhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, vulnerabilityhistory.FieldSystemInternalID)
	}
	if m.external_owner_id != nil {
		fields = append(fields, vulnerabilityhistory.FieldExternalOwnerID)
	}
	if m.external_id != nil {
		fields = append(fields, vulnerabilityhistory.FieldExternalID)
	}
	if m.cve_id != nil {
		fields = append(fields, vulnerabilityhistory.FieldCveID)
	}
	if m.source != nil {
		fields = append(fields, vulnerabilityhistory.FieldSource)
	}
	if m.display_name != nil {
		fields = append(fields, vulnerabilityhistory.FieldDisplayName)
	}
	if m.category != nil {
		fields = append(fields, vulnerabilityhistory.FieldCategory)
	}
	if m.severity != nil {
		fields = append(fields, vulnerabilityhistory.FieldSeverity)
	}
	if m.score != nil {
		fields = append(fields, vulnerabilityhistory.FieldScore)
	}
	if m.impact != nil {
		fields = append(fields, vulnerabilityhistory.FieldImpact)
	}
	if m.exploitability != nil {
		fields = append(fields, vulnerabilityhistory.FieldExploitability)
	}
	if m.priority != nil {
		fields = append(fields, vulnerabilityhistory.FieldPriority)
	}
	if m.status != nil {
		fields = append(fields, vulnerabilityhistory.FieldStatus)
	}
	if m.summary != nil {
		fields = append(fields, vulnerabilityhistory.FieldSummary)
	}
	if m.description != nil {
		fields = append(fields, vulnerabilityhistory.FieldDescription)
	}
	if m.vector != nil {
		fields = append(fields, vulnerabilityhistory.FieldVector)
	}
	if m.remediation_sla != nil {
		fields = append(fields, vulnerabilityhistory.FieldRemediationSLA)
	}
	if m.open != nil {
		fields = append(fields, vulnerabilityhistory.FieldOpen)
	}
	if m.blocking != nil {
		fields = append(fields, vulnerabilityhistory.FieldBlocking)
	}
	if m.production != nil {
		fields = append(fields, vulnerabilityhistory.FieldProduction)
	}
	if m.public != nil {
		fields = append(fields, vulnerabilityhistory.FieldPublic)
	}
	if m.validated != nil {
		fields = append(fields, vulnerabilityhistory.FieldValidated)
	}
	if m.references != nil {
		fields = append(fields, vulnerabilityhistory.FieldReferences)
	}
	if m.impacts != nil {
		fields = append(fields, vulnerabilityhistory.FieldImpacts)
	}
	if m.published_at != nil {
		fields = append(fields, vulnerabilityhistory.FieldPublishedAt)
	}
	if m.discovered_at != nil {
		fields = append(fields, vulnerabilityhistory.FieldDiscoveredAt)
	}
	if m.source_updated_at != nil {
		fields = append(fields, vulnerabilityhistory.FieldSourceUpdatedAt)
	}
	if m.external_uri != nil {
		fields = append(fields, vulnerabilityhistory.FieldExternalURI)
	}
	if m.metadata != nil {
		fields = append(fields, vulnerabilityhistory.FieldMetadata)
	}
	if m.raw_payload != nil {
		fields = append(fields, vulnerabilityhistory.FieldRawPayload)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnerabilityHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vulnerabilityhistory.FieldHistoryTime:
		return m.HistoryTime()
	case vulnerabilityhistory.FieldRef:
		return m.Ref()
	case vulnerabilityhistory.FieldOperation:
		return m.Operation()
	case vulnerabilityhistory.FieldCreatedAt:
		return m.CreatedAt()
	case vulnerabilityhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case vulnerabilityhistory.FieldCreatedBy:
		return m.CreatedBy()
	case vulnerabilityhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case vulnerabilityhistory.FieldDeletedAt:
		return m.DeletedAt()
	case vulnerabilityhistory.FieldDeletedBy:
		return m.DeletedBy()
	case vulnerabilityhistory.FieldDisplayID:
		return m.DisplayID()
	case vulnerabilityhistory.FieldTags:
		return m.Tags()
	case vulnerabilityhistory.FieldOwnerID:
		return m.OwnerID()
	case vulnerabilityhistory.FieldSystemOwned:
		return m.SystemOwned()
	case vulnerabilityhistory.FieldInternalNotes:
		return m.InternalNotes()
	case vulnerabilityhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case vulnerabilityhistory.FieldExternalOwnerID:
		return m.ExternalOwnerID()
	case vulnerabilityhistory.FieldExternalID:
		return m.ExternalID()
	case vulnerabilityhistory.FieldCveID:
		return m.CveID()
	case vulnerabilityhistory.FieldSource:
		return m.Source()
	case vulnerabilityhistory.FieldDisplayName:
		return m.DisplayName()
	case vulnerabilityhistory.FieldCategory:
		return m.Category()
	case vulnerabilityhistory.FieldSeverity:
		return m.Severity()
	case vulnerabilityhistory.FieldScore:
		return m.Score()
	case vulnerabilityhistory.FieldImpact:
		return m.Impact()
	case vulnerabilityhistory.FieldExploitability:
		return m.Exploitability()
	case vulnerabilityhistory.FieldPriority:
		return m.Priority()
	case vulnerabilityhistory.FieldStatus:
		return m.Status()
	case vulnerabilityhistory.FieldSummary:
		return m.Summary()
	case vulnerabilityhistory.FieldDescription:
		return m.Description()
	case vulnerabilityhistory.FieldVector:
		return m.Vector()
	case vulnerabilityhistory.FieldRemediationSLA:
		return m.RemediationSLA()
	case vulnerabilityhistory.FieldOpen:
		return m.Open()
	case vulnerabilityhistory.FieldBlocking:
		return m.Blocking()
	case vulnerabilityhistory.FieldProduction:
		return m.Production()
	case vulnerabilityhistory.FieldPublic:
		return m.Public()
	case vulnerabilityhistory.FieldValidated:
		return m.Validated()
	case vulnerabilityhistory.FieldReferences:
		return m.References()
	case vulnerabilityhistory.FieldImpacts:
		return m.Impacts()
	case vulnerabilityhistory.FieldPublishedAt:
		return m.PublishedAt()
	case vulnerabilityhistory.FieldDiscoveredAt:
		return m.DiscoveredAt()
	case vulnerabilityhistory.FieldSourceUpdatedAt:
		return m.SourceUpdatedAt()
	case vulnerabilityhistory.FieldExternalURI:
		return m.ExternalURI()
	case vulnerabilityhistory.FieldMetadata:
		return m.Metadata()
	case vulnerabilityhistory.FieldRawPayload:
		return m.RawPayload()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnerabilityHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vulnerabilityhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case vulnerabilityhistory.FieldRef:
		return m.OldRef(ctx)
	case vulnerabilityhistory.FieldOperation:
		return m.OldOperation(ctx)
	case vulnerabilityhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vulnerabilityhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vulnerabilityhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case vulnerabilityhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case vulnerabilityhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case vulnerabilityhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case vulnerabilityhistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case vulnerabilityhistory.FieldTags:
		return m.OldTags(ctx)
	case vulnerabilityhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case vulnerabilityhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case vulnerabilityhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case vulnerabilityhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case vulnerabilityhistory.FieldExternalOwnerID:
		return m.OldExternalOwnerID(ctx)
	case vulnerabilityhistory.FieldExternalID:
		return m.OldExternalID(ctx)
	case vulnerabilityhistory.FieldCveID:
		return m.OldCveID(ctx)
	case vulnerabilityhistory.FieldSource:
		return m.OldSource(ctx)
	case vulnerabilityhistory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case vulnerabilityhistory.FieldCategory:
		return m.OldCategory(ctx)
	case vulnerabilityhistory.FieldSeverity:
		return m.OldSeverity(ctx)
	case vulnerabilityhistory.FieldScore:
		return m.OldScore(ctx)
	case vulnerabilityhistory.FieldImpact:
		return m.OldImpact(ctx)
	case vulnerabilityhistory.FieldExploitability:
		return m.OldExploitability(ctx)
	case vulnerabilityhistory.FieldPriority:
		return m.OldPriority(ctx)
	case vulnerabilityhistory.FieldStatus:
		return m.OldStatus(ctx)
	case vulnerabilityhistory.FieldSummary:
		return m.OldSummary(ctx)
	case vulnerabilityhistory.FieldDescription:
		return m.OldDescription(ctx)
	case vulnerabilityhistory.FieldVector:
		return m.OldVector(ctx)
	case vulnerabilityhistory.FieldRemediationSLA:
		return m.OldRemediationSLA(ctx)
	case vulnerabilityhistory.FieldOpen:
		return m.OldOpen(ctx)
	case vulnerabilityhistory.FieldBlocking:
		return m.OldBlocking(ctx)
	case vulnerabilityhistory.FieldProduction:
		return m.OldProduction(ctx)
	case vulnerabilityhistory.FieldPublic:
		return m.OldPublic(ctx)
	case vulnerabilityhistory.FieldValidated:
		return m.OldValidated(ctx)
	case vulnerabilityhistory.FieldReferences:
		return m.OldReferences(ctx)
	case vulnerabilityhistory.FieldImpacts:
		return m.OldImpacts(ctx)
	case vulnerabilityhistory.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	case vulnerabilityhistory.FieldDiscoveredAt:
		return m.OldDiscoveredAt(ctx)
	case vulnerabilityhistory.FieldSourceUpdatedAt:
		return m.OldSourceUpdatedAt(ctx)
	case vulnerabilityhistory.FieldExternalURI:
		return m.OldExternalURI(ctx)
	case vulnerabilityhistory.FieldMetadata:
		return m.OldMetadata(ctx)
	case vulnerabilityhistory.FieldRawPayload:
		return m.OldRawPayload(ctx)
	}
	return nil, fmt.Errorf("unknown VulnerabilityHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vulnerabilityhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case vulnerabilityhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case vulnerabilityhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case vulnerabilityhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vulnerabilityhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vulnerabilityhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case vulnerabilityhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case vulnerabilityhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case vulnerabilityhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case vulnerabilityhistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case vulnerabilityhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case vulnerabilityhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case vulnerabilityhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case vulnerabilityhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case vulnerabilityhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case vulnerabilityhistory.FieldExternalOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalOwnerID(v)
		return nil
	case vulnerabilityhistory.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case vulnerabilityhistory.FieldCveID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCveID(v)
		return nil
	case vulnerabilityhistory.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case vulnerabilityhistory.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case vulnerabilityhistory.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case vulnerabilityhistory.FieldSeverity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case vulnerabilityhistory.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case vulnerabilityhistory.FieldImpact:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpact(v)
		return nil
	case vulnerabilityhistory.FieldExploitability:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExploitability(v)
		return nil
	case vulnerabilityhistory.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case vulnerabilityhistory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case vulnerabilityhistory.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case vulnerabilityhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case vulnerabilityhistory.FieldVector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVector(v)
		return nil
	case vulnerabilityhistory.FieldRemediationSLA:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemediationSLA(v)
		return nil
	case vulnerabilityhistory.FieldOpen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpen(v)
		return nil
	case vulnerabilityhistory.FieldBlocking:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlocking(v)
		return nil
	case vulnerabilityhistory.FieldProduction:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProduction(v)
		return nil
	case vulnerabilityhistory.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case vulnerabilityhistory.FieldValidated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidated(v)
		return nil
	case vulnerabilityhistory.FieldReferences:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferences(v)
		return nil
	case vulnerabilityhistory.FieldImpacts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpacts(v)
		return nil
	case vulnerabilityhistory.FieldPublishedAt:
		v, ok := value.(models.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case vulnerabilityhistory.FieldDiscoveredAt:
		v, ok := value.(models.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveredAt(v)
		return nil
	case vulnerabilityhistory.FieldSourceUpdatedAt:
		v, ok := value.(models.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceUpdatedAt(v)
		return nil
	case vulnerabilityhistory.FieldExternalURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalURI(v)
		return nil
	case vulnerabilityhistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case vulnerabilityhistory.FieldRawPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawPayload(v)
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnerabilityHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, vulnerabilityhistory.FieldScore)
	}
	if m.addimpact != nil {
		fields = append(fields, vulnerabilityhistory.FieldImpact)
	}
	if m.addexploitability != nil {
		fields = append(fields, vulnerabilityhistory.FieldExploitability)
	}
	if m.addremediation_sla != nil {
		fields = append(fields, vulnerabilityhistory.FieldRemediationSLA)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnerabilityHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vulnerabilityhistory.FieldScore:
		return m.AddedScore()
	case vulnerabilityhistory.FieldImpact:
		return m.AddedImpact()
	case vulnerabilityhistory.FieldExploitability:
		return m.AddedExploitability()
	case vulnerabilityhistory.FieldRemediationSLA:
		return m.AddedRemediationSLA()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vulnerabilityhistory.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case vulnerabilityhistory.FieldImpact:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImpact(v)
		return nil
	case vulnerabilityhistory.FieldExploitability:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExploitability(v)
		return nil
	case vulnerabilityhistory.FieldRemediationSLA:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemediationSLA(v)
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnerabilityHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vulnerabilityhistory.FieldRef) {
		fields = append(fields, vulnerabilityhistory.FieldRef)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldCreatedAt) {
		fields = append(fields, vulnerabilityhistory.FieldCreatedAt)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldUpdatedAt) {
		fields = append(fields, vulnerabilityhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldCreatedBy) {
		fields = append(fields, vulnerabilityhistory.FieldCreatedBy)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldUpdatedBy) {
		fields = append(fields, vulnerabilityhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldDeletedAt) {
		fields = append(fields, vulnerabilityhistory.FieldDeletedAt)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldDeletedBy) {
		fields = append(fields, vulnerabilityhistory.FieldDeletedBy)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldTags) {
		fields = append(fields, vulnerabilityhistory.FieldTags)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldOwnerID) {
		fields = append(fields, vulnerabilityhistory.FieldOwnerID)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldSystemOwned) {
		fields = append(fields, vulnerabilityhistory.FieldSystemOwned)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldInternalNotes) {
		fields = append(fields, vulnerabilityhistory.FieldInternalNotes)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldSystemInternalID) {
		fields = append(fields, vulnerabilityhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldExternalOwnerID) {
		fields = append(fields, vulnerabilityhistory.FieldExternalOwnerID)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldCveID) {
		fields = append(fields, vulnerabilityhistory.FieldCveID)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldSource) {
		fields = append(fields, vulnerabilityhistory.FieldSource)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldDisplayName) {
		fields = append(fields, vulnerabilityhistory.FieldDisplayName)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldCategory) {
		fields = append(fields, vulnerabilityhistory.FieldCategory)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldSeverity) {
		fields = append(fields, vulnerabilityhistory.FieldSeverity)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldScore) {
		fields = append(fields, vulnerabilityhistory.FieldScore)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldImpact) {
		fields = append(fields, vulnerabilityhistory.FieldImpact)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldExploitability) {
		fields = append(fields, vulnerabilityhistory.FieldExploitability)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldPriority) {
		fields = append(fields, vulnerabilityhistory.FieldPriority)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldStatus) {
		fields = append(fields, vulnerabilityhistory.FieldStatus)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldSummary) {
		fields = append(fields, vulnerabilityhistory.FieldSummary)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldDescription) {
		fields = append(fields, vulnerabilityhistory.FieldDescription)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldVector) {
		fields = append(fields, vulnerabilityhistory.FieldVector)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldRemediationSLA) {
		fields = append(fields, vulnerabilityhistory.FieldRemediationSLA)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldOpen) {
		fields = append(fields, vulnerabilityhistory.FieldOpen)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldBlocking) {
		fields = append(fields, vulnerabilityhistory.FieldBlocking)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldProduction) {
		fields = append(fields, vulnerabilityhistory.FieldProduction)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldPublic) {
		fields = append(fields, vulnerabilityhistory.FieldPublic)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldValidated) {
		fields = append(fields, vulnerabilityhistory.FieldValidated)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldReferences) {
		fields = append(fields, vulnerabilityhistory.FieldReferences)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldImpacts) {
		fields = append(fields, vulnerabilityhistory.FieldImpacts)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldPublishedAt) {
		fields = append(fields, vulnerabilityhistory.FieldPublishedAt)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldDiscoveredAt) {
		fields = append(fields, vulnerabilityhistory.FieldDiscoveredAt)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldSourceUpdatedAt) {
		fields = append(fields, vulnerabilityhistory.FieldSourceUpdatedAt)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldExternalURI) {
		fields = append(fields, vulnerabilityhistory.FieldExternalURI)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldMetadata) {
		fields = append(fields, vulnerabilityhistory.FieldMetadata)
	}
	if m.FieldCleared(vulnerabilityhistory.FieldRawPayload) {
		fields = append(fields, vulnerabilityhistory.FieldRawPayload)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnerabilityHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnerabilityHistoryMutation) ClearField(name string) error {
	switch name {
	case vulnerabilityhistory.FieldRef:
		m.ClearRef()
		return nil
	case vulnerabilityhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case vulnerabilityhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case vulnerabilityhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case vulnerabilityhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case vulnerabilityhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case vulnerabilityhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case vulnerabilityhistory.FieldTags:
		m.ClearTags()
		return nil
	case vulnerabilityhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case vulnerabilityhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case vulnerabilityhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case vulnerabilityhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case vulnerabilityhistory.FieldExternalOwnerID:
		m.ClearExternalOwnerID()
		return nil
	case vulnerabilityhistory.FieldCveID:
		m.ClearCveID()
		return nil
	case vulnerabilityhistory.FieldSource:
		m.ClearSource()
		return nil
	case vulnerabilityhistory.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case vulnerabilityhistory.FieldCategory:
		m.ClearCategory()
		return nil
	case vulnerabilityhistory.FieldSeverity:
		m.ClearSeverity()
		return nil
	case vulnerabilityhistory.FieldScore:
		m.ClearScore()
		return nil
	case vulnerabilityhistory.FieldImpact:
		m.ClearImpact()
		return nil
	case vulnerabilityhistory.FieldExploitability:
		m.ClearExploitability()
		return nil
	case vulnerabilityhistory.FieldPriority:
		m.ClearPriority()
		return nil
	case vulnerabilityhistory.FieldStatus:
		m.ClearStatus()
		return nil
	case vulnerabilityhistory.FieldSummary:
		m.ClearSummary()
		return nil
	case vulnerabilityhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case vulnerabilityhistory.FieldVector:
		m.ClearVector()
		return nil
	case vulnerabilityhistory.FieldRemediationSLA:
		m.ClearRemediationSLA()
		return nil
	case vulnerabilityhistory.FieldOpen:
		m.ClearOpen()
		return nil
	case vulnerabilityhistory.FieldBlocking:
		m.ClearBlocking()
		return nil
	case vulnerabilityhistory.FieldProduction:
		m.ClearProduction()
		return nil
	case vulnerabilityhistory.FieldPublic:
		m.ClearPublic()
		return nil
	case vulnerabilityhistory.FieldValidated:
		m.ClearValidated()
		return nil
	case vulnerabilityhistory.FieldReferences:
		m.ClearReferences()
		return nil
	case vulnerabilityhistory.FieldImpacts:
		m.ClearImpacts()
		return nil
	case vulnerabilityhistory.FieldPublishedAt:
		m.ClearPublishedAt()
		return nil
	case vulnerabilityhistory.FieldDiscoveredAt:
		m.ClearDiscoveredAt()
		return nil
	case vulnerabilityhistory.FieldSourceUpdatedAt:
		m.ClearSourceUpdatedAt()
		return nil
	case vulnerabilityhistory.FieldExternalURI:
		m.ClearExternalURI()
		return nil
	case vulnerabilityhistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	case vulnerabilityhistory.FieldRawPayload:
		m.ClearRawPayload()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnerabilityHistoryMutation) ResetField(name string) error {
	switch name {
	case vulnerabilityhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case vulnerabilityhistory.FieldRef:
		m.ResetRef()
		return nil
	case vulnerabilityhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case vulnerabilityhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vulnerabilityhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vulnerabilityhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case vulnerabilityhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case vulnerabilityhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case vulnerabilityhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case vulnerabilityhistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case vulnerabilityhistory.FieldTags:
		m.ResetTags()
		return nil
	case vulnerabilityhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case vulnerabilityhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case vulnerabilityhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case vulnerabilityhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case vulnerabilityhistory.FieldExternalOwnerID:
		m.ResetExternalOwnerID()
		return nil
	case vulnerabilityhistory.FieldExternalID:
		m.ResetExternalID()
		return nil
	case vulnerabilityhistory.FieldCveID:
		m.ResetCveID()
		return nil
	case vulnerabilityhistory.FieldSource:
		m.ResetSource()
		return nil
	case vulnerabilityhistory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case vulnerabilityhistory.FieldCategory:
		m.ResetCategory()
		return nil
	case vulnerabilityhistory.FieldSeverity:
		m.ResetSeverity()
		return nil
	case vulnerabilityhistory.FieldScore:
		m.ResetScore()
		return nil
	case vulnerabilityhistory.FieldImpact:
		m.ResetImpact()
		return nil
	case vulnerabilityhistory.FieldExploitability:
		m.ResetExploitability()
		return nil
	case vulnerabilityhistory.FieldPriority:
		m.ResetPriority()
		return nil
	case vulnerabilityhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case vulnerabilityhistory.FieldSummary:
		m.ResetSummary()
		return nil
	case vulnerabilityhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case vulnerabilityhistory.FieldVector:
		m.ResetVector()
		return nil
	case vulnerabilityhistory.FieldRemediationSLA:
		m.ResetRemediationSLA()
		return nil
	case vulnerabilityhistory.FieldOpen:
		m.ResetOpen()
		return nil
	case vulnerabilityhistory.FieldBlocking:
		m.ResetBlocking()
		return nil
	case vulnerabilityhistory.FieldProduction:
		m.ResetProduction()
		return nil
	case vulnerabilityhistory.FieldPublic:
		m.ResetPublic()
		return nil
	case vulnerabilityhistory.FieldValidated:
		m.ResetValidated()
		return nil
	case vulnerabilityhistory.FieldReferences:
		m.ResetReferences()
		return nil
	case vulnerabilityhistory.FieldImpacts:
		m.ResetImpacts()
		return nil
	case vulnerabilityhistory.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case vulnerabilityhistory.FieldDiscoveredAt:
		m.ResetDiscoveredAt()
		return nil
	case vulnerabilityhistory.FieldSourceUpdatedAt:
		m.ResetSourceUpdatedAt()
		return nil
	case vulnerabilityhistory.FieldExternalURI:
		m.ResetExternalURI()
		return nil
	case vulnerabilityhistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	case vulnerabilityhistory.FieldRawPayload:
		m.ResetRawPayload()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnerabilityHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnerabilityHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnerabilityHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnerabilityHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnerabilityHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnerabilityHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnerabilityHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VulnerabilityHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnerabilityHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VulnerabilityHistory edge %s", name)
}

// WorkflowAssignmentHistoryMutation represents an operation that mutates the WorkflowAssignmentHistory nodes in the graph.
type WorkflowAssignmentHistoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	history_time         *time.Time
	ref                  *string
	operation            *history.OpType
	created_at           *time.Time
	updated_at           *time.Time
	created_by           *string
	updated_by           *string
	deleted_at           *time.Time
	deleted_by           *string
	display_id           *string
	tags                 *[]string
	appendtags           []string
	owner_id             *string
	workflow_instance_id *string
	assignment_key       *string
	role                 *string
	label                *string
	required             *bool
	status               *enums.WorkflowAssignmentStatus
	metadata             *map[string]interface{}
	decided_at           *time.Time
	actor_user_id        *string
	actor_group_id       *string
	notes                *string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*WorkflowAssignmentHistory, error)
	predicates           []predicate.WorkflowAssignmentHistory
}

var _ ent.Mutation = (*WorkflowAssignmentHistoryMutation)(nil)

// workflowassignmenthistoryOption allows management of the mutation configuration using functional options.
type workflowassignmenthistoryOption func(*WorkflowAssignmentHistoryMutation)

// newWorkflowAssignmentHistoryMutation creates new mutation for the WorkflowAssignmentHistory entity.
func newWorkflowAssignmentHistoryMutation(c config, op Op, opts ...workflowassignmenthistoryOption) *WorkflowAssignmentHistoryMutation {
	m := &WorkflowAssignmentHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowAssignmentHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowAssignmentHistoryID sets the ID field of the mutation.
func withWorkflowAssignmentHistoryID(id string) workflowassignmenthistoryOption {
	return func(m *WorkflowAssignmentHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowAssignmentHistory
		)
		m.oldValue = func(ctx context.Context) (*WorkflowAssignmentHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowAssignmentHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowAssignmentHistory sets the old WorkflowAssignmentHistory of the mutation.
func withWorkflowAssignmentHistory(node *WorkflowAssignmentHistory) workflowassignmenthistoryOption {
	return func(m *WorkflowAssignmentHistoryMutation) {
		m.oldValue = func(context.Context) (*WorkflowAssignmentHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowAssignmentHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowAssignmentHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowAssignmentHistory entities.
func (m *WorkflowAssignmentHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowAssignmentHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowAssignmentHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowAssignmentHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *WorkflowAssignmentHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *WorkflowAssignmentHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *WorkflowAssignmentHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *WorkflowAssignmentHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[workflowassignmenthistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[workflowassignmenthistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *WorkflowAssignmentHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, workflowassignmenthistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *WorkflowAssignmentHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *WorkflowAssignmentHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowAssignmentHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *WorkflowAssignmentHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[workflowassignmenthistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[workflowassignmenthistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowAssignmentHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, workflowassignmenthistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowAssignmentHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *WorkflowAssignmentHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[workflowassignmenthistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[workflowassignmenthistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowAssignmentHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, workflowassignmenthistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *WorkflowAssignmentHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *WorkflowAssignmentHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[workflowassignmenthistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[workflowassignmenthistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WorkflowAssignmentHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, workflowassignmenthistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *WorkflowAssignmentHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *WorkflowAssignmentHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[workflowassignmenthistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[workflowassignmenthistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *WorkflowAssignmentHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, workflowassignmenthistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WorkflowAssignmentHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WorkflowAssignmentHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[workflowassignmenthistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[workflowassignmenthistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WorkflowAssignmentHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, workflowassignmenthistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *WorkflowAssignmentHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *WorkflowAssignmentHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[workflowassignmenthistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[workflowassignmenthistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *WorkflowAssignmentHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, workflowassignmenthistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *WorkflowAssignmentHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *WorkflowAssignmentHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *WorkflowAssignmentHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *WorkflowAssignmentHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *WorkflowAssignmentHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *WorkflowAssignmentHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[workflowassignmenthistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[workflowassignmenthistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *WorkflowAssignmentHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, workflowassignmenthistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *WorkflowAssignmentHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *WorkflowAssignmentHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[workflowassignmenthistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[workflowassignmenthistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *WorkflowAssignmentHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, workflowassignmenthistory.FieldOwnerID)
}

// SetWorkflowInstanceID sets the "workflow_instance_id" field.
func (m *WorkflowAssignmentHistoryMutation) SetWorkflowInstanceID(s string) {
	m.workflow_instance_id = &s
}

// WorkflowInstanceID returns the value of the "workflow_instance_id" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) WorkflowInstanceID() (r string, exists bool) {
	v := m.workflow_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowInstanceID returns the old "workflow_instance_id" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldWorkflowInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowInstanceID: %w", err)
	}
	return oldValue.WorkflowInstanceID, nil
}

// ResetWorkflowInstanceID resets all changes to the "workflow_instance_id" field.
func (m *WorkflowAssignmentHistoryMutation) ResetWorkflowInstanceID() {
	m.workflow_instance_id = nil
}

// SetAssignmentKey sets the "assignment_key" field.
func (m *WorkflowAssignmentHistoryMutation) SetAssignmentKey(s string) {
	m.assignment_key = &s
}

// AssignmentKey returns the value of the "assignment_key" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) AssignmentKey() (r string, exists bool) {
	v := m.assignment_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignmentKey returns the old "assignment_key" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldAssignmentKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignmentKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignmentKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignmentKey: %w", err)
	}
	return oldValue.AssignmentKey, nil
}

// ResetAssignmentKey resets all changes to the "assignment_key" field.
func (m *WorkflowAssignmentHistoryMutation) ResetAssignmentKey() {
	m.assignment_key = nil
}

// SetRole sets the "role" field.
func (m *WorkflowAssignmentHistoryMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *WorkflowAssignmentHistoryMutation) ResetRole() {
	m.role = nil
}

// SetLabel sets the "label" field.
func (m *WorkflowAssignmentHistoryMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ClearLabel clears the value of the "label" field.
func (m *WorkflowAssignmentHistoryMutation) ClearLabel() {
	m.label = nil
	m.clearedFields[workflowassignmenthistory.FieldLabel] = struct{}{}
}

// LabelCleared returns if the "label" field was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) LabelCleared() bool {
	_, ok := m.clearedFields[workflowassignmenthistory.FieldLabel]
	return ok
}

// ResetLabel resets all changes to the "label" field.
func (m *WorkflowAssignmentHistoryMutation) ResetLabel() {
	m.label = nil
	delete(m.clearedFields, workflowassignmenthistory.FieldLabel)
}

// SetRequired sets the "required" field.
func (m *WorkflowAssignmentHistoryMutation) SetRequired(b bool) {
	m.required = &b
}

// Required returns the value of the "required" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) Required() (r bool, exists bool) {
	v := m.required
	if v == nil {
		return
	}
	return *v, true
}

// OldRequired returns the old "required" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequired: %w", err)
	}
	return oldValue.Required, nil
}

// ResetRequired resets all changes to the "required" field.
func (m *WorkflowAssignmentHistoryMutation) ResetRequired() {
	m.required = nil
}

// SetStatus sets the "status" field.
func (m *WorkflowAssignmentHistoryMutation) SetStatus(eas enums.WorkflowAssignmentStatus) {
	m.status = &eas
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) Status() (r enums.WorkflowAssignmentStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldStatus(ctx context.Context) (v enums.WorkflowAssignmentStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkflowAssignmentHistoryMutation) ResetStatus() {
	m.status = nil
}

// SetMetadata sets the "metadata" field.
func (m *WorkflowAssignmentHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *WorkflowAssignmentHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[workflowassignmenthistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[workflowassignmenthistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *WorkflowAssignmentHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, workflowassignmenthistory.FieldMetadata)
}

// SetDecidedAt sets the "decided_at" field.
func (m *WorkflowAssignmentHistoryMutation) SetDecidedAt(t time.Time) {
	m.decided_at = &t
}

// DecidedAt returns the value of the "decided_at" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) DecidedAt() (r time.Time, exists bool) {
	v := m.decided_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDecidedAt returns the old "decided_at" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldDecidedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDecidedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDecidedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDecidedAt: %w", err)
	}
	return oldValue.DecidedAt, nil
}

// ClearDecidedAt clears the value of the "decided_at" field.
func (m *WorkflowAssignmentHistoryMutation) ClearDecidedAt() {
	m.decided_at = nil
	m.clearedFields[workflowassignmenthistory.FieldDecidedAt] = struct{}{}
}

// DecidedAtCleared returns if the "decided_at" field was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) DecidedAtCleared() bool {
	_, ok := m.clearedFields[workflowassignmenthistory.FieldDecidedAt]
	return ok
}

// ResetDecidedAt resets all changes to the "decided_at" field.
func (m *WorkflowAssignmentHistoryMutation) ResetDecidedAt() {
	m.decided_at = nil
	delete(m.clearedFields, workflowassignmenthistory.FieldDecidedAt)
}

// SetActorUserID sets the "actor_user_id" field.
func (m *WorkflowAssignmentHistoryMutation) SetActorUserID(s string) {
	m.actor_user_id = &s
}

// ActorUserID returns the value of the "actor_user_id" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) ActorUserID() (r string, exists bool) {
	v := m.actor_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldActorUserID returns the old "actor_user_id" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldActorUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActorUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActorUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActorUserID: %w", err)
	}
	return oldValue.ActorUserID, nil
}

// ClearActorUserID clears the value of the "actor_user_id" field.
func (m *WorkflowAssignmentHistoryMutation) ClearActorUserID() {
	m.actor_user_id = nil
	m.clearedFields[workflowassignmenthistory.FieldActorUserID] = struct{}{}
}

// ActorUserIDCleared returns if the "actor_user_id" field was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) ActorUserIDCleared() bool {
	_, ok := m.clearedFields[workflowassignmenthistory.FieldActorUserID]
	return ok
}

// ResetActorUserID resets all changes to the "actor_user_id" field.
func (m *WorkflowAssignmentHistoryMutation) ResetActorUserID() {
	m.actor_user_id = nil
	delete(m.clearedFields, workflowassignmenthistory.FieldActorUserID)
}

// SetActorGroupID sets the "actor_group_id" field.
func (m *WorkflowAssignmentHistoryMutation) SetActorGroupID(s string) {
	m.actor_group_id = &s
}

// ActorGroupID returns the value of the "actor_group_id" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) ActorGroupID() (r string, exists bool) {
	v := m.actor_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldActorGroupID returns the old "actor_group_id" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldActorGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActorGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActorGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActorGroupID: %w", err)
	}
	return oldValue.ActorGroupID, nil
}

// ClearActorGroupID clears the value of the "actor_group_id" field.
func (m *WorkflowAssignmentHistoryMutation) ClearActorGroupID() {
	m.actor_group_id = nil
	m.clearedFields[workflowassignmenthistory.FieldActorGroupID] = struct{}{}
}

// ActorGroupIDCleared returns if the "actor_group_id" field was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) ActorGroupIDCleared() bool {
	_, ok := m.clearedFields[workflowassignmenthistory.FieldActorGroupID]
	return ok
}

// ResetActorGroupID resets all changes to the "actor_group_id" field.
func (m *WorkflowAssignmentHistoryMutation) ResetActorGroupID() {
	m.actor_group_id = nil
	delete(m.clearedFields, workflowassignmenthistory.FieldActorGroupID)
}

// SetNotes sets the "notes" field.
func (m *WorkflowAssignmentHistoryMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *WorkflowAssignmentHistoryMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the WorkflowAssignmentHistory entity.
// If the WorkflowAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentHistoryMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *WorkflowAssignmentHistoryMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[workflowassignmenthistory.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) NotesCleared() bool {
	_, ok := m.clearedFields[workflowassignmenthistory.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *WorkflowAssignmentHistoryMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, workflowassignmenthistory.FieldNotes)
}

// Where appends a list predicates to the WorkflowAssignmentHistoryMutation builder.
func (m *WorkflowAssignmentHistoryMutation) Where(ps ...predicate.WorkflowAssignmentHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowAssignmentHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowAssignmentHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowAssignmentHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowAssignmentHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowAssignmentHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowAssignmentHistory).
func (m *WorkflowAssignmentHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowAssignmentHistoryMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.history_time != nil {
		fields = append(fields, workflowassignmenthistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, workflowassignmenthistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, workflowassignmenthistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, workflowassignmenthistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflowassignmenthistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, workflowassignmenthistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, workflowassignmenthistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, workflowassignmenthistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, workflowassignmenthistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, workflowassignmenthistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, workflowassignmenthistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, workflowassignmenthistory.FieldOwnerID)
	}
	if m.workflow_instance_id != nil {
		fields = append(fields, workflowassignmenthistory.FieldWorkflowInstanceID)
	}
	if m.assignment_key != nil {
		fields = append(fields, workflowassignmenthistory.FieldAssignmentKey)
	}
	if m.role != nil {
		fields = append(fields, workflowassignmenthistory.FieldRole)
	}
	if m.label != nil {
		fields = append(fields, workflowassignmenthistory.FieldLabel)
	}
	if m.required != nil {
		fields = append(fields, workflowassignmenthistory.FieldRequired)
	}
	if m.status != nil {
		fields = append(fields, workflowassignmenthistory.FieldStatus)
	}
	if m.metadata != nil {
		fields = append(fields, workflowassignmenthistory.FieldMetadata)
	}
	if m.decided_at != nil {
		fields = append(fields, workflowassignmenthistory.FieldDecidedAt)
	}
	if m.actor_user_id != nil {
		fields = append(fields, workflowassignmenthistory.FieldActorUserID)
	}
	if m.actor_group_id != nil {
		fields = append(fields, workflowassignmenthistory.FieldActorGroupID)
	}
	if m.notes != nil {
		fields = append(fields, workflowassignmenthistory.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowAssignmentHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowassignmenthistory.FieldHistoryTime:
		return m.HistoryTime()
	case workflowassignmenthistory.FieldRef:
		return m.Ref()
	case workflowassignmenthistory.FieldOperation:
		return m.Operation()
	case workflowassignmenthistory.FieldCreatedAt:
		return m.CreatedAt()
	case workflowassignmenthistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case workflowassignmenthistory.FieldCreatedBy:
		return m.CreatedBy()
	case workflowassignmenthistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case workflowassignmenthistory.FieldDeletedAt:
		return m.DeletedAt()
	case workflowassignmenthistory.FieldDeletedBy:
		return m.DeletedBy()
	case workflowassignmenthistory.FieldDisplayID:
		return m.DisplayID()
	case workflowassignmenthistory.FieldTags:
		return m.Tags()
	case workflowassignmenthistory.FieldOwnerID:
		return m.OwnerID()
	case workflowassignmenthistory.FieldWorkflowInstanceID:
		return m.WorkflowInstanceID()
	case workflowassignmenthistory.FieldAssignmentKey:
		return m.AssignmentKey()
	case workflowassignmenthistory.FieldRole:
		return m.Role()
	case workflowassignmenthistory.FieldLabel:
		return m.Label()
	case workflowassignmenthistory.FieldRequired:
		return m.Required()
	case workflowassignmenthistory.FieldStatus:
		return m.Status()
	case workflowassignmenthistory.FieldMetadata:
		return m.Metadata()
	case workflowassignmenthistory.FieldDecidedAt:
		return m.DecidedAt()
	case workflowassignmenthistory.FieldActorUserID:
		return m.ActorUserID()
	case workflowassignmenthistory.FieldActorGroupID:
		return m.ActorGroupID()
	case workflowassignmenthistory.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowAssignmentHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowassignmenthistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case workflowassignmenthistory.FieldRef:
		return m.OldRef(ctx)
	case workflowassignmenthistory.FieldOperation:
		return m.OldOperation(ctx)
	case workflowassignmenthistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflowassignmenthistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workflowassignmenthistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case workflowassignmenthistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case workflowassignmenthistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case workflowassignmenthistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case workflowassignmenthistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case workflowassignmenthistory.FieldTags:
		return m.OldTags(ctx)
	case workflowassignmenthistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case workflowassignmenthistory.FieldWorkflowInstanceID:
		return m.OldWorkflowInstanceID(ctx)
	case workflowassignmenthistory.FieldAssignmentKey:
		return m.OldAssignmentKey(ctx)
	case workflowassignmenthistory.FieldRole:
		return m.OldRole(ctx)
	case workflowassignmenthistory.FieldLabel:
		return m.OldLabel(ctx)
	case workflowassignmenthistory.FieldRequired:
		return m.OldRequired(ctx)
	case workflowassignmenthistory.FieldStatus:
		return m.OldStatus(ctx)
	case workflowassignmenthistory.FieldMetadata:
		return m.OldMetadata(ctx)
	case workflowassignmenthistory.FieldDecidedAt:
		return m.OldDecidedAt(ctx)
	case workflowassignmenthistory.FieldActorUserID:
		return m.OldActorUserID(ctx)
	case workflowassignmenthistory.FieldActorGroupID:
		return m.OldActorGroupID(ctx)
	case workflowassignmenthistory.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowAssignmentHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowAssignmentHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowassignmenthistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case workflowassignmenthistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case workflowassignmenthistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case workflowassignmenthistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflowassignmenthistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workflowassignmenthistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case workflowassignmenthistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case workflowassignmenthistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case workflowassignmenthistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case workflowassignmenthistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case workflowassignmenthistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case workflowassignmenthistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case workflowassignmenthistory.FieldWorkflowInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowInstanceID(v)
		return nil
	case workflowassignmenthistory.FieldAssignmentKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignmentKey(v)
		return nil
	case workflowassignmenthistory.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case workflowassignmenthistory.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case workflowassignmenthistory.FieldRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequired(v)
		return nil
	case workflowassignmenthistory.FieldStatus:
		v, ok := value.(enums.WorkflowAssignmentStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workflowassignmenthistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case workflowassignmenthistory.FieldDecidedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDecidedAt(v)
		return nil
	case workflowassignmenthistory.FieldActorUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActorUserID(v)
		return nil
	case workflowassignmenthistory.FieldActorGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActorGroupID(v)
		return nil
	case workflowassignmenthistory.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowAssignmentHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowAssignmentHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowAssignmentHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowAssignmentHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkflowAssignmentHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowAssignmentHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowassignmenthistory.FieldRef) {
		fields = append(fields, workflowassignmenthistory.FieldRef)
	}
	if m.FieldCleared(workflowassignmenthistory.FieldCreatedAt) {
		fields = append(fields, workflowassignmenthistory.FieldCreatedAt)
	}
	if m.FieldCleared(workflowassignmenthistory.FieldUpdatedAt) {
		fields = append(fields, workflowassignmenthistory.FieldUpdatedAt)
	}
	if m.FieldCleared(workflowassignmenthistory.FieldCreatedBy) {
		fields = append(fields, workflowassignmenthistory.FieldCreatedBy)
	}
	if m.FieldCleared(workflowassignmenthistory.FieldUpdatedBy) {
		fields = append(fields, workflowassignmenthistory.FieldUpdatedBy)
	}
	if m.FieldCleared(workflowassignmenthistory.FieldDeletedAt) {
		fields = append(fields, workflowassignmenthistory.FieldDeletedAt)
	}
	if m.FieldCleared(workflowassignmenthistory.FieldDeletedBy) {
		fields = append(fields, workflowassignmenthistory.FieldDeletedBy)
	}
	if m.FieldCleared(workflowassignmenthistory.FieldTags) {
		fields = append(fields, workflowassignmenthistory.FieldTags)
	}
	if m.FieldCleared(workflowassignmenthistory.FieldOwnerID) {
		fields = append(fields, workflowassignmenthistory.FieldOwnerID)
	}
	if m.FieldCleared(workflowassignmenthistory.FieldLabel) {
		fields = append(fields, workflowassignmenthistory.FieldLabel)
	}
	if m.FieldCleared(workflowassignmenthistory.FieldMetadata) {
		fields = append(fields, workflowassignmenthistory.FieldMetadata)
	}
	if m.FieldCleared(workflowassignmenthistory.FieldDecidedAt) {
		fields = append(fields, workflowassignmenthistory.FieldDecidedAt)
	}
	if m.FieldCleared(workflowassignmenthistory.FieldActorUserID) {
		fields = append(fields, workflowassignmenthistory.FieldActorUserID)
	}
	if m.FieldCleared(workflowassignmenthistory.FieldActorGroupID) {
		fields = append(fields, workflowassignmenthistory.FieldActorGroupID)
	}
	if m.FieldCleared(workflowassignmenthistory.FieldNotes) {
		fields = append(fields, workflowassignmenthistory.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowAssignmentHistoryMutation) ClearField(name string) error {
	switch name {
	case workflowassignmenthistory.FieldRef:
		m.ClearRef()
		return nil
	case workflowassignmenthistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case workflowassignmenthistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case workflowassignmenthistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case workflowassignmenthistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case workflowassignmenthistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case workflowassignmenthistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case workflowassignmenthistory.FieldTags:
		m.ClearTags()
		return nil
	case workflowassignmenthistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case workflowassignmenthistory.FieldLabel:
		m.ClearLabel()
		return nil
	case workflowassignmenthistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	case workflowassignmenthistory.FieldDecidedAt:
		m.ClearDecidedAt()
		return nil
	case workflowassignmenthistory.FieldActorUserID:
		m.ClearActorUserID()
		return nil
	case workflowassignmenthistory.FieldActorGroupID:
		m.ClearActorGroupID()
		return nil
	case workflowassignmenthistory.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown WorkflowAssignmentHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowAssignmentHistoryMutation) ResetField(name string) error {
	switch name {
	case workflowassignmenthistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case workflowassignmenthistory.FieldRef:
		m.ResetRef()
		return nil
	case workflowassignmenthistory.FieldOperation:
		m.ResetOperation()
		return nil
	case workflowassignmenthistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflowassignmenthistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workflowassignmenthistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case workflowassignmenthistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case workflowassignmenthistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case workflowassignmenthistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case workflowassignmenthistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case workflowassignmenthistory.FieldTags:
		m.ResetTags()
		return nil
	case workflowassignmenthistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case workflowassignmenthistory.FieldWorkflowInstanceID:
		m.ResetWorkflowInstanceID()
		return nil
	case workflowassignmenthistory.FieldAssignmentKey:
		m.ResetAssignmentKey()
		return nil
	case workflowassignmenthistory.FieldRole:
		m.ResetRole()
		return nil
	case workflowassignmenthistory.FieldLabel:
		m.ResetLabel()
		return nil
	case workflowassignmenthistory.FieldRequired:
		m.ResetRequired()
		return nil
	case workflowassignmenthistory.FieldStatus:
		m.ResetStatus()
		return nil
	case workflowassignmenthistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	case workflowassignmenthistory.FieldDecidedAt:
		m.ResetDecidedAt()
		return nil
	case workflowassignmenthistory.FieldActorUserID:
		m.ResetActorUserID()
		return nil
	case workflowassignmenthistory.FieldActorGroupID:
		m.ResetActorGroupID()
		return nil
	case workflowassignmenthistory.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown WorkflowAssignmentHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowAssignmentHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowAssignmentHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowAssignmentHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowAssignmentHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowAssignmentHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowAssignmentHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WorkflowAssignmentHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowAssignmentHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WorkflowAssignmentHistory edge %s", name)
}

// WorkflowAssignmentTargetHistoryMutation represents an operation that mutates the WorkflowAssignmentTargetHistory nodes in the graph.
type WorkflowAssignmentTargetHistoryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	history_time           *time.Time
	ref                    *string
	operation              *history.OpType
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	deleted_at             *time.Time
	deleted_by             *string
	display_id             *string
	tags                   *[]string
	appendtags             []string
	owner_id               *string
	workflow_assignment_id *string
	target_type            *enums.WorkflowTargetType
	target_user_id         *string
	target_group_id        *string
	resolver_key           *string
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*WorkflowAssignmentTargetHistory, error)
	predicates             []predicate.WorkflowAssignmentTargetHistory
}

var _ ent.Mutation = (*WorkflowAssignmentTargetHistoryMutation)(nil)

// workflowassignmenttargethistoryOption allows management of the mutation configuration using functional options.
type workflowassignmenttargethistoryOption func(*WorkflowAssignmentTargetHistoryMutation)

// newWorkflowAssignmentTargetHistoryMutation creates new mutation for the WorkflowAssignmentTargetHistory entity.
func newWorkflowAssignmentTargetHistoryMutation(c config, op Op, opts ...workflowassignmenttargethistoryOption) *WorkflowAssignmentTargetHistoryMutation {
	m := &WorkflowAssignmentTargetHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowAssignmentTargetHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowAssignmentTargetHistoryID sets the ID field of the mutation.
func withWorkflowAssignmentTargetHistoryID(id string) workflowassignmenttargethistoryOption {
	return func(m *WorkflowAssignmentTargetHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowAssignmentTargetHistory
		)
		m.oldValue = func(ctx context.Context) (*WorkflowAssignmentTargetHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowAssignmentTargetHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowAssignmentTargetHistory sets the old WorkflowAssignmentTargetHistory of the mutation.
func withWorkflowAssignmentTargetHistory(node *WorkflowAssignmentTargetHistory) workflowassignmenttargethistoryOption {
	return func(m *WorkflowAssignmentTargetHistoryMutation) {
		m.oldValue = func(context.Context) (*WorkflowAssignmentTargetHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowAssignmentTargetHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowAssignmentTargetHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowAssignmentTargetHistory entities.
func (m *WorkflowAssignmentTargetHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowAssignmentTargetHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowAssignmentTargetHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[workflowassignmenttargethistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[workflowassignmenttargethistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, workflowassignmenttargethistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[workflowassignmenttargethistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[workflowassignmenttargethistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, workflowassignmenttargethistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[workflowassignmenttargethistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[workflowassignmenttargethistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, workflowassignmenttargethistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[workflowassignmenttargethistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[workflowassignmenttargethistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, workflowassignmenttargethistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[workflowassignmenttargethistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[workflowassignmenttargethistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, workflowassignmenttargethistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[workflowassignmenttargethistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[workflowassignmenttargethistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, workflowassignmenttargethistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[workflowassignmenttargethistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[workflowassignmenttargethistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, workflowassignmenttargethistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *WorkflowAssignmentTargetHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[workflowassignmenttargethistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[workflowassignmenttargethistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, workflowassignmenttargethistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[workflowassignmenttargethistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[workflowassignmenttargethistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, workflowassignmenttargethistory.FieldOwnerID)
}

// SetWorkflowAssignmentID sets the "workflow_assignment_id" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetWorkflowAssignmentID(s string) {
	m.workflow_assignment_id = &s
}

// WorkflowAssignmentID returns the value of the "workflow_assignment_id" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) WorkflowAssignmentID() (r string, exists bool) {
	v := m.workflow_assignment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowAssignmentID returns the old "workflow_assignment_id" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldWorkflowAssignmentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowAssignmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowAssignmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowAssignmentID: %w", err)
	}
	return oldValue.WorkflowAssignmentID, nil
}

// ResetWorkflowAssignmentID resets all changes to the "workflow_assignment_id" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetWorkflowAssignmentID() {
	m.workflow_assignment_id = nil
}

// SetTargetType sets the "target_type" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetTargetType(ett enums.WorkflowTargetType) {
	m.target_type = &ett
}

// TargetType returns the value of the "target_type" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) TargetType() (r enums.WorkflowTargetType, exists bool) {
	v := m.target_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetType returns the old "target_type" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldTargetType(ctx context.Context) (v enums.WorkflowTargetType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetType: %w", err)
	}
	return oldValue.TargetType, nil
}

// ResetTargetType resets all changes to the "target_type" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetTargetType() {
	m.target_type = nil
}

// SetTargetUserID sets the "target_user_id" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetTargetUserID(s string) {
	m.target_user_id = &s
}

// TargetUserID returns the value of the "target_user_id" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) TargetUserID() (r string, exists bool) {
	v := m.target_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetUserID returns the old "target_user_id" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldTargetUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetUserID: %w", err)
	}
	return oldValue.TargetUserID, nil
}

// ClearTargetUserID clears the value of the "target_user_id" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearTargetUserID() {
	m.target_user_id = nil
	m.clearedFields[workflowassignmenttargethistory.FieldTargetUserID] = struct{}{}
}

// TargetUserIDCleared returns if the "target_user_id" field was cleared in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) TargetUserIDCleared() bool {
	_, ok := m.clearedFields[workflowassignmenttargethistory.FieldTargetUserID]
	return ok
}

// ResetTargetUserID resets all changes to the "target_user_id" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetTargetUserID() {
	m.target_user_id = nil
	delete(m.clearedFields, workflowassignmenttargethistory.FieldTargetUserID)
}

// SetTargetGroupID sets the "target_group_id" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetTargetGroupID(s string) {
	m.target_group_id = &s
}

// TargetGroupID returns the value of the "target_group_id" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) TargetGroupID() (r string, exists bool) {
	v := m.target_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetGroupID returns the old "target_group_id" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldTargetGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetGroupID: %w", err)
	}
	return oldValue.TargetGroupID, nil
}

// ClearTargetGroupID clears the value of the "target_group_id" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearTargetGroupID() {
	m.target_group_id = nil
	m.clearedFields[workflowassignmenttargethistory.FieldTargetGroupID] = struct{}{}
}

// TargetGroupIDCleared returns if the "target_group_id" field was cleared in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) TargetGroupIDCleared() bool {
	_, ok := m.clearedFields[workflowassignmenttargethistory.FieldTargetGroupID]
	return ok
}

// ResetTargetGroupID resets all changes to the "target_group_id" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetTargetGroupID() {
	m.target_group_id = nil
	delete(m.clearedFields, workflowassignmenttargethistory.FieldTargetGroupID)
}

// SetResolverKey sets the "resolver_key" field.
func (m *WorkflowAssignmentTargetHistoryMutation) SetResolverKey(s string) {
	m.resolver_key = &s
}

// ResolverKey returns the value of the "resolver_key" field in the mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) ResolverKey() (r string, exists bool) {
	v := m.resolver_key
	if v == nil {
		return
	}
	return *v, true
}

// OldResolverKey returns the old "resolver_key" field's value of the WorkflowAssignmentTargetHistory entity.
// If the WorkflowAssignmentTargetHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowAssignmentTargetHistoryMutation) OldResolverKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolverKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolverKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolverKey: %w", err)
	}
	return oldValue.ResolverKey, nil
}

// ClearResolverKey clears the value of the "resolver_key" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearResolverKey() {
	m.resolver_key = nil
	m.clearedFields[workflowassignmenttargethistory.FieldResolverKey] = struct{}{}
}

// ResolverKeyCleared returns if the "resolver_key" field was cleared in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) ResolverKeyCleared() bool {
	_, ok := m.clearedFields[workflowassignmenttargethistory.FieldResolverKey]
	return ok
}

// ResetResolverKey resets all changes to the "resolver_key" field.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetResolverKey() {
	m.resolver_key = nil
	delete(m.clearedFields, workflowassignmenttargethistory.FieldResolverKey)
}

// Where appends a list predicates to the WorkflowAssignmentTargetHistoryMutation builder.
func (m *WorkflowAssignmentTargetHistoryMutation) Where(ps ...predicate.WorkflowAssignmentTargetHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowAssignmentTargetHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowAssignmentTargetHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowAssignmentTargetHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowAssignmentTargetHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowAssignmentTargetHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowAssignmentTargetHistory).
func (m *WorkflowAssignmentTargetHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowAssignmentTargetHistoryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.history_time != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldOwnerID)
	}
	if m.workflow_assignment_id != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldWorkflowAssignmentID)
	}
	if m.target_type != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldTargetType)
	}
	if m.target_user_id != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldTargetUserID)
	}
	if m.target_group_id != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldTargetGroupID)
	}
	if m.resolver_key != nil {
		fields = append(fields, workflowassignmenttargethistory.FieldResolverKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowAssignmentTargetHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowassignmenttargethistory.FieldHistoryTime:
		return m.HistoryTime()
	case workflowassignmenttargethistory.FieldRef:
		return m.Ref()
	case workflowassignmenttargethistory.FieldOperation:
		return m.Operation()
	case workflowassignmenttargethistory.FieldCreatedAt:
		return m.CreatedAt()
	case workflowassignmenttargethistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case workflowassignmenttargethistory.FieldCreatedBy:
		return m.CreatedBy()
	case workflowassignmenttargethistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case workflowassignmenttargethistory.FieldDeletedAt:
		return m.DeletedAt()
	case workflowassignmenttargethistory.FieldDeletedBy:
		return m.DeletedBy()
	case workflowassignmenttargethistory.FieldDisplayID:
		return m.DisplayID()
	case workflowassignmenttargethistory.FieldTags:
		return m.Tags()
	case workflowassignmenttargethistory.FieldOwnerID:
		return m.OwnerID()
	case workflowassignmenttargethistory.FieldWorkflowAssignmentID:
		return m.WorkflowAssignmentID()
	case workflowassignmenttargethistory.FieldTargetType:
		return m.TargetType()
	case workflowassignmenttargethistory.FieldTargetUserID:
		return m.TargetUserID()
	case workflowassignmenttargethistory.FieldTargetGroupID:
		return m.TargetGroupID()
	case workflowassignmenttargethistory.FieldResolverKey:
		return m.ResolverKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowAssignmentTargetHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowassignmenttargethistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case workflowassignmenttargethistory.FieldRef:
		return m.OldRef(ctx)
	case workflowassignmenttargethistory.FieldOperation:
		return m.OldOperation(ctx)
	case workflowassignmenttargethistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflowassignmenttargethistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workflowassignmenttargethistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case workflowassignmenttargethistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case workflowassignmenttargethistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case workflowassignmenttargethistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case workflowassignmenttargethistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case workflowassignmenttargethistory.FieldTags:
		return m.OldTags(ctx)
	case workflowassignmenttargethistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case workflowassignmenttargethistory.FieldWorkflowAssignmentID:
		return m.OldWorkflowAssignmentID(ctx)
	case workflowassignmenttargethistory.FieldTargetType:
		return m.OldTargetType(ctx)
	case workflowassignmenttargethistory.FieldTargetUserID:
		return m.OldTargetUserID(ctx)
	case workflowassignmenttargethistory.FieldTargetGroupID:
		return m.OldTargetGroupID(ctx)
	case workflowassignmenttargethistory.FieldResolverKey:
		return m.OldResolverKey(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowAssignmentTargetHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowAssignmentTargetHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowassignmenttargethistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case workflowassignmenttargethistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case workflowassignmenttargethistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case workflowassignmenttargethistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflowassignmenttargethistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workflowassignmenttargethistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case workflowassignmenttargethistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case workflowassignmenttargethistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case workflowassignmenttargethistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case workflowassignmenttargethistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case workflowassignmenttargethistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case workflowassignmenttargethistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case workflowassignmenttargethistory.FieldWorkflowAssignmentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowAssignmentID(v)
		return nil
	case workflowassignmenttargethistory.FieldTargetType:
		v, ok := value.(enums.WorkflowTargetType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetType(v)
		return nil
	case workflowassignmenttargethistory.FieldTargetUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetUserID(v)
		return nil
	case workflowassignmenttargethistory.FieldTargetGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetGroupID(v)
		return nil
	case workflowassignmenttargethistory.FieldResolverKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolverKey(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowAssignmentTargetHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowAssignmentTargetHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowAssignmentTargetHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkflowAssignmentTargetHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowassignmenttargethistory.FieldRef) {
		fields = append(fields, workflowassignmenttargethistory.FieldRef)
	}
	if m.FieldCleared(workflowassignmenttargethistory.FieldCreatedAt) {
		fields = append(fields, workflowassignmenttargethistory.FieldCreatedAt)
	}
	if m.FieldCleared(workflowassignmenttargethistory.FieldUpdatedAt) {
		fields = append(fields, workflowassignmenttargethistory.FieldUpdatedAt)
	}
	if m.FieldCleared(workflowassignmenttargethistory.FieldCreatedBy) {
		fields = append(fields, workflowassignmenttargethistory.FieldCreatedBy)
	}
	if m.FieldCleared(workflowassignmenttargethistory.FieldUpdatedBy) {
		fields = append(fields, workflowassignmenttargethistory.FieldUpdatedBy)
	}
	if m.FieldCleared(workflowassignmenttargethistory.FieldDeletedAt) {
		fields = append(fields, workflowassignmenttargethistory.FieldDeletedAt)
	}
	if m.FieldCleared(workflowassignmenttargethistory.FieldDeletedBy) {
		fields = append(fields, workflowassignmenttargethistory.FieldDeletedBy)
	}
	if m.FieldCleared(workflowassignmenttargethistory.FieldTags) {
		fields = append(fields, workflowassignmenttargethistory.FieldTags)
	}
	if m.FieldCleared(workflowassignmenttargethistory.FieldOwnerID) {
		fields = append(fields, workflowassignmenttargethistory.FieldOwnerID)
	}
	if m.FieldCleared(workflowassignmenttargethistory.FieldTargetUserID) {
		fields = append(fields, workflowassignmenttargethistory.FieldTargetUserID)
	}
	if m.FieldCleared(workflowassignmenttargethistory.FieldTargetGroupID) {
		fields = append(fields, workflowassignmenttargethistory.FieldTargetGroupID)
	}
	if m.FieldCleared(workflowassignmenttargethistory.FieldResolverKey) {
		fields = append(fields, workflowassignmenttargethistory.FieldResolverKey)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearField(name string) error {
	switch name {
	case workflowassignmenttargethistory.FieldRef:
		m.ClearRef()
		return nil
	case workflowassignmenttargethistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case workflowassignmenttargethistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case workflowassignmenttargethistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case workflowassignmenttargethistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case workflowassignmenttargethistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case workflowassignmenttargethistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case workflowassignmenttargethistory.FieldTags:
		m.ClearTags()
		return nil
	case workflowassignmenttargethistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case workflowassignmenttargethistory.FieldTargetUserID:
		m.ClearTargetUserID()
		return nil
	case workflowassignmenttargethistory.FieldTargetGroupID:
		m.ClearTargetGroupID()
		return nil
	case workflowassignmenttargethistory.FieldResolverKey:
		m.ClearResolverKey()
		return nil
	}
	return fmt.Errorf("unknown WorkflowAssignmentTargetHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetField(name string) error {
	switch name {
	case workflowassignmenttargethistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case workflowassignmenttargethistory.FieldRef:
		m.ResetRef()
		return nil
	case workflowassignmenttargethistory.FieldOperation:
		m.ResetOperation()
		return nil
	case workflowassignmenttargethistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflowassignmenttargethistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workflowassignmenttargethistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case workflowassignmenttargethistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case workflowassignmenttargethistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case workflowassignmenttargethistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case workflowassignmenttargethistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case workflowassignmenttargethistory.FieldTags:
		m.ResetTags()
		return nil
	case workflowassignmenttargethistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case workflowassignmenttargethistory.FieldWorkflowAssignmentID:
		m.ResetWorkflowAssignmentID()
		return nil
	case workflowassignmenttargethistory.FieldTargetType:
		m.ResetTargetType()
		return nil
	case workflowassignmenttargethistory.FieldTargetUserID:
		m.ResetTargetUserID()
		return nil
	case workflowassignmenttargethistory.FieldTargetGroupID:
		m.ResetTargetGroupID()
		return nil
	case workflowassignmenttargethistory.FieldResolverKey:
		m.ResetResolverKey()
		return nil
	}
	return fmt.Errorf("unknown WorkflowAssignmentTargetHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowAssignmentTargetHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowAssignmentTargetHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WorkflowAssignmentTargetHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowAssignmentTargetHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WorkflowAssignmentTargetHistory edge %s", name)
}

// WorkflowDefinitionHistoryMutation represents an operation that mutates the WorkflowDefinitionHistory nodes in the graph.
type WorkflowDefinitionHistoryMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	history_time             *time.Time
	ref                      *string
	operation                *history.OpType
	created_at               *time.Time
	updated_at               *time.Time
	created_by               *string
	updated_by               *string
	deleted_at               *time.Time
	deleted_by               *string
	display_id               *string
	tags                     *[]string
	appendtags               []string
	owner_id                 *string
	system_owned             *bool
	internal_notes           *string
	system_internal_id       *string
	name                     *string
	description              *string
	workflow_kind            *enums.WorkflowKind
	schema_type              *string
	revision                 *int
	addrevision              *int
	draft                    *bool
	published_at             *time.Time
	cooldown_seconds         *int
	addcooldown_seconds      *int
	is_default               *bool
	active                   *bool
	trigger_operations       *[]string
	appendtrigger_operations []string
	trigger_fields           *[]string
	appendtrigger_fields     []string
	definition_json          *models.WorkflowDefinitionDocument
	tracked_fields           *[]string
	appendtracked_fields     []string
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*WorkflowDefinitionHistory, error)
	predicates               []predicate.WorkflowDefinitionHistory
}

var _ ent.Mutation = (*WorkflowDefinitionHistoryMutation)(nil)

// workflowdefinitionhistoryOption allows management of the mutation configuration using functional options.
type workflowdefinitionhistoryOption func(*WorkflowDefinitionHistoryMutation)

// newWorkflowDefinitionHistoryMutation creates new mutation for the WorkflowDefinitionHistory entity.
func newWorkflowDefinitionHistoryMutation(c config, op Op, opts ...workflowdefinitionhistoryOption) *WorkflowDefinitionHistoryMutation {
	m := &WorkflowDefinitionHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowDefinitionHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowDefinitionHistoryID sets the ID field of the mutation.
func withWorkflowDefinitionHistoryID(id string) workflowdefinitionhistoryOption {
	return func(m *WorkflowDefinitionHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowDefinitionHistory
		)
		m.oldValue = func(ctx context.Context) (*WorkflowDefinitionHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowDefinitionHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowDefinitionHistory sets the old WorkflowDefinitionHistory of the mutation.
func withWorkflowDefinitionHistory(node *WorkflowDefinitionHistory) workflowdefinitionhistoryOption {
	return func(m *WorkflowDefinitionHistoryMutation) {
		m.oldValue = func(context.Context) (*WorkflowDefinitionHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowDefinitionHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowDefinitionHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowDefinitionHistory entities.
func (m *WorkflowDefinitionHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowDefinitionHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowDefinitionHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowDefinitionHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *WorkflowDefinitionHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *WorkflowDefinitionHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *WorkflowDefinitionHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *WorkflowDefinitionHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[workflowdefinitionhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *WorkflowDefinitionHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *WorkflowDefinitionHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *WorkflowDefinitionHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowDefinitionHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *WorkflowDefinitionHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[workflowdefinitionhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowDefinitionHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowDefinitionHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *WorkflowDefinitionHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[workflowdefinitionhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowDefinitionHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *WorkflowDefinitionHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *WorkflowDefinitionHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[workflowdefinitionhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WorkflowDefinitionHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *WorkflowDefinitionHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *WorkflowDefinitionHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[workflowdefinitionhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *WorkflowDefinitionHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WorkflowDefinitionHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WorkflowDefinitionHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[workflowdefinitionhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WorkflowDefinitionHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *WorkflowDefinitionHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *WorkflowDefinitionHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[workflowdefinitionhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *WorkflowDefinitionHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *WorkflowDefinitionHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *WorkflowDefinitionHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *WorkflowDefinitionHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *WorkflowDefinitionHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *WorkflowDefinitionHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *WorkflowDefinitionHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[workflowdefinitionhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *WorkflowDefinitionHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *WorkflowDefinitionHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *WorkflowDefinitionHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[workflowdefinitionhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *WorkflowDefinitionHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldOwnerID)
}

// SetSystemOwned sets the "system_owned" field.
func (m *WorkflowDefinitionHistoryMutation) SetSystemOwned(b bool) {
	m.system_owned = &b
}

// SystemOwned returns the value of the "system_owned" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) SystemOwned() (r bool, exists bool) {
	v := m.system_owned
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemOwned returns the old "system_owned" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldSystemOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemOwned: %w", err)
	}
	return oldValue.SystemOwned, nil
}

// ClearSystemOwned clears the value of the "system_owned" field.
func (m *WorkflowDefinitionHistoryMutation) ClearSystemOwned() {
	m.system_owned = nil
	m.clearedFields[workflowdefinitionhistory.FieldSystemOwned] = struct{}{}
}

// SystemOwnedCleared returns if the "system_owned" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) SystemOwnedCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldSystemOwned]
	return ok
}

// ResetSystemOwned resets all changes to the "system_owned" field.
func (m *WorkflowDefinitionHistoryMutation) ResetSystemOwned() {
	m.system_owned = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldSystemOwned)
}

// SetInternalNotes sets the "internal_notes" field.
func (m *WorkflowDefinitionHistoryMutation) SetInternalNotes(s string) {
	m.internal_notes = &s
}

// InternalNotes returns the value of the "internal_notes" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) InternalNotes() (r string, exists bool) {
	v := m.internal_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNotes returns the old "internal_notes" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldInternalNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNotes: %w", err)
	}
	return oldValue.InternalNotes, nil
}

// ClearInternalNotes clears the value of the "internal_notes" field.
func (m *WorkflowDefinitionHistoryMutation) ClearInternalNotes() {
	m.internal_notes = nil
	m.clearedFields[workflowdefinitionhistory.FieldInternalNotes] = struct{}{}
}

// InternalNotesCleared returns if the "internal_notes" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) InternalNotesCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldInternalNotes]
	return ok
}

// ResetInternalNotes resets all changes to the "internal_notes" field.
func (m *WorkflowDefinitionHistoryMutation) ResetInternalNotes() {
	m.internal_notes = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldInternalNotes)
}

// SetSystemInternalID sets the "system_internal_id" field.
func (m *WorkflowDefinitionHistoryMutation) SetSystemInternalID(s string) {
	m.system_internal_id = &s
}

// SystemInternalID returns the value of the "system_internal_id" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) SystemInternalID() (r string, exists bool) {
	v := m.system_internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInternalID returns the old "system_internal_id" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldSystemInternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInternalID: %w", err)
	}
	return oldValue.SystemInternalID, nil
}

// ClearSystemInternalID clears the value of the "system_internal_id" field.
func (m *WorkflowDefinitionHistoryMutation) ClearSystemInternalID() {
	m.system_internal_id = nil
	m.clearedFields[workflowdefinitionhistory.FieldSystemInternalID] = struct{}{}
}

// SystemInternalIDCleared returns if the "system_internal_id" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) SystemInternalIDCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldSystemInternalID]
	return ok
}

// ResetSystemInternalID resets all changes to the "system_internal_id" field.
func (m *WorkflowDefinitionHistoryMutation) ResetSystemInternalID() {
	m.system_internal_id = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldSystemInternalID)
}

// SetName sets the "name" field.
func (m *WorkflowDefinitionHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkflowDefinitionHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *WorkflowDefinitionHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkflowDefinitionHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workflowdefinitionhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkflowDefinitionHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldDescription)
}

// SetWorkflowKind sets the "workflow_kind" field.
func (m *WorkflowDefinitionHistoryMutation) SetWorkflowKind(ek enums.WorkflowKind) {
	m.workflow_kind = &ek
}

// WorkflowKind returns the value of the "workflow_kind" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) WorkflowKind() (r enums.WorkflowKind, exists bool) {
	v := m.workflow_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowKind returns the old "workflow_kind" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldWorkflowKind(ctx context.Context) (v enums.WorkflowKind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowKind: %w", err)
	}
	return oldValue.WorkflowKind, nil
}

// ResetWorkflowKind resets all changes to the "workflow_kind" field.
func (m *WorkflowDefinitionHistoryMutation) ResetWorkflowKind() {
	m.workflow_kind = nil
}

// SetSchemaType sets the "schema_type" field.
func (m *WorkflowDefinitionHistoryMutation) SetSchemaType(s string) {
	m.schema_type = &s
}

// SchemaType returns the value of the "schema_type" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) SchemaType() (r string, exists bool) {
	v := m.schema_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSchemaType returns the old "schema_type" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldSchemaType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchemaType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchemaType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchemaType: %w", err)
	}
	return oldValue.SchemaType, nil
}

// ResetSchemaType resets all changes to the "schema_type" field.
func (m *WorkflowDefinitionHistoryMutation) ResetSchemaType() {
	m.schema_type = nil
}

// SetRevision sets the "revision" field.
func (m *WorkflowDefinitionHistoryMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *WorkflowDefinitionHistoryMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *WorkflowDefinitionHistoryMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *WorkflowDefinitionHistoryMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetDraft sets the "draft" field.
func (m *WorkflowDefinitionHistoryMutation) SetDraft(b bool) {
	m.draft = &b
}

// Draft returns the value of the "draft" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) Draft() (r bool, exists bool) {
	v := m.draft
	if v == nil {
		return
	}
	return *v, true
}

// OldDraft returns the old "draft" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldDraft(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDraft is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDraft requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDraft: %w", err)
	}
	return oldValue.Draft, nil
}

// ResetDraft resets all changes to the "draft" field.
func (m *WorkflowDefinitionHistoryMutation) ResetDraft() {
	m.draft = nil
}

// SetPublishedAt sets the "published_at" field.
func (m *WorkflowDefinitionHistoryMutation) SetPublishedAt(t time.Time) {
	m.published_at = &t
}

// PublishedAt returns the value of the "published_at" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) PublishedAt() (r time.Time, exists bool) {
	v := m.published_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "published_at" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldPublishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ClearPublishedAt clears the value of the "published_at" field.
func (m *WorkflowDefinitionHistoryMutation) ClearPublishedAt() {
	m.published_at = nil
	m.clearedFields[workflowdefinitionhistory.FieldPublishedAt] = struct{}{}
}

// PublishedAtCleared returns if the "published_at" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) PublishedAtCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldPublishedAt]
	return ok
}

// ResetPublishedAt resets all changes to the "published_at" field.
func (m *WorkflowDefinitionHistoryMutation) ResetPublishedAt() {
	m.published_at = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldPublishedAt)
}

// SetCooldownSeconds sets the "cooldown_seconds" field.
func (m *WorkflowDefinitionHistoryMutation) SetCooldownSeconds(i int) {
	m.cooldown_seconds = &i
	m.addcooldown_seconds = nil
}

// CooldownSeconds returns the value of the "cooldown_seconds" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) CooldownSeconds() (r int, exists bool) {
	v := m.cooldown_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldCooldownSeconds returns the old "cooldown_seconds" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldCooldownSeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCooldownSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCooldownSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCooldownSeconds: %w", err)
	}
	return oldValue.CooldownSeconds, nil
}

// AddCooldownSeconds adds i to the "cooldown_seconds" field.
func (m *WorkflowDefinitionHistoryMutation) AddCooldownSeconds(i int) {
	if m.addcooldown_seconds != nil {
		*m.addcooldown_seconds += i
	} else {
		m.addcooldown_seconds = &i
	}
}

// AddedCooldownSeconds returns the value that was added to the "cooldown_seconds" field in this mutation.
func (m *WorkflowDefinitionHistoryMutation) AddedCooldownSeconds() (r int, exists bool) {
	v := m.addcooldown_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetCooldownSeconds resets all changes to the "cooldown_seconds" field.
func (m *WorkflowDefinitionHistoryMutation) ResetCooldownSeconds() {
	m.cooldown_seconds = nil
	m.addcooldown_seconds = nil
}

// SetIsDefault sets the "is_default" field.
func (m *WorkflowDefinitionHistoryMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *WorkflowDefinitionHistoryMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetActive sets the "active" field.
func (m *WorkflowDefinitionHistoryMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *WorkflowDefinitionHistoryMutation) ResetActive() {
	m.active = nil
}

// SetTriggerOperations sets the "trigger_operations" field.
func (m *WorkflowDefinitionHistoryMutation) SetTriggerOperations(s []string) {
	m.trigger_operations = &s
	m.appendtrigger_operations = nil
}

// TriggerOperations returns the value of the "trigger_operations" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) TriggerOperations() (r []string, exists bool) {
	v := m.trigger_operations
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggerOperations returns the old "trigger_operations" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldTriggerOperations(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggerOperations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggerOperations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggerOperations: %w", err)
	}
	return oldValue.TriggerOperations, nil
}

// AppendTriggerOperations adds s to the "trigger_operations" field.
func (m *WorkflowDefinitionHistoryMutation) AppendTriggerOperations(s []string) {
	m.appendtrigger_operations = append(m.appendtrigger_operations, s...)
}

// AppendedTriggerOperations returns the list of values that were appended to the "trigger_operations" field in this mutation.
func (m *WorkflowDefinitionHistoryMutation) AppendedTriggerOperations() ([]string, bool) {
	if len(m.appendtrigger_operations) == 0 {
		return nil, false
	}
	return m.appendtrigger_operations, true
}

// ClearTriggerOperations clears the value of the "trigger_operations" field.
func (m *WorkflowDefinitionHistoryMutation) ClearTriggerOperations() {
	m.trigger_operations = nil
	m.appendtrigger_operations = nil
	m.clearedFields[workflowdefinitionhistory.FieldTriggerOperations] = struct{}{}
}

// TriggerOperationsCleared returns if the "trigger_operations" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) TriggerOperationsCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldTriggerOperations]
	return ok
}

// ResetTriggerOperations resets all changes to the "trigger_operations" field.
func (m *WorkflowDefinitionHistoryMutation) ResetTriggerOperations() {
	m.trigger_operations = nil
	m.appendtrigger_operations = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldTriggerOperations)
}

// SetTriggerFields sets the "trigger_fields" field.
func (m *WorkflowDefinitionHistoryMutation) SetTriggerFields(s []string) {
	m.trigger_fields = &s
	m.appendtrigger_fields = nil
}

// TriggerFields returns the value of the "trigger_fields" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) TriggerFields() (r []string, exists bool) {
	v := m.trigger_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggerFields returns the old "trigger_fields" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldTriggerFields(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggerFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggerFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggerFields: %w", err)
	}
	return oldValue.TriggerFields, nil
}

// AppendTriggerFields adds s to the "trigger_fields" field.
func (m *WorkflowDefinitionHistoryMutation) AppendTriggerFields(s []string) {
	m.appendtrigger_fields = append(m.appendtrigger_fields, s...)
}

// AppendedTriggerFields returns the list of values that were appended to the "trigger_fields" field in this mutation.
func (m *WorkflowDefinitionHistoryMutation) AppendedTriggerFields() ([]string, bool) {
	if len(m.appendtrigger_fields) == 0 {
		return nil, false
	}
	return m.appendtrigger_fields, true
}

// ClearTriggerFields clears the value of the "trigger_fields" field.
func (m *WorkflowDefinitionHistoryMutation) ClearTriggerFields() {
	m.trigger_fields = nil
	m.appendtrigger_fields = nil
	m.clearedFields[workflowdefinitionhistory.FieldTriggerFields] = struct{}{}
}

// TriggerFieldsCleared returns if the "trigger_fields" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) TriggerFieldsCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldTriggerFields]
	return ok
}

// ResetTriggerFields resets all changes to the "trigger_fields" field.
func (m *WorkflowDefinitionHistoryMutation) ResetTriggerFields() {
	m.trigger_fields = nil
	m.appendtrigger_fields = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldTriggerFields)
}

// SetDefinitionJSON sets the "definition_json" field.
func (m *WorkflowDefinitionHistoryMutation) SetDefinitionJSON(mdd models.WorkflowDefinitionDocument) {
	m.definition_json = &mdd
}

// DefinitionJSON returns the value of the "definition_json" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) DefinitionJSON() (r models.WorkflowDefinitionDocument, exists bool) {
	v := m.definition_json
	if v == nil {
		return
	}
	return *v, true
}

// OldDefinitionJSON returns the old "definition_json" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldDefinitionJSON(ctx context.Context) (v models.WorkflowDefinitionDocument, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefinitionJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefinitionJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefinitionJSON: %w", err)
	}
	return oldValue.DefinitionJSON, nil
}

// ClearDefinitionJSON clears the value of the "definition_json" field.
func (m *WorkflowDefinitionHistoryMutation) ClearDefinitionJSON() {
	m.definition_json = nil
	m.clearedFields[workflowdefinitionhistory.FieldDefinitionJSON] = struct{}{}
}

// DefinitionJSONCleared returns if the "definition_json" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) DefinitionJSONCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldDefinitionJSON]
	return ok
}

// ResetDefinitionJSON resets all changes to the "definition_json" field.
func (m *WorkflowDefinitionHistoryMutation) ResetDefinitionJSON() {
	m.definition_json = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldDefinitionJSON)
}

// SetTrackedFields sets the "tracked_fields" field.
func (m *WorkflowDefinitionHistoryMutation) SetTrackedFields(s []string) {
	m.tracked_fields = &s
	m.appendtracked_fields = nil
}

// TrackedFields returns the value of the "tracked_fields" field in the mutation.
func (m *WorkflowDefinitionHistoryMutation) TrackedFields() (r []string, exists bool) {
	v := m.tracked_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackedFields returns the old "tracked_fields" field's value of the WorkflowDefinitionHistory entity.
// If the WorkflowDefinitionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDefinitionHistoryMutation) OldTrackedFields(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackedFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackedFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackedFields: %w", err)
	}
	return oldValue.TrackedFields, nil
}

// AppendTrackedFields adds s to the "tracked_fields" field.
func (m *WorkflowDefinitionHistoryMutation) AppendTrackedFields(s []string) {
	m.appendtracked_fields = append(m.appendtracked_fields, s...)
}

// AppendedTrackedFields returns the list of values that were appended to the "tracked_fields" field in this mutation.
func (m *WorkflowDefinitionHistoryMutation) AppendedTrackedFields() ([]string, bool) {
	if len(m.appendtracked_fields) == 0 {
		return nil, false
	}
	return m.appendtracked_fields, true
}

// ClearTrackedFields clears the value of the "tracked_fields" field.
func (m *WorkflowDefinitionHistoryMutation) ClearTrackedFields() {
	m.tracked_fields = nil
	m.appendtracked_fields = nil
	m.clearedFields[workflowdefinitionhistory.FieldTrackedFields] = struct{}{}
}

// TrackedFieldsCleared returns if the "tracked_fields" field was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) TrackedFieldsCleared() bool {
	_, ok := m.clearedFields[workflowdefinitionhistory.FieldTrackedFields]
	return ok
}

// ResetTrackedFields resets all changes to the "tracked_fields" field.
func (m *WorkflowDefinitionHistoryMutation) ResetTrackedFields() {
	m.tracked_fields = nil
	m.appendtracked_fields = nil
	delete(m.clearedFields, workflowdefinitionhistory.FieldTrackedFields)
}

// Where appends a list predicates to the WorkflowDefinitionHistoryMutation builder.
func (m *WorkflowDefinitionHistoryMutation) Where(ps ...predicate.WorkflowDefinitionHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowDefinitionHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowDefinitionHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowDefinitionHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowDefinitionHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowDefinitionHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowDefinitionHistory).
func (m *WorkflowDefinitionHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowDefinitionHistoryMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.history_time != nil {
		fields = append(fields, workflowdefinitionhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, workflowdefinitionhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, workflowdefinitionhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, workflowdefinitionhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflowdefinitionhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, workflowdefinitionhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, workflowdefinitionhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, workflowdefinitionhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, workflowdefinitionhistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, workflowdefinitionhistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, workflowdefinitionhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, workflowdefinitionhistory.FieldOwnerID)
	}
	if m.system_owned != nil {
		fields = append(fields, workflowdefinitionhistory.FieldSystemOwned)
	}
	if m.internal_notes != nil {
		fields = append(fields, workflowdefinitionhistory.FieldInternalNotes)
	}
	if m.system_internal_id != nil {
		fields = append(fields, workflowdefinitionhistory.FieldSystemInternalID)
	}
	if m.name != nil {
		fields = append(fields, workflowdefinitionhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, workflowdefinitionhistory.FieldDescription)
	}
	if m.workflow_kind != nil {
		fields = append(fields, workflowdefinitionhistory.FieldWorkflowKind)
	}
	if m.schema_type != nil {
		fields = append(fields, workflowdefinitionhistory.FieldSchemaType)
	}
	if m.revision != nil {
		fields = append(fields, workflowdefinitionhistory.FieldRevision)
	}
	if m.draft != nil {
		fields = append(fields, workflowdefinitionhistory.FieldDraft)
	}
	if m.published_at != nil {
		fields = append(fields, workflowdefinitionhistory.FieldPublishedAt)
	}
	if m.cooldown_seconds != nil {
		fields = append(fields, workflowdefinitionhistory.FieldCooldownSeconds)
	}
	if m.is_default != nil {
		fields = append(fields, workflowdefinitionhistory.FieldIsDefault)
	}
	if m.active != nil {
		fields = append(fields, workflowdefinitionhistory.FieldActive)
	}
	if m.trigger_operations != nil {
		fields = append(fields, workflowdefinitionhistory.FieldTriggerOperations)
	}
	if m.trigger_fields != nil {
		fields = append(fields, workflowdefinitionhistory.FieldTriggerFields)
	}
	if m.definition_json != nil {
		fields = append(fields, workflowdefinitionhistory.FieldDefinitionJSON)
	}
	if m.tracked_fields != nil {
		fields = append(fields, workflowdefinitionhistory.FieldTrackedFields)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowDefinitionHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowdefinitionhistory.FieldHistoryTime:
		return m.HistoryTime()
	case workflowdefinitionhistory.FieldRef:
		return m.Ref()
	case workflowdefinitionhistory.FieldOperation:
		return m.Operation()
	case workflowdefinitionhistory.FieldCreatedAt:
		return m.CreatedAt()
	case workflowdefinitionhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case workflowdefinitionhistory.FieldCreatedBy:
		return m.CreatedBy()
	case workflowdefinitionhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case workflowdefinitionhistory.FieldDeletedAt:
		return m.DeletedAt()
	case workflowdefinitionhistory.FieldDeletedBy:
		return m.DeletedBy()
	case workflowdefinitionhistory.FieldDisplayID:
		return m.DisplayID()
	case workflowdefinitionhistory.FieldTags:
		return m.Tags()
	case workflowdefinitionhistory.FieldOwnerID:
		return m.OwnerID()
	case workflowdefinitionhistory.FieldSystemOwned:
		return m.SystemOwned()
	case workflowdefinitionhistory.FieldInternalNotes:
		return m.InternalNotes()
	case workflowdefinitionhistory.FieldSystemInternalID:
		return m.SystemInternalID()
	case workflowdefinitionhistory.FieldName:
		return m.Name()
	case workflowdefinitionhistory.FieldDescription:
		return m.Description()
	case workflowdefinitionhistory.FieldWorkflowKind:
		return m.WorkflowKind()
	case workflowdefinitionhistory.FieldSchemaType:
		return m.SchemaType()
	case workflowdefinitionhistory.FieldRevision:
		return m.Revision()
	case workflowdefinitionhistory.FieldDraft:
		return m.Draft()
	case workflowdefinitionhistory.FieldPublishedAt:
		return m.PublishedAt()
	case workflowdefinitionhistory.FieldCooldownSeconds:
		return m.CooldownSeconds()
	case workflowdefinitionhistory.FieldIsDefault:
		return m.IsDefault()
	case workflowdefinitionhistory.FieldActive:
		return m.Active()
	case workflowdefinitionhistory.FieldTriggerOperations:
		return m.TriggerOperations()
	case workflowdefinitionhistory.FieldTriggerFields:
		return m.TriggerFields()
	case workflowdefinitionhistory.FieldDefinitionJSON:
		return m.DefinitionJSON()
	case workflowdefinitionhistory.FieldTrackedFields:
		return m.TrackedFields()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowDefinitionHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowdefinitionhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case workflowdefinitionhistory.FieldRef:
		return m.OldRef(ctx)
	case workflowdefinitionhistory.FieldOperation:
		return m.OldOperation(ctx)
	case workflowdefinitionhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflowdefinitionhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workflowdefinitionhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case workflowdefinitionhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case workflowdefinitionhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case workflowdefinitionhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case workflowdefinitionhistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case workflowdefinitionhistory.FieldTags:
		return m.OldTags(ctx)
	case workflowdefinitionhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case workflowdefinitionhistory.FieldSystemOwned:
		return m.OldSystemOwned(ctx)
	case workflowdefinitionhistory.FieldInternalNotes:
		return m.OldInternalNotes(ctx)
	case workflowdefinitionhistory.FieldSystemInternalID:
		return m.OldSystemInternalID(ctx)
	case workflowdefinitionhistory.FieldName:
		return m.OldName(ctx)
	case workflowdefinitionhistory.FieldDescription:
		return m.OldDescription(ctx)
	case workflowdefinitionhistory.FieldWorkflowKind:
		return m.OldWorkflowKind(ctx)
	case workflowdefinitionhistory.FieldSchemaType:
		return m.OldSchemaType(ctx)
	case workflowdefinitionhistory.FieldRevision:
		return m.OldRevision(ctx)
	case workflowdefinitionhistory.FieldDraft:
		return m.OldDraft(ctx)
	case workflowdefinitionhistory.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	case workflowdefinitionhistory.FieldCooldownSeconds:
		return m.OldCooldownSeconds(ctx)
	case workflowdefinitionhistory.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case workflowdefinitionhistory.FieldActive:
		return m.OldActive(ctx)
	case workflowdefinitionhistory.FieldTriggerOperations:
		return m.OldTriggerOperations(ctx)
	case workflowdefinitionhistory.FieldTriggerFields:
		return m.OldTriggerFields(ctx)
	case workflowdefinitionhistory.FieldDefinitionJSON:
		return m.OldDefinitionJSON(ctx)
	case workflowdefinitionhistory.FieldTrackedFields:
		return m.OldTrackedFields(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowDefinitionHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowDefinitionHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowdefinitionhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case workflowdefinitionhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case workflowdefinitionhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case workflowdefinitionhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflowdefinitionhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workflowdefinitionhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case workflowdefinitionhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case workflowdefinitionhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case workflowdefinitionhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case workflowdefinitionhistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case workflowdefinitionhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case workflowdefinitionhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case workflowdefinitionhistory.FieldSystemOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemOwned(v)
		return nil
	case workflowdefinitionhistory.FieldInternalNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNotes(v)
		return nil
	case workflowdefinitionhistory.FieldSystemInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInternalID(v)
		return nil
	case workflowdefinitionhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workflowdefinitionhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workflowdefinitionhistory.FieldWorkflowKind:
		v, ok := value.(enums.WorkflowKind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowKind(v)
		return nil
	case workflowdefinitionhistory.FieldSchemaType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchemaType(v)
		return nil
	case workflowdefinitionhistory.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case workflowdefinitionhistory.FieldDraft:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDraft(v)
		return nil
	case workflowdefinitionhistory.FieldPublishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case workflowdefinitionhistory.FieldCooldownSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCooldownSeconds(v)
		return nil
	case workflowdefinitionhistory.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case workflowdefinitionhistory.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case workflowdefinitionhistory.FieldTriggerOperations:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggerOperations(v)
		return nil
	case workflowdefinitionhistory.FieldTriggerFields:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggerFields(v)
		return nil
	case workflowdefinitionhistory.FieldDefinitionJSON:
		v, ok := value.(models.WorkflowDefinitionDocument)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefinitionJSON(v)
		return nil
	case workflowdefinitionhistory.FieldTrackedFields:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackedFields(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowDefinitionHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowDefinitionHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addrevision != nil {
		fields = append(fields, workflowdefinitionhistory.FieldRevision)
	}
	if m.addcooldown_seconds != nil {
		fields = append(fields, workflowdefinitionhistory.FieldCooldownSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowDefinitionHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflowdefinitionhistory.FieldRevision:
		return m.AddedRevision()
	case workflowdefinitionhistory.FieldCooldownSeconds:
		return m.AddedCooldownSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowDefinitionHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflowdefinitionhistory.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	case workflowdefinitionhistory.FieldCooldownSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCooldownSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowDefinitionHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowDefinitionHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowdefinitionhistory.FieldRef) {
		fields = append(fields, workflowdefinitionhistory.FieldRef)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldCreatedAt) {
		fields = append(fields, workflowdefinitionhistory.FieldCreatedAt)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldUpdatedAt) {
		fields = append(fields, workflowdefinitionhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldCreatedBy) {
		fields = append(fields, workflowdefinitionhistory.FieldCreatedBy)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldUpdatedBy) {
		fields = append(fields, workflowdefinitionhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldDeletedAt) {
		fields = append(fields, workflowdefinitionhistory.FieldDeletedAt)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldDeletedBy) {
		fields = append(fields, workflowdefinitionhistory.FieldDeletedBy)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldTags) {
		fields = append(fields, workflowdefinitionhistory.FieldTags)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldOwnerID) {
		fields = append(fields, workflowdefinitionhistory.FieldOwnerID)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldSystemOwned) {
		fields = append(fields, workflowdefinitionhistory.FieldSystemOwned)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldInternalNotes) {
		fields = append(fields, workflowdefinitionhistory.FieldInternalNotes)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldSystemInternalID) {
		fields = append(fields, workflowdefinitionhistory.FieldSystemInternalID)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldDescription) {
		fields = append(fields, workflowdefinitionhistory.FieldDescription)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldPublishedAt) {
		fields = append(fields, workflowdefinitionhistory.FieldPublishedAt)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldTriggerOperations) {
		fields = append(fields, workflowdefinitionhistory.FieldTriggerOperations)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldTriggerFields) {
		fields = append(fields, workflowdefinitionhistory.FieldTriggerFields)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldDefinitionJSON) {
		fields = append(fields, workflowdefinitionhistory.FieldDefinitionJSON)
	}
	if m.FieldCleared(workflowdefinitionhistory.FieldTrackedFields) {
		fields = append(fields, workflowdefinitionhistory.FieldTrackedFields)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowDefinitionHistoryMutation) ClearField(name string) error {
	switch name {
	case workflowdefinitionhistory.FieldRef:
		m.ClearRef()
		return nil
	case workflowdefinitionhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case workflowdefinitionhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case workflowdefinitionhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case workflowdefinitionhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case workflowdefinitionhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case workflowdefinitionhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case workflowdefinitionhistory.FieldTags:
		m.ClearTags()
		return nil
	case workflowdefinitionhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case workflowdefinitionhistory.FieldSystemOwned:
		m.ClearSystemOwned()
		return nil
	case workflowdefinitionhistory.FieldInternalNotes:
		m.ClearInternalNotes()
		return nil
	case workflowdefinitionhistory.FieldSystemInternalID:
		m.ClearSystemInternalID()
		return nil
	case workflowdefinitionhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case workflowdefinitionhistory.FieldPublishedAt:
		m.ClearPublishedAt()
		return nil
	case workflowdefinitionhistory.FieldTriggerOperations:
		m.ClearTriggerOperations()
		return nil
	case workflowdefinitionhistory.FieldTriggerFields:
		m.ClearTriggerFields()
		return nil
	case workflowdefinitionhistory.FieldDefinitionJSON:
		m.ClearDefinitionJSON()
		return nil
	case workflowdefinitionhistory.FieldTrackedFields:
		m.ClearTrackedFields()
		return nil
	}
	return fmt.Errorf("unknown WorkflowDefinitionHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowDefinitionHistoryMutation) ResetField(name string) error {
	switch name {
	case workflowdefinitionhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case workflowdefinitionhistory.FieldRef:
		m.ResetRef()
		return nil
	case workflowdefinitionhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case workflowdefinitionhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflowdefinitionhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workflowdefinitionhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case workflowdefinitionhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case workflowdefinitionhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case workflowdefinitionhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case workflowdefinitionhistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case workflowdefinitionhistory.FieldTags:
		m.ResetTags()
		return nil
	case workflowdefinitionhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case workflowdefinitionhistory.FieldSystemOwned:
		m.ResetSystemOwned()
		return nil
	case workflowdefinitionhistory.FieldInternalNotes:
		m.ResetInternalNotes()
		return nil
	case workflowdefinitionhistory.FieldSystemInternalID:
		m.ResetSystemInternalID()
		return nil
	case workflowdefinitionhistory.FieldName:
		m.ResetName()
		return nil
	case workflowdefinitionhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case workflowdefinitionhistory.FieldWorkflowKind:
		m.ResetWorkflowKind()
		return nil
	case workflowdefinitionhistory.FieldSchemaType:
		m.ResetSchemaType()
		return nil
	case workflowdefinitionhistory.FieldRevision:
		m.ResetRevision()
		return nil
	case workflowdefinitionhistory.FieldDraft:
		m.ResetDraft()
		return nil
	case workflowdefinitionhistory.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case workflowdefinitionhistory.FieldCooldownSeconds:
		m.ResetCooldownSeconds()
		return nil
	case workflowdefinitionhistory.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case workflowdefinitionhistory.FieldActive:
		m.ResetActive()
		return nil
	case workflowdefinitionhistory.FieldTriggerOperations:
		m.ResetTriggerOperations()
		return nil
	case workflowdefinitionhistory.FieldTriggerFields:
		m.ResetTriggerFields()
		return nil
	case workflowdefinitionhistory.FieldDefinitionJSON:
		m.ResetDefinitionJSON()
		return nil
	case workflowdefinitionhistory.FieldTrackedFields:
		m.ResetTrackedFields()
		return nil
	}
	return fmt.Errorf("unknown WorkflowDefinitionHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowDefinitionHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowDefinitionHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowDefinitionHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowDefinitionHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowDefinitionHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowDefinitionHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WorkflowDefinitionHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowDefinitionHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WorkflowDefinitionHistory edge %s", name)
}

// WorkflowEventHistoryMutation represents an operation that mutates the WorkflowEventHistory nodes in the graph.
type WorkflowEventHistoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	history_time         *time.Time
	ref                  *string
	operation            *history.OpType
	created_at           *time.Time
	updated_at           *time.Time
	created_by           *string
	updated_by           *string
	deleted_at           *time.Time
	deleted_by           *string
	display_id           *string
	tags                 *[]string
	appendtags           []string
	owner_id             *string
	workflow_instance_id *string
	event_type           *enums.WorkflowEventType
	payload              *models.WorkflowEventPayload
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*WorkflowEventHistory, error)
	predicates           []predicate.WorkflowEventHistory
}

var _ ent.Mutation = (*WorkflowEventHistoryMutation)(nil)

// workfloweventhistoryOption allows management of the mutation configuration using functional options.
type workfloweventhistoryOption func(*WorkflowEventHistoryMutation)

// newWorkflowEventHistoryMutation creates new mutation for the WorkflowEventHistory entity.
func newWorkflowEventHistoryMutation(c config, op Op, opts ...workfloweventhistoryOption) *WorkflowEventHistoryMutation {
	m := &WorkflowEventHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowEventHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowEventHistoryID sets the ID field of the mutation.
func withWorkflowEventHistoryID(id string) workfloweventhistoryOption {
	return func(m *WorkflowEventHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowEventHistory
		)
		m.oldValue = func(ctx context.Context) (*WorkflowEventHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowEventHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowEventHistory sets the old WorkflowEventHistory of the mutation.
func withWorkflowEventHistory(node *WorkflowEventHistory) workfloweventhistoryOption {
	return func(m *WorkflowEventHistoryMutation) {
		m.oldValue = func(context.Context) (*WorkflowEventHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowEventHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowEventHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowEventHistory entities.
func (m *WorkflowEventHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowEventHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowEventHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowEventHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *WorkflowEventHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *WorkflowEventHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the WorkflowEventHistory entity.
// If the WorkflowEventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *WorkflowEventHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *WorkflowEventHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *WorkflowEventHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the WorkflowEventHistory entity.
// If the WorkflowEventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *WorkflowEventHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[workfloweventhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *WorkflowEventHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[workfloweventhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *WorkflowEventHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, workfloweventhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *WorkflowEventHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *WorkflowEventHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the WorkflowEventHistory entity.
// If the WorkflowEventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *WorkflowEventHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowEventHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowEventHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkflowEventHistory entity.
// If the WorkflowEventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *WorkflowEventHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[workfloweventhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *WorkflowEventHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[workfloweventhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowEventHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, workfloweventhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowEventHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowEventHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkflowEventHistory entity.
// If the WorkflowEventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *WorkflowEventHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[workfloweventhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *WorkflowEventHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[workfloweventhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowEventHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, workfloweventhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *WorkflowEventHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WorkflowEventHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the WorkflowEventHistory entity.
// If the WorkflowEventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *WorkflowEventHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[workfloweventhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *WorkflowEventHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[workfloweventhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WorkflowEventHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, workfloweventhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *WorkflowEventHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *WorkflowEventHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the WorkflowEventHistory entity.
// If the WorkflowEventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *WorkflowEventHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[workfloweventhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *WorkflowEventHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[workfloweventhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *WorkflowEventHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, workfloweventhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WorkflowEventHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WorkflowEventHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WorkflowEventHistory entity.
// If the WorkflowEventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WorkflowEventHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[workfloweventhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WorkflowEventHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[workfloweventhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WorkflowEventHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, workfloweventhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *WorkflowEventHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *WorkflowEventHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the WorkflowEventHistory entity.
// If the WorkflowEventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *WorkflowEventHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[workfloweventhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *WorkflowEventHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[workfloweventhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *WorkflowEventHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, workfloweventhistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *WorkflowEventHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *WorkflowEventHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the WorkflowEventHistory entity.
// If the WorkflowEventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *WorkflowEventHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *WorkflowEventHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *WorkflowEventHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the WorkflowEventHistory entity.
// If the WorkflowEventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *WorkflowEventHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *WorkflowEventHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *WorkflowEventHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[workfloweventhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *WorkflowEventHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[workfloweventhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *WorkflowEventHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, workfloweventhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *WorkflowEventHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *WorkflowEventHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the WorkflowEventHistory entity.
// If the WorkflowEventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *WorkflowEventHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[workfloweventhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *WorkflowEventHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[workfloweventhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *WorkflowEventHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, workfloweventhistory.FieldOwnerID)
}

// SetWorkflowInstanceID sets the "workflow_instance_id" field.
func (m *WorkflowEventHistoryMutation) SetWorkflowInstanceID(s string) {
	m.workflow_instance_id = &s
}

// WorkflowInstanceID returns the value of the "workflow_instance_id" field in the mutation.
func (m *WorkflowEventHistoryMutation) WorkflowInstanceID() (r string, exists bool) {
	v := m.workflow_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowInstanceID returns the old "workflow_instance_id" field's value of the WorkflowEventHistory entity.
// If the WorkflowEventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventHistoryMutation) OldWorkflowInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowInstanceID: %w", err)
	}
	return oldValue.WorkflowInstanceID, nil
}

// ResetWorkflowInstanceID resets all changes to the "workflow_instance_id" field.
func (m *WorkflowEventHistoryMutation) ResetWorkflowInstanceID() {
	m.workflow_instance_id = nil
}

// SetEventType sets the "event_type" field.
func (m *WorkflowEventHistoryMutation) SetEventType(eet enums.WorkflowEventType) {
	m.event_type = &eet
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *WorkflowEventHistoryMutation) EventType() (r enums.WorkflowEventType, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the WorkflowEventHistory entity.
// If the WorkflowEventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventHistoryMutation) OldEventType(ctx context.Context) (v enums.WorkflowEventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *WorkflowEventHistoryMutation) ResetEventType() {
	m.event_type = nil
}

// SetPayload sets the "payload" field.
func (m *WorkflowEventHistoryMutation) SetPayload(mep models.WorkflowEventPayload) {
	m.payload = &mep
}

// Payload returns the value of the "payload" field in the mutation.
func (m *WorkflowEventHistoryMutation) Payload() (r models.WorkflowEventPayload, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the WorkflowEventHistory entity.
// If the WorkflowEventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventHistoryMutation) OldPayload(ctx context.Context) (v models.WorkflowEventPayload, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ClearPayload clears the value of the "payload" field.
func (m *WorkflowEventHistoryMutation) ClearPayload() {
	m.payload = nil
	m.clearedFields[workfloweventhistory.FieldPayload] = struct{}{}
}

// PayloadCleared returns if the "payload" field was cleared in this mutation.
func (m *WorkflowEventHistoryMutation) PayloadCleared() bool {
	_, ok := m.clearedFields[workfloweventhistory.FieldPayload]
	return ok
}

// ResetPayload resets all changes to the "payload" field.
func (m *WorkflowEventHistoryMutation) ResetPayload() {
	m.payload = nil
	delete(m.clearedFields, workfloweventhistory.FieldPayload)
}

// Where appends a list predicates to the WorkflowEventHistoryMutation builder.
func (m *WorkflowEventHistoryMutation) Where(ps ...predicate.WorkflowEventHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowEventHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowEventHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowEventHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowEventHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowEventHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowEventHistory).
func (m *WorkflowEventHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowEventHistoryMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.history_time != nil {
		fields = append(fields, workfloweventhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, workfloweventhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, workfloweventhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, workfloweventhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workfloweventhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, workfloweventhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, workfloweventhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, workfloweventhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, workfloweventhistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, workfloweventhistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, workfloweventhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, workfloweventhistory.FieldOwnerID)
	}
	if m.workflow_instance_id != nil {
		fields = append(fields, workfloweventhistory.FieldWorkflowInstanceID)
	}
	if m.event_type != nil {
		fields = append(fields, workfloweventhistory.FieldEventType)
	}
	if m.payload != nil {
		fields = append(fields, workfloweventhistory.FieldPayload)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowEventHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workfloweventhistory.FieldHistoryTime:
		return m.HistoryTime()
	case workfloweventhistory.FieldRef:
		return m.Ref()
	case workfloweventhistory.FieldOperation:
		return m.Operation()
	case workfloweventhistory.FieldCreatedAt:
		return m.CreatedAt()
	case workfloweventhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case workfloweventhistory.FieldCreatedBy:
		return m.CreatedBy()
	case workfloweventhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case workfloweventhistory.FieldDeletedAt:
		return m.DeletedAt()
	case workfloweventhistory.FieldDeletedBy:
		return m.DeletedBy()
	case workfloweventhistory.FieldDisplayID:
		return m.DisplayID()
	case workfloweventhistory.FieldTags:
		return m.Tags()
	case workfloweventhistory.FieldOwnerID:
		return m.OwnerID()
	case workfloweventhistory.FieldWorkflowInstanceID:
		return m.WorkflowInstanceID()
	case workfloweventhistory.FieldEventType:
		return m.EventType()
	case workfloweventhistory.FieldPayload:
		return m.Payload()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowEventHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workfloweventhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case workfloweventhistory.FieldRef:
		return m.OldRef(ctx)
	case workfloweventhistory.FieldOperation:
		return m.OldOperation(ctx)
	case workfloweventhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workfloweventhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workfloweventhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case workfloweventhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case workfloweventhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case workfloweventhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case workfloweventhistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case workfloweventhistory.FieldTags:
		return m.OldTags(ctx)
	case workfloweventhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case workfloweventhistory.FieldWorkflowInstanceID:
		return m.OldWorkflowInstanceID(ctx)
	case workfloweventhistory.FieldEventType:
		return m.OldEventType(ctx)
	case workfloweventhistory.FieldPayload:
		return m.OldPayload(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowEventHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowEventHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workfloweventhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case workfloweventhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case workfloweventhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case workfloweventhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workfloweventhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workfloweventhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case workfloweventhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case workfloweventhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case workfloweventhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case workfloweventhistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case workfloweventhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case workfloweventhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case workfloweventhistory.FieldWorkflowInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowInstanceID(v)
		return nil
	case workfloweventhistory.FieldEventType:
		v, ok := value.(enums.WorkflowEventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case workfloweventhistory.FieldPayload:
		v, ok := value.(models.WorkflowEventPayload)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowEventHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowEventHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowEventHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowEventHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkflowEventHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowEventHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workfloweventhistory.FieldRef) {
		fields = append(fields, workfloweventhistory.FieldRef)
	}
	if m.FieldCleared(workfloweventhistory.FieldCreatedAt) {
		fields = append(fields, workfloweventhistory.FieldCreatedAt)
	}
	if m.FieldCleared(workfloweventhistory.FieldUpdatedAt) {
		fields = append(fields, workfloweventhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(workfloweventhistory.FieldCreatedBy) {
		fields = append(fields, workfloweventhistory.FieldCreatedBy)
	}
	if m.FieldCleared(workfloweventhistory.FieldUpdatedBy) {
		fields = append(fields, workfloweventhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(workfloweventhistory.FieldDeletedAt) {
		fields = append(fields, workfloweventhistory.FieldDeletedAt)
	}
	if m.FieldCleared(workfloweventhistory.FieldDeletedBy) {
		fields = append(fields, workfloweventhistory.FieldDeletedBy)
	}
	if m.FieldCleared(workfloweventhistory.FieldTags) {
		fields = append(fields, workfloweventhistory.FieldTags)
	}
	if m.FieldCleared(workfloweventhistory.FieldOwnerID) {
		fields = append(fields, workfloweventhistory.FieldOwnerID)
	}
	if m.FieldCleared(workfloweventhistory.FieldPayload) {
		fields = append(fields, workfloweventhistory.FieldPayload)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowEventHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowEventHistoryMutation) ClearField(name string) error {
	switch name {
	case workfloweventhistory.FieldRef:
		m.ClearRef()
		return nil
	case workfloweventhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case workfloweventhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case workfloweventhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case workfloweventhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case workfloweventhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case workfloweventhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case workfloweventhistory.FieldTags:
		m.ClearTags()
		return nil
	case workfloweventhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case workfloweventhistory.FieldPayload:
		m.ClearPayload()
		return nil
	}
	return fmt.Errorf("unknown WorkflowEventHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowEventHistoryMutation) ResetField(name string) error {
	switch name {
	case workfloweventhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case workfloweventhistory.FieldRef:
		m.ResetRef()
		return nil
	case workfloweventhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case workfloweventhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workfloweventhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workfloweventhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case workfloweventhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case workfloweventhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case workfloweventhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case workfloweventhistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case workfloweventhistory.FieldTags:
		m.ResetTags()
		return nil
	case workfloweventhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case workfloweventhistory.FieldWorkflowInstanceID:
		m.ResetWorkflowInstanceID()
		return nil
	case workfloweventhistory.FieldEventType:
		m.ResetEventType()
		return nil
	case workfloweventhistory.FieldPayload:
		m.ResetPayload()
		return nil
	}
	return fmt.Errorf("unknown WorkflowEventHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowEventHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowEventHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowEventHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowEventHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowEventHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowEventHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowEventHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WorkflowEventHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowEventHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WorkflowEventHistory edge %s", name)
}

// WorkflowInstanceHistoryMutation represents an operation that mutates the WorkflowInstanceHistory nodes in the graph.
type WorkflowInstanceHistoryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	history_time           *time.Time
	ref                    *string
	operation              *history.OpType
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	deleted_at             *time.Time
	deleted_by             *string
	display_id             *string
	tags                   *[]string
	appendtags             []string
	owner_id               *string
	workflow_definition_id *string
	state                  *enums.WorkflowInstanceState
	context                *models.WorkflowInstanceContext
	last_evaluated_at      *time.Time
	definition_snapshot    *models.WorkflowDefinitionDocument
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*WorkflowInstanceHistory, error)
	predicates             []predicate.WorkflowInstanceHistory
}

var _ ent.Mutation = (*WorkflowInstanceHistoryMutation)(nil)

// workflowinstancehistoryOption allows management of the mutation configuration using functional options.
type workflowinstancehistoryOption func(*WorkflowInstanceHistoryMutation)

// newWorkflowInstanceHistoryMutation creates new mutation for the WorkflowInstanceHistory entity.
func newWorkflowInstanceHistoryMutation(c config, op Op, opts ...workflowinstancehistoryOption) *WorkflowInstanceHistoryMutation {
	m := &WorkflowInstanceHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowInstanceHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowInstanceHistoryID sets the ID field of the mutation.
func withWorkflowInstanceHistoryID(id string) workflowinstancehistoryOption {
	return func(m *WorkflowInstanceHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowInstanceHistory
		)
		m.oldValue = func(ctx context.Context) (*WorkflowInstanceHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowInstanceHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowInstanceHistory sets the old WorkflowInstanceHistory of the mutation.
func withWorkflowInstanceHistory(node *WorkflowInstanceHistory) workflowinstancehistoryOption {
	return func(m *WorkflowInstanceHistoryMutation) {
		m.oldValue = func(context.Context) (*WorkflowInstanceHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowInstanceHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowInstanceHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowInstanceHistory entities.
func (m *WorkflowInstanceHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowInstanceHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowInstanceHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowInstanceHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *WorkflowInstanceHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *WorkflowInstanceHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *WorkflowInstanceHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *WorkflowInstanceHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[workflowinstancehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *WorkflowInstanceHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[workflowinstancehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *WorkflowInstanceHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, workflowinstancehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *WorkflowInstanceHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *WorkflowInstanceHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowInstanceHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *WorkflowInstanceHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[workflowinstancehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *WorkflowInstanceHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[workflowinstancehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowInstanceHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, workflowinstancehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowInstanceHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *WorkflowInstanceHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[workflowinstancehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *WorkflowInstanceHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[workflowinstancehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowInstanceHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, workflowinstancehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *WorkflowInstanceHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *WorkflowInstanceHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[workflowinstancehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *WorkflowInstanceHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[workflowinstancehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WorkflowInstanceHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, workflowinstancehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *WorkflowInstanceHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *WorkflowInstanceHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[workflowinstancehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *WorkflowInstanceHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[workflowinstancehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *WorkflowInstanceHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, workflowinstancehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WorkflowInstanceHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WorkflowInstanceHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[workflowinstancehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WorkflowInstanceHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[workflowinstancehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WorkflowInstanceHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, workflowinstancehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *WorkflowInstanceHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *WorkflowInstanceHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[workflowinstancehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *WorkflowInstanceHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[workflowinstancehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *WorkflowInstanceHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, workflowinstancehistory.FieldDeletedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *WorkflowInstanceHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *WorkflowInstanceHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetTags sets the "tags" field.
func (m *WorkflowInstanceHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *WorkflowInstanceHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *WorkflowInstanceHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *WorkflowInstanceHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[workflowinstancehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *WorkflowInstanceHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[workflowinstancehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *WorkflowInstanceHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, workflowinstancehistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *WorkflowInstanceHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *WorkflowInstanceHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[workflowinstancehistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *WorkflowInstanceHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[workflowinstancehistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *WorkflowInstanceHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, workflowinstancehistory.FieldOwnerID)
}

// SetWorkflowDefinitionID sets the "workflow_definition_id" field.
func (m *WorkflowInstanceHistoryMutation) SetWorkflowDefinitionID(s string) {
	m.workflow_definition_id = &s
}

// WorkflowDefinitionID returns the value of the "workflow_definition_id" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) WorkflowDefinitionID() (r string, exists bool) {
	v := m.workflow_definition_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowDefinitionID returns the old "workflow_definition_id" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldWorkflowDefinitionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowDefinitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowDefinitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowDefinitionID: %w", err)
	}
	return oldValue.WorkflowDefinitionID, nil
}

// ResetWorkflowDefinitionID resets all changes to the "workflow_definition_id" field.
func (m *WorkflowInstanceHistoryMutation) ResetWorkflowDefinitionID() {
	m.workflow_definition_id = nil
}

// SetState sets the "state" field.
func (m *WorkflowInstanceHistoryMutation) SetState(eis enums.WorkflowInstanceState) {
	m.state = &eis
}

// State returns the value of the "state" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) State() (r enums.WorkflowInstanceState, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldState(ctx context.Context) (v enums.WorkflowInstanceState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *WorkflowInstanceHistoryMutation) ResetState() {
	m.state = nil
}

// SetContext sets the "context" field.
func (m *WorkflowInstanceHistoryMutation) SetContext(mic models.WorkflowInstanceContext) {
	m.context = &mic
}

// Context returns the value of the "context" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) Context() (r models.WorkflowInstanceContext, exists bool) {
	v := m.context
	if v == nil {
		return
	}
	return *v, true
}

// OldContext returns the old "context" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldContext(ctx context.Context) (v models.WorkflowInstanceContext, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContext: %w", err)
	}
	return oldValue.Context, nil
}

// ClearContext clears the value of the "context" field.
func (m *WorkflowInstanceHistoryMutation) ClearContext() {
	m.context = nil
	m.clearedFields[workflowinstancehistory.FieldContext] = struct{}{}
}

// ContextCleared returns if the "context" field was cleared in this mutation.
func (m *WorkflowInstanceHistoryMutation) ContextCleared() bool {
	_, ok := m.clearedFields[workflowinstancehistory.FieldContext]
	return ok
}

// ResetContext resets all changes to the "context" field.
func (m *WorkflowInstanceHistoryMutation) ResetContext() {
	m.context = nil
	delete(m.clearedFields, workflowinstancehistory.FieldContext)
}

// SetLastEvaluatedAt sets the "last_evaluated_at" field.
func (m *WorkflowInstanceHistoryMutation) SetLastEvaluatedAt(t time.Time) {
	m.last_evaluated_at = &t
}

// LastEvaluatedAt returns the value of the "last_evaluated_at" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) LastEvaluatedAt() (r time.Time, exists bool) {
	v := m.last_evaluated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastEvaluatedAt returns the old "last_evaluated_at" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldLastEvaluatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastEvaluatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastEvaluatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastEvaluatedAt: %w", err)
	}
	return oldValue.LastEvaluatedAt, nil
}

// ClearLastEvaluatedAt clears the value of the "last_evaluated_at" field.
func (m *WorkflowInstanceHistoryMutation) ClearLastEvaluatedAt() {
	m.last_evaluated_at = nil
	m.clearedFields[workflowinstancehistory.FieldLastEvaluatedAt] = struct{}{}
}

// LastEvaluatedAtCleared returns if the "last_evaluated_at" field was cleared in this mutation.
func (m *WorkflowInstanceHistoryMutation) LastEvaluatedAtCleared() bool {
	_, ok := m.clearedFields[workflowinstancehistory.FieldLastEvaluatedAt]
	return ok
}

// ResetLastEvaluatedAt resets all changes to the "last_evaluated_at" field.
func (m *WorkflowInstanceHistoryMutation) ResetLastEvaluatedAt() {
	m.last_evaluated_at = nil
	delete(m.clearedFields, workflowinstancehistory.FieldLastEvaluatedAt)
}

// SetDefinitionSnapshot sets the "definition_snapshot" field.
func (m *WorkflowInstanceHistoryMutation) SetDefinitionSnapshot(mdd models.WorkflowDefinitionDocument) {
	m.definition_snapshot = &mdd
}

// DefinitionSnapshot returns the value of the "definition_snapshot" field in the mutation.
func (m *WorkflowInstanceHistoryMutation) DefinitionSnapshot() (r models.WorkflowDefinitionDocument, exists bool) {
	v := m.definition_snapshot
	if v == nil {
		return
	}
	return *v, true
}

// OldDefinitionSnapshot returns the old "definition_snapshot" field's value of the WorkflowInstanceHistory entity.
// If the WorkflowInstanceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceHistoryMutation) OldDefinitionSnapshot(ctx context.Context) (v models.WorkflowDefinitionDocument, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefinitionSnapshot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefinitionSnapshot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefinitionSnapshot: %w", err)
	}
	return oldValue.DefinitionSnapshot, nil
}

// ClearDefinitionSnapshot clears the value of the "definition_snapshot" field.
func (m *WorkflowInstanceHistoryMutation) ClearDefinitionSnapshot() {
	m.definition_snapshot = nil
	m.clearedFields[workflowinstancehistory.FieldDefinitionSnapshot] = struct{}{}
}

// DefinitionSnapshotCleared returns if the "definition_snapshot" field was cleared in this mutation.
func (m *WorkflowInstanceHistoryMutation) DefinitionSnapshotCleared() bool {
	_, ok := m.clearedFields[workflowinstancehistory.FieldDefinitionSnapshot]
	return ok
}

// ResetDefinitionSnapshot resets all changes to the "definition_snapshot" field.
func (m *WorkflowInstanceHistoryMutation) ResetDefinitionSnapshot() {
	m.definition_snapshot = nil
	delete(m.clearedFields, workflowinstancehistory.FieldDefinitionSnapshot)
}

// Where appends a list predicates to the WorkflowInstanceHistoryMutation builder.
func (m *WorkflowInstanceHistoryMutation) Where(ps ...predicate.WorkflowInstanceHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowInstanceHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowInstanceHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowInstanceHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowInstanceHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowInstanceHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowInstanceHistory).
func (m *WorkflowInstanceHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowInstanceHistoryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.history_time != nil {
		fields = append(fields, workflowinstancehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, workflowinstancehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, workflowinstancehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, workflowinstancehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflowinstancehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, workflowinstancehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, workflowinstancehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, workflowinstancehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, workflowinstancehistory.FieldDeletedBy)
	}
	if m.display_id != nil {
		fields = append(fields, workflowinstancehistory.FieldDisplayID)
	}
	if m.tags != nil {
		fields = append(fields, workflowinstancehistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, workflowinstancehistory.FieldOwnerID)
	}
	if m.workflow_definition_id != nil {
		fields = append(fields, workflowinstancehistory.FieldWorkflowDefinitionID)
	}
	if m.state != nil {
		fields = append(fields, workflowinstancehistory.FieldState)
	}
	if m.context != nil {
		fields = append(fields, workflowinstancehistory.FieldContext)
	}
	if m.last_evaluated_at != nil {
		fields = append(fields, workflowinstancehistory.FieldLastEvaluatedAt)
	}
	if m.definition_snapshot != nil {
		fields = append(fields, workflowinstancehistory.FieldDefinitionSnapshot)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowInstanceHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowinstancehistory.FieldHistoryTime:
		return m.HistoryTime()
	case workflowinstancehistory.FieldRef:
		return m.Ref()
	case workflowinstancehistory.FieldOperation:
		return m.Operation()
	case workflowinstancehistory.FieldCreatedAt:
		return m.CreatedAt()
	case workflowinstancehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case workflowinstancehistory.FieldCreatedBy:
		return m.CreatedBy()
	case workflowinstancehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case workflowinstancehistory.FieldDeletedAt:
		return m.DeletedAt()
	case workflowinstancehistory.FieldDeletedBy:
		return m.DeletedBy()
	case workflowinstancehistory.FieldDisplayID:
		return m.DisplayID()
	case workflowinstancehistory.FieldTags:
		return m.Tags()
	case workflowinstancehistory.FieldOwnerID:
		return m.OwnerID()
	case workflowinstancehistory.FieldWorkflowDefinitionID:
		return m.WorkflowDefinitionID()
	case workflowinstancehistory.FieldState:
		return m.State()
	case workflowinstancehistory.FieldContext:
		return m.Context()
	case workflowinstancehistory.FieldLastEvaluatedAt:
		return m.LastEvaluatedAt()
	case workflowinstancehistory.FieldDefinitionSnapshot:
		return m.DefinitionSnapshot()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowInstanceHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowinstancehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case workflowinstancehistory.FieldRef:
		return m.OldRef(ctx)
	case workflowinstancehistory.FieldOperation:
		return m.OldOperation(ctx)
	case workflowinstancehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflowinstancehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workflowinstancehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case workflowinstancehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case workflowinstancehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case workflowinstancehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case workflowinstancehistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case workflowinstancehistory.FieldTags:
		return m.OldTags(ctx)
	case workflowinstancehistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case workflowinstancehistory.FieldWorkflowDefinitionID:
		return m.OldWorkflowDefinitionID(ctx)
	case workflowinstancehistory.FieldState:
		return m.OldState(ctx)
	case workflowinstancehistory.FieldContext:
		return m.OldContext(ctx)
	case workflowinstancehistory.FieldLastEvaluatedAt:
		return m.OldLastEvaluatedAt(ctx)
	case workflowinstancehistory.FieldDefinitionSnapshot:
		return m.OldDefinitionSnapshot(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowInstanceHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowInstanceHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowinstancehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case workflowinstancehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case workflowinstancehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case workflowinstancehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflowinstancehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workflowinstancehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case workflowinstancehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case workflowinstancehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case workflowinstancehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case workflowinstancehistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case workflowinstancehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case workflowinstancehistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case workflowinstancehistory.FieldWorkflowDefinitionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowDefinitionID(v)
		return nil
	case workflowinstancehistory.FieldState:
		v, ok := value.(enums.WorkflowInstanceState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case workflowinstancehistory.FieldContext:
		v, ok := value.(models.WorkflowInstanceContext)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContext(v)
		return nil
	case workflowinstancehistory.FieldLastEvaluatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastEvaluatedAt(v)
		return nil
	case workflowinstancehistory.FieldDefinitionSnapshot:
		v, ok := value.(models.WorkflowDefinitionDocument)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefinitionSnapshot(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstanceHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowInstanceHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowInstanceHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowInstanceHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkflowInstanceHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowInstanceHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowinstancehistory.FieldRef) {
		fields = append(fields, workflowinstancehistory.FieldRef)
	}
	if m.FieldCleared(workflowinstancehistory.FieldCreatedAt) {
		fields = append(fields, workflowinstancehistory.FieldCreatedAt)
	}
	if m.FieldCleared(workflowinstancehistory.FieldUpdatedAt) {
		fields = append(fields, workflowinstancehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(workflowinstancehistory.FieldCreatedBy) {
		fields = append(fields, workflowinstancehistory.FieldCreatedBy)
	}
	if m.FieldCleared(workflowinstancehistory.FieldUpdatedBy) {
		fields = append(fields, workflowinstancehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(workflowinstancehistory.FieldDeletedAt) {
		fields = append(fields, workflowinstancehistory.FieldDeletedAt)
	}
	if m.FieldCleared(workflowinstancehistory.FieldDeletedBy) {
		fields = append(fields, workflowinstancehistory.FieldDeletedBy)
	}
	if m.FieldCleared(workflowinstancehistory.FieldTags) {
		fields = append(fields, workflowinstancehistory.FieldTags)
	}
	if m.FieldCleared(workflowinstancehistory.FieldOwnerID) {
		fields = append(fields, workflowinstancehistory.FieldOwnerID)
	}
	if m.FieldCleared(workflowinstancehistory.FieldContext) {
		fields = append(fields, workflowinstancehistory.FieldContext)
	}
	if m.FieldCleared(workflowinstancehistory.FieldLastEvaluatedAt) {
		fields = append(fields, workflowinstancehistory.FieldLastEvaluatedAt)
	}
	if m.FieldCleared(workflowinstancehistory.FieldDefinitionSnapshot) {
		fields = append(fields, workflowinstancehistory.FieldDefinitionSnapshot)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowInstanceHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowInstanceHistoryMutation) ClearField(name string) error {
	switch name {
	case workflowinstancehistory.FieldRef:
		m.ClearRef()
		return nil
	case workflowinstancehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case workflowinstancehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case workflowinstancehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case workflowinstancehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case workflowinstancehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case workflowinstancehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case workflowinstancehistory.FieldTags:
		m.ClearTags()
		return nil
	case workflowinstancehistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case workflowinstancehistory.FieldContext:
		m.ClearContext()
		return nil
	case workflowinstancehistory.FieldLastEvaluatedAt:
		m.ClearLastEvaluatedAt()
		return nil
	case workflowinstancehistory.FieldDefinitionSnapshot:
		m.ClearDefinitionSnapshot()
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstanceHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowInstanceHistoryMutation) ResetField(name string) error {
	switch name {
	case workflowinstancehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case workflowinstancehistory.FieldRef:
		m.ResetRef()
		return nil
	case workflowinstancehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case workflowinstancehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflowinstancehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workflowinstancehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case workflowinstancehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case workflowinstancehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case workflowinstancehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case workflowinstancehistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case workflowinstancehistory.FieldTags:
		m.ResetTags()
		return nil
	case workflowinstancehistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case workflowinstancehistory.FieldWorkflowDefinitionID:
		m.ResetWorkflowDefinitionID()
		return nil
	case workflowinstancehistory.FieldState:
		m.ResetState()
		return nil
	case workflowinstancehistory.FieldContext:
		m.ResetContext()
		return nil
	case workflowinstancehistory.FieldLastEvaluatedAt:
		m.ResetLastEvaluatedAt()
		return nil
	case workflowinstancehistory.FieldDefinitionSnapshot:
		m.ResetDefinitionSnapshot()
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstanceHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowInstanceHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowInstanceHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowInstanceHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowInstanceHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowInstanceHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowInstanceHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowInstanceHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WorkflowInstanceHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowInstanceHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WorkflowInstanceHistory edge %s", name)
}

// WorkflowObjectRefHistoryMutation represents an operation that mutates the WorkflowObjectRefHistory nodes in the graph.
type WorkflowObjectRefHistoryMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	history_time            *time.Time
	ref                     *string
	operation               *history.OpType
	created_at              *time.Time
	updated_at              *time.Time
	created_by              *string
	updated_by              *string
	display_id              *string
	owner_id                *string
	workflow_instance_id    *string
	control_id              *string
	task_id                 *string
	internal_policy_id      *string
	finding_id              *string
	directory_account_id    *string
	directory_group_id      *string
	directory_membership_id *string
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*WorkflowObjectRefHistory, error)
	predicates              []predicate.WorkflowObjectRefHistory
}

var _ ent.Mutation = (*WorkflowObjectRefHistoryMutation)(nil)

// workflowobjectrefhistoryOption allows management of the mutation configuration using functional options.
type workflowobjectrefhistoryOption func(*WorkflowObjectRefHistoryMutation)

// newWorkflowObjectRefHistoryMutation creates new mutation for the WorkflowObjectRefHistory entity.
func newWorkflowObjectRefHistoryMutation(c config, op Op, opts ...workflowobjectrefhistoryOption) *WorkflowObjectRefHistoryMutation {
	m := &WorkflowObjectRefHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowObjectRefHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowObjectRefHistoryID sets the ID field of the mutation.
func withWorkflowObjectRefHistoryID(id string) workflowobjectrefhistoryOption {
	return func(m *WorkflowObjectRefHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowObjectRefHistory
		)
		m.oldValue = func(ctx context.Context) (*WorkflowObjectRefHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowObjectRefHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowObjectRefHistory sets the old WorkflowObjectRefHistory of the mutation.
func withWorkflowObjectRefHistory(node *WorkflowObjectRefHistory) workflowobjectrefhistoryOption {
	return func(m *WorkflowObjectRefHistoryMutation) {
		m.oldValue = func(context.Context) (*WorkflowObjectRefHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowObjectRefHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowObjectRefHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("historygenerated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowObjectRefHistory entities.
func (m *WorkflowObjectRefHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowObjectRefHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowObjectRefHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowObjectRefHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *WorkflowObjectRefHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *WorkflowObjectRefHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *WorkflowObjectRefHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *WorkflowObjectRefHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[workflowobjectrefhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[workflowobjectrefhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *WorkflowObjectRefHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, workflowobjectrefhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *WorkflowObjectRefHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *WorkflowObjectRefHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowObjectRefHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *WorkflowObjectRefHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[workflowobjectrefhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[workflowobjectrefhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowObjectRefHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, workflowobjectrefhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowObjectRefHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *WorkflowObjectRefHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[workflowobjectrefhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[workflowobjectrefhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowObjectRefHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, workflowobjectrefhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *WorkflowObjectRefHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *WorkflowObjectRefHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[workflowobjectrefhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[workflowobjectrefhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WorkflowObjectRefHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, workflowobjectrefhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *WorkflowObjectRefHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *WorkflowObjectRefHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[workflowobjectrefhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[workflowobjectrefhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *WorkflowObjectRefHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, workflowobjectrefhistory.FieldUpdatedBy)
}

// SetDisplayID sets the "display_id" field.
func (m *WorkflowObjectRefHistoryMutation) SetDisplayID(s string) {
	m.display_id = &s
}

// DisplayID returns the value of the "display_id" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) DisplayID() (r string, exists bool) {
	v := m.display_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayID returns the old "display_id" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldDisplayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayID: %w", err)
	}
	return oldValue.DisplayID, nil
}

// ResetDisplayID resets all changes to the "display_id" field.
func (m *WorkflowObjectRefHistoryMutation) ResetDisplayID() {
	m.display_id = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *WorkflowObjectRefHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *WorkflowObjectRefHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[workflowobjectrefhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[workflowobjectrefhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *WorkflowObjectRefHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, workflowobjectrefhistory.FieldOwnerID)
}

// SetWorkflowInstanceID sets the "workflow_instance_id" field.
func (m *WorkflowObjectRefHistoryMutation) SetWorkflowInstanceID(s string) {
	m.workflow_instance_id = &s
}

// WorkflowInstanceID returns the value of the "workflow_instance_id" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) WorkflowInstanceID() (r string, exists bool) {
	v := m.workflow_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowInstanceID returns the old "workflow_instance_id" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldWorkflowInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowInstanceID: %w", err)
	}
	return oldValue.WorkflowInstanceID, nil
}

// ResetWorkflowInstanceID resets all changes to the "workflow_instance_id" field.
func (m *WorkflowObjectRefHistoryMutation) ResetWorkflowInstanceID() {
	m.workflow_instance_id = nil
}

// SetControlID sets the "control_id" field.
func (m *WorkflowObjectRefHistoryMutation) SetControlID(s string) {
	m.control_id = &s
}

// ControlID returns the value of the "control_id" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) ControlID() (r string, exists bool) {
	v := m.control_id
	if v == nil {
		return
	}
	return *v, true
}

// OldControlID returns the old "control_id" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldControlID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlID: %w", err)
	}
	return oldValue.ControlID, nil
}

// ClearControlID clears the value of the "control_id" field.
func (m *WorkflowObjectRefHistoryMutation) ClearControlID() {
	m.control_id = nil
	m.clearedFields[workflowobjectrefhistory.FieldControlID] = struct{}{}
}

// ControlIDCleared returns if the "control_id" field was cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) ControlIDCleared() bool {
	_, ok := m.clearedFields[workflowobjectrefhistory.FieldControlID]
	return ok
}

// ResetControlID resets all changes to the "control_id" field.
func (m *WorkflowObjectRefHistoryMutation) ResetControlID() {
	m.control_id = nil
	delete(m.clearedFields, workflowobjectrefhistory.FieldControlID)
}

// SetTaskID sets the "task_id" field.
func (m *WorkflowObjectRefHistoryMutation) SetTaskID(s string) {
	m.task_id = &s
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) TaskID() (r string, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ClearTaskID clears the value of the "task_id" field.
func (m *WorkflowObjectRefHistoryMutation) ClearTaskID() {
	m.task_id = nil
	m.clearedFields[workflowobjectrefhistory.FieldTaskID] = struct{}{}
}

// TaskIDCleared returns if the "task_id" field was cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) TaskIDCleared() bool {
	_, ok := m.clearedFields[workflowobjectrefhistory.FieldTaskID]
	return ok
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *WorkflowObjectRefHistoryMutation) ResetTaskID() {
	m.task_id = nil
	delete(m.clearedFields, workflowobjectrefhistory.FieldTaskID)
}

// SetInternalPolicyID sets the "internal_policy_id" field.
func (m *WorkflowObjectRefHistoryMutation) SetInternalPolicyID(s string) {
	m.internal_policy_id = &s
}

// InternalPolicyID returns the value of the "internal_policy_id" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) InternalPolicyID() (r string, exists bool) {
	v := m.internal_policy_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalPolicyID returns the old "internal_policy_id" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldInternalPolicyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalPolicyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalPolicyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalPolicyID: %w", err)
	}
	return oldValue.InternalPolicyID, nil
}

// ClearInternalPolicyID clears the value of the "internal_policy_id" field.
func (m *WorkflowObjectRefHistoryMutation) ClearInternalPolicyID() {
	m.internal_policy_id = nil
	m.clearedFields[workflowobjectrefhistory.FieldInternalPolicyID] = struct{}{}
}

// InternalPolicyIDCleared returns if the "internal_policy_id" field was cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) InternalPolicyIDCleared() bool {
	_, ok := m.clearedFields[workflowobjectrefhistory.FieldInternalPolicyID]
	return ok
}

// ResetInternalPolicyID resets all changes to the "internal_policy_id" field.
func (m *WorkflowObjectRefHistoryMutation) ResetInternalPolicyID() {
	m.internal_policy_id = nil
	delete(m.clearedFields, workflowobjectrefhistory.FieldInternalPolicyID)
}

// SetFindingID sets the "finding_id" field.
func (m *WorkflowObjectRefHistoryMutation) SetFindingID(s string) {
	m.finding_id = &s
}

// FindingID returns the value of the "finding_id" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) FindingID() (r string, exists bool) {
	v := m.finding_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFindingID returns the old "finding_id" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldFindingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFindingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFindingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFindingID: %w", err)
	}
	return oldValue.FindingID, nil
}

// ClearFindingID clears the value of the "finding_id" field.
func (m *WorkflowObjectRefHistoryMutation) ClearFindingID() {
	m.finding_id = nil
	m.clearedFields[workflowobjectrefhistory.FieldFindingID] = struct{}{}
}

// FindingIDCleared returns if the "finding_id" field was cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) FindingIDCleared() bool {
	_, ok := m.clearedFields[workflowobjectrefhistory.FieldFindingID]
	return ok
}

// ResetFindingID resets all changes to the "finding_id" field.
func (m *WorkflowObjectRefHistoryMutation) ResetFindingID() {
	m.finding_id = nil
	delete(m.clearedFields, workflowobjectrefhistory.FieldFindingID)
}

// SetDirectoryAccountID sets the "directory_account_id" field.
func (m *WorkflowObjectRefHistoryMutation) SetDirectoryAccountID(s string) {
	m.directory_account_id = &s
}

// DirectoryAccountID returns the value of the "directory_account_id" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) DirectoryAccountID() (r string, exists bool) {
	v := m.directory_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectoryAccountID returns the old "directory_account_id" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldDirectoryAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectoryAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectoryAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectoryAccountID: %w", err)
	}
	return oldValue.DirectoryAccountID, nil
}

// ClearDirectoryAccountID clears the value of the "directory_account_id" field.
func (m *WorkflowObjectRefHistoryMutation) ClearDirectoryAccountID() {
	m.directory_account_id = nil
	m.clearedFields[workflowobjectrefhistory.FieldDirectoryAccountID] = struct{}{}
}

// DirectoryAccountIDCleared returns if the "directory_account_id" field was cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) DirectoryAccountIDCleared() bool {
	_, ok := m.clearedFields[workflowobjectrefhistory.FieldDirectoryAccountID]
	return ok
}

// ResetDirectoryAccountID resets all changes to the "directory_account_id" field.
func (m *WorkflowObjectRefHistoryMutation) ResetDirectoryAccountID() {
	m.directory_account_id = nil
	delete(m.clearedFields, workflowobjectrefhistory.FieldDirectoryAccountID)
}

// SetDirectoryGroupID sets the "directory_group_id" field.
func (m *WorkflowObjectRefHistoryMutation) SetDirectoryGroupID(s string) {
	m.directory_group_id = &s
}

// DirectoryGroupID returns the value of the "directory_group_id" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) DirectoryGroupID() (r string, exists bool) {
	v := m.directory_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectoryGroupID returns the old "directory_group_id" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldDirectoryGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectoryGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectoryGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectoryGroupID: %w", err)
	}
	return oldValue.DirectoryGroupID, nil
}

// ClearDirectoryGroupID clears the value of the "directory_group_id" field.
func (m *WorkflowObjectRefHistoryMutation) ClearDirectoryGroupID() {
	m.directory_group_id = nil
	m.clearedFields[workflowobjectrefhistory.FieldDirectoryGroupID] = struct{}{}
}

// DirectoryGroupIDCleared returns if the "directory_group_id" field was cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) DirectoryGroupIDCleared() bool {
	_, ok := m.clearedFields[workflowobjectrefhistory.FieldDirectoryGroupID]
	return ok
}

// ResetDirectoryGroupID resets all changes to the "directory_group_id" field.
func (m *WorkflowObjectRefHistoryMutation) ResetDirectoryGroupID() {
	m.directory_group_id = nil
	delete(m.clearedFields, workflowobjectrefhistory.FieldDirectoryGroupID)
}

// SetDirectoryMembershipID sets the "directory_membership_id" field.
func (m *WorkflowObjectRefHistoryMutation) SetDirectoryMembershipID(s string) {
	m.directory_membership_id = &s
}

// DirectoryMembershipID returns the value of the "directory_membership_id" field in the mutation.
func (m *WorkflowObjectRefHistoryMutation) DirectoryMembershipID() (r string, exists bool) {
	v := m.directory_membership_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectoryMembershipID returns the old "directory_membership_id" field's value of the WorkflowObjectRefHistory entity.
// If the WorkflowObjectRefHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowObjectRefHistoryMutation) OldDirectoryMembershipID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectoryMembershipID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectoryMembershipID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectoryMembershipID: %w", err)
	}
	return oldValue.DirectoryMembershipID, nil
}

// ClearDirectoryMembershipID clears the value of the "directory_membership_id" field.
func (m *WorkflowObjectRefHistoryMutation) ClearDirectoryMembershipID() {
	m.directory_membership_id = nil
	m.clearedFields[workflowobjectrefhistory.FieldDirectoryMembershipID] = struct{}{}
}

// DirectoryMembershipIDCleared returns if the "directory_membership_id" field was cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) DirectoryMembershipIDCleared() bool {
	_, ok := m.clearedFields[workflowobjectrefhistory.FieldDirectoryMembershipID]
	return ok
}

// ResetDirectoryMembershipID resets all changes to the "directory_membership_id" field.
func (m *WorkflowObjectRefHistoryMutation) ResetDirectoryMembershipID() {
	m.directory_membership_id = nil
	delete(m.clearedFields, workflowobjectrefhistory.FieldDirectoryMembershipID)
}

// Where appends a list predicates to the WorkflowObjectRefHistoryMutation builder.
func (m *WorkflowObjectRefHistoryMutation) Where(ps ...predicate.WorkflowObjectRefHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowObjectRefHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowObjectRefHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowObjectRefHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowObjectRefHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowObjectRefHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowObjectRefHistory).
func (m *WorkflowObjectRefHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowObjectRefHistoryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.history_time != nil {
		fields = append(fields, workflowobjectrefhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, workflowobjectrefhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, workflowobjectrefhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, workflowobjectrefhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflowobjectrefhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, workflowobjectrefhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, workflowobjectrefhistory.FieldUpdatedBy)
	}
	if m.display_id != nil {
		fields = append(fields, workflowobjectrefhistory.FieldDisplayID)
	}
	if m.owner_id != nil {
		fields = append(fields, workflowobjectrefhistory.FieldOwnerID)
	}
	if m.workflow_instance_id != nil {
		fields = append(fields, workflowobjectrefhistory.FieldWorkflowInstanceID)
	}
	if m.control_id != nil {
		fields = append(fields, workflowobjectrefhistory.FieldControlID)
	}
	if m.task_id != nil {
		fields = append(fields, workflowobjectrefhistory.FieldTaskID)
	}
	if m.internal_policy_id != nil {
		fields = append(fields, workflowobjectrefhistory.FieldInternalPolicyID)
	}
	if m.finding_id != nil {
		fields = append(fields, workflowobjectrefhistory.FieldFindingID)
	}
	if m.directory_account_id != nil {
		fields = append(fields, workflowobjectrefhistory.FieldDirectoryAccountID)
	}
	if m.directory_group_id != nil {
		fields = append(fields, workflowobjectrefhistory.FieldDirectoryGroupID)
	}
	if m.directory_membership_id != nil {
		fields = append(fields, workflowobjectrefhistory.FieldDirectoryMembershipID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowObjectRefHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowobjectrefhistory.FieldHistoryTime:
		return m.HistoryTime()
	case workflowobjectrefhistory.FieldRef:
		return m.Ref()
	case workflowobjectrefhistory.FieldOperation:
		return m.Operation()
	case workflowobjectrefhistory.FieldCreatedAt:
		return m.CreatedAt()
	case workflowobjectrefhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case workflowobjectrefhistory.FieldCreatedBy:
		return m.CreatedBy()
	case workflowobjectrefhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case workflowobjectrefhistory.FieldDisplayID:
		return m.DisplayID()
	case workflowobjectrefhistory.FieldOwnerID:
		return m.OwnerID()
	case workflowobjectrefhistory.FieldWorkflowInstanceID:
		return m.WorkflowInstanceID()
	case workflowobjectrefhistory.FieldControlID:
		return m.ControlID()
	case workflowobjectrefhistory.FieldTaskID:
		return m.TaskID()
	case workflowobjectrefhistory.FieldInternalPolicyID:
		return m.InternalPolicyID()
	case workflowobjectrefhistory.FieldFindingID:
		return m.FindingID()
	case workflowobjectrefhistory.FieldDirectoryAccountID:
		return m.DirectoryAccountID()
	case workflowobjectrefhistory.FieldDirectoryGroupID:
		return m.DirectoryGroupID()
	case workflowobjectrefhistory.FieldDirectoryMembershipID:
		return m.DirectoryMembershipID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowObjectRefHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowobjectrefhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case workflowobjectrefhistory.FieldRef:
		return m.OldRef(ctx)
	case workflowobjectrefhistory.FieldOperation:
		return m.OldOperation(ctx)
	case workflowobjectrefhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflowobjectrefhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workflowobjectrefhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case workflowobjectrefhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case workflowobjectrefhistory.FieldDisplayID:
		return m.OldDisplayID(ctx)
	case workflowobjectrefhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case workflowobjectrefhistory.FieldWorkflowInstanceID:
		return m.OldWorkflowInstanceID(ctx)
	case workflowobjectrefhistory.FieldControlID:
		return m.OldControlID(ctx)
	case workflowobjectrefhistory.FieldTaskID:
		return m.OldTaskID(ctx)
	case workflowobjectrefhistory.FieldInternalPolicyID:
		return m.OldInternalPolicyID(ctx)
	case workflowobjectrefhistory.FieldFindingID:
		return m.OldFindingID(ctx)
	case workflowobjectrefhistory.FieldDirectoryAccountID:
		return m.OldDirectoryAccountID(ctx)
	case workflowobjectrefhistory.FieldDirectoryGroupID:
		return m.OldDirectoryGroupID(ctx)
	case workflowobjectrefhistory.FieldDirectoryMembershipID:
		return m.OldDirectoryMembershipID(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowObjectRefHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowObjectRefHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowobjectrefhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case workflowobjectrefhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case workflowobjectrefhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case workflowobjectrefhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflowobjectrefhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workflowobjectrefhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case workflowobjectrefhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case workflowobjectrefhistory.FieldDisplayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayID(v)
		return nil
	case workflowobjectrefhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case workflowobjectrefhistory.FieldWorkflowInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowInstanceID(v)
		return nil
	case workflowobjectrefhistory.FieldControlID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlID(v)
		return nil
	case workflowobjectrefhistory.FieldTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case workflowobjectrefhistory.FieldInternalPolicyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalPolicyID(v)
		return nil
	case workflowobjectrefhistory.FieldFindingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFindingID(v)
		return nil
	case workflowobjectrefhistory.FieldDirectoryAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectoryAccountID(v)
		return nil
	case workflowobjectrefhistory.FieldDirectoryGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectoryGroupID(v)
		return nil
	case workflowobjectrefhistory.FieldDirectoryMembershipID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectoryMembershipID(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowObjectRefHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowObjectRefHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowObjectRefHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowObjectRefHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkflowObjectRefHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowObjectRefHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowobjectrefhistory.FieldRef) {
		fields = append(fields, workflowobjectrefhistory.FieldRef)
	}
	if m.FieldCleared(workflowobjectrefhistory.FieldCreatedAt) {
		fields = append(fields, workflowobjectrefhistory.FieldCreatedAt)
	}
	if m.FieldCleared(workflowobjectrefhistory.FieldUpdatedAt) {
		fields = append(fields, workflowobjectrefhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(workflowobjectrefhistory.FieldCreatedBy) {
		fields = append(fields, workflowobjectrefhistory.FieldCreatedBy)
	}
	if m.FieldCleared(workflowobjectrefhistory.FieldUpdatedBy) {
		fields = append(fields, workflowobjectrefhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(workflowobjectrefhistory.FieldOwnerID) {
		fields = append(fields, workflowobjectrefhistory.FieldOwnerID)
	}
	if m.FieldCleared(workflowobjectrefhistory.FieldControlID) {
		fields = append(fields, workflowobjectrefhistory.FieldControlID)
	}
	if m.FieldCleared(workflowobjectrefhistory.FieldTaskID) {
		fields = append(fields, workflowobjectrefhistory.FieldTaskID)
	}
	if m.FieldCleared(workflowobjectrefhistory.FieldInternalPolicyID) {
		fields = append(fields, workflowobjectrefhistory.FieldInternalPolicyID)
	}
	if m.FieldCleared(workflowobjectrefhistory.FieldFindingID) {
		fields = append(fields, workflowobjectrefhistory.FieldFindingID)
	}
	if m.FieldCleared(workflowobjectrefhistory.FieldDirectoryAccountID) {
		fields = append(fields, workflowobjectrefhistory.FieldDirectoryAccountID)
	}
	if m.FieldCleared(workflowobjectrefhistory.FieldDirectoryGroupID) {
		fields = append(fields, workflowobjectrefhistory.FieldDirectoryGroupID)
	}
	if m.FieldCleared(workflowobjectrefhistory.FieldDirectoryMembershipID) {
		fields = append(fields, workflowobjectrefhistory.FieldDirectoryMembershipID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowObjectRefHistoryMutation) ClearField(name string) error {
	switch name {
	case workflowobjectrefhistory.FieldRef:
		m.ClearRef()
		return nil
	case workflowobjectrefhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case workflowobjectrefhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case workflowobjectrefhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case workflowobjectrefhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case workflowobjectrefhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case workflowobjectrefhistory.FieldControlID:
		m.ClearControlID()
		return nil
	case workflowobjectrefhistory.FieldTaskID:
		m.ClearTaskID()
		return nil
	case workflowobjectrefhistory.FieldInternalPolicyID:
		m.ClearInternalPolicyID()
		return nil
	case workflowobjectrefhistory.FieldFindingID:
		m.ClearFindingID()
		return nil
	case workflowobjectrefhistory.FieldDirectoryAccountID:
		m.ClearDirectoryAccountID()
		return nil
	case workflowobjectrefhistory.FieldDirectoryGroupID:
		m.ClearDirectoryGroupID()
		return nil
	case workflowobjectrefhistory.FieldDirectoryMembershipID:
		m.ClearDirectoryMembershipID()
		return nil
	}
	return fmt.Errorf("unknown WorkflowObjectRefHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowObjectRefHistoryMutation) ResetField(name string) error {
	switch name {
	case workflowobjectrefhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case workflowobjectrefhistory.FieldRef:
		m.ResetRef()
		return nil
	case workflowobjectrefhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case workflowobjectrefhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflowobjectrefhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workflowobjectrefhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case workflowobjectrefhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case workflowobjectrefhistory.FieldDisplayID:
		m.ResetDisplayID()
		return nil
	case workflowobjectrefhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case workflowobjectrefhistory.FieldWorkflowInstanceID:
		m.ResetWorkflowInstanceID()
		return nil
	case workflowobjectrefhistory.FieldControlID:
		m.ResetControlID()
		return nil
	case workflowobjectrefhistory.FieldTaskID:
		m.ResetTaskID()
		return nil
	case workflowobjectrefhistory.FieldInternalPolicyID:
		m.ResetInternalPolicyID()
		return nil
	case workflowobjectrefhistory.FieldFindingID:
		m.ResetFindingID()
		return nil
	case workflowobjectrefhistory.FieldDirectoryAccountID:
		m.ResetDirectoryAccountID()
		return nil
	case workflowobjectrefhistory.FieldDirectoryGroupID:
		m.ResetDirectoryGroupID()
		return nil
	case workflowobjectrefhistory.FieldDirectoryMembershipID:
		m.ResetDirectoryMembershipID()
		return nil
	}
	return fmt.Errorf("unknown WorkflowObjectRefHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowObjectRefHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowObjectRefHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowObjectRefHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowObjectRefHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowObjectRefHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowObjectRefHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WorkflowObjectRefHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowObjectRefHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WorkflowObjectRefHistory edge %s", name)
}
