// Code generated by ent, DO NOT EDIT.

package generated

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/theopenlane/core/common/enums"
	"github.com/theopenlane/core/internal/ent/generated/invite"
	"github.com/theopenlane/core/internal/ent/generated/organization"
)

// Invite is the model entity for the Invite schema.
type Invite struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// CreatedBy holds the value of the "created_by" field.
	CreatedBy string `json:"created_by,omitempty"`
	// UpdatedBy holds the value of the "updated_by" field.
	UpdatedBy string `json:"updated_by,omitempty"`
	// DeletedAt holds the value of the "deleted_at" field.
	DeletedAt time.Time `json:"deleted_at,omitempty"`
	// DeletedBy holds the value of the "deleted_by" field.
	DeletedBy string `json:"deleted_by,omitempty"`
	// the user who initiated the request
	RequestorID string `json:"requestor_id,omitempty"`
	// the organization id that owns the object
	OwnerID string `json:"owner_id,omitempty"`
	// the invitation token sent to the user via email which should only be provided to the /verify endpoint + handler
	Token string `json:"-"`
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires time.Time `json:"expires,omitempty"`
	// the email used as input to generate the invitation token and is the destination person the invitation is sent to who is required to accept to join the organization
	Recipient string `json:"recipient,omitempty"`
	// the status of the invitation
	Status enums.InviteStatus `json:"status,omitempty"`
	// Role holds the value of the "role" field.
	Role enums.Role `json:"role,omitempty"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts int `json:"send_attempts,omitempty"`
	// the comparison secret to verify the token's signature
	Secret *[]byte `json:"-"`
	// indicates if this invitation is for transferring organization ownership - when accepted, current owner becomes admin and invitee becomes owner
	OwnershipTransfer bool `json:"ownership_transfer,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the InviteQuery when eager-loading is set.
	Edges        InviteEdges `json:"edges"`
	selectValues sql.SelectValues
}

// InviteEdges holds the relations/edges for other nodes in the graph.
type InviteEdges struct {
	// Owner holds the value of the owner edge.
	Owner *Organization `json:"owner,omitempty"`
	// Events holds the value of the events edge.
	Events []*Event `json:"events,omitempty"`
	// Groups holds the value of the groups edge.
	Groups []*Group `json:"groups,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [3]bool
	// totalCount holds the count of the edges above.
	totalCount [3]map[string]int

	namedEvents map[string][]*Event
	namedGroups map[string][]*Group
}

// OwnerOrErr returns the Owner value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e InviteEdges) OwnerOrErr() (*Organization, error) {
	if e.Owner != nil {
		return e.Owner, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: organization.Label}
	}
	return nil, &NotLoadedError{edge: "owner"}
}

// EventsOrErr returns the Events value or an error if the edge
// was not loaded in eager-loading.
func (e InviteEdges) EventsOrErr() ([]*Event, error) {
	if e.loadedTypes[1] {
		return e.Events, nil
	}
	return nil, &NotLoadedError{edge: "events"}
}

// GroupsOrErr returns the Groups value or an error if the edge
// was not loaded in eager-loading.
func (e InviteEdges) GroupsOrErr() ([]*Group, error) {
	if e.loadedTypes[2] {
		return e.Groups, nil
	}
	return nil, &NotLoadedError{edge: "groups"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Invite) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case invite.FieldSecret:
			values[i] = new([]byte)
		case invite.FieldOwnershipTransfer:
			values[i] = new(sql.NullBool)
		case invite.FieldSendAttempts:
			values[i] = new(sql.NullInt64)
		case invite.FieldID, invite.FieldCreatedBy, invite.FieldUpdatedBy, invite.FieldDeletedBy, invite.FieldRequestorID, invite.FieldOwnerID, invite.FieldToken, invite.FieldRecipient, invite.FieldStatus, invite.FieldRole:
			values[i] = new(sql.NullString)
		case invite.FieldCreatedAt, invite.FieldUpdatedAt, invite.FieldDeletedAt, invite.FieldExpires:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Invite fields.
func (_m *Invite) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case invite.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				_m.ID = value.String
			}
		case invite.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				_m.CreatedAt = value.Time
			}
		case invite.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				_m.UpdatedAt = value.Time
			}
		case invite.FieldCreatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field created_by", values[i])
			} else if value.Valid {
				_m.CreatedBy = value.String
			}
		case invite.FieldUpdatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field updated_by", values[i])
			} else if value.Valid {
				_m.UpdatedBy = value.String
			}
		case invite.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				_m.DeletedAt = value.Time
			}
		case invite.FieldDeletedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_by", values[i])
			} else if value.Valid {
				_m.DeletedBy = value.String
			}
		case invite.FieldRequestorID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field requestor_id", values[i])
			} else if value.Valid {
				_m.RequestorID = value.String
			}
		case invite.FieldOwnerID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field owner_id", values[i])
			} else if value.Valid {
				_m.OwnerID = value.String
			}
		case invite.FieldToken:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field token", values[i])
			} else if value.Valid {
				_m.Token = value.String
			}
		case invite.FieldExpires:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field expires", values[i])
			} else if value.Valid {
				_m.Expires = value.Time
			}
		case invite.FieldRecipient:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field recipient", values[i])
			} else if value.Valid {
				_m.Recipient = value.String
			}
		case invite.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				_m.Status = enums.InviteStatus(value.String)
			}
		case invite.FieldRole:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field role", values[i])
			} else if value.Valid {
				_m.Role = enums.Role(value.String)
			}
		case invite.FieldSendAttempts:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field send_attempts", values[i])
			} else if value.Valid {
				_m.SendAttempts = int(value.Int64)
			}
		case invite.FieldSecret:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field secret", values[i])
			} else if value != nil {
				_m.Secret = value
			}
		case invite.FieldOwnershipTransfer:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field ownership_transfer", values[i])
			} else if value.Valid {
				_m.OwnershipTransfer = value.Bool
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Invite.
// This includes values selected through modifiers, order, etc.
func (_m *Invite) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// QueryOwner queries the "owner" edge of the Invite entity.
func (_m *Invite) QueryOwner() *OrganizationQuery {
	return NewInviteClient(_m.config).QueryOwner(_m)
}

// QueryEvents queries the "events" edge of the Invite entity.
func (_m *Invite) QueryEvents() *EventQuery {
	return NewInviteClient(_m.config).QueryEvents(_m)
}

// QueryGroups queries the "groups" edge of the Invite entity.
func (_m *Invite) QueryGroups() *GroupQuery {
	return NewInviteClient(_m.config).QueryGroups(_m)
}

// Update returns a builder for updating this Invite.
// Note that you need to call Invite.Unwrap() before calling this method if this Invite
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *Invite) Update() *InviteUpdateOne {
	return NewInviteClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the Invite entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *Invite) Unwrap() *Invite {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("generated: Invite is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *Invite) String() string {
	var builder strings.Builder
	builder.WriteString("Invite(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("created_at=")
	builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(_m.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("created_by=")
	builder.WriteString(_m.CreatedBy)
	builder.WriteString(", ")
	builder.WriteString("updated_by=")
	builder.WriteString(_m.UpdatedBy)
	builder.WriteString(", ")
	builder.WriteString("deleted_at=")
	builder.WriteString(_m.DeletedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("deleted_by=")
	builder.WriteString(_m.DeletedBy)
	builder.WriteString(", ")
	builder.WriteString("requestor_id=")
	builder.WriteString(_m.RequestorID)
	builder.WriteString(", ")
	builder.WriteString("owner_id=")
	builder.WriteString(_m.OwnerID)
	builder.WriteString(", ")
	builder.WriteString("token=<sensitive>")
	builder.WriteString(", ")
	builder.WriteString("expires=")
	builder.WriteString(_m.Expires.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("recipient=")
	builder.WriteString(_m.Recipient)
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(fmt.Sprintf("%v", _m.Status))
	builder.WriteString(", ")
	builder.WriteString("role=")
	builder.WriteString(fmt.Sprintf("%v", _m.Role))
	builder.WriteString(", ")
	builder.WriteString("send_attempts=")
	builder.WriteString(fmt.Sprintf("%v", _m.SendAttempts))
	builder.WriteString(", ")
	builder.WriteString("secret=<sensitive>")
	builder.WriteString(", ")
	builder.WriteString("ownership_transfer=")
	builder.WriteString(fmt.Sprintf("%v", _m.OwnershipTransfer))
	builder.WriteByte(')')
	return builder.String()
}

// NamedEvents returns the Events named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *Invite) NamedEvents(name string) ([]*Event, error) {
	if _m.Edges.namedEvents == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedEvents[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *Invite) appendNamedEvents(name string, edges ...*Event) {
	if _m.Edges.namedEvents == nil {
		_m.Edges.namedEvents = make(map[string][]*Event)
	}
	if len(edges) == 0 {
		_m.Edges.namedEvents[name] = []*Event{}
	} else {
		_m.Edges.namedEvents[name] = append(_m.Edges.namedEvents[name], edges...)
	}
}

// NamedGroups returns the Groups named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *Invite) NamedGroups(name string) ([]*Group, error) {
	if _m.Edges.namedGroups == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedGroups[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *Invite) appendNamedGroups(name string, edges ...*Group) {
	if _m.Edges.namedGroups == nil {
		_m.Edges.namedGroups = make(map[string][]*Group)
	}
	if len(edges) == 0 {
		_m.Edges.namedGroups[name] = []*Group{}
	} else {
		_m.Edges.namedGroups[name] = append(_m.Edges.namedGroups[name], edges...)
	}
}

// Invites is a parsable slice of Invite.
type Invites []*Invite
