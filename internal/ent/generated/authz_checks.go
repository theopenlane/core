// Code generated by entfga, DO NOT EDIT.
package generated

import (
	"context"
	"errors"

	"entgo.io/ent/privacy"
	"github.com/99designs/gqlgen/graphql"
	"github.com/rs/zerolog/log"

	"github.com/theopenlane/core/internal/ent/generated/groupmembership"
	"github.com/theopenlane/core/internal/ent/generated/groupsetting"
	"github.com/theopenlane/core/internal/ent/generated/organizationsetting"
	"github.com/theopenlane/core/internal/ent/generated/orgmembership"
	"github.com/theopenlane/core/internal/ent/generated/programmembership"
	"github.com/theopenlane/iam/auth"
	"github.com/theopenlane/iam/fgax"
)

var (
	ErrPermissionDenied = errors.New("you are not authorized to perform this action")
)

func (q *ActionPlanQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ActionPlanWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "action_plan",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *ActionPlanMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "action_plan",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *ActionPlanMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "action_plan",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *ActionPlanHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ActionPlanHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "action_plan",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *ControlQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ControlWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "control",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *ControlMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "control",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *ControlMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "control",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *ControlHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ControlHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "control",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *ControlImplementationQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ControlImplementationWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "control_implementation",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *ControlImplementationMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "control_implementation",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *ControlImplementationMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "control_implementation",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *ControlImplementationHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ControlImplementationHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "control_implementation",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *ControlObjectiveQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ControlObjectiveWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "control_objective",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *ControlObjectiveMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "control_objective",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *ControlObjectiveMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "control_objective",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *ControlObjectiveHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ControlObjectiveHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "control_objective",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *DocumentDataQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*DocumentDataWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "document_data",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *DocumentDataMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "document_data",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *DocumentDataMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "document_data",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *DocumentDataHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*DocumentDataHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "document_data",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *EvidenceQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*EvidenceWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "evidence",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *EvidenceMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "evidence",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *EvidenceMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "evidence",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *EvidenceHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*EvidenceHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "evidence",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *FileQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*FileWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "file",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *FileMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "file",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *FileMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "file",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *FileHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*FileHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "file",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *GroupQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*GroupWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "group",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *GroupMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "group",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *GroupMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "group",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *GroupHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*GroupHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "group",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *GroupMembershipQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*GroupMembershipWhereInput)
		if ok && where != nil && where.GroupID != nil {
			objectID = *where.GroupID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["groupid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.GroupID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "group",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *GroupMembershipMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateGroupMembershipInput
	input, ok := gInput.(CreateGroupMembershipInput)
	if ok {
		objectID = input.GroupID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["groupid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().GroupMembership.Query().Where(groupmembership.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.GroupID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "group",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *GroupMembershipMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "group",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *GroupMembershipHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*GroupMembershipHistoryWhereInput)
		if ok && where != nil && where.GroupID != nil {
			objectID = *where.GroupID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["groupid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.GroupID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "group",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *GroupSettingQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*GroupSettingWhereInput)
		if ok && where != nil && where.GroupID != nil {
			objectID = *where.GroupID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["groupid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.GroupID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "group",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *GroupSettingMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateGroupSettingInput
	input, ok := gInput.(CreateGroupSettingInput)
	if ok {
		objectID = *input.GroupID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["groupid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().GroupSetting.Query().Where(groupsetting.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.GroupID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "group",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *GroupSettingMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "group",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *GroupSettingHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*GroupSettingHistoryWhereInput)
		if ok && where != nil && where.GroupID != nil {
			objectID = *where.GroupID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["groupid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.GroupID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "group",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *InternalPolicyQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*InternalPolicyWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "internal_policy",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *InternalPolicyMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "internal_policy",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *InternalPolicyMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "internal_policy",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *InternalPolicyHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*InternalPolicyHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "internal_policy",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *NarrativeQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*NarrativeWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "narrative",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *NarrativeMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "narrative",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *NarrativeMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "narrative",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *NarrativeHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*NarrativeHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "narrative",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *NoteQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*NoteWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "note",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *NoteMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "note",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *NoteMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "note",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *NoteHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*NoteHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "note",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *OrgMembershipQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*OrgMembershipWhereInput)
		if ok && where != nil && where.OrganizationID != nil {
			objectID = *where.OrganizationID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["organizationid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.OrganizationID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *OrgMembershipMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateOrgMembershipInput
	input, ok := gInput.(CreateOrgMembershipInput)
	if ok {
		objectID = input.OrganizationID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["organizationid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().OrgMembership.Query().Where(orgmembership.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.OrganizationID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *OrgMembershipMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *OrgMembershipHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*OrgMembershipHistoryWhereInput)
		if ok && where != nil && where.OrganizationID != nil {
			objectID = *where.OrganizationID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["organizationid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.OrganizationID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *OrganizationQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*OrganizationWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *OrganizationMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *OrganizationMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *OrganizationHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*OrganizationHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *OrganizationSettingQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*OrganizationSettingWhereInput)
		if ok && where != nil && where.OrganizationID != nil {
			objectID = *where.OrganizationID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["organizationid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.OrganizationID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *OrganizationSettingMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateOrganizationSettingInput
	input, ok := gInput.(CreateOrganizationSettingInput)
	if ok {
		objectID = *input.OrganizationID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["organizationid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().OrganizationSetting.Query().Where(organizationsetting.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.OrganizationID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *OrganizationSettingMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *OrganizationSettingHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*OrganizationSettingHistoryWhereInput)
		if ok && where != nil && where.OrganizationID != nil {
			objectID = *where.OrganizationID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["organizationid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.OrganizationID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *ProcedureQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ProcedureWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "procedure",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *ProcedureMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "procedure",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *ProcedureMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "procedure",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *ProcedureHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ProcedureHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "procedure",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *ProgramQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ProgramWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "program",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *ProgramMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "program",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *ProgramMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "program",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *ProgramHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ProgramHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "program",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *ProgramMembershipQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ProgramMembershipWhereInput)
		if ok && where != nil && where.ProgramID != nil {
			objectID = *where.ProgramID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["programid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.ProgramID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "program",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *ProgramMembershipMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateProgramMembershipInput
	input, ok := gInput.(CreateProgramMembershipInput)
	if ok {
		objectID = input.ProgramID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["programid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().ProgramMembership.Query().Where(programmembership.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.ProgramID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "program",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *ProgramMembershipMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "program",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *ProgramMembershipHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ProgramMembershipHistoryWhereInput)
		if ok && where != nil && where.ProgramID != nil {
			objectID = *where.ProgramID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["programid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.ProgramID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "program",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *RiskQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*RiskWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "risk",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *RiskMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "risk",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *RiskMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "risk",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *RiskHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*RiskHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "risk",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *SubcontrolQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*SubcontrolWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "subcontrol",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *SubcontrolMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "subcontrol",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *SubcontrolMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "subcontrol",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *SubcontrolHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*SubcontrolHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "subcontrol",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *TaskQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*TaskWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "task",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *TaskMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "task",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *TaskMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "task",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *TaskHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	subjectID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get user id from context")

		return err
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*TaskHistoryWhereInput)
		if ok && where != nil && where.Ref != nil {
			objectID = *where.Ref
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["ref"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.Ref
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanViewAuditLog,
		ObjectType:  "task",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   subjectID,
		ObjectID:    objectID,
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
