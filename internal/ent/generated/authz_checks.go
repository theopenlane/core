// Code generated by entfga, DO NOT EDIT.
package generated

import (
	"context"
	"errors"
	"strings"

	"entgo.io/ent/privacy"
	"github.com/99designs/gqlgen/graphql"
	"github.com/rs/zerolog/log"

	"github.com/theopenlane/core/internal/ent/generated/groupmembership"
	"github.com/theopenlane/core/internal/ent/generated/groupsetting"
	"github.com/theopenlane/core/internal/ent/generated/organizationsetting"
	"github.com/theopenlane/core/internal/ent/generated/orgmembership"
	"github.com/theopenlane/core/internal/ent/generated/programmembership"
	"github.com/theopenlane/core/internal/ent/generated/trustcentercompliance"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterdoc"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterentity"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterfaq"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterndarequest"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersetting"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersubprocessor"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterwatermarkconfig"
	"github.com/theopenlane/iam/auth"
	"github.com/theopenlane/iam/fgax"
)

var (
	ErrPermissionDenied = errors.New("you are not authorized to perform this action")
)

// newOrganizationContextKey creates a new context key for organization checks
// if the full email is provided it will take the domain after the `@` symbol
func newOrganizationContextKey(e string) *map[string]any {
	domain := e
	if strings.Contains(e, "@") {
		domain = strings.Split(e, "@")[1]
	}

	return &map[string]any{
		"email_domain": domain,
	}
}

func (q *ActionPlanQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ActionPlanWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "action_plan",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *ActionPlanMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "action_plan",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *ActionPlanMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "action_plan",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *AssessmentQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*AssessmentWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "assessment",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *AssessmentMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "assessment",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *AssessmentMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "assessment",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *AssessmentResponseQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*AssessmentResponseWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "assessment_response",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *AssessmentResponseMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "assessment_response",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *AssessmentResponseMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "assessment_response",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *AssetQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*AssetWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "asset",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *AssetMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "asset",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *AssetMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "asset",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *CampaignQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*CampaignWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "campaign",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *CampaignMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "campaign",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *CampaignMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "campaign",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *CampaignTargetQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*CampaignTargetWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "campaign_target",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *CampaignTargetMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "campaign_target",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *CampaignTargetMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "campaign_target",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *ControlQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ControlWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "control",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *ControlMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "control",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *ControlMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "control",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *ControlImplementationQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ControlImplementationWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "control_implementation",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *ControlImplementationMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "control_implementation",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *ControlImplementationMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "control_implementation",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *ControlObjectiveQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ControlObjectiveWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "control_objective",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *ControlObjectiveMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "control_objective",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *ControlObjectiveMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "control_objective",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *DiscussionQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*DiscussionWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "discussion",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *DiscussionMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "discussion",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *DiscussionMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "discussion",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *DocumentDataQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*DocumentDataWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "document_data",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *DocumentDataMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "document_data",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *DocumentDataMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "document_data",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *EntityQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*EntityWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "entity",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *EntityMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "entity",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *EntityMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "entity",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *EvidenceQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*EvidenceWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "evidence",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *EvidenceMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "evidence",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *EvidenceMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "evidence",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *FileQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*FileWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "file",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *FileMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "file",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *FileMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "file",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *FindingQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*FindingWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "finding",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *FindingMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "finding",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *FindingMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "finding",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *FindingControlQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*FindingControlWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "finding_control",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *FindingControlMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "finding_control",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *FindingControlMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "finding_control",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *GroupQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*GroupWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "group",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *GroupMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "group",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *GroupMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "group",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *GroupMembershipQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*GroupMembershipWhereInput)
		if ok && where != nil && where.GroupID != nil {
			objectID = *where.GroupID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["groupid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.GroupID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "group",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *GroupMembershipMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateGroupMembershipInput
	input, ok := gInput.(CreateGroupMembershipInput)
	if ok {
		objectID = input.GroupID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["groupid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().GroupMembership.Query().Where(groupmembership.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.GroupID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "group",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *GroupMembershipMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "group",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *GroupSettingQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*GroupSettingWhereInput)
		if ok && where != nil && where.GroupID != nil {
			objectID = *where.GroupID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["groupid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.GroupID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "group",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *GroupSettingMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateGroupSettingInput
	input, ok := gInput.(CreateGroupSettingInput)
	if ok {
		objectID = *input.GroupID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["groupid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().GroupSetting.Query().Where(groupsetting.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.GroupID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "group",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *GroupSettingMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "group",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *IdentityHolderQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*IdentityHolderWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "identity_holder",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *IdentityHolderMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "identity_holder",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *IdentityHolderMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "identity_holder",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *InternalPolicyQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*InternalPolicyWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "internal_policy",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *InternalPolicyMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "internal_policy",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *InternalPolicyMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "internal_policy",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *JobTemplateQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*JobTemplateWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "job_template",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *JobTemplateMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "job_template",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *JobTemplateMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "job_template",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *MappedControlQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*MappedControlWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "mapped_control",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *MappedControlMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "mapped_control",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *MappedControlMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "mapped_control",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *NarrativeQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*NarrativeWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "narrative",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *NarrativeMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "narrative",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *NarrativeMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "narrative",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *NoteQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*NoteWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "note",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *NoteMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "note",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *NoteMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "note",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *OrgMembershipQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*OrgMembershipWhereInput)
		if ok && where != nil && where.OrganizationID != nil {
			objectID = *where.OrganizationID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["organizationid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.OrganizationID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *OrgMembershipMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateOrgMembershipInput
	input, ok := gInput.(CreateOrgMembershipInput)
	if ok {
		objectID = input.OrganizationID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["organizationid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().OrgMembership.Query().Where(orgmembership.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.OrganizationID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *OrgMembershipMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *OrganizationQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*OrganizationWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *OrganizationMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *OrganizationMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *OrganizationSettingQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*OrganizationSettingWhereInput)
		if ok && where != nil && where.OrganizationID != nil {
			objectID = *where.OrganizationID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["organizationid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.OrganizationID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *OrganizationSettingMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateOrganizationSettingInput
	input, ok := gInput.(CreateOrganizationSettingInput)
	if ok {
		objectID = *input.OrganizationID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["organizationid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().OrganizationSetting.Query().Where(organizationsetting.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.OrganizationID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *OrganizationSettingMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *PlatformQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*PlatformWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "platform",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *PlatformMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "platform",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *PlatformMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "platform",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *ProcedureQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ProcedureWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "procedure",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *ProcedureMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "procedure",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *ProcedureMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "procedure",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *ProgramQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ProgramWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "program",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *ProgramMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "program",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *ProgramMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "program",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *ProgramMembershipQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ProgramMembershipWhereInput)
		if ok && where != nil && where.ProgramID != nil {
			objectID = *where.ProgramID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["programid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.ProgramID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "program",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *ProgramMembershipMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateProgramMembershipInput
	input, ok := gInput.(CreateProgramMembershipInput)
	if ok {
		objectID = input.ProgramID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["programid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().ProgramMembership.Query().Where(programmembership.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.ProgramID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "program",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *ProgramMembershipMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "program",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *RemediationQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*RemediationWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "remediation",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *RemediationMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "remediation",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *RemediationMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "remediation",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *ReviewQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*ReviewWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "review",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *ReviewMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "review",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *ReviewMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "review",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *RiskQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*RiskWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "risk",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *RiskMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "risk",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *RiskMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "risk",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *SubcontrolQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*SubcontrolWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "subcontrol",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *SubcontrolMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "subcontrol",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *SubcontrolMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "subcontrol",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *SubprocessorQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*SubprocessorWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "subprocessor",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *SubprocessorMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "subprocessor",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *SubprocessorMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "subprocessor",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *TaskQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*TaskWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "task",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *TaskMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "task",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *TaskMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "task",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *TemplateQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*TemplateWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "template",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *TemplateMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "template",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *TemplateMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "template",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *TrustCenterQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*TrustCenterWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "trust_center",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *TrustCenterMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *TrustCenterMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *TrustCenterComplianceQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*TrustCenterComplianceWhereInput)
		if ok && where != nil && where.TrustCenterID != nil {
			objectID = *where.TrustCenterID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.TrustCenterID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "trust_center",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *TrustCenterComplianceMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateTrustCenterComplianceInput
	input, ok := gInput.(CreateTrustCenterComplianceInput)
	if ok {
		objectID = *input.TrustCenterID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().TrustCenterCompliance.Query().Where(trustcentercompliance.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.TrustCenterID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *TrustCenterComplianceMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *TrustCenterDocQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*TrustCenterDocWhereInput)
		if ok && where != nil && where.TrustCenterID != nil {
			objectID = *where.TrustCenterID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.TrustCenterID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "trust_center",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *TrustCenterDocMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateTrustCenterDocInput
	input, ok := gInput.(CreateTrustCenterDocInput)
	if ok {
		objectID = *input.TrustCenterID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().TrustCenterDoc.Query().Where(trustcenterdoc.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.TrustCenterID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *TrustCenterDocMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *TrustCenterEntityQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*TrustCenterEntityWhereInput)
		if ok && where != nil && where.TrustCenterID != nil {
			objectID = *where.TrustCenterID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.TrustCenterID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "trust_center",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *TrustCenterEntityMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateTrustCenterEntityInput
	input, ok := gInput.(CreateTrustCenterEntityInput)
	if ok {
		objectID = *input.TrustCenterID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().TrustCenterEntity.Query().Where(trustcenterentity.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.TrustCenterID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *TrustCenterEntityMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *TrustCenterFAQQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*TrustCenterFAQWhereInput)
		if ok && where != nil && where.TrustCenterID != nil {
			objectID = *where.TrustCenterID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.TrustCenterID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "trust_center",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *TrustCenterFAQMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateTrustCenterFAQInput
	input, ok := gInput.(CreateTrustCenterFAQInput)
	if ok {
		objectID = *input.TrustCenterID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().TrustCenterFAQ.Query().Where(trustcenterfaq.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.TrustCenterID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *TrustCenterFAQMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *TrustCenterNDARequestQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*TrustCenterNDARequestWhereInput)
		if ok && where != nil && where.TrustCenterID != nil {
			objectID = *where.TrustCenterID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.TrustCenterID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "trust_center",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *TrustCenterNDARequestMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateTrustCenterNDARequestInput
	input, ok := gInput.(CreateTrustCenterNDARequestInput)
	if ok {
		objectID = *input.TrustCenterID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().TrustCenterNDARequest.Query().Where(trustcenterndarequest.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.TrustCenterID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *TrustCenterNDARequestMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *TrustCenterSettingQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*TrustCenterSettingWhereInput)
		if ok && where != nil && where.TrustCenterID != nil {
			objectID = *where.TrustCenterID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.TrustCenterID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "trust_center",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *TrustCenterSettingMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateTrustCenterSettingInput
	input, ok := gInput.(CreateTrustCenterSettingInput)
	if ok {
		objectID = *input.TrustCenterID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().TrustCenterSetting.Query().Where(trustcentersetting.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.TrustCenterID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *TrustCenterSettingMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *TrustCenterSubprocessorQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*TrustCenterSubprocessorWhereInput)
		if ok && where != nil && where.TrustCenterID != nil {
			objectID = *where.TrustCenterID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.TrustCenterID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "trust_center",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *TrustCenterSubprocessorMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateTrustCenterSubprocessorInput
	input, ok := gInput.(CreateTrustCenterSubprocessorInput)
	if ok {
		objectID = *input.TrustCenterID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().TrustCenterSubprocessor.Query().Where(trustcentersubprocessor.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.TrustCenterID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *TrustCenterSubprocessorMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *TrustCenterWatermarkConfigQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*TrustCenterWatermarkConfigWhereInput)
		if ok && where != nil && where.TrustCenterID != nil {
			objectID = *where.TrustCenterID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens on join tables where we have the join ID (for updates and deletes)
	// and not the actual object id
	if objectID == "" {
		// allow this query to run
		reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

		ob, err := q.Clone().Only(reqCtx)
		if err != nil {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		objectID = ob.TrustCenterID
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "trust_center",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *TrustCenterWatermarkConfigMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateTrustCenterWatermarkConfigInput
	input, ok := gInput.(CreateTrustCenterWatermarkConfigInput)
	if ok {
		objectID = *input.TrustCenterID

	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["trustcenterid"].(string)
	}
	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if objectID == "" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().TrustCenterWatermarkConfig.Query().Where(trustcenterwatermarkconfig.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			objectID = ob.TrustCenterID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *TrustCenterWatermarkConfigMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "trust_center",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *VulnerabilityQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*VulnerabilityWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "vulnerability",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *VulnerabilityMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "vulnerability",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *VulnerabilityMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "vulnerability",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *WorkflowAssignmentQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*WorkflowAssignmentWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "workflow_assignment",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *WorkflowAssignmentMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "workflow_assignment",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *WorkflowAssignmentMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "workflow_assignment",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *WorkflowDefinitionQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*WorkflowDefinitionWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "workflow_definition",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *WorkflowDefinitionMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "workflow_definition",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *WorkflowDefinitionMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "workflow_definition",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *WorkflowEventQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*WorkflowEventWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "workflow_event",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *WorkflowEventMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "workflow_event",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *WorkflowEventMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "workflow_event",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *WorkflowInstanceQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*WorkflowInstanceWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "workflow_instance",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *WorkflowInstanceMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "workflow_instance",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *WorkflowInstanceMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "workflow_instance",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (q *WorkflowObjectRefQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	var objectID string

	// check id from graphql arg context
	// when all objects are requested, the interceptor will check object access
	// check the where input first
	whereArg := gCtx.Args["where"]
	if whereArg != nil {
		where, ok := whereArg.(*WorkflowObjectRefWhereInput)
		if ok && where != nil && where.ID != nil {
			objectID = *where.ID
		}
	}

	// if that doesn't work, check for the id in the request args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	// check if the user has access to the object requested
	ac := fgax.AccessCheck{
		Relation:    fgax.CanView,
		ObjectType:  "workflow_object_ref",
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		ObjectID:    objectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	access, err := q.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *WorkflowObjectRefMutation) CheckAccessForEdit(ctx context.Context) error {
	var objectID string

	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	// check the id from the args
	if objectID == "" {
		objectID, _ = gCtx.Args["id"].(string)
	}

	// request is for a list objects, will get filtered in interceptors
	if objectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "workflow_object_ref",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}

func (m *WorkflowObjectRefMutation) CheckAccessForDelete(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)
	if gCtx == nil {
		// Skip to the next privacy rule (equivalent to return nil)
		// if this is not a graphql request
		return privacy.Skipf("not a graphql request, no context to check")
	}

	objectID, ok := gCtx.Args["id"].(string)
	if !ok {
		log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

		return privacy.Allowf("nil request, bypassing auth check")
	}

	au, err := auth.GetAuthenticatedUserFromContext(ctx)
	if err != nil {
		log.Error().Err(err).Msg("unable to get authenticated user from context")
		return privacy.Skipf("unable to get authenticated user from context")
	}

	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "workflow_object_ref",
		ObjectID:    objectID,
		SubjectType: auth.GetAuthzSubjectType(ctx),
		SubjectID:   au.SubjectID,
		Context:     newOrganizationContextKey(au.SubjectEmail),
	}

	log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err == nil && access {
		return privacy.Allow
	}

	log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

	// return error if the action is not allowed
	return ErrPermissionDenied
}
