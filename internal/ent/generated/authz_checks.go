// Code generated by entfga, DO NOT EDIT.
package generated

import (
	"context"

	"entgo.io/ent/privacy"
	"github.com/99designs/gqlgen/graphql"
	"github.com/rs/zerolog/log"

	"github.com/theopenlane/core/internal/ent/generated/file"
	"github.com/theopenlane/core/internal/ent/generated/group"
	"github.com/theopenlane/core/internal/ent/generated/groupmembership"
	"github.com/theopenlane/core/internal/ent/generated/groupsetting"
	"github.com/theopenlane/core/internal/ent/generated/organization"
	"github.com/theopenlane/core/internal/ent/generated/organizationsetting"
	"github.com/theopenlane/core/internal/ent/generated/orgmembership"
	"github.com/theopenlane/core/internal/ent/generated/programmembership"
	"github.com/theopenlane/core/internal/ent/generated/task"
	"github.com/theopenlane/core/internal/ent/generated/webhook"
	"github.com/theopenlane/iam/auth"
	"github.com/theopenlane/iam/fgax"
)

func (q *APITokenQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*APITokenWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *APITokenMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}
	orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens when using a personal access token since it is authorized for multiple orgs
	if orgID == "" || oErr != nil {
		id, _ := m.ID()

		if id != "" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().APIToken.Get(reqCtx, id)
			if err != nil {
				log.Debug().Err(err).Msg("error getting object")

				return err
			}

			orgID = ob.OwnerID
		}
	}

	ac.ObjectID = orgID

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *APITokenMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *ContactQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*ContactWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *ContactMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}
	orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens when using a personal access token since it is authorized for multiple orgs
	if orgID == "" || oErr != nil {
		id, _ := m.ID()

		if id != "" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().Contact.Get(reqCtx, id)
			if err != nil {
				log.Debug().Err(err).Msg("error getting object")

				return err
			}

			orgID = ob.OwnerID
		}
	}

	ac.ObjectID = orgID

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *ContactMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *ContactHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*ContactHistoryWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *DocumentDataQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*DocumentDataWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *DocumentDataMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}
	orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens when using a personal access token since it is authorized for multiple orgs
	if orgID == "" || oErr != nil {
		id, _ := m.ID()

		if id != "" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().DocumentData.Get(reqCtx, id)
			if err != nil {
				log.Debug().Err(err).Msg("error getting object")

				return err
			}

			orgID = ob.OwnerID
		}
	}

	ac.ObjectID = orgID

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *DocumentDataMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *DocumentDataHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*DocumentDataHistoryWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *EntitlementQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*EntitlementWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *EntitlementMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}
	orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens when using a personal access token since it is authorized for multiple orgs
	if orgID == "" || oErr != nil {
		id, _ := m.ID()

		if id != "" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().Entitlement.Get(reqCtx, id)
			if err != nil {
				log.Debug().Err(err).Msg("error getting object")

				return err
			}

			orgID = ob.OwnerID
		}
	}

	ac.ObjectID = orgID

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *EntitlementMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *EntitlementHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*EntitlementHistoryWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *EntitlementPlanQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*EntitlementPlanWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *EntitlementPlanMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}
	orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens when using a personal access token since it is authorized for multiple orgs
	if orgID == "" || oErr != nil {
		id, _ := m.ID()

		if id != "" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().EntitlementPlan.Get(reqCtx, id)
			if err != nil {
				log.Debug().Err(err).Msg("error getting object")

				return err
			}

			orgID = ob.OwnerID
		}
	}

	ac.ObjectID = orgID

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *EntitlementPlanMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *EntitlementPlanFeatureQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*EntitlementPlanFeatureWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *EntitlementPlanFeatureMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}
	orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens when using a personal access token since it is authorized for multiple orgs
	if orgID == "" || oErr != nil {
		id, _ := m.ID()

		if id != "" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().EntitlementPlanFeature.Get(reqCtx, id)
			if err != nil {
				log.Debug().Err(err).Msg("error getting object")

				return err
			}

			orgID = ob.OwnerID
		}
	}

	ac.ObjectID = orgID

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *EntitlementPlanFeatureMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *EntitlementPlanFeatureHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*EntitlementPlanFeatureHistoryWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *EntitlementPlanHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*EntitlementPlanHistoryWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *EntityQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*EntityWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *EntityMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}
	orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens when using a personal access token since it is authorized for multiple orgs
	if orgID == "" || oErr != nil {
		id, _ := m.ID()

		if id != "" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().Entity.Get(reqCtx, id)
			if err != nil {
				log.Debug().Err(err).Msg("error getting object")

				return err
			}

			orgID = ob.OwnerID
		}
	}

	ac.ObjectID = orgID

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *EntityMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *EntityHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*EntityHistoryWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *EntityTypeQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*EntityTypeWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *EntityTypeMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}
	orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens when using a personal access token since it is authorized for multiple orgs
	if orgID == "" || oErr != nil {
		id, _ := m.ID()

		if id != "" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().EntityType.Get(reqCtx, id)
			if err != nil {
				log.Debug().Err(err).Msg("error getting object")

				return err
			}

			orgID = ob.OwnerID
		}
	}

	ac.ObjectID = orgID

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *EntityTypeMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *EntityTypeHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*EntityTypeHistoryWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *FeatureQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*FeatureWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *FeatureMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}
	orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens when using a personal access token since it is authorized for multiple orgs
	if orgID == "" || oErr != nil {
		id, _ := m.ID()

		if id != "" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().Feature.Get(reqCtx, id)
			if err != nil {
				log.Debug().Err(err).Msg("error getting object")

				return err
			}

			orgID = ob.OwnerID
		}
	}

	ac.ObjectID = orgID

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *FeatureMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *FeatureHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*FeatureHistoryWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *FileQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "file",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*FileWhereInput)
			if ok && where != nil && where.ID != nil {
				ac.ObjectID = *where.ID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["id"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "id" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.ID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *FileMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "file",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	// check the id from the args
	if ac.ObjectID == "" {
		ac.ObjectID, _ = gCtx.Args["id"].(string)
	}

	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if ac.ObjectID == "" && "id" != "id" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().File.Query().Where(file.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			ac.ObjectID = ob.ID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *FileMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "file",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *FileHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "file",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*FileHistoryWhereInput)
			if ok && where != nil && where.Ref != nil {
				ac.ObjectID = *where.Ref
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ref"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ref" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.Ref
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *GroupQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "group",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*GroupWhereInput)
			if ok && where != nil && where.ID != nil {
				ac.ObjectID = *where.ID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["id"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "id" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.ID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *GroupMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "group",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	// check the id from the args
	if ac.ObjectID == "" {
		ac.ObjectID, _ = gCtx.Args["id"].(string)
	}

	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if ac.ObjectID == "" && "id" != "id" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().Group.Query().Where(group.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			ac.ObjectID = ob.ID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *GroupMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "group",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *GroupHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "group",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*GroupHistoryWhereInput)
			if ok && where != nil && where.Ref != nil {
				ac.ObjectID = *where.Ref
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ref"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ref" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.Ref
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *GroupMembershipQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "group",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*GroupMembershipWhereInput)
			if ok && where != nil && where.GroupID != nil {
				ac.ObjectID = *where.GroupID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["groupid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "groupid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.GroupID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *GroupMembershipMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "group",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateGroupMembershipInput
	input, ok := gInput.(CreateGroupMembershipInput)
	if ok {
		ac.ObjectID = input.GroupID

	}

	// check the id from the args
	if ac.ObjectID == "" {
		ac.ObjectID, _ = gCtx.Args["groupid"].(string)
	}

	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if ac.ObjectID == "" && "id" != "groupid" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().GroupMembership.Query().Where(groupmembership.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			ac.ObjectID = ob.GroupID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *GroupMembershipMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "group",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *GroupMembershipHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "group",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*GroupMembershipHistoryWhereInput)
			if ok && where != nil && where.GroupID != nil {
				ac.ObjectID = *where.GroupID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["groupid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "groupid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.GroupID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *GroupSettingQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "group",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*GroupSettingWhereInput)
			if ok && where != nil && where.GroupID != nil {
				ac.ObjectID = *where.GroupID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["groupid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "groupid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.GroupID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *GroupSettingMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "group",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateGroupSettingInput
	input, ok := gInput.(CreateGroupSettingInput)
	if ok {
		ac.ObjectID = *input.GroupID

	}

	// check the id from the args
	if ac.ObjectID == "" {
		ac.ObjectID, _ = gCtx.Args["groupid"].(string)
	}

	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if ac.ObjectID == "" && "id" != "groupid" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().GroupSetting.Query().Where(groupsetting.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			ac.ObjectID = ob.GroupID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *GroupSettingMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "group",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *GroupSettingHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "group",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*GroupSettingHistoryWhereInput)
			if ok && where != nil && where.GroupID != nil {
				ac.ObjectID = *where.GroupID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["groupid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "groupid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.GroupID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *IntegrationQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*IntegrationWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *IntegrationMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}
	orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens when using a personal access token since it is authorized for multiple orgs
	if orgID == "" || oErr != nil {
		id, _ := m.ID()

		if id != "" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().Integration.Get(reqCtx, id)
			if err != nil {
				log.Debug().Err(err).Msg("error getting object")

				return err
			}

			orgID = ob.OwnerID
		}
	}

	ac.ObjectID = orgID

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *IntegrationMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *IntegrationHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*IntegrationHistoryWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *InviteQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*InviteWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *InviteMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}
	orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens when using a personal access token since it is authorized for multiple orgs
	if orgID == "" || oErr != nil {
		id, _ := m.ID()

		if id != "" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().Invite.Get(reqCtx, id)
			if err != nil {
				log.Debug().Err(err).Msg("error getting object")

				return err
			}

			orgID = ob.OwnerID
		}
	}

	ac.ObjectID = orgID

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *InviteMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *NoteQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*NoteWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *NoteMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}
	orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens when using a personal access token since it is authorized for multiple orgs
	if orgID == "" || oErr != nil {
		id, _ := m.ID()

		if id != "" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().Note.Get(reqCtx, id)
			if err != nil {
				log.Debug().Err(err).Msg("error getting object")

				return err
			}

			orgID = ob.OwnerID
		}
	}

	ac.ObjectID = orgID

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *NoteMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *NoteHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*NoteHistoryWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *OauthProviderQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*OauthProviderWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *OauthProviderMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}
	orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens when using a personal access token since it is authorized for multiple orgs
	if orgID == "" || oErr != nil {
		id, _ := m.ID()

		if id != "" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().OauthProvider.Get(reqCtx, id)
			if err != nil {
				log.Debug().Err(err).Msg("error getting object")

				return err
			}

			orgID = ob.OwnerID
		}
	}

	ac.ObjectID = orgID

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *OauthProviderMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *OauthProviderHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*OauthProviderHistoryWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *OrgMembershipQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*OrgMembershipWhereInput)
			if ok && where != nil && where.OrganizationID != nil {
				ac.ObjectID = *where.OrganizationID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["organizationid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "organizationid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OrganizationID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *OrgMembershipMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateOrgMembershipInput
	input, ok := gInput.(CreateOrgMembershipInput)
	if ok {
		ac.ObjectID = input.OrganizationID

	}

	// check the id from the args
	if ac.ObjectID == "" {
		ac.ObjectID, _ = gCtx.Args["organizationid"].(string)
	}

	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if ac.ObjectID == "" && "id" != "organizationid" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().OrgMembership.Query().Where(orgmembership.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			ac.ObjectID = ob.OrganizationID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *OrgMembershipMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *OrgMembershipHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*OrgMembershipHistoryWhereInput)
			if ok && where != nil && where.OrganizationID != nil {
				ac.ObjectID = *where.OrganizationID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["organizationid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "organizationid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OrganizationID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *OrganizationQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*OrganizationWhereInput)
			if ok && where != nil && where.ID != nil {
				ac.ObjectID = *where.ID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["id"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "id" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.ID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *OrganizationMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	// check the id from the args
	if ac.ObjectID == "" {
		ac.ObjectID, _ = gCtx.Args["id"].(string)
	}

	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if ac.ObjectID == "" && "id" != "id" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().Organization.Query().Where(organization.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			ac.ObjectID = ob.ID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *OrganizationMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *OrganizationHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*OrganizationHistoryWhereInput)
			if ok && where != nil && where.Ref != nil {
				ac.ObjectID = *where.Ref
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ref"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ref" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.Ref
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *OrganizationSettingQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*OrganizationSettingWhereInput)
			if ok && where != nil && where.OrganizationID != nil {
				ac.ObjectID = *where.OrganizationID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["organizationid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "organizationid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OrganizationID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *OrganizationSettingMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateOrganizationSettingInput
	input, ok := gInput.(CreateOrganizationSettingInput)
	if ok {
		ac.ObjectID = *input.OrganizationID

	}

	// check the id from the args
	if ac.ObjectID == "" {
		ac.ObjectID, _ = gCtx.Args["organizationid"].(string)
	}

	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if ac.ObjectID == "" && "id" != "organizationid" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().OrganizationSetting.Query().Where(organizationsetting.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			ac.ObjectID = ob.OrganizationID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *OrganizationSettingMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *OrganizationSettingHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*OrganizationSettingHistoryWhereInput)
			if ok && where != nil && where.OrganizationID != nil {
				ac.ObjectID = *where.OrganizationID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["organizationid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "organizationid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OrganizationID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *ProgramMembershipQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "program",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*ProgramMembershipWhereInput)
			if ok && where != nil && where.ProgramID != nil {
				ac.ObjectID = *where.ProgramID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["programid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "programid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.ProgramID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *ProgramMembershipMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "program",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateProgramMembershipInput
	input, ok := gInput.(CreateProgramMembershipInput)
	if ok {
		ac.ObjectID = input.ProgramID

	}

	// check the id from the args
	if ac.ObjectID == "" {
		ac.ObjectID, _ = gCtx.Args["programid"].(string)
	}

	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if ac.ObjectID == "" && "id" != "programid" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().ProgramMembership.Query().Where(programmembership.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			ac.ObjectID = ob.ProgramID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *ProgramMembershipMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "program",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *ProgramMembershipHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "program",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*ProgramMembershipHistoryWhereInput)
			if ok && where != nil && where.ProgramID != nil {
				ac.ObjectID = *where.ProgramID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["programid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "programid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.ProgramID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *SubscriberQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*SubscriberWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *SubscriberMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}
	orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens when using a personal access token since it is authorized for multiple orgs
	if orgID == "" || oErr != nil {
		id, _ := m.ID()

		if id != "" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().Subscriber.Get(reqCtx, id)
			if err != nil {
				log.Debug().Err(err).Msg("error getting object")

				return err
			}

			orgID = ob.OwnerID
		}
	}

	ac.ObjectID = orgID

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *SubscriberMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *TaskQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "task",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*TaskWhereInput)
			if ok && where != nil && where.ID != nil {
				ac.ObjectID = *where.ID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["id"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "id" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.ID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *TaskMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "task",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	// check the id from the args
	if ac.ObjectID == "" {
		ac.ObjectID, _ = gCtx.Args["id"].(string)
	}

	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if ac.ObjectID == "" && "id" != "id" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().Task.Query().Where(task.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			ac.ObjectID = ob.ID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *TaskMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "task",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *TaskHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "task",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*TaskHistoryWhereInput)
			if ok && where != nil && where.Ref != nil {
				ac.ObjectID = *where.Ref
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ref"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ref" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.Ref
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *TemplateQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*TemplateWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *TemplateMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}
	orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

	// if we still don't have an object id, run the query and grab the object ID
	// from the result
	// this happens when using a personal access token since it is authorized for multiple orgs
	if orgID == "" || oErr != nil {
		id, _ := m.ID()

		if id != "" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().Template.Get(reqCtx, id)
			if err != nil {
				log.Debug().Err(err).Msg("error getting object")

				return err
			}

			orgID = ob.OwnerID
		}
	}

	ac.ObjectID = orgID

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *TemplateMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *TemplateHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*TemplateHistoryWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (q *WebhookQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*WebhookWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
func (m *WebhookMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanEdit,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateWebhookInput
	input, ok := gInput.(CreateWebhookInput)
	if ok {
		ac.ObjectID = *input.OwnerID

	}

	// check the id from the args
	if ac.ObjectID == "" {
		ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
	}

	// if this is still empty, we need to query the object to get the object id
	// this happens on join tables where we have the join ID (for updates and deletes)
	if ac.ObjectID == "" && "id" != "ownerid" {
		id, ok := gCtx.Args["id"].(string)
		if ok {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := m.Client().Webhook.Query().Where(webhook.ID(id)).Only(reqCtx)
			if err != nil {
				return privacy.Skipf("nil request, skipping auth check")
			}
			ac.ObjectID = ob.OwnerID
		}
	}

	// request is for a list objects, will get filtered in interceptors
	if ac.ObjectID == "" {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *WebhookMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:    fgax.CanDelete,
		ObjectType:  "organization",
		SubjectType: auth.GetAuthzSubjectType(ctx),
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	log.Debug().Msg("checking mutation access")

	var err error
	ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	log.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		log.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *WebhookHistoryQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation:    fgax.CanView,
			ObjectType:  "organization",
			SubjectType: auth.GetAuthzSubjectType(ctx),
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		// check the where input first
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*WebhookHistoryWhereInput)
			if ok && where != nil && where.OwnerID != nil {
				ac.ObjectID = *where.OwnerID
			}
		}

		// if that doesn't work, check for the id in the args
		if ac.ObjectID == "" {
			ac.ObjectID, _ = gCtx.Args["ownerid"].(string)
		}

		// if we still don't have an object id, run the query and grab the object ID
		// from the result
		// this happens on join tables where we have the join ID (for updates and deletes)
		// and not the actual object id
		if ac.ObjectID == "" && "id" != "ownerid" {
			// allow this query to run
			reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
			ob, err := q.Clone().Only(reqCtx)
			if err != nil {
				return privacy.Allowf("nil request, bypassing auth check")
			}
			ac.ObjectID = ob.OwnerID
		}

		// request is for a list objects, will get filtered in interceptors
		if ac.ObjectID == "" {
			return privacy.Allowf("nil request, bypassing auth check")
		}

		var err error
		ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}
