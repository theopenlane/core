// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"database/sql/driver"
	"fmt"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/theopenlane/core/internal/ent/generated/actionplan"
	"github.com/theopenlane/core/internal/ent/generated/actionplanhistory"
	"github.com/theopenlane/core/internal/ent/generated/apitoken"
	"github.com/theopenlane/core/internal/ent/generated/contact"
	"github.com/theopenlane/core/internal/ent/generated/contacthistory"
	"github.com/theopenlane/core/internal/ent/generated/control"
	"github.com/theopenlane/core/internal/ent/generated/controlhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlobjective"
	"github.com/theopenlane/core/internal/ent/generated/controlobjectivehistory"
	"github.com/theopenlane/core/internal/ent/generated/documentdata"
	"github.com/theopenlane/core/internal/ent/generated/documentdatahistory"
	"github.com/theopenlane/core/internal/ent/generated/entity"
	"github.com/theopenlane/core/internal/ent/generated/entityhistory"
	"github.com/theopenlane/core/internal/ent/generated/entitytype"
	"github.com/theopenlane/core/internal/ent/generated/entitytypehistory"
	"github.com/theopenlane/core/internal/ent/generated/event"
	"github.com/theopenlane/core/internal/ent/generated/eventhistory"
	"github.com/theopenlane/core/internal/ent/generated/file"
	"github.com/theopenlane/core/internal/ent/generated/filehistory"
	"github.com/theopenlane/core/internal/ent/generated/group"
	"github.com/theopenlane/core/internal/ent/generated/grouphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupmembership"
	"github.com/theopenlane/core/internal/ent/generated/groupmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupsetting"
	"github.com/theopenlane/core/internal/ent/generated/groupsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/hush"
	"github.com/theopenlane/core/internal/ent/generated/hushhistory"
	"github.com/theopenlane/core/internal/ent/generated/integration"
	"github.com/theopenlane/core/internal/ent/generated/integrationhistory"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicy"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicyhistory"
	"github.com/theopenlane/core/internal/ent/generated/invite"
	"github.com/theopenlane/core/internal/ent/generated/narrative"
	"github.com/theopenlane/core/internal/ent/generated/narrativehistory"
	"github.com/theopenlane/core/internal/ent/generated/note"
	"github.com/theopenlane/core/internal/ent/generated/notehistory"
	"github.com/theopenlane/core/internal/ent/generated/organization"
	"github.com/theopenlane/core/internal/ent/generated/organizationhistory"
	"github.com/theopenlane/core/internal/ent/generated/organizationsetting"
	"github.com/theopenlane/core/internal/ent/generated/organizationsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/orgmembership"
	"github.com/theopenlane/core/internal/ent/generated/orgmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/orgsubscription"
	"github.com/theopenlane/core/internal/ent/generated/orgsubscriptionhistory"
	"github.com/theopenlane/core/internal/ent/generated/personalaccesstoken"
	"github.com/theopenlane/core/internal/ent/generated/procedure"
	"github.com/theopenlane/core/internal/ent/generated/procedurehistory"
	"github.com/theopenlane/core/internal/ent/generated/program"
	"github.com/theopenlane/core/internal/ent/generated/programhistory"
	"github.com/theopenlane/core/internal/ent/generated/programmembership"
	"github.com/theopenlane/core/internal/ent/generated/programmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/risk"
	"github.com/theopenlane/core/internal/ent/generated/riskhistory"
	"github.com/theopenlane/core/internal/ent/generated/standard"
	"github.com/theopenlane/core/internal/ent/generated/standardhistory"
	"github.com/theopenlane/core/internal/ent/generated/subcontrol"
	"github.com/theopenlane/core/internal/ent/generated/subcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/subscriber"
	"github.com/theopenlane/core/internal/ent/generated/task"
	"github.com/theopenlane/core/internal/ent/generated/taskhistory"
	"github.com/theopenlane/core/internal/ent/generated/template"
	"github.com/theopenlane/core/internal/ent/generated/templatehistory"
	"github.com/theopenlane/core/internal/ent/generated/tfasetting"
	"github.com/theopenlane/core/internal/ent/generated/user"
	"github.com/theopenlane/core/internal/ent/generated/userhistory"
	"github.com/theopenlane/core/internal/ent/generated/usersetting"
	"github.com/theopenlane/core/internal/ent/generated/usersettinghistory"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (at *APITokenQuery) CollectFields(ctx context.Context, satisfies ...string) (*APITokenQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return at, nil
	}
	if err := at.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return at, nil
}

func (at *APITokenQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(apitoken.Columns))
		selectedFields = []string{apitoken.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: at.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			at.withCreatedBy = query
			if _, ok := fieldSeen[apitoken.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldCreatedByID)
				fieldSeen[apitoken.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: at.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			at.withUpdatedBy = query
			if _, ok := fieldSeen[apitoken.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldUpdatedByID)
				fieldSeen[apitoken.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: at.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			at.withOwner = query
			if _, ok := fieldSeen[apitoken.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldOwnerID)
				fieldSeen[apitoken.FieldOwnerID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[apitoken.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldCreatedAt)
				fieldSeen[apitoken.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[apitoken.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldUpdatedAt)
				fieldSeen[apitoken.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[apitoken.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldCreatedByID)
				fieldSeen[apitoken.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[apitoken.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldUpdatedByID)
				fieldSeen[apitoken.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[apitoken.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldDeletedAt)
				fieldSeen[apitoken.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[apitoken.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldDeletedByID)
				fieldSeen[apitoken.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[apitoken.FieldTags]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldTags)
				fieldSeen[apitoken.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[apitoken.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldOwnerID)
				fieldSeen[apitoken.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[apitoken.FieldName]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldName)
				fieldSeen[apitoken.FieldName] = struct{}{}
			}
		case "token":
			if _, ok := fieldSeen[apitoken.FieldToken]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldToken)
				fieldSeen[apitoken.FieldToken] = struct{}{}
			}
		case "expiresAt":
			if _, ok := fieldSeen[apitoken.FieldExpiresAt]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldExpiresAt)
				fieldSeen[apitoken.FieldExpiresAt] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[apitoken.FieldDescription]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldDescription)
				fieldSeen[apitoken.FieldDescription] = struct{}{}
			}
		case "scopes":
			if _, ok := fieldSeen[apitoken.FieldScopes]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldScopes)
				fieldSeen[apitoken.FieldScopes] = struct{}{}
			}
		case "lastUsedAt":
			if _, ok := fieldSeen[apitoken.FieldLastUsedAt]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldLastUsedAt)
				fieldSeen[apitoken.FieldLastUsedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		at.Select(selectedFields...)
	}
	return nil
}

type apitokenPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []APITokenPaginateOption
}

func newAPITokenPaginateArgs(rv map[string]any) *apitokenPaginateArgs {
	args := &apitokenPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*APITokenWhereInput); ok {
		args.opts = append(args.opts, WithAPITokenFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ap *ActionPlanQuery) CollectFields(ctx context.Context, satisfies ...string) (*ActionPlanQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ap, nil
	}
	if err := ap.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ap, nil
}

func (ap *ActionPlanQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(actionplan.Columns))
		selectedFields = []string{actionplan.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			ap.withCreatedBy = query
			if _, ok := fieldSeen[actionplan.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldCreatedByID)
				fieldSeen[actionplan.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			ap.withUpdatedBy = query
			if _, ok := fieldSeen[actionplan.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldUpdatedByID)
				fieldSeen[actionplan.FieldUpdatedByID] = struct{}{}
			}

		case "standard":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StandardClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, standardImplementors)...); err != nil {
				return err
			}
			ap.WithNamedStandard(alias, func(wq *StandardQuery) {
				*wq = *query
			})

		case "risk":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RiskClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, riskImplementors)...); err != nil {
				return err
			}
			ap.WithNamedRisk(alias, func(wq *RiskQuery) {
				*wq = *query
			})

		case "control":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlImplementors)...); err != nil {
				return err
			}
			ap.WithNamedControl(alias, func(wq *ControlQuery) {
				*wq = *query
			})

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			ap.WithNamedUser(alias, func(wq *UserQuery) {
				*wq = *query
			})

		case "program":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			ap.WithNamedProgram(alias, func(wq *ProgramQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[actionplan.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldCreatedAt)
				fieldSeen[actionplan.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[actionplan.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldUpdatedAt)
				fieldSeen[actionplan.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[actionplan.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldCreatedByID)
				fieldSeen[actionplan.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[actionplan.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldUpdatedByID)
				fieldSeen[actionplan.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[actionplan.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldDeletedAt)
				fieldSeen[actionplan.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[actionplan.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldDeletedByID)
				fieldSeen[actionplan.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[actionplan.FieldTags]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldTags)
				fieldSeen[actionplan.FieldTags] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[actionplan.FieldName]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldName)
				fieldSeen[actionplan.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[actionplan.FieldDescription]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldDescription)
				fieldSeen[actionplan.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[actionplan.FieldStatus]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldStatus)
				fieldSeen[actionplan.FieldStatus] = struct{}{}
			}
		case "dueDate":
			if _, ok := fieldSeen[actionplan.FieldDueDate]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldDueDate)
				fieldSeen[actionplan.FieldDueDate] = struct{}{}
			}
		case "priority":
			if _, ok := fieldSeen[actionplan.FieldPriority]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldPriority)
				fieldSeen[actionplan.FieldPriority] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[actionplan.FieldSource]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldSource)
				fieldSeen[actionplan.FieldSource] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[actionplan.FieldDetails]; !ok {
				selectedFields = append(selectedFields, actionplan.FieldDetails)
				fieldSeen[actionplan.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ap.Select(selectedFields...)
	}
	return nil
}

type actionplanPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ActionPlanPaginateOption
}

func newActionPlanPaginateArgs(rv map[string]any) *actionplanPaginateArgs {
	args := &actionplanPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ActionPlanWhereInput); ok {
		args.opts = append(args.opts, WithActionPlanFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (aph *ActionPlanHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*ActionPlanHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return aph, nil
	}
	if err := aph.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return aph, nil
}

func (aph *ActionPlanHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(actionplanhistory.Columns))
		selectedFields = []string{actionplanhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[actionplanhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldHistoryTime)
				fieldSeen[actionplanhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[actionplanhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldRef)
				fieldSeen[actionplanhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[actionplanhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldOperation)
				fieldSeen[actionplanhistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[actionplanhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldUpdatedBy)
				fieldSeen[actionplanhistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[actionplanhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldCreatedAt)
				fieldSeen[actionplanhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[actionplanhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldUpdatedAt)
				fieldSeen[actionplanhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[actionplanhistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldCreatedByID)
				fieldSeen[actionplanhistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[actionplanhistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldUpdatedByID)
				fieldSeen[actionplanhistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[actionplanhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldDeletedAt)
				fieldSeen[actionplanhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[actionplanhistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldDeletedByID)
				fieldSeen[actionplanhistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[actionplanhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldTags)
				fieldSeen[actionplanhistory.FieldTags] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[actionplanhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldName)
				fieldSeen[actionplanhistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[actionplanhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldDescription)
				fieldSeen[actionplanhistory.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[actionplanhistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldStatus)
				fieldSeen[actionplanhistory.FieldStatus] = struct{}{}
			}
		case "dueDate":
			if _, ok := fieldSeen[actionplanhistory.FieldDueDate]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldDueDate)
				fieldSeen[actionplanhistory.FieldDueDate] = struct{}{}
			}
		case "priority":
			if _, ok := fieldSeen[actionplanhistory.FieldPriority]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldPriority)
				fieldSeen[actionplanhistory.FieldPriority] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[actionplanhistory.FieldSource]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldSource)
				fieldSeen[actionplanhistory.FieldSource] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[actionplanhistory.FieldDetails]; !ok {
				selectedFields = append(selectedFields, actionplanhistory.FieldDetails)
				fieldSeen[actionplanhistory.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		aph.Select(selectedFields...)
	}
	return nil
}

type actionplanhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ActionPlanHistoryPaginateOption
}

func newActionPlanHistoryPaginateArgs(rv map[string]any) *actionplanhistoryPaginateArgs {
	args := &actionplanhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ActionPlanHistoryWhereInput); ok {
		args.opts = append(args.opts, WithActionPlanHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *ContactQuery) CollectFields(ctx context.Context, satisfies ...string) (*ContactQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *ContactQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(contact.Columns))
		selectedFields = []string{contact.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			c.withCreatedBy = query
			if _, ok := fieldSeen[contact.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, contact.FieldCreatedByID)
				fieldSeen[contact.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			c.withUpdatedBy = query
			if _, ok := fieldSeen[contact.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, contact.FieldUpdatedByID)
				fieldSeen[contact.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			c.withOwner = query
			if _, ok := fieldSeen[contact.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, contact.FieldOwnerID)
				fieldSeen[contact.FieldOwnerID] = struct{}{}
			}

		case "entities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entityImplementors)...); err != nil {
				return err
			}
			c.WithNamedEntities(alias, func(wq *EntityQuery) {
				*wq = *query
			})

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			c.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[contact.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, contact.FieldCreatedAt)
				fieldSeen[contact.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[contact.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, contact.FieldUpdatedAt)
				fieldSeen[contact.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[contact.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, contact.FieldCreatedByID)
				fieldSeen[contact.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[contact.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, contact.FieldUpdatedByID)
				fieldSeen[contact.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[contact.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, contact.FieldDeletedAt)
				fieldSeen[contact.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[contact.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, contact.FieldDeletedByID)
				fieldSeen[contact.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[contact.FieldTags]; !ok {
				selectedFields = append(selectedFields, contact.FieldTags)
				fieldSeen[contact.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[contact.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, contact.FieldOwnerID)
				fieldSeen[contact.FieldOwnerID] = struct{}{}
			}
		case "fullName":
			if _, ok := fieldSeen[contact.FieldFullName]; !ok {
				selectedFields = append(selectedFields, contact.FieldFullName)
				fieldSeen[contact.FieldFullName] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[contact.FieldTitle]; !ok {
				selectedFields = append(selectedFields, contact.FieldTitle)
				fieldSeen[contact.FieldTitle] = struct{}{}
			}
		case "company":
			if _, ok := fieldSeen[contact.FieldCompany]; !ok {
				selectedFields = append(selectedFields, contact.FieldCompany)
				fieldSeen[contact.FieldCompany] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[contact.FieldEmail]; !ok {
				selectedFields = append(selectedFields, contact.FieldEmail)
				fieldSeen[contact.FieldEmail] = struct{}{}
			}
		case "phoneNumber":
			if _, ok := fieldSeen[contact.FieldPhoneNumber]; !ok {
				selectedFields = append(selectedFields, contact.FieldPhoneNumber)
				fieldSeen[contact.FieldPhoneNumber] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[contact.FieldAddress]; !ok {
				selectedFields = append(selectedFields, contact.FieldAddress)
				fieldSeen[contact.FieldAddress] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[contact.FieldStatus]; !ok {
				selectedFields = append(selectedFields, contact.FieldStatus)
				fieldSeen[contact.FieldStatus] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type contactPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ContactPaginateOption
}

func newContactPaginateArgs(rv map[string]any) *contactPaginateArgs {
	args := &contactPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ContactWhereInput); ok {
		args.opts = append(args.opts, WithContactFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ch *ContactHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*ContactHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ch, nil
	}
	if err := ch.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ch, nil
}

func (ch *ContactHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(contacthistory.Columns))
		selectedFields = []string{contacthistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[contacthistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldHistoryTime)
				fieldSeen[contacthistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[contacthistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldRef)
				fieldSeen[contacthistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[contacthistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldOperation)
				fieldSeen[contacthistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[contacthistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldUpdatedBy)
				fieldSeen[contacthistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[contacthistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldCreatedAt)
				fieldSeen[contacthistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[contacthistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldUpdatedAt)
				fieldSeen[contacthistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[contacthistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldCreatedByID)
				fieldSeen[contacthistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[contacthistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldUpdatedByID)
				fieldSeen[contacthistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[contacthistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldDeletedAt)
				fieldSeen[contacthistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[contacthistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldDeletedByID)
				fieldSeen[contacthistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[contacthistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldTags)
				fieldSeen[contacthistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[contacthistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldOwnerID)
				fieldSeen[contacthistory.FieldOwnerID] = struct{}{}
			}
		case "fullName":
			if _, ok := fieldSeen[contacthistory.FieldFullName]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldFullName)
				fieldSeen[contacthistory.FieldFullName] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[contacthistory.FieldTitle]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldTitle)
				fieldSeen[contacthistory.FieldTitle] = struct{}{}
			}
		case "company":
			if _, ok := fieldSeen[contacthistory.FieldCompany]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldCompany)
				fieldSeen[contacthistory.FieldCompany] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[contacthistory.FieldEmail]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldEmail)
				fieldSeen[contacthistory.FieldEmail] = struct{}{}
			}
		case "phoneNumber":
			if _, ok := fieldSeen[contacthistory.FieldPhoneNumber]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldPhoneNumber)
				fieldSeen[contacthistory.FieldPhoneNumber] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[contacthistory.FieldAddress]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldAddress)
				fieldSeen[contacthistory.FieldAddress] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[contacthistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldStatus)
				fieldSeen[contacthistory.FieldStatus] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ch.Select(selectedFields...)
	}
	return nil
}

type contacthistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ContactHistoryPaginateOption
}

func newContactHistoryPaginateArgs(rv map[string]any) *contacthistoryPaginateArgs {
	args := &contacthistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ContactHistoryWhereInput); ok {
		args.opts = append(args.opts, WithContactHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *ControlQuery) CollectFields(ctx context.Context, satisfies ...string) (*ControlQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *ControlQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(control.Columns))
		selectedFields = []string{control.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			c.withCreatedBy = query
			if _, ok := fieldSeen[control.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, control.FieldCreatedByID)
				fieldSeen[control.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			c.withUpdatedBy = query
			if _, ok := fieldSeen[control.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, control.FieldUpdatedByID)
				fieldSeen[control.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			c.withOwner = query
			if _, ok := fieldSeen[control.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, control.FieldOwnerID)
				fieldSeen[control.FieldOwnerID] = struct{}{}
			}

		case "blockedGroups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			c.WithNamedBlockedGroups(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "editors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			c.WithNamedEditors(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "viewers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			c.WithNamedViewers(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "procedures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProcedureClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, procedureImplementors)...); err != nil {
				return err
			}
			c.WithNamedProcedures(alias, func(wq *ProcedureQuery) {
				*wq = *query
			})

		case "subcontrols":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SubcontrolClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, subcontrolImplementors)...); err != nil {
				return err
			}
			c.WithNamedSubcontrols(alias, func(wq *SubcontrolQuery) {
				*wq = *query
			})

		case "controlObjectives":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlObjectiveClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlobjectiveImplementors)...); err != nil {
				return err
			}
			c.WithNamedControlObjectives(alias, func(wq *ControlObjectiveQuery) {
				*wq = *query
			})

		case "standard":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StandardClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, standardImplementors)...); err != nil {
				return err
			}
			c.WithNamedStandard(alias, func(wq *StandardQuery) {
				*wq = *query
			})

		case "narratives":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NarrativeClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, narrativeImplementors)...); err != nil {
				return err
			}
			c.WithNamedNarratives(alias, func(wq *NarrativeQuery) {
				*wq = *query
			})

		case "risks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RiskClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, riskImplementors)...); err != nil {
				return err
			}
			c.WithNamedRisks(alias, func(wq *RiskQuery) {
				*wq = *query
			})

		case "actionPlans":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ActionPlanClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, actionplanImplementors)...); err != nil {
				return err
			}
			c.WithNamedActionPlans(alias, func(wq *ActionPlanQuery) {
				*wq = *query
			})

		case "tasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			c.WithNamedTasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "programs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			c.WithNamedPrograms(alias, func(wq *ProgramQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[control.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, control.FieldCreatedAt)
				fieldSeen[control.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[control.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, control.FieldUpdatedAt)
				fieldSeen[control.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[control.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, control.FieldCreatedByID)
				fieldSeen[control.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[control.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, control.FieldUpdatedByID)
				fieldSeen[control.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[control.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, control.FieldDeletedAt)
				fieldSeen[control.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[control.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, control.FieldDeletedByID)
				fieldSeen[control.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[control.FieldTags]; !ok {
				selectedFields = append(selectedFields, control.FieldTags)
				fieldSeen[control.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[control.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, control.FieldOwnerID)
				fieldSeen[control.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[control.FieldName]; !ok {
				selectedFields = append(selectedFields, control.FieldName)
				fieldSeen[control.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[control.FieldDescription]; !ok {
				selectedFields = append(selectedFields, control.FieldDescription)
				fieldSeen[control.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[control.FieldStatus]; !ok {
				selectedFields = append(selectedFields, control.FieldStatus)
				fieldSeen[control.FieldStatus] = struct{}{}
			}
		case "controlType":
			if _, ok := fieldSeen[control.FieldControlType]; !ok {
				selectedFields = append(selectedFields, control.FieldControlType)
				fieldSeen[control.FieldControlType] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[control.FieldVersion]; !ok {
				selectedFields = append(selectedFields, control.FieldVersion)
				fieldSeen[control.FieldVersion] = struct{}{}
			}
		case "controlNumber":
			if _, ok := fieldSeen[control.FieldControlNumber]; !ok {
				selectedFields = append(selectedFields, control.FieldControlNumber)
				fieldSeen[control.FieldControlNumber] = struct{}{}
			}
		case "family":
			if _, ok := fieldSeen[control.FieldFamily]; !ok {
				selectedFields = append(selectedFields, control.FieldFamily)
				fieldSeen[control.FieldFamily] = struct{}{}
			}
		case "class":
			if _, ok := fieldSeen[control.FieldClass]; !ok {
				selectedFields = append(selectedFields, control.FieldClass)
				fieldSeen[control.FieldClass] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[control.FieldSource]; !ok {
				selectedFields = append(selectedFields, control.FieldSource)
				fieldSeen[control.FieldSource] = struct{}{}
			}
		case "satisfies":
			if _, ok := fieldSeen[control.FieldSatisfies]; !ok {
				selectedFields = append(selectedFields, control.FieldSatisfies)
				fieldSeen[control.FieldSatisfies] = struct{}{}
			}
		case "mappedFrameworks":
			if _, ok := fieldSeen[control.FieldMappedFrameworks]; !ok {
				selectedFields = append(selectedFields, control.FieldMappedFrameworks)
				fieldSeen[control.FieldMappedFrameworks] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[control.FieldDetails]; !ok {
				selectedFields = append(selectedFields, control.FieldDetails)
				fieldSeen[control.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type controlPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ControlPaginateOption
}

func newControlPaginateArgs(rv map[string]any) *controlPaginateArgs {
	args := &controlPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ControlWhereInput); ok {
		args.opts = append(args.opts, WithControlFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ch *ControlHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*ControlHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ch, nil
	}
	if err := ch.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ch, nil
}

func (ch *ControlHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(controlhistory.Columns))
		selectedFields = []string{controlhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[controlhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldHistoryTime)
				fieldSeen[controlhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[controlhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldRef)
				fieldSeen[controlhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[controlhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldOperation)
				fieldSeen[controlhistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[controlhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldUpdatedBy)
				fieldSeen[controlhistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[controlhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldCreatedAt)
				fieldSeen[controlhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[controlhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldUpdatedAt)
				fieldSeen[controlhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[controlhistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldCreatedByID)
				fieldSeen[controlhistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[controlhistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldUpdatedByID)
				fieldSeen[controlhistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[controlhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldDeletedAt)
				fieldSeen[controlhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[controlhistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldDeletedByID)
				fieldSeen[controlhistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[controlhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldTags)
				fieldSeen[controlhistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[controlhistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldOwnerID)
				fieldSeen[controlhistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[controlhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldName)
				fieldSeen[controlhistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[controlhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldDescription)
				fieldSeen[controlhistory.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[controlhistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldStatus)
				fieldSeen[controlhistory.FieldStatus] = struct{}{}
			}
		case "controlType":
			if _, ok := fieldSeen[controlhistory.FieldControlType]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldControlType)
				fieldSeen[controlhistory.FieldControlType] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[controlhistory.FieldVersion]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldVersion)
				fieldSeen[controlhistory.FieldVersion] = struct{}{}
			}
		case "controlNumber":
			if _, ok := fieldSeen[controlhistory.FieldControlNumber]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldControlNumber)
				fieldSeen[controlhistory.FieldControlNumber] = struct{}{}
			}
		case "family":
			if _, ok := fieldSeen[controlhistory.FieldFamily]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldFamily)
				fieldSeen[controlhistory.FieldFamily] = struct{}{}
			}
		case "class":
			if _, ok := fieldSeen[controlhistory.FieldClass]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldClass)
				fieldSeen[controlhistory.FieldClass] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[controlhistory.FieldSource]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldSource)
				fieldSeen[controlhistory.FieldSource] = struct{}{}
			}
		case "satisfies":
			if _, ok := fieldSeen[controlhistory.FieldSatisfies]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldSatisfies)
				fieldSeen[controlhistory.FieldSatisfies] = struct{}{}
			}
		case "mappedFrameworks":
			if _, ok := fieldSeen[controlhistory.FieldMappedFrameworks]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldMappedFrameworks)
				fieldSeen[controlhistory.FieldMappedFrameworks] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[controlhistory.FieldDetails]; !ok {
				selectedFields = append(selectedFields, controlhistory.FieldDetails)
				fieldSeen[controlhistory.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ch.Select(selectedFields...)
	}
	return nil
}

type controlhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ControlHistoryPaginateOption
}

func newControlHistoryPaginateArgs(rv map[string]any) *controlhistoryPaginateArgs {
	args := &controlhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ControlHistoryWhereInput); ok {
		args.opts = append(args.opts, WithControlHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (co *ControlObjectiveQuery) CollectFields(ctx context.Context, satisfies ...string) (*ControlObjectiveQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return co, nil
	}
	if err := co.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return co, nil
}

func (co *ControlObjectiveQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(controlobjective.Columns))
		selectedFields = []string{controlobjective.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: co.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			co.withCreatedBy = query
			if _, ok := fieldSeen[controlobjective.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldCreatedByID)
				fieldSeen[controlobjective.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: co.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			co.withUpdatedBy = query
			if _, ok := fieldSeen[controlobjective.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldUpdatedByID)
				fieldSeen[controlobjective.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: co.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			co.withOwner = query
			if _, ok := fieldSeen[controlobjective.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldOwnerID)
				fieldSeen[controlobjective.FieldOwnerID] = struct{}{}
			}

		case "blockedGroups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: co.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			co.WithNamedBlockedGroups(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "editors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: co.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			co.WithNamedEditors(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "viewers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: co.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			co.WithNamedViewers(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "internalPolicies":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InternalPolicyClient{config: co.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, internalpolicyImplementors)...); err != nil {
				return err
			}
			co.WithNamedInternalPolicies(alias, func(wq *InternalPolicyQuery) {
				*wq = *query
			})

		case "controls":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlClient{config: co.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlImplementors)...); err != nil {
				return err
			}
			co.WithNamedControls(alias, func(wq *ControlQuery) {
				*wq = *query
			})

		case "procedures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProcedureClient{config: co.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, procedureImplementors)...); err != nil {
				return err
			}
			co.WithNamedProcedures(alias, func(wq *ProcedureQuery) {
				*wq = *query
			})

		case "risks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RiskClient{config: co.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, riskImplementors)...); err != nil {
				return err
			}
			co.WithNamedRisks(alias, func(wq *RiskQuery) {
				*wq = *query
			})

		case "subcontrols":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SubcontrolClient{config: co.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, subcontrolImplementors)...); err != nil {
				return err
			}
			co.WithNamedSubcontrols(alias, func(wq *SubcontrolQuery) {
				*wq = *query
			})

		case "standard":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StandardClient{config: co.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, standardImplementors)...); err != nil {
				return err
			}
			co.WithNamedStandard(alias, func(wq *StandardQuery) {
				*wq = *query
			})

		case "narratives":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NarrativeClient{config: co.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, narrativeImplementors)...); err != nil {
				return err
			}
			co.WithNamedNarratives(alias, func(wq *NarrativeQuery) {
				*wq = *query
			})

		case "tasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: co.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			co.WithNamedTasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "programs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: co.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			co.WithNamedPrograms(alias, func(wq *ProgramQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[controlobjective.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldCreatedAt)
				fieldSeen[controlobjective.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[controlobjective.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldUpdatedAt)
				fieldSeen[controlobjective.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[controlobjective.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldCreatedByID)
				fieldSeen[controlobjective.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[controlobjective.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldUpdatedByID)
				fieldSeen[controlobjective.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[controlobjective.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldDeletedAt)
				fieldSeen[controlobjective.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[controlobjective.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldDeletedByID)
				fieldSeen[controlobjective.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[controlobjective.FieldTags]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldTags)
				fieldSeen[controlobjective.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[controlobjective.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldOwnerID)
				fieldSeen[controlobjective.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[controlobjective.FieldName]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldName)
				fieldSeen[controlobjective.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[controlobjective.FieldDescription]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldDescription)
				fieldSeen[controlobjective.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[controlobjective.FieldStatus]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldStatus)
				fieldSeen[controlobjective.FieldStatus] = struct{}{}
			}
		case "controlObjectiveType":
			if _, ok := fieldSeen[controlobjective.FieldControlObjectiveType]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldControlObjectiveType)
				fieldSeen[controlobjective.FieldControlObjectiveType] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[controlobjective.FieldVersion]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldVersion)
				fieldSeen[controlobjective.FieldVersion] = struct{}{}
			}
		case "controlNumber":
			if _, ok := fieldSeen[controlobjective.FieldControlNumber]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldControlNumber)
				fieldSeen[controlobjective.FieldControlNumber] = struct{}{}
			}
		case "family":
			if _, ok := fieldSeen[controlobjective.FieldFamily]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldFamily)
				fieldSeen[controlobjective.FieldFamily] = struct{}{}
			}
		case "class":
			if _, ok := fieldSeen[controlobjective.FieldClass]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldClass)
				fieldSeen[controlobjective.FieldClass] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[controlobjective.FieldSource]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldSource)
				fieldSeen[controlobjective.FieldSource] = struct{}{}
			}
		case "mappedFrameworks":
			if _, ok := fieldSeen[controlobjective.FieldMappedFrameworks]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldMappedFrameworks)
				fieldSeen[controlobjective.FieldMappedFrameworks] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[controlobjective.FieldDetails]; !ok {
				selectedFields = append(selectedFields, controlobjective.FieldDetails)
				fieldSeen[controlobjective.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		co.Select(selectedFields...)
	}
	return nil
}

type controlobjectivePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ControlObjectivePaginateOption
}

func newControlObjectivePaginateArgs(rv map[string]any) *controlobjectivePaginateArgs {
	args := &controlobjectivePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ControlObjectiveWhereInput); ok {
		args.opts = append(args.opts, WithControlObjectiveFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (coh *ControlObjectiveHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*ControlObjectiveHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return coh, nil
	}
	if err := coh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return coh, nil
}

func (coh *ControlObjectiveHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(controlobjectivehistory.Columns))
		selectedFields = []string{controlobjectivehistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[controlobjectivehistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldHistoryTime)
				fieldSeen[controlobjectivehistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[controlobjectivehistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldRef)
				fieldSeen[controlobjectivehistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[controlobjectivehistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldOperation)
				fieldSeen[controlobjectivehistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[controlobjectivehistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldUpdatedBy)
				fieldSeen[controlobjectivehistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[controlobjectivehistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldCreatedAt)
				fieldSeen[controlobjectivehistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[controlobjectivehistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldUpdatedAt)
				fieldSeen[controlobjectivehistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[controlobjectivehistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldCreatedByID)
				fieldSeen[controlobjectivehistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[controlobjectivehistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldUpdatedByID)
				fieldSeen[controlobjectivehistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[controlobjectivehistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldDeletedAt)
				fieldSeen[controlobjectivehistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[controlobjectivehistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldDeletedByID)
				fieldSeen[controlobjectivehistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[controlobjectivehistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldTags)
				fieldSeen[controlobjectivehistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[controlobjectivehistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldOwnerID)
				fieldSeen[controlobjectivehistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[controlobjectivehistory.FieldName]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldName)
				fieldSeen[controlobjectivehistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[controlobjectivehistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldDescription)
				fieldSeen[controlobjectivehistory.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[controlobjectivehistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldStatus)
				fieldSeen[controlobjectivehistory.FieldStatus] = struct{}{}
			}
		case "controlObjectiveType":
			if _, ok := fieldSeen[controlobjectivehistory.FieldControlObjectiveType]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldControlObjectiveType)
				fieldSeen[controlobjectivehistory.FieldControlObjectiveType] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[controlobjectivehistory.FieldVersion]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldVersion)
				fieldSeen[controlobjectivehistory.FieldVersion] = struct{}{}
			}
		case "controlNumber":
			if _, ok := fieldSeen[controlobjectivehistory.FieldControlNumber]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldControlNumber)
				fieldSeen[controlobjectivehistory.FieldControlNumber] = struct{}{}
			}
		case "family":
			if _, ok := fieldSeen[controlobjectivehistory.FieldFamily]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldFamily)
				fieldSeen[controlobjectivehistory.FieldFamily] = struct{}{}
			}
		case "class":
			if _, ok := fieldSeen[controlobjectivehistory.FieldClass]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldClass)
				fieldSeen[controlobjectivehistory.FieldClass] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[controlobjectivehistory.FieldSource]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldSource)
				fieldSeen[controlobjectivehistory.FieldSource] = struct{}{}
			}
		case "mappedFrameworks":
			if _, ok := fieldSeen[controlobjectivehistory.FieldMappedFrameworks]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldMappedFrameworks)
				fieldSeen[controlobjectivehistory.FieldMappedFrameworks] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[controlobjectivehistory.FieldDetails]; !ok {
				selectedFields = append(selectedFields, controlobjectivehistory.FieldDetails)
				fieldSeen[controlobjectivehistory.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		coh.Select(selectedFields...)
	}
	return nil
}

type controlobjectivehistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ControlObjectiveHistoryPaginateOption
}

func newControlObjectiveHistoryPaginateArgs(rv map[string]any) *controlobjectivehistoryPaginateArgs {
	args := &controlobjectivehistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ControlObjectiveHistoryWhereInput); ok {
		args.opts = append(args.opts, WithControlObjectiveHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (dd *DocumentDataQuery) CollectFields(ctx context.Context, satisfies ...string) (*DocumentDataQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return dd, nil
	}
	if err := dd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return dd, nil
}

func (dd *DocumentDataQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(documentdata.Columns))
		selectedFields = []string{documentdata.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: dd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			dd.withCreatedBy = query
			if _, ok := fieldSeen[documentdata.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldCreatedByID)
				fieldSeen[documentdata.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: dd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			dd.withUpdatedBy = query
			if _, ok := fieldSeen[documentdata.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldUpdatedByID)
				fieldSeen[documentdata.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: dd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			dd.withOwner = query
			if _, ok := fieldSeen[documentdata.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldOwnerID)
				fieldSeen[documentdata.FieldOwnerID] = struct{}{}
			}

		case "template":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TemplateClient{config: dd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, templateImplementors)...); err != nil {
				return err
			}
			dd.withTemplate = query
			if _, ok := fieldSeen[documentdata.FieldTemplateID]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldTemplateID)
				fieldSeen[documentdata.FieldTemplateID] = struct{}{}
			}

		case "entity":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityClient{config: dd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entityImplementors)...); err != nil {
				return err
			}
			dd.WithNamedEntity(alias, func(wq *EntityQuery) {
				*wq = *query
			})

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: dd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			dd.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[documentdata.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldCreatedAt)
				fieldSeen[documentdata.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[documentdata.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldUpdatedAt)
				fieldSeen[documentdata.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[documentdata.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldCreatedByID)
				fieldSeen[documentdata.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[documentdata.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldUpdatedByID)
				fieldSeen[documentdata.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[documentdata.FieldTags]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldTags)
				fieldSeen[documentdata.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[documentdata.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldDeletedAt)
				fieldSeen[documentdata.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[documentdata.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldDeletedByID)
				fieldSeen[documentdata.FieldDeletedByID] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[documentdata.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldOwnerID)
				fieldSeen[documentdata.FieldOwnerID] = struct{}{}
			}
		case "templateID":
			if _, ok := fieldSeen[documentdata.FieldTemplateID]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldTemplateID)
				fieldSeen[documentdata.FieldTemplateID] = struct{}{}
			}
		case "data":
			if _, ok := fieldSeen[documentdata.FieldData]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldData)
				fieldSeen[documentdata.FieldData] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		dd.Select(selectedFields...)
	}
	return nil
}

type documentdataPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DocumentDataPaginateOption
}

func newDocumentDataPaginateArgs(rv map[string]any) *documentdataPaginateArgs {
	args := &documentdataPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DocumentDataWhereInput); ok {
		args.opts = append(args.opts, WithDocumentDataFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ddh *DocumentDataHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*DocumentDataHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ddh, nil
	}
	if err := ddh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ddh, nil
}

func (ddh *DocumentDataHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(documentdatahistory.Columns))
		selectedFields = []string{documentdatahistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[documentdatahistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldHistoryTime)
				fieldSeen[documentdatahistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[documentdatahistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldRef)
				fieldSeen[documentdatahistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[documentdatahistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldOperation)
				fieldSeen[documentdatahistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[documentdatahistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldUpdatedBy)
				fieldSeen[documentdatahistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[documentdatahistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldCreatedAt)
				fieldSeen[documentdatahistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[documentdatahistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldUpdatedAt)
				fieldSeen[documentdatahistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[documentdatahistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldCreatedByID)
				fieldSeen[documentdatahistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[documentdatahistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldUpdatedByID)
				fieldSeen[documentdatahistory.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[documentdatahistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldTags)
				fieldSeen[documentdatahistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[documentdatahistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldDeletedAt)
				fieldSeen[documentdatahistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[documentdatahistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldDeletedByID)
				fieldSeen[documentdatahistory.FieldDeletedByID] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[documentdatahistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldOwnerID)
				fieldSeen[documentdatahistory.FieldOwnerID] = struct{}{}
			}
		case "templateID":
			if _, ok := fieldSeen[documentdatahistory.FieldTemplateID]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldTemplateID)
				fieldSeen[documentdatahistory.FieldTemplateID] = struct{}{}
			}
		case "data":
			if _, ok := fieldSeen[documentdatahistory.FieldData]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldData)
				fieldSeen[documentdatahistory.FieldData] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ddh.Select(selectedFields...)
	}
	return nil
}

type documentdatahistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DocumentDataHistoryPaginateOption
}

func newDocumentDataHistoryPaginateArgs(rv map[string]any) *documentdatahistoryPaginateArgs {
	args := &documentdatahistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DocumentDataHistoryWhereInput); ok {
		args.opts = append(args.opts, WithDocumentDataHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (e *EntityQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntityQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return e, nil
	}
	if err := e.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return e, nil
}

func (e *EntityQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(entity.Columns))
		selectedFields = []string{entity.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			e.withCreatedBy = query
			if _, ok := fieldSeen[entity.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, entity.FieldCreatedByID)
				fieldSeen[entity.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			e.withUpdatedBy = query
			if _, ok := fieldSeen[entity.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, entity.FieldUpdatedByID)
				fieldSeen[entity.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			e.withOwner = query
			if _, ok := fieldSeen[entity.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entity.FieldOwnerID)
				fieldSeen[entity.FieldOwnerID] = struct{}{}
			}

		case "contacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ContactClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, contactImplementors)...); err != nil {
				return err
			}
			e.WithNamedContacts(alias, func(wq *ContactQuery) {
				*wq = *query
			})

		case "documents":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentDataClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentdataImplementors)...); err != nil {
				return err
			}
			e.WithNamedDocuments(alias, func(wq *DocumentDataQuery) {
				*wq = *query
			})

		case "notes":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NoteClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, noteImplementors)...); err != nil {
				return err
			}
			e.WithNamedNotes(alias, func(wq *NoteQuery) {
				*wq = *query
			})

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			e.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})

		case "entityType":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityTypeClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, entitytypeImplementors)...); err != nil {
				return err
			}
			e.withEntityType = query
			if _, ok := fieldSeen[entity.FieldEntityTypeID]; !ok {
				selectedFields = append(selectedFields, entity.FieldEntityTypeID)
				fieldSeen[entity.FieldEntityTypeID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[entity.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, entity.FieldCreatedAt)
				fieldSeen[entity.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[entity.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, entity.FieldUpdatedAt)
				fieldSeen[entity.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[entity.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, entity.FieldCreatedByID)
				fieldSeen[entity.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[entity.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, entity.FieldUpdatedByID)
				fieldSeen[entity.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[entity.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, entity.FieldDeletedAt)
				fieldSeen[entity.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[entity.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, entity.FieldDeletedByID)
				fieldSeen[entity.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[entity.FieldTags]; !ok {
				selectedFields = append(selectedFields, entity.FieldTags)
				fieldSeen[entity.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[entity.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entity.FieldOwnerID)
				fieldSeen[entity.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[entity.FieldName]; !ok {
				selectedFields = append(selectedFields, entity.FieldName)
				fieldSeen[entity.FieldName] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[entity.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, entity.FieldDisplayName)
				fieldSeen[entity.FieldDisplayName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[entity.FieldDescription]; !ok {
				selectedFields = append(selectedFields, entity.FieldDescription)
				fieldSeen[entity.FieldDescription] = struct{}{}
			}
		case "domains":
			if _, ok := fieldSeen[entity.FieldDomains]; !ok {
				selectedFields = append(selectedFields, entity.FieldDomains)
				fieldSeen[entity.FieldDomains] = struct{}{}
			}
		case "entityTypeID":
			if _, ok := fieldSeen[entity.FieldEntityTypeID]; !ok {
				selectedFields = append(selectedFields, entity.FieldEntityTypeID)
				fieldSeen[entity.FieldEntityTypeID] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[entity.FieldStatus]; !ok {
				selectedFields = append(selectedFields, entity.FieldStatus)
				fieldSeen[entity.FieldStatus] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		e.Select(selectedFields...)
	}
	return nil
}

type entityPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntityPaginateOption
}

func newEntityPaginateArgs(rv map[string]any) *entityPaginateArgs {
	args := &entityPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &EntityOrder{Field: &EntityOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithEntityOrder(order))
			}
		case *EntityOrder:
			if v != nil {
				args.opts = append(args.opts, WithEntityOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*EntityWhereInput); ok {
		args.opts = append(args.opts, WithEntityFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (eh *EntityHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntityHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return eh, nil
	}
	if err := eh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return eh, nil
}

func (eh *EntityHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(entityhistory.Columns))
		selectedFields = []string{entityhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[entityhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldHistoryTime)
				fieldSeen[entityhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[entityhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldRef)
				fieldSeen[entityhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[entityhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldOperation)
				fieldSeen[entityhistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[entityhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldUpdatedBy)
				fieldSeen[entityhistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[entityhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldCreatedAt)
				fieldSeen[entityhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[entityhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldUpdatedAt)
				fieldSeen[entityhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[entityhistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldCreatedByID)
				fieldSeen[entityhistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[entityhistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldUpdatedByID)
				fieldSeen[entityhistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[entityhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldDeletedAt)
				fieldSeen[entityhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[entityhistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldDeletedByID)
				fieldSeen[entityhistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[entityhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldTags)
				fieldSeen[entityhistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[entityhistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldOwnerID)
				fieldSeen[entityhistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[entityhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldName)
				fieldSeen[entityhistory.FieldName] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[entityhistory.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldDisplayName)
				fieldSeen[entityhistory.FieldDisplayName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[entityhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldDescription)
				fieldSeen[entityhistory.FieldDescription] = struct{}{}
			}
		case "domains":
			if _, ok := fieldSeen[entityhistory.FieldDomains]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldDomains)
				fieldSeen[entityhistory.FieldDomains] = struct{}{}
			}
		case "entityTypeID":
			if _, ok := fieldSeen[entityhistory.FieldEntityTypeID]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldEntityTypeID)
				fieldSeen[entityhistory.FieldEntityTypeID] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[entityhistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldStatus)
				fieldSeen[entityhistory.FieldStatus] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		eh.Select(selectedFields...)
	}
	return nil
}

type entityhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntityHistoryPaginateOption
}

func newEntityHistoryPaginateArgs(rv map[string]any) *entityhistoryPaginateArgs {
	args := &entityhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &EntityHistoryOrder{Field: &EntityHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithEntityHistoryOrder(order))
			}
		case *EntityHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithEntityHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*EntityHistoryWhereInput); ok {
		args.opts = append(args.opts, WithEntityHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (et *EntityTypeQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntityTypeQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return et, nil
	}
	if err := et.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return et, nil
}

func (et *EntityTypeQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(entitytype.Columns))
		selectedFields = []string{entitytype.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: et.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			et.withCreatedBy = query
			if _, ok := fieldSeen[entitytype.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldCreatedByID)
				fieldSeen[entitytype.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: et.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			et.withUpdatedBy = query
			if _, ok := fieldSeen[entitytype.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldUpdatedByID)
				fieldSeen[entitytype.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: et.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			et.withOwner = query
			if _, ok := fieldSeen[entitytype.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldOwnerID)
				fieldSeen[entitytype.FieldOwnerID] = struct{}{}
			}

		case "entities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityClient{config: et.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entityImplementors)...); err != nil {
				return err
			}
			et.WithNamedEntities(alias, func(wq *EntityQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[entitytype.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldCreatedAt)
				fieldSeen[entitytype.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[entitytype.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldUpdatedAt)
				fieldSeen[entitytype.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[entitytype.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldCreatedByID)
				fieldSeen[entitytype.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[entitytype.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldUpdatedByID)
				fieldSeen[entitytype.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[entitytype.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldDeletedAt)
				fieldSeen[entitytype.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[entitytype.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldDeletedByID)
				fieldSeen[entitytype.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[entitytype.FieldTags]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldTags)
				fieldSeen[entitytype.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[entitytype.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldOwnerID)
				fieldSeen[entitytype.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[entitytype.FieldName]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldName)
				fieldSeen[entitytype.FieldName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		et.Select(selectedFields...)
	}
	return nil
}

type entitytypePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntityTypePaginateOption
}

func newEntityTypePaginateArgs(rv map[string]any) *entitytypePaginateArgs {
	args := &entitytypePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &EntityTypeOrder{Field: &EntityTypeOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithEntityTypeOrder(order))
			}
		case *EntityTypeOrder:
			if v != nil {
				args.opts = append(args.opts, WithEntityTypeOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*EntityTypeWhereInput); ok {
		args.opts = append(args.opts, WithEntityTypeFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (eth *EntityTypeHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntityTypeHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return eth, nil
	}
	if err := eth.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return eth, nil
}

func (eth *EntityTypeHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(entitytypehistory.Columns))
		selectedFields = []string{entitytypehistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[entitytypehistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldHistoryTime)
				fieldSeen[entitytypehistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[entitytypehistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldRef)
				fieldSeen[entitytypehistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[entitytypehistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldOperation)
				fieldSeen[entitytypehistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[entitytypehistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldUpdatedBy)
				fieldSeen[entitytypehistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[entitytypehistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldCreatedAt)
				fieldSeen[entitytypehistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[entitytypehistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldUpdatedAt)
				fieldSeen[entitytypehistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[entitytypehistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldCreatedByID)
				fieldSeen[entitytypehistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[entitytypehistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldUpdatedByID)
				fieldSeen[entitytypehistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[entitytypehistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldDeletedAt)
				fieldSeen[entitytypehistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[entitytypehistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldDeletedByID)
				fieldSeen[entitytypehistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[entitytypehistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldTags)
				fieldSeen[entitytypehistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[entitytypehistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldOwnerID)
				fieldSeen[entitytypehistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[entitytypehistory.FieldName]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldName)
				fieldSeen[entitytypehistory.FieldName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		eth.Select(selectedFields...)
	}
	return nil
}

type entitytypehistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntityTypeHistoryPaginateOption
}

func newEntityTypeHistoryPaginateArgs(rv map[string]any) *entitytypehistoryPaginateArgs {
	args := &entitytypehistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &EntityTypeHistoryOrder{Field: &EntityTypeHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithEntityTypeHistoryOrder(order))
			}
		case *EntityTypeHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithEntityTypeHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*EntityTypeHistoryWhereInput); ok {
		args.opts = append(args.opts, WithEntityTypeHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (e *EventQuery) CollectFields(ctx context.Context, satisfies ...string) (*EventQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return e, nil
	}
	if err := e.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return e, nil
}

func (e *EventQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(event.Columns))
		selectedFields = []string{event.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			e.withCreatedBy = query
			if _, ok := fieldSeen[event.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, event.FieldCreatedByID)
				fieldSeen[event.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			e.withUpdatedBy = query
			if _, ok := fieldSeen[event.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, event.FieldUpdatedByID)
				fieldSeen[event.FieldUpdatedByID] = struct{}{}
			}

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			e.WithNamedUser(alias, func(wq *UserQuery) {
				*wq = *query
			})

		case "group":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			e.WithNamedGroup(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "integration":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IntegrationClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, integrationImplementors)...); err != nil {
				return err
			}
			e.WithNamedIntegration(alias, func(wq *IntegrationQuery) {
				*wq = *query
			})

		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			e.WithNamedOrganization(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "invite":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InviteClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, inviteImplementors)...); err != nil {
				return err
			}
			e.WithNamedInvite(alias, func(wq *InviteQuery) {
				*wq = *query
			})

		case "personalAccessToken":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonalAccessTokenClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, personalaccesstokenImplementors)...); err != nil {
				return err
			}
			e.WithNamedPersonalAccessToken(alias, func(wq *PersonalAccessTokenQuery) {
				*wq = *query
			})

		case "hush":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HushClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, hushImplementors)...); err != nil {
				return err
			}
			e.WithNamedHush(alias, func(wq *HushQuery) {
				*wq = *query
			})

		case "orgmembership":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrgMembershipClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, orgmembershipImplementors)...); err != nil {
				return err
			}
			e.WithNamedOrgmembership(alias, func(wq *OrgMembershipQuery) {
				*wq = *query
			})

		case "groupmembership":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupMembershipClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupmembershipImplementors)...); err != nil {
				return err
			}
			e.WithNamedGroupmembership(alias, func(wq *GroupMembershipQuery) {
				*wq = *query
			})

		case "subscriber":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SubscriberClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, subscriberImplementors)...); err != nil {
				return err
			}
			e.WithNamedSubscriber(alias, func(wq *SubscriberQuery) {
				*wq = *query
			})

		case "file":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			e.WithNamedFile(alias, func(wq *FileQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[event.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, event.FieldCreatedAt)
				fieldSeen[event.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[event.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, event.FieldUpdatedAt)
				fieldSeen[event.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[event.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, event.FieldCreatedByID)
				fieldSeen[event.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[event.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, event.FieldUpdatedByID)
				fieldSeen[event.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[event.FieldTags]; !ok {
				selectedFields = append(selectedFields, event.FieldTags)
				fieldSeen[event.FieldTags] = struct{}{}
			}
		case "eventID":
			if _, ok := fieldSeen[event.FieldEventID]; !ok {
				selectedFields = append(selectedFields, event.FieldEventID)
				fieldSeen[event.FieldEventID] = struct{}{}
			}
		case "correlationID":
			if _, ok := fieldSeen[event.FieldCorrelationID]; !ok {
				selectedFields = append(selectedFields, event.FieldCorrelationID)
				fieldSeen[event.FieldCorrelationID] = struct{}{}
			}
		case "eventType":
			if _, ok := fieldSeen[event.FieldEventType]; !ok {
				selectedFields = append(selectedFields, event.FieldEventType)
				fieldSeen[event.FieldEventType] = struct{}{}
			}
		case "metadata":
			if _, ok := fieldSeen[event.FieldMetadata]; !ok {
				selectedFields = append(selectedFields, event.FieldMetadata)
				fieldSeen[event.FieldMetadata] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		e.Select(selectedFields...)
	}
	return nil
}

type eventPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EventPaginateOption
}

func newEventPaginateArgs(rv map[string]any) *eventPaginateArgs {
	args := &eventPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*EventWhereInput); ok {
		args.opts = append(args.opts, WithEventFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (eh *EventHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*EventHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return eh, nil
	}
	if err := eh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return eh, nil
}

func (eh *EventHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(eventhistory.Columns))
		selectedFields = []string{eventhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[eventhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldHistoryTime)
				fieldSeen[eventhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[eventhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldRef)
				fieldSeen[eventhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[eventhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldOperation)
				fieldSeen[eventhistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[eventhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldUpdatedBy)
				fieldSeen[eventhistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[eventhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldCreatedAt)
				fieldSeen[eventhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[eventhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldUpdatedAt)
				fieldSeen[eventhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[eventhistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldCreatedByID)
				fieldSeen[eventhistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[eventhistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldUpdatedByID)
				fieldSeen[eventhistory.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[eventhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldTags)
				fieldSeen[eventhistory.FieldTags] = struct{}{}
			}
		case "eventID":
			if _, ok := fieldSeen[eventhistory.FieldEventID]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldEventID)
				fieldSeen[eventhistory.FieldEventID] = struct{}{}
			}
		case "correlationID":
			if _, ok := fieldSeen[eventhistory.FieldCorrelationID]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldCorrelationID)
				fieldSeen[eventhistory.FieldCorrelationID] = struct{}{}
			}
		case "eventType":
			if _, ok := fieldSeen[eventhistory.FieldEventType]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldEventType)
				fieldSeen[eventhistory.FieldEventType] = struct{}{}
			}
		case "metadata":
			if _, ok := fieldSeen[eventhistory.FieldMetadata]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldMetadata)
				fieldSeen[eventhistory.FieldMetadata] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		eh.Select(selectedFields...)
	}
	return nil
}

type eventhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EventHistoryPaginateOption
}

func newEventHistoryPaginateArgs(rv map[string]any) *eventhistoryPaginateArgs {
	args := &eventhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*EventHistoryWhereInput); ok {
		args.opts = append(args.opts, WithEventHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (f *FileQuery) CollectFields(ctx context.Context, satisfies ...string) (*FileQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return f, nil
	}
	if err := f.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return f, nil
}

func (f *FileQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(file.Columns))
		selectedFields = []string{file.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			f.withCreatedBy = query
			if _, ok := fieldSeen[file.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, file.FieldCreatedByID)
				fieldSeen[file.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			f.withUpdatedBy = query
			if _, ok := fieldSeen[file.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, file.FieldUpdatedByID)
				fieldSeen[file.FieldUpdatedByID] = struct{}{}
			}

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			f.WithNamedUser(alias, func(wq *UserQuery) {
				*wq = *query
			})

		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			f.WithNamedOrganization(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "group":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			f.WithNamedGroup(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "contact":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ContactClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, contactImplementors)...); err != nil {
				return err
			}
			f.WithNamedContact(alias, func(wq *ContactQuery) {
				*wq = *query
			})

		case "entity":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entityImplementors)...); err != nil {
				return err
			}
			f.WithNamedEntity(alias, func(wq *EntityQuery) {
				*wq = *query
			})

		case "userSetting":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserSettingClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, usersettingImplementors)...); err != nil {
				return err
			}
			f.WithNamedUserSetting(alias, func(wq *UserSettingQuery) {
				*wq = *query
			})

		case "organizationSetting":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationSettingClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationsettingImplementors)...); err != nil {
				return err
			}
			f.WithNamedOrganizationSetting(alias, func(wq *OrganizationSettingQuery) {
				*wq = *query
			})

		case "template":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TemplateClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, templateImplementors)...); err != nil {
				return err
			}
			f.WithNamedTemplate(alias, func(wq *TemplateQuery) {
				*wq = *query
			})

		case "documentData":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentDataClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentdataImplementors)...); err != nil {
				return err
			}
			f.WithNamedDocumentData(alias, func(wq *DocumentDataQuery) {
				*wq = *query
			})

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			f.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})

		case "program":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			f.WithNamedProgram(alias, func(wq *ProgramQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[file.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, file.FieldCreatedAt)
				fieldSeen[file.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[file.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, file.FieldUpdatedAt)
				fieldSeen[file.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[file.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, file.FieldCreatedByID)
				fieldSeen[file.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[file.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, file.FieldUpdatedByID)
				fieldSeen[file.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[file.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, file.FieldDeletedAt)
				fieldSeen[file.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[file.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, file.FieldDeletedByID)
				fieldSeen[file.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[file.FieldTags]; !ok {
				selectedFields = append(selectedFields, file.FieldTags)
				fieldSeen[file.FieldTags] = struct{}{}
			}
		case "providedFileName":
			if _, ok := fieldSeen[file.FieldProvidedFileName]; !ok {
				selectedFields = append(selectedFields, file.FieldProvidedFileName)
				fieldSeen[file.FieldProvidedFileName] = struct{}{}
			}
		case "providedFileExtension":
			if _, ok := fieldSeen[file.FieldProvidedFileExtension]; !ok {
				selectedFields = append(selectedFields, file.FieldProvidedFileExtension)
				fieldSeen[file.FieldProvidedFileExtension] = struct{}{}
			}
		case "providedFileSize":
			if _, ok := fieldSeen[file.FieldProvidedFileSize]; !ok {
				selectedFields = append(selectedFields, file.FieldProvidedFileSize)
				fieldSeen[file.FieldProvidedFileSize] = struct{}{}
			}
		case "persistedFileSize":
			if _, ok := fieldSeen[file.FieldPersistedFileSize]; !ok {
				selectedFields = append(selectedFields, file.FieldPersistedFileSize)
				fieldSeen[file.FieldPersistedFileSize] = struct{}{}
			}
		case "detectedMimeType":
			if _, ok := fieldSeen[file.FieldDetectedMimeType]; !ok {
				selectedFields = append(selectedFields, file.FieldDetectedMimeType)
				fieldSeen[file.FieldDetectedMimeType] = struct{}{}
			}
		case "md5Hash":
			if _, ok := fieldSeen[file.FieldMd5Hash]; !ok {
				selectedFields = append(selectedFields, file.FieldMd5Hash)
				fieldSeen[file.FieldMd5Hash] = struct{}{}
			}
		case "detectedContentType":
			if _, ok := fieldSeen[file.FieldDetectedContentType]; !ok {
				selectedFields = append(selectedFields, file.FieldDetectedContentType)
				fieldSeen[file.FieldDetectedContentType] = struct{}{}
			}
		case "storeKey":
			if _, ok := fieldSeen[file.FieldStoreKey]; !ok {
				selectedFields = append(selectedFields, file.FieldStoreKey)
				fieldSeen[file.FieldStoreKey] = struct{}{}
			}
		case "categoryType":
			if _, ok := fieldSeen[file.FieldCategoryType]; !ok {
				selectedFields = append(selectedFields, file.FieldCategoryType)
				fieldSeen[file.FieldCategoryType] = struct{}{}
			}
		case "uri":
			if _, ok := fieldSeen[file.FieldURI]; !ok {
				selectedFields = append(selectedFields, file.FieldURI)
				fieldSeen[file.FieldURI] = struct{}{}
			}
		case "storageScheme":
			if _, ok := fieldSeen[file.FieldStorageScheme]; !ok {
				selectedFields = append(selectedFields, file.FieldStorageScheme)
				fieldSeen[file.FieldStorageScheme] = struct{}{}
			}
		case "storageVolume":
			if _, ok := fieldSeen[file.FieldStorageVolume]; !ok {
				selectedFields = append(selectedFields, file.FieldStorageVolume)
				fieldSeen[file.FieldStorageVolume] = struct{}{}
			}
		case "storagePath":
			if _, ok := fieldSeen[file.FieldStoragePath]; !ok {
				selectedFields = append(selectedFields, file.FieldStoragePath)
				fieldSeen[file.FieldStoragePath] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		f.Select(selectedFields...)
	}
	return nil
}

type filePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FilePaginateOption
}

func newFilePaginateArgs(rv map[string]any) *filePaginateArgs {
	args := &filePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*FileWhereInput); ok {
		args.opts = append(args.opts, WithFileFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (fh *FileHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*FileHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return fh, nil
	}
	if err := fh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return fh, nil
}

func (fh *FileHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(filehistory.Columns))
		selectedFields = []string{filehistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[filehistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldHistoryTime)
				fieldSeen[filehistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[filehistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldRef)
				fieldSeen[filehistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[filehistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldOperation)
				fieldSeen[filehistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[filehistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldUpdatedBy)
				fieldSeen[filehistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[filehistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldCreatedAt)
				fieldSeen[filehistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[filehistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldUpdatedAt)
				fieldSeen[filehistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[filehistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldCreatedByID)
				fieldSeen[filehistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[filehistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldUpdatedByID)
				fieldSeen[filehistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[filehistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldDeletedAt)
				fieldSeen[filehistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[filehistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldDeletedByID)
				fieldSeen[filehistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[filehistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldTags)
				fieldSeen[filehistory.FieldTags] = struct{}{}
			}
		case "providedFileName":
			if _, ok := fieldSeen[filehistory.FieldProvidedFileName]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldProvidedFileName)
				fieldSeen[filehistory.FieldProvidedFileName] = struct{}{}
			}
		case "providedFileExtension":
			if _, ok := fieldSeen[filehistory.FieldProvidedFileExtension]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldProvidedFileExtension)
				fieldSeen[filehistory.FieldProvidedFileExtension] = struct{}{}
			}
		case "providedFileSize":
			if _, ok := fieldSeen[filehistory.FieldProvidedFileSize]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldProvidedFileSize)
				fieldSeen[filehistory.FieldProvidedFileSize] = struct{}{}
			}
		case "persistedFileSize":
			if _, ok := fieldSeen[filehistory.FieldPersistedFileSize]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldPersistedFileSize)
				fieldSeen[filehistory.FieldPersistedFileSize] = struct{}{}
			}
		case "detectedMimeType":
			if _, ok := fieldSeen[filehistory.FieldDetectedMimeType]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldDetectedMimeType)
				fieldSeen[filehistory.FieldDetectedMimeType] = struct{}{}
			}
		case "md5Hash":
			if _, ok := fieldSeen[filehistory.FieldMd5Hash]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldMd5Hash)
				fieldSeen[filehistory.FieldMd5Hash] = struct{}{}
			}
		case "detectedContentType":
			if _, ok := fieldSeen[filehistory.FieldDetectedContentType]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldDetectedContentType)
				fieldSeen[filehistory.FieldDetectedContentType] = struct{}{}
			}
		case "storeKey":
			if _, ok := fieldSeen[filehistory.FieldStoreKey]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldStoreKey)
				fieldSeen[filehistory.FieldStoreKey] = struct{}{}
			}
		case "categoryType":
			if _, ok := fieldSeen[filehistory.FieldCategoryType]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldCategoryType)
				fieldSeen[filehistory.FieldCategoryType] = struct{}{}
			}
		case "uri":
			if _, ok := fieldSeen[filehistory.FieldURI]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldURI)
				fieldSeen[filehistory.FieldURI] = struct{}{}
			}
		case "storageScheme":
			if _, ok := fieldSeen[filehistory.FieldStorageScheme]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldStorageScheme)
				fieldSeen[filehistory.FieldStorageScheme] = struct{}{}
			}
		case "storageVolume":
			if _, ok := fieldSeen[filehistory.FieldStorageVolume]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldStorageVolume)
				fieldSeen[filehistory.FieldStorageVolume] = struct{}{}
			}
		case "storagePath":
			if _, ok := fieldSeen[filehistory.FieldStoragePath]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldStoragePath)
				fieldSeen[filehistory.FieldStoragePath] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		fh.Select(selectedFields...)
	}
	return nil
}

type filehistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FileHistoryPaginateOption
}

func newFileHistoryPaginateArgs(rv map[string]any) *filehistoryPaginateArgs {
	args := &filehistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*FileHistoryWhereInput); ok {
		args.opts = append(args.opts, WithFileHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gr *GroupQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gr, nil
	}
	if err := gr.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gr, nil
}

func (gr *GroupQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(group.Columns))
		selectedFields = []string{group.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			gr.withCreatedBy = query
			if _, ok := fieldSeen[group.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, group.FieldCreatedByID)
				fieldSeen[group.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			gr.withUpdatedBy = query
			if _, ok := fieldSeen[group.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, group.FieldUpdatedByID)
				fieldSeen[group.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			gr.withOwner = query
			if _, ok := fieldSeen[group.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, group.FieldOwnerID)
				fieldSeen[group.FieldOwnerID] = struct{}{}
			}

		case "controlCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			gr.WithNamedControlCreators(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "controlObjectiveCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			gr.WithNamedControlObjectiveCreators(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "groupCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			gr.WithNamedGroupCreators(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "internalPolicyCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			gr.WithNamedInternalPolicyCreators(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "narrativeCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			gr.WithNamedNarrativeCreators(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "procedureCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			gr.WithNamedProcedureCreators(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "programCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			gr.WithNamedProgramCreators(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "riskCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			gr.WithNamedRiskCreators(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "templateCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			gr.WithNamedTemplateCreators(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "procedureEditors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProcedureClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, procedureImplementors)...); err != nil {
				return err
			}
			gr.WithNamedProcedureEditors(alias, func(wq *ProcedureQuery) {
				*wq = *query
			})

		case "procedureBlockedGroups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProcedureClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, procedureImplementors)...); err != nil {
				return err
			}
			gr.WithNamedProcedureBlockedGroups(alias, func(wq *ProcedureQuery) {
				*wq = *query
			})

		case "internalPolicyEditors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InternalPolicyClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, internalpolicyImplementors)...); err != nil {
				return err
			}
			gr.WithNamedInternalPolicyEditors(alias, func(wq *InternalPolicyQuery) {
				*wq = *query
			})

		case "internalPolicyBlockedGroups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InternalPolicyClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, internalpolicyImplementors)...); err != nil {
				return err
			}
			gr.WithNamedInternalPolicyBlockedGroups(alias, func(wq *InternalPolicyQuery) {
				*wq = *query
			})

		case "programEditors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			gr.WithNamedProgramEditors(alias, func(wq *ProgramQuery) {
				*wq = *query
			})

		case "programBlockedGroups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			gr.WithNamedProgramBlockedGroups(alias, func(wq *ProgramQuery) {
				*wq = *query
			})

		case "programViewers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			gr.WithNamedProgramViewers(alias, func(wq *ProgramQuery) {
				*wq = *query
			})

		case "riskEditors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RiskClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, riskImplementors)...); err != nil {
				return err
			}
			gr.WithNamedRiskEditors(alias, func(wq *RiskQuery) {
				*wq = *query
			})

		case "riskBlockedGroups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RiskClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, riskImplementors)...); err != nil {
				return err
			}
			gr.WithNamedRiskBlockedGroups(alias, func(wq *RiskQuery) {
				*wq = *query
			})

		case "riskViewers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RiskClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, riskImplementors)...); err != nil {
				return err
			}
			gr.WithNamedRiskViewers(alias, func(wq *RiskQuery) {
				*wq = *query
			})

		case "controlObjectiveEditors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlObjectiveClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlobjectiveImplementors)...); err != nil {
				return err
			}
			gr.WithNamedControlObjectiveEditors(alias, func(wq *ControlObjectiveQuery) {
				*wq = *query
			})

		case "controlObjectiveBlockedGroups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlObjectiveClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlobjectiveImplementors)...); err != nil {
				return err
			}
			gr.WithNamedControlObjectiveBlockedGroups(alias, func(wq *ControlObjectiveQuery) {
				*wq = *query
			})

		case "controlObjectiveViewers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlObjectiveClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlobjectiveImplementors)...); err != nil {
				return err
			}
			gr.WithNamedControlObjectiveViewers(alias, func(wq *ControlObjectiveQuery) {
				*wq = *query
			})

		case "controlEditors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlImplementors)...); err != nil {
				return err
			}
			gr.WithNamedControlEditors(alias, func(wq *ControlQuery) {
				*wq = *query
			})

		case "controlBlockedGroups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlImplementors)...); err != nil {
				return err
			}
			gr.WithNamedControlBlockedGroups(alias, func(wq *ControlQuery) {
				*wq = *query
			})

		case "controlViewers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlImplementors)...); err != nil {
				return err
			}
			gr.WithNamedControlViewers(alias, func(wq *ControlQuery) {
				*wq = *query
			})

		case "narrativeEditors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NarrativeClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, narrativeImplementors)...); err != nil {
				return err
			}
			gr.WithNamedNarrativeEditors(alias, func(wq *NarrativeQuery) {
				*wq = *query
			})

		case "narrativeBlockedGroups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NarrativeClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, narrativeImplementors)...); err != nil {
				return err
			}
			gr.WithNamedNarrativeBlockedGroups(alias, func(wq *NarrativeQuery) {
				*wq = *query
			})

		case "narrativeViewers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NarrativeClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, narrativeImplementors)...); err != nil {
				return err
			}
			gr.WithNamedNarrativeViewers(alias, func(wq *NarrativeQuery) {
				*wq = *query
			})

		case "setting":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupSettingClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, groupsettingImplementors)...); err != nil {
				return err
			}
			gr.withSetting = query

		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			gr.WithNamedUsers(alias, func(wq *UserQuery) {
				*wq = *query
			})

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			gr.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})

		case "integrations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IntegrationClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, integrationImplementors)...); err != nil {
				return err
			}
			gr.WithNamedIntegrations(alias, func(wq *IntegrationQuery) {
				*wq = *query
			})

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			gr.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})

		case "tasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			gr.WithNamedTasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "members":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupMembershipClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupmembershipImplementors)...); err != nil {
				return err
			}
			gr.WithNamedMembers(alias, func(wq *GroupMembershipQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[group.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, group.FieldCreatedAt)
				fieldSeen[group.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[group.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, group.FieldUpdatedAt)
				fieldSeen[group.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[group.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, group.FieldCreatedByID)
				fieldSeen[group.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[group.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, group.FieldUpdatedByID)
				fieldSeen[group.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[group.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, group.FieldDeletedAt)
				fieldSeen[group.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[group.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, group.FieldDeletedByID)
				fieldSeen[group.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[group.FieldTags]; !ok {
				selectedFields = append(selectedFields, group.FieldTags)
				fieldSeen[group.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[group.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, group.FieldOwnerID)
				fieldSeen[group.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[group.FieldName]; !ok {
				selectedFields = append(selectedFields, group.FieldName)
				fieldSeen[group.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[group.FieldDescription]; !ok {
				selectedFields = append(selectedFields, group.FieldDescription)
				fieldSeen[group.FieldDescription] = struct{}{}
			}
		case "gravatarLogoURL":
			if _, ok := fieldSeen[group.FieldGravatarLogoURL]; !ok {
				selectedFields = append(selectedFields, group.FieldGravatarLogoURL)
				fieldSeen[group.FieldGravatarLogoURL] = struct{}{}
			}
		case "logoURL":
			if _, ok := fieldSeen[group.FieldLogoURL]; !ok {
				selectedFields = append(selectedFields, group.FieldLogoURL)
				fieldSeen[group.FieldLogoURL] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[group.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, group.FieldDisplayName)
				fieldSeen[group.FieldDisplayName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gr.Select(selectedFields...)
	}
	return nil
}

type groupPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupPaginateOption
}

func newGroupPaginateArgs(rv map[string]any) *groupPaginateArgs {
	args := &groupPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &GroupOrder{Field: &GroupOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithGroupOrder(order))
			}
		case *GroupOrder:
			if v != nil {
				args.opts = append(args.opts, WithGroupOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*GroupWhereInput); ok {
		args.opts = append(args.opts, WithGroupFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gh *GroupHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gh, nil
	}
	if err := gh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gh, nil
}

func (gh *GroupHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(grouphistory.Columns))
		selectedFields = []string{grouphistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[grouphistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldHistoryTime)
				fieldSeen[grouphistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[grouphistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldRef)
				fieldSeen[grouphistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[grouphistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldOperation)
				fieldSeen[grouphistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[grouphistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldUpdatedBy)
				fieldSeen[grouphistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[grouphistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldCreatedAt)
				fieldSeen[grouphistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[grouphistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldUpdatedAt)
				fieldSeen[grouphistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[grouphistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldCreatedByID)
				fieldSeen[grouphistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[grouphistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldUpdatedByID)
				fieldSeen[grouphistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[grouphistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldDeletedAt)
				fieldSeen[grouphistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[grouphistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldDeletedByID)
				fieldSeen[grouphistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[grouphistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldTags)
				fieldSeen[grouphistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[grouphistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldOwnerID)
				fieldSeen[grouphistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[grouphistory.FieldName]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldName)
				fieldSeen[grouphistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[grouphistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldDescription)
				fieldSeen[grouphistory.FieldDescription] = struct{}{}
			}
		case "gravatarLogoURL":
			if _, ok := fieldSeen[grouphistory.FieldGravatarLogoURL]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldGravatarLogoURL)
				fieldSeen[grouphistory.FieldGravatarLogoURL] = struct{}{}
			}
		case "logoURL":
			if _, ok := fieldSeen[grouphistory.FieldLogoURL]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldLogoURL)
				fieldSeen[grouphistory.FieldLogoURL] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[grouphistory.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldDisplayName)
				fieldSeen[grouphistory.FieldDisplayName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gh.Select(selectedFields...)
	}
	return nil
}

type grouphistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupHistoryPaginateOption
}

func newGroupHistoryPaginateArgs(rv map[string]any) *grouphistoryPaginateArgs {
	args := &grouphistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &GroupHistoryOrder{Field: &GroupHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithGroupHistoryOrder(order))
			}
		case *GroupHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithGroupHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*GroupHistoryWhereInput); ok {
		args.opts = append(args.opts, WithGroupHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gm *GroupMembershipQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupMembershipQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gm, nil
	}
	if err := gm.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gm, nil
}

func (gm *GroupMembershipQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(groupmembership.Columns))
		selectedFields = []string{groupmembership.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: gm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			gm.withCreatedBy = query
			if _, ok := fieldSeen[groupmembership.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldCreatedByID)
				fieldSeen[groupmembership.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: gm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			gm.withUpdatedBy = query
			if _, ok := fieldSeen[groupmembership.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldUpdatedByID)
				fieldSeen[groupmembership.FieldUpdatedByID] = struct{}{}
			}

		case "group":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: gm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			gm.withGroup = query
			if _, ok := fieldSeen[groupmembership.FieldGroupID]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldGroupID)
				fieldSeen[groupmembership.FieldGroupID] = struct{}{}
			}

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: gm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			gm.withUser = query
			if _, ok := fieldSeen[groupmembership.FieldUserID]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldUserID)
				fieldSeen[groupmembership.FieldUserID] = struct{}{}
			}

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: gm.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			gm.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[groupmembership.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldCreatedAt)
				fieldSeen[groupmembership.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[groupmembership.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldUpdatedAt)
				fieldSeen[groupmembership.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[groupmembership.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldCreatedByID)
				fieldSeen[groupmembership.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[groupmembership.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldUpdatedByID)
				fieldSeen[groupmembership.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[groupmembership.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldDeletedAt)
				fieldSeen[groupmembership.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[groupmembership.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldDeletedByID)
				fieldSeen[groupmembership.FieldDeletedByID] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[groupmembership.FieldRole]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldRole)
				fieldSeen[groupmembership.FieldRole] = struct{}{}
			}
		case "groupID":
			if _, ok := fieldSeen[groupmembership.FieldGroupID]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldGroupID)
				fieldSeen[groupmembership.FieldGroupID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[groupmembership.FieldUserID]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldUserID)
				fieldSeen[groupmembership.FieldUserID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gm.Select(selectedFields...)
	}
	return nil
}

type groupmembershipPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupMembershipPaginateOption
}

func newGroupMembershipPaginateArgs(rv map[string]any) *groupmembershipPaginateArgs {
	args := &groupmembershipPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*GroupMembershipWhereInput); ok {
		args.opts = append(args.opts, WithGroupMembershipFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gmh *GroupMembershipHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupMembershipHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gmh, nil
	}
	if err := gmh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gmh, nil
}

func (gmh *GroupMembershipHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(groupmembershiphistory.Columns))
		selectedFields = []string{groupmembershiphistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[groupmembershiphistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldHistoryTime)
				fieldSeen[groupmembershiphistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[groupmembershiphistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldRef)
				fieldSeen[groupmembershiphistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[groupmembershiphistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldOperation)
				fieldSeen[groupmembershiphistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[groupmembershiphistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldUpdatedBy)
				fieldSeen[groupmembershiphistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[groupmembershiphistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldCreatedAt)
				fieldSeen[groupmembershiphistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[groupmembershiphistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldUpdatedAt)
				fieldSeen[groupmembershiphistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[groupmembershiphistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldCreatedByID)
				fieldSeen[groupmembershiphistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[groupmembershiphistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldUpdatedByID)
				fieldSeen[groupmembershiphistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[groupmembershiphistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldDeletedAt)
				fieldSeen[groupmembershiphistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[groupmembershiphistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldDeletedByID)
				fieldSeen[groupmembershiphistory.FieldDeletedByID] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[groupmembershiphistory.FieldRole]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldRole)
				fieldSeen[groupmembershiphistory.FieldRole] = struct{}{}
			}
		case "groupID":
			if _, ok := fieldSeen[groupmembershiphistory.FieldGroupID]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldGroupID)
				fieldSeen[groupmembershiphistory.FieldGroupID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[groupmembershiphistory.FieldUserID]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldUserID)
				fieldSeen[groupmembershiphistory.FieldUserID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gmh.Select(selectedFields...)
	}
	return nil
}

type groupmembershiphistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupMembershipHistoryPaginateOption
}

func newGroupMembershipHistoryPaginateArgs(rv map[string]any) *groupmembershiphistoryPaginateArgs {
	args := &groupmembershiphistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*GroupMembershipHistoryWhereInput); ok {
		args.opts = append(args.opts, WithGroupMembershipHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gs *GroupSettingQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupSettingQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gs, nil
	}
	if err := gs.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gs, nil
}

func (gs *GroupSettingQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(groupsetting.Columns))
		selectedFields = []string{groupsetting.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: gs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			gs.withCreatedBy = query
			if _, ok := fieldSeen[groupsetting.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldCreatedByID)
				fieldSeen[groupsetting.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: gs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			gs.withUpdatedBy = query
			if _, ok := fieldSeen[groupsetting.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldUpdatedByID)
				fieldSeen[groupsetting.FieldUpdatedByID] = struct{}{}
			}

		case "group":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: gs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			gs.withGroup = query
			if _, ok := fieldSeen[groupsetting.FieldGroupID]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldGroupID)
				fieldSeen[groupsetting.FieldGroupID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[groupsetting.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldCreatedAt)
				fieldSeen[groupsetting.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[groupsetting.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldUpdatedAt)
				fieldSeen[groupsetting.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[groupsetting.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldCreatedByID)
				fieldSeen[groupsetting.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[groupsetting.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldUpdatedByID)
				fieldSeen[groupsetting.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[groupsetting.FieldTags]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldTags)
				fieldSeen[groupsetting.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[groupsetting.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldDeletedAt)
				fieldSeen[groupsetting.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[groupsetting.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldDeletedByID)
				fieldSeen[groupsetting.FieldDeletedByID] = struct{}{}
			}
		case "visibility":
			if _, ok := fieldSeen[groupsetting.FieldVisibility]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldVisibility)
				fieldSeen[groupsetting.FieldVisibility] = struct{}{}
			}
		case "joinPolicy":
			if _, ok := fieldSeen[groupsetting.FieldJoinPolicy]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldJoinPolicy)
				fieldSeen[groupsetting.FieldJoinPolicy] = struct{}{}
			}
		case "syncToSlack":
			if _, ok := fieldSeen[groupsetting.FieldSyncToSlack]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldSyncToSlack)
				fieldSeen[groupsetting.FieldSyncToSlack] = struct{}{}
			}
		case "syncToGithub":
			if _, ok := fieldSeen[groupsetting.FieldSyncToGithub]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldSyncToGithub)
				fieldSeen[groupsetting.FieldSyncToGithub] = struct{}{}
			}
		case "groupID":
			if _, ok := fieldSeen[groupsetting.FieldGroupID]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldGroupID)
				fieldSeen[groupsetting.FieldGroupID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gs.Select(selectedFields...)
	}
	return nil
}

type groupsettingPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupSettingPaginateOption
}

func newGroupSettingPaginateArgs(rv map[string]any) *groupsettingPaginateArgs {
	args := &groupsettingPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*GroupSettingWhereInput); ok {
		args.opts = append(args.opts, WithGroupSettingFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gsh *GroupSettingHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupSettingHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gsh, nil
	}
	if err := gsh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gsh, nil
}

func (gsh *GroupSettingHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(groupsettinghistory.Columns))
		selectedFields = []string{groupsettinghistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[groupsettinghistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldHistoryTime)
				fieldSeen[groupsettinghistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[groupsettinghistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldRef)
				fieldSeen[groupsettinghistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[groupsettinghistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldOperation)
				fieldSeen[groupsettinghistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[groupsettinghistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldUpdatedBy)
				fieldSeen[groupsettinghistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[groupsettinghistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldCreatedAt)
				fieldSeen[groupsettinghistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[groupsettinghistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldUpdatedAt)
				fieldSeen[groupsettinghistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[groupsettinghistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldCreatedByID)
				fieldSeen[groupsettinghistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[groupsettinghistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldUpdatedByID)
				fieldSeen[groupsettinghistory.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[groupsettinghistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldTags)
				fieldSeen[groupsettinghistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[groupsettinghistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldDeletedAt)
				fieldSeen[groupsettinghistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[groupsettinghistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldDeletedByID)
				fieldSeen[groupsettinghistory.FieldDeletedByID] = struct{}{}
			}
		case "visibility":
			if _, ok := fieldSeen[groupsettinghistory.FieldVisibility]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldVisibility)
				fieldSeen[groupsettinghistory.FieldVisibility] = struct{}{}
			}
		case "joinPolicy":
			if _, ok := fieldSeen[groupsettinghistory.FieldJoinPolicy]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldJoinPolicy)
				fieldSeen[groupsettinghistory.FieldJoinPolicy] = struct{}{}
			}
		case "syncToSlack":
			if _, ok := fieldSeen[groupsettinghistory.FieldSyncToSlack]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldSyncToSlack)
				fieldSeen[groupsettinghistory.FieldSyncToSlack] = struct{}{}
			}
		case "syncToGithub":
			if _, ok := fieldSeen[groupsettinghistory.FieldSyncToGithub]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldSyncToGithub)
				fieldSeen[groupsettinghistory.FieldSyncToGithub] = struct{}{}
			}
		case "groupID":
			if _, ok := fieldSeen[groupsettinghistory.FieldGroupID]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldGroupID)
				fieldSeen[groupsettinghistory.FieldGroupID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gsh.Select(selectedFields...)
	}
	return nil
}

type groupsettinghistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupSettingHistoryPaginateOption
}

func newGroupSettingHistoryPaginateArgs(rv map[string]any) *groupsettinghistoryPaginateArgs {
	args := &groupsettinghistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*GroupSettingHistoryWhereInput); ok {
		args.opts = append(args.opts, WithGroupSettingHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (h *HushQuery) CollectFields(ctx context.Context, satisfies ...string) (*HushQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return h, nil
	}
	if err := h.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return h, nil
}

func (h *HushQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hush.Columns))
		selectedFields = []string{hush.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			h.withCreatedBy = query
			if _, ok := fieldSeen[hush.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, hush.FieldCreatedByID)
				fieldSeen[hush.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			h.withUpdatedBy = query
			if _, ok := fieldSeen[hush.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, hush.FieldUpdatedByID)
				fieldSeen[hush.FieldUpdatedByID] = struct{}{}
			}

		case "integrations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IntegrationClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, integrationImplementors)...); err != nil {
				return err
			}
			h.WithNamedIntegrations(alias, func(wq *IntegrationQuery) {
				*wq = *query
			})

		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			h.WithNamedOrganization(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			h.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[hush.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hush.FieldCreatedAt)
				fieldSeen[hush.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hush.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hush.FieldUpdatedAt)
				fieldSeen[hush.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[hush.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, hush.FieldCreatedByID)
				fieldSeen[hush.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[hush.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, hush.FieldUpdatedByID)
				fieldSeen[hush.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[hush.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, hush.FieldDeletedAt)
				fieldSeen[hush.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[hush.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, hush.FieldDeletedByID)
				fieldSeen[hush.FieldDeletedByID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[hush.FieldName]; !ok {
				selectedFields = append(selectedFields, hush.FieldName)
				fieldSeen[hush.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[hush.FieldDescription]; !ok {
				selectedFields = append(selectedFields, hush.FieldDescription)
				fieldSeen[hush.FieldDescription] = struct{}{}
			}
		case "kind":
			if _, ok := fieldSeen[hush.FieldKind]; !ok {
				selectedFields = append(selectedFields, hush.FieldKind)
				fieldSeen[hush.FieldKind] = struct{}{}
			}
		case "secretName":
			if _, ok := fieldSeen[hush.FieldSecretName]; !ok {
				selectedFields = append(selectedFields, hush.FieldSecretName)
				fieldSeen[hush.FieldSecretName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		h.Select(selectedFields...)
	}
	return nil
}

type hushPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HushPaginateOption
}

func newHushPaginateArgs(rv map[string]any) *hushPaginateArgs {
	args := &hushPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &HushOrder{Field: &HushOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHushOrder(order))
			}
		case *HushOrder:
			if v != nil {
				args.opts = append(args.opts, WithHushOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*HushWhereInput); ok {
		args.opts = append(args.opts, WithHushFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hh *HushHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*HushHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hh, nil
	}
	if err := hh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hh, nil
}

func (hh *HushHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hushhistory.Columns))
		selectedFields = []string{hushhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[hushhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldHistoryTime)
				fieldSeen[hushhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[hushhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldRef)
				fieldSeen[hushhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[hushhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldOperation)
				fieldSeen[hushhistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[hushhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldUpdatedBy)
				fieldSeen[hushhistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[hushhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldCreatedAt)
				fieldSeen[hushhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hushhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldUpdatedAt)
				fieldSeen[hushhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[hushhistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldCreatedByID)
				fieldSeen[hushhistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[hushhistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldUpdatedByID)
				fieldSeen[hushhistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[hushhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldDeletedAt)
				fieldSeen[hushhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[hushhistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldDeletedByID)
				fieldSeen[hushhistory.FieldDeletedByID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[hushhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldName)
				fieldSeen[hushhistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[hushhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldDescription)
				fieldSeen[hushhistory.FieldDescription] = struct{}{}
			}
		case "kind":
			if _, ok := fieldSeen[hushhistory.FieldKind]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldKind)
				fieldSeen[hushhistory.FieldKind] = struct{}{}
			}
		case "secretName":
			if _, ok := fieldSeen[hushhistory.FieldSecretName]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldSecretName)
				fieldSeen[hushhistory.FieldSecretName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hh.Select(selectedFields...)
	}
	return nil
}

type hushhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HushHistoryPaginateOption
}

func newHushHistoryPaginateArgs(rv map[string]any) *hushhistoryPaginateArgs {
	args := &hushhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &HushHistoryOrder{Field: &HushHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHushHistoryOrder(order))
			}
		case *HushHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithHushHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*HushHistoryWhereInput); ok {
		args.opts = append(args.opts, WithHushHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (i *IntegrationQuery) CollectFields(ctx context.Context, satisfies ...string) (*IntegrationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return i, nil
	}
	if err := i.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return i, nil
}

func (i *IntegrationQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(integration.Columns))
		selectedFields = []string{integration.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			i.withCreatedBy = query
			if _, ok := fieldSeen[integration.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, integration.FieldCreatedByID)
				fieldSeen[integration.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			i.withUpdatedBy = query
			if _, ok := fieldSeen[integration.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, integration.FieldUpdatedByID)
				fieldSeen[integration.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			i.withOwner = query
			if _, ok := fieldSeen[integration.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, integration.FieldOwnerID)
				fieldSeen[integration.FieldOwnerID] = struct{}{}
			}

		case "secrets":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HushClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, hushImplementors)...); err != nil {
				return err
			}
			i.WithNamedSecrets(alias, func(wq *HushQuery) {
				*wq = *query
			})

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			i.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[integration.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, integration.FieldCreatedAt)
				fieldSeen[integration.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[integration.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, integration.FieldUpdatedAt)
				fieldSeen[integration.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[integration.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, integration.FieldCreatedByID)
				fieldSeen[integration.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[integration.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, integration.FieldUpdatedByID)
				fieldSeen[integration.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[integration.FieldTags]; !ok {
				selectedFields = append(selectedFields, integration.FieldTags)
				fieldSeen[integration.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[integration.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, integration.FieldDeletedAt)
				fieldSeen[integration.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[integration.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, integration.FieldDeletedByID)
				fieldSeen[integration.FieldDeletedByID] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[integration.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, integration.FieldOwnerID)
				fieldSeen[integration.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[integration.FieldName]; !ok {
				selectedFields = append(selectedFields, integration.FieldName)
				fieldSeen[integration.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[integration.FieldDescription]; !ok {
				selectedFields = append(selectedFields, integration.FieldDescription)
				fieldSeen[integration.FieldDescription] = struct{}{}
			}
		case "kind":
			if _, ok := fieldSeen[integration.FieldKind]; !ok {
				selectedFields = append(selectedFields, integration.FieldKind)
				fieldSeen[integration.FieldKind] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		i.Select(selectedFields...)
	}
	return nil
}

type integrationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []IntegrationPaginateOption
}

func newIntegrationPaginateArgs(rv map[string]any) *integrationPaginateArgs {
	args := &integrationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &IntegrationOrder{Field: &IntegrationOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithIntegrationOrder(order))
			}
		case *IntegrationOrder:
			if v != nil {
				args.opts = append(args.opts, WithIntegrationOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*IntegrationWhereInput); ok {
		args.opts = append(args.opts, WithIntegrationFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ih *IntegrationHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*IntegrationHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ih, nil
	}
	if err := ih.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ih, nil
}

func (ih *IntegrationHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(integrationhistory.Columns))
		selectedFields = []string{integrationhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[integrationhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldHistoryTime)
				fieldSeen[integrationhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[integrationhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldRef)
				fieldSeen[integrationhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[integrationhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldOperation)
				fieldSeen[integrationhistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[integrationhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldUpdatedBy)
				fieldSeen[integrationhistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[integrationhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldCreatedAt)
				fieldSeen[integrationhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[integrationhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldUpdatedAt)
				fieldSeen[integrationhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[integrationhistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldCreatedByID)
				fieldSeen[integrationhistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[integrationhistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldUpdatedByID)
				fieldSeen[integrationhistory.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[integrationhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldTags)
				fieldSeen[integrationhistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[integrationhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldDeletedAt)
				fieldSeen[integrationhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[integrationhistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldDeletedByID)
				fieldSeen[integrationhistory.FieldDeletedByID] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[integrationhistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldOwnerID)
				fieldSeen[integrationhistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[integrationhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldName)
				fieldSeen[integrationhistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[integrationhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldDescription)
				fieldSeen[integrationhistory.FieldDescription] = struct{}{}
			}
		case "kind":
			if _, ok := fieldSeen[integrationhistory.FieldKind]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldKind)
				fieldSeen[integrationhistory.FieldKind] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ih.Select(selectedFields...)
	}
	return nil
}

type integrationhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []IntegrationHistoryPaginateOption
}

func newIntegrationHistoryPaginateArgs(rv map[string]any) *integrationhistoryPaginateArgs {
	args := &integrationhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &IntegrationHistoryOrder{Field: &IntegrationHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithIntegrationHistoryOrder(order))
			}
		case *IntegrationHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithIntegrationHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*IntegrationHistoryWhereInput); ok {
		args.opts = append(args.opts, WithIntegrationHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ip *InternalPolicyQuery) CollectFields(ctx context.Context, satisfies ...string) (*InternalPolicyQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ip, nil
	}
	if err := ip.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ip, nil
}

func (ip *InternalPolicyQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(internalpolicy.Columns))
		selectedFields = []string{internalpolicy.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ip.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			ip.withCreatedBy = query
			if _, ok := fieldSeen[internalpolicy.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldCreatedByID)
				fieldSeen[internalpolicy.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ip.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			ip.withUpdatedBy = query
			if _, ok := fieldSeen[internalpolicy.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldUpdatedByID)
				fieldSeen[internalpolicy.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: ip.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			ip.withOwner = query
			if _, ok := fieldSeen[internalpolicy.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldOwnerID)
				fieldSeen[internalpolicy.FieldOwnerID] = struct{}{}
			}

		case "blockedGroups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: ip.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			ip.WithNamedBlockedGroups(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "editors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: ip.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			ip.WithNamedEditors(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "controlObjectives":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlObjectiveClient{config: ip.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlobjectiveImplementors)...); err != nil {
				return err
			}
			ip.WithNamedControlObjectives(alias, func(wq *ControlObjectiveQuery) {
				*wq = *query
			})

		case "controls":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlClient{config: ip.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlImplementors)...); err != nil {
				return err
			}
			ip.WithNamedControls(alias, func(wq *ControlQuery) {
				*wq = *query
			})

		case "procedures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProcedureClient{config: ip.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, procedureImplementors)...); err != nil {
				return err
			}
			ip.WithNamedProcedures(alias, func(wq *ProcedureQuery) {
				*wq = *query
			})

		case "narratives":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NarrativeClient{config: ip.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, narrativeImplementors)...); err != nil {
				return err
			}
			ip.WithNamedNarratives(alias, func(wq *NarrativeQuery) {
				*wq = *query
			})

		case "tasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: ip.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			ip.WithNamedTasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "programs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: ip.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			ip.WithNamedPrograms(alias, func(wq *ProgramQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[internalpolicy.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldCreatedAt)
				fieldSeen[internalpolicy.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[internalpolicy.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldUpdatedAt)
				fieldSeen[internalpolicy.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[internalpolicy.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldCreatedByID)
				fieldSeen[internalpolicy.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[internalpolicy.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldUpdatedByID)
				fieldSeen[internalpolicy.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[internalpolicy.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldDeletedAt)
				fieldSeen[internalpolicy.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[internalpolicy.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldDeletedByID)
				fieldSeen[internalpolicy.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[internalpolicy.FieldTags]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldTags)
				fieldSeen[internalpolicy.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[internalpolicy.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldOwnerID)
				fieldSeen[internalpolicy.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[internalpolicy.FieldName]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldName)
				fieldSeen[internalpolicy.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[internalpolicy.FieldDescription]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldDescription)
				fieldSeen[internalpolicy.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[internalpolicy.FieldStatus]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldStatus)
				fieldSeen[internalpolicy.FieldStatus] = struct{}{}
			}
		case "policyType":
			if _, ok := fieldSeen[internalpolicy.FieldPolicyType]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldPolicyType)
				fieldSeen[internalpolicy.FieldPolicyType] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[internalpolicy.FieldVersion]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldVersion)
				fieldSeen[internalpolicy.FieldVersion] = struct{}{}
			}
		case "purposeAndScope":
			if _, ok := fieldSeen[internalpolicy.FieldPurposeAndScope]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldPurposeAndScope)
				fieldSeen[internalpolicy.FieldPurposeAndScope] = struct{}{}
			}
		case "background":
			if _, ok := fieldSeen[internalpolicy.FieldBackground]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldBackground)
				fieldSeen[internalpolicy.FieldBackground] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[internalpolicy.FieldDetails]; !ok {
				selectedFields = append(selectedFields, internalpolicy.FieldDetails)
				fieldSeen[internalpolicy.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ip.Select(selectedFields...)
	}
	return nil
}

type internalpolicyPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []InternalPolicyPaginateOption
}

func newInternalPolicyPaginateArgs(rv map[string]any) *internalpolicyPaginateArgs {
	args := &internalpolicyPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*InternalPolicyWhereInput); ok {
		args.opts = append(args.opts, WithInternalPolicyFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (iph *InternalPolicyHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*InternalPolicyHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return iph, nil
	}
	if err := iph.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return iph, nil
}

func (iph *InternalPolicyHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(internalpolicyhistory.Columns))
		selectedFields = []string{internalpolicyhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[internalpolicyhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldHistoryTime)
				fieldSeen[internalpolicyhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[internalpolicyhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldRef)
				fieldSeen[internalpolicyhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[internalpolicyhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldOperation)
				fieldSeen[internalpolicyhistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[internalpolicyhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldUpdatedBy)
				fieldSeen[internalpolicyhistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[internalpolicyhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldCreatedAt)
				fieldSeen[internalpolicyhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[internalpolicyhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldUpdatedAt)
				fieldSeen[internalpolicyhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[internalpolicyhistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldCreatedByID)
				fieldSeen[internalpolicyhistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[internalpolicyhistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldUpdatedByID)
				fieldSeen[internalpolicyhistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[internalpolicyhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldDeletedAt)
				fieldSeen[internalpolicyhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[internalpolicyhistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldDeletedByID)
				fieldSeen[internalpolicyhistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[internalpolicyhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldTags)
				fieldSeen[internalpolicyhistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[internalpolicyhistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldOwnerID)
				fieldSeen[internalpolicyhistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[internalpolicyhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldName)
				fieldSeen[internalpolicyhistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[internalpolicyhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldDescription)
				fieldSeen[internalpolicyhistory.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[internalpolicyhistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldStatus)
				fieldSeen[internalpolicyhistory.FieldStatus] = struct{}{}
			}
		case "policyType":
			if _, ok := fieldSeen[internalpolicyhistory.FieldPolicyType]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldPolicyType)
				fieldSeen[internalpolicyhistory.FieldPolicyType] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[internalpolicyhistory.FieldVersion]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldVersion)
				fieldSeen[internalpolicyhistory.FieldVersion] = struct{}{}
			}
		case "purposeAndScope":
			if _, ok := fieldSeen[internalpolicyhistory.FieldPurposeAndScope]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldPurposeAndScope)
				fieldSeen[internalpolicyhistory.FieldPurposeAndScope] = struct{}{}
			}
		case "background":
			if _, ok := fieldSeen[internalpolicyhistory.FieldBackground]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldBackground)
				fieldSeen[internalpolicyhistory.FieldBackground] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[internalpolicyhistory.FieldDetails]; !ok {
				selectedFields = append(selectedFields, internalpolicyhistory.FieldDetails)
				fieldSeen[internalpolicyhistory.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		iph.Select(selectedFields...)
	}
	return nil
}

type internalpolicyhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []InternalPolicyHistoryPaginateOption
}

func newInternalPolicyHistoryPaginateArgs(rv map[string]any) *internalpolicyhistoryPaginateArgs {
	args := &internalpolicyhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*InternalPolicyHistoryWhereInput); ok {
		args.opts = append(args.opts, WithInternalPolicyHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (i *InviteQuery) CollectFields(ctx context.Context, satisfies ...string) (*InviteQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return i, nil
	}
	if err := i.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return i, nil
}

func (i *InviteQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(invite.Columns))
		selectedFields = []string{invite.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			i.withCreatedBy = query
			if _, ok := fieldSeen[invite.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, invite.FieldCreatedByID)
				fieldSeen[invite.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			i.withUpdatedBy = query
			if _, ok := fieldSeen[invite.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, invite.FieldUpdatedByID)
				fieldSeen[invite.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			i.withOwner = query
			if _, ok := fieldSeen[invite.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, invite.FieldOwnerID)
				fieldSeen[invite.FieldOwnerID] = struct{}{}
			}

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			i.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[invite.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, invite.FieldCreatedAt)
				fieldSeen[invite.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[invite.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, invite.FieldUpdatedAt)
				fieldSeen[invite.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[invite.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, invite.FieldCreatedByID)
				fieldSeen[invite.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[invite.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, invite.FieldUpdatedByID)
				fieldSeen[invite.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[invite.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, invite.FieldDeletedAt)
				fieldSeen[invite.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[invite.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, invite.FieldDeletedByID)
				fieldSeen[invite.FieldDeletedByID] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[invite.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, invite.FieldOwnerID)
				fieldSeen[invite.FieldOwnerID] = struct{}{}
			}
		case "expires":
			if _, ok := fieldSeen[invite.FieldExpires]; !ok {
				selectedFields = append(selectedFields, invite.FieldExpires)
				fieldSeen[invite.FieldExpires] = struct{}{}
			}
		case "recipient":
			if _, ok := fieldSeen[invite.FieldRecipient]; !ok {
				selectedFields = append(selectedFields, invite.FieldRecipient)
				fieldSeen[invite.FieldRecipient] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[invite.FieldStatus]; !ok {
				selectedFields = append(selectedFields, invite.FieldStatus)
				fieldSeen[invite.FieldStatus] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[invite.FieldRole]; !ok {
				selectedFields = append(selectedFields, invite.FieldRole)
				fieldSeen[invite.FieldRole] = struct{}{}
			}
		case "sendAttempts":
			if _, ok := fieldSeen[invite.FieldSendAttempts]; !ok {
				selectedFields = append(selectedFields, invite.FieldSendAttempts)
				fieldSeen[invite.FieldSendAttempts] = struct{}{}
			}
		case "requestorID":
			if _, ok := fieldSeen[invite.FieldRequestorID]; !ok {
				selectedFields = append(selectedFields, invite.FieldRequestorID)
				fieldSeen[invite.FieldRequestorID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		i.Select(selectedFields...)
	}
	return nil
}

type invitePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []InvitePaginateOption
}

func newInvitePaginateArgs(rv map[string]any) *invitePaginateArgs {
	args := &invitePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*InviteWhereInput); ok {
		args.opts = append(args.opts, WithInviteFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (n *NarrativeQuery) CollectFields(ctx context.Context, satisfies ...string) (*NarrativeQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return n, nil
	}
	if err := n.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return n, nil
}

func (n *NarrativeQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(narrative.Columns))
		selectedFields = []string{narrative.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			n.withCreatedBy = query
			if _, ok := fieldSeen[narrative.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, narrative.FieldCreatedByID)
				fieldSeen[narrative.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			n.withUpdatedBy = query
			if _, ok := fieldSeen[narrative.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, narrative.FieldUpdatedByID)
				fieldSeen[narrative.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			n.withOwner = query
			if _, ok := fieldSeen[narrative.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, narrative.FieldOwnerID)
				fieldSeen[narrative.FieldOwnerID] = struct{}{}
			}

		case "blockedGroups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			n.WithNamedBlockedGroups(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "editors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			n.WithNamedEditors(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "viewers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			n.WithNamedViewers(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "internalPolicy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InternalPolicyClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, internalpolicyImplementors)...); err != nil {
				return err
			}
			n.WithNamedInternalPolicy(alias, func(wq *InternalPolicyQuery) {
				*wq = *query
			})

		case "control":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlImplementors)...); err != nil {
				return err
			}
			n.WithNamedControl(alias, func(wq *ControlQuery) {
				*wq = *query
			})

		case "procedure":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProcedureClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, procedureImplementors)...); err != nil {
				return err
			}
			n.WithNamedProcedure(alias, func(wq *ProcedureQuery) {
				*wq = *query
			})

		case "controlObjective":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlObjectiveClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlobjectiveImplementors)...); err != nil {
				return err
			}
			n.WithNamedControlObjective(alias, func(wq *ControlObjectiveQuery) {
				*wq = *query
			})

		case "programs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			n.WithNamedPrograms(alias, func(wq *ProgramQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[narrative.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, narrative.FieldCreatedAt)
				fieldSeen[narrative.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[narrative.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, narrative.FieldUpdatedAt)
				fieldSeen[narrative.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[narrative.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, narrative.FieldCreatedByID)
				fieldSeen[narrative.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[narrative.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, narrative.FieldUpdatedByID)
				fieldSeen[narrative.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[narrative.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, narrative.FieldDeletedAt)
				fieldSeen[narrative.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[narrative.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, narrative.FieldDeletedByID)
				fieldSeen[narrative.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[narrative.FieldTags]; !ok {
				selectedFields = append(selectedFields, narrative.FieldTags)
				fieldSeen[narrative.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[narrative.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, narrative.FieldOwnerID)
				fieldSeen[narrative.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[narrative.FieldName]; !ok {
				selectedFields = append(selectedFields, narrative.FieldName)
				fieldSeen[narrative.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[narrative.FieldDescription]; !ok {
				selectedFields = append(selectedFields, narrative.FieldDescription)
				fieldSeen[narrative.FieldDescription] = struct{}{}
			}
		case "satisfies":
			if _, ok := fieldSeen[narrative.FieldSatisfies]; !ok {
				selectedFields = append(selectedFields, narrative.FieldSatisfies)
				fieldSeen[narrative.FieldSatisfies] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[narrative.FieldDetails]; !ok {
				selectedFields = append(selectedFields, narrative.FieldDetails)
				fieldSeen[narrative.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		n.Select(selectedFields...)
	}
	return nil
}

type narrativePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []NarrativePaginateOption
}

func newNarrativePaginateArgs(rv map[string]any) *narrativePaginateArgs {
	args := &narrativePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*NarrativeWhereInput); ok {
		args.opts = append(args.opts, WithNarrativeFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (nh *NarrativeHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*NarrativeHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nh, nil
	}
	if err := nh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return nh, nil
}

func (nh *NarrativeHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(narrativehistory.Columns))
		selectedFields = []string{narrativehistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[narrativehistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldHistoryTime)
				fieldSeen[narrativehistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[narrativehistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldRef)
				fieldSeen[narrativehistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[narrativehistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldOperation)
				fieldSeen[narrativehistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[narrativehistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldUpdatedBy)
				fieldSeen[narrativehistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[narrativehistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldCreatedAt)
				fieldSeen[narrativehistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[narrativehistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldUpdatedAt)
				fieldSeen[narrativehistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[narrativehistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldCreatedByID)
				fieldSeen[narrativehistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[narrativehistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldUpdatedByID)
				fieldSeen[narrativehistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[narrativehistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldDeletedAt)
				fieldSeen[narrativehistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[narrativehistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldDeletedByID)
				fieldSeen[narrativehistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[narrativehistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldTags)
				fieldSeen[narrativehistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[narrativehistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldOwnerID)
				fieldSeen[narrativehistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[narrativehistory.FieldName]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldName)
				fieldSeen[narrativehistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[narrativehistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldDescription)
				fieldSeen[narrativehistory.FieldDescription] = struct{}{}
			}
		case "satisfies":
			if _, ok := fieldSeen[narrativehistory.FieldSatisfies]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldSatisfies)
				fieldSeen[narrativehistory.FieldSatisfies] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[narrativehistory.FieldDetails]; !ok {
				selectedFields = append(selectedFields, narrativehistory.FieldDetails)
				fieldSeen[narrativehistory.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		nh.Select(selectedFields...)
	}
	return nil
}

type narrativehistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []NarrativeHistoryPaginateOption
}

func newNarrativeHistoryPaginateArgs(rv map[string]any) *narrativehistoryPaginateArgs {
	args := &narrativehistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*NarrativeHistoryWhereInput); ok {
		args.opts = append(args.opts, WithNarrativeHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (n *NoteQuery) CollectFields(ctx context.Context, satisfies ...string) (*NoteQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return n, nil
	}
	if err := n.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return n, nil
}

func (n *NoteQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(note.Columns))
		selectedFields = []string{note.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			n.withCreatedBy = query
			if _, ok := fieldSeen[note.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, note.FieldCreatedByID)
				fieldSeen[note.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			n.withUpdatedBy = query
			if _, ok := fieldSeen[note.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, note.FieldUpdatedByID)
				fieldSeen[note.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			n.withOwner = query
			if _, ok := fieldSeen[note.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, note.FieldOwnerID)
				fieldSeen[note.FieldOwnerID] = struct{}{}
			}

		case "entity":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, entityImplementors)...); err != nil {
				return err
			}
			n.withEntity = query

		case "subcontrols":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SubcontrolClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, subcontrolImplementors)...); err != nil {
				return err
			}
			n.WithNamedSubcontrols(alias, func(wq *SubcontrolQuery) {
				*wq = *query
			})

		case "program":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			n.WithNamedProgram(alias, func(wq *ProgramQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[note.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, note.FieldCreatedAt)
				fieldSeen[note.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[note.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, note.FieldUpdatedAt)
				fieldSeen[note.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[note.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, note.FieldCreatedByID)
				fieldSeen[note.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[note.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, note.FieldUpdatedByID)
				fieldSeen[note.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[note.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, note.FieldDeletedAt)
				fieldSeen[note.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[note.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, note.FieldDeletedByID)
				fieldSeen[note.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[note.FieldTags]; !ok {
				selectedFields = append(selectedFields, note.FieldTags)
				fieldSeen[note.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[note.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, note.FieldOwnerID)
				fieldSeen[note.FieldOwnerID] = struct{}{}
			}
		case "text":
			if _, ok := fieldSeen[note.FieldText]; !ok {
				selectedFields = append(selectedFields, note.FieldText)
				fieldSeen[note.FieldText] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		n.Select(selectedFields...)
	}
	return nil
}

type notePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []NotePaginateOption
}

func newNotePaginateArgs(rv map[string]any) *notePaginateArgs {
	args := &notePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*NoteWhereInput); ok {
		args.opts = append(args.opts, WithNoteFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (nh *NoteHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*NoteHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nh, nil
	}
	if err := nh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return nh, nil
}

func (nh *NoteHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(notehistory.Columns))
		selectedFields = []string{notehistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[notehistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldHistoryTime)
				fieldSeen[notehistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[notehistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldRef)
				fieldSeen[notehistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[notehistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldOperation)
				fieldSeen[notehistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[notehistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldUpdatedBy)
				fieldSeen[notehistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[notehistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldCreatedAt)
				fieldSeen[notehistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[notehistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldUpdatedAt)
				fieldSeen[notehistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[notehistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldCreatedByID)
				fieldSeen[notehistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[notehistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldUpdatedByID)
				fieldSeen[notehistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[notehistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldDeletedAt)
				fieldSeen[notehistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[notehistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldDeletedByID)
				fieldSeen[notehistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[notehistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldTags)
				fieldSeen[notehistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[notehistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldOwnerID)
				fieldSeen[notehistory.FieldOwnerID] = struct{}{}
			}
		case "text":
			if _, ok := fieldSeen[notehistory.FieldText]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldText)
				fieldSeen[notehistory.FieldText] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		nh.Select(selectedFields...)
	}
	return nil
}

type notehistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []NoteHistoryPaginateOption
}

func newNoteHistoryPaginateArgs(rv map[string]any) *notehistoryPaginateArgs {
	args := &notehistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*NoteHistoryWhereInput); ok {
		args.opts = append(args.opts, WithNoteHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (om *OrgMembershipQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrgMembershipQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return om, nil
	}
	if err := om.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return om, nil
}

func (om *OrgMembershipQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(orgmembership.Columns))
		selectedFields = []string{orgmembership.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: om.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			om.withCreatedBy = query
			if _, ok := fieldSeen[orgmembership.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldCreatedByID)
				fieldSeen[orgmembership.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: om.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			om.withUpdatedBy = query
			if _, ok := fieldSeen[orgmembership.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldUpdatedByID)
				fieldSeen[orgmembership.FieldUpdatedByID] = struct{}{}
			}

		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: om.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			om.withOrganization = query
			if _, ok := fieldSeen[orgmembership.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldOrganizationID)
				fieldSeen[orgmembership.FieldOrganizationID] = struct{}{}
			}

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: om.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			om.withUser = query
			if _, ok := fieldSeen[orgmembership.FieldUserID]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldUserID)
				fieldSeen[orgmembership.FieldUserID] = struct{}{}
			}

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: om.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			om.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[orgmembership.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldCreatedAt)
				fieldSeen[orgmembership.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[orgmembership.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldUpdatedAt)
				fieldSeen[orgmembership.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[orgmembership.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldCreatedByID)
				fieldSeen[orgmembership.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[orgmembership.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldUpdatedByID)
				fieldSeen[orgmembership.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[orgmembership.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldDeletedAt)
				fieldSeen[orgmembership.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[orgmembership.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldDeletedByID)
				fieldSeen[orgmembership.FieldDeletedByID] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[orgmembership.FieldRole]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldRole)
				fieldSeen[orgmembership.FieldRole] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[orgmembership.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldOrganizationID)
				fieldSeen[orgmembership.FieldOrganizationID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[orgmembership.FieldUserID]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldUserID)
				fieldSeen[orgmembership.FieldUserID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		om.Select(selectedFields...)
	}
	return nil
}

type orgmembershipPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrgMembershipPaginateOption
}

func newOrgMembershipPaginateArgs(rv map[string]any) *orgmembershipPaginateArgs {
	args := &orgmembershipPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OrgMembershipWhereInput); ok {
		args.opts = append(args.opts, WithOrgMembershipFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (omh *OrgMembershipHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrgMembershipHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return omh, nil
	}
	if err := omh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return omh, nil
}

func (omh *OrgMembershipHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(orgmembershiphistory.Columns))
		selectedFields = []string{orgmembershiphistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[orgmembershiphistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldHistoryTime)
				fieldSeen[orgmembershiphistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[orgmembershiphistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldRef)
				fieldSeen[orgmembershiphistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[orgmembershiphistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldOperation)
				fieldSeen[orgmembershiphistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[orgmembershiphistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldUpdatedBy)
				fieldSeen[orgmembershiphistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[orgmembershiphistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldCreatedAt)
				fieldSeen[orgmembershiphistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[orgmembershiphistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldUpdatedAt)
				fieldSeen[orgmembershiphistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[orgmembershiphistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldCreatedByID)
				fieldSeen[orgmembershiphistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[orgmembershiphistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldUpdatedByID)
				fieldSeen[orgmembershiphistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[orgmembershiphistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldDeletedAt)
				fieldSeen[orgmembershiphistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[orgmembershiphistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldDeletedByID)
				fieldSeen[orgmembershiphistory.FieldDeletedByID] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[orgmembershiphistory.FieldRole]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldRole)
				fieldSeen[orgmembershiphistory.FieldRole] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[orgmembershiphistory.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldOrganizationID)
				fieldSeen[orgmembershiphistory.FieldOrganizationID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[orgmembershiphistory.FieldUserID]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldUserID)
				fieldSeen[orgmembershiphistory.FieldUserID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		omh.Select(selectedFields...)
	}
	return nil
}

type orgmembershiphistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrgMembershipHistoryPaginateOption
}

func newOrgMembershipHistoryPaginateArgs(rv map[string]any) *orgmembershiphistoryPaginateArgs {
	args := &orgmembershiphistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OrgMembershipHistoryWhereInput); ok {
		args.opts = append(args.opts, WithOrgMembershipHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (os *OrgSubscriptionQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrgSubscriptionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return os, nil
	}
	if err := os.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return os, nil
}

func (os *OrgSubscriptionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(orgsubscription.Columns))
		selectedFields = []string{orgsubscription.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: os.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			os.withCreatedBy = query
			if _, ok := fieldSeen[orgsubscription.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldCreatedByID)
				fieldSeen[orgsubscription.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: os.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			os.withUpdatedBy = query
			if _, ok := fieldSeen[orgsubscription.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldUpdatedByID)
				fieldSeen[orgsubscription.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: os.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			os.withOwner = query
			if _, ok := fieldSeen[orgsubscription.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldOwnerID)
				fieldSeen[orgsubscription.FieldOwnerID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[orgsubscription.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldCreatedAt)
				fieldSeen[orgsubscription.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[orgsubscription.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldUpdatedAt)
				fieldSeen[orgsubscription.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[orgsubscription.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldCreatedByID)
				fieldSeen[orgsubscription.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[orgsubscription.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldUpdatedByID)
				fieldSeen[orgsubscription.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[orgsubscription.FieldTags]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldTags)
				fieldSeen[orgsubscription.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[orgsubscription.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldDeletedAt)
				fieldSeen[orgsubscription.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[orgsubscription.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldDeletedByID)
				fieldSeen[orgsubscription.FieldDeletedByID] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[orgsubscription.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldOwnerID)
				fieldSeen[orgsubscription.FieldOwnerID] = struct{}{}
			}
		case "stripeSubscriptionID":
			if _, ok := fieldSeen[orgsubscription.FieldStripeSubscriptionID]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldStripeSubscriptionID)
				fieldSeen[orgsubscription.FieldStripeSubscriptionID] = struct{}{}
			}
		case "productTier":
			if _, ok := fieldSeen[orgsubscription.FieldProductTier]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldProductTier)
				fieldSeen[orgsubscription.FieldProductTier] = struct{}{}
			}
		case "stripeProductTierID":
			if _, ok := fieldSeen[orgsubscription.FieldStripeProductTierID]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldStripeProductTierID)
				fieldSeen[orgsubscription.FieldStripeProductTierID] = struct{}{}
			}
		case "stripeSubscriptionStatus":
			if _, ok := fieldSeen[orgsubscription.FieldStripeSubscriptionStatus]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldStripeSubscriptionStatus)
				fieldSeen[orgsubscription.FieldStripeSubscriptionStatus] = struct{}{}
			}
		case "active":
			if _, ok := fieldSeen[orgsubscription.FieldActive]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldActive)
				fieldSeen[orgsubscription.FieldActive] = struct{}{}
			}
		case "stripeCustomerID":
			if _, ok := fieldSeen[orgsubscription.FieldStripeCustomerID]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldStripeCustomerID)
				fieldSeen[orgsubscription.FieldStripeCustomerID] = struct{}{}
			}
		case "expiresAt":
			if _, ok := fieldSeen[orgsubscription.FieldExpiresAt]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldExpiresAt)
				fieldSeen[orgsubscription.FieldExpiresAt] = struct{}{}
			}
		case "features":
			if _, ok := fieldSeen[orgsubscription.FieldFeatures]; !ok {
				selectedFields = append(selectedFields, orgsubscription.FieldFeatures)
				fieldSeen[orgsubscription.FieldFeatures] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		os.Select(selectedFields...)
	}
	return nil
}

type orgsubscriptionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrgSubscriptionPaginateOption
}

func newOrgSubscriptionPaginateArgs(rv map[string]any) *orgsubscriptionPaginateArgs {
	args := &orgsubscriptionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OrgSubscriptionWhereInput); ok {
		args.opts = append(args.opts, WithOrgSubscriptionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (osh *OrgSubscriptionHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrgSubscriptionHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return osh, nil
	}
	if err := osh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return osh, nil
}

func (osh *OrgSubscriptionHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(orgsubscriptionhistory.Columns))
		selectedFields = []string{orgsubscriptionhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldHistoryTime)
				fieldSeen[orgsubscriptionhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldRef)
				fieldSeen[orgsubscriptionhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldOperation)
				fieldSeen[orgsubscriptionhistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldUpdatedBy)
				fieldSeen[orgsubscriptionhistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldCreatedAt)
				fieldSeen[orgsubscriptionhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldUpdatedAt)
				fieldSeen[orgsubscriptionhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldCreatedByID)
				fieldSeen[orgsubscriptionhistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldUpdatedByID)
				fieldSeen[orgsubscriptionhistory.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldTags)
				fieldSeen[orgsubscriptionhistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldDeletedAt)
				fieldSeen[orgsubscriptionhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldDeletedByID)
				fieldSeen[orgsubscriptionhistory.FieldDeletedByID] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldOwnerID)
				fieldSeen[orgsubscriptionhistory.FieldOwnerID] = struct{}{}
			}
		case "stripeSubscriptionID":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldStripeSubscriptionID]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldStripeSubscriptionID)
				fieldSeen[orgsubscriptionhistory.FieldStripeSubscriptionID] = struct{}{}
			}
		case "productTier":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldProductTier]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldProductTier)
				fieldSeen[orgsubscriptionhistory.FieldProductTier] = struct{}{}
			}
		case "stripeProductTierID":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldStripeProductTierID]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldStripeProductTierID)
				fieldSeen[orgsubscriptionhistory.FieldStripeProductTierID] = struct{}{}
			}
		case "stripeSubscriptionStatus":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldStripeSubscriptionStatus]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldStripeSubscriptionStatus)
				fieldSeen[orgsubscriptionhistory.FieldStripeSubscriptionStatus] = struct{}{}
			}
		case "active":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldActive]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldActive)
				fieldSeen[orgsubscriptionhistory.FieldActive] = struct{}{}
			}
		case "stripeCustomerID":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldStripeCustomerID]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldStripeCustomerID)
				fieldSeen[orgsubscriptionhistory.FieldStripeCustomerID] = struct{}{}
			}
		case "expiresAt":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldExpiresAt]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldExpiresAt)
				fieldSeen[orgsubscriptionhistory.FieldExpiresAt] = struct{}{}
			}
		case "features":
			if _, ok := fieldSeen[orgsubscriptionhistory.FieldFeatures]; !ok {
				selectedFields = append(selectedFields, orgsubscriptionhistory.FieldFeatures)
				fieldSeen[orgsubscriptionhistory.FieldFeatures] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		osh.Select(selectedFields...)
	}
	return nil
}

type orgsubscriptionhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrgSubscriptionHistoryPaginateOption
}

func newOrgSubscriptionHistoryPaginateArgs(rv map[string]any) *orgsubscriptionhistoryPaginateArgs {
	args := &orgsubscriptionhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OrgSubscriptionHistoryWhereInput); ok {
		args.opts = append(args.opts, WithOrgSubscriptionHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (o *OrganizationQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrganizationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return o, nil
	}
	if err := o.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return o, nil
}

func (o *OrganizationQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(organization.Columns))
		selectedFields = []string{organization.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			o.withCreatedBy = query
			if _, ok := fieldSeen[organization.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, organization.FieldCreatedByID)
				fieldSeen[organization.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			o.withUpdatedBy = query
			if _, ok := fieldSeen[organization.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, organization.FieldUpdatedByID)
				fieldSeen[organization.FieldUpdatedByID] = struct{}{}
			}

		case "controlCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			o.WithNamedControlCreators(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "controlObjectiveCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			o.WithNamedControlObjectiveCreators(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "groupCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			o.WithNamedGroupCreators(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "internalPolicyCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			o.WithNamedInternalPolicyCreators(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "narrativeCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			o.WithNamedNarrativeCreators(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "procedureCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			o.WithNamedProcedureCreators(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "programCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			o.WithNamedProgramCreators(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "riskCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			o.WithNamedRiskCreators(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "templateCreators":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			o.WithNamedTemplateCreators(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "parent":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			o.withParent = query
			if _, ok := fieldSeen[organization.FieldParentOrganizationID]; !ok {
				selectedFields = append(selectedFields, organization.FieldParentOrganizationID)
				fieldSeen[organization.FieldParentOrganizationID] = struct{}{}
			}

		case "children":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: o.config}).Query()
			)
			args := newOrganizationPaginateArgs(fieldArgs(ctx, new(OrganizationWhereInput), path...))
			if err := validateFirstLast(args.first, args.last); err != nil {
				return fmt.Errorf("validate first and last in path %q: %w", path, err)
			}
			pager, err := newOrganizationPager(args.opts, args.last != nil)
			if err != nil {
				return fmt.Errorf("create new pager in path %q: %w", path, err)
			}
			if query, err = pager.applyFilter(query); err != nil {
				return err
			}
			ignoredEdges := !hasCollectedField(ctx, append(path, edgesField)...)
			if hasCollectedField(ctx, append(path, totalCountField)...) || hasCollectedField(ctx, append(path, pageInfoField)...) {
				hasPagination := args.after != nil || args.first != nil || args.before != nil || args.last != nil
				if hasPagination || ignoredEdges {
					query := query.Clone()
					o.loadTotal = append(o.loadTotal, func(ctx context.Context, nodes []*Organization) error {
						ids := make([]driver.Value, len(nodes))
						for i := range nodes {
							ids[i] = nodes[i].ID
						}
						var v []struct {
							NodeID string `sql:"parent_organization_id"`
							Count  int    `sql:"count"`
						}
						query.Where(func(s *sql.Selector) {
							s.Where(sql.InValues(s.C(organization.ChildrenColumn), ids...))
						})
						if err := query.GroupBy(organization.ChildrenColumn).Aggregate(Count()).Scan(ctx, &v); err != nil {
							return err
						}
						m := make(map[string]int, len(v))
						for i := range v {
							m[v[i].NodeID] = v[i].Count
						}
						for i := range nodes {
							n := m[nodes[i].ID]
							if nodes[i].Edges.totalCount[12] == nil {
								nodes[i].Edges.totalCount[12] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[12][alias] = n
						}
						return nil
					})
				} else {
					o.loadTotal = append(o.loadTotal, func(_ context.Context, nodes []*Organization) error {
						for i := range nodes {
							n := len(nodes[i].Edges.Children)
							if nodes[i].Edges.totalCount[12] == nil {
								nodes[i].Edges.totalCount[12] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[12][alias] = n
						}
						return nil
					})
				}
			}
			if ignoredEdges || (args.first != nil && *args.first == 0) || (args.last != nil && *args.last == 0) {
				continue
			}
			if query, err = pager.applyCursors(query, args.after, args.before); err != nil {
				return err
			}
			path = append(path, edgesField, nodeField)
			if field := collectedField(ctx, path...); field != nil {
				if err := query.collectField(ctx, false, opCtx, *field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
					return err
				}
			}
			if limit := paginateLimit(args.first, args.last); limit > 0 {
				if oneNode {
					pager.applyOrder(query.Limit(limit))
				} else {
					modify := entgql.LimitPerRow(organization.ChildrenColumn, limit, pager.orderExpr(query))
					query.modifiers = append(query.modifiers, modify)
				}
			} else {
				query = pager.applyOrder(query)
			}
			o.WithNamedChildren(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "groups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			o.WithNamedGroups(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "templates":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TemplateClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, templateImplementors)...); err != nil {
				return err
			}
			o.WithNamedTemplates(alias, func(wq *TemplateQuery) {
				*wq = *query
			})

		case "integrations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IntegrationClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, integrationImplementors)...); err != nil {
				return err
			}
			o.WithNamedIntegrations(alias, func(wq *IntegrationQuery) {
				*wq = *query
			})

		case "setting":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationSettingClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationsettingImplementors)...); err != nil {
				return err
			}
			o.withSetting = query

		case "documentData":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentDataClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentdataImplementors)...); err != nil {
				return err
			}
			o.WithNamedDocumentData(alias, func(wq *DocumentDataQuery) {
				*wq = *query
			})

		case "orgSubscriptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrgSubscriptionClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, orgsubscriptionImplementors)...); err != nil {
				return err
			}
			o.WithNamedOrgSubscriptions(alias, func(wq *OrgSubscriptionQuery) {
				*wq = *query
			})

		case "personalAccessTokens":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonalAccessTokenClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, personalaccesstokenImplementors)...); err != nil {
				return err
			}
			o.WithNamedPersonalAccessTokens(alias, func(wq *PersonalAccessTokenQuery) {
				*wq = *query
			})

		case "apiTokens":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&APITokenClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, apitokenImplementors)...); err != nil {
				return err
			}
			o.WithNamedAPITokens(alias, func(wq *APITokenQuery) {
				*wq = *query
			})

		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			o.WithNamedUsers(alias, func(wq *UserQuery) {
				*wq = *query
			})

		case "invites":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InviteClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, inviteImplementors)...); err != nil {
				return err
			}
			o.WithNamedInvites(alias, func(wq *InviteQuery) {
				*wq = *query
			})

		case "subscribers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SubscriberClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, subscriberImplementors)...); err != nil {
				return err
			}
			o.WithNamedSubscribers(alias, func(wq *SubscriberQuery) {
				*wq = *query
			})

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			o.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})

		case "secrets":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HushClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, hushImplementors)...); err != nil {
				return err
			}
			o.WithNamedSecrets(alias, func(wq *HushQuery) {
				*wq = *query
			})

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			o.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})

		case "entities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entityImplementors)...); err != nil {
				return err
			}
			o.WithNamedEntities(alias, func(wq *EntityQuery) {
				*wq = *query
			})

		case "entityTypes":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityTypeClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entitytypeImplementors)...); err != nil {
				return err
			}
			o.WithNamedEntityTypes(alias, func(wq *EntityTypeQuery) {
				*wq = *query
			})

		case "contacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ContactClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, contactImplementors)...); err != nil {
				return err
			}
			o.WithNamedContacts(alias, func(wq *ContactQuery) {
				*wq = *query
			})

		case "notes":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NoteClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, noteImplementors)...); err != nil {
				return err
			}
			o.WithNamedNotes(alias, func(wq *NoteQuery) {
				*wq = *query
			})

		case "tasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			o.WithNamedTasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "programs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			o.WithNamedPrograms(alias, func(wq *ProgramQuery) {
				*wq = *query
			})

		case "procedures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProcedureClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, procedureImplementors)...); err != nil {
				return err
			}
			o.WithNamedProcedures(alias, func(wq *ProcedureQuery) {
				*wq = *query
			})

		case "internalPolicies":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InternalPolicyClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, internalpolicyImplementors)...); err != nil {
				return err
			}
			o.WithNamedInternalPolicies(alias, func(wq *InternalPolicyQuery) {
				*wq = *query
			})

		case "risks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RiskClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, riskImplementors)...); err != nil {
				return err
			}
			o.WithNamedRisks(alias, func(wq *RiskQuery) {
				*wq = *query
			})

		case "controlObjectives":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlObjectiveClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlobjectiveImplementors)...); err != nil {
				return err
			}
			o.WithNamedControlObjectives(alias, func(wq *ControlObjectiveQuery) {
				*wq = *query
			})

		case "narratives":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NarrativeClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, narrativeImplementors)...); err != nil {
				return err
			}
			o.WithNamedNarratives(alias, func(wq *NarrativeQuery) {
				*wq = *query
			})

		case "controls":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlImplementors)...); err != nil {
				return err
			}
			o.WithNamedControls(alias, func(wq *ControlQuery) {
				*wq = *query
			})

		case "subcontrols":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SubcontrolClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, subcontrolImplementors)...); err != nil {
				return err
			}
			o.WithNamedSubcontrols(alias, func(wq *SubcontrolQuery) {
				*wq = *query
			})

		case "members":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrgMembershipClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, orgmembershipImplementors)...); err != nil {
				return err
			}
			o.WithNamedMembers(alias, func(wq *OrgMembershipQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[organization.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, organization.FieldCreatedAt)
				fieldSeen[organization.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[organization.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, organization.FieldUpdatedAt)
				fieldSeen[organization.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[organization.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, organization.FieldCreatedByID)
				fieldSeen[organization.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[organization.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, organization.FieldUpdatedByID)
				fieldSeen[organization.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[organization.FieldTags]; !ok {
				selectedFields = append(selectedFields, organization.FieldTags)
				fieldSeen[organization.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[organization.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, organization.FieldDeletedAt)
				fieldSeen[organization.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[organization.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, organization.FieldDeletedByID)
				fieldSeen[organization.FieldDeletedByID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[organization.FieldName]; !ok {
				selectedFields = append(selectedFields, organization.FieldName)
				fieldSeen[organization.FieldName] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[organization.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, organization.FieldDisplayName)
				fieldSeen[organization.FieldDisplayName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[organization.FieldDescription]; !ok {
				selectedFields = append(selectedFields, organization.FieldDescription)
				fieldSeen[organization.FieldDescription] = struct{}{}
			}
		case "personalOrg":
			if _, ok := fieldSeen[organization.FieldPersonalOrg]; !ok {
				selectedFields = append(selectedFields, organization.FieldPersonalOrg)
				fieldSeen[organization.FieldPersonalOrg] = struct{}{}
			}
		case "avatarRemoteURL":
			if _, ok := fieldSeen[organization.FieldAvatarRemoteURL]; !ok {
				selectedFields = append(selectedFields, organization.FieldAvatarRemoteURL)
				fieldSeen[organization.FieldAvatarRemoteURL] = struct{}{}
			}
		case "dedicatedDb":
			if _, ok := fieldSeen[organization.FieldDedicatedDb]; !ok {
				selectedFields = append(selectedFields, organization.FieldDedicatedDb)
				fieldSeen[organization.FieldDedicatedDb] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		o.Select(selectedFields...)
	}
	return nil
}

type organizationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrganizationPaginateOption
}

func newOrganizationPaginateArgs(rv map[string]any) *organizationPaginateArgs {
	args := &organizationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &OrganizationOrder{Field: &OrganizationOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithOrganizationOrder(order))
			}
		case *OrganizationOrder:
			if v != nil {
				args.opts = append(args.opts, WithOrganizationOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*OrganizationWhereInput); ok {
		args.opts = append(args.opts, WithOrganizationFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (oh *OrganizationHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrganizationHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return oh, nil
	}
	if err := oh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return oh, nil
}

func (oh *OrganizationHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(organizationhistory.Columns))
		selectedFields = []string{organizationhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[organizationhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldHistoryTime)
				fieldSeen[organizationhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[organizationhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldRef)
				fieldSeen[organizationhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[organizationhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldOperation)
				fieldSeen[organizationhistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[organizationhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldUpdatedBy)
				fieldSeen[organizationhistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[organizationhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldCreatedAt)
				fieldSeen[organizationhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[organizationhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldUpdatedAt)
				fieldSeen[organizationhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[organizationhistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldCreatedByID)
				fieldSeen[organizationhistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[organizationhistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldUpdatedByID)
				fieldSeen[organizationhistory.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[organizationhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldTags)
				fieldSeen[organizationhistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[organizationhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldDeletedAt)
				fieldSeen[organizationhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[organizationhistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldDeletedByID)
				fieldSeen[organizationhistory.FieldDeletedByID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[organizationhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldName)
				fieldSeen[organizationhistory.FieldName] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[organizationhistory.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldDisplayName)
				fieldSeen[organizationhistory.FieldDisplayName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[organizationhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldDescription)
				fieldSeen[organizationhistory.FieldDescription] = struct{}{}
			}
		case "personalOrg":
			if _, ok := fieldSeen[organizationhistory.FieldPersonalOrg]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldPersonalOrg)
				fieldSeen[organizationhistory.FieldPersonalOrg] = struct{}{}
			}
		case "avatarRemoteURL":
			if _, ok := fieldSeen[organizationhistory.FieldAvatarRemoteURL]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldAvatarRemoteURL)
				fieldSeen[organizationhistory.FieldAvatarRemoteURL] = struct{}{}
			}
		case "dedicatedDb":
			if _, ok := fieldSeen[organizationhistory.FieldDedicatedDb]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldDedicatedDb)
				fieldSeen[organizationhistory.FieldDedicatedDb] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		oh.Select(selectedFields...)
	}
	return nil
}

type organizationhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrganizationHistoryPaginateOption
}

func newOrganizationHistoryPaginateArgs(rv map[string]any) *organizationhistoryPaginateArgs {
	args := &organizationhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &OrganizationHistoryOrder{Field: &OrganizationHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithOrganizationHistoryOrder(order))
			}
		case *OrganizationHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithOrganizationHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*OrganizationHistoryWhereInput); ok {
		args.opts = append(args.opts, WithOrganizationHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (os *OrganizationSettingQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrganizationSettingQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return os, nil
	}
	if err := os.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return os, nil
}

func (os *OrganizationSettingQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(organizationsetting.Columns))
		selectedFields = []string{organizationsetting.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: os.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			os.withCreatedBy = query
			if _, ok := fieldSeen[organizationsetting.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldCreatedByID)
				fieldSeen[organizationsetting.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: os.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			os.withUpdatedBy = query
			if _, ok := fieldSeen[organizationsetting.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldUpdatedByID)
				fieldSeen[organizationsetting.FieldUpdatedByID] = struct{}{}
			}

		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: os.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			os.withOrganization = query
			if _, ok := fieldSeen[organizationsetting.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldOrganizationID)
				fieldSeen[organizationsetting.FieldOrganizationID] = struct{}{}
			}

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: os.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			os.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[organizationsetting.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldCreatedAt)
				fieldSeen[organizationsetting.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[organizationsetting.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldUpdatedAt)
				fieldSeen[organizationsetting.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[organizationsetting.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldCreatedByID)
				fieldSeen[organizationsetting.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[organizationsetting.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldUpdatedByID)
				fieldSeen[organizationsetting.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[organizationsetting.FieldTags]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldTags)
				fieldSeen[organizationsetting.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[organizationsetting.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldDeletedAt)
				fieldSeen[organizationsetting.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[organizationsetting.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldDeletedByID)
				fieldSeen[organizationsetting.FieldDeletedByID] = struct{}{}
			}
		case "domains":
			if _, ok := fieldSeen[organizationsetting.FieldDomains]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldDomains)
				fieldSeen[organizationsetting.FieldDomains] = struct{}{}
			}
		case "billingContact":
			if _, ok := fieldSeen[organizationsetting.FieldBillingContact]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldBillingContact)
				fieldSeen[organizationsetting.FieldBillingContact] = struct{}{}
			}
		case "billingEmail":
			if _, ok := fieldSeen[organizationsetting.FieldBillingEmail]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldBillingEmail)
				fieldSeen[organizationsetting.FieldBillingEmail] = struct{}{}
			}
		case "billingPhone":
			if _, ok := fieldSeen[organizationsetting.FieldBillingPhone]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldBillingPhone)
				fieldSeen[organizationsetting.FieldBillingPhone] = struct{}{}
			}
		case "billingAddress":
			if _, ok := fieldSeen[organizationsetting.FieldBillingAddress]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldBillingAddress)
				fieldSeen[organizationsetting.FieldBillingAddress] = struct{}{}
			}
		case "taxIdentifier":
			if _, ok := fieldSeen[organizationsetting.FieldTaxIdentifier]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldTaxIdentifier)
				fieldSeen[organizationsetting.FieldTaxIdentifier] = struct{}{}
			}
		case "geoLocation":
			if _, ok := fieldSeen[organizationsetting.FieldGeoLocation]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldGeoLocation)
				fieldSeen[organizationsetting.FieldGeoLocation] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[organizationsetting.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldOrganizationID)
				fieldSeen[organizationsetting.FieldOrganizationID] = struct{}{}
			}
		case "stripeID":
			if _, ok := fieldSeen[organizationsetting.FieldStripeID]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldStripeID)
				fieldSeen[organizationsetting.FieldStripeID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		os.Select(selectedFields...)
	}
	return nil
}

type organizationsettingPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrganizationSettingPaginateOption
}

func newOrganizationSettingPaginateArgs(rv map[string]any) *organizationsettingPaginateArgs {
	args := &organizationsettingPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OrganizationSettingWhereInput); ok {
		args.opts = append(args.opts, WithOrganizationSettingFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (osh *OrganizationSettingHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrganizationSettingHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return osh, nil
	}
	if err := osh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return osh, nil
}

func (osh *OrganizationSettingHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(organizationsettinghistory.Columns))
		selectedFields = []string{organizationsettinghistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[organizationsettinghistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldHistoryTime)
				fieldSeen[organizationsettinghistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[organizationsettinghistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldRef)
				fieldSeen[organizationsettinghistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[organizationsettinghistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldOperation)
				fieldSeen[organizationsettinghistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[organizationsettinghistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldUpdatedBy)
				fieldSeen[organizationsettinghistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[organizationsettinghistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldCreatedAt)
				fieldSeen[organizationsettinghistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[organizationsettinghistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldUpdatedAt)
				fieldSeen[organizationsettinghistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[organizationsettinghistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldCreatedByID)
				fieldSeen[organizationsettinghistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[organizationsettinghistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldUpdatedByID)
				fieldSeen[organizationsettinghistory.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[organizationsettinghistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldTags)
				fieldSeen[organizationsettinghistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[organizationsettinghistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldDeletedAt)
				fieldSeen[organizationsettinghistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[organizationsettinghistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldDeletedByID)
				fieldSeen[organizationsettinghistory.FieldDeletedByID] = struct{}{}
			}
		case "domains":
			if _, ok := fieldSeen[organizationsettinghistory.FieldDomains]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldDomains)
				fieldSeen[organizationsettinghistory.FieldDomains] = struct{}{}
			}
		case "billingContact":
			if _, ok := fieldSeen[organizationsettinghistory.FieldBillingContact]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldBillingContact)
				fieldSeen[organizationsettinghistory.FieldBillingContact] = struct{}{}
			}
		case "billingEmail":
			if _, ok := fieldSeen[organizationsettinghistory.FieldBillingEmail]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldBillingEmail)
				fieldSeen[organizationsettinghistory.FieldBillingEmail] = struct{}{}
			}
		case "billingPhone":
			if _, ok := fieldSeen[organizationsettinghistory.FieldBillingPhone]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldBillingPhone)
				fieldSeen[organizationsettinghistory.FieldBillingPhone] = struct{}{}
			}
		case "billingAddress":
			if _, ok := fieldSeen[organizationsettinghistory.FieldBillingAddress]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldBillingAddress)
				fieldSeen[organizationsettinghistory.FieldBillingAddress] = struct{}{}
			}
		case "taxIdentifier":
			if _, ok := fieldSeen[organizationsettinghistory.FieldTaxIdentifier]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldTaxIdentifier)
				fieldSeen[organizationsettinghistory.FieldTaxIdentifier] = struct{}{}
			}
		case "geoLocation":
			if _, ok := fieldSeen[organizationsettinghistory.FieldGeoLocation]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldGeoLocation)
				fieldSeen[organizationsettinghistory.FieldGeoLocation] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[organizationsettinghistory.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldOrganizationID)
				fieldSeen[organizationsettinghistory.FieldOrganizationID] = struct{}{}
			}
		case "stripeID":
			if _, ok := fieldSeen[organizationsettinghistory.FieldStripeID]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldStripeID)
				fieldSeen[organizationsettinghistory.FieldStripeID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		osh.Select(selectedFields...)
	}
	return nil
}

type organizationsettinghistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrganizationSettingHistoryPaginateOption
}

func newOrganizationSettingHistoryPaginateArgs(rv map[string]any) *organizationsettinghistoryPaginateArgs {
	args := &organizationsettinghistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OrganizationSettingHistoryWhereInput); ok {
		args.opts = append(args.opts, WithOrganizationSettingHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pat *PersonalAccessTokenQuery) CollectFields(ctx context.Context, satisfies ...string) (*PersonalAccessTokenQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pat, nil
	}
	if err := pat.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pat, nil
}

func (pat *PersonalAccessTokenQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(personalaccesstoken.Columns))
		selectedFields = []string{personalaccesstoken.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pat.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			pat.withCreatedBy = query
			if _, ok := fieldSeen[personalaccesstoken.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldCreatedByID)
				fieldSeen[personalaccesstoken.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pat.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			pat.withUpdatedBy = query
			if _, ok := fieldSeen[personalaccesstoken.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldUpdatedByID)
				fieldSeen[personalaccesstoken.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pat.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			pat.withOwner = query
			if _, ok := fieldSeen[personalaccesstoken.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldOwnerID)
				fieldSeen[personalaccesstoken.FieldOwnerID] = struct{}{}
			}

		case "organizations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: pat.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			pat.WithNamedOrganizations(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: pat.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			pat.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[personalaccesstoken.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldCreatedAt)
				fieldSeen[personalaccesstoken.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[personalaccesstoken.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldUpdatedAt)
				fieldSeen[personalaccesstoken.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[personalaccesstoken.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldCreatedByID)
				fieldSeen[personalaccesstoken.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[personalaccesstoken.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldUpdatedByID)
				fieldSeen[personalaccesstoken.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[personalaccesstoken.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldDeletedAt)
				fieldSeen[personalaccesstoken.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[personalaccesstoken.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldDeletedByID)
				fieldSeen[personalaccesstoken.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[personalaccesstoken.FieldTags]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldTags)
				fieldSeen[personalaccesstoken.FieldTags] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[personalaccesstoken.FieldName]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldName)
				fieldSeen[personalaccesstoken.FieldName] = struct{}{}
			}
		case "token":
			if _, ok := fieldSeen[personalaccesstoken.FieldToken]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldToken)
				fieldSeen[personalaccesstoken.FieldToken] = struct{}{}
			}
		case "expiresAt":
			if _, ok := fieldSeen[personalaccesstoken.FieldExpiresAt]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldExpiresAt)
				fieldSeen[personalaccesstoken.FieldExpiresAt] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[personalaccesstoken.FieldDescription]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldDescription)
				fieldSeen[personalaccesstoken.FieldDescription] = struct{}{}
			}
		case "scopes":
			if _, ok := fieldSeen[personalaccesstoken.FieldScopes]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldScopes)
				fieldSeen[personalaccesstoken.FieldScopes] = struct{}{}
			}
		case "lastUsedAt":
			if _, ok := fieldSeen[personalaccesstoken.FieldLastUsedAt]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldLastUsedAt)
				fieldSeen[personalaccesstoken.FieldLastUsedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pat.Select(selectedFields...)
	}
	return nil
}

type personalaccesstokenPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PersonalAccessTokenPaginateOption
}

func newPersonalAccessTokenPaginateArgs(rv map[string]any) *personalaccesstokenPaginateArgs {
	args := &personalaccesstokenPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PersonalAccessTokenWhereInput); ok {
		args.opts = append(args.opts, WithPersonalAccessTokenFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pr *ProcedureQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProcedureQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pr, nil
	}
	if err := pr.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pr, nil
}

func (pr *ProcedureQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(procedure.Columns))
		selectedFields = []string{procedure.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			pr.withCreatedBy = query
			if _, ok := fieldSeen[procedure.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, procedure.FieldCreatedByID)
				fieldSeen[procedure.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			pr.withUpdatedBy = query
			if _, ok := fieldSeen[procedure.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, procedure.FieldUpdatedByID)
				fieldSeen[procedure.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			pr.withOwner = query
			if _, ok := fieldSeen[procedure.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, procedure.FieldOwnerID)
				fieldSeen[procedure.FieldOwnerID] = struct{}{}
			}

		case "blockedGroups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			pr.WithNamedBlockedGroups(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "editors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			pr.WithNamedEditors(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "controls":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlImplementors)...); err != nil {
				return err
			}
			pr.WithNamedControls(alias, func(wq *ControlQuery) {
				*wq = *query
			})

		case "internalPolicies":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InternalPolicyClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, internalpolicyImplementors)...); err != nil {
				return err
			}
			pr.WithNamedInternalPolicies(alias, func(wq *InternalPolicyQuery) {
				*wq = *query
			})

		case "narratives":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NarrativeClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, narrativeImplementors)...); err != nil {
				return err
			}
			pr.WithNamedNarratives(alias, func(wq *NarrativeQuery) {
				*wq = *query
			})

		case "risks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RiskClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, riskImplementors)...); err != nil {
				return err
			}
			pr.WithNamedRisks(alias, func(wq *RiskQuery) {
				*wq = *query
			})

		case "tasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			pr.WithNamedTasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "programs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			pr.WithNamedPrograms(alias, func(wq *ProgramQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[procedure.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, procedure.FieldCreatedAt)
				fieldSeen[procedure.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[procedure.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, procedure.FieldUpdatedAt)
				fieldSeen[procedure.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[procedure.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, procedure.FieldCreatedByID)
				fieldSeen[procedure.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[procedure.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, procedure.FieldUpdatedByID)
				fieldSeen[procedure.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[procedure.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, procedure.FieldDeletedAt)
				fieldSeen[procedure.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[procedure.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, procedure.FieldDeletedByID)
				fieldSeen[procedure.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[procedure.FieldTags]; !ok {
				selectedFields = append(selectedFields, procedure.FieldTags)
				fieldSeen[procedure.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[procedure.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, procedure.FieldOwnerID)
				fieldSeen[procedure.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[procedure.FieldName]; !ok {
				selectedFields = append(selectedFields, procedure.FieldName)
				fieldSeen[procedure.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[procedure.FieldDescription]; !ok {
				selectedFields = append(selectedFields, procedure.FieldDescription)
				fieldSeen[procedure.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[procedure.FieldStatus]; !ok {
				selectedFields = append(selectedFields, procedure.FieldStatus)
				fieldSeen[procedure.FieldStatus] = struct{}{}
			}
		case "procedureType":
			if _, ok := fieldSeen[procedure.FieldProcedureType]; !ok {
				selectedFields = append(selectedFields, procedure.FieldProcedureType)
				fieldSeen[procedure.FieldProcedureType] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[procedure.FieldVersion]; !ok {
				selectedFields = append(selectedFields, procedure.FieldVersion)
				fieldSeen[procedure.FieldVersion] = struct{}{}
			}
		case "purposeAndScope":
			if _, ok := fieldSeen[procedure.FieldPurposeAndScope]; !ok {
				selectedFields = append(selectedFields, procedure.FieldPurposeAndScope)
				fieldSeen[procedure.FieldPurposeAndScope] = struct{}{}
			}
		case "background":
			if _, ok := fieldSeen[procedure.FieldBackground]; !ok {
				selectedFields = append(selectedFields, procedure.FieldBackground)
				fieldSeen[procedure.FieldBackground] = struct{}{}
			}
		case "satisfies":
			if _, ok := fieldSeen[procedure.FieldSatisfies]; !ok {
				selectedFields = append(selectedFields, procedure.FieldSatisfies)
				fieldSeen[procedure.FieldSatisfies] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[procedure.FieldDetails]; !ok {
				selectedFields = append(selectedFields, procedure.FieldDetails)
				fieldSeen[procedure.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pr.Select(selectedFields...)
	}
	return nil
}

type procedurePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProcedurePaginateOption
}

func newProcedurePaginateArgs(rv map[string]any) *procedurePaginateArgs {
	args := &procedurePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ProcedureWhereInput); ok {
		args.opts = append(args.opts, WithProcedureFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ph *ProcedureHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProcedureHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ph, nil
	}
	if err := ph.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ph, nil
}

func (ph *ProcedureHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(procedurehistory.Columns))
		selectedFields = []string{procedurehistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[procedurehistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldHistoryTime)
				fieldSeen[procedurehistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[procedurehistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldRef)
				fieldSeen[procedurehistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[procedurehistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldOperation)
				fieldSeen[procedurehistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[procedurehistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldUpdatedBy)
				fieldSeen[procedurehistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[procedurehistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldCreatedAt)
				fieldSeen[procedurehistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[procedurehistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldUpdatedAt)
				fieldSeen[procedurehistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[procedurehistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldCreatedByID)
				fieldSeen[procedurehistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[procedurehistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldUpdatedByID)
				fieldSeen[procedurehistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[procedurehistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldDeletedAt)
				fieldSeen[procedurehistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[procedurehistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldDeletedByID)
				fieldSeen[procedurehistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[procedurehistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldTags)
				fieldSeen[procedurehistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[procedurehistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldOwnerID)
				fieldSeen[procedurehistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[procedurehistory.FieldName]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldName)
				fieldSeen[procedurehistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[procedurehistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldDescription)
				fieldSeen[procedurehistory.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[procedurehistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldStatus)
				fieldSeen[procedurehistory.FieldStatus] = struct{}{}
			}
		case "procedureType":
			if _, ok := fieldSeen[procedurehistory.FieldProcedureType]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldProcedureType)
				fieldSeen[procedurehistory.FieldProcedureType] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[procedurehistory.FieldVersion]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldVersion)
				fieldSeen[procedurehistory.FieldVersion] = struct{}{}
			}
		case "purposeAndScope":
			if _, ok := fieldSeen[procedurehistory.FieldPurposeAndScope]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldPurposeAndScope)
				fieldSeen[procedurehistory.FieldPurposeAndScope] = struct{}{}
			}
		case "background":
			if _, ok := fieldSeen[procedurehistory.FieldBackground]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldBackground)
				fieldSeen[procedurehistory.FieldBackground] = struct{}{}
			}
		case "satisfies":
			if _, ok := fieldSeen[procedurehistory.FieldSatisfies]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldSatisfies)
				fieldSeen[procedurehistory.FieldSatisfies] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[procedurehistory.FieldDetails]; !ok {
				selectedFields = append(selectedFields, procedurehistory.FieldDetails)
				fieldSeen[procedurehistory.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ph.Select(selectedFields...)
	}
	return nil
}

type procedurehistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProcedureHistoryPaginateOption
}

func newProcedureHistoryPaginateArgs(rv map[string]any) *procedurehistoryPaginateArgs {
	args := &procedurehistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ProcedureHistoryWhereInput); ok {
		args.opts = append(args.opts, WithProcedureHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pr *ProgramQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProgramQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pr, nil
	}
	if err := pr.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pr, nil
}

func (pr *ProgramQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(program.Columns))
		selectedFields = []string{program.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			pr.withCreatedBy = query
			if _, ok := fieldSeen[program.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, program.FieldCreatedByID)
				fieldSeen[program.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			pr.withUpdatedBy = query
			if _, ok := fieldSeen[program.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, program.FieldUpdatedByID)
				fieldSeen[program.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			pr.withOwner = query
			if _, ok := fieldSeen[program.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, program.FieldOwnerID)
				fieldSeen[program.FieldOwnerID] = struct{}{}
			}

		case "blockedGroups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			pr.WithNamedBlockedGroups(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "editors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			pr.WithNamedEditors(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "viewers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			pr.WithNamedViewers(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "controls":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlImplementors)...); err != nil {
				return err
			}
			pr.WithNamedControls(alias, func(wq *ControlQuery) {
				*wq = *query
			})

		case "subcontrols":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SubcontrolClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, subcontrolImplementors)...); err != nil {
				return err
			}
			pr.WithNamedSubcontrols(alias, func(wq *SubcontrolQuery) {
				*wq = *query
			})

		case "controlObjectives":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlObjectiveClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlobjectiveImplementors)...); err != nil {
				return err
			}
			pr.WithNamedControlObjectives(alias, func(wq *ControlObjectiveQuery) {
				*wq = *query
			})

		case "internalPolicies":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InternalPolicyClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, internalpolicyImplementors)...); err != nil {
				return err
			}
			pr.WithNamedInternalPolicies(alias, func(wq *InternalPolicyQuery) {
				*wq = *query
			})

		case "procedures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProcedureClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, procedureImplementors)...); err != nil {
				return err
			}
			pr.WithNamedProcedures(alias, func(wq *ProcedureQuery) {
				*wq = *query
			})

		case "risks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RiskClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, riskImplementors)...); err != nil {
				return err
			}
			pr.WithNamedRisks(alias, func(wq *RiskQuery) {
				*wq = *query
			})

		case "tasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			pr.WithNamedTasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "notes":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NoteClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, noteImplementors)...); err != nil {
				return err
			}
			pr.WithNamedNotes(alias, func(wq *NoteQuery) {
				*wq = *query
			})

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			pr.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})

		case "narratives":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NarrativeClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, narrativeImplementors)...); err != nil {
				return err
			}
			pr.WithNamedNarratives(alias, func(wq *NarrativeQuery) {
				*wq = *query
			})

		case "actionPlans":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ActionPlanClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, actionplanImplementors)...); err != nil {
				return err
			}
			pr.WithNamedActionPlans(alias, func(wq *ActionPlanQuery) {
				*wq = *query
			})

		case "standards":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StandardClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, standardImplementors)...); err != nil {
				return err
			}
			pr.WithNamedStandards(alias, func(wq *StandardQuery) {
				*wq = *query
			})

		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			pr.WithNamedUsers(alias, func(wq *UserQuery) {
				*wq = *query
			})

		case "members":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramMembershipClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programmembershipImplementors)...); err != nil {
				return err
			}
			pr.WithNamedMembers(alias, func(wq *ProgramMembershipQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[program.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, program.FieldCreatedAt)
				fieldSeen[program.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[program.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, program.FieldUpdatedAt)
				fieldSeen[program.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[program.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, program.FieldCreatedByID)
				fieldSeen[program.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[program.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, program.FieldUpdatedByID)
				fieldSeen[program.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[program.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, program.FieldDeletedAt)
				fieldSeen[program.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[program.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, program.FieldDeletedByID)
				fieldSeen[program.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[program.FieldTags]; !ok {
				selectedFields = append(selectedFields, program.FieldTags)
				fieldSeen[program.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[program.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, program.FieldOwnerID)
				fieldSeen[program.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[program.FieldName]; !ok {
				selectedFields = append(selectedFields, program.FieldName)
				fieldSeen[program.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[program.FieldDescription]; !ok {
				selectedFields = append(selectedFields, program.FieldDescription)
				fieldSeen[program.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[program.FieldStatus]; !ok {
				selectedFields = append(selectedFields, program.FieldStatus)
				fieldSeen[program.FieldStatus] = struct{}{}
			}
		case "startDate":
			if _, ok := fieldSeen[program.FieldStartDate]; !ok {
				selectedFields = append(selectedFields, program.FieldStartDate)
				fieldSeen[program.FieldStartDate] = struct{}{}
			}
		case "endDate":
			if _, ok := fieldSeen[program.FieldEndDate]; !ok {
				selectedFields = append(selectedFields, program.FieldEndDate)
				fieldSeen[program.FieldEndDate] = struct{}{}
			}
		case "auditorReady":
			if _, ok := fieldSeen[program.FieldAuditorReady]; !ok {
				selectedFields = append(selectedFields, program.FieldAuditorReady)
				fieldSeen[program.FieldAuditorReady] = struct{}{}
			}
		case "auditorWriteComments":
			if _, ok := fieldSeen[program.FieldAuditorWriteComments]; !ok {
				selectedFields = append(selectedFields, program.FieldAuditorWriteComments)
				fieldSeen[program.FieldAuditorWriteComments] = struct{}{}
			}
		case "auditorReadComments":
			if _, ok := fieldSeen[program.FieldAuditorReadComments]; !ok {
				selectedFields = append(selectedFields, program.FieldAuditorReadComments)
				fieldSeen[program.FieldAuditorReadComments] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pr.Select(selectedFields...)
	}
	return nil
}

type programPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProgramPaginateOption
}

func newProgramPaginateArgs(rv map[string]any) *programPaginateArgs {
	args := &programPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ProgramWhereInput); ok {
		args.opts = append(args.opts, WithProgramFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ph *ProgramHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProgramHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ph, nil
	}
	if err := ph.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ph, nil
}

func (ph *ProgramHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(programhistory.Columns))
		selectedFields = []string{programhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[programhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldHistoryTime)
				fieldSeen[programhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[programhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldRef)
				fieldSeen[programhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[programhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldOperation)
				fieldSeen[programhistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[programhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldUpdatedBy)
				fieldSeen[programhistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[programhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldCreatedAt)
				fieldSeen[programhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[programhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldUpdatedAt)
				fieldSeen[programhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[programhistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldCreatedByID)
				fieldSeen[programhistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[programhistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldUpdatedByID)
				fieldSeen[programhistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[programhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldDeletedAt)
				fieldSeen[programhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[programhistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldDeletedByID)
				fieldSeen[programhistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[programhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldTags)
				fieldSeen[programhistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[programhistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldOwnerID)
				fieldSeen[programhistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[programhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldName)
				fieldSeen[programhistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[programhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldDescription)
				fieldSeen[programhistory.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[programhistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldStatus)
				fieldSeen[programhistory.FieldStatus] = struct{}{}
			}
		case "startDate":
			if _, ok := fieldSeen[programhistory.FieldStartDate]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldStartDate)
				fieldSeen[programhistory.FieldStartDate] = struct{}{}
			}
		case "endDate":
			if _, ok := fieldSeen[programhistory.FieldEndDate]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldEndDate)
				fieldSeen[programhistory.FieldEndDate] = struct{}{}
			}
		case "auditorReady":
			if _, ok := fieldSeen[programhistory.FieldAuditorReady]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldAuditorReady)
				fieldSeen[programhistory.FieldAuditorReady] = struct{}{}
			}
		case "auditorWriteComments":
			if _, ok := fieldSeen[programhistory.FieldAuditorWriteComments]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldAuditorWriteComments)
				fieldSeen[programhistory.FieldAuditorWriteComments] = struct{}{}
			}
		case "auditorReadComments":
			if _, ok := fieldSeen[programhistory.FieldAuditorReadComments]; !ok {
				selectedFields = append(selectedFields, programhistory.FieldAuditorReadComments)
				fieldSeen[programhistory.FieldAuditorReadComments] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ph.Select(selectedFields...)
	}
	return nil
}

type programhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProgramHistoryPaginateOption
}

func newProgramHistoryPaginateArgs(rv map[string]any) *programhistoryPaginateArgs {
	args := &programhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ProgramHistoryWhereInput); ok {
		args.opts = append(args.opts, WithProgramHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pm *ProgramMembershipQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProgramMembershipQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pm, nil
	}
	if err := pm.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pm, nil
}

func (pm *ProgramMembershipQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(programmembership.Columns))
		selectedFields = []string{programmembership.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			pm.withCreatedBy = query
			if _, ok := fieldSeen[programmembership.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, programmembership.FieldCreatedByID)
				fieldSeen[programmembership.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			pm.withUpdatedBy = query
			if _, ok := fieldSeen[programmembership.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, programmembership.FieldUpdatedByID)
				fieldSeen[programmembership.FieldUpdatedByID] = struct{}{}
			}

		case "program":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: pm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			pm.withProgram = query
			if _, ok := fieldSeen[programmembership.FieldProgramID]; !ok {
				selectedFields = append(selectedFields, programmembership.FieldProgramID)
				fieldSeen[programmembership.FieldProgramID] = struct{}{}
			}

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			pm.withUser = query
			if _, ok := fieldSeen[programmembership.FieldUserID]; !ok {
				selectedFields = append(selectedFields, programmembership.FieldUserID)
				fieldSeen[programmembership.FieldUserID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[programmembership.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, programmembership.FieldCreatedAt)
				fieldSeen[programmembership.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[programmembership.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, programmembership.FieldUpdatedAt)
				fieldSeen[programmembership.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[programmembership.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, programmembership.FieldCreatedByID)
				fieldSeen[programmembership.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[programmembership.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, programmembership.FieldUpdatedByID)
				fieldSeen[programmembership.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[programmembership.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, programmembership.FieldDeletedAt)
				fieldSeen[programmembership.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[programmembership.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, programmembership.FieldDeletedByID)
				fieldSeen[programmembership.FieldDeletedByID] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[programmembership.FieldRole]; !ok {
				selectedFields = append(selectedFields, programmembership.FieldRole)
				fieldSeen[programmembership.FieldRole] = struct{}{}
			}
		case "programID":
			if _, ok := fieldSeen[programmembership.FieldProgramID]; !ok {
				selectedFields = append(selectedFields, programmembership.FieldProgramID)
				fieldSeen[programmembership.FieldProgramID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[programmembership.FieldUserID]; !ok {
				selectedFields = append(selectedFields, programmembership.FieldUserID)
				fieldSeen[programmembership.FieldUserID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pm.Select(selectedFields...)
	}
	return nil
}

type programmembershipPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProgramMembershipPaginateOption
}

func newProgramMembershipPaginateArgs(rv map[string]any) *programmembershipPaginateArgs {
	args := &programmembershipPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ProgramMembershipWhereInput); ok {
		args.opts = append(args.opts, WithProgramMembershipFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pmh *ProgramMembershipHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProgramMembershipHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pmh, nil
	}
	if err := pmh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pmh, nil
}

func (pmh *ProgramMembershipHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(programmembershiphistory.Columns))
		selectedFields = []string{programmembershiphistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[programmembershiphistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, programmembershiphistory.FieldHistoryTime)
				fieldSeen[programmembershiphistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[programmembershiphistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, programmembershiphistory.FieldRef)
				fieldSeen[programmembershiphistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[programmembershiphistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, programmembershiphistory.FieldOperation)
				fieldSeen[programmembershiphistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[programmembershiphistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, programmembershiphistory.FieldUpdatedBy)
				fieldSeen[programmembershiphistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[programmembershiphistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, programmembershiphistory.FieldCreatedAt)
				fieldSeen[programmembershiphistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[programmembershiphistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, programmembershiphistory.FieldUpdatedAt)
				fieldSeen[programmembershiphistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[programmembershiphistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, programmembershiphistory.FieldCreatedByID)
				fieldSeen[programmembershiphistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[programmembershiphistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, programmembershiphistory.FieldUpdatedByID)
				fieldSeen[programmembershiphistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[programmembershiphistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, programmembershiphistory.FieldDeletedAt)
				fieldSeen[programmembershiphistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[programmembershiphistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, programmembershiphistory.FieldDeletedByID)
				fieldSeen[programmembershiphistory.FieldDeletedByID] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[programmembershiphistory.FieldRole]; !ok {
				selectedFields = append(selectedFields, programmembershiphistory.FieldRole)
				fieldSeen[programmembershiphistory.FieldRole] = struct{}{}
			}
		case "programID":
			if _, ok := fieldSeen[programmembershiphistory.FieldProgramID]; !ok {
				selectedFields = append(selectedFields, programmembershiphistory.FieldProgramID)
				fieldSeen[programmembershiphistory.FieldProgramID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[programmembershiphistory.FieldUserID]; !ok {
				selectedFields = append(selectedFields, programmembershiphistory.FieldUserID)
				fieldSeen[programmembershiphistory.FieldUserID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pmh.Select(selectedFields...)
	}
	return nil
}

type programmembershiphistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProgramMembershipHistoryPaginateOption
}

func newProgramMembershipHistoryPaginateArgs(rv map[string]any) *programmembershiphistoryPaginateArgs {
	args := &programmembershiphistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ProgramMembershipHistoryWhereInput); ok {
		args.opts = append(args.opts, WithProgramMembershipHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (r *RiskQuery) CollectFields(ctx context.Context, satisfies ...string) (*RiskQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return r, nil
	}
	if err := r.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return r, nil
}

func (r *RiskQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(risk.Columns))
		selectedFields = []string{risk.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			r.withCreatedBy = query
			if _, ok := fieldSeen[risk.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, risk.FieldCreatedByID)
				fieldSeen[risk.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			r.withUpdatedBy = query
			if _, ok := fieldSeen[risk.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, risk.FieldUpdatedByID)
				fieldSeen[risk.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			r.withOwner = query
			if _, ok := fieldSeen[risk.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, risk.FieldOwnerID)
				fieldSeen[risk.FieldOwnerID] = struct{}{}
			}

		case "blockedGroups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			r.WithNamedBlockedGroups(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "editors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			r.WithNamedEditors(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "viewers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			r.WithNamedViewers(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "control":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlImplementors)...); err != nil {
				return err
			}
			r.WithNamedControl(alias, func(wq *ControlQuery) {
				*wq = *query
			})

		case "procedure":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProcedureClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, procedureImplementors)...); err != nil {
				return err
			}
			r.WithNamedProcedure(alias, func(wq *ProcedureQuery) {
				*wq = *query
			})

		case "actionPlans":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ActionPlanClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, actionplanImplementors)...); err != nil {
				return err
			}
			r.WithNamedActionPlans(alias, func(wq *ActionPlanQuery) {
				*wq = *query
			})

		case "programs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			r.WithNamedPrograms(alias, func(wq *ProgramQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[risk.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, risk.FieldCreatedAt)
				fieldSeen[risk.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[risk.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, risk.FieldUpdatedAt)
				fieldSeen[risk.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[risk.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, risk.FieldCreatedByID)
				fieldSeen[risk.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[risk.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, risk.FieldUpdatedByID)
				fieldSeen[risk.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[risk.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, risk.FieldDeletedAt)
				fieldSeen[risk.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[risk.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, risk.FieldDeletedByID)
				fieldSeen[risk.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[risk.FieldTags]; !ok {
				selectedFields = append(selectedFields, risk.FieldTags)
				fieldSeen[risk.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[risk.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, risk.FieldOwnerID)
				fieldSeen[risk.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[risk.FieldName]; !ok {
				selectedFields = append(selectedFields, risk.FieldName)
				fieldSeen[risk.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[risk.FieldDescription]; !ok {
				selectedFields = append(selectedFields, risk.FieldDescription)
				fieldSeen[risk.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[risk.FieldStatus]; !ok {
				selectedFields = append(selectedFields, risk.FieldStatus)
				fieldSeen[risk.FieldStatus] = struct{}{}
			}
		case "riskType":
			if _, ok := fieldSeen[risk.FieldRiskType]; !ok {
				selectedFields = append(selectedFields, risk.FieldRiskType)
				fieldSeen[risk.FieldRiskType] = struct{}{}
			}
		case "businessCosts":
			if _, ok := fieldSeen[risk.FieldBusinessCosts]; !ok {
				selectedFields = append(selectedFields, risk.FieldBusinessCosts)
				fieldSeen[risk.FieldBusinessCosts] = struct{}{}
			}
		case "impact":
			if _, ok := fieldSeen[risk.FieldImpact]; !ok {
				selectedFields = append(selectedFields, risk.FieldImpact)
				fieldSeen[risk.FieldImpact] = struct{}{}
			}
		case "likelihood":
			if _, ok := fieldSeen[risk.FieldLikelihood]; !ok {
				selectedFields = append(selectedFields, risk.FieldLikelihood)
				fieldSeen[risk.FieldLikelihood] = struct{}{}
			}
		case "mitigation":
			if _, ok := fieldSeen[risk.FieldMitigation]; !ok {
				selectedFields = append(selectedFields, risk.FieldMitigation)
				fieldSeen[risk.FieldMitigation] = struct{}{}
			}
		case "satisfies":
			if _, ok := fieldSeen[risk.FieldSatisfies]; !ok {
				selectedFields = append(selectedFields, risk.FieldSatisfies)
				fieldSeen[risk.FieldSatisfies] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[risk.FieldDetails]; !ok {
				selectedFields = append(selectedFields, risk.FieldDetails)
				fieldSeen[risk.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		r.Select(selectedFields...)
	}
	return nil
}

type riskPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RiskPaginateOption
}

func newRiskPaginateArgs(rv map[string]any) *riskPaginateArgs {
	args := &riskPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*RiskWhereInput); ok {
		args.opts = append(args.opts, WithRiskFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (rh *RiskHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*RiskHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return rh, nil
	}
	if err := rh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return rh, nil
}

func (rh *RiskHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(riskhistory.Columns))
		selectedFields = []string{riskhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[riskhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldHistoryTime)
				fieldSeen[riskhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[riskhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldRef)
				fieldSeen[riskhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[riskhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldOperation)
				fieldSeen[riskhistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[riskhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldUpdatedBy)
				fieldSeen[riskhistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[riskhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldCreatedAt)
				fieldSeen[riskhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[riskhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldUpdatedAt)
				fieldSeen[riskhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[riskhistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldCreatedByID)
				fieldSeen[riskhistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[riskhistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldUpdatedByID)
				fieldSeen[riskhistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[riskhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldDeletedAt)
				fieldSeen[riskhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[riskhistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldDeletedByID)
				fieldSeen[riskhistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[riskhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldTags)
				fieldSeen[riskhistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[riskhistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldOwnerID)
				fieldSeen[riskhistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[riskhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldName)
				fieldSeen[riskhistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[riskhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldDescription)
				fieldSeen[riskhistory.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[riskhistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldStatus)
				fieldSeen[riskhistory.FieldStatus] = struct{}{}
			}
		case "riskType":
			if _, ok := fieldSeen[riskhistory.FieldRiskType]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldRiskType)
				fieldSeen[riskhistory.FieldRiskType] = struct{}{}
			}
		case "businessCosts":
			if _, ok := fieldSeen[riskhistory.FieldBusinessCosts]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldBusinessCosts)
				fieldSeen[riskhistory.FieldBusinessCosts] = struct{}{}
			}
		case "impact":
			if _, ok := fieldSeen[riskhistory.FieldImpact]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldImpact)
				fieldSeen[riskhistory.FieldImpact] = struct{}{}
			}
		case "likelihood":
			if _, ok := fieldSeen[riskhistory.FieldLikelihood]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldLikelihood)
				fieldSeen[riskhistory.FieldLikelihood] = struct{}{}
			}
		case "mitigation":
			if _, ok := fieldSeen[riskhistory.FieldMitigation]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldMitigation)
				fieldSeen[riskhistory.FieldMitigation] = struct{}{}
			}
		case "satisfies":
			if _, ok := fieldSeen[riskhistory.FieldSatisfies]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldSatisfies)
				fieldSeen[riskhistory.FieldSatisfies] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[riskhistory.FieldDetails]; !ok {
				selectedFields = append(selectedFields, riskhistory.FieldDetails)
				fieldSeen[riskhistory.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		rh.Select(selectedFields...)
	}
	return nil
}

type riskhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RiskHistoryPaginateOption
}

func newRiskHistoryPaginateArgs(rv map[string]any) *riskhistoryPaginateArgs {
	args := &riskhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*RiskHistoryWhereInput); ok {
		args.opts = append(args.opts, WithRiskHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *StandardQuery) CollectFields(ctx context.Context, satisfies ...string) (*StandardQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *StandardQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(standard.Columns))
		selectedFields = []string{standard.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			s.withCreatedBy = query
			if _, ok := fieldSeen[standard.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, standard.FieldCreatedByID)
				fieldSeen[standard.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			s.withUpdatedBy = query
			if _, ok := fieldSeen[standard.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, standard.FieldUpdatedByID)
				fieldSeen[standard.FieldUpdatedByID] = struct{}{}
			}

		case "controlObjectives":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlObjectiveClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlobjectiveImplementors)...); err != nil {
				return err
			}
			s.WithNamedControlObjectives(alias, func(wq *ControlObjectiveQuery) {
				*wq = *query
			})

		case "controls":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlImplementors)...); err != nil {
				return err
			}
			s.WithNamedControls(alias, func(wq *ControlQuery) {
				*wq = *query
			})

		case "procedures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProcedureClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, procedureImplementors)...); err != nil {
				return err
			}
			s.WithNamedProcedures(alias, func(wq *ProcedureQuery) {
				*wq = *query
			})

		case "actionPlans":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ActionPlanClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, actionplanImplementors)...); err != nil {
				return err
			}
			s.WithNamedActionPlans(alias, func(wq *ActionPlanQuery) {
				*wq = *query
			})

		case "programs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			s.WithNamedPrograms(alias, func(wq *ProgramQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[standard.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, standard.FieldCreatedAt)
				fieldSeen[standard.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[standard.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, standard.FieldUpdatedAt)
				fieldSeen[standard.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[standard.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, standard.FieldCreatedByID)
				fieldSeen[standard.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[standard.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, standard.FieldUpdatedByID)
				fieldSeen[standard.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[standard.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, standard.FieldDeletedAt)
				fieldSeen[standard.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[standard.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, standard.FieldDeletedByID)
				fieldSeen[standard.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[standard.FieldTags]; !ok {
				selectedFields = append(selectedFields, standard.FieldTags)
				fieldSeen[standard.FieldTags] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[standard.FieldName]; !ok {
				selectedFields = append(selectedFields, standard.FieldName)
				fieldSeen[standard.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[standard.FieldDescription]; !ok {
				selectedFields = append(selectedFields, standard.FieldDescription)
				fieldSeen[standard.FieldDescription] = struct{}{}
			}
		case "family":
			if _, ok := fieldSeen[standard.FieldFamily]; !ok {
				selectedFields = append(selectedFields, standard.FieldFamily)
				fieldSeen[standard.FieldFamily] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[standard.FieldStatus]; !ok {
				selectedFields = append(selectedFields, standard.FieldStatus)
				fieldSeen[standard.FieldStatus] = struct{}{}
			}
		case "standardType":
			if _, ok := fieldSeen[standard.FieldStandardType]; !ok {
				selectedFields = append(selectedFields, standard.FieldStandardType)
				fieldSeen[standard.FieldStandardType] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[standard.FieldVersion]; !ok {
				selectedFields = append(selectedFields, standard.FieldVersion)
				fieldSeen[standard.FieldVersion] = struct{}{}
			}
		case "purposeAndScope":
			if _, ok := fieldSeen[standard.FieldPurposeAndScope]; !ok {
				selectedFields = append(selectedFields, standard.FieldPurposeAndScope)
				fieldSeen[standard.FieldPurposeAndScope] = struct{}{}
			}
		case "background":
			if _, ok := fieldSeen[standard.FieldBackground]; !ok {
				selectedFields = append(selectedFields, standard.FieldBackground)
				fieldSeen[standard.FieldBackground] = struct{}{}
			}
		case "satisfies":
			if _, ok := fieldSeen[standard.FieldSatisfies]; !ok {
				selectedFields = append(selectedFields, standard.FieldSatisfies)
				fieldSeen[standard.FieldSatisfies] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[standard.FieldDetails]; !ok {
				selectedFields = append(selectedFields, standard.FieldDetails)
				fieldSeen[standard.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type standardPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []StandardPaginateOption
}

func newStandardPaginateArgs(rv map[string]any) *standardPaginateArgs {
	args := &standardPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*StandardWhereInput); ok {
		args.opts = append(args.opts, WithStandardFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sh *StandardHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*StandardHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sh, nil
	}
	if err := sh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sh, nil
}

func (sh *StandardHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(standardhistory.Columns))
		selectedFields = []string{standardhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[standardhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldHistoryTime)
				fieldSeen[standardhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[standardhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldRef)
				fieldSeen[standardhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[standardhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldOperation)
				fieldSeen[standardhistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[standardhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldUpdatedBy)
				fieldSeen[standardhistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[standardhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldCreatedAt)
				fieldSeen[standardhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[standardhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldUpdatedAt)
				fieldSeen[standardhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[standardhistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldCreatedByID)
				fieldSeen[standardhistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[standardhistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldUpdatedByID)
				fieldSeen[standardhistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[standardhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldDeletedAt)
				fieldSeen[standardhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[standardhistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldDeletedByID)
				fieldSeen[standardhistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[standardhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldTags)
				fieldSeen[standardhistory.FieldTags] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[standardhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldName)
				fieldSeen[standardhistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[standardhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldDescription)
				fieldSeen[standardhistory.FieldDescription] = struct{}{}
			}
		case "family":
			if _, ok := fieldSeen[standardhistory.FieldFamily]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldFamily)
				fieldSeen[standardhistory.FieldFamily] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[standardhistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldStatus)
				fieldSeen[standardhistory.FieldStatus] = struct{}{}
			}
		case "standardType":
			if _, ok := fieldSeen[standardhistory.FieldStandardType]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldStandardType)
				fieldSeen[standardhistory.FieldStandardType] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[standardhistory.FieldVersion]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldVersion)
				fieldSeen[standardhistory.FieldVersion] = struct{}{}
			}
		case "purposeAndScope":
			if _, ok := fieldSeen[standardhistory.FieldPurposeAndScope]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldPurposeAndScope)
				fieldSeen[standardhistory.FieldPurposeAndScope] = struct{}{}
			}
		case "background":
			if _, ok := fieldSeen[standardhistory.FieldBackground]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldBackground)
				fieldSeen[standardhistory.FieldBackground] = struct{}{}
			}
		case "satisfies":
			if _, ok := fieldSeen[standardhistory.FieldSatisfies]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldSatisfies)
				fieldSeen[standardhistory.FieldSatisfies] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[standardhistory.FieldDetails]; !ok {
				selectedFields = append(selectedFields, standardhistory.FieldDetails)
				fieldSeen[standardhistory.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sh.Select(selectedFields...)
	}
	return nil
}

type standardhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []StandardHistoryPaginateOption
}

func newStandardHistoryPaginateArgs(rv map[string]any) *standardhistoryPaginateArgs {
	args := &standardhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*StandardHistoryWhereInput); ok {
		args.opts = append(args.opts, WithStandardHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *SubcontrolQuery) CollectFields(ctx context.Context, satisfies ...string) (*SubcontrolQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *SubcontrolQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(subcontrol.Columns))
		selectedFields = []string{subcontrol.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			s.withCreatedBy = query
			if _, ok := fieldSeen[subcontrol.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldCreatedByID)
				fieldSeen[subcontrol.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			s.withUpdatedBy = query
			if _, ok := fieldSeen[subcontrol.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldUpdatedByID)
				fieldSeen[subcontrol.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			s.withOwner = query
			if _, ok := fieldSeen[subcontrol.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldOwnerID)
				fieldSeen[subcontrol.FieldOwnerID] = struct{}{}
			}

		case "controls":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlImplementors)...); err != nil {
				return err
			}
			s.WithNamedControls(alias, func(wq *ControlQuery) {
				*wq = *query
			})

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			s.WithNamedUser(alias, func(wq *UserQuery) {
				*wq = *query
			})

		case "tasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			s.WithNamedTasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "notes":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NoteClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, noteImplementors)...); err != nil {
				return err
			}
			s.withNotes = query

		case "programs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			s.WithNamedPrograms(alias, func(wq *ProgramQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[subcontrol.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldCreatedAt)
				fieldSeen[subcontrol.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[subcontrol.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldUpdatedAt)
				fieldSeen[subcontrol.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[subcontrol.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldCreatedByID)
				fieldSeen[subcontrol.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[subcontrol.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldUpdatedByID)
				fieldSeen[subcontrol.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[subcontrol.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldDeletedAt)
				fieldSeen[subcontrol.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[subcontrol.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldDeletedByID)
				fieldSeen[subcontrol.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[subcontrol.FieldTags]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldTags)
				fieldSeen[subcontrol.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[subcontrol.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldOwnerID)
				fieldSeen[subcontrol.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[subcontrol.FieldName]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldName)
				fieldSeen[subcontrol.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[subcontrol.FieldDescription]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldDescription)
				fieldSeen[subcontrol.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[subcontrol.FieldStatus]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldStatus)
				fieldSeen[subcontrol.FieldStatus] = struct{}{}
			}
		case "subcontrolType":
			if _, ok := fieldSeen[subcontrol.FieldSubcontrolType]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldSubcontrolType)
				fieldSeen[subcontrol.FieldSubcontrolType] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[subcontrol.FieldVersion]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldVersion)
				fieldSeen[subcontrol.FieldVersion] = struct{}{}
			}
		case "subcontrolNumber":
			if _, ok := fieldSeen[subcontrol.FieldSubcontrolNumber]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldSubcontrolNumber)
				fieldSeen[subcontrol.FieldSubcontrolNumber] = struct{}{}
			}
		case "family":
			if _, ok := fieldSeen[subcontrol.FieldFamily]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldFamily)
				fieldSeen[subcontrol.FieldFamily] = struct{}{}
			}
		case "class":
			if _, ok := fieldSeen[subcontrol.FieldClass]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldClass)
				fieldSeen[subcontrol.FieldClass] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[subcontrol.FieldSource]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldSource)
				fieldSeen[subcontrol.FieldSource] = struct{}{}
			}
		case "mappedFrameworks":
			if _, ok := fieldSeen[subcontrol.FieldMappedFrameworks]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldMappedFrameworks)
				fieldSeen[subcontrol.FieldMappedFrameworks] = struct{}{}
			}
		case "implementationEvidence":
			if _, ok := fieldSeen[subcontrol.FieldImplementationEvidence]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldImplementationEvidence)
				fieldSeen[subcontrol.FieldImplementationEvidence] = struct{}{}
			}
		case "implementationStatus":
			if _, ok := fieldSeen[subcontrol.FieldImplementationStatus]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldImplementationStatus)
				fieldSeen[subcontrol.FieldImplementationStatus] = struct{}{}
			}
		case "implementationDate":
			if _, ok := fieldSeen[subcontrol.FieldImplementationDate]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldImplementationDate)
				fieldSeen[subcontrol.FieldImplementationDate] = struct{}{}
			}
		case "implementationVerification":
			if _, ok := fieldSeen[subcontrol.FieldImplementationVerification]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldImplementationVerification)
				fieldSeen[subcontrol.FieldImplementationVerification] = struct{}{}
			}
		case "implementationVerificationDate":
			if _, ok := fieldSeen[subcontrol.FieldImplementationVerificationDate]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldImplementationVerificationDate)
				fieldSeen[subcontrol.FieldImplementationVerificationDate] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[subcontrol.FieldDetails]; !ok {
				selectedFields = append(selectedFields, subcontrol.FieldDetails)
				fieldSeen[subcontrol.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type subcontrolPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SubcontrolPaginateOption
}

func newSubcontrolPaginateArgs(rv map[string]any) *subcontrolPaginateArgs {
	args := &subcontrolPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*SubcontrolWhereInput); ok {
		args.opts = append(args.opts, WithSubcontrolFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sh *SubcontrolHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*SubcontrolHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sh, nil
	}
	if err := sh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sh, nil
}

func (sh *SubcontrolHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(subcontrolhistory.Columns))
		selectedFields = []string{subcontrolhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[subcontrolhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldHistoryTime)
				fieldSeen[subcontrolhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[subcontrolhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldRef)
				fieldSeen[subcontrolhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[subcontrolhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldOperation)
				fieldSeen[subcontrolhistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[subcontrolhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldUpdatedBy)
				fieldSeen[subcontrolhistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[subcontrolhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldCreatedAt)
				fieldSeen[subcontrolhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[subcontrolhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldUpdatedAt)
				fieldSeen[subcontrolhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[subcontrolhistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldCreatedByID)
				fieldSeen[subcontrolhistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[subcontrolhistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldUpdatedByID)
				fieldSeen[subcontrolhistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[subcontrolhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldDeletedAt)
				fieldSeen[subcontrolhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[subcontrolhistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldDeletedByID)
				fieldSeen[subcontrolhistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[subcontrolhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldTags)
				fieldSeen[subcontrolhistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[subcontrolhistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldOwnerID)
				fieldSeen[subcontrolhistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[subcontrolhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldName)
				fieldSeen[subcontrolhistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[subcontrolhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldDescription)
				fieldSeen[subcontrolhistory.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[subcontrolhistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldStatus)
				fieldSeen[subcontrolhistory.FieldStatus] = struct{}{}
			}
		case "subcontrolType":
			if _, ok := fieldSeen[subcontrolhistory.FieldSubcontrolType]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldSubcontrolType)
				fieldSeen[subcontrolhistory.FieldSubcontrolType] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[subcontrolhistory.FieldVersion]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldVersion)
				fieldSeen[subcontrolhistory.FieldVersion] = struct{}{}
			}
		case "subcontrolNumber":
			if _, ok := fieldSeen[subcontrolhistory.FieldSubcontrolNumber]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldSubcontrolNumber)
				fieldSeen[subcontrolhistory.FieldSubcontrolNumber] = struct{}{}
			}
		case "family":
			if _, ok := fieldSeen[subcontrolhistory.FieldFamily]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldFamily)
				fieldSeen[subcontrolhistory.FieldFamily] = struct{}{}
			}
		case "class":
			if _, ok := fieldSeen[subcontrolhistory.FieldClass]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldClass)
				fieldSeen[subcontrolhistory.FieldClass] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[subcontrolhistory.FieldSource]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldSource)
				fieldSeen[subcontrolhistory.FieldSource] = struct{}{}
			}
		case "mappedFrameworks":
			if _, ok := fieldSeen[subcontrolhistory.FieldMappedFrameworks]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldMappedFrameworks)
				fieldSeen[subcontrolhistory.FieldMappedFrameworks] = struct{}{}
			}
		case "implementationEvidence":
			if _, ok := fieldSeen[subcontrolhistory.FieldImplementationEvidence]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldImplementationEvidence)
				fieldSeen[subcontrolhistory.FieldImplementationEvidence] = struct{}{}
			}
		case "implementationStatus":
			if _, ok := fieldSeen[subcontrolhistory.FieldImplementationStatus]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldImplementationStatus)
				fieldSeen[subcontrolhistory.FieldImplementationStatus] = struct{}{}
			}
		case "implementationDate":
			if _, ok := fieldSeen[subcontrolhistory.FieldImplementationDate]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldImplementationDate)
				fieldSeen[subcontrolhistory.FieldImplementationDate] = struct{}{}
			}
		case "implementationVerification":
			if _, ok := fieldSeen[subcontrolhistory.FieldImplementationVerification]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldImplementationVerification)
				fieldSeen[subcontrolhistory.FieldImplementationVerification] = struct{}{}
			}
		case "implementationVerificationDate":
			if _, ok := fieldSeen[subcontrolhistory.FieldImplementationVerificationDate]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldImplementationVerificationDate)
				fieldSeen[subcontrolhistory.FieldImplementationVerificationDate] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[subcontrolhistory.FieldDetails]; !ok {
				selectedFields = append(selectedFields, subcontrolhistory.FieldDetails)
				fieldSeen[subcontrolhistory.FieldDetails] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sh.Select(selectedFields...)
	}
	return nil
}

type subcontrolhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SubcontrolHistoryPaginateOption
}

func newSubcontrolHistoryPaginateArgs(rv map[string]any) *subcontrolhistoryPaginateArgs {
	args := &subcontrolhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*SubcontrolHistoryWhereInput); ok {
		args.opts = append(args.opts, WithSubcontrolHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *SubscriberQuery) CollectFields(ctx context.Context, satisfies ...string) (*SubscriberQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *SubscriberQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(subscriber.Columns))
		selectedFields = []string{subscriber.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			s.withCreatedBy = query
			if _, ok := fieldSeen[subscriber.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldCreatedByID)
				fieldSeen[subscriber.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			s.withUpdatedBy = query
			if _, ok := fieldSeen[subscriber.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldUpdatedByID)
				fieldSeen[subscriber.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			s.withOwner = query
			if _, ok := fieldSeen[subscriber.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldOwnerID)
				fieldSeen[subscriber.FieldOwnerID] = struct{}{}
			}

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			s.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[subscriber.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldCreatedAt)
				fieldSeen[subscriber.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[subscriber.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldUpdatedAt)
				fieldSeen[subscriber.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[subscriber.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldCreatedByID)
				fieldSeen[subscriber.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[subscriber.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldUpdatedByID)
				fieldSeen[subscriber.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[subscriber.FieldTags]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldTags)
				fieldSeen[subscriber.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[subscriber.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldDeletedAt)
				fieldSeen[subscriber.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[subscriber.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldDeletedByID)
				fieldSeen[subscriber.FieldDeletedByID] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[subscriber.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldOwnerID)
				fieldSeen[subscriber.FieldOwnerID] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[subscriber.FieldEmail]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldEmail)
				fieldSeen[subscriber.FieldEmail] = struct{}{}
			}
		case "phoneNumber":
			if _, ok := fieldSeen[subscriber.FieldPhoneNumber]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldPhoneNumber)
				fieldSeen[subscriber.FieldPhoneNumber] = struct{}{}
			}
		case "verifiedEmail":
			if _, ok := fieldSeen[subscriber.FieldVerifiedEmail]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldVerifiedEmail)
				fieldSeen[subscriber.FieldVerifiedEmail] = struct{}{}
			}
		case "verifiedPhone":
			if _, ok := fieldSeen[subscriber.FieldVerifiedPhone]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldVerifiedPhone)
				fieldSeen[subscriber.FieldVerifiedPhone] = struct{}{}
			}
		case "active":
			if _, ok := fieldSeen[subscriber.FieldActive]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldActive)
				fieldSeen[subscriber.FieldActive] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type subscriberPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SubscriberPaginateOption
}

func newSubscriberPaginateArgs(rv map[string]any) *subscriberPaginateArgs {
	args := &subscriberPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*SubscriberWhereInput); ok {
		args.opts = append(args.opts, WithSubscriberFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ts *TFASettingQuery) CollectFields(ctx context.Context, satisfies ...string) (*TFASettingQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ts, nil
	}
	if err := ts.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ts, nil
}

func (ts *TFASettingQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(tfasetting.Columns))
		selectedFields = []string{tfasetting.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ts.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			ts.withCreatedBy = query
			if _, ok := fieldSeen[tfasetting.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldCreatedByID)
				fieldSeen[tfasetting.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ts.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			ts.withUpdatedBy = query
			if _, ok := fieldSeen[tfasetting.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldUpdatedByID)
				fieldSeen[tfasetting.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ts.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			ts.withOwner = query
			if _, ok := fieldSeen[tfasetting.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldOwnerID)
				fieldSeen[tfasetting.FieldOwnerID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[tfasetting.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldCreatedAt)
				fieldSeen[tfasetting.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[tfasetting.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldUpdatedAt)
				fieldSeen[tfasetting.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[tfasetting.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldCreatedByID)
				fieldSeen[tfasetting.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[tfasetting.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldUpdatedByID)
				fieldSeen[tfasetting.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[tfasetting.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldDeletedAt)
				fieldSeen[tfasetting.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[tfasetting.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldDeletedByID)
				fieldSeen[tfasetting.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[tfasetting.FieldTags]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldTags)
				fieldSeen[tfasetting.FieldTags] = struct{}{}
			}
		case "tfaSecret":
			if _, ok := fieldSeen[tfasetting.FieldTfaSecret]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldTfaSecret)
				fieldSeen[tfasetting.FieldTfaSecret] = struct{}{}
			}
		case "verified":
			if _, ok := fieldSeen[tfasetting.FieldVerified]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldVerified)
				fieldSeen[tfasetting.FieldVerified] = struct{}{}
			}
		case "recoveryCodes":
			if _, ok := fieldSeen[tfasetting.FieldRecoveryCodes]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldRecoveryCodes)
				fieldSeen[tfasetting.FieldRecoveryCodes] = struct{}{}
			}
		case "totpAllowed":
			if _, ok := fieldSeen[tfasetting.FieldTotpAllowed]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldTotpAllowed)
				fieldSeen[tfasetting.FieldTotpAllowed] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ts.Select(selectedFields...)
	}
	return nil
}

type tfasettingPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TFASettingPaginateOption
}

func newTFASettingPaginateArgs(rv map[string]any) *tfasettingPaginateArgs {
	args := &tfasettingPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TFASettingWhereInput); ok {
		args.opts = append(args.opts, WithTFASettingFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TaskQuery) CollectFields(ctx context.Context, satisfies ...string) (*TaskQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TaskQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(task.Columns))
		selectedFields = []string{task.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			t.withCreatedBy = query
			if _, ok := fieldSeen[task.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, task.FieldCreatedByID)
				fieldSeen[task.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			t.withUpdatedBy = query
			if _, ok := fieldSeen[task.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, task.FieldUpdatedByID)
				fieldSeen[task.FieldUpdatedByID] = struct{}{}
			}

		case "assigner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			t.withAssigner = query

		case "assignee":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			t.withAssignee = query

		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			t.WithNamedOrganization(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "group":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			t.WithNamedGroup(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "internalPolicy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InternalPolicyClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, internalpolicyImplementors)...); err != nil {
				return err
			}
			t.WithNamedInternalPolicy(alias, func(wq *InternalPolicyQuery) {
				*wq = *query
			})

		case "procedure":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProcedureClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, procedureImplementors)...); err != nil {
				return err
			}
			t.WithNamedProcedure(alias, func(wq *ProcedureQuery) {
				*wq = *query
			})

		case "control":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlImplementors)...); err != nil {
				return err
			}
			t.WithNamedControl(alias, func(wq *ControlQuery) {
				*wq = *query
			})

		case "controlObjective":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ControlObjectiveClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, controlobjectiveImplementors)...); err != nil {
				return err
			}
			t.WithNamedControlObjective(alias, func(wq *ControlObjectiveQuery) {
				*wq = *query
			})

		case "subcontrol":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SubcontrolClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, subcontrolImplementors)...); err != nil {
				return err
			}
			t.WithNamedSubcontrol(alias, func(wq *SubcontrolQuery) {
				*wq = *query
			})

		case "program":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			t.WithNamedProgram(alias, func(wq *ProgramQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[task.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, task.FieldCreatedAt)
				fieldSeen[task.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[task.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, task.FieldUpdatedAt)
				fieldSeen[task.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[task.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, task.FieldCreatedByID)
				fieldSeen[task.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[task.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, task.FieldUpdatedByID)
				fieldSeen[task.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[task.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, task.FieldDeletedAt)
				fieldSeen[task.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[task.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, task.FieldDeletedByID)
				fieldSeen[task.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[task.FieldTags]; !ok {
				selectedFields = append(selectedFields, task.FieldTags)
				fieldSeen[task.FieldTags] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[task.FieldTitle]; !ok {
				selectedFields = append(selectedFields, task.FieldTitle)
				fieldSeen[task.FieldTitle] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[task.FieldDescription]; !ok {
				selectedFields = append(selectedFields, task.FieldDescription)
				fieldSeen[task.FieldDescription] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[task.FieldDetails]; !ok {
				selectedFields = append(selectedFields, task.FieldDetails)
				fieldSeen[task.FieldDetails] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[task.FieldStatus]; !ok {
				selectedFields = append(selectedFields, task.FieldStatus)
				fieldSeen[task.FieldStatus] = struct{}{}
			}
		case "due":
			if _, ok := fieldSeen[task.FieldDue]; !ok {
				selectedFields = append(selectedFields, task.FieldDue)
				fieldSeen[task.FieldDue] = struct{}{}
			}
		case "completed":
			if _, ok := fieldSeen[task.FieldCompleted]; !ok {
				selectedFields = append(selectedFields, task.FieldCompleted)
				fieldSeen[task.FieldCompleted] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type taskPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TaskPaginateOption
}

func newTaskPaginateArgs(rv map[string]any) *taskPaginateArgs {
	args := &taskPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TaskWhereInput); ok {
		args.opts = append(args.opts, WithTaskFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (th *TaskHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*TaskHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return th, nil
	}
	if err := th.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return th, nil
}

func (th *TaskHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(taskhistory.Columns))
		selectedFields = []string{taskhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[taskhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldHistoryTime)
				fieldSeen[taskhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[taskhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldRef)
				fieldSeen[taskhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[taskhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldOperation)
				fieldSeen[taskhistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[taskhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldUpdatedBy)
				fieldSeen[taskhistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[taskhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldCreatedAt)
				fieldSeen[taskhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[taskhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldUpdatedAt)
				fieldSeen[taskhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[taskhistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldCreatedByID)
				fieldSeen[taskhistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[taskhistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldUpdatedByID)
				fieldSeen[taskhistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[taskhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldDeletedAt)
				fieldSeen[taskhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[taskhistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldDeletedByID)
				fieldSeen[taskhistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[taskhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldTags)
				fieldSeen[taskhistory.FieldTags] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[taskhistory.FieldTitle]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldTitle)
				fieldSeen[taskhistory.FieldTitle] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[taskhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldDescription)
				fieldSeen[taskhistory.FieldDescription] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[taskhistory.FieldDetails]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldDetails)
				fieldSeen[taskhistory.FieldDetails] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[taskhistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldStatus)
				fieldSeen[taskhistory.FieldStatus] = struct{}{}
			}
		case "due":
			if _, ok := fieldSeen[taskhistory.FieldDue]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldDue)
				fieldSeen[taskhistory.FieldDue] = struct{}{}
			}
		case "completed":
			if _, ok := fieldSeen[taskhistory.FieldCompleted]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldCompleted)
				fieldSeen[taskhistory.FieldCompleted] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		th.Select(selectedFields...)
	}
	return nil
}

type taskhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TaskHistoryPaginateOption
}

func newTaskHistoryPaginateArgs(rv map[string]any) *taskhistoryPaginateArgs {
	args := &taskhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TaskHistoryWhereInput); ok {
		args.opts = append(args.opts, WithTaskHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TemplateQuery) CollectFields(ctx context.Context, satisfies ...string) (*TemplateQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TemplateQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(template.Columns))
		selectedFields = []string{template.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			t.withCreatedBy = query
			if _, ok := fieldSeen[template.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, template.FieldCreatedByID)
				fieldSeen[template.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			t.withUpdatedBy = query
			if _, ok := fieldSeen[template.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, template.FieldUpdatedByID)
				fieldSeen[template.FieldUpdatedByID] = struct{}{}
			}

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			t.withOwner = query
			if _, ok := fieldSeen[template.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, template.FieldOwnerID)
				fieldSeen[template.FieldOwnerID] = struct{}{}
			}

		case "documents":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentDataClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentdataImplementors)...); err != nil {
				return err
			}
			t.WithNamedDocuments(alias, func(wq *DocumentDataQuery) {
				*wq = *query
			})

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			t.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[template.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, template.FieldCreatedAt)
				fieldSeen[template.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[template.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, template.FieldUpdatedAt)
				fieldSeen[template.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[template.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, template.FieldCreatedByID)
				fieldSeen[template.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[template.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, template.FieldUpdatedByID)
				fieldSeen[template.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[template.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, template.FieldDeletedAt)
				fieldSeen[template.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[template.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, template.FieldDeletedByID)
				fieldSeen[template.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[template.FieldTags]; !ok {
				selectedFields = append(selectedFields, template.FieldTags)
				fieldSeen[template.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[template.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, template.FieldOwnerID)
				fieldSeen[template.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[template.FieldName]; !ok {
				selectedFields = append(selectedFields, template.FieldName)
				fieldSeen[template.FieldName] = struct{}{}
			}
		case "templateType":
			if _, ok := fieldSeen[template.FieldTemplateType]; !ok {
				selectedFields = append(selectedFields, template.FieldTemplateType)
				fieldSeen[template.FieldTemplateType] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[template.FieldDescription]; !ok {
				selectedFields = append(selectedFields, template.FieldDescription)
				fieldSeen[template.FieldDescription] = struct{}{}
			}
		case "jsonconfig":
			if _, ok := fieldSeen[template.FieldJsonconfig]; !ok {
				selectedFields = append(selectedFields, template.FieldJsonconfig)
				fieldSeen[template.FieldJsonconfig] = struct{}{}
			}
		case "uischema":
			if _, ok := fieldSeen[template.FieldUischema]; !ok {
				selectedFields = append(selectedFields, template.FieldUischema)
				fieldSeen[template.FieldUischema] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type templatePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TemplatePaginateOption
}

func newTemplatePaginateArgs(rv map[string]any) *templatePaginateArgs {
	args := &templatePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &TemplateOrder{Field: &TemplateOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithTemplateOrder(order))
			}
		case *TemplateOrder:
			if v != nil {
				args.opts = append(args.opts, WithTemplateOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*TemplateWhereInput); ok {
		args.opts = append(args.opts, WithTemplateFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (th *TemplateHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*TemplateHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return th, nil
	}
	if err := th.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return th, nil
}

func (th *TemplateHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(templatehistory.Columns))
		selectedFields = []string{templatehistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[templatehistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldHistoryTime)
				fieldSeen[templatehistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[templatehistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldRef)
				fieldSeen[templatehistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[templatehistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldOperation)
				fieldSeen[templatehistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[templatehistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldUpdatedBy)
				fieldSeen[templatehistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[templatehistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldCreatedAt)
				fieldSeen[templatehistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[templatehistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldUpdatedAt)
				fieldSeen[templatehistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[templatehistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldCreatedByID)
				fieldSeen[templatehistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[templatehistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldUpdatedByID)
				fieldSeen[templatehistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[templatehistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldDeletedAt)
				fieldSeen[templatehistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[templatehistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldDeletedByID)
				fieldSeen[templatehistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[templatehistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldTags)
				fieldSeen[templatehistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[templatehistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldOwnerID)
				fieldSeen[templatehistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[templatehistory.FieldName]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldName)
				fieldSeen[templatehistory.FieldName] = struct{}{}
			}
		case "templateType":
			if _, ok := fieldSeen[templatehistory.FieldTemplateType]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldTemplateType)
				fieldSeen[templatehistory.FieldTemplateType] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[templatehistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldDescription)
				fieldSeen[templatehistory.FieldDescription] = struct{}{}
			}
		case "jsonconfig":
			if _, ok := fieldSeen[templatehistory.FieldJsonconfig]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldJsonconfig)
				fieldSeen[templatehistory.FieldJsonconfig] = struct{}{}
			}
		case "uischema":
			if _, ok := fieldSeen[templatehistory.FieldUischema]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldUischema)
				fieldSeen[templatehistory.FieldUischema] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		th.Select(selectedFields...)
	}
	return nil
}

type templatehistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TemplateHistoryPaginateOption
}

func newTemplateHistoryPaginateArgs(rv map[string]any) *templatehistoryPaginateArgs {
	args := &templatehistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &TemplateHistoryOrder{Field: &TemplateHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithTemplateHistoryOrder(order))
			}
		case *TemplateHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithTemplateHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*TemplateHistoryWhereInput); ok {
		args.opts = append(args.opts, WithTemplateHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "personalAccessTokens":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonalAccessTokenClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, personalaccesstokenImplementors)...); err != nil {
				return err
			}
			u.WithNamedPersonalAccessTokens(alias, func(wq *PersonalAccessTokenQuery) {
				*wq = *query
			})

		case "tfaSettings":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TFASettingClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, tfasettingImplementors)...); err != nil {
				return err
			}
			u.WithNamedTfaSettings(alias, func(wq *TFASettingQuery) {
				*wq = *query
			})

		case "setting":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserSettingClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, usersettingImplementors)...); err != nil {
				return err
			}
			u.withSetting = query

		case "groups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			u.WithNamedGroups(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "organizations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			u.WithNamedOrganizations(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			u.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})

		case "file":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			u.withFile = query
			if _, ok := fieldSeen[user.FieldAvatarLocalFileID]; !ok {
				selectedFields = append(selectedFields, user.FieldAvatarLocalFileID)
				fieldSeen[user.FieldAvatarLocalFileID] = struct{}{}
			}

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			u.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})

		case "actionPlans":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ActionPlanClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, actionplanImplementors)...); err != nil {
				return err
			}
			u.WithNamedActionPlans(alias, func(wq *ActionPlanQuery) {
				*wq = *query
			})

		case "subcontrols":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SubcontrolClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, subcontrolImplementors)...); err != nil {
				return err
			}
			u.WithNamedSubcontrols(alias, func(wq *SubcontrolQuery) {
				*wq = *query
			})

		case "assignerTasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			u.WithNamedAssignerTasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "assigneeTasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			u.WithNamedAssigneeTasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "programs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programImplementors)...); err != nil {
				return err
			}
			u.WithNamedPrograms(alias, func(wq *ProgramQuery) {
				*wq = *query
			})

		case "groupMemberships":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupMembershipClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupmembershipImplementors)...); err != nil {
				return err
			}
			u.WithNamedGroupMemberships(alias, func(wq *GroupMembershipQuery) {
				*wq = *query
			})

		case "orgMemberships":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrgMembershipClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, orgmembershipImplementors)...); err != nil {
				return err
			}
			u.WithNamedOrgMemberships(alias, func(wq *OrgMembershipQuery) {
				*wq = *query
			})

		case "programMemberships":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProgramMembershipClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, programmembershipImplementors)...); err != nil {
				return err
			}
			u.WithNamedProgramMemberships(alias, func(wq *ProgramMembershipQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[user.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldCreatedAt)
				fieldSeen[user.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[user.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldUpdatedAt)
				fieldSeen[user.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[user.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, user.FieldCreatedByID)
				fieldSeen[user.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[user.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, user.FieldUpdatedByID)
				fieldSeen[user.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[user.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldDeletedAt)
				fieldSeen[user.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[user.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, user.FieldDeletedByID)
				fieldSeen[user.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[user.FieldTags]; !ok {
				selectedFields = append(selectedFields, user.FieldTags)
				fieldSeen[user.FieldTags] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[user.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, user.FieldFirstName)
				fieldSeen[user.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[user.FieldLastName]; !ok {
				selectedFields = append(selectedFields, user.FieldLastName)
				fieldSeen[user.FieldLastName] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[user.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, user.FieldDisplayName)
				fieldSeen[user.FieldDisplayName] = struct{}{}
			}
		case "avatarRemoteURL":
			if _, ok := fieldSeen[user.FieldAvatarRemoteURL]; !ok {
				selectedFields = append(selectedFields, user.FieldAvatarRemoteURL)
				fieldSeen[user.FieldAvatarRemoteURL] = struct{}{}
			}
		case "avatarLocalFile":
			if _, ok := fieldSeen[user.FieldAvatarLocalFile]; !ok {
				selectedFields = append(selectedFields, user.FieldAvatarLocalFile)
				fieldSeen[user.FieldAvatarLocalFile] = struct{}{}
			}
		case "avatarLocalFileID":
			if _, ok := fieldSeen[user.FieldAvatarLocalFileID]; !ok {
				selectedFields = append(selectedFields, user.FieldAvatarLocalFileID)
				fieldSeen[user.FieldAvatarLocalFileID] = struct{}{}
			}
		case "avatarUpdatedAt":
			if _, ok := fieldSeen[user.FieldAvatarUpdatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldAvatarUpdatedAt)
				fieldSeen[user.FieldAvatarUpdatedAt] = struct{}{}
			}
		case "lastSeen":
			if _, ok := fieldSeen[user.FieldLastSeen]; !ok {
				selectedFields = append(selectedFields, user.FieldLastSeen)
				fieldSeen[user.FieldLastSeen] = struct{}{}
			}
		case "sub":
			if _, ok := fieldSeen[user.FieldSub]; !ok {
				selectedFields = append(selectedFields, user.FieldSub)
				fieldSeen[user.FieldSub] = struct{}{}
			}
		case "authProvider":
			if _, ok := fieldSeen[user.FieldAuthProvider]; !ok {
				selectedFields = append(selectedFields, user.FieldAuthProvider)
				fieldSeen[user.FieldAuthProvider] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[user.FieldRole]; !ok {
				selectedFields = append(selectedFields, user.FieldRole)
				fieldSeen[user.FieldRole] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &UserOrder{Field: &UserOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserOrder(order))
			}
		case *UserOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*UserWhereInput); ok {
		args.opts = append(args.opts, WithUserFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (uh *UserHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return uh, nil
	}
	if err := uh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return uh, nil
}

func (uh *UserHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(userhistory.Columns))
		selectedFields = []string{userhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[userhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldHistoryTime)
				fieldSeen[userhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[userhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldRef)
				fieldSeen[userhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[userhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldOperation)
				fieldSeen[userhistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[userhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldUpdatedBy)
				fieldSeen[userhistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[userhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldCreatedAt)
				fieldSeen[userhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[userhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldUpdatedAt)
				fieldSeen[userhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[userhistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldCreatedByID)
				fieldSeen[userhistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[userhistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldUpdatedByID)
				fieldSeen[userhistory.FieldUpdatedByID] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[userhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldDeletedAt)
				fieldSeen[userhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[userhistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldDeletedByID)
				fieldSeen[userhistory.FieldDeletedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[userhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldTags)
				fieldSeen[userhistory.FieldTags] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[userhistory.FieldEmail]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldEmail)
				fieldSeen[userhistory.FieldEmail] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[userhistory.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldFirstName)
				fieldSeen[userhistory.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[userhistory.FieldLastName]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldLastName)
				fieldSeen[userhistory.FieldLastName] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[userhistory.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldDisplayName)
				fieldSeen[userhistory.FieldDisplayName] = struct{}{}
			}
		case "avatarRemoteURL":
			if _, ok := fieldSeen[userhistory.FieldAvatarRemoteURL]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldAvatarRemoteURL)
				fieldSeen[userhistory.FieldAvatarRemoteURL] = struct{}{}
			}
		case "avatarLocalFile":
			if _, ok := fieldSeen[userhistory.FieldAvatarLocalFile]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldAvatarLocalFile)
				fieldSeen[userhistory.FieldAvatarLocalFile] = struct{}{}
			}
		case "avatarLocalFileID":
			if _, ok := fieldSeen[userhistory.FieldAvatarLocalFileID]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldAvatarLocalFileID)
				fieldSeen[userhistory.FieldAvatarLocalFileID] = struct{}{}
			}
		case "avatarUpdatedAt":
			if _, ok := fieldSeen[userhistory.FieldAvatarUpdatedAt]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldAvatarUpdatedAt)
				fieldSeen[userhistory.FieldAvatarUpdatedAt] = struct{}{}
			}
		case "lastSeen":
			if _, ok := fieldSeen[userhistory.FieldLastSeen]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldLastSeen)
				fieldSeen[userhistory.FieldLastSeen] = struct{}{}
			}
		case "sub":
			if _, ok := fieldSeen[userhistory.FieldSub]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldSub)
				fieldSeen[userhistory.FieldSub] = struct{}{}
			}
		case "authProvider":
			if _, ok := fieldSeen[userhistory.FieldAuthProvider]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldAuthProvider)
				fieldSeen[userhistory.FieldAuthProvider] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[userhistory.FieldRole]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldRole)
				fieldSeen[userhistory.FieldRole] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		uh.Select(selectedFields...)
	}
	return nil
}

type userhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserHistoryPaginateOption
}

func newUserHistoryPaginateArgs(rv map[string]any) *userhistoryPaginateArgs {
	args := &userhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &UserHistoryOrder{Field: &UserHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserHistoryOrder(order))
			}
		case *UserHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*UserHistoryWhereInput); ok {
		args.opts = append(args.opts, WithUserHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (us *UserSettingQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserSettingQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return us, nil
	}
	if err := us.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return us, nil
}

func (us *UserSettingQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(usersetting.Columns))
		selectedFields = []string{usersetting.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: us.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			us.withCreatedBy = query
			if _, ok := fieldSeen[usersetting.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldCreatedByID)
				fieldSeen[usersetting.FieldCreatedByID] = struct{}{}
			}

		case "updatedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: us.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			us.withUpdatedBy = query
			if _, ok := fieldSeen[usersetting.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldUpdatedByID)
				fieldSeen[usersetting.FieldUpdatedByID] = struct{}{}
			}

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: us.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			us.withUser = query
			if _, ok := fieldSeen[usersetting.FieldUserID]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldUserID)
				fieldSeen[usersetting.FieldUserID] = struct{}{}
			}

		case "defaultOrg":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: us.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			us.withDefaultOrg = query

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: us.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			us.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[usersetting.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldCreatedAt)
				fieldSeen[usersetting.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[usersetting.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldUpdatedAt)
				fieldSeen[usersetting.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[usersetting.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldCreatedByID)
				fieldSeen[usersetting.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[usersetting.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldUpdatedByID)
				fieldSeen[usersetting.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[usersetting.FieldTags]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldTags)
				fieldSeen[usersetting.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[usersetting.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldDeletedAt)
				fieldSeen[usersetting.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[usersetting.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldDeletedByID)
				fieldSeen[usersetting.FieldDeletedByID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[usersetting.FieldUserID]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldUserID)
				fieldSeen[usersetting.FieldUserID] = struct{}{}
			}
		case "locked":
			if _, ok := fieldSeen[usersetting.FieldLocked]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldLocked)
				fieldSeen[usersetting.FieldLocked] = struct{}{}
			}
		case "silencedAt":
			if _, ok := fieldSeen[usersetting.FieldSilencedAt]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldSilencedAt)
				fieldSeen[usersetting.FieldSilencedAt] = struct{}{}
			}
		case "suspendedAt":
			if _, ok := fieldSeen[usersetting.FieldSuspendedAt]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldSuspendedAt)
				fieldSeen[usersetting.FieldSuspendedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[usersetting.FieldStatus]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldStatus)
				fieldSeen[usersetting.FieldStatus] = struct{}{}
			}
		case "emailConfirmed":
			if _, ok := fieldSeen[usersetting.FieldEmailConfirmed]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldEmailConfirmed)
				fieldSeen[usersetting.FieldEmailConfirmed] = struct{}{}
			}
		case "isWebauthnAllowed":
			if _, ok := fieldSeen[usersetting.FieldIsWebauthnAllowed]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldIsWebauthnAllowed)
				fieldSeen[usersetting.FieldIsWebauthnAllowed] = struct{}{}
			}
		case "isTfaEnabled":
			if _, ok := fieldSeen[usersetting.FieldIsTfaEnabled]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldIsTfaEnabled)
				fieldSeen[usersetting.FieldIsTfaEnabled] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		us.Select(selectedFields...)
	}
	return nil
}

type usersettingPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserSettingPaginateOption
}

func newUserSettingPaginateArgs(rv map[string]any) *usersettingPaginateArgs {
	args := &usersettingPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*UserSettingWhereInput); ok {
		args.opts = append(args.opts, WithUserSettingFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ush *UserSettingHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserSettingHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ush, nil
	}
	if err := ush.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ush, nil
}

func (ush *UserSettingHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(usersettinghistory.Columns))
		selectedFields = []string{usersettinghistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[usersettinghistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldHistoryTime)
				fieldSeen[usersettinghistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[usersettinghistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldRef)
				fieldSeen[usersettinghistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[usersettinghistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldOperation)
				fieldSeen[usersettinghistory.FieldOperation] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[usersettinghistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldUpdatedBy)
				fieldSeen[usersettinghistory.FieldUpdatedBy] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[usersettinghistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldCreatedAt)
				fieldSeen[usersettinghistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[usersettinghistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldUpdatedAt)
				fieldSeen[usersettinghistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdByID":
			if _, ok := fieldSeen[usersettinghistory.FieldCreatedByID]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldCreatedByID)
				fieldSeen[usersettinghistory.FieldCreatedByID] = struct{}{}
			}
		case "updatedByID":
			if _, ok := fieldSeen[usersettinghistory.FieldUpdatedByID]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldUpdatedByID)
				fieldSeen[usersettinghistory.FieldUpdatedByID] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[usersettinghistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldTags)
				fieldSeen[usersettinghistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[usersettinghistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldDeletedAt)
				fieldSeen[usersettinghistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedByID":
			if _, ok := fieldSeen[usersettinghistory.FieldDeletedByID]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldDeletedByID)
				fieldSeen[usersettinghistory.FieldDeletedByID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[usersettinghistory.FieldUserID]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldUserID)
				fieldSeen[usersettinghistory.FieldUserID] = struct{}{}
			}
		case "locked":
			if _, ok := fieldSeen[usersettinghistory.FieldLocked]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldLocked)
				fieldSeen[usersettinghistory.FieldLocked] = struct{}{}
			}
		case "silencedAt":
			if _, ok := fieldSeen[usersettinghistory.FieldSilencedAt]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldSilencedAt)
				fieldSeen[usersettinghistory.FieldSilencedAt] = struct{}{}
			}
		case "suspendedAt":
			if _, ok := fieldSeen[usersettinghistory.FieldSuspendedAt]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldSuspendedAt)
				fieldSeen[usersettinghistory.FieldSuspendedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[usersettinghistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldStatus)
				fieldSeen[usersettinghistory.FieldStatus] = struct{}{}
			}
		case "emailConfirmed":
			if _, ok := fieldSeen[usersettinghistory.FieldEmailConfirmed]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldEmailConfirmed)
				fieldSeen[usersettinghistory.FieldEmailConfirmed] = struct{}{}
			}
		case "isWebauthnAllowed":
			if _, ok := fieldSeen[usersettinghistory.FieldIsWebauthnAllowed]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldIsWebauthnAllowed)
				fieldSeen[usersettinghistory.FieldIsWebauthnAllowed] = struct{}{}
			}
		case "isTfaEnabled":
			if _, ok := fieldSeen[usersettinghistory.FieldIsTfaEnabled]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldIsTfaEnabled)
				fieldSeen[usersettinghistory.FieldIsTfaEnabled] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ush.Select(selectedFields...)
	}
	return nil
}

type usersettinghistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserSettingHistoryPaginateOption
}

func newUserSettingHistoryPaginateArgs(rv map[string]any) *usersettinghistoryPaginateArgs {
	args := &usersettinghistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*UserSettingHistoryWhereInput); ok {
		args.opts = append(args.opts, WithUserSettingHistoryFilter(v.Filter))
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}
