// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"database/sql/driver"
	"fmt"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/theopenlane/core/internal/ent/generated/apitoken"
	"github.com/theopenlane/core/internal/ent/generated/contact"
	"github.com/theopenlane/core/internal/ent/generated/contacthistory"
	"github.com/theopenlane/core/internal/ent/generated/documentdata"
	"github.com/theopenlane/core/internal/ent/generated/documentdatahistory"
	"github.com/theopenlane/core/internal/ent/generated/entitlement"
	"github.com/theopenlane/core/internal/ent/generated/entitlementhistory"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplan"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplanfeature"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplanfeaturehistory"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplanhistory"
	"github.com/theopenlane/core/internal/ent/generated/entity"
	"github.com/theopenlane/core/internal/ent/generated/entityhistory"
	"github.com/theopenlane/core/internal/ent/generated/entitytype"
	"github.com/theopenlane/core/internal/ent/generated/entitytypehistory"
	"github.com/theopenlane/core/internal/ent/generated/event"
	"github.com/theopenlane/core/internal/ent/generated/eventhistory"
	"github.com/theopenlane/core/internal/ent/generated/feature"
	"github.com/theopenlane/core/internal/ent/generated/featurehistory"
	"github.com/theopenlane/core/internal/ent/generated/file"
	"github.com/theopenlane/core/internal/ent/generated/filehistory"
	"github.com/theopenlane/core/internal/ent/generated/group"
	"github.com/theopenlane/core/internal/ent/generated/grouphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupmembership"
	"github.com/theopenlane/core/internal/ent/generated/groupmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupsetting"
	"github.com/theopenlane/core/internal/ent/generated/groupsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/hush"
	"github.com/theopenlane/core/internal/ent/generated/hushhistory"
	"github.com/theopenlane/core/internal/ent/generated/integration"
	"github.com/theopenlane/core/internal/ent/generated/integrationhistory"
	"github.com/theopenlane/core/internal/ent/generated/invite"
	"github.com/theopenlane/core/internal/ent/generated/note"
	"github.com/theopenlane/core/internal/ent/generated/notehistory"
	"github.com/theopenlane/core/internal/ent/generated/oauthprovider"
	"github.com/theopenlane/core/internal/ent/generated/oauthproviderhistory"
	"github.com/theopenlane/core/internal/ent/generated/ohauthtootoken"
	"github.com/theopenlane/core/internal/ent/generated/organization"
	"github.com/theopenlane/core/internal/ent/generated/organizationhistory"
	"github.com/theopenlane/core/internal/ent/generated/organizationsetting"
	"github.com/theopenlane/core/internal/ent/generated/organizationsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/orgmembership"
	"github.com/theopenlane/core/internal/ent/generated/orgmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/personalaccesstoken"
	"github.com/theopenlane/core/internal/ent/generated/subscriber"
	"github.com/theopenlane/core/internal/ent/generated/task"
	"github.com/theopenlane/core/internal/ent/generated/taskhistory"
	"github.com/theopenlane/core/internal/ent/generated/template"
	"github.com/theopenlane/core/internal/ent/generated/templatehistory"
	"github.com/theopenlane/core/internal/ent/generated/tfasetting"
	"github.com/theopenlane/core/internal/ent/generated/user"
	"github.com/theopenlane/core/internal/ent/generated/userhistory"
	"github.com/theopenlane/core/internal/ent/generated/usersetting"
	"github.com/theopenlane/core/internal/ent/generated/usersettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/webhook"
	"github.com/theopenlane/core/internal/ent/generated/webhookhistory"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (at *APITokenQuery) CollectFields(ctx context.Context, satisfies ...string) (*APITokenQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return at, nil
	}
	if err := at.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return at, nil
}

func (at *APITokenQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(apitoken.Columns))
		selectedFields = []string{apitoken.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: at.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			at.withOwner = query
			if _, ok := fieldSeen[apitoken.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldOwnerID)
				fieldSeen[apitoken.FieldOwnerID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[apitoken.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldCreatedAt)
				fieldSeen[apitoken.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[apitoken.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldUpdatedAt)
				fieldSeen[apitoken.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[apitoken.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldCreatedBy)
				fieldSeen[apitoken.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[apitoken.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldUpdatedBy)
				fieldSeen[apitoken.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[apitoken.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldDeletedAt)
				fieldSeen[apitoken.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[apitoken.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldDeletedBy)
				fieldSeen[apitoken.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[apitoken.FieldTags]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldTags)
				fieldSeen[apitoken.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[apitoken.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldOwnerID)
				fieldSeen[apitoken.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[apitoken.FieldName]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldName)
				fieldSeen[apitoken.FieldName] = struct{}{}
			}
		case "token":
			if _, ok := fieldSeen[apitoken.FieldToken]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldToken)
				fieldSeen[apitoken.FieldToken] = struct{}{}
			}
		case "expiresAt":
			if _, ok := fieldSeen[apitoken.FieldExpiresAt]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldExpiresAt)
				fieldSeen[apitoken.FieldExpiresAt] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[apitoken.FieldDescription]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldDescription)
				fieldSeen[apitoken.FieldDescription] = struct{}{}
			}
		case "scopes":
			if _, ok := fieldSeen[apitoken.FieldScopes]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldScopes)
				fieldSeen[apitoken.FieldScopes] = struct{}{}
			}
		case "lastUsedAt":
			if _, ok := fieldSeen[apitoken.FieldLastUsedAt]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldLastUsedAt)
				fieldSeen[apitoken.FieldLastUsedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		at.Select(selectedFields...)
	}
	return nil
}

type apitokenPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []APITokenPaginateOption
}

func newAPITokenPaginateArgs(rv map[string]any) *apitokenPaginateArgs {
	args := &apitokenPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*APITokenWhereInput); ok {
		args.opts = append(args.opts, WithAPITokenFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *ContactQuery) CollectFields(ctx context.Context, satisfies ...string) (*ContactQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *ContactQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(contact.Columns))
		selectedFields = []string{contact.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			c.withOwner = query
			if _, ok := fieldSeen[contact.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, contact.FieldOwnerID)
				fieldSeen[contact.FieldOwnerID] = struct{}{}
			}

		case "entities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entityImplementors)...); err != nil {
				return err
			}
			c.WithNamedEntities(alias, func(wq *EntityQuery) {
				*wq = *query
			})

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			c.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[contact.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, contact.FieldCreatedAt)
				fieldSeen[contact.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[contact.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, contact.FieldUpdatedAt)
				fieldSeen[contact.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[contact.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, contact.FieldCreatedBy)
				fieldSeen[contact.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[contact.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, contact.FieldUpdatedBy)
				fieldSeen[contact.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[contact.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, contact.FieldDeletedAt)
				fieldSeen[contact.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[contact.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, contact.FieldDeletedBy)
				fieldSeen[contact.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[contact.FieldTags]; !ok {
				selectedFields = append(selectedFields, contact.FieldTags)
				fieldSeen[contact.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[contact.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, contact.FieldOwnerID)
				fieldSeen[contact.FieldOwnerID] = struct{}{}
			}
		case "fullName":
			if _, ok := fieldSeen[contact.FieldFullName]; !ok {
				selectedFields = append(selectedFields, contact.FieldFullName)
				fieldSeen[contact.FieldFullName] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[contact.FieldTitle]; !ok {
				selectedFields = append(selectedFields, contact.FieldTitle)
				fieldSeen[contact.FieldTitle] = struct{}{}
			}
		case "company":
			if _, ok := fieldSeen[contact.FieldCompany]; !ok {
				selectedFields = append(selectedFields, contact.FieldCompany)
				fieldSeen[contact.FieldCompany] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[contact.FieldEmail]; !ok {
				selectedFields = append(selectedFields, contact.FieldEmail)
				fieldSeen[contact.FieldEmail] = struct{}{}
			}
		case "phoneNumber":
			if _, ok := fieldSeen[contact.FieldPhoneNumber]; !ok {
				selectedFields = append(selectedFields, contact.FieldPhoneNumber)
				fieldSeen[contact.FieldPhoneNumber] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[contact.FieldAddress]; !ok {
				selectedFields = append(selectedFields, contact.FieldAddress)
				fieldSeen[contact.FieldAddress] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[contact.FieldStatus]; !ok {
				selectedFields = append(selectedFields, contact.FieldStatus)
				fieldSeen[contact.FieldStatus] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type contactPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ContactPaginateOption
}

func newContactPaginateArgs(rv map[string]any) *contactPaginateArgs {
	args := &contactPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ContactWhereInput); ok {
		args.opts = append(args.opts, WithContactFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ch *ContactHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*ContactHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ch, nil
	}
	if err := ch.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ch, nil
}

func (ch *ContactHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(contacthistory.Columns))
		selectedFields = []string{contacthistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[contacthistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldHistoryTime)
				fieldSeen[contacthistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[contacthistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldRef)
				fieldSeen[contacthistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[contacthistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldOperation)
				fieldSeen[contacthistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[contacthistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldCreatedAt)
				fieldSeen[contacthistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[contacthistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldUpdatedAt)
				fieldSeen[contacthistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[contacthistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldCreatedBy)
				fieldSeen[contacthistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[contacthistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldUpdatedBy)
				fieldSeen[contacthistory.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[contacthistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldDeletedAt)
				fieldSeen[contacthistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[contacthistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldDeletedBy)
				fieldSeen[contacthistory.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[contacthistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldTags)
				fieldSeen[contacthistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[contacthistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldOwnerID)
				fieldSeen[contacthistory.FieldOwnerID] = struct{}{}
			}
		case "fullName":
			if _, ok := fieldSeen[contacthistory.FieldFullName]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldFullName)
				fieldSeen[contacthistory.FieldFullName] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[contacthistory.FieldTitle]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldTitle)
				fieldSeen[contacthistory.FieldTitle] = struct{}{}
			}
		case "company":
			if _, ok := fieldSeen[contacthistory.FieldCompany]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldCompany)
				fieldSeen[contacthistory.FieldCompany] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[contacthistory.FieldEmail]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldEmail)
				fieldSeen[contacthistory.FieldEmail] = struct{}{}
			}
		case "phoneNumber":
			if _, ok := fieldSeen[contacthistory.FieldPhoneNumber]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldPhoneNumber)
				fieldSeen[contacthistory.FieldPhoneNumber] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[contacthistory.FieldAddress]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldAddress)
				fieldSeen[contacthistory.FieldAddress] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[contacthistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, contacthistory.FieldStatus)
				fieldSeen[contacthistory.FieldStatus] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ch.Select(selectedFields...)
	}
	return nil
}

type contacthistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ContactHistoryPaginateOption
}

func newContactHistoryPaginateArgs(rv map[string]any) *contacthistoryPaginateArgs {
	args := &contacthistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ContactHistoryWhereInput); ok {
		args.opts = append(args.opts, WithContactHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (dd *DocumentDataQuery) CollectFields(ctx context.Context, satisfies ...string) (*DocumentDataQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return dd, nil
	}
	if err := dd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return dd, nil
}

func (dd *DocumentDataQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(documentdata.Columns))
		selectedFields = []string{documentdata.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: dd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			dd.withOwner = query
			if _, ok := fieldSeen[documentdata.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldOwnerID)
				fieldSeen[documentdata.FieldOwnerID] = struct{}{}
			}

		case "template":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TemplateClient{config: dd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, templateImplementors)...); err != nil {
				return err
			}
			dd.withTemplate = query
			if _, ok := fieldSeen[documentdata.FieldTemplateID]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldTemplateID)
				fieldSeen[documentdata.FieldTemplateID] = struct{}{}
			}

		case "entity":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityClient{config: dd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entityImplementors)...); err != nil {
				return err
			}
			dd.WithNamedEntity(alias, func(wq *EntityQuery) {
				*wq = *query
			})

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: dd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			dd.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[documentdata.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldCreatedAt)
				fieldSeen[documentdata.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[documentdata.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldUpdatedAt)
				fieldSeen[documentdata.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[documentdata.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldCreatedBy)
				fieldSeen[documentdata.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[documentdata.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldUpdatedBy)
				fieldSeen[documentdata.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[documentdata.FieldTags]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldTags)
				fieldSeen[documentdata.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[documentdata.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldDeletedAt)
				fieldSeen[documentdata.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[documentdata.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldDeletedBy)
				fieldSeen[documentdata.FieldDeletedBy] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[documentdata.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldOwnerID)
				fieldSeen[documentdata.FieldOwnerID] = struct{}{}
			}
		case "templateID":
			if _, ok := fieldSeen[documentdata.FieldTemplateID]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldTemplateID)
				fieldSeen[documentdata.FieldTemplateID] = struct{}{}
			}
		case "data":
			if _, ok := fieldSeen[documentdata.FieldData]; !ok {
				selectedFields = append(selectedFields, documentdata.FieldData)
				fieldSeen[documentdata.FieldData] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		dd.Select(selectedFields...)
	}
	return nil
}

type documentdataPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DocumentDataPaginateOption
}

func newDocumentDataPaginateArgs(rv map[string]any) *documentdataPaginateArgs {
	args := &documentdataPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DocumentDataWhereInput); ok {
		args.opts = append(args.opts, WithDocumentDataFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ddh *DocumentDataHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*DocumentDataHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ddh, nil
	}
	if err := ddh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ddh, nil
}

func (ddh *DocumentDataHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(documentdatahistory.Columns))
		selectedFields = []string{documentdatahistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[documentdatahistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldHistoryTime)
				fieldSeen[documentdatahistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[documentdatahistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldRef)
				fieldSeen[documentdatahistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[documentdatahistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldOperation)
				fieldSeen[documentdatahistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[documentdatahistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldCreatedAt)
				fieldSeen[documentdatahistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[documentdatahistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldUpdatedAt)
				fieldSeen[documentdatahistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[documentdatahistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldCreatedBy)
				fieldSeen[documentdatahistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[documentdatahistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldUpdatedBy)
				fieldSeen[documentdatahistory.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[documentdatahistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldTags)
				fieldSeen[documentdatahistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[documentdatahistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldDeletedAt)
				fieldSeen[documentdatahistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[documentdatahistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldDeletedBy)
				fieldSeen[documentdatahistory.FieldDeletedBy] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[documentdatahistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldOwnerID)
				fieldSeen[documentdatahistory.FieldOwnerID] = struct{}{}
			}
		case "templateID":
			if _, ok := fieldSeen[documentdatahistory.FieldTemplateID]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldTemplateID)
				fieldSeen[documentdatahistory.FieldTemplateID] = struct{}{}
			}
		case "data":
			if _, ok := fieldSeen[documentdatahistory.FieldData]; !ok {
				selectedFields = append(selectedFields, documentdatahistory.FieldData)
				fieldSeen[documentdatahistory.FieldData] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ddh.Select(selectedFields...)
	}
	return nil
}

type documentdatahistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DocumentDataHistoryPaginateOption
}

func newDocumentDataHistoryPaginateArgs(rv map[string]any) *documentdatahistoryPaginateArgs {
	args := &documentdatahistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DocumentDataHistoryWhereInput); ok {
		args.opts = append(args.opts, WithDocumentDataHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (e *EntitlementQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntitlementQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return e, nil
	}
	if err := e.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return e, nil
}

func (e *EntitlementQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(entitlement.Columns))
		selectedFields = []string{entitlement.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			e.withOwner = query
			if _, ok := fieldSeen[entitlement.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldOwnerID)
				fieldSeen[entitlement.FieldOwnerID] = struct{}{}
			}

		case "plan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntitlementPlanClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, entitlementplanImplementors)...); err != nil {
				return err
			}
			e.withPlan = query
			if _, ok := fieldSeen[entitlement.FieldPlanID]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldPlanID)
				fieldSeen[entitlement.FieldPlanID] = struct{}{}
			}

		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			e.withOrganization = query
			if _, ok := fieldSeen[entitlement.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldOrganizationID)
				fieldSeen[entitlement.FieldOrganizationID] = struct{}{}
			}

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			e.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[entitlement.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldCreatedAt)
				fieldSeen[entitlement.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[entitlement.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldUpdatedAt)
				fieldSeen[entitlement.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[entitlement.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldCreatedBy)
				fieldSeen[entitlement.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[entitlement.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldUpdatedBy)
				fieldSeen[entitlement.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[entitlement.FieldTags]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldTags)
				fieldSeen[entitlement.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[entitlement.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldDeletedAt)
				fieldSeen[entitlement.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[entitlement.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldDeletedBy)
				fieldSeen[entitlement.FieldDeletedBy] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[entitlement.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldOwnerID)
				fieldSeen[entitlement.FieldOwnerID] = struct{}{}
			}
		case "planID":
			if _, ok := fieldSeen[entitlement.FieldPlanID]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldPlanID)
				fieldSeen[entitlement.FieldPlanID] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[entitlement.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldOrganizationID)
				fieldSeen[entitlement.FieldOrganizationID] = struct{}{}
			}
		case "externalCustomerID":
			if _, ok := fieldSeen[entitlement.FieldExternalCustomerID]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldExternalCustomerID)
				fieldSeen[entitlement.FieldExternalCustomerID] = struct{}{}
			}
		case "externalSubscriptionID":
			if _, ok := fieldSeen[entitlement.FieldExternalSubscriptionID]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldExternalSubscriptionID)
				fieldSeen[entitlement.FieldExternalSubscriptionID] = struct{}{}
			}
		case "expires":
			if _, ok := fieldSeen[entitlement.FieldExpires]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldExpires)
				fieldSeen[entitlement.FieldExpires] = struct{}{}
			}
		case "expiresAt":
			if _, ok := fieldSeen[entitlement.FieldExpiresAt]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldExpiresAt)
				fieldSeen[entitlement.FieldExpiresAt] = struct{}{}
			}
		case "cancelled":
			if _, ok := fieldSeen[entitlement.FieldCancelled]; !ok {
				selectedFields = append(selectedFields, entitlement.FieldCancelled)
				fieldSeen[entitlement.FieldCancelled] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		e.Select(selectedFields...)
	}
	return nil
}

type entitlementPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntitlementPaginateOption
}

func newEntitlementPaginateArgs(rv map[string]any) *entitlementPaginateArgs {
	args := &entitlementPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*EntitlementWhereInput); ok {
		args.opts = append(args.opts, WithEntitlementFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (eh *EntitlementHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntitlementHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return eh, nil
	}
	if err := eh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return eh, nil
}

func (eh *EntitlementHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(entitlementhistory.Columns))
		selectedFields = []string{entitlementhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[entitlementhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldHistoryTime)
				fieldSeen[entitlementhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[entitlementhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldRef)
				fieldSeen[entitlementhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[entitlementhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldOperation)
				fieldSeen[entitlementhistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[entitlementhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldCreatedAt)
				fieldSeen[entitlementhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[entitlementhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldUpdatedAt)
				fieldSeen[entitlementhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[entitlementhistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldCreatedBy)
				fieldSeen[entitlementhistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[entitlementhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldUpdatedBy)
				fieldSeen[entitlementhistory.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[entitlementhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldTags)
				fieldSeen[entitlementhistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[entitlementhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldDeletedAt)
				fieldSeen[entitlementhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[entitlementhistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldDeletedBy)
				fieldSeen[entitlementhistory.FieldDeletedBy] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[entitlementhistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldOwnerID)
				fieldSeen[entitlementhistory.FieldOwnerID] = struct{}{}
			}
		case "planID":
			if _, ok := fieldSeen[entitlementhistory.FieldPlanID]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldPlanID)
				fieldSeen[entitlementhistory.FieldPlanID] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[entitlementhistory.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldOrganizationID)
				fieldSeen[entitlementhistory.FieldOrganizationID] = struct{}{}
			}
		case "externalCustomerID":
			if _, ok := fieldSeen[entitlementhistory.FieldExternalCustomerID]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldExternalCustomerID)
				fieldSeen[entitlementhistory.FieldExternalCustomerID] = struct{}{}
			}
		case "externalSubscriptionID":
			if _, ok := fieldSeen[entitlementhistory.FieldExternalSubscriptionID]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldExternalSubscriptionID)
				fieldSeen[entitlementhistory.FieldExternalSubscriptionID] = struct{}{}
			}
		case "expires":
			if _, ok := fieldSeen[entitlementhistory.FieldExpires]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldExpires)
				fieldSeen[entitlementhistory.FieldExpires] = struct{}{}
			}
		case "expiresAt":
			if _, ok := fieldSeen[entitlementhistory.FieldExpiresAt]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldExpiresAt)
				fieldSeen[entitlementhistory.FieldExpiresAt] = struct{}{}
			}
		case "cancelled":
			if _, ok := fieldSeen[entitlementhistory.FieldCancelled]; !ok {
				selectedFields = append(selectedFields, entitlementhistory.FieldCancelled)
				fieldSeen[entitlementhistory.FieldCancelled] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		eh.Select(selectedFields...)
	}
	return nil
}

type entitlementhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntitlementHistoryPaginateOption
}

func newEntitlementHistoryPaginateArgs(rv map[string]any) *entitlementhistoryPaginateArgs {
	args := &entitlementhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*EntitlementHistoryWhereInput); ok {
		args.opts = append(args.opts, WithEntitlementHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ep *EntitlementPlanQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntitlementPlanQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ep, nil
	}
	if err := ep.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ep, nil
}

func (ep *EntitlementPlanQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(entitlementplan.Columns))
		selectedFields = []string{entitlementplan.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: ep.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			ep.withOwner = query
			if _, ok := fieldSeen[entitlementplan.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entitlementplan.FieldOwnerID)
				fieldSeen[entitlementplan.FieldOwnerID] = struct{}{}
			}

		case "entitlements":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntitlementClient{config: ep.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entitlementImplementors)...); err != nil {
				return err
			}
			ep.WithNamedEntitlements(alias, func(wq *EntitlementQuery) {
				*wq = *query
			})

		case "baseFeatures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FeatureClient{config: ep.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, featureImplementors)...); err != nil {
				return err
			}
			ep.WithNamedBaseFeatures(alias, func(wq *FeatureQuery) {
				*wq = *query
			})

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: ep.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			ep.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})

		case "features":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntitlementPlanFeatureClient{config: ep.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entitlementplanfeatureImplementors)...); err != nil {
				return err
			}
			ep.WithNamedFeatures(alias, func(wq *EntitlementPlanFeatureQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[entitlementplan.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, entitlementplan.FieldCreatedAt)
				fieldSeen[entitlementplan.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[entitlementplan.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, entitlementplan.FieldUpdatedAt)
				fieldSeen[entitlementplan.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[entitlementplan.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, entitlementplan.FieldCreatedBy)
				fieldSeen[entitlementplan.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[entitlementplan.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, entitlementplan.FieldUpdatedBy)
				fieldSeen[entitlementplan.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[entitlementplan.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, entitlementplan.FieldDeletedAt)
				fieldSeen[entitlementplan.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[entitlementplan.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, entitlementplan.FieldDeletedBy)
				fieldSeen[entitlementplan.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[entitlementplan.FieldTags]; !ok {
				selectedFields = append(selectedFields, entitlementplan.FieldTags)
				fieldSeen[entitlementplan.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[entitlementplan.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entitlementplan.FieldOwnerID)
				fieldSeen[entitlementplan.FieldOwnerID] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[entitlementplan.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, entitlementplan.FieldDisplayName)
				fieldSeen[entitlementplan.FieldDisplayName] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[entitlementplan.FieldName]; !ok {
				selectedFields = append(selectedFields, entitlementplan.FieldName)
				fieldSeen[entitlementplan.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[entitlementplan.FieldDescription]; !ok {
				selectedFields = append(selectedFields, entitlementplan.FieldDescription)
				fieldSeen[entitlementplan.FieldDescription] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[entitlementplan.FieldVersion]; !ok {
				selectedFields = append(selectedFields, entitlementplan.FieldVersion)
				fieldSeen[entitlementplan.FieldVersion] = struct{}{}
			}
		case "metadata":
			if _, ok := fieldSeen[entitlementplan.FieldMetadata]; !ok {
				selectedFields = append(selectedFields, entitlementplan.FieldMetadata)
				fieldSeen[entitlementplan.FieldMetadata] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ep.Select(selectedFields...)
	}
	return nil
}

type entitlementplanPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntitlementPlanPaginateOption
}

func newEntitlementPlanPaginateArgs(rv map[string]any) *entitlementplanPaginateArgs {
	args := &entitlementplanPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*EntitlementPlanWhereInput); ok {
		args.opts = append(args.opts, WithEntitlementPlanFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (epf *EntitlementPlanFeatureQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntitlementPlanFeatureQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return epf, nil
	}
	if err := epf.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return epf, nil
}

func (epf *EntitlementPlanFeatureQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(entitlementplanfeature.Columns))
		selectedFields = []string{entitlementplanfeature.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: epf.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			epf.withOwner = query
			if _, ok := fieldSeen[entitlementplanfeature.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeature.FieldOwnerID)
				fieldSeen[entitlementplanfeature.FieldOwnerID] = struct{}{}
			}

		case "plan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntitlementPlanClient{config: epf.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, entitlementplanImplementors)...); err != nil {
				return err
			}
			epf.withPlan = query
			if _, ok := fieldSeen[entitlementplanfeature.FieldPlanID]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeature.FieldPlanID)
				fieldSeen[entitlementplanfeature.FieldPlanID] = struct{}{}
			}

		case "feature":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FeatureClient{config: epf.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, featureImplementors)...); err != nil {
				return err
			}
			epf.withFeature = query
			if _, ok := fieldSeen[entitlementplanfeature.FieldFeatureID]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeature.FieldFeatureID)
				fieldSeen[entitlementplanfeature.FieldFeatureID] = struct{}{}
			}

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: epf.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			epf.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[entitlementplanfeature.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeature.FieldCreatedAt)
				fieldSeen[entitlementplanfeature.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[entitlementplanfeature.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeature.FieldUpdatedAt)
				fieldSeen[entitlementplanfeature.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[entitlementplanfeature.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeature.FieldCreatedBy)
				fieldSeen[entitlementplanfeature.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[entitlementplanfeature.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeature.FieldUpdatedBy)
				fieldSeen[entitlementplanfeature.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[entitlementplanfeature.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeature.FieldDeletedAt)
				fieldSeen[entitlementplanfeature.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[entitlementplanfeature.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeature.FieldDeletedBy)
				fieldSeen[entitlementplanfeature.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[entitlementplanfeature.FieldTags]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeature.FieldTags)
				fieldSeen[entitlementplanfeature.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[entitlementplanfeature.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeature.FieldOwnerID)
				fieldSeen[entitlementplanfeature.FieldOwnerID] = struct{}{}
			}
		case "metadata":
			if _, ok := fieldSeen[entitlementplanfeature.FieldMetadata]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeature.FieldMetadata)
				fieldSeen[entitlementplanfeature.FieldMetadata] = struct{}{}
			}
		case "planID":
			if _, ok := fieldSeen[entitlementplanfeature.FieldPlanID]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeature.FieldPlanID)
				fieldSeen[entitlementplanfeature.FieldPlanID] = struct{}{}
			}
		case "featureID":
			if _, ok := fieldSeen[entitlementplanfeature.FieldFeatureID]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeature.FieldFeatureID)
				fieldSeen[entitlementplanfeature.FieldFeatureID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		epf.Select(selectedFields...)
	}
	return nil
}

type entitlementplanfeaturePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntitlementPlanFeaturePaginateOption
}

func newEntitlementPlanFeaturePaginateArgs(rv map[string]any) *entitlementplanfeaturePaginateArgs {
	args := &entitlementplanfeaturePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*EntitlementPlanFeatureWhereInput); ok {
		args.opts = append(args.opts, WithEntitlementPlanFeatureFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (epfh *EntitlementPlanFeatureHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntitlementPlanFeatureHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return epfh, nil
	}
	if err := epfh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return epfh, nil
}

func (epfh *EntitlementPlanFeatureHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(entitlementplanfeaturehistory.Columns))
		selectedFields = []string{entitlementplanfeaturehistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[entitlementplanfeaturehistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeaturehistory.FieldHistoryTime)
				fieldSeen[entitlementplanfeaturehistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[entitlementplanfeaturehistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeaturehistory.FieldRef)
				fieldSeen[entitlementplanfeaturehistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[entitlementplanfeaturehistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeaturehistory.FieldOperation)
				fieldSeen[entitlementplanfeaturehistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[entitlementplanfeaturehistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeaturehistory.FieldCreatedAt)
				fieldSeen[entitlementplanfeaturehistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[entitlementplanfeaturehistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeaturehistory.FieldUpdatedAt)
				fieldSeen[entitlementplanfeaturehistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[entitlementplanfeaturehistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeaturehistory.FieldCreatedBy)
				fieldSeen[entitlementplanfeaturehistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[entitlementplanfeaturehistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeaturehistory.FieldUpdatedBy)
				fieldSeen[entitlementplanfeaturehistory.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[entitlementplanfeaturehistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeaturehistory.FieldDeletedAt)
				fieldSeen[entitlementplanfeaturehistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[entitlementplanfeaturehistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeaturehistory.FieldDeletedBy)
				fieldSeen[entitlementplanfeaturehistory.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[entitlementplanfeaturehistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeaturehistory.FieldTags)
				fieldSeen[entitlementplanfeaturehistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[entitlementplanfeaturehistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeaturehistory.FieldOwnerID)
				fieldSeen[entitlementplanfeaturehistory.FieldOwnerID] = struct{}{}
			}
		case "metadata":
			if _, ok := fieldSeen[entitlementplanfeaturehistory.FieldMetadata]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeaturehistory.FieldMetadata)
				fieldSeen[entitlementplanfeaturehistory.FieldMetadata] = struct{}{}
			}
		case "planID":
			if _, ok := fieldSeen[entitlementplanfeaturehistory.FieldPlanID]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeaturehistory.FieldPlanID)
				fieldSeen[entitlementplanfeaturehistory.FieldPlanID] = struct{}{}
			}
		case "featureID":
			if _, ok := fieldSeen[entitlementplanfeaturehistory.FieldFeatureID]; !ok {
				selectedFields = append(selectedFields, entitlementplanfeaturehistory.FieldFeatureID)
				fieldSeen[entitlementplanfeaturehistory.FieldFeatureID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		epfh.Select(selectedFields...)
	}
	return nil
}

type entitlementplanfeaturehistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntitlementPlanFeatureHistoryPaginateOption
}

func newEntitlementPlanFeatureHistoryPaginateArgs(rv map[string]any) *entitlementplanfeaturehistoryPaginateArgs {
	args := &entitlementplanfeaturehistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*EntitlementPlanFeatureHistoryWhereInput); ok {
		args.opts = append(args.opts, WithEntitlementPlanFeatureHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (eph *EntitlementPlanHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntitlementPlanHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return eph, nil
	}
	if err := eph.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return eph, nil
}

func (eph *EntitlementPlanHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(entitlementplanhistory.Columns))
		selectedFields = []string{entitlementplanhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[entitlementplanhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldHistoryTime)
				fieldSeen[entitlementplanhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[entitlementplanhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldRef)
				fieldSeen[entitlementplanhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[entitlementplanhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldOperation)
				fieldSeen[entitlementplanhistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[entitlementplanhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldCreatedAt)
				fieldSeen[entitlementplanhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[entitlementplanhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldUpdatedAt)
				fieldSeen[entitlementplanhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[entitlementplanhistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldCreatedBy)
				fieldSeen[entitlementplanhistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[entitlementplanhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldUpdatedBy)
				fieldSeen[entitlementplanhistory.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[entitlementplanhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldDeletedAt)
				fieldSeen[entitlementplanhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[entitlementplanhistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldDeletedBy)
				fieldSeen[entitlementplanhistory.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[entitlementplanhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldTags)
				fieldSeen[entitlementplanhistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[entitlementplanhistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldOwnerID)
				fieldSeen[entitlementplanhistory.FieldOwnerID] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[entitlementplanhistory.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldDisplayName)
				fieldSeen[entitlementplanhistory.FieldDisplayName] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[entitlementplanhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldName)
				fieldSeen[entitlementplanhistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[entitlementplanhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldDescription)
				fieldSeen[entitlementplanhistory.FieldDescription] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[entitlementplanhistory.FieldVersion]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldVersion)
				fieldSeen[entitlementplanhistory.FieldVersion] = struct{}{}
			}
		case "metadata":
			if _, ok := fieldSeen[entitlementplanhistory.FieldMetadata]; !ok {
				selectedFields = append(selectedFields, entitlementplanhistory.FieldMetadata)
				fieldSeen[entitlementplanhistory.FieldMetadata] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		eph.Select(selectedFields...)
	}
	return nil
}

type entitlementplanhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntitlementPlanHistoryPaginateOption
}

func newEntitlementPlanHistoryPaginateArgs(rv map[string]any) *entitlementplanhistoryPaginateArgs {
	args := &entitlementplanhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*EntitlementPlanHistoryWhereInput); ok {
		args.opts = append(args.opts, WithEntitlementPlanHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (e *EntityQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntityQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return e, nil
	}
	if err := e.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return e, nil
}

func (e *EntityQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(entity.Columns))
		selectedFields = []string{entity.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			e.withOwner = query
			if _, ok := fieldSeen[entity.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entity.FieldOwnerID)
				fieldSeen[entity.FieldOwnerID] = struct{}{}
			}

		case "contacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ContactClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, contactImplementors)...); err != nil {
				return err
			}
			e.WithNamedContacts(alias, func(wq *ContactQuery) {
				*wq = *query
			})

		case "documents":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentDataClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentdataImplementors)...); err != nil {
				return err
			}
			e.WithNamedDocuments(alias, func(wq *DocumentDataQuery) {
				*wq = *query
			})

		case "notes":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NoteClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, noteImplementors)...); err != nil {
				return err
			}
			e.WithNamedNotes(alias, func(wq *NoteQuery) {
				*wq = *query
			})

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			e.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})

		case "entityType":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityTypeClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, entitytypeImplementors)...); err != nil {
				return err
			}
			e.withEntityType = query
			if _, ok := fieldSeen[entity.FieldEntityTypeID]; !ok {
				selectedFields = append(selectedFields, entity.FieldEntityTypeID)
				fieldSeen[entity.FieldEntityTypeID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[entity.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, entity.FieldCreatedAt)
				fieldSeen[entity.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[entity.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, entity.FieldUpdatedAt)
				fieldSeen[entity.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[entity.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, entity.FieldCreatedBy)
				fieldSeen[entity.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[entity.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, entity.FieldUpdatedBy)
				fieldSeen[entity.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[entity.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, entity.FieldDeletedAt)
				fieldSeen[entity.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[entity.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, entity.FieldDeletedBy)
				fieldSeen[entity.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[entity.FieldTags]; !ok {
				selectedFields = append(selectedFields, entity.FieldTags)
				fieldSeen[entity.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[entity.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entity.FieldOwnerID)
				fieldSeen[entity.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[entity.FieldName]; !ok {
				selectedFields = append(selectedFields, entity.FieldName)
				fieldSeen[entity.FieldName] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[entity.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, entity.FieldDisplayName)
				fieldSeen[entity.FieldDisplayName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[entity.FieldDescription]; !ok {
				selectedFields = append(selectedFields, entity.FieldDescription)
				fieldSeen[entity.FieldDescription] = struct{}{}
			}
		case "domains":
			if _, ok := fieldSeen[entity.FieldDomains]; !ok {
				selectedFields = append(selectedFields, entity.FieldDomains)
				fieldSeen[entity.FieldDomains] = struct{}{}
			}
		case "entityTypeID":
			if _, ok := fieldSeen[entity.FieldEntityTypeID]; !ok {
				selectedFields = append(selectedFields, entity.FieldEntityTypeID)
				fieldSeen[entity.FieldEntityTypeID] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[entity.FieldStatus]; !ok {
				selectedFields = append(selectedFields, entity.FieldStatus)
				fieldSeen[entity.FieldStatus] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		e.Select(selectedFields...)
	}
	return nil
}

type entityPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntityPaginateOption
}

func newEntityPaginateArgs(rv map[string]any) *entityPaginateArgs {
	args := &entityPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &EntityOrder{Field: &EntityOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithEntityOrder(order))
			}
		case *EntityOrder:
			if v != nil {
				args.opts = append(args.opts, WithEntityOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*EntityWhereInput); ok {
		args.opts = append(args.opts, WithEntityFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (eh *EntityHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntityHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return eh, nil
	}
	if err := eh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return eh, nil
}

func (eh *EntityHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(entityhistory.Columns))
		selectedFields = []string{entityhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[entityhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldHistoryTime)
				fieldSeen[entityhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[entityhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldRef)
				fieldSeen[entityhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[entityhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldOperation)
				fieldSeen[entityhistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[entityhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldCreatedAt)
				fieldSeen[entityhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[entityhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldUpdatedAt)
				fieldSeen[entityhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[entityhistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldCreatedBy)
				fieldSeen[entityhistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[entityhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldUpdatedBy)
				fieldSeen[entityhistory.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[entityhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldDeletedAt)
				fieldSeen[entityhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[entityhistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldDeletedBy)
				fieldSeen[entityhistory.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[entityhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldTags)
				fieldSeen[entityhistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[entityhistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldOwnerID)
				fieldSeen[entityhistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[entityhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldName)
				fieldSeen[entityhistory.FieldName] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[entityhistory.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldDisplayName)
				fieldSeen[entityhistory.FieldDisplayName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[entityhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldDescription)
				fieldSeen[entityhistory.FieldDescription] = struct{}{}
			}
		case "domains":
			if _, ok := fieldSeen[entityhistory.FieldDomains]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldDomains)
				fieldSeen[entityhistory.FieldDomains] = struct{}{}
			}
		case "entityTypeID":
			if _, ok := fieldSeen[entityhistory.FieldEntityTypeID]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldEntityTypeID)
				fieldSeen[entityhistory.FieldEntityTypeID] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[entityhistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, entityhistory.FieldStatus)
				fieldSeen[entityhistory.FieldStatus] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		eh.Select(selectedFields...)
	}
	return nil
}

type entityhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntityHistoryPaginateOption
}

func newEntityHistoryPaginateArgs(rv map[string]any) *entityhistoryPaginateArgs {
	args := &entityhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &EntityHistoryOrder{Field: &EntityHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithEntityHistoryOrder(order))
			}
		case *EntityHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithEntityHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*EntityHistoryWhereInput); ok {
		args.opts = append(args.opts, WithEntityHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (et *EntityTypeQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntityTypeQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return et, nil
	}
	if err := et.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return et, nil
}

func (et *EntityTypeQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(entitytype.Columns))
		selectedFields = []string{entitytype.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: et.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			et.withOwner = query
			if _, ok := fieldSeen[entitytype.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldOwnerID)
				fieldSeen[entitytype.FieldOwnerID] = struct{}{}
			}

		case "entities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityClient{config: et.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entityImplementors)...); err != nil {
				return err
			}
			et.WithNamedEntities(alias, func(wq *EntityQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[entitytype.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldCreatedAt)
				fieldSeen[entitytype.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[entitytype.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldUpdatedAt)
				fieldSeen[entitytype.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[entitytype.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldCreatedBy)
				fieldSeen[entitytype.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[entitytype.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldUpdatedBy)
				fieldSeen[entitytype.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[entitytype.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldDeletedAt)
				fieldSeen[entitytype.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[entitytype.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldDeletedBy)
				fieldSeen[entitytype.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[entitytype.FieldTags]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldTags)
				fieldSeen[entitytype.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[entitytype.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldOwnerID)
				fieldSeen[entitytype.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[entitytype.FieldName]; !ok {
				selectedFields = append(selectedFields, entitytype.FieldName)
				fieldSeen[entitytype.FieldName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		et.Select(selectedFields...)
	}
	return nil
}

type entitytypePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntityTypePaginateOption
}

func newEntityTypePaginateArgs(rv map[string]any) *entitytypePaginateArgs {
	args := &entitytypePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &EntityTypeOrder{Field: &EntityTypeOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithEntityTypeOrder(order))
			}
		case *EntityTypeOrder:
			if v != nil {
				args.opts = append(args.opts, WithEntityTypeOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*EntityTypeWhereInput); ok {
		args.opts = append(args.opts, WithEntityTypeFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (eth *EntityTypeHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntityTypeHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return eth, nil
	}
	if err := eth.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return eth, nil
}

func (eth *EntityTypeHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(entitytypehistory.Columns))
		selectedFields = []string{entitytypehistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[entitytypehistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldHistoryTime)
				fieldSeen[entitytypehistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[entitytypehistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldRef)
				fieldSeen[entitytypehistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[entitytypehistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldOperation)
				fieldSeen[entitytypehistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[entitytypehistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldCreatedAt)
				fieldSeen[entitytypehistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[entitytypehistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldUpdatedAt)
				fieldSeen[entitytypehistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[entitytypehistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldCreatedBy)
				fieldSeen[entitytypehistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[entitytypehistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldUpdatedBy)
				fieldSeen[entitytypehistory.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[entitytypehistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldDeletedAt)
				fieldSeen[entitytypehistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[entitytypehistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldDeletedBy)
				fieldSeen[entitytypehistory.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[entitytypehistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldTags)
				fieldSeen[entitytypehistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[entitytypehistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldOwnerID)
				fieldSeen[entitytypehistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[entitytypehistory.FieldName]; !ok {
				selectedFields = append(selectedFields, entitytypehistory.FieldName)
				fieldSeen[entitytypehistory.FieldName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		eth.Select(selectedFields...)
	}
	return nil
}

type entitytypehistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntityTypeHistoryPaginateOption
}

func newEntityTypeHistoryPaginateArgs(rv map[string]any) *entitytypehistoryPaginateArgs {
	args := &entitytypehistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &EntityTypeHistoryOrder{Field: &EntityTypeHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithEntityTypeHistoryOrder(order))
			}
		case *EntityTypeHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithEntityTypeHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*EntityTypeHistoryWhereInput); ok {
		args.opts = append(args.opts, WithEntityTypeHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (e *EventQuery) CollectFields(ctx context.Context, satisfies ...string) (*EventQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return e, nil
	}
	if err := e.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return e, nil
}

func (e *EventQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(event.Columns))
		selectedFields = []string{event.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			e.WithNamedUser(alias, func(wq *UserQuery) {
				*wq = *query
			})

		case "group":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			e.WithNamedGroup(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "integration":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IntegrationClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, integrationImplementors)...); err != nil {
				return err
			}
			e.WithNamedIntegration(alias, func(wq *IntegrationQuery) {
				*wq = *query
			})

		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			e.WithNamedOrganization(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "invite":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InviteClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, inviteImplementors)...); err != nil {
				return err
			}
			e.WithNamedInvite(alias, func(wq *InviteQuery) {
				*wq = *query
			})

		case "feature":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FeatureClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, featureImplementors)...); err != nil {
				return err
			}
			e.WithNamedFeature(alias, func(wq *FeatureQuery) {
				*wq = *query
			})

		case "entitlementplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntitlementPlanClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entitlementplanImplementors)...); err != nil {
				return err
			}
			e.WithNamedEntitlementplan(alias, func(wq *EntitlementPlanQuery) {
				*wq = *query
			})

		case "entitlementplanfeature":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntitlementPlanFeatureClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entitlementplanfeatureImplementors)...); err != nil {
				return err
			}
			e.WithNamedEntitlementplanfeature(alias, func(wq *EntitlementPlanFeatureQuery) {
				*wq = *query
			})

		case "personalAccessToken":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonalAccessTokenClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, personalaccesstokenImplementors)...); err != nil {
				return err
			}
			e.WithNamedPersonalAccessToken(alias, func(wq *PersonalAccessTokenQuery) {
				*wq = *query
			})

		case "oauth2token":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OhAuthTooTokenClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, ohauthtootokenImplementors)...); err != nil {
				return err
			}
			e.WithNamedOauth2token(alias, func(wq *OhAuthTooTokenQuery) {
				*wq = *query
			})

		case "hush":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HushClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, hushImplementors)...); err != nil {
				return err
			}
			e.WithNamedHush(alias, func(wq *HushQuery) {
				*wq = *query
			})

		case "orgmembership":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrgMembershipClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, orgmembershipImplementors)...); err != nil {
				return err
			}
			e.WithNamedOrgmembership(alias, func(wq *OrgMembershipQuery) {
				*wq = *query
			})

		case "groupmembership":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupMembershipClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupmembershipImplementors)...); err != nil {
				return err
			}
			e.WithNamedGroupmembership(alias, func(wq *GroupMembershipQuery) {
				*wq = *query
			})

		case "entitlement":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntitlementClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entitlementImplementors)...); err != nil {
				return err
			}
			e.WithNamedEntitlement(alias, func(wq *EntitlementQuery) {
				*wq = *query
			})

		case "webhook":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&WebhookClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, webhookImplementors)...); err != nil {
				return err
			}
			e.WithNamedWebhook(alias, func(wq *WebhookQuery) {
				*wq = *query
			})

		case "subscriber":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SubscriberClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, subscriberImplementors)...); err != nil {
				return err
			}
			e.WithNamedSubscriber(alias, func(wq *SubscriberQuery) {
				*wq = *query
			})

		case "file":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			e.WithNamedFile(alias, func(wq *FileQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[event.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, event.FieldCreatedAt)
				fieldSeen[event.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[event.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, event.FieldUpdatedAt)
				fieldSeen[event.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[event.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, event.FieldCreatedBy)
				fieldSeen[event.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[event.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, event.FieldUpdatedBy)
				fieldSeen[event.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[event.FieldTags]; !ok {
				selectedFields = append(selectedFields, event.FieldTags)
				fieldSeen[event.FieldTags] = struct{}{}
			}
		case "eventID":
			if _, ok := fieldSeen[event.FieldEventID]; !ok {
				selectedFields = append(selectedFields, event.FieldEventID)
				fieldSeen[event.FieldEventID] = struct{}{}
			}
		case "correlationID":
			if _, ok := fieldSeen[event.FieldCorrelationID]; !ok {
				selectedFields = append(selectedFields, event.FieldCorrelationID)
				fieldSeen[event.FieldCorrelationID] = struct{}{}
			}
		case "eventType":
			if _, ok := fieldSeen[event.FieldEventType]; !ok {
				selectedFields = append(selectedFields, event.FieldEventType)
				fieldSeen[event.FieldEventType] = struct{}{}
			}
		case "metadata":
			if _, ok := fieldSeen[event.FieldMetadata]; !ok {
				selectedFields = append(selectedFields, event.FieldMetadata)
				fieldSeen[event.FieldMetadata] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		e.Select(selectedFields...)
	}
	return nil
}

type eventPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EventPaginateOption
}

func newEventPaginateArgs(rv map[string]any) *eventPaginateArgs {
	args := &eventPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*EventWhereInput); ok {
		args.opts = append(args.opts, WithEventFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (eh *EventHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*EventHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return eh, nil
	}
	if err := eh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return eh, nil
}

func (eh *EventHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(eventhistory.Columns))
		selectedFields = []string{eventhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[eventhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldHistoryTime)
				fieldSeen[eventhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[eventhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldRef)
				fieldSeen[eventhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[eventhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldOperation)
				fieldSeen[eventhistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[eventhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldCreatedAt)
				fieldSeen[eventhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[eventhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldUpdatedAt)
				fieldSeen[eventhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[eventhistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldCreatedBy)
				fieldSeen[eventhistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[eventhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldUpdatedBy)
				fieldSeen[eventhistory.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[eventhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldTags)
				fieldSeen[eventhistory.FieldTags] = struct{}{}
			}
		case "eventID":
			if _, ok := fieldSeen[eventhistory.FieldEventID]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldEventID)
				fieldSeen[eventhistory.FieldEventID] = struct{}{}
			}
		case "correlationID":
			if _, ok := fieldSeen[eventhistory.FieldCorrelationID]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldCorrelationID)
				fieldSeen[eventhistory.FieldCorrelationID] = struct{}{}
			}
		case "eventType":
			if _, ok := fieldSeen[eventhistory.FieldEventType]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldEventType)
				fieldSeen[eventhistory.FieldEventType] = struct{}{}
			}
		case "metadata":
			if _, ok := fieldSeen[eventhistory.FieldMetadata]; !ok {
				selectedFields = append(selectedFields, eventhistory.FieldMetadata)
				fieldSeen[eventhistory.FieldMetadata] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		eh.Select(selectedFields...)
	}
	return nil
}

type eventhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EventHistoryPaginateOption
}

func newEventHistoryPaginateArgs(rv map[string]any) *eventhistoryPaginateArgs {
	args := &eventhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*EventHistoryWhereInput); ok {
		args.opts = append(args.opts, WithEventHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (f *FeatureQuery) CollectFields(ctx context.Context, satisfies ...string) (*FeatureQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return f, nil
	}
	if err := f.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return f, nil
}

func (f *FeatureQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(feature.Columns))
		selectedFields = []string{feature.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			f.withOwner = query
			if _, ok := fieldSeen[feature.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, feature.FieldOwnerID)
				fieldSeen[feature.FieldOwnerID] = struct{}{}
			}

		case "plans":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntitlementPlanClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entitlementplanImplementors)...); err != nil {
				return err
			}
			f.WithNamedPlans(alias, func(wq *EntitlementPlanQuery) {
				*wq = *query
			})

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			f.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})

		case "features":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntitlementPlanFeatureClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entitlementplanfeatureImplementors)...); err != nil {
				return err
			}
			f.WithNamedFeatures(alias, func(wq *EntitlementPlanFeatureQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[feature.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, feature.FieldCreatedAt)
				fieldSeen[feature.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[feature.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, feature.FieldUpdatedAt)
				fieldSeen[feature.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[feature.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, feature.FieldCreatedBy)
				fieldSeen[feature.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[feature.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, feature.FieldUpdatedBy)
				fieldSeen[feature.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[feature.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, feature.FieldDeletedAt)
				fieldSeen[feature.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[feature.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, feature.FieldDeletedBy)
				fieldSeen[feature.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[feature.FieldTags]; !ok {
				selectedFields = append(selectedFields, feature.FieldTags)
				fieldSeen[feature.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[feature.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, feature.FieldOwnerID)
				fieldSeen[feature.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[feature.FieldName]; !ok {
				selectedFields = append(selectedFields, feature.FieldName)
				fieldSeen[feature.FieldName] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[feature.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, feature.FieldDisplayName)
				fieldSeen[feature.FieldDisplayName] = struct{}{}
			}
		case "enabled":
			if _, ok := fieldSeen[feature.FieldEnabled]; !ok {
				selectedFields = append(selectedFields, feature.FieldEnabled)
				fieldSeen[feature.FieldEnabled] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[feature.FieldDescription]; !ok {
				selectedFields = append(selectedFields, feature.FieldDescription)
				fieldSeen[feature.FieldDescription] = struct{}{}
			}
		case "metadata":
			if _, ok := fieldSeen[feature.FieldMetadata]; !ok {
				selectedFields = append(selectedFields, feature.FieldMetadata)
				fieldSeen[feature.FieldMetadata] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		f.Select(selectedFields...)
	}
	return nil
}

type featurePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FeaturePaginateOption
}

func newFeaturePaginateArgs(rv map[string]any) *featurePaginateArgs {
	args := &featurePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*FeatureWhereInput); ok {
		args.opts = append(args.opts, WithFeatureFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (fh *FeatureHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*FeatureHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return fh, nil
	}
	if err := fh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return fh, nil
}

func (fh *FeatureHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(featurehistory.Columns))
		selectedFields = []string{featurehistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[featurehistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldHistoryTime)
				fieldSeen[featurehistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[featurehistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldRef)
				fieldSeen[featurehistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[featurehistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldOperation)
				fieldSeen[featurehistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[featurehistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldCreatedAt)
				fieldSeen[featurehistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[featurehistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldUpdatedAt)
				fieldSeen[featurehistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[featurehistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldCreatedBy)
				fieldSeen[featurehistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[featurehistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldUpdatedBy)
				fieldSeen[featurehistory.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[featurehistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldDeletedAt)
				fieldSeen[featurehistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[featurehistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldDeletedBy)
				fieldSeen[featurehistory.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[featurehistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldTags)
				fieldSeen[featurehistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[featurehistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldOwnerID)
				fieldSeen[featurehistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[featurehistory.FieldName]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldName)
				fieldSeen[featurehistory.FieldName] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[featurehistory.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldDisplayName)
				fieldSeen[featurehistory.FieldDisplayName] = struct{}{}
			}
		case "enabled":
			if _, ok := fieldSeen[featurehistory.FieldEnabled]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldEnabled)
				fieldSeen[featurehistory.FieldEnabled] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[featurehistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldDescription)
				fieldSeen[featurehistory.FieldDescription] = struct{}{}
			}
		case "metadata":
			if _, ok := fieldSeen[featurehistory.FieldMetadata]; !ok {
				selectedFields = append(selectedFields, featurehistory.FieldMetadata)
				fieldSeen[featurehistory.FieldMetadata] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		fh.Select(selectedFields...)
	}
	return nil
}

type featurehistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FeatureHistoryPaginateOption
}

func newFeatureHistoryPaginateArgs(rv map[string]any) *featurehistoryPaginateArgs {
	args := &featurehistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*FeatureHistoryWhereInput); ok {
		args.opts = append(args.opts, WithFeatureHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (f *FileQuery) CollectFields(ctx context.Context, satisfies ...string) (*FileQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return f, nil
	}
	if err := f.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return f, nil
}

func (f *FileQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(file.Columns))
		selectedFields = []string{file.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			f.WithNamedUser(alias, func(wq *UserQuery) {
				*wq = *query
			})

		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			f.WithNamedOrganization(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "group":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			f.WithNamedGroup(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "contact":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ContactClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, contactImplementors)...); err != nil {
				return err
			}
			f.WithNamedContact(alias, func(wq *ContactQuery) {
				*wq = *query
			})

		case "entity":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entityImplementors)...); err != nil {
				return err
			}
			f.WithNamedEntity(alias, func(wq *EntityQuery) {
				*wq = *query
			})

		case "usersetting":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserSettingClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, usersettingImplementors)...); err != nil {
				return err
			}
			f.WithNamedUsersetting(alias, func(wq *UserSettingQuery) {
				*wq = *query
			})

		case "organizationsetting":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationSettingClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationsettingImplementors)...); err != nil {
				return err
			}
			f.WithNamedOrganizationsetting(alias, func(wq *OrganizationSettingQuery) {
				*wq = *query
			})

		case "template":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TemplateClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, templateImplementors)...); err != nil {
				return err
			}
			f.WithNamedTemplate(alias, func(wq *TemplateQuery) {
				*wq = *query
			})

		case "documentdata":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentDataClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentdataImplementors)...); err != nil {
				return err
			}
			f.WithNamedDocumentdata(alias, func(wq *DocumentDataQuery) {
				*wq = *query
			})

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			f.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[file.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, file.FieldCreatedAt)
				fieldSeen[file.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[file.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, file.FieldUpdatedAt)
				fieldSeen[file.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[file.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, file.FieldCreatedBy)
				fieldSeen[file.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[file.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, file.FieldUpdatedBy)
				fieldSeen[file.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[file.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, file.FieldDeletedAt)
				fieldSeen[file.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[file.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, file.FieldDeletedBy)
				fieldSeen[file.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[file.FieldTags]; !ok {
				selectedFields = append(selectedFields, file.FieldTags)
				fieldSeen[file.FieldTags] = struct{}{}
			}
		case "providedFileName":
			if _, ok := fieldSeen[file.FieldProvidedFileName]; !ok {
				selectedFields = append(selectedFields, file.FieldProvidedFileName)
				fieldSeen[file.FieldProvidedFileName] = struct{}{}
			}
		case "providedFileExtension":
			if _, ok := fieldSeen[file.FieldProvidedFileExtension]; !ok {
				selectedFields = append(selectedFields, file.FieldProvidedFileExtension)
				fieldSeen[file.FieldProvidedFileExtension] = struct{}{}
			}
		case "providedFileSize":
			if _, ok := fieldSeen[file.FieldProvidedFileSize]; !ok {
				selectedFields = append(selectedFields, file.FieldProvidedFileSize)
				fieldSeen[file.FieldProvidedFileSize] = struct{}{}
			}
		case "persistedFileSize":
			if _, ok := fieldSeen[file.FieldPersistedFileSize]; !ok {
				selectedFields = append(selectedFields, file.FieldPersistedFileSize)
				fieldSeen[file.FieldPersistedFileSize] = struct{}{}
			}
		case "detectedMimeType":
			if _, ok := fieldSeen[file.FieldDetectedMimeType]; !ok {
				selectedFields = append(selectedFields, file.FieldDetectedMimeType)
				fieldSeen[file.FieldDetectedMimeType] = struct{}{}
			}
		case "md5Hash":
			if _, ok := fieldSeen[file.FieldMd5Hash]; !ok {
				selectedFields = append(selectedFields, file.FieldMd5Hash)
				fieldSeen[file.FieldMd5Hash] = struct{}{}
			}
		case "detectedContentType":
			if _, ok := fieldSeen[file.FieldDetectedContentType]; !ok {
				selectedFields = append(selectedFields, file.FieldDetectedContentType)
				fieldSeen[file.FieldDetectedContentType] = struct{}{}
			}
		case "storeKey":
			if _, ok := fieldSeen[file.FieldStoreKey]; !ok {
				selectedFields = append(selectedFields, file.FieldStoreKey)
				fieldSeen[file.FieldStoreKey] = struct{}{}
			}
		case "categoryType":
			if _, ok := fieldSeen[file.FieldCategoryType]; !ok {
				selectedFields = append(selectedFields, file.FieldCategoryType)
				fieldSeen[file.FieldCategoryType] = struct{}{}
			}
		case "uri":
			if _, ok := fieldSeen[file.FieldURI]; !ok {
				selectedFields = append(selectedFields, file.FieldURI)
				fieldSeen[file.FieldURI] = struct{}{}
			}
		case "storageScheme":
			if _, ok := fieldSeen[file.FieldStorageScheme]; !ok {
				selectedFields = append(selectedFields, file.FieldStorageScheme)
				fieldSeen[file.FieldStorageScheme] = struct{}{}
			}
		case "storageVolume":
			if _, ok := fieldSeen[file.FieldStorageVolume]; !ok {
				selectedFields = append(selectedFields, file.FieldStorageVolume)
				fieldSeen[file.FieldStorageVolume] = struct{}{}
			}
		case "storagePath":
			if _, ok := fieldSeen[file.FieldStoragePath]; !ok {
				selectedFields = append(selectedFields, file.FieldStoragePath)
				fieldSeen[file.FieldStoragePath] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		f.Select(selectedFields...)
	}
	return nil
}

type filePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FilePaginateOption
}

func newFilePaginateArgs(rv map[string]any) *filePaginateArgs {
	args := &filePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*FileWhereInput); ok {
		args.opts = append(args.opts, WithFileFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (fh *FileHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*FileHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return fh, nil
	}
	if err := fh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return fh, nil
}

func (fh *FileHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(filehistory.Columns))
		selectedFields = []string{filehistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[filehistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldHistoryTime)
				fieldSeen[filehistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[filehistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldRef)
				fieldSeen[filehistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[filehistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldOperation)
				fieldSeen[filehistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[filehistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldCreatedAt)
				fieldSeen[filehistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[filehistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldUpdatedAt)
				fieldSeen[filehistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[filehistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldCreatedBy)
				fieldSeen[filehistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[filehistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldUpdatedBy)
				fieldSeen[filehistory.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[filehistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldDeletedAt)
				fieldSeen[filehistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[filehistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldDeletedBy)
				fieldSeen[filehistory.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[filehistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldTags)
				fieldSeen[filehistory.FieldTags] = struct{}{}
			}
		case "providedFileName":
			if _, ok := fieldSeen[filehistory.FieldProvidedFileName]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldProvidedFileName)
				fieldSeen[filehistory.FieldProvidedFileName] = struct{}{}
			}
		case "providedFileExtension":
			if _, ok := fieldSeen[filehistory.FieldProvidedFileExtension]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldProvidedFileExtension)
				fieldSeen[filehistory.FieldProvidedFileExtension] = struct{}{}
			}
		case "providedFileSize":
			if _, ok := fieldSeen[filehistory.FieldProvidedFileSize]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldProvidedFileSize)
				fieldSeen[filehistory.FieldProvidedFileSize] = struct{}{}
			}
		case "persistedFileSize":
			if _, ok := fieldSeen[filehistory.FieldPersistedFileSize]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldPersistedFileSize)
				fieldSeen[filehistory.FieldPersistedFileSize] = struct{}{}
			}
		case "detectedMimeType":
			if _, ok := fieldSeen[filehistory.FieldDetectedMimeType]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldDetectedMimeType)
				fieldSeen[filehistory.FieldDetectedMimeType] = struct{}{}
			}
		case "md5Hash":
			if _, ok := fieldSeen[filehistory.FieldMd5Hash]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldMd5Hash)
				fieldSeen[filehistory.FieldMd5Hash] = struct{}{}
			}
		case "detectedContentType":
			if _, ok := fieldSeen[filehistory.FieldDetectedContentType]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldDetectedContentType)
				fieldSeen[filehistory.FieldDetectedContentType] = struct{}{}
			}
		case "storeKey":
			if _, ok := fieldSeen[filehistory.FieldStoreKey]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldStoreKey)
				fieldSeen[filehistory.FieldStoreKey] = struct{}{}
			}
		case "categoryType":
			if _, ok := fieldSeen[filehistory.FieldCategoryType]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldCategoryType)
				fieldSeen[filehistory.FieldCategoryType] = struct{}{}
			}
		case "uri":
			if _, ok := fieldSeen[filehistory.FieldURI]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldURI)
				fieldSeen[filehistory.FieldURI] = struct{}{}
			}
		case "storageScheme":
			if _, ok := fieldSeen[filehistory.FieldStorageScheme]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldStorageScheme)
				fieldSeen[filehistory.FieldStorageScheme] = struct{}{}
			}
		case "storageVolume":
			if _, ok := fieldSeen[filehistory.FieldStorageVolume]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldStorageVolume)
				fieldSeen[filehistory.FieldStorageVolume] = struct{}{}
			}
		case "storagePath":
			if _, ok := fieldSeen[filehistory.FieldStoragePath]; !ok {
				selectedFields = append(selectedFields, filehistory.FieldStoragePath)
				fieldSeen[filehistory.FieldStoragePath] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		fh.Select(selectedFields...)
	}
	return nil
}

type filehistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FileHistoryPaginateOption
}

func newFileHistoryPaginateArgs(rv map[string]any) *filehistoryPaginateArgs {
	args := &filehistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*FileHistoryWhereInput); ok {
		args.opts = append(args.opts, WithFileHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gr *GroupQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gr, nil
	}
	if err := gr.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gr, nil
}

func (gr *GroupQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(group.Columns))
		selectedFields = []string{group.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			gr.withOwner = query
			if _, ok := fieldSeen[group.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, group.FieldOwnerID)
				fieldSeen[group.FieldOwnerID] = struct{}{}
			}

		case "setting":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupSettingClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, groupsettingImplementors)...); err != nil {
				return err
			}
			gr.withSetting = query

		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			gr.WithNamedUsers(alias, func(wq *UserQuery) {
				*wq = *query
			})

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			gr.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})

		case "integrations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IntegrationClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, integrationImplementors)...); err != nil {
				return err
			}
			gr.WithNamedIntegrations(alias, func(wq *IntegrationQuery) {
				*wq = *query
			})

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			gr.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})

		case "tasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			gr.WithNamedTasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "members":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupMembershipClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupmembershipImplementors)...); err != nil {
				return err
			}
			gr.WithNamedMembers(alias, func(wq *GroupMembershipQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[group.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, group.FieldCreatedAt)
				fieldSeen[group.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[group.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, group.FieldUpdatedAt)
				fieldSeen[group.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[group.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, group.FieldCreatedBy)
				fieldSeen[group.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[group.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, group.FieldUpdatedBy)
				fieldSeen[group.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[group.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, group.FieldDeletedAt)
				fieldSeen[group.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[group.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, group.FieldDeletedBy)
				fieldSeen[group.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[group.FieldTags]; !ok {
				selectedFields = append(selectedFields, group.FieldTags)
				fieldSeen[group.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[group.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, group.FieldOwnerID)
				fieldSeen[group.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[group.FieldName]; !ok {
				selectedFields = append(selectedFields, group.FieldName)
				fieldSeen[group.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[group.FieldDescription]; !ok {
				selectedFields = append(selectedFields, group.FieldDescription)
				fieldSeen[group.FieldDescription] = struct{}{}
			}
		case "gravatarLogoURL":
			if _, ok := fieldSeen[group.FieldGravatarLogoURL]; !ok {
				selectedFields = append(selectedFields, group.FieldGravatarLogoURL)
				fieldSeen[group.FieldGravatarLogoURL] = struct{}{}
			}
		case "logoURL":
			if _, ok := fieldSeen[group.FieldLogoURL]; !ok {
				selectedFields = append(selectedFields, group.FieldLogoURL)
				fieldSeen[group.FieldLogoURL] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[group.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, group.FieldDisplayName)
				fieldSeen[group.FieldDisplayName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gr.Select(selectedFields...)
	}
	return nil
}

type groupPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupPaginateOption
}

func newGroupPaginateArgs(rv map[string]any) *groupPaginateArgs {
	args := &groupPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &GroupOrder{Field: &GroupOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithGroupOrder(order))
			}
		case *GroupOrder:
			if v != nil {
				args.opts = append(args.opts, WithGroupOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*GroupWhereInput); ok {
		args.opts = append(args.opts, WithGroupFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gh *GroupHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gh, nil
	}
	if err := gh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gh, nil
}

func (gh *GroupHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(grouphistory.Columns))
		selectedFields = []string{grouphistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[grouphistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldHistoryTime)
				fieldSeen[grouphistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[grouphistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldRef)
				fieldSeen[grouphistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[grouphistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldOperation)
				fieldSeen[grouphistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[grouphistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldCreatedAt)
				fieldSeen[grouphistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[grouphistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldUpdatedAt)
				fieldSeen[grouphistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[grouphistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldCreatedBy)
				fieldSeen[grouphistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[grouphistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldUpdatedBy)
				fieldSeen[grouphistory.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[grouphistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldDeletedAt)
				fieldSeen[grouphistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[grouphistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldDeletedBy)
				fieldSeen[grouphistory.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[grouphistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldTags)
				fieldSeen[grouphistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[grouphistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldOwnerID)
				fieldSeen[grouphistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[grouphistory.FieldName]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldName)
				fieldSeen[grouphistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[grouphistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldDescription)
				fieldSeen[grouphistory.FieldDescription] = struct{}{}
			}
		case "gravatarLogoURL":
			if _, ok := fieldSeen[grouphistory.FieldGravatarLogoURL]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldGravatarLogoURL)
				fieldSeen[grouphistory.FieldGravatarLogoURL] = struct{}{}
			}
		case "logoURL":
			if _, ok := fieldSeen[grouphistory.FieldLogoURL]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldLogoURL)
				fieldSeen[grouphistory.FieldLogoURL] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[grouphistory.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, grouphistory.FieldDisplayName)
				fieldSeen[grouphistory.FieldDisplayName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gh.Select(selectedFields...)
	}
	return nil
}

type grouphistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupHistoryPaginateOption
}

func newGroupHistoryPaginateArgs(rv map[string]any) *grouphistoryPaginateArgs {
	args := &grouphistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &GroupHistoryOrder{Field: &GroupHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithGroupHistoryOrder(order))
			}
		case *GroupHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithGroupHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*GroupHistoryWhereInput); ok {
		args.opts = append(args.opts, WithGroupHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gm *GroupMembershipQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupMembershipQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gm, nil
	}
	if err := gm.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gm, nil
}

func (gm *GroupMembershipQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(groupmembership.Columns))
		selectedFields = []string{groupmembership.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "group":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: gm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			gm.withGroup = query
			if _, ok := fieldSeen[groupmembership.FieldGroupID]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldGroupID)
				fieldSeen[groupmembership.FieldGroupID] = struct{}{}
			}

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: gm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			gm.withUser = query
			if _, ok := fieldSeen[groupmembership.FieldUserID]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldUserID)
				fieldSeen[groupmembership.FieldUserID] = struct{}{}
			}

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: gm.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			gm.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[groupmembership.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldCreatedAt)
				fieldSeen[groupmembership.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[groupmembership.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldUpdatedAt)
				fieldSeen[groupmembership.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[groupmembership.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldCreatedBy)
				fieldSeen[groupmembership.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[groupmembership.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldUpdatedBy)
				fieldSeen[groupmembership.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[groupmembership.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldDeletedAt)
				fieldSeen[groupmembership.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[groupmembership.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldDeletedBy)
				fieldSeen[groupmembership.FieldDeletedBy] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[groupmembership.FieldRole]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldRole)
				fieldSeen[groupmembership.FieldRole] = struct{}{}
			}
		case "groupID":
			if _, ok := fieldSeen[groupmembership.FieldGroupID]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldGroupID)
				fieldSeen[groupmembership.FieldGroupID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[groupmembership.FieldUserID]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldUserID)
				fieldSeen[groupmembership.FieldUserID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gm.Select(selectedFields...)
	}
	return nil
}

type groupmembershipPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupMembershipPaginateOption
}

func newGroupMembershipPaginateArgs(rv map[string]any) *groupmembershipPaginateArgs {
	args := &groupmembershipPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*GroupMembershipWhereInput); ok {
		args.opts = append(args.opts, WithGroupMembershipFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gmh *GroupMembershipHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupMembershipHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gmh, nil
	}
	if err := gmh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gmh, nil
}

func (gmh *GroupMembershipHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(groupmembershiphistory.Columns))
		selectedFields = []string{groupmembershiphistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[groupmembershiphistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldHistoryTime)
				fieldSeen[groupmembershiphistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[groupmembershiphistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldRef)
				fieldSeen[groupmembershiphistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[groupmembershiphistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldOperation)
				fieldSeen[groupmembershiphistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[groupmembershiphistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldCreatedAt)
				fieldSeen[groupmembershiphistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[groupmembershiphistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldUpdatedAt)
				fieldSeen[groupmembershiphistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[groupmembershiphistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldCreatedBy)
				fieldSeen[groupmembershiphistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[groupmembershiphistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldUpdatedBy)
				fieldSeen[groupmembershiphistory.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[groupmembershiphistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldDeletedAt)
				fieldSeen[groupmembershiphistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[groupmembershiphistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldDeletedBy)
				fieldSeen[groupmembershiphistory.FieldDeletedBy] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[groupmembershiphistory.FieldRole]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldRole)
				fieldSeen[groupmembershiphistory.FieldRole] = struct{}{}
			}
		case "groupID":
			if _, ok := fieldSeen[groupmembershiphistory.FieldGroupID]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldGroupID)
				fieldSeen[groupmembershiphistory.FieldGroupID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[groupmembershiphistory.FieldUserID]; !ok {
				selectedFields = append(selectedFields, groupmembershiphistory.FieldUserID)
				fieldSeen[groupmembershiphistory.FieldUserID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gmh.Select(selectedFields...)
	}
	return nil
}

type groupmembershiphistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupMembershipHistoryPaginateOption
}

func newGroupMembershipHistoryPaginateArgs(rv map[string]any) *groupmembershiphistoryPaginateArgs {
	args := &groupmembershiphistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*GroupMembershipHistoryWhereInput); ok {
		args.opts = append(args.opts, WithGroupMembershipHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gs *GroupSettingQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupSettingQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gs, nil
	}
	if err := gs.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gs, nil
}

func (gs *GroupSettingQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(groupsetting.Columns))
		selectedFields = []string{groupsetting.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "group":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: gs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			gs.withGroup = query
			if _, ok := fieldSeen[groupsetting.FieldGroupID]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldGroupID)
				fieldSeen[groupsetting.FieldGroupID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[groupsetting.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldCreatedAt)
				fieldSeen[groupsetting.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[groupsetting.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldUpdatedAt)
				fieldSeen[groupsetting.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[groupsetting.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldCreatedBy)
				fieldSeen[groupsetting.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[groupsetting.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldUpdatedBy)
				fieldSeen[groupsetting.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[groupsetting.FieldTags]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldTags)
				fieldSeen[groupsetting.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[groupsetting.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldDeletedAt)
				fieldSeen[groupsetting.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[groupsetting.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldDeletedBy)
				fieldSeen[groupsetting.FieldDeletedBy] = struct{}{}
			}
		case "visibility":
			if _, ok := fieldSeen[groupsetting.FieldVisibility]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldVisibility)
				fieldSeen[groupsetting.FieldVisibility] = struct{}{}
			}
		case "joinPolicy":
			if _, ok := fieldSeen[groupsetting.FieldJoinPolicy]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldJoinPolicy)
				fieldSeen[groupsetting.FieldJoinPolicy] = struct{}{}
			}
		case "syncToSlack":
			if _, ok := fieldSeen[groupsetting.FieldSyncToSlack]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldSyncToSlack)
				fieldSeen[groupsetting.FieldSyncToSlack] = struct{}{}
			}
		case "syncToGithub":
			if _, ok := fieldSeen[groupsetting.FieldSyncToGithub]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldSyncToGithub)
				fieldSeen[groupsetting.FieldSyncToGithub] = struct{}{}
			}
		case "groupID":
			if _, ok := fieldSeen[groupsetting.FieldGroupID]; !ok {
				selectedFields = append(selectedFields, groupsetting.FieldGroupID)
				fieldSeen[groupsetting.FieldGroupID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gs.Select(selectedFields...)
	}
	return nil
}

type groupsettingPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupSettingPaginateOption
}

func newGroupSettingPaginateArgs(rv map[string]any) *groupsettingPaginateArgs {
	args := &groupsettingPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*GroupSettingWhereInput); ok {
		args.opts = append(args.opts, WithGroupSettingFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gsh *GroupSettingHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupSettingHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gsh, nil
	}
	if err := gsh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gsh, nil
}

func (gsh *GroupSettingHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(groupsettinghistory.Columns))
		selectedFields = []string{groupsettinghistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[groupsettinghistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldHistoryTime)
				fieldSeen[groupsettinghistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[groupsettinghistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldRef)
				fieldSeen[groupsettinghistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[groupsettinghistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldOperation)
				fieldSeen[groupsettinghistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[groupsettinghistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldCreatedAt)
				fieldSeen[groupsettinghistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[groupsettinghistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldUpdatedAt)
				fieldSeen[groupsettinghistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[groupsettinghistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldCreatedBy)
				fieldSeen[groupsettinghistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[groupsettinghistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldUpdatedBy)
				fieldSeen[groupsettinghistory.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[groupsettinghistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldTags)
				fieldSeen[groupsettinghistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[groupsettinghistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldDeletedAt)
				fieldSeen[groupsettinghistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[groupsettinghistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldDeletedBy)
				fieldSeen[groupsettinghistory.FieldDeletedBy] = struct{}{}
			}
		case "visibility":
			if _, ok := fieldSeen[groupsettinghistory.FieldVisibility]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldVisibility)
				fieldSeen[groupsettinghistory.FieldVisibility] = struct{}{}
			}
		case "joinPolicy":
			if _, ok := fieldSeen[groupsettinghistory.FieldJoinPolicy]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldJoinPolicy)
				fieldSeen[groupsettinghistory.FieldJoinPolicy] = struct{}{}
			}
		case "syncToSlack":
			if _, ok := fieldSeen[groupsettinghistory.FieldSyncToSlack]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldSyncToSlack)
				fieldSeen[groupsettinghistory.FieldSyncToSlack] = struct{}{}
			}
		case "syncToGithub":
			if _, ok := fieldSeen[groupsettinghistory.FieldSyncToGithub]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldSyncToGithub)
				fieldSeen[groupsettinghistory.FieldSyncToGithub] = struct{}{}
			}
		case "groupID":
			if _, ok := fieldSeen[groupsettinghistory.FieldGroupID]; !ok {
				selectedFields = append(selectedFields, groupsettinghistory.FieldGroupID)
				fieldSeen[groupsettinghistory.FieldGroupID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gsh.Select(selectedFields...)
	}
	return nil
}

type groupsettinghistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupSettingHistoryPaginateOption
}

func newGroupSettingHistoryPaginateArgs(rv map[string]any) *groupsettinghistoryPaginateArgs {
	args := &groupsettinghistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*GroupSettingHistoryWhereInput); ok {
		args.opts = append(args.opts, WithGroupSettingHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (h *HushQuery) CollectFields(ctx context.Context, satisfies ...string) (*HushQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return h, nil
	}
	if err := h.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return h, nil
}

func (h *HushQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hush.Columns))
		selectedFields = []string{hush.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "integrations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IntegrationClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, integrationImplementors)...); err != nil {
				return err
			}
			h.WithNamedIntegrations(alias, func(wq *IntegrationQuery) {
				*wq = *query
			})

		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			h.WithNamedOrganization(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			h.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[hush.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hush.FieldCreatedAt)
				fieldSeen[hush.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hush.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hush.FieldUpdatedAt)
				fieldSeen[hush.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[hush.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, hush.FieldCreatedBy)
				fieldSeen[hush.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[hush.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, hush.FieldUpdatedBy)
				fieldSeen[hush.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[hush.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, hush.FieldDeletedAt)
				fieldSeen[hush.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[hush.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, hush.FieldDeletedBy)
				fieldSeen[hush.FieldDeletedBy] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[hush.FieldName]; !ok {
				selectedFields = append(selectedFields, hush.FieldName)
				fieldSeen[hush.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[hush.FieldDescription]; !ok {
				selectedFields = append(selectedFields, hush.FieldDescription)
				fieldSeen[hush.FieldDescription] = struct{}{}
			}
		case "kind":
			if _, ok := fieldSeen[hush.FieldKind]; !ok {
				selectedFields = append(selectedFields, hush.FieldKind)
				fieldSeen[hush.FieldKind] = struct{}{}
			}
		case "secretName":
			if _, ok := fieldSeen[hush.FieldSecretName]; !ok {
				selectedFields = append(selectedFields, hush.FieldSecretName)
				fieldSeen[hush.FieldSecretName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		h.Select(selectedFields...)
	}
	return nil
}

type hushPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HushPaginateOption
}

func newHushPaginateArgs(rv map[string]any) *hushPaginateArgs {
	args := &hushPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &HushOrder{Field: &HushOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHushOrder(order))
			}
		case *HushOrder:
			if v != nil {
				args.opts = append(args.opts, WithHushOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*HushWhereInput); ok {
		args.opts = append(args.opts, WithHushFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hh *HushHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*HushHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hh, nil
	}
	if err := hh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hh, nil
}

func (hh *HushHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hushhistory.Columns))
		selectedFields = []string{hushhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[hushhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldHistoryTime)
				fieldSeen[hushhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[hushhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldRef)
				fieldSeen[hushhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[hushhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldOperation)
				fieldSeen[hushhistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[hushhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldCreatedAt)
				fieldSeen[hushhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hushhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldUpdatedAt)
				fieldSeen[hushhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[hushhistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldCreatedBy)
				fieldSeen[hushhistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[hushhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldUpdatedBy)
				fieldSeen[hushhistory.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[hushhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldDeletedAt)
				fieldSeen[hushhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[hushhistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldDeletedBy)
				fieldSeen[hushhistory.FieldDeletedBy] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[hushhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldName)
				fieldSeen[hushhistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[hushhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldDescription)
				fieldSeen[hushhistory.FieldDescription] = struct{}{}
			}
		case "kind":
			if _, ok := fieldSeen[hushhistory.FieldKind]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldKind)
				fieldSeen[hushhistory.FieldKind] = struct{}{}
			}
		case "secretName":
			if _, ok := fieldSeen[hushhistory.FieldSecretName]; !ok {
				selectedFields = append(selectedFields, hushhistory.FieldSecretName)
				fieldSeen[hushhistory.FieldSecretName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hh.Select(selectedFields...)
	}
	return nil
}

type hushhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HushHistoryPaginateOption
}

func newHushHistoryPaginateArgs(rv map[string]any) *hushhistoryPaginateArgs {
	args := &hushhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &HushHistoryOrder{Field: &HushHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHushHistoryOrder(order))
			}
		case *HushHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithHushHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*HushHistoryWhereInput); ok {
		args.opts = append(args.opts, WithHushHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (i *IntegrationQuery) CollectFields(ctx context.Context, satisfies ...string) (*IntegrationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return i, nil
	}
	if err := i.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return i, nil
}

func (i *IntegrationQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(integration.Columns))
		selectedFields = []string{integration.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			i.withOwner = query
			if _, ok := fieldSeen[integration.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, integration.FieldOwnerID)
				fieldSeen[integration.FieldOwnerID] = struct{}{}
			}

		case "secrets":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HushClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, hushImplementors)...); err != nil {
				return err
			}
			i.WithNamedSecrets(alias, func(wq *HushQuery) {
				*wq = *query
			})

		case "oauth2tokens":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OhAuthTooTokenClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, ohauthtootokenImplementors)...); err != nil {
				return err
			}
			i.WithNamedOauth2tokens(alias, func(wq *OhAuthTooTokenQuery) {
				*wq = *query
			})

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			i.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})

		case "webhooks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&WebhookClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, webhookImplementors)...); err != nil {
				return err
			}
			i.WithNamedWebhooks(alias, func(wq *WebhookQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[integration.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, integration.FieldCreatedAt)
				fieldSeen[integration.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[integration.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, integration.FieldUpdatedAt)
				fieldSeen[integration.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[integration.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, integration.FieldCreatedBy)
				fieldSeen[integration.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[integration.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, integration.FieldUpdatedBy)
				fieldSeen[integration.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[integration.FieldTags]; !ok {
				selectedFields = append(selectedFields, integration.FieldTags)
				fieldSeen[integration.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[integration.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, integration.FieldDeletedAt)
				fieldSeen[integration.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[integration.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, integration.FieldDeletedBy)
				fieldSeen[integration.FieldDeletedBy] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[integration.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, integration.FieldOwnerID)
				fieldSeen[integration.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[integration.FieldName]; !ok {
				selectedFields = append(selectedFields, integration.FieldName)
				fieldSeen[integration.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[integration.FieldDescription]; !ok {
				selectedFields = append(selectedFields, integration.FieldDescription)
				fieldSeen[integration.FieldDescription] = struct{}{}
			}
		case "kind":
			if _, ok := fieldSeen[integration.FieldKind]; !ok {
				selectedFields = append(selectedFields, integration.FieldKind)
				fieldSeen[integration.FieldKind] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		i.Select(selectedFields...)
	}
	return nil
}

type integrationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []IntegrationPaginateOption
}

func newIntegrationPaginateArgs(rv map[string]any) *integrationPaginateArgs {
	args := &integrationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &IntegrationOrder{Field: &IntegrationOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithIntegrationOrder(order))
			}
		case *IntegrationOrder:
			if v != nil {
				args.opts = append(args.opts, WithIntegrationOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*IntegrationWhereInput); ok {
		args.opts = append(args.opts, WithIntegrationFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ih *IntegrationHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*IntegrationHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ih, nil
	}
	if err := ih.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ih, nil
}

func (ih *IntegrationHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(integrationhistory.Columns))
		selectedFields = []string{integrationhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[integrationhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldHistoryTime)
				fieldSeen[integrationhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[integrationhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldRef)
				fieldSeen[integrationhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[integrationhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldOperation)
				fieldSeen[integrationhistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[integrationhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldCreatedAt)
				fieldSeen[integrationhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[integrationhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldUpdatedAt)
				fieldSeen[integrationhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[integrationhistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldCreatedBy)
				fieldSeen[integrationhistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[integrationhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldUpdatedBy)
				fieldSeen[integrationhistory.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[integrationhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldTags)
				fieldSeen[integrationhistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[integrationhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldDeletedAt)
				fieldSeen[integrationhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[integrationhistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldDeletedBy)
				fieldSeen[integrationhistory.FieldDeletedBy] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[integrationhistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldOwnerID)
				fieldSeen[integrationhistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[integrationhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldName)
				fieldSeen[integrationhistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[integrationhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldDescription)
				fieldSeen[integrationhistory.FieldDescription] = struct{}{}
			}
		case "kind":
			if _, ok := fieldSeen[integrationhistory.FieldKind]; !ok {
				selectedFields = append(selectedFields, integrationhistory.FieldKind)
				fieldSeen[integrationhistory.FieldKind] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ih.Select(selectedFields...)
	}
	return nil
}

type integrationhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []IntegrationHistoryPaginateOption
}

func newIntegrationHistoryPaginateArgs(rv map[string]any) *integrationhistoryPaginateArgs {
	args := &integrationhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &IntegrationHistoryOrder{Field: &IntegrationHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithIntegrationHistoryOrder(order))
			}
		case *IntegrationHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithIntegrationHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*IntegrationHistoryWhereInput); ok {
		args.opts = append(args.opts, WithIntegrationHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (i *InviteQuery) CollectFields(ctx context.Context, satisfies ...string) (*InviteQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return i, nil
	}
	if err := i.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return i, nil
}

func (i *InviteQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(invite.Columns))
		selectedFields = []string{invite.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			i.withOwner = query
			if _, ok := fieldSeen[invite.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, invite.FieldOwnerID)
				fieldSeen[invite.FieldOwnerID] = struct{}{}
			}

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			i.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[invite.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, invite.FieldCreatedAt)
				fieldSeen[invite.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[invite.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, invite.FieldUpdatedAt)
				fieldSeen[invite.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[invite.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, invite.FieldCreatedBy)
				fieldSeen[invite.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[invite.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, invite.FieldUpdatedBy)
				fieldSeen[invite.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[invite.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, invite.FieldDeletedAt)
				fieldSeen[invite.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[invite.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, invite.FieldDeletedBy)
				fieldSeen[invite.FieldDeletedBy] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[invite.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, invite.FieldOwnerID)
				fieldSeen[invite.FieldOwnerID] = struct{}{}
			}
		case "expires":
			if _, ok := fieldSeen[invite.FieldExpires]; !ok {
				selectedFields = append(selectedFields, invite.FieldExpires)
				fieldSeen[invite.FieldExpires] = struct{}{}
			}
		case "recipient":
			if _, ok := fieldSeen[invite.FieldRecipient]; !ok {
				selectedFields = append(selectedFields, invite.FieldRecipient)
				fieldSeen[invite.FieldRecipient] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[invite.FieldStatus]; !ok {
				selectedFields = append(selectedFields, invite.FieldStatus)
				fieldSeen[invite.FieldStatus] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[invite.FieldRole]; !ok {
				selectedFields = append(selectedFields, invite.FieldRole)
				fieldSeen[invite.FieldRole] = struct{}{}
			}
		case "sendAttempts":
			if _, ok := fieldSeen[invite.FieldSendAttempts]; !ok {
				selectedFields = append(selectedFields, invite.FieldSendAttempts)
				fieldSeen[invite.FieldSendAttempts] = struct{}{}
			}
		case "requestorID":
			if _, ok := fieldSeen[invite.FieldRequestorID]; !ok {
				selectedFields = append(selectedFields, invite.FieldRequestorID)
				fieldSeen[invite.FieldRequestorID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		i.Select(selectedFields...)
	}
	return nil
}

type invitePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []InvitePaginateOption
}

func newInvitePaginateArgs(rv map[string]any) *invitePaginateArgs {
	args := &invitePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*InviteWhereInput); ok {
		args.opts = append(args.opts, WithInviteFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (n *NoteQuery) CollectFields(ctx context.Context, satisfies ...string) (*NoteQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return n, nil
	}
	if err := n.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return n, nil
}

func (n *NoteQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(note.Columns))
		selectedFields = []string{note.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			n.withOwner = query
			if _, ok := fieldSeen[note.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, note.FieldOwnerID)
				fieldSeen[note.FieldOwnerID] = struct{}{}
			}

		case "entity":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, entityImplementors)...); err != nil {
				return err
			}
			n.withEntity = query
		case "createdAt":
			if _, ok := fieldSeen[note.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, note.FieldCreatedAt)
				fieldSeen[note.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[note.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, note.FieldUpdatedAt)
				fieldSeen[note.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[note.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, note.FieldCreatedBy)
				fieldSeen[note.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[note.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, note.FieldUpdatedBy)
				fieldSeen[note.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[note.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, note.FieldDeletedAt)
				fieldSeen[note.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[note.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, note.FieldDeletedBy)
				fieldSeen[note.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[note.FieldTags]; !ok {
				selectedFields = append(selectedFields, note.FieldTags)
				fieldSeen[note.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[note.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, note.FieldOwnerID)
				fieldSeen[note.FieldOwnerID] = struct{}{}
			}
		case "text":
			if _, ok := fieldSeen[note.FieldText]; !ok {
				selectedFields = append(selectedFields, note.FieldText)
				fieldSeen[note.FieldText] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		n.Select(selectedFields...)
	}
	return nil
}

type notePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []NotePaginateOption
}

func newNotePaginateArgs(rv map[string]any) *notePaginateArgs {
	args := &notePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*NoteWhereInput); ok {
		args.opts = append(args.opts, WithNoteFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (nh *NoteHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*NoteHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nh, nil
	}
	if err := nh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return nh, nil
}

func (nh *NoteHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(notehistory.Columns))
		selectedFields = []string{notehistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[notehistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldHistoryTime)
				fieldSeen[notehistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[notehistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldRef)
				fieldSeen[notehistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[notehistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldOperation)
				fieldSeen[notehistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[notehistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldCreatedAt)
				fieldSeen[notehistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[notehistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldUpdatedAt)
				fieldSeen[notehistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[notehistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldCreatedBy)
				fieldSeen[notehistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[notehistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldUpdatedBy)
				fieldSeen[notehistory.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[notehistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldDeletedAt)
				fieldSeen[notehistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[notehistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldDeletedBy)
				fieldSeen[notehistory.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[notehistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldTags)
				fieldSeen[notehistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[notehistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldOwnerID)
				fieldSeen[notehistory.FieldOwnerID] = struct{}{}
			}
		case "text":
			if _, ok := fieldSeen[notehistory.FieldText]; !ok {
				selectedFields = append(selectedFields, notehistory.FieldText)
				fieldSeen[notehistory.FieldText] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		nh.Select(selectedFields...)
	}
	return nil
}

type notehistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []NoteHistoryPaginateOption
}

func newNoteHistoryPaginateArgs(rv map[string]any) *notehistoryPaginateArgs {
	args := &notehistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*NoteHistoryWhereInput); ok {
		args.opts = append(args.opts, WithNoteHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (op *OauthProviderQuery) CollectFields(ctx context.Context, satisfies ...string) (*OauthProviderQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return op, nil
	}
	if err := op.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return op, nil
}

func (op *OauthProviderQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(oauthprovider.Columns))
		selectedFields = []string{oauthprovider.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: op.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			op.withOwner = query
			if _, ok := fieldSeen[oauthprovider.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldOwnerID)
				fieldSeen[oauthprovider.FieldOwnerID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[oauthprovider.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldCreatedAt)
				fieldSeen[oauthprovider.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[oauthprovider.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldUpdatedAt)
				fieldSeen[oauthprovider.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[oauthprovider.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldCreatedBy)
				fieldSeen[oauthprovider.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[oauthprovider.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldUpdatedBy)
				fieldSeen[oauthprovider.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[oauthprovider.FieldTags]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldTags)
				fieldSeen[oauthprovider.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[oauthprovider.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldDeletedAt)
				fieldSeen[oauthprovider.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[oauthprovider.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldDeletedBy)
				fieldSeen[oauthprovider.FieldDeletedBy] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[oauthprovider.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldOwnerID)
				fieldSeen[oauthprovider.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[oauthprovider.FieldName]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldName)
				fieldSeen[oauthprovider.FieldName] = struct{}{}
			}
		case "clientID":
			if _, ok := fieldSeen[oauthprovider.FieldClientID]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldClientID)
				fieldSeen[oauthprovider.FieldClientID] = struct{}{}
			}
		case "clientSecret":
			if _, ok := fieldSeen[oauthprovider.FieldClientSecret]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldClientSecret)
				fieldSeen[oauthprovider.FieldClientSecret] = struct{}{}
			}
		case "redirectURL":
			if _, ok := fieldSeen[oauthprovider.FieldRedirectURL]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldRedirectURL)
				fieldSeen[oauthprovider.FieldRedirectURL] = struct{}{}
			}
		case "scopes":
			if _, ok := fieldSeen[oauthprovider.FieldScopes]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldScopes)
				fieldSeen[oauthprovider.FieldScopes] = struct{}{}
			}
		case "authURL":
			if _, ok := fieldSeen[oauthprovider.FieldAuthURL]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldAuthURL)
				fieldSeen[oauthprovider.FieldAuthURL] = struct{}{}
			}
		case "tokenURL":
			if _, ok := fieldSeen[oauthprovider.FieldTokenURL]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldTokenURL)
				fieldSeen[oauthprovider.FieldTokenURL] = struct{}{}
			}
		case "authStyle":
			if _, ok := fieldSeen[oauthprovider.FieldAuthStyle]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldAuthStyle)
				fieldSeen[oauthprovider.FieldAuthStyle] = struct{}{}
			}
		case "infoURL":
			if _, ok := fieldSeen[oauthprovider.FieldInfoURL]; !ok {
				selectedFields = append(selectedFields, oauthprovider.FieldInfoURL)
				fieldSeen[oauthprovider.FieldInfoURL] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		op.Select(selectedFields...)
	}
	return nil
}

type oauthproviderPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OauthProviderPaginateOption
}

func newOauthProviderPaginateArgs(rv map[string]any) *oauthproviderPaginateArgs {
	args := &oauthproviderPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OauthProviderWhereInput); ok {
		args.opts = append(args.opts, WithOauthProviderFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (oph *OauthProviderHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*OauthProviderHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return oph, nil
	}
	if err := oph.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return oph, nil
}

func (oph *OauthProviderHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(oauthproviderhistory.Columns))
		selectedFields = []string{oauthproviderhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[oauthproviderhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldHistoryTime)
				fieldSeen[oauthproviderhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[oauthproviderhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldRef)
				fieldSeen[oauthproviderhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[oauthproviderhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldOperation)
				fieldSeen[oauthproviderhistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[oauthproviderhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldCreatedAt)
				fieldSeen[oauthproviderhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[oauthproviderhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldUpdatedAt)
				fieldSeen[oauthproviderhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[oauthproviderhistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldCreatedBy)
				fieldSeen[oauthproviderhistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[oauthproviderhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldUpdatedBy)
				fieldSeen[oauthproviderhistory.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[oauthproviderhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldTags)
				fieldSeen[oauthproviderhistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[oauthproviderhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldDeletedAt)
				fieldSeen[oauthproviderhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[oauthproviderhistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldDeletedBy)
				fieldSeen[oauthproviderhistory.FieldDeletedBy] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[oauthproviderhistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldOwnerID)
				fieldSeen[oauthproviderhistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[oauthproviderhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldName)
				fieldSeen[oauthproviderhistory.FieldName] = struct{}{}
			}
		case "clientID":
			if _, ok := fieldSeen[oauthproviderhistory.FieldClientID]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldClientID)
				fieldSeen[oauthproviderhistory.FieldClientID] = struct{}{}
			}
		case "clientSecret":
			if _, ok := fieldSeen[oauthproviderhistory.FieldClientSecret]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldClientSecret)
				fieldSeen[oauthproviderhistory.FieldClientSecret] = struct{}{}
			}
		case "redirectURL":
			if _, ok := fieldSeen[oauthproviderhistory.FieldRedirectURL]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldRedirectURL)
				fieldSeen[oauthproviderhistory.FieldRedirectURL] = struct{}{}
			}
		case "scopes":
			if _, ok := fieldSeen[oauthproviderhistory.FieldScopes]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldScopes)
				fieldSeen[oauthproviderhistory.FieldScopes] = struct{}{}
			}
		case "authURL":
			if _, ok := fieldSeen[oauthproviderhistory.FieldAuthURL]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldAuthURL)
				fieldSeen[oauthproviderhistory.FieldAuthURL] = struct{}{}
			}
		case "tokenURL":
			if _, ok := fieldSeen[oauthproviderhistory.FieldTokenURL]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldTokenURL)
				fieldSeen[oauthproviderhistory.FieldTokenURL] = struct{}{}
			}
		case "authStyle":
			if _, ok := fieldSeen[oauthproviderhistory.FieldAuthStyle]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldAuthStyle)
				fieldSeen[oauthproviderhistory.FieldAuthStyle] = struct{}{}
			}
		case "infoURL":
			if _, ok := fieldSeen[oauthproviderhistory.FieldInfoURL]; !ok {
				selectedFields = append(selectedFields, oauthproviderhistory.FieldInfoURL)
				fieldSeen[oauthproviderhistory.FieldInfoURL] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		oph.Select(selectedFields...)
	}
	return nil
}

type oauthproviderhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OauthProviderHistoryPaginateOption
}

func newOauthProviderHistoryPaginateArgs(rv map[string]any) *oauthproviderhistoryPaginateArgs {
	args := &oauthproviderhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OauthProviderHistoryWhereInput); ok {
		args.opts = append(args.opts, WithOauthProviderHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (oatt *OhAuthTooTokenQuery) CollectFields(ctx context.Context, satisfies ...string) (*OhAuthTooTokenQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return oatt, nil
	}
	if err := oatt.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return oatt, nil
}

func (oatt *OhAuthTooTokenQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(ohauthtootoken.Columns))
		selectedFields = []string{ohauthtootoken.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "integration":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IntegrationClient{config: oatt.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, integrationImplementors)...); err != nil {
				return err
			}
			oatt.WithNamedIntegration(alias, func(wq *IntegrationQuery) {
				*wq = *query
			})

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: oatt.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			oatt.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "tags":
			if _, ok := fieldSeen[ohauthtootoken.FieldTags]; !ok {
				selectedFields = append(selectedFields, ohauthtootoken.FieldTags)
				fieldSeen[ohauthtootoken.FieldTags] = struct{}{}
			}
		case "clientID":
			if _, ok := fieldSeen[ohauthtootoken.FieldClientID]; !ok {
				selectedFields = append(selectedFields, ohauthtootoken.FieldClientID)
				fieldSeen[ohauthtootoken.FieldClientID] = struct{}{}
			}
		case "scopes":
			if _, ok := fieldSeen[ohauthtootoken.FieldScopes]; !ok {
				selectedFields = append(selectedFields, ohauthtootoken.FieldScopes)
				fieldSeen[ohauthtootoken.FieldScopes] = struct{}{}
			}
		case "nonce":
			if _, ok := fieldSeen[ohauthtootoken.FieldNonce]; !ok {
				selectedFields = append(selectedFields, ohauthtootoken.FieldNonce)
				fieldSeen[ohauthtootoken.FieldNonce] = struct{}{}
			}
		case "claimsUserID":
			if _, ok := fieldSeen[ohauthtootoken.FieldClaimsUserID]; !ok {
				selectedFields = append(selectedFields, ohauthtootoken.FieldClaimsUserID)
				fieldSeen[ohauthtootoken.FieldClaimsUserID] = struct{}{}
			}
		case "claimsUsername":
			if _, ok := fieldSeen[ohauthtootoken.FieldClaimsUsername]; !ok {
				selectedFields = append(selectedFields, ohauthtootoken.FieldClaimsUsername)
				fieldSeen[ohauthtootoken.FieldClaimsUsername] = struct{}{}
			}
		case "claimsEmail":
			if _, ok := fieldSeen[ohauthtootoken.FieldClaimsEmail]; !ok {
				selectedFields = append(selectedFields, ohauthtootoken.FieldClaimsEmail)
				fieldSeen[ohauthtootoken.FieldClaimsEmail] = struct{}{}
			}
		case "claimsEmailVerified":
			if _, ok := fieldSeen[ohauthtootoken.FieldClaimsEmailVerified]; !ok {
				selectedFields = append(selectedFields, ohauthtootoken.FieldClaimsEmailVerified)
				fieldSeen[ohauthtootoken.FieldClaimsEmailVerified] = struct{}{}
			}
		case "claimsGroups":
			if _, ok := fieldSeen[ohauthtootoken.FieldClaimsGroups]; !ok {
				selectedFields = append(selectedFields, ohauthtootoken.FieldClaimsGroups)
				fieldSeen[ohauthtootoken.FieldClaimsGroups] = struct{}{}
			}
		case "claimsPreferredUsername":
			if _, ok := fieldSeen[ohauthtootoken.FieldClaimsPreferredUsername]; !ok {
				selectedFields = append(selectedFields, ohauthtootoken.FieldClaimsPreferredUsername)
				fieldSeen[ohauthtootoken.FieldClaimsPreferredUsername] = struct{}{}
			}
		case "connectorID":
			if _, ok := fieldSeen[ohauthtootoken.FieldConnectorID]; !ok {
				selectedFields = append(selectedFields, ohauthtootoken.FieldConnectorID)
				fieldSeen[ohauthtootoken.FieldConnectorID] = struct{}{}
			}
		case "connectorData":
			if _, ok := fieldSeen[ohauthtootoken.FieldConnectorData]; !ok {
				selectedFields = append(selectedFields, ohauthtootoken.FieldConnectorData)
				fieldSeen[ohauthtootoken.FieldConnectorData] = struct{}{}
			}
		case "lastUsed":
			if _, ok := fieldSeen[ohauthtootoken.FieldLastUsed]; !ok {
				selectedFields = append(selectedFields, ohauthtootoken.FieldLastUsed)
				fieldSeen[ohauthtootoken.FieldLastUsed] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		oatt.Select(selectedFields...)
	}
	return nil
}

type ohauthtootokenPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OhAuthTooTokenPaginateOption
}

func newOhAuthTooTokenPaginateArgs(rv map[string]any) *ohauthtootokenPaginateArgs {
	args := &ohauthtootokenPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OhAuthTooTokenWhereInput); ok {
		args.opts = append(args.opts, WithOhAuthTooTokenFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (om *OrgMembershipQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrgMembershipQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return om, nil
	}
	if err := om.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return om, nil
}

func (om *OrgMembershipQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(orgmembership.Columns))
		selectedFields = []string{orgmembership.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: om.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			om.withOrganization = query
			if _, ok := fieldSeen[orgmembership.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldOrganizationID)
				fieldSeen[orgmembership.FieldOrganizationID] = struct{}{}
			}

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: om.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			om.withUser = query
			if _, ok := fieldSeen[orgmembership.FieldUserID]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldUserID)
				fieldSeen[orgmembership.FieldUserID] = struct{}{}
			}

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: om.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			om.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[orgmembership.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldCreatedAt)
				fieldSeen[orgmembership.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[orgmembership.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldUpdatedAt)
				fieldSeen[orgmembership.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[orgmembership.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldCreatedBy)
				fieldSeen[orgmembership.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[orgmembership.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldUpdatedBy)
				fieldSeen[orgmembership.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[orgmembership.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldDeletedAt)
				fieldSeen[orgmembership.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[orgmembership.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldDeletedBy)
				fieldSeen[orgmembership.FieldDeletedBy] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[orgmembership.FieldRole]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldRole)
				fieldSeen[orgmembership.FieldRole] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[orgmembership.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldOrganizationID)
				fieldSeen[orgmembership.FieldOrganizationID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[orgmembership.FieldUserID]; !ok {
				selectedFields = append(selectedFields, orgmembership.FieldUserID)
				fieldSeen[orgmembership.FieldUserID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		om.Select(selectedFields...)
	}
	return nil
}

type orgmembershipPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrgMembershipPaginateOption
}

func newOrgMembershipPaginateArgs(rv map[string]any) *orgmembershipPaginateArgs {
	args := &orgmembershipPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OrgMembershipWhereInput); ok {
		args.opts = append(args.opts, WithOrgMembershipFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (omh *OrgMembershipHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrgMembershipHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return omh, nil
	}
	if err := omh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return omh, nil
}

func (omh *OrgMembershipHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(orgmembershiphistory.Columns))
		selectedFields = []string{orgmembershiphistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[orgmembershiphistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldHistoryTime)
				fieldSeen[orgmembershiphistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[orgmembershiphistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldRef)
				fieldSeen[orgmembershiphistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[orgmembershiphistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldOperation)
				fieldSeen[orgmembershiphistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[orgmembershiphistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldCreatedAt)
				fieldSeen[orgmembershiphistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[orgmembershiphistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldUpdatedAt)
				fieldSeen[orgmembershiphistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[orgmembershiphistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldCreatedBy)
				fieldSeen[orgmembershiphistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[orgmembershiphistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldUpdatedBy)
				fieldSeen[orgmembershiphistory.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[orgmembershiphistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldDeletedAt)
				fieldSeen[orgmembershiphistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[orgmembershiphistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldDeletedBy)
				fieldSeen[orgmembershiphistory.FieldDeletedBy] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[orgmembershiphistory.FieldRole]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldRole)
				fieldSeen[orgmembershiphistory.FieldRole] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[orgmembershiphistory.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldOrganizationID)
				fieldSeen[orgmembershiphistory.FieldOrganizationID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[orgmembershiphistory.FieldUserID]; !ok {
				selectedFields = append(selectedFields, orgmembershiphistory.FieldUserID)
				fieldSeen[orgmembershiphistory.FieldUserID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		omh.Select(selectedFields...)
	}
	return nil
}

type orgmembershiphistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrgMembershipHistoryPaginateOption
}

func newOrgMembershipHistoryPaginateArgs(rv map[string]any) *orgmembershiphistoryPaginateArgs {
	args := &orgmembershiphistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OrgMembershipHistoryWhereInput); ok {
		args.opts = append(args.opts, WithOrgMembershipHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (o *OrganizationQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrganizationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return o, nil
	}
	if err := o.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return o, nil
}

func (o *OrganizationQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(organization.Columns))
		selectedFields = []string{organization.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "parent":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			o.withParent = query
			if _, ok := fieldSeen[organization.FieldParentOrganizationID]; !ok {
				selectedFields = append(selectedFields, organization.FieldParentOrganizationID)
				fieldSeen[organization.FieldParentOrganizationID] = struct{}{}
			}

		case "children":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: o.config}).Query()
			)
			args := newOrganizationPaginateArgs(fieldArgs(ctx, new(OrganizationWhereInput), path...))
			if err := validateFirstLast(args.first, args.last); err != nil {
				return fmt.Errorf("validate first and last in path %q: %w", path, err)
			}
			pager, err := newOrganizationPager(args.opts, args.last != nil)
			if err != nil {
				return fmt.Errorf("create new pager in path %q: %w", path, err)
			}
			if query, err = pager.applyFilter(query); err != nil {
				return err
			}
			ignoredEdges := !hasCollectedField(ctx, append(path, edgesField)...)
			if hasCollectedField(ctx, append(path, totalCountField)...) || hasCollectedField(ctx, append(path, pageInfoField)...) {
				hasPagination := args.after != nil || args.first != nil || args.before != nil || args.last != nil
				if hasPagination || ignoredEdges {
					query := query.Clone()
					o.loadTotal = append(o.loadTotal, func(ctx context.Context, nodes []*Organization) error {
						ids := make([]driver.Value, len(nodes))
						for i := range nodes {
							ids[i] = nodes[i].ID
						}
						var v []struct {
							NodeID string `sql:"parent_organization_id"`
							Count  int    `sql:"count"`
						}
						query.Where(func(s *sql.Selector) {
							s.Where(sql.InValues(s.C(organization.ChildrenColumn), ids...))
						})
						if err := query.GroupBy(organization.ChildrenColumn).Aggregate(Count()).Scan(ctx, &v); err != nil {
							return err
						}
						m := make(map[string]int, len(v))
						for i := range v {
							m[v[i].NodeID] = v[i].Count
						}
						for i := range nodes {
							n := m[nodes[i].ID]
							if nodes[i].Edges.totalCount[1] == nil {
								nodes[i].Edges.totalCount[1] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[1][alias] = n
						}
						return nil
					})
				} else {
					o.loadTotal = append(o.loadTotal, func(_ context.Context, nodes []*Organization) error {
						for i := range nodes {
							n := len(nodes[i].Edges.Children)
							if nodes[i].Edges.totalCount[1] == nil {
								nodes[i].Edges.totalCount[1] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[1][alias] = n
						}
						return nil
					})
				}
			}
			if ignoredEdges || (args.first != nil && *args.first == 0) || (args.last != nil && *args.last == 0) {
				continue
			}
			if query, err = pager.applyCursors(query, args.after, args.before); err != nil {
				return err
			}
			path = append(path, edgesField, nodeField)
			if field := collectedField(ctx, path...); field != nil {
				if err := query.collectField(ctx, false, opCtx, *field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
					return err
				}
			}
			if limit := paginateLimit(args.first, args.last); limit > 0 {
				if oneNode {
					pager.applyOrder(query.Limit(limit))
				} else {
					modify := entgql.LimitPerRow(organization.ChildrenColumn, limit, pager.orderExpr(query))
					query.modifiers = append(query.modifiers, modify)
				}
			} else {
				query = pager.applyOrder(query)
			}
			o.WithNamedChildren(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "groups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			o.WithNamedGroups(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "templates":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TemplateClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, templateImplementors)...); err != nil {
				return err
			}
			o.WithNamedTemplates(alias, func(wq *TemplateQuery) {
				*wq = *query
			})

		case "integrations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IntegrationClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, integrationImplementors)...); err != nil {
				return err
			}
			o.WithNamedIntegrations(alias, func(wq *IntegrationQuery) {
				*wq = *query
			})

		case "setting":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationSettingClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationsettingImplementors)...); err != nil {
				return err
			}
			o.withSetting = query

		case "documentdata":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentDataClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentdataImplementors)...); err != nil {
				return err
			}
			o.WithNamedDocumentdata(alias, func(wq *DocumentDataQuery) {
				*wq = *query
			})

		case "entitlements":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntitlementClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entitlementImplementors)...); err != nil {
				return err
			}
			o.WithNamedEntitlements(alias, func(wq *EntitlementQuery) {
				*wq = *query
			})

		case "organizationEntitlement":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntitlementClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entitlementImplementors)...); err != nil {
				return err
			}
			o.WithNamedOrganizationEntitlement(alias, func(wq *EntitlementQuery) {
				*wq = *query
			})

		case "personalAccessTokens":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonalAccessTokenClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, personalaccesstokenImplementors)...); err != nil {
				return err
			}
			o.WithNamedPersonalAccessTokens(alias, func(wq *PersonalAccessTokenQuery) {
				*wq = *query
			})

		case "apiTokens":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&APITokenClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, apitokenImplementors)...); err != nil {
				return err
			}
			o.WithNamedAPITokens(alias, func(wq *APITokenQuery) {
				*wq = *query
			})

		case "oauthprovider":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OauthProviderClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, oauthproviderImplementors)...); err != nil {
				return err
			}
			o.WithNamedOauthprovider(alias, func(wq *OauthProviderQuery) {
				*wq = *query
			})

		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			o.WithNamedUsers(alias, func(wq *UserQuery) {
				*wq = *query
			})

		case "invites":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InviteClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, inviteImplementors)...); err != nil {
				return err
			}
			o.WithNamedInvites(alias, func(wq *InviteQuery) {
				*wq = *query
			})

		case "subscribers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SubscriberClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, subscriberImplementors)...); err != nil {
				return err
			}
			o.WithNamedSubscribers(alias, func(wq *SubscriberQuery) {
				*wq = *query
			})

		case "webhooks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&WebhookClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, webhookImplementors)...); err != nil {
				return err
			}
			o.WithNamedWebhooks(alias, func(wq *WebhookQuery) {
				*wq = *query
			})

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			o.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})

		case "secrets":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HushClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, hushImplementors)...); err != nil {
				return err
			}
			o.WithNamedSecrets(alias, func(wq *HushQuery) {
				*wq = *query
			})

		case "features":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FeatureClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, featureImplementors)...); err != nil {
				return err
			}
			o.WithNamedFeatures(alias, func(wq *FeatureQuery) {
				*wq = *query
			})

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			o.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})

		case "entitlementplans":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntitlementPlanClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entitlementplanImplementors)...); err != nil {
				return err
			}
			o.WithNamedEntitlementplans(alias, func(wq *EntitlementPlanQuery) {
				*wq = *query
			})

		case "entitlementplanfeatures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntitlementPlanFeatureClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entitlementplanfeatureImplementors)...); err != nil {
				return err
			}
			o.WithNamedEntitlementplanfeatures(alias, func(wq *EntitlementPlanFeatureQuery) {
				*wq = *query
			})

		case "entities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entityImplementors)...); err != nil {
				return err
			}
			o.WithNamedEntities(alias, func(wq *EntityQuery) {
				*wq = *query
			})

		case "entitytypes":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EntityTypeClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, entitytypeImplementors)...); err != nil {
				return err
			}
			o.WithNamedEntitytypes(alias, func(wq *EntityTypeQuery) {
				*wq = *query
			})

		case "contacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ContactClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, contactImplementors)...); err != nil {
				return err
			}
			o.WithNamedContacts(alias, func(wq *ContactQuery) {
				*wq = *query
			})

		case "notes":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NoteClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, noteImplementors)...); err != nil {
				return err
			}
			o.WithNamedNotes(alias, func(wq *NoteQuery) {
				*wq = *query
			})

		case "tasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			o.WithNamedTasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "members":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrgMembershipClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, orgmembershipImplementors)...); err != nil {
				return err
			}
			o.WithNamedMembers(alias, func(wq *OrgMembershipQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[organization.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, organization.FieldCreatedAt)
				fieldSeen[organization.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[organization.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, organization.FieldUpdatedAt)
				fieldSeen[organization.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[organization.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, organization.FieldCreatedBy)
				fieldSeen[organization.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[organization.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, organization.FieldUpdatedBy)
				fieldSeen[organization.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[organization.FieldTags]; !ok {
				selectedFields = append(selectedFields, organization.FieldTags)
				fieldSeen[organization.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[organization.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, organization.FieldDeletedAt)
				fieldSeen[organization.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[organization.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, organization.FieldDeletedBy)
				fieldSeen[organization.FieldDeletedBy] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[organization.FieldName]; !ok {
				selectedFields = append(selectedFields, organization.FieldName)
				fieldSeen[organization.FieldName] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[organization.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, organization.FieldDisplayName)
				fieldSeen[organization.FieldDisplayName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[organization.FieldDescription]; !ok {
				selectedFields = append(selectedFields, organization.FieldDescription)
				fieldSeen[organization.FieldDescription] = struct{}{}
			}
		case "personalOrg":
			if _, ok := fieldSeen[organization.FieldPersonalOrg]; !ok {
				selectedFields = append(selectedFields, organization.FieldPersonalOrg)
				fieldSeen[organization.FieldPersonalOrg] = struct{}{}
			}
		case "avatarRemoteURL":
			if _, ok := fieldSeen[organization.FieldAvatarRemoteURL]; !ok {
				selectedFields = append(selectedFields, organization.FieldAvatarRemoteURL)
				fieldSeen[organization.FieldAvatarRemoteURL] = struct{}{}
			}
		case "dedicatedDb":
			if _, ok := fieldSeen[organization.FieldDedicatedDb]; !ok {
				selectedFields = append(selectedFields, organization.FieldDedicatedDb)
				fieldSeen[organization.FieldDedicatedDb] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		o.Select(selectedFields...)
	}
	return nil
}

type organizationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrganizationPaginateOption
}

func newOrganizationPaginateArgs(rv map[string]any) *organizationPaginateArgs {
	args := &organizationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &OrganizationOrder{Field: &OrganizationOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithOrganizationOrder(order))
			}
		case *OrganizationOrder:
			if v != nil {
				args.opts = append(args.opts, WithOrganizationOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*OrganizationWhereInput); ok {
		args.opts = append(args.opts, WithOrganizationFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (oh *OrganizationHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrganizationHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return oh, nil
	}
	if err := oh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return oh, nil
}

func (oh *OrganizationHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(organizationhistory.Columns))
		selectedFields = []string{organizationhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[organizationhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldHistoryTime)
				fieldSeen[organizationhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[organizationhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldRef)
				fieldSeen[organizationhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[organizationhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldOperation)
				fieldSeen[organizationhistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[organizationhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldCreatedAt)
				fieldSeen[organizationhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[organizationhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldUpdatedAt)
				fieldSeen[organizationhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[organizationhistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldCreatedBy)
				fieldSeen[organizationhistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[organizationhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldUpdatedBy)
				fieldSeen[organizationhistory.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[organizationhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldTags)
				fieldSeen[organizationhistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[organizationhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldDeletedAt)
				fieldSeen[organizationhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[organizationhistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldDeletedBy)
				fieldSeen[organizationhistory.FieldDeletedBy] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[organizationhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldName)
				fieldSeen[organizationhistory.FieldName] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[organizationhistory.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldDisplayName)
				fieldSeen[organizationhistory.FieldDisplayName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[organizationhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldDescription)
				fieldSeen[organizationhistory.FieldDescription] = struct{}{}
			}
		case "personalOrg":
			if _, ok := fieldSeen[organizationhistory.FieldPersonalOrg]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldPersonalOrg)
				fieldSeen[organizationhistory.FieldPersonalOrg] = struct{}{}
			}
		case "avatarRemoteURL":
			if _, ok := fieldSeen[organizationhistory.FieldAvatarRemoteURL]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldAvatarRemoteURL)
				fieldSeen[organizationhistory.FieldAvatarRemoteURL] = struct{}{}
			}
		case "dedicatedDb":
			if _, ok := fieldSeen[organizationhistory.FieldDedicatedDb]; !ok {
				selectedFields = append(selectedFields, organizationhistory.FieldDedicatedDb)
				fieldSeen[organizationhistory.FieldDedicatedDb] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		oh.Select(selectedFields...)
	}
	return nil
}

type organizationhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrganizationHistoryPaginateOption
}

func newOrganizationHistoryPaginateArgs(rv map[string]any) *organizationhistoryPaginateArgs {
	args := &organizationhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &OrganizationHistoryOrder{Field: &OrganizationHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithOrganizationHistoryOrder(order))
			}
		case *OrganizationHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithOrganizationHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*OrganizationHistoryWhereInput); ok {
		args.opts = append(args.opts, WithOrganizationHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (os *OrganizationSettingQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrganizationSettingQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return os, nil
	}
	if err := os.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return os, nil
}

func (os *OrganizationSettingQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(organizationsetting.Columns))
		selectedFields = []string{organizationsetting.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: os.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			os.withOrganization = query
			if _, ok := fieldSeen[organizationsetting.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldOrganizationID)
				fieldSeen[organizationsetting.FieldOrganizationID] = struct{}{}
			}

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: os.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			os.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[organizationsetting.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldCreatedAt)
				fieldSeen[organizationsetting.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[organizationsetting.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldUpdatedAt)
				fieldSeen[organizationsetting.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[organizationsetting.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldCreatedBy)
				fieldSeen[organizationsetting.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[organizationsetting.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldUpdatedBy)
				fieldSeen[organizationsetting.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[organizationsetting.FieldTags]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldTags)
				fieldSeen[organizationsetting.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[organizationsetting.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldDeletedAt)
				fieldSeen[organizationsetting.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[organizationsetting.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldDeletedBy)
				fieldSeen[organizationsetting.FieldDeletedBy] = struct{}{}
			}
		case "domains":
			if _, ok := fieldSeen[organizationsetting.FieldDomains]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldDomains)
				fieldSeen[organizationsetting.FieldDomains] = struct{}{}
			}
		case "billingContact":
			if _, ok := fieldSeen[organizationsetting.FieldBillingContact]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldBillingContact)
				fieldSeen[organizationsetting.FieldBillingContact] = struct{}{}
			}
		case "billingEmail":
			if _, ok := fieldSeen[organizationsetting.FieldBillingEmail]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldBillingEmail)
				fieldSeen[organizationsetting.FieldBillingEmail] = struct{}{}
			}
		case "billingPhone":
			if _, ok := fieldSeen[organizationsetting.FieldBillingPhone]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldBillingPhone)
				fieldSeen[organizationsetting.FieldBillingPhone] = struct{}{}
			}
		case "billingAddress":
			if _, ok := fieldSeen[organizationsetting.FieldBillingAddress]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldBillingAddress)
				fieldSeen[organizationsetting.FieldBillingAddress] = struct{}{}
			}
		case "taxIdentifier":
			if _, ok := fieldSeen[organizationsetting.FieldTaxIdentifier]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldTaxIdentifier)
				fieldSeen[organizationsetting.FieldTaxIdentifier] = struct{}{}
			}
		case "geoLocation":
			if _, ok := fieldSeen[organizationsetting.FieldGeoLocation]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldGeoLocation)
				fieldSeen[organizationsetting.FieldGeoLocation] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[organizationsetting.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, organizationsetting.FieldOrganizationID)
				fieldSeen[organizationsetting.FieldOrganizationID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		os.Select(selectedFields...)
	}
	return nil
}

type organizationsettingPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrganizationSettingPaginateOption
}

func newOrganizationSettingPaginateArgs(rv map[string]any) *organizationsettingPaginateArgs {
	args := &organizationsettingPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OrganizationSettingWhereInput); ok {
		args.opts = append(args.opts, WithOrganizationSettingFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (osh *OrganizationSettingHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrganizationSettingHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return osh, nil
	}
	if err := osh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return osh, nil
}

func (osh *OrganizationSettingHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(organizationsettinghistory.Columns))
		selectedFields = []string{organizationsettinghistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[organizationsettinghistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldHistoryTime)
				fieldSeen[organizationsettinghistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[organizationsettinghistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldRef)
				fieldSeen[organizationsettinghistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[organizationsettinghistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldOperation)
				fieldSeen[organizationsettinghistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[organizationsettinghistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldCreatedAt)
				fieldSeen[organizationsettinghistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[organizationsettinghistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldUpdatedAt)
				fieldSeen[organizationsettinghistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[organizationsettinghistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldCreatedBy)
				fieldSeen[organizationsettinghistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[organizationsettinghistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldUpdatedBy)
				fieldSeen[organizationsettinghistory.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[organizationsettinghistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldTags)
				fieldSeen[organizationsettinghistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[organizationsettinghistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldDeletedAt)
				fieldSeen[organizationsettinghistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[organizationsettinghistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldDeletedBy)
				fieldSeen[organizationsettinghistory.FieldDeletedBy] = struct{}{}
			}
		case "domains":
			if _, ok := fieldSeen[organizationsettinghistory.FieldDomains]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldDomains)
				fieldSeen[organizationsettinghistory.FieldDomains] = struct{}{}
			}
		case "billingContact":
			if _, ok := fieldSeen[organizationsettinghistory.FieldBillingContact]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldBillingContact)
				fieldSeen[organizationsettinghistory.FieldBillingContact] = struct{}{}
			}
		case "billingEmail":
			if _, ok := fieldSeen[organizationsettinghistory.FieldBillingEmail]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldBillingEmail)
				fieldSeen[organizationsettinghistory.FieldBillingEmail] = struct{}{}
			}
		case "billingPhone":
			if _, ok := fieldSeen[organizationsettinghistory.FieldBillingPhone]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldBillingPhone)
				fieldSeen[organizationsettinghistory.FieldBillingPhone] = struct{}{}
			}
		case "billingAddress":
			if _, ok := fieldSeen[organizationsettinghistory.FieldBillingAddress]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldBillingAddress)
				fieldSeen[organizationsettinghistory.FieldBillingAddress] = struct{}{}
			}
		case "taxIdentifier":
			if _, ok := fieldSeen[organizationsettinghistory.FieldTaxIdentifier]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldTaxIdentifier)
				fieldSeen[organizationsettinghistory.FieldTaxIdentifier] = struct{}{}
			}
		case "geoLocation":
			if _, ok := fieldSeen[organizationsettinghistory.FieldGeoLocation]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldGeoLocation)
				fieldSeen[organizationsettinghistory.FieldGeoLocation] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[organizationsettinghistory.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, organizationsettinghistory.FieldOrganizationID)
				fieldSeen[organizationsettinghistory.FieldOrganizationID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		osh.Select(selectedFields...)
	}
	return nil
}

type organizationsettinghistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrganizationSettingHistoryPaginateOption
}

func newOrganizationSettingHistoryPaginateArgs(rv map[string]any) *organizationsettinghistoryPaginateArgs {
	args := &organizationsettinghistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OrganizationSettingHistoryWhereInput); ok {
		args.opts = append(args.opts, WithOrganizationSettingHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pat *PersonalAccessTokenQuery) CollectFields(ctx context.Context, satisfies ...string) (*PersonalAccessTokenQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pat, nil
	}
	if err := pat.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pat, nil
}

func (pat *PersonalAccessTokenQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(personalaccesstoken.Columns))
		selectedFields = []string{personalaccesstoken.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pat.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			pat.withOwner = query
			if _, ok := fieldSeen[personalaccesstoken.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldOwnerID)
				fieldSeen[personalaccesstoken.FieldOwnerID] = struct{}{}
			}

		case "organizations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: pat.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			pat.WithNamedOrganizations(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: pat.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			pat.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[personalaccesstoken.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldCreatedAt)
				fieldSeen[personalaccesstoken.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[personalaccesstoken.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldUpdatedAt)
				fieldSeen[personalaccesstoken.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[personalaccesstoken.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldCreatedBy)
				fieldSeen[personalaccesstoken.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[personalaccesstoken.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldUpdatedBy)
				fieldSeen[personalaccesstoken.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[personalaccesstoken.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldDeletedAt)
				fieldSeen[personalaccesstoken.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[personalaccesstoken.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldDeletedBy)
				fieldSeen[personalaccesstoken.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[personalaccesstoken.FieldTags]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldTags)
				fieldSeen[personalaccesstoken.FieldTags] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[personalaccesstoken.FieldName]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldName)
				fieldSeen[personalaccesstoken.FieldName] = struct{}{}
			}
		case "token":
			if _, ok := fieldSeen[personalaccesstoken.FieldToken]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldToken)
				fieldSeen[personalaccesstoken.FieldToken] = struct{}{}
			}
		case "expiresAt":
			if _, ok := fieldSeen[personalaccesstoken.FieldExpiresAt]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldExpiresAt)
				fieldSeen[personalaccesstoken.FieldExpiresAt] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[personalaccesstoken.FieldDescription]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldDescription)
				fieldSeen[personalaccesstoken.FieldDescription] = struct{}{}
			}
		case "scopes":
			if _, ok := fieldSeen[personalaccesstoken.FieldScopes]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldScopes)
				fieldSeen[personalaccesstoken.FieldScopes] = struct{}{}
			}
		case "lastUsedAt":
			if _, ok := fieldSeen[personalaccesstoken.FieldLastUsedAt]; !ok {
				selectedFields = append(selectedFields, personalaccesstoken.FieldLastUsedAt)
				fieldSeen[personalaccesstoken.FieldLastUsedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pat.Select(selectedFields...)
	}
	return nil
}

type personalaccesstokenPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PersonalAccessTokenPaginateOption
}

func newPersonalAccessTokenPaginateArgs(rv map[string]any) *personalaccesstokenPaginateArgs {
	args := &personalaccesstokenPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PersonalAccessTokenWhereInput); ok {
		args.opts = append(args.opts, WithPersonalAccessTokenFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *SubscriberQuery) CollectFields(ctx context.Context, satisfies ...string) (*SubscriberQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *SubscriberQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(subscriber.Columns))
		selectedFields = []string{subscriber.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			s.withOwner = query
			if _, ok := fieldSeen[subscriber.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldOwnerID)
				fieldSeen[subscriber.FieldOwnerID] = struct{}{}
			}

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			s.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[subscriber.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldCreatedAt)
				fieldSeen[subscriber.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[subscriber.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldUpdatedAt)
				fieldSeen[subscriber.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[subscriber.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldCreatedBy)
				fieldSeen[subscriber.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[subscriber.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldUpdatedBy)
				fieldSeen[subscriber.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[subscriber.FieldTags]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldTags)
				fieldSeen[subscriber.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[subscriber.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldDeletedAt)
				fieldSeen[subscriber.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[subscriber.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldDeletedBy)
				fieldSeen[subscriber.FieldDeletedBy] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[subscriber.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldOwnerID)
				fieldSeen[subscriber.FieldOwnerID] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[subscriber.FieldEmail]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldEmail)
				fieldSeen[subscriber.FieldEmail] = struct{}{}
			}
		case "phoneNumber":
			if _, ok := fieldSeen[subscriber.FieldPhoneNumber]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldPhoneNumber)
				fieldSeen[subscriber.FieldPhoneNumber] = struct{}{}
			}
		case "verifiedEmail":
			if _, ok := fieldSeen[subscriber.FieldVerifiedEmail]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldVerifiedEmail)
				fieldSeen[subscriber.FieldVerifiedEmail] = struct{}{}
			}
		case "verifiedPhone":
			if _, ok := fieldSeen[subscriber.FieldVerifiedPhone]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldVerifiedPhone)
				fieldSeen[subscriber.FieldVerifiedPhone] = struct{}{}
			}
		case "active":
			if _, ok := fieldSeen[subscriber.FieldActive]; !ok {
				selectedFields = append(selectedFields, subscriber.FieldActive)
				fieldSeen[subscriber.FieldActive] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type subscriberPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SubscriberPaginateOption
}

func newSubscriberPaginateArgs(rv map[string]any) *subscriberPaginateArgs {
	args := &subscriberPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*SubscriberWhereInput); ok {
		args.opts = append(args.opts, WithSubscriberFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ts *TFASettingQuery) CollectFields(ctx context.Context, satisfies ...string) (*TFASettingQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ts, nil
	}
	if err := ts.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ts, nil
}

func (ts *TFASettingQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(tfasetting.Columns))
		selectedFields = []string{tfasetting.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ts.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			ts.withOwner = query
			if _, ok := fieldSeen[tfasetting.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldOwnerID)
				fieldSeen[tfasetting.FieldOwnerID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[tfasetting.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldCreatedAt)
				fieldSeen[tfasetting.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[tfasetting.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldUpdatedAt)
				fieldSeen[tfasetting.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[tfasetting.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldCreatedBy)
				fieldSeen[tfasetting.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[tfasetting.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldUpdatedBy)
				fieldSeen[tfasetting.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[tfasetting.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldDeletedAt)
				fieldSeen[tfasetting.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[tfasetting.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldDeletedBy)
				fieldSeen[tfasetting.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[tfasetting.FieldTags]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldTags)
				fieldSeen[tfasetting.FieldTags] = struct{}{}
			}
		case "tfaSecret":
			if _, ok := fieldSeen[tfasetting.FieldTfaSecret]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldTfaSecret)
				fieldSeen[tfasetting.FieldTfaSecret] = struct{}{}
			}
		case "verified":
			if _, ok := fieldSeen[tfasetting.FieldVerified]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldVerified)
				fieldSeen[tfasetting.FieldVerified] = struct{}{}
			}
		case "recoveryCodes":
			if _, ok := fieldSeen[tfasetting.FieldRecoveryCodes]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldRecoveryCodes)
				fieldSeen[tfasetting.FieldRecoveryCodes] = struct{}{}
			}
		case "totpAllowed":
			if _, ok := fieldSeen[tfasetting.FieldTotpAllowed]; !ok {
				selectedFields = append(selectedFields, tfasetting.FieldTotpAllowed)
				fieldSeen[tfasetting.FieldTotpAllowed] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ts.Select(selectedFields...)
	}
	return nil
}

type tfasettingPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TFASettingPaginateOption
}

func newTFASettingPaginateArgs(rv map[string]any) *tfasettingPaginateArgs {
	args := &tfasettingPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TFASettingWhereInput); ok {
		args.opts = append(args.opts, WithTFASettingFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TaskQuery) CollectFields(ctx context.Context, satisfies ...string) (*TaskQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TaskQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(task.Columns))
		selectedFields = []string{task.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			t.withUser = query
			if _, ok := fieldSeen[task.FieldAssigner]; !ok {
				selectedFields = append(selectedFields, task.FieldAssigner)
				fieldSeen[task.FieldAssigner] = struct{}{}
			}

		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			t.WithNamedOrganization(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "group":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			t.WithNamedGroup(alias, func(wq *GroupQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[task.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, task.FieldCreatedAt)
				fieldSeen[task.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[task.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, task.FieldUpdatedAt)
				fieldSeen[task.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[task.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, task.FieldCreatedBy)
				fieldSeen[task.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[task.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, task.FieldUpdatedBy)
				fieldSeen[task.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[task.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, task.FieldDeletedAt)
				fieldSeen[task.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[task.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, task.FieldDeletedBy)
				fieldSeen[task.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[task.FieldTags]; !ok {
				selectedFields = append(selectedFields, task.FieldTags)
				fieldSeen[task.FieldTags] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[task.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, task.FieldOrganizationID)
				fieldSeen[task.FieldOrganizationID] = struct{}{}
			}
		case "groupID":
			if _, ok := fieldSeen[task.FieldGroupID]; !ok {
				selectedFields = append(selectedFields, task.FieldGroupID)
				fieldSeen[task.FieldGroupID] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[task.FieldTitle]; !ok {
				selectedFields = append(selectedFields, task.FieldTitle)
				fieldSeen[task.FieldTitle] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[task.FieldDescription]; !ok {
				selectedFields = append(selectedFields, task.FieldDescription)
				fieldSeen[task.FieldDescription] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[task.FieldDetails]; !ok {
				selectedFields = append(selectedFields, task.FieldDetails)
				fieldSeen[task.FieldDetails] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[task.FieldStatus]; !ok {
				selectedFields = append(selectedFields, task.FieldStatus)
				fieldSeen[task.FieldStatus] = struct{}{}
			}
		case "due":
			if _, ok := fieldSeen[task.FieldDue]; !ok {
				selectedFields = append(selectedFields, task.FieldDue)
				fieldSeen[task.FieldDue] = struct{}{}
			}
		case "completed":
			if _, ok := fieldSeen[task.FieldCompleted]; !ok {
				selectedFields = append(selectedFields, task.FieldCompleted)
				fieldSeen[task.FieldCompleted] = struct{}{}
			}
		case "assignee":
			if _, ok := fieldSeen[task.FieldAssignee]; !ok {
				selectedFields = append(selectedFields, task.FieldAssignee)
				fieldSeen[task.FieldAssignee] = struct{}{}
			}
		case "assigner":
			if _, ok := fieldSeen[task.FieldAssigner]; !ok {
				selectedFields = append(selectedFields, task.FieldAssigner)
				fieldSeen[task.FieldAssigner] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type taskPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TaskPaginateOption
}

func newTaskPaginateArgs(rv map[string]any) *taskPaginateArgs {
	args := &taskPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TaskWhereInput); ok {
		args.opts = append(args.opts, WithTaskFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (th *TaskHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*TaskHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return th, nil
	}
	if err := th.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return th, nil
}

func (th *TaskHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(taskhistory.Columns))
		selectedFields = []string{taskhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[taskhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldHistoryTime)
				fieldSeen[taskhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[taskhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldRef)
				fieldSeen[taskhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[taskhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldOperation)
				fieldSeen[taskhistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[taskhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldCreatedAt)
				fieldSeen[taskhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[taskhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldUpdatedAt)
				fieldSeen[taskhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[taskhistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldCreatedBy)
				fieldSeen[taskhistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[taskhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldUpdatedBy)
				fieldSeen[taskhistory.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[taskhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldDeletedAt)
				fieldSeen[taskhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[taskhistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldDeletedBy)
				fieldSeen[taskhistory.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[taskhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldTags)
				fieldSeen[taskhistory.FieldTags] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[taskhistory.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldOrganizationID)
				fieldSeen[taskhistory.FieldOrganizationID] = struct{}{}
			}
		case "groupID":
			if _, ok := fieldSeen[taskhistory.FieldGroupID]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldGroupID)
				fieldSeen[taskhistory.FieldGroupID] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[taskhistory.FieldTitle]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldTitle)
				fieldSeen[taskhistory.FieldTitle] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[taskhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldDescription)
				fieldSeen[taskhistory.FieldDescription] = struct{}{}
			}
		case "details":
			if _, ok := fieldSeen[taskhistory.FieldDetails]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldDetails)
				fieldSeen[taskhistory.FieldDetails] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[taskhistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldStatus)
				fieldSeen[taskhistory.FieldStatus] = struct{}{}
			}
		case "due":
			if _, ok := fieldSeen[taskhistory.FieldDue]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldDue)
				fieldSeen[taskhistory.FieldDue] = struct{}{}
			}
		case "completed":
			if _, ok := fieldSeen[taskhistory.FieldCompleted]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldCompleted)
				fieldSeen[taskhistory.FieldCompleted] = struct{}{}
			}
		case "assignee":
			if _, ok := fieldSeen[taskhistory.FieldAssignee]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldAssignee)
				fieldSeen[taskhistory.FieldAssignee] = struct{}{}
			}
		case "assigner":
			if _, ok := fieldSeen[taskhistory.FieldAssigner]; !ok {
				selectedFields = append(selectedFields, taskhistory.FieldAssigner)
				fieldSeen[taskhistory.FieldAssigner] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		th.Select(selectedFields...)
	}
	return nil
}

type taskhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TaskHistoryPaginateOption
}

func newTaskHistoryPaginateArgs(rv map[string]any) *taskhistoryPaginateArgs {
	args := &taskhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TaskHistoryWhereInput); ok {
		args.opts = append(args.opts, WithTaskHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TemplateQuery) CollectFields(ctx context.Context, satisfies ...string) (*TemplateQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TemplateQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(template.Columns))
		selectedFields = []string{template.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			t.withOwner = query
			if _, ok := fieldSeen[template.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, template.FieldOwnerID)
				fieldSeen[template.FieldOwnerID] = struct{}{}
			}

		case "documents":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentDataClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentdataImplementors)...); err != nil {
				return err
			}
			t.WithNamedDocuments(alias, func(wq *DocumentDataQuery) {
				*wq = *query
			})

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			t.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[template.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, template.FieldCreatedAt)
				fieldSeen[template.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[template.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, template.FieldUpdatedAt)
				fieldSeen[template.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[template.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, template.FieldCreatedBy)
				fieldSeen[template.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[template.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, template.FieldUpdatedBy)
				fieldSeen[template.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[template.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, template.FieldDeletedAt)
				fieldSeen[template.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[template.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, template.FieldDeletedBy)
				fieldSeen[template.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[template.FieldTags]; !ok {
				selectedFields = append(selectedFields, template.FieldTags)
				fieldSeen[template.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[template.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, template.FieldOwnerID)
				fieldSeen[template.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[template.FieldName]; !ok {
				selectedFields = append(selectedFields, template.FieldName)
				fieldSeen[template.FieldName] = struct{}{}
			}
		case "templateType":
			if _, ok := fieldSeen[template.FieldTemplateType]; !ok {
				selectedFields = append(selectedFields, template.FieldTemplateType)
				fieldSeen[template.FieldTemplateType] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[template.FieldDescription]; !ok {
				selectedFields = append(selectedFields, template.FieldDescription)
				fieldSeen[template.FieldDescription] = struct{}{}
			}
		case "jsonconfig":
			if _, ok := fieldSeen[template.FieldJsonconfig]; !ok {
				selectedFields = append(selectedFields, template.FieldJsonconfig)
				fieldSeen[template.FieldJsonconfig] = struct{}{}
			}
		case "uischema":
			if _, ok := fieldSeen[template.FieldUischema]; !ok {
				selectedFields = append(selectedFields, template.FieldUischema)
				fieldSeen[template.FieldUischema] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type templatePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TemplatePaginateOption
}

func newTemplatePaginateArgs(rv map[string]any) *templatePaginateArgs {
	args := &templatePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &TemplateOrder{Field: &TemplateOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithTemplateOrder(order))
			}
		case *TemplateOrder:
			if v != nil {
				args.opts = append(args.opts, WithTemplateOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*TemplateWhereInput); ok {
		args.opts = append(args.opts, WithTemplateFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (th *TemplateHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*TemplateHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return th, nil
	}
	if err := th.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return th, nil
}

func (th *TemplateHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(templatehistory.Columns))
		selectedFields = []string{templatehistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[templatehistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldHistoryTime)
				fieldSeen[templatehistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[templatehistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldRef)
				fieldSeen[templatehistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[templatehistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldOperation)
				fieldSeen[templatehistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[templatehistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldCreatedAt)
				fieldSeen[templatehistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[templatehistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldUpdatedAt)
				fieldSeen[templatehistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[templatehistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldCreatedBy)
				fieldSeen[templatehistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[templatehistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldUpdatedBy)
				fieldSeen[templatehistory.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[templatehistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldDeletedAt)
				fieldSeen[templatehistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[templatehistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldDeletedBy)
				fieldSeen[templatehistory.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[templatehistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldTags)
				fieldSeen[templatehistory.FieldTags] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[templatehistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldOwnerID)
				fieldSeen[templatehistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[templatehistory.FieldName]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldName)
				fieldSeen[templatehistory.FieldName] = struct{}{}
			}
		case "templateType":
			if _, ok := fieldSeen[templatehistory.FieldTemplateType]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldTemplateType)
				fieldSeen[templatehistory.FieldTemplateType] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[templatehistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldDescription)
				fieldSeen[templatehistory.FieldDescription] = struct{}{}
			}
		case "jsonconfig":
			if _, ok := fieldSeen[templatehistory.FieldJsonconfig]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldJsonconfig)
				fieldSeen[templatehistory.FieldJsonconfig] = struct{}{}
			}
		case "uischema":
			if _, ok := fieldSeen[templatehistory.FieldUischema]; !ok {
				selectedFields = append(selectedFields, templatehistory.FieldUischema)
				fieldSeen[templatehistory.FieldUischema] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		th.Select(selectedFields...)
	}
	return nil
}

type templatehistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TemplateHistoryPaginateOption
}

func newTemplateHistoryPaginateArgs(rv map[string]any) *templatehistoryPaginateArgs {
	args := &templatehistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &TemplateHistoryOrder{Field: &TemplateHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithTemplateHistoryOrder(order))
			}
		case *TemplateHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithTemplateHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*TemplateHistoryWhereInput); ok {
		args.opts = append(args.opts, WithTemplateHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "personalAccessTokens":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonalAccessTokenClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, personalaccesstokenImplementors)...); err != nil {
				return err
			}
			u.WithNamedPersonalAccessTokens(alias, func(wq *PersonalAccessTokenQuery) {
				*wq = *query
			})

		case "tfaSettings":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TFASettingClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, tfasettingImplementors)...); err != nil {
				return err
			}
			u.WithNamedTfaSettings(alias, func(wq *TFASettingQuery) {
				*wq = *query
			})

		case "setting":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserSettingClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, usersettingImplementors)...); err != nil {
				return err
			}
			u.withSetting = query

		case "groups":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			u.WithNamedGroups(alias, func(wq *GroupQuery) {
				*wq = *query
			})

		case "organizations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			u.WithNamedOrganizations(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			u.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})

		case "file":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			u.withFile = query
			if _, ok := fieldSeen[user.FieldAvatarLocalFileID]; !ok {
				selectedFields = append(selectedFields, user.FieldAvatarLocalFileID)
				fieldSeen[user.FieldAvatarLocalFileID] = struct{}{}
			}

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			u.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})

		case "tasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			u.WithNamedTasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "groupMemberships":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupMembershipClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupmembershipImplementors)...); err != nil {
				return err
			}
			u.WithNamedGroupMemberships(alias, func(wq *GroupMembershipQuery) {
				*wq = *query
			})

		case "orgMemberships":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrgMembershipClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, orgmembershipImplementors)...); err != nil {
				return err
			}
			u.WithNamedOrgMemberships(alias, func(wq *OrgMembershipQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[user.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldCreatedAt)
				fieldSeen[user.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[user.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldUpdatedAt)
				fieldSeen[user.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[user.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, user.FieldCreatedBy)
				fieldSeen[user.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[user.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, user.FieldUpdatedBy)
				fieldSeen[user.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[user.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldDeletedAt)
				fieldSeen[user.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[user.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, user.FieldDeletedBy)
				fieldSeen[user.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[user.FieldTags]; !ok {
				selectedFields = append(selectedFields, user.FieldTags)
				fieldSeen[user.FieldTags] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[user.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, user.FieldFirstName)
				fieldSeen[user.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[user.FieldLastName]; !ok {
				selectedFields = append(selectedFields, user.FieldLastName)
				fieldSeen[user.FieldLastName] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[user.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, user.FieldDisplayName)
				fieldSeen[user.FieldDisplayName] = struct{}{}
			}
		case "avatarRemoteURL":
			if _, ok := fieldSeen[user.FieldAvatarRemoteURL]; !ok {
				selectedFields = append(selectedFields, user.FieldAvatarRemoteURL)
				fieldSeen[user.FieldAvatarRemoteURL] = struct{}{}
			}
		case "avatarLocalFile":
			if _, ok := fieldSeen[user.FieldAvatarLocalFile]; !ok {
				selectedFields = append(selectedFields, user.FieldAvatarLocalFile)
				fieldSeen[user.FieldAvatarLocalFile] = struct{}{}
			}
		case "avatarLocalFileID":
			if _, ok := fieldSeen[user.FieldAvatarLocalFileID]; !ok {
				selectedFields = append(selectedFields, user.FieldAvatarLocalFileID)
				fieldSeen[user.FieldAvatarLocalFileID] = struct{}{}
			}
		case "avatarUpdatedAt":
			if _, ok := fieldSeen[user.FieldAvatarUpdatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldAvatarUpdatedAt)
				fieldSeen[user.FieldAvatarUpdatedAt] = struct{}{}
			}
		case "lastSeen":
			if _, ok := fieldSeen[user.FieldLastSeen]; !ok {
				selectedFields = append(selectedFields, user.FieldLastSeen)
				fieldSeen[user.FieldLastSeen] = struct{}{}
			}
		case "sub":
			if _, ok := fieldSeen[user.FieldSub]; !ok {
				selectedFields = append(selectedFields, user.FieldSub)
				fieldSeen[user.FieldSub] = struct{}{}
			}
		case "authProvider":
			if _, ok := fieldSeen[user.FieldAuthProvider]; !ok {
				selectedFields = append(selectedFields, user.FieldAuthProvider)
				fieldSeen[user.FieldAuthProvider] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[user.FieldRole]; !ok {
				selectedFields = append(selectedFields, user.FieldRole)
				fieldSeen[user.FieldRole] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &UserOrder{Field: &UserOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserOrder(order))
			}
		case *UserOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*UserWhereInput); ok {
		args.opts = append(args.opts, WithUserFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (uh *UserHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return uh, nil
	}
	if err := uh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return uh, nil
}

func (uh *UserHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(userhistory.Columns))
		selectedFields = []string{userhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[userhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldHistoryTime)
				fieldSeen[userhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[userhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldRef)
				fieldSeen[userhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[userhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldOperation)
				fieldSeen[userhistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[userhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldCreatedAt)
				fieldSeen[userhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[userhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldUpdatedAt)
				fieldSeen[userhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[userhistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldCreatedBy)
				fieldSeen[userhistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[userhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldUpdatedBy)
				fieldSeen[userhistory.FieldUpdatedBy] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[userhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldDeletedAt)
				fieldSeen[userhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[userhistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldDeletedBy)
				fieldSeen[userhistory.FieldDeletedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[userhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldTags)
				fieldSeen[userhistory.FieldTags] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[userhistory.FieldEmail]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldEmail)
				fieldSeen[userhistory.FieldEmail] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[userhistory.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldFirstName)
				fieldSeen[userhistory.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[userhistory.FieldLastName]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldLastName)
				fieldSeen[userhistory.FieldLastName] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[userhistory.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldDisplayName)
				fieldSeen[userhistory.FieldDisplayName] = struct{}{}
			}
		case "avatarRemoteURL":
			if _, ok := fieldSeen[userhistory.FieldAvatarRemoteURL]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldAvatarRemoteURL)
				fieldSeen[userhistory.FieldAvatarRemoteURL] = struct{}{}
			}
		case "avatarLocalFile":
			if _, ok := fieldSeen[userhistory.FieldAvatarLocalFile]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldAvatarLocalFile)
				fieldSeen[userhistory.FieldAvatarLocalFile] = struct{}{}
			}
		case "avatarLocalFileID":
			if _, ok := fieldSeen[userhistory.FieldAvatarLocalFileID]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldAvatarLocalFileID)
				fieldSeen[userhistory.FieldAvatarLocalFileID] = struct{}{}
			}
		case "avatarUpdatedAt":
			if _, ok := fieldSeen[userhistory.FieldAvatarUpdatedAt]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldAvatarUpdatedAt)
				fieldSeen[userhistory.FieldAvatarUpdatedAt] = struct{}{}
			}
		case "lastSeen":
			if _, ok := fieldSeen[userhistory.FieldLastSeen]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldLastSeen)
				fieldSeen[userhistory.FieldLastSeen] = struct{}{}
			}
		case "sub":
			if _, ok := fieldSeen[userhistory.FieldSub]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldSub)
				fieldSeen[userhistory.FieldSub] = struct{}{}
			}
		case "authProvider":
			if _, ok := fieldSeen[userhistory.FieldAuthProvider]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldAuthProvider)
				fieldSeen[userhistory.FieldAuthProvider] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[userhistory.FieldRole]; !ok {
				selectedFields = append(selectedFields, userhistory.FieldRole)
				fieldSeen[userhistory.FieldRole] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		uh.Select(selectedFields...)
	}
	return nil
}

type userhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserHistoryPaginateOption
}

func newUserHistoryPaginateArgs(rv map[string]any) *userhistoryPaginateArgs {
	args := &userhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &UserHistoryOrder{Field: &UserHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserHistoryOrder(order))
			}
		case *UserHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*UserHistoryWhereInput); ok {
		args.opts = append(args.opts, WithUserHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (us *UserSettingQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserSettingQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return us, nil
	}
	if err := us.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return us, nil
}

func (us *UserSettingQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(usersetting.Columns))
		selectedFields = []string{usersetting.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: us.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			us.withUser = query
			if _, ok := fieldSeen[usersetting.FieldUserID]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldUserID)
				fieldSeen[usersetting.FieldUserID] = struct{}{}
			}

		case "defaultOrg":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: us.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			us.withDefaultOrg = query

		case "files":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileClient{config: us.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fileImplementors)...); err != nil {
				return err
			}
			us.WithNamedFiles(alias, func(wq *FileQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[usersetting.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldCreatedAt)
				fieldSeen[usersetting.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[usersetting.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldUpdatedAt)
				fieldSeen[usersetting.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[usersetting.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldCreatedBy)
				fieldSeen[usersetting.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[usersetting.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldUpdatedBy)
				fieldSeen[usersetting.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[usersetting.FieldTags]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldTags)
				fieldSeen[usersetting.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[usersetting.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldDeletedAt)
				fieldSeen[usersetting.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[usersetting.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldDeletedBy)
				fieldSeen[usersetting.FieldDeletedBy] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[usersetting.FieldUserID]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldUserID)
				fieldSeen[usersetting.FieldUserID] = struct{}{}
			}
		case "locked":
			if _, ok := fieldSeen[usersetting.FieldLocked]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldLocked)
				fieldSeen[usersetting.FieldLocked] = struct{}{}
			}
		case "silencedAt":
			if _, ok := fieldSeen[usersetting.FieldSilencedAt]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldSilencedAt)
				fieldSeen[usersetting.FieldSilencedAt] = struct{}{}
			}
		case "suspendedAt":
			if _, ok := fieldSeen[usersetting.FieldSuspendedAt]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldSuspendedAt)
				fieldSeen[usersetting.FieldSuspendedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[usersetting.FieldStatus]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldStatus)
				fieldSeen[usersetting.FieldStatus] = struct{}{}
			}
		case "emailConfirmed":
			if _, ok := fieldSeen[usersetting.FieldEmailConfirmed]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldEmailConfirmed)
				fieldSeen[usersetting.FieldEmailConfirmed] = struct{}{}
			}
		case "isWebauthnAllowed":
			if _, ok := fieldSeen[usersetting.FieldIsWebauthnAllowed]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldIsWebauthnAllowed)
				fieldSeen[usersetting.FieldIsWebauthnAllowed] = struct{}{}
			}
		case "isTfaEnabled":
			if _, ok := fieldSeen[usersetting.FieldIsTfaEnabled]; !ok {
				selectedFields = append(selectedFields, usersetting.FieldIsTfaEnabled)
				fieldSeen[usersetting.FieldIsTfaEnabled] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		us.Select(selectedFields...)
	}
	return nil
}

type usersettingPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserSettingPaginateOption
}

func newUserSettingPaginateArgs(rv map[string]any) *usersettingPaginateArgs {
	args := &usersettingPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*UserSettingWhereInput); ok {
		args.opts = append(args.opts, WithUserSettingFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ush *UserSettingHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserSettingHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ush, nil
	}
	if err := ush.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ush, nil
}

func (ush *UserSettingHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(usersettinghistory.Columns))
		selectedFields = []string{usersettinghistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[usersettinghistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldHistoryTime)
				fieldSeen[usersettinghistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[usersettinghistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldRef)
				fieldSeen[usersettinghistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[usersettinghistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldOperation)
				fieldSeen[usersettinghistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[usersettinghistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldCreatedAt)
				fieldSeen[usersettinghistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[usersettinghistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldUpdatedAt)
				fieldSeen[usersettinghistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[usersettinghistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldCreatedBy)
				fieldSeen[usersettinghistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[usersettinghistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldUpdatedBy)
				fieldSeen[usersettinghistory.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[usersettinghistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldTags)
				fieldSeen[usersettinghistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[usersettinghistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldDeletedAt)
				fieldSeen[usersettinghistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[usersettinghistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldDeletedBy)
				fieldSeen[usersettinghistory.FieldDeletedBy] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[usersettinghistory.FieldUserID]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldUserID)
				fieldSeen[usersettinghistory.FieldUserID] = struct{}{}
			}
		case "locked":
			if _, ok := fieldSeen[usersettinghistory.FieldLocked]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldLocked)
				fieldSeen[usersettinghistory.FieldLocked] = struct{}{}
			}
		case "silencedAt":
			if _, ok := fieldSeen[usersettinghistory.FieldSilencedAt]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldSilencedAt)
				fieldSeen[usersettinghistory.FieldSilencedAt] = struct{}{}
			}
		case "suspendedAt":
			if _, ok := fieldSeen[usersettinghistory.FieldSuspendedAt]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldSuspendedAt)
				fieldSeen[usersettinghistory.FieldSuspendedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[usersettinghistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldStatus)
				fieldSeen[usersettinghistory.FieldStatus] = struct{}{}
			}
		case "emailConfirmed":
			if _, ok := fieldSeen[usersettinghistory.FieldEmailConfirmed]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldEmailConfirmed)
				fieldSeen[usersettinghistory.FieldEmailConfirmed] = struct{}{}
			}
		case "isWebauthnAllowed":
			if _, ok := fieldSeen[usersettinghistory.FieldIsWebauthnAllowed]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldIsWebauthnAllowed)
				fieldSeen[usersettinghistory.FieldIsWebauthnAllowed] = struct{}{}
			}
		case "isTfaEnabled":
			if _, ok := fieldSeen[usersettinghistory.FieldIsTfaEnabled]; !ok {
				selectedFields = append(selectedFields, usersettinghistory.FieldIsTfaEnabled)
				fieldSeen[usersettinghistory.FieldIsTfaEnabled] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ush.Select(selectedFields...)
	}
	return nil
}

type usersettinghistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserSettingHistoryPaginateOption
}

func newUserSettingHistoryPaginateArgs(rv map[string]any) *usersettinghistoryPaginateArgs {
	args := &usersettinghistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*UserSettingHistoryWhereInput); ok {
		args.opts = append(args.opts, WithUserSettingHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (w *WebhookQuery) CollectFields(ctx context.Context, satisfies ...string) (*WebhookQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return w, nil
	}
	if err := w.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return w, nil
}

func (w *WebhookQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(webhook.Columns))
		selectedFields = []string{webhook.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: w.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			w.withOwner = query
			if _, ok := fieldSeen[webhook.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, webhook.FieldOwnerID)
				fieldSeen[webhook.FieldOwnerID] = struct{}{}
			}

		case "events":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EventClient{config: w.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, eventImplementors)...); err != nil {
				return err
			}
			w.WithNamedEvents(alias, func(wq *EventQuery) {
				*wq = *query
			})

		case "integrations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IntegrationClient{config: w.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, integrationImplementors)...); err != nil {
				return err
			}
			w.WithNamedIntegrations(alias, func(wq *IntegrationQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[webhook.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, webhook.FieldCreatedAt)
				fieldSeen[webhook.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[webhook.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, webhook.FieldUpdatedAt)
				fieldSeen[webhook.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[webhook.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, webhook.FieldCreatedBy)
				fieldSeen[webhook.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[webhook.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, webhook.FieldUpdatedBy)
				fieldSeen[webhook.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[webhook.FieldTags]; !ok {
				selectedFields = append(selectedFields, webhook.FieldTags)
				fieldSeen[webhook.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[webhook.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, webhook.FieldDeletedAt)
				fieldSeen[webhook.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[webhook.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, webhook.FieldDeletedBy)
				fieldSeen[webhook.FieldDeletedBy] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[webhook.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, webhook.FieldOwnerID)
				fieldSeen[webhook.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[webhook.FieldName]; !ok {
				selectedFields = append(selectedFields, webhook.FieldName)
				fieldSeen[webhook.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[webhook.FieldDescription]; !ok {
				selectedFields = append(selectedFields, webhook.FieldDescription)
				fieldSeen[webhook.FieldDescription] = struct{}{}
			}
		case "destinationURL":
			if _, ok := fieldSeen[webhook.FieldDestinationURL]; !ok {
				selectedFields = append(selectedFields, webhook.FieldDestinationURL)
				fieldSeen[webhook.FieldDestinationURL] = struct{}{}
			}
		case "enabled":
			if _, ok := fieldSeen[webhook.FieldEnabled]; !ok {
				selectedFields = append(selectedFields, webhook.FieldEnabled)
				fieldSeen[webhook.FieldEnabled] = struct{}{}
			}
		case "failures":
			if _, ok := fieldSeen[webhook.FieldFailures]; !ok {
				selectedFields = append(selectedFields, webhook.FieldFailures)
				fieldSeen[webhook.FieldFailures] = struct{}{}
			}
		case "lastError":
			if _, ok := fieldSeen[webhook.FieldLastError]; !ok {
				selectedFields = append(selectedFields, webhook.FieldLastError)
				fieldSeen[webhook.FieldLastError] = struct{}{}
			}
		case "lastResponse":
			if _, ok := fieldSeen[webhook.FieldLastResponse]; !ok {
				selectedFields = append(selectedFields, webhook.FieldLastResponse)
				fieldSeen[webhook.FieldLastResponse] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		w.Select(selectedFields...)
	}
	return nil
}

type webhookPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WebhookPaginateOption
}

func newWebhookPaginateArgs(rv map[string]any) *webhookPaginateArgs {
	args := &webhookPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &WebhookOrder{Field: &WebhookOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithWebhookOrder(order))
			}
		case *WebhookOrder:
			if v != nil {
				args.opts = append(args.opts, WithWebhookOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*WebhookWhereInput); ok {
		args.opts = append(args.opts, WithWebhookFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (wh *WebhookHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*WebhookHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return wh, nil
	}
	if err := wh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return wh, nil
}

func (wh *WebhookHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(webhookhistory.Columns))
		selectedFields = []string{webhookhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "historyTime":
			if _, ok := fieldSeen[webhookhistory.FieldHistoryTime]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldHistoryTime)
				fieldSeen[webhookhistory.FieldHistoryTime] = struct{}{}
			}
		case "ref":
			if _, ok := fieldSeen[webhookhistory.FieldRef]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldRef)
				fieldSeen[webhookhistory.FieldRef] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[webhookhistory.FieldOperation]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldOperation)
				fieldSeen[webhookhistory.FieldOperation] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[webhookhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldCreatedAt)
				fieldSeen[webhookhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[webhookhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldUpdatedAt)
				fieldSeen[webhookhistory.FieldUpdatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[webhookhistory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldCreatedBy)
				fieldSeen[webhookhistory.FieldCreatedBy] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[webhookhistory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldUpdatedBy)
				fieldSeen[webhookhistory.FieldUpdatedBy] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[webhookhistory.FieldTags]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldTags)
				fieldSeen[webhookhistory.FieldTags] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[webhookhistory.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldDeletedAt)
				fieldSeen[webhookhistory.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[webhookhistory.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldDeletedBy)
				fieldSeen[webhookhistory.FieldDeletedBy] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[webhookhistory.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldOwnerID)
				fieldSeen[webhookhistory.FieldOwnerID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[webhookhistory.FieldName]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldName)
				fieldSeen[webhookhistory.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[webhookhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldDescription)
				fieldSeen[webhookhistory.FieldDescription] = struct{}{}
			}
		case "destinationURL":
			if _, ok := fieldSeen[webhookhistory.FieldDestinationURL]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldDestinationURL)
				fieldSeen[webhookhistory.FieldDestinationURL] = struct{}{}
			}
		case "enabled":
			if _, ok := fieldSeen[webhookhistory.FieldEnabled]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldEnabled)
				fieldSeen[webhookhistory.FieldEnabled] = struct{}{}
			}
		case "failures":
			if _, ok := fieldSeen[webhookhistory.FieldFailures]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldFailures)
				fieldSeen[webhookhistory.FieldFailures] = struct{}{}
			}
		case "lastError":
			if _, ok := fieldSeen[webhookhistory.FieldLastError]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldLastError)
				fieldSeen[webhookhistory.FieldLastError] = struct{}{}
			}
		case "lastResponse":
			if _, ok := fieldSeen[webhookhistory.FieldLastResponse]; !ok {
				selectedFields = append(selectedFields, webhookhistory.FieldLastResponse)
				fieldSeen[webhookhistory.FieldLastResponse] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		wh.Select(selectedFields...)
	}
	return nil
}

type webhookhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WebhookHistoryPaginateOption
}

func newWebhookHistoryPaginateArgs(rv map[string]any) *webhookhistoryPaginateArgs {
	args := &webhookhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &WebhookHistoryOrder{Field: &WebhookHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithWebhookHistoryOrder(order))
			}
		case *WebhookHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithWebhookHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*WebhookHistoryWhereInput); ok {
		args.opts = append(args.opts, WithWebhookHistoryFilter(v.Filter))
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}
