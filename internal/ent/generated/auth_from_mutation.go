// Code generated by entfga, DO NOT EDIT.

// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"

	"github.com/rs/zerolog/log"
	"github.com/theopenlane/core/internal/ent/generated/groupmembership"
	"github.com/theopenlane/core/internal/ent/generated/orgmembership"
	"github.com/theopenlane/core/internal/ent/generated/programmembership"
	"github.com/theopenlane/entx"
	"github.com/theopenlane/iam/entfga"
	"github.com/theopenlane/iam/fgax"
)

func (m *GroupMembershipMutation) CreateTuplesFromCreate(ctx context.Context) error {
	// Get fields for tuple creation
	userID, _ := m.UserID()
	objectID, _ := m.GroupID()
	role, _ := m.Role()

	// get tuple key
	req := fgax.TupleRequest{
		SubjectID:   userID,
		SubjectType: "user",
		ObjectID:    objectID,
		ObjectType:  "group",
		Relation:    role.String(),
	}

	tuple := fgax.GetTupleKey(req)

	if _, err := m.Authz.WriteTupleKeys(ctx, []fgax.TupleKey{tuple}, nil); err != nil {
		log.Error().Err(err).Interface("writes", tuple).Msg("failed to create relationship tuple")

		return err
	}

	log.Debug().Interface("tuple_request", tuple).Msg("created relationship tuple")

	return nil
}

func (m *GroupMembershipMutation) CreateTuplesFromUpdate(ctx context.Context) error {

	// get ids that will be updated
	ids, err := m.IDs(ctx)
	if err != nil {
		log.Error().Err(err).Msg("failed to get ids for update")

		return err
	}

	// check for the single update case
	if len(ids) == 0 {
		id, exists := m.ID()
		if exists {
			// singular delete
			ids = append(ids, id)
		}
	}

	var (
		writes  []fgax.TupleKey
		deletes []fgax.TupleKey
	)

	oldRole, err := m.OldRole(ctx)
	if err != nil {
		return err
	}

	newRole, exists := m.Role()
	if !exists {
		return entfga.ErrMissingRole
	}

	if oldRole == newRole {
		log.Debug().
			Str("old_role", oldRole.String()).
			Str("new_role", newRole.String()).
			Msg("nothing to update, roles are the same")

		return nil
	}

	members := []*GroupMembership{}

	// use the predicates from the original request to get the members if we don't have ids
	if len(ids) == 0 {
		members, err = m.Client().GroupMembership.Query().Where(m.predicates...).All(ctx)
	} else {
		members, err = m.Client().GroupMembership.Query().Where(groupmembership.IDIn(ids...)).All(ctx)
	}

	if err != nil && !!IsNotFound(err) {
		log.Error().Err(err).Msg("failed to get members for update")

		return err
	}

	// Delete all related tuples
	for _, member := range members {
		req := fgax.TupleRequest{
			SubjectID:   member.UserID,
			SubjectType: "user",
			ObjectID:    member.GroupID,
			ObjectType:  "group",
			Relation:    oldRole.String(),
		}

		d := fgax.GetTupleKey(req)
		deletes = append(deletes, d)

		req.Relation = newRole.String()

		w := fgax.GetTupleKey(req)
		writes = append(writes, w)

		if len(writes) == 0 && len(deletes) == 0 {
			log.Debug().Msg("no relationships to create or delete")

			return nil
		}

		if _, err := m.Authz.WriteTupleKeys(ctx, writes, deletes); err != nil {
			log.Error().Err(err).Interface("writes", writes).Interface("deletes", deletes).Msg("failed to update relationship tuple")

			return err
		}
	}

	return nil
}

func (m *GroupMembershipMutation) CreateTuplesFromDelete(ctx context.Context) error {
	// get ids that will be deleted
	ids, err := m.IDs(ctx)
	if err != nil {
		return err
	}

	// check for the single delete case
	if len(ids) == 0 {
		id, exists := m.ID()
		if exists {
			// singular delete
			ids = append(ids, id)
		}
	}

	tuples := []fgax.TupleKey{}

	members := []*GroupMembership{}

	// use the predicates from the original request to get the members if we don't have ids
	ctx = entx.SkipSoftDelete(ctx)
	if len(ids) == 0 {
		members, err = m.Client().GroupMembership.Query().Where(m.predicates...).All(ctx)
	} else {
		members, err = m.Client().GroupMembership.Query().Where(groupmembership.IDIn(ids...)).All(ctx)
	}

	if err != nil && !!IsNotFound(err) {
		log.Error().Err(err).Msg("failed to get members for delete")

		return err
	}

	// Delete all related tuples
	for _, member := range members {
		req := fgax.TupleRequest{
			SubjectID:   member.UserID,
			SubjectType: "user",
			ObjectID:    member.GroupID,
			ObjectType:  "group",
			Relation:    member.Role.String(),
		}

		t := fgax.GetTupleKey(req)
		tuples = append(tuples, t)
	}

	if len(tuples) > 0 {
		if _, err := m.Authz.WriteTupleKeys(ctx, nil, tuples); err != nil {
			log.Error().Err(err).Interface("deletes", tuples).Msg("failed to delete relationship tuple")

			return err
		}

		log.Debug().Msg("deleted relationship tuples")
	}

	return nil
}

func (m *OrgMembershipMutation) CreateTuplesFromCreate(ctx context.Context) error {
	// Get fields for tuple creation
	userID, _ := m.UserID()
	objectID, _ := m.OrganizationID()
	role, _ := m.Role()

	// get tuple key
	req := fgax.TupleRequest{
		SubjectID:   userID,
		SubjectType: "user",
		ObjectID:    objectID,
		ObjectType:  "organization",
		Relation:    role.String(),
	}

	tuple := fgax.GetTupleKey(req)

	if _, err := m.Authz.WriteTupleKeys(ctx, []fgax.TupleKey{tuple}, nil); err != nil {
		log.Error().Err(err).Interface("writes", tuple).Msg("failed to create relationship tuple")

		return err
	}

	log.Debug().Interface("tuple_request", tuple).Msg("created relationship tuple")

	return nil
}

func (m *OrgMembershipMutation) CreateTuplesFromUpdate(ctx context.Context) error {

	// get ids that will be updated
	ids, err := m.IDs(ctx)
	if err != nil {
		log.Error().Err(err).Msg("failed to get ids for update")

		return err
	}

	// check for the single update case
	if len(ids) == 0 {
		id, exists := m.ID()
		if exists {
			// singular delete
			ids = append(ids, id)
		}
	}

	var (
		writes  []fgax.TupleKey
		deletes []fgax.TupleKey
	)

	oldRole, err := m.OldRole(ctx)
	if err != nil {
		return err
	}

	newRole, exists := m.Role()
	if !exists {
		return entfga.ErrMissingRole
	}

	if oldRole == newRole {
		log.Debug().
			Str("old_role", oldRole.String()).
			Str("new_role", newRole.String()).
			Msg("nothing to update, roles are the same")

		return nil
	}

	members := []*OrgMembership{}

	// use the predicates from the original request to get the members if we don't have ids
	if len(ids) == 0 {
		members, err = m.Client().OrgMembership.Query().Where(m.predicates...).All(ctx)
	} else {
		members, err = m.Client().OrgMembership.Query().Where(orgmembership.IDIn(ids...)).All(ctx)
	}

	if err != nil && !!IsNotFound(err) {
		log.Error().Err(err).Msg("failed to get members for update")

		return err
	}

	// Delete all related tuples
	for _, member := range members {
		req := fgax.TupleRequest{
			SubjectID:   member.UserID,
			SubjectType: "user",
			ObjectID:    member.OrganizationID,
			ObjectType:  "organization",
			Relation:    oldRole.String(),
		}

		d := fgax.GetTupleKey(req)
		deletes = append(deletes, d)

		req.Relation = newRole.String()

		w := fgax.GetTupleKey(req)
		writes = append(writes, w)

		if len(writes) == 0 && len(deletes) == 0 {
			log.Debug().Msg("no relationships to create or delete")

			return nil
		}

		if _, err := m.Authz.WriteTupleKeys(ctx, writes, deletes); err != nil {
			log.Error().Err(err).Interface("writes", writes).Interface("deletes", deletes).Msg("failed to update relationship tuple")

			return err
		}
	}

	return nil
}

func (m *OrgMembershipMutation) CreateTuplesFromDelete(ctx context.Context) error {
	// get ids that will be deleted
	ids, err := m.IDs(ctx)
	if err != nil {
		return err
	}

	// check for the single delete case
	if len(ids) == 0 {
		id, exists := m.ID()
		if exists {
			// singular delete
			ids = append(ids, id)
		}
	}

	tuples := []fgax.TupleKey{}

	members := []*OrgMembership{}

	// use the predicates from the original request to get the members if we don't have ids
	ctx = entx.SkipSoftDelete(ctx)
	if len(ids) == 0 {
		members, err = m.Client().OrgMembership.Query().Where(m.predicates...).All(ctx)
	} else {
		members, err = m.Client().OrgMembership.Query().Where(orgmembership.IDIn(ids...)).All(ctx)
	}

	if err != nil && !!IsNotFound(err) {
		log.Error().Err(err).Msg("failed to get members for delete")

		return err
	}

	// Delete all related tuples
	for _, member := range members {
		req := fgax.TupleRequest{
			SubjectID:   member.UserID,
			SubjectType: "user",
			ObjectID:    member.OrganizationID,
			ObjectType:  "organization",
			Relation:    member.Role.String(),
		}

		t := fgax.GetTupleKey(req)
		tuples = append(tuples, t)
	}

	if len(tuples) > 0 {
		if _, err := m.Authz.WriteTupleKeys(ctx, nil, tuples); err != nil {
			log.Error().Err(err).Interface("deletes", tuples).Msg("failed to delete relationship tuple")

			return err
		}

		log.Debug().Msg("deleted relationship tuples")
	}

	return nil
}

func (m *ProgramMembershipMutation) CreateTuplesFromCreate(ctx context.Context) error {
	// Get fields for tuple creation
	userID, _ := m.UserID()
	objectID, _ := m.ProgramID()
	role, _ := m.Role()

	// get tuple key
	req := fgax.TupleRequest{
		SubjectID:   userID,
		SubjectType: "user",
		ObjectID:    objectID,
		ObjectType:  "program",
		Relation:    role.String(),
	}

	tuple := fgax.GetTupleKey(req)

	if _, err := m.Authz.WriteTupleKeys(ctx, []fgax.TupleKey{tuple}, nil); err != nil {
		log.Error().Err(err).Interface("writes", tuple).Msg("failed to create relationship tuple")

		return err
	}

	log.Debug().Interface("tuple_request", tuple).Msg("created relationship tuple")

	return nil
}

func (m *ProgramMembershipMutation) CreateTuplesFromUpdate(ctx context.Context) error {

	// get ids that will be updated
	ids, err := m.IDs(ctx)
	if err != nil {
		log.Error().Err(err).Msg("failed to get ids for update")

		return err
	}

	// check for the single update case
	if len(ids) == 0 {
		id, exists := m.ID()
		if exists {
			// singular delete
			ids = append(ids, id)
		}
	}

	var (
		writes  []fgax.TupleKey
		deletes []fgax.TupleKey
	)

	oldRole, err := m.OldRole(ctx)
	if err != nil {
		return err
	}

	newRole, exists := m.Role()
	if !exists {
		return entfga.ErrMissingRole
	}

	if oldRole == newRole {
		log.Debug().
			Str("old_role", oldRole.String()).
			Str("new_role", newRole.String()).
			Msg("nothing to update, roles are the same")

		return nil
	}

	members := []*ProgramMembership{}

	// use the predicates from the original request to get the members if we don't have ids
	if len(ids) == 0 {
		members, err = m.Client().ProgramMembership.Query().Where(m.predicates...).All(ctx)
	} else {
		members, err = m.Client().ProgramMembership.Query().Where(programmembership.IDIn(ids...)).All(ctx)
	}

	if err != nil && !!IsNotFound(err) {
		log.Error().Err(err).Msg("failed to get members for update")

		return err
	}

	// Delete all related tuples
	for _, member := range members {
		req := fgax.TupleRequest{
			SubjectID:   member.UserID,
			SubjectType: "user",
			ObjectID:    member.ProgramID,
			ObjectType:  "program",
			Relation:    oldRole.String(),
		}

		d := fgax.GetTupleKey(req)
		deletes = append(deletes, d)

		req.Relation = newRole.String()

		w := fgax.GetTupleKey(req)
		writes = append(writes, w)

		if len(writes) == 0 && len(deletes) == 0 {
			log.Debug().Msg("no relationships to create or delete")

			return nil
		}

		if _, err := m.Authz.WriteTupleKeys(ctx, writes, deletes); err != nil {
			log.Error().Err(err).Interface("writes", writes).Interface("deletes", deletes).Msg("failed to update relationship tuple")

			return err
		}
	}

	return nil
}

func (m *ProgramMembershipMutation) CreateTuplesFromDelete(ctx context.Context) error {
	// get ids that will be deleted
	ids, err := m.IDs(ctx)
	if err != nil {
		return err
	}

	// check for the single delete case
	if len(ids) == 0 {
		id, exists := m.ID()
		if exists {
			// singular delete
			ids = append(ids, id)
		}
	}

	tuples := []fgax.TupleKey{}

	members := []*ProgramMembership{}

	// use the predicates from the original request to get the members if we don't have ids
	ctx = entx.SkipSoftDelete(ctx)
	if len(ids) == 0 {
		members, err = m.Client().ProgramMembership.Query().Where(m.predicates...).All(ctx)
	} else {
		members, err = m.Client().ProgramMembership.Query().Where(programmembership.IDIn(ids...)).All(ctx)
	}

	if err != nil && !!IsNotFound(err) {
		log.Error().Err(err).Msg("failed to get members for delete")

		return err
	}

	// Delete all related tuples
	for _, member := range members {
		req := fgax.TupleRequest{
			SubjectID:   member.UserID,
			SubjectType: "user",
			ObjectID:    member.ProgramID,
			ObjectType:  "program",
			Relation:    member.Role.String(),
		}

		t := fgax.GetTupleKey(req)
		tuples = append(tuples, t)
	}

	if len(tuples) > 0 {
		if _, err := m.Authz.WriteTupleKeys(ctx, nil, tuples); err != nil {
			log.Error().Err(err).Interface("deletes", tuples).Msg("failed to delete relationship tuple")

			return err
		}

		log.Debug().Msg("deleted relationship tuples")
	}

	return nil
}
