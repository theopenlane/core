// Code generated by ent, DO NOT EDIT.

package generated

import (
	"errors"
	"fmt"
	"time"

	"github.com/theopenlane/core/internal/ent/generated/actionplan"
	"github.com/theopenlane/core/internal/ent/generated/actionplanhistory"
	"github.com/theopenlane/core/internal/ent/generated/apitoken"
	"github.com/theopenlane/core/internal/ent/generated/contact"
	"github.com/theopenlane/core/internal/ent/generated/contacthistory"
	"github.com/theopenlane/core/internal/ent/generated/control"
	"github.com/theopenlane/core/internal/ent/generated/controlhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlimplementation"
	"github.com/theopenlane/core/internal/ent/generated/controlimplementationhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlobjective"
	"github.com/theopenlane/core/internal/ent/generated/controlobjectivehistory"
	"github.com/theopenlane/core/internal/ent/generated/controlscheduledjob"
	"github.com/theopenlane/core/internal/ent/generated/controlscheduledjobhistory"
	"github.com/theopenlane/core/internal/ent/generated/customdomain"
	"github.com/theopenlane/core/internal/ent/generated/customdomainhistory"
	"github.com/theopenlane/core/internal/ent/generated/dnsverification"
	"github.com/theopenlane/core/internal/ent/generated/dnsverificationhistory"
	"github.com/theopenlane/core/internal/ent/generated/documentdata"
	"github.com/theopenlane/core/internal/ent/generated/documentdatahistory"
	"github.com/theopenlane/core/internal/ent/generated/entity"
	"github.com/theopenlane/core/internal/ent/generated/entityhistory"
	"github.com/theopenlane/core/internal/ent/generated/entitytype"
	"github.com/theopenlane/core/internal/ent/generated/entitytypehistory"
	"github.com/theopenlane/core/internal/ent/generated/event"
	"github.com/theopenlane/core/internal/ent/generated/evidence"
	"github.com/theopenlane/core/internal/ent/generated/evidencehistory"
	"github.com/theopenlane/core/internal/ent/generated/file"
	"github.com/theopenlane/core/internal/ent/generated/filehistory"
	"github.com/theopenlane/core/internal/ent/generated/group"
	"github.com/theopenlane/core/internal/ent/generated/grouphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupmembership"
	"github.com/theopenlane/core/internal/ent/generated/groupmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupsetting"
	"github.com/theopenlane/core/internal/ent/generated/groupsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/hush"
	"github.com/theopenlane/core/internal/ent/generated/hushhistory"
	"github.com/theopenlane/core/internal/ent/generated/integration"
	"github.com/theopenlane/core/internal/ent/generated/integrationhistory"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicy"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicyhistory"
	"github.com/theopenlane/core/internal/ent/generated/invite"
	"github.com/theopenlane/core/internal/ent/generated/jobresult"
	"github.com/theopenlane/core/internal/ent/generated/jobrunner"
	"github.com/theopenlane/core/internal/ent/generated/jobrunnerregistrationtoken"
	"github.com/theopenlane/core/internal/ent/generated/jobrunnertoken"
	"github.com/theopenlane/core/internal/ent/generated/mappabledomain"
	"github.com/theopenlane/core/internal/ent/generated/mappabledomainhistory"
	"github.com/theopenlane/core/internal/ent/generated/mappedcontrol"
	"github.com/theopenlane/core/internal/ent/generated/mappedcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/narrative"
	"github.com/theopenlane/core/internal/ent/generated/narrativehistory"
	"github.com/theopenlane/core/internal/ent/generated/note"
	"github.com/theopenlane/core/internal/ent/generated/notehistory"
	"github.com/theopenlane/core/internal/ent/generated/onboarding"
	"github.com/theopenlane/core/internal/ent/generated/organization"
	"github.com/theopenlane/core/internal/ent/generated/organizationhistory"
	"github.com/theopenlane/core/internal/ent/generated/organizationsetting"
	"github.com/theopenlane/core/internal/ent/generated/organizationsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/orgmembership"
	"github.com/theopenlane/core/internal/ent/generated/orgmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/orgsubscription"
	"github.com/theopenlane/core/internal/ent/generated/orgsubscriptionhistory"
	"github.com/theopenlane/core/internal/ent/generated/personalaccesstoken"
	"github.com/theopenlane/core/internal/ent/generated/predicate"
	"github.com/theopenlane/core/internal/ent/generated/procedure"
	"github.com/theopenlane/core/internal/ent/generated/procedurehistory"
	"github.com/theopenlane/core/internal/ent/generated/program"
	"github.com/theopenlane/core/internal/ent/generated/programhistory"
	"github.com/theopenlane/core/internal/ent/generated/programmembership"
	"github.com/theopenlane/core/internal/ent/generated/programmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/risk"
	"github.com/theopenlane/core/internal/ent/generated/riskhistory"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjob"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjobhistory"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjobrun"
	"github.com/theopenlane/core/internal/ent/generated/standard"
	"github.com/theopenlane/core/internal/ent/generated/standardhistory"
	"github.com/theopenlane/core/internal/ent/generated/subcontrol"
	"github.com/theopenlane/core/internal/ent/generated/subcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/subscriber"
	"github.com/theopenlane/core/internal/ent/generated/task"
	"github.com/theopenlane/core/internal/ent/generated/taskhistory"
	"github.com/theopenlane/core/internal/ent/generated/template"
	"github.com/theopenlane/core/internal/ent/generated/templatehistory"
	"github.com/theopenlane/core/internal/ent/generated/tfasetting"
	"github.com/theopenlane/core/internal/ent/generated/user"
	"github.com/theopenlane/core/internal/ent/generated/userhistory"
	"github.com/theopenlane/core/internal/ent/generated/usersetting"
	"github.com/theopenlane/core/internal/ent/generated/usersettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/webauthn"
	"github.com/theopenlane/core/pkg/enums"
	"github.com/theopenlane/core/pkg/models"
	"github.com/theopenlane/entx/history"
)

// APITokenWhereInput represents a where input for filtering APIToken queries.
type APITokenWhereInput struct {
	Predicates []predicate.APIToken  `json:"-"`
	Not        *APITokenWhereInput   `json:"not,omitempty"`
	Or         []*APITokenWhereInput `json:"or,omitempty"`
	And        []*APITokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "expires_at" field predicates.
	ExpiresAt       *time.Time  `json:"expiresAt,omitempty"`
	ExpiresAtNEQ    *time.Time  `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGT     *time.Time  `json:"expiresAtGT,omitempty"`
	ExpiresAtGTE    *time.Time  `json:"expiresAtGTE,omitempty"`
	ExpiresAtLT     *time.Time  `json:"expiresAtLT,omitempty"`
	ExpiresAtLTE    *time.Time  `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil bool        `json:"expiresAtNotNil,omitempty"`

	// "last_used_at" field predicates.
	LastUsedAt       *time.Time  `json:"lastUsedAt,omitempty"`
	LastUsedAtNEQ    *time.Time  `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGT     *time.Time  `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGTE    *time.Time  `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLT     *time.Time  `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLTE    *time.Time  `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil bool        `json:"lastUsedAtNotNil,omitempty"`

	// "is_active" field predicates.
	IsActive       *bool `json:"isActive,omitempty"`
	IsActiveNEQ    *bool `json:"isActiveNEQ,omitempty"`
	IsActiveIsNil  bool  `json:"isActiveIsNil,omitempty"`
	IsActiveNotNil bool  `json:"isActiveNotNil,omitempty"`

	// "revoked_reason" field predicates.
	RevokedReason             *string  `json:"revokedReason,omitempty"`
	RevokedReasonNEQ          *string  `json:"revokedReasonNEQ,omitempty"`
	RevokedReasonIn           []string `json:"revokedReasonIn,omitempty"`
	RevokedReasonNotIn        []string `json:"revokedReasonNotIn,omitempty"`
	RevokedReasonGT           *string  `json:"revokedReasonGT,omitempty"`
	RevokedReasonGTE          *string  `json:"revokedReasonGTE,omitempty"`
	RevokedReasonLT           *string  `json:"revokedReasonLT,omitempty"`
	RevokedReasonLTE          *string  `json:"revokedReasonLTE,omitempty"`
	RevokedReasonContains     *string  `json:"revokedReasonContains,omitempty"`
	RevokedReasonHasPrefix    *string  `json:"revokedReasonHasPrefix,omitempty"`
	RevokedReasonHasSuffix    *string  `json:"revokedReasonHasSuffix,omitempty"`
	RevokedReasonIsNil        bool     `json:"revokedReasonIsNil,omitempty"`
	RevokedReasonNotNil       bool     `json:"revokedReasonNotNil,omitempty"`
	RevokedReasonEqualFold    *string  `json:"revokedReasonEqualFold,omitempty"`
	RevokedReasonContainsFold *string  `json:"revokedReasonContainsFold,omitempty"`

	// "revoked_by" field predicates.
	RevokedBy             *string  `json:"revokedBy,omitempty"`
	RevokedByNEQ          *string  `json:"revokedByNEQ,omitempty"`
	RevokedByIn           []string `json:"revokedByIn,omitempty"`
	RevokedByNotIn        []string `json:"revokedByNotIn,omitempty"`
	RevokedByGT           *string  `json:"revokedByGT,omitempty"`
	RevokedByGTE          *string  `json:"revokedByGTE,omitempty"`
	RevokedByLT           *string  `json:"revokedByLT,omitempty"`
	RevokedByLTE          *string  `json:"revokedByLTE,omitempty"`
	RevokedByContains     *string  `json:"revokedByContains,omitempty"`
	RevokedByHasPrefix    *string  `json:"revokedByHasPrefix,omitempty"`
	RevokedByHasSuffix    *string  `json:"revokedByHasSuffix,omitempty"`
	RevokedByIsNil        bool     `json:"revokedByIsNil,omitempty"`
	RevokedByNotNil       bool     `json:"revokedByNotNil,omitempty"`
	RevokedByEqualFold    *string  `json:"revokedByEqualFold,omitempty"`
	RevokedByContainsFold *string  `json:"revokedByContainsFold,omitempty"`

	// "revoked_at" field predicates.
	RevokedAt       *time.Time  `json:"revokedAt,omitempty"`
	RevokedAtNEQ    *time.Time  `json:"revokedAtNEQ,omitempty"`
	RevokedAtIn     []time.Time `json:"revokedAtIn,omitempty"`
	RevokedAtNotIn  []time.Time `json:"revokedAtNotIn,omitempty"`
	RevokedAtGT     *time.Time  `json:"revokedAtGT,omitempty"`
	RevokedAtGTE    *time.Time  `json:"revokedAtGTE,omitempty"`
	RevokedAtLT     *time.Time  `json:"revokedAtLT,omitempty"`
	RevokedAtLTE    *time.Time  `json:"revokedAtLTE,omitempty"`
	RevokedAtIsNil  bool        `json:"revokedAtIsNil,omitempty"`
	RevokedAtNotNil bool        `json:"revokedAtNotNil,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *APITokenWhereInput) AddPredicates(predicates ...predicate.APIToken) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the APITokenWhereInput filter on the APITokenQuery builder.
func (i *APITokenWhereInput) Filter(q *APITokenQuery) (*APITokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAPITokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAPITokenWhereInput is returned in case the APITokenWhereInput is empty.
var ErrEmptyAPITokenWhereInput = errors.New("generated: empty predicate APITokenWhereInput")

// P returns a predicate for filtering apitokens.
// An error is returned if the input is empty or invalid.
func (i *APITokenWhereInput) P() (predicate.APIToken, error) {
	var predicates []predicate.APIToken
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, apitoken.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.APIToken, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, apitoken.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.APIToken, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, apitoken.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, apitoken.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, apitoken.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, apitoken.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, apitoken.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, apitoken.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, apitoken.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, apitoken.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, apitoken.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, apitoken.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, apitoken.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, apitoken.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, apitoken.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, apitoken.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, apitoken.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, apitoken.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, apitoken.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, apitoken.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, apitoken.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, apitoken.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, apitoken.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, apitoken.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, apitoken.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, apitoken.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, apitoken.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, apitoken.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, apitoken.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, apitoken.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, apitoken.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, apitoken.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, apitoken.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, apitoken.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, apitoken.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, apitoken.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, apitoken.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, apitoken.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, apitoken.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, apitoken.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, apitoken.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, apitoken.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, apitoken.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, apitoken.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, apitoken.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, apitoken.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, apitoken.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, apitoken.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, apitoken.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, apitoken.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, apitoken.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, apitoken.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, apitoken.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, apitoken.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, apitoken.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, apitoken.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, apitoken.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, apitoken.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, apitoken.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, apitoken.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, apitoken.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, apitoken.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, apitoken.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, apitoken.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, apitoken.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, apitoken.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, apitoken.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, apitoken.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, apitoken.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, apitoken.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, apitoken.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, apitoken.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, apitoken.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, apitoken.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, apitoken.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, apitoken.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, apitoken.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, apitoken.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, apitoken.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, apitoken.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, apitoken.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, apitoken.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, apitoken.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, apitoken.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, apitoken.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, apitoken.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, apitoken.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, apitoken.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, apitoken.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, apitoken.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, apitoken.NameContainsFold(*i.NameContainsFold))
	}
	if i.ExpiresAt != nil {
		predicates = append(predicates, apitoken.ExpiresAtEQ(*i.ExpiresAt))
	}
	if i.ExpiresAtNEQ != nil {
		predicates = append(predicates, apitoken.ExpiresAtNEQ(*i.ExpiresAtNEQ))
	}
	if len(i.ExpiresAtIn) > 0 {
		predicates = append(predicates, apitoken.ExpiresAtIn(i.ExpiresAtIn...))
	}
	if len(i.ExpiresAtNotIn) > 0 {
		predicates = append(predicates, apitoken.ExpiresAtNotIn(i.ExpiresAtNotIn...))
	}
	if i.ExpiresAtGT != nil {
		predicates = append(predicates, apitoken.ExpiresAtGT(*i.ExpiresAtGT))
	}
	if i.ExpiresAtGTE != nil {
		predicates = append(predicates, apitoken.ExpiresAtGTE(*i.ExpiresAtGTE))
	}
	if i.ExpiresAtLT != nil {
		predicates = append(predicates, apitoken.ExpiresAtLT(*i.ExpiresAtLT))
	}
	if i.ExpiresAtLTE != nil {
		predicates = append(predicates, apitoken.ExpiresAtLTE(*i.ExpiresAtLTE))
	}
	if i.ExpiresAtIsNil {
		predicates = append(predicates, apitoken.ExpiresAtIsNil())
	}
	if i.ExpiresAtNotNil {
		predicates = append(predicates, apitoken.ExpiresAtNotNil())
	}
	if i.LastUsedAt != nil {
		predicates = append(predicates, apitoken.LastUsedAtEQ(*i.LastUsedAt))
	}
	if i.LastUsedAtNEQ != nil {
		predicates = append(predicates, apitoken.LastUsedAtNEQ(*i.LastUsedAtNEQ))
	}
	if len(i.LastUsedAtIn) > 0 {
		predicates = append(predicates, apitoken.LastUsedAtIn(i.LastUsedAtIn...))
	}
	if len(i.LastUsedAtNotIn) > 0 {
		predicates = append(predicates, apitoken.LastUsedAtNotIn(i.LastUsedAtNotIn...))
	}
	if i.LastUsedAtGT != nil {
		predicates = append(predicates, apitoken.LastUsedAtGT(*i.LastUsedAtGT))
	}
	if i.LastUsedAtGTE != nil {
		predicates = append(predicates, apitoken.LastUsedAtGTE(*i.LastUsedAtGTE))
	}
	if i.LastUsedAtLT != nil {
		predicates = append(predicates, apitoken.LastUsedAtLT(*i.LastUsedAtLT))
	}
	if i.LastUsedAtLTE != nil {
		predicates = append(predicates, apitoken.LastUsedAtLTE(*i.LastUsedAtLTE))
	}
	if i.LastUsedAtIsNil {
		predicates = append(predicates, apitoken.LastUsedAtIsNil())
	}
	if i.LastUsedAtNotNil {
		predicates = append(predicates, apitoken.LastUsedAtNotNil())
	}
	if i.IsActive != nil {
		predicates = append(predicates, apitoken.IsActiveEQ(*i.IsActive))
	}
	if i.IsActiveNEQ != nil {
		predicates = append(predicates, apitoken.IsActiveNEQ(*i.IsActiveNEQ))
	}
	if i.IsActiveIsNil {
		predicates = append(predicates, apitoken.IsActiveIsNil())
	}
	if i.IsActiveNotNil {
		predicates = append(predicates, apitoken.IsActiveNotNil())
	}
	if i.RevokedReason != nil {
		predicates = append(predicates, apitoken.RevokedReasonEQ(*i.RevokedReason))
	}
	if i.RevokedReasonNEQ != nil {
		predicates = append(predicates, apitoken.RevokedReasonNEQ(*i.RevokedReasonNEQ))
	}
	if len(i.RevokedReasonIn) > 0 {
		predicates = append(predicates, apitoken.RevokedReasonIn(i.RevokedReasonIn...))
	}
	if len(i.RevokedReasonNotIn) > 0 {
		predicates = append(predicates, apitoken.RevokedReasonNotIn(i.RevokedReasonNotIn...))
	}
	if i.RevokedReasonGT != nil {
		predicates = append(predicates, apitoken.RevokedReasonGT(*i.RevokedReasonGT))
	}
	if i.RevokedReasonGTE != nil {
		predicates = append(predicates, apitoken.RevokedReasonGTE(*i.RevokedReasonGTE))
	}
	if i.RevokedReasonLT != nil {
		predicates = append(predicates, apitoken.RevokedReasonLT(*i.RevokedReasonLT))
	}
	if i.RevokedReasonLTE != nil {
		predicates = append(predicates, apitoken.RevokedReasonLTE(*i.RevokedReasonLTE))
	}
	if i.RevokedReasonContains != nil {
		predicates = append(predicates, apitoken.RevokedReasonContains(*i.RevokedReasonContains))
	}
	if i.RevokedReasonHasPrefix != nil {
		predicates = append(predicates, apitoken.RevokedReasonHasPrefix(*i.RevokedReasonHasPrefix))
	}
	if i.RevokedReasonHasSuffix != nil {
		predicates = append(predicates, apitoken.RevokedReasonHasSuffix(*i.RevokedReasonHasSuffix))
	}
	if i.RevokedReasonIsNil {
		predicates = append(predicates, apitoken.RevokedReasonIsNil())
	}
	if i.RevokedReasonNotNil {
		predicates = append(predicates, apitoken.RevokedReasonNotNil())
	}
	if i.RevokedReasonEqualFold != nil {
		predicates = append(predicates, apitoken.RevokedReasonEqualFold(*i.RevokedReasonEqualFold))
	}
	if i.RevokedReasonContainsFold != nil {
		predicates = append(predicates, apitoken.RevokedReasonContainsFold(*i.RevokedReasonContainsFold))
	}
	if i.RevokedBy != nil {
		predicates = append(predicates, apitoken.RevokedByEQ(*i.RevokedBy))
	}
	if i.RevokedByNEQ != nil {
		predicates = append(predicates, apitoken.RevokedByNEQ(*i.RevokedByNEQ))
	}
	if len(i.RevokedByIn) > 0 {
		predicates = append(predicates, apitoken.RevokedByIn(i.RevokedByIn...))
	}
	if len(i.RevokedByNotIn) > 0 {
		predicates = append(predicates, apitoken.RevokedByNotIn(i.RevokedByNotIn...))
	}
	if i.RevokedByGT != nil {
		predicates = append(predicates, apitoken.RevokedByGT(*i.RevokedByGT))
	}
	if i.RevokedByGTE != nil {
		predicates = append(predicates, apitoken.RevokedByGTE(*i.RevokedByGTE))
	}
	if i.RevokedByLT != nil {
		predicates = append(predicates, apitoken.RevokedByLT(*i.RevokedByLT))
	}
	if i.RevokedByLTE != nil {
		predicates = append(predicates, apitoken.RevokedByLTE(*i.RevokedByLTE))
	}
	if i.RevokedByContains != nil {
		predicates = append(predicates, apitoken.RevokedByContains(*i.RevokedByContains))
	}
	if i.RevokedByHasPrefix != nil {
		predicates = append(predicates, apitoken.RevokedByHasPrefix(*i.RevokedByHasPrefix))
	}
	if i.RevokedByHasSuffix != nil {
		predicates = append(predicates, apitoken.RevokedByHasSuffix(*i.RevokedByHasSuffix))
	}
	if i.RevokedByIsNil {
		predicates = append(predicates, apitoken.RevokedByIsNil())
	}
	if i.RevokedByNotNil {
		predicates = append(predicates, apitoken.RevokedByNotNil())
	}
	if i.RevokedByEqualFold != nil {
		predicates = append(predicates, apitoken.RevokedByEqualFold(*i.RevokedByEqualFold))
	}
	if i.RevokedByContainsFold != nil {
		predicates = append(predicates, apitoken.RevokedByContainsFold(*i.RevokedByContainsFold))
	}
	if i.RevokedAt != nil {
		predicates = append(predicates, apitoken.RevokedAtEQ(*i.RevokedAt))
	}
	if i.RevokedAtNEQ != nil {
		predicates = append(predicates, apitoken.RevokedAtNEQ(*i.RevokedAtNEQ))
	}
	if len(i.RevokedAtIn) > 0 {
		predicates = append(predicates, apitoken.RevokedAtIn(i.RevokedAtIn...))
	}
	if len(i.RevokedAtNotIn) > 0 {
		predicates = append(predicates, apitoken.RevokedAtNotIn(i.RevokedAtNotIn...))
	}
	if i.RevokedAtGT != nil {
		predicates = append(predicates, apitoken.RevokedAtGT(*i.RevokedAtGT))
	}
	if i.RevokedAtGTE != nil {
		predicates = append(predicates, apitoken.RevokedAtGTE(*i.RevokedAtGTE))
	}
	if i.RevokedAtLT != nil {
		predicates = append(predicates, apitoken.RevokedAtLT(*i.RevokedAtLT))
	}
	if i.RevokedAtLTE != nil {
		predicates = append(predicates, apitoken.RevokedAtLTE(*i.RevokedAtLTE))
	}
	if i.RevokedAtIsNil {
		predicates = append(predicates, apitoken.RevokedAtIsNil())
	}
	if i.RevokedAtNotNil {
		predicates = append(predicates, apitoken.RevokedAtNotNil())
	}

	if i.HasOwner != nil {
		p := apitoken.HasOwner()
		if !*i.HasOwner {
			p = apitoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apitoken.HasOwnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAPITokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return apitoken.And(predicates...), nil
	}
}

// ActionPlanWhereInput represents a where input for filtering ActionPlan queries.
type ActionPlanWhereInput struct {
	Predicates []predicate.ActionPlan  `json:"-"`
	Not        *ActionPlanWhereInput   `json:"not,omitempty"`
	Or         []*ActionPlanWhereInput `json:"or,omitempty"`
	And        []*ActionPlanWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "revision" field predicates.
	Revision             *string  `json:"revision,omitempty"`
	RevisionNEQ          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGT           *string  `json:"revisionGT,omitempty"`
	RevisionGTE          *string  `json:"revisionGTE,omitempty"`
	RevisionLT           *string  `json:"revisionLT,omitempty"`
	RevisionLTE          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        bool     `json:"revisionIsNil,omitempty"`
	RevisionNotNil       bool     `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                   `json:"statusIsNil,omitempty"`
	StatusNotNil bool                   `json:"statusNotNil,omitempty"`

	// "action_plan_type" field predicates.
	ActionPlanType             *string  `json:"actionPlanType,omitempty"`
	ActionPlanTypeNEQ          *string  `json:"actionPlanTypeNEQ,omitempty"`
	ActionPlanTypeIn           []string `json:"actionPlanTypeIn,omitempty"`
	ActionPlanTypeNotIn        []string `json:"actionPlanTypeNotIn,omitempty"`
	ActionPlanTypeGT           *string  `json:"actionPlanTypeGT,omitempty"`
	ActionPlanTypeGTE          *string  `json:"actionPlanTypeGTE,omitempty"`
	ActionPlanTypeLT           *string  `json:"actionPlanTypeLT,omitempty"`
	ActionPlanTypeLTE          *string  `json:"actionPlanTypeLTE,omitempty"`
	ActionPlanTypeContains     *string  `json:"actionPlanTypeContains,omitempty"`
	ActionPlanTypeHasPrefix    *string  `json:"actionPlanTypeHasPrefix,omitempty"`
	ActionPlanTypeHasSuffix    *string  `json:"actionPlanTypeHasSuffix,omitempty"`
	ActionPlanTypeIsNil        bool     `json:"actionPlanTypeIsNil,omitempty"`
	ActionPlanTypeNotNil       bool     `json:"actionPlanTypeNotNil,omitempty"`
	ActionPlanTypeEqualFold    *string  `json:"actionPlanTypeEqualFold,omitempty"`
	ActionPlanTypeContainsFold *string  `json:"actionPlanTypeContainsFold,omitempty"`

	// "details" field predicates.
	Details             *string  `json:"details,omitempty"`
	DetailsNEQ          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGT           *string  `json:"detailsGT,omitempty"`
	DetailsGTE          *string  `json:"detailsGTE,omitempty"`
	DetailsLT           *string  `json:"detailsLT,omitempty"`
	DetailsLTE          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        bool     `json:"detailsIsNil,omitempty"`
	DetailsNotNil       bool     `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`

	// "approval_required" field predicates.
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNEQ    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  bool  `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil bool  `json:"approvalRequiredNotNil,omitempty"`

	// "review_due" field predicates.
	ReviewDue       *time.Time  `json:"reviewDue,omitempty"`
	ReviewDueNEQ    *time.Time  `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGT     *time.Time  `json:"reviewDueGT,omitempty"`
	ReviewDueGTE    *time.Time  `json:"reviewDueGTE,omitempty"`
	ReviewDueLT     *time.Time  `json:"reviewDueLT,omitempty"`
	ReviewDueLTE    *time.Time  `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil bool        `json:"reviewDueNotNil,omitempty"`

	// "review_frequency" field predicates.
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNEQ    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  bool              `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil bool              `json:"reviewFrequencyNotNil,omitempty"`

	// "approver_id" field predicates.
	ApproverID             *string  `json:"approverID,omitempty"`
	ApproverIDNEQ          *string  `json:"approverIDNEQ,omitempty"`
	ApproverIDIn           []string `json:"approverIDIn,omitempty"`
	ApproverIDNotIn        []string `json:"approverIDNotIn,omitempty"`
	ApproverIDGT           *string  `json:"approverIDGT,omitempty"`
	ApproverIDGTE          *string  `json:"approverIDGTE,omitempty"`
	ApproverIDLT           *string  `json:"approverIDLT,omitempty"`
	ApproverIDLTE          *string  `json:"approverIDLTE,omitempty"`
	ApproverIDContains     *string  `json:"approverIDContains,omitempty"`
	ApproverIDHasPrefix    *string  `json:"approverIDHasPrefix,omitempty"`
	ApproverIDHasSuffix    *string  `json:"approverIDHasSuffix,omitempty"`
	ApproverIDIsNil        bool     `json:"approverIDIsNil,omitempty"`
	ApproverIDNotNil       bool     `json:"approverIDNotNil,omitempty"`
	ApproverIDEqualFold    *string  `json:"approverIDEqualFold,omitempty"`
	ApproverIDContainsFold *string  `json:"approverIDContainsFold,omitempty"`

	// "delegate_id" field predicates.
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIDNEQ          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIDGT           *string  `json:"delegateIDGT,omitempty"`
	DelegateIDGTE          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIDLT           *string  `json:"delegateIDLT,omitempty"`
	DelegateIDLTE          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        bool     `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       bool     `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "due_date" field predicates.
	DueDate       *time.Time  `json:"dueDate,omitempty"`
	DueDateNEQ    *time.Time  `json:"dueDateNEQ,omitempty"`
	DueDateIn     []time.Time `json:"dueDateIn,omitempty"`
	DueDateNotIn  []time.Time `json:"dueDateNotIn,omitempty"`
	DueDateGT     *time.Time  `json:"dueDateGT,omitempty"`
	DueDateGTE    *time.Time  `json:"dueDateGTE,omitempty"`
	DueDateLT     *time.Time  `json:"dueDateLT,omitempty"`
	DueDateLTE    *time.Time  `json:"dueDateLTE,omitempty"`
	DueDateIsNil  bool        `json:"dueDateIsNil,omitempty"`
	DueDateNotNil bool        `json:"dueDateNotNil,omitempty"`

	// "priority" field predicates.
	Priority       *enums.Priority  `json:"priority,omitempty"`
	PriorityNEQ    *enums.Priority  `json:"priorityNEQ,omitempty"`
	PriorityIn     []enums.Priority `json:"priorityIn,omitempty"`
	PriorityNotIn  []enums.Priority `json:"priorityNotIn,omitempty"`
	PriorityIsNil  bool             `json:"priorityIsNil,omitempty"`
	PriorityNotNil bool             `json:"priorityNotNil,omitempty"`

	// "source" field predicates.
	Source             *string  `json:"source,omitempty"`
	SourceNEQ          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGT           *string  `json:"sourceGT,omitempty"`
	SourceGTE          *string  `json:"sourceGTE,omitempty"`
	SourceLT           *string  `json:"sourceLT,omitempty"`
	SourceLTE          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        bool     `json:"sourceIsNil,omitempty"`
	SourceNotNil       bool     `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`

	// "approver" edge predicates.
	HasApprover     *bool              `json:"hasApprover,omitempty"`
	HasApproverWith []*GroupWhereInput `json:"hasApproverWith,omitempty"`

	// "delegate" edge predicates.
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "risks" edge predicates.
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`

	// "controls" edge predicates.
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "programs" edge predicates.
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ActionPlanWhereInput) AddPredicates(predicates ...predicate.ActionPlan) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ActionPlanWhereInput filter on the ActionPlanQuery builder.
func (i *ActionPlanWhereInput) Filter(q *ActionPlanQuery) (*ActionPlanQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyActionPlanWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyActionPlanWhereInput is returned in case the ActionPlanWhereInput is empty.
var ErrEmptyActionPlanWhereInput = errors.New("generated: empty predicate ActionPlanWhereInput")

// P returns a predicate for filtering actionplans.
// An error is returned if the input is empty or invalid.
func (i *ActionPlanWhereInput) P() (predicate.ActionPlan, error) {
	var predicates []predicate.ActionPlan
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, actionplan.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ActionPlan, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, actionplan.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ActionPlan, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, actionplan.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, actionplan.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, actionplan.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, actionplan.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, actionplan.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, actionplan.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, actionplan.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, actionplan.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, actionplan.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, actionplan.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, actionplan.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, actionplan.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, actionplan.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, actionplan.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, actionplan.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, actionplan.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, actionplan.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, actionplan.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, actionplan.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, actionplan.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, actionplan.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, actionplan.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, actionplan.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, actionplan.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, actionplan.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, actionplan.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, actionplan.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, actionplan.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, actionplan.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, actionplan.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, actionplan.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, actionplan.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, actionplan.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, actionplan.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, actionplan.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, actionplan.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, actionplan.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, actionplan.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, actionplan.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, actionplan.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, actionplan.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, actionplan.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, actionplan.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, actionplan.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, actionplan.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, actionplan.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, actionplan.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, actionplan.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, actionplan.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, actionplan.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, actionplan.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, actionplan.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, actionplan.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, actionplan.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, actionplan.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, actionplan.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, actionplan.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, actionplan.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, actionplan.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, actionplan.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, actionplan.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Revision != nil {
		predicates = append(predicates, actionplan.RevisionEQ(*i.Revision))
	}
	if i.RevisionNEQ != nil {
		predicates = append(predicates, actionplan.RevisionNEQ(*i.RevisionNEQ))
	}
	if len(i.RevisionIn) > 0 {
		predicates = append(predicates, actionplan.RevisionIn(i.RevisionIn...))
	}
	if len(i.RevisionNotIn) > 0 {
		predicates = append(predicates, actionplan.RevisionNotIn(i.RevisionNotIn...))
	}
	if i.RevisionGT != nil {
		predicates = append(predicates, actionplan.RevisionGT(*i.RevisionGT))
	}
	if i.RevisionGTE != nil {
		predicates = append(predicates, actionplan.RevisionGTE(*i.RevisionGTE))
	}
	if i.RevisionLT != nil {
		predicates = append(predicates, actionplan.RevisionLT(*i.RevisionLT))
	}
	if i.RevisionLTE != nil {
		predicates = append(predicates, actionplan.RevisionLTE(*i.RevisionLTE))
	}
	if i.RevisionContains != nil {
		predicates = append(predicates, actionplan.RevisionContains(*i.RevisionContains))
	}
	if i.RevisionHasPrefix != nil {
		predicates = append(predicates, actionplan.RevisionHasPrefix(*i.RevisionHasPrefix))
	}
	if i.RevisionHasSuffix != nil {
		predicates = append(predicates, actionplan.RevisionHasSuffix(*i.RevisionHasSuffix))
	}
	if i.RevisionIsNil {
		predicates = append(predicates, actionplan.RevisionIsNil())
	}
	if i.RevisionNotNil {
		predicates = append(predicates, actionplan.RevisionNotNil())
	}
	if i.RevisionEqualFold != nil {
		predicates = append(predicates, actionplan.RevisionEqualFold(*i.RevisionEqualFold))
	}
	if i.RevisionContainsFold != nil {
		predicates = append(predicates, actionplan.RevisionContainsFold(*i.RevisionContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, actionplan.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, actionplan.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, actionplan.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, actionplan.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, actionplan.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, actionplan.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, actionplan.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, actionplan.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, actionplan.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, actionplan.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, actionplan.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, actionplan.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, actionplan.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, actionplan.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, actionplan.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, actionplan.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, actionplan.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, actionplan.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, actionplan.StatusNotNil())
	}
	if i.ActionPlanType != nil {
		predicates = append(predicates, actionplan.ActionPlanTypeEQ(*i.ActionPlanType))
	}
	if i.ActionPlanTypeNEQ != nil {
		predicates = append(predicates, actionplan.ActionPlanTypeNEQ(*i.ActionPlanTypeNEQ))
	}
	if len(i.ActionPlanTypeIn) > 0 {
		predicates = append(predicates, actionplan.ActionPlanTypeIn(i.ActionPlanTypeIn...))
	}
	if len(i.ActionPlanTypeNotIn) > 0 {
		predicates = append(predicates, actionplan.ActionPlanTypeNotIn(i.ActionPlanTypeNotIn...))
	}
	if i.ActionPlanTypeGT != nil {
		predicates = append(predicates, actionplan.ActionPlanTypeGT(*i.ActionPlanTypeGT))
	}
	if i.ActionPlanTypeGTE != nil {
		predicates = append(predicates, actionplan.ActionPlanTypeGTE(*i.ActionPlanTypeGTE))
	}
	if i.ActionPlanTypeLT != nil {
		predicates = append(predicates, actionplan.ActionPlanTypeLT(*i.ActionPlanTypeLT))
	}
	if i.ActionPlanTypeLTE != nil {
		predicates = append(predicates, actionplan.ActionPlanTypeLTE(*i.ActionPlanTypeLTE))
	}
	if i.ActionPlanTypeContains != nil {
		predicates = append(predicates, actionplan.ActionPlanTypeContains(*i.ActionPlanTypeContains))
	}
	if i.ActionPlanTypeHasPrefix != nil {
		predicates = append(predicates, actionplan.ActionPlanTypeHasPrefix(*i.ActionPlanTypeHasPrefix))
	}
	if i.ActionPlanTypeHasSuffix != nil {
		predicates = append(predicates, actionplan.ActionPlanTypeHasSuffix(*i.ActionPlanTypeHasSuffix))
	}
	if i.ActionPlanTypeIsNil {
		predicates = append(predicates, actionplan.ActionPlanTypeIsNil())
	}
	if i.ActionPlanTypeNotNil {
		predicates = append(predicates, actionplan.ActionPlanTypeNotNil())
	}
	if i.ActionPlanTypeEqualFold != nil {
		predicates = append(predicates, actionplan.ActionPlanTypeEqualFold(*i.ActionPlanTypeEqualFold))
	}
	if i.ActionPlanTypeContainsFold != nil {
		predicates = append(predicates, actionplan.ActionPlanTypeContainsFold(*i.ActionPlanTypeContainsFold))
	}
	if i.Details != nil {
		predicates = append(predicates, actionplan.DetailsEQ(*i.Details))
	}
	if i.DetailsNEQ != nil {
		predicates = append(predicates, actionplan.DetailsNEQ(*i.DetailsNEQ))
	}
	if len(i.DetailsIn) > 0 {
		predicates = append(predicates, actionplan.DetailsIn(i.DetailsIn...))
	}
	if len(i.DetailsNotIn) > 0 {
		predicates = append(predicates, actionplan.DetailsNotIn(i.DetailsNotIn...))
	}
	if i.DetailsGT != nil {
		predicates = append(predicates, actionplan.DetailsGT(*i.DetailsGT))
	}
	if i.DetailsGTE != nil {
		predicates = append(predicates, actionplan.DetailsGTE(*i.DetailsGTE))
	}
	if i.DetailsLT != nil {
		predicates = append(predicates, actionplan.DetailsLT(*i.DetailsLT))
	}
	if i.DetailsLTE != nil {
		predicates = append(predicates, actionplan.DetailsLTE(*i.DetailsLTE))
	}
	if i.DetailsContains != nil {
		predicates = append(predicates, actionplan.DetailsContains(*i.DetailsContains))
	}
	if i.DetailsHasPrefix != nil {
		predicates = append(predicates, actionplan.DetailsHasPrefix(*i.DetailsHasPrefix))
	}
	if i.DetailsHasSuffix != nil {
		predicates = append(predicates, actionplan.DetailsHasSuffix(*i.DetailsHasSuffix))
	}
	if i.DetailsIsNil {
		predicates = append(predicates, actionplan.DetailsIsNil())
	}
	if i.DetailsNotNil {
		predicates = append(predicates, actionplan.DetailsNotNil())
	}
	if i.DetailsEqualFold != nil {
		predicates = append(predicates, actionplan.DetailsEqualFold(*i.DetailsEqualFold))
	}
	if i.DetailsContainsFold != nil {
		predicates = append(predicates, actionplan.DetailsContainsFold(*i.DetailsContainsFold))
	}
	if i.ApprovalRequired != nil {
		predicates = append(predicates, actionplan.ApprovalRequiredEQ(*i.ApprovalRequired))
	}
	if i.ApprovalRequiredNEQ != nil {
		predicates = append(predicates, actionplan.ApprovalRequiredNEQ(*i.ApprovalRequiredNEQ))
	}
	if i.ApprovalRequiredIsNil {
		predicates = append(predicates, actionplan.ApprovalRequiredIsNil())
	}
	if i.ApprovalRequiredNotNil {
		predicates = append(predicates, actionplan.ApprovalRequiredNotNil())
	}
	if i.ReviewDue != nil {
		predicates = append(predicates, actionplan.ReviewDueEQ(*i.ReviewDue))
	}
	if i.ReviewDueNEQ != nil {
		predicates = append(predicates, actionplan.ReviewDueNEQ(*i.ReviewDueNEQ))
	}
	if len(i.ReviewDueIn) > 0 {
		predicates = append(predicates, actionplan.ReviewDueIn(i.ReviewDueIn...))
	}
	if len(i.ReviewDueNotIn) > 0 {
		predicates = append(predicates, actionplan.ReviewDueNotIn(i.ReviewDueNotIn...))
	}
	if i.ReviewDueGT != nil {
		predicates = append(predicates, actionplan.ReviewDueGT(*i.ReviewDueGT))
	}
	if i.ReviewDueGTE != nil {
		predicates = append(predicates, actionplan.ReviewDueGTE(*i.ReviewDueGTE))
	}
	if i.ReviewDueLT != nil {
		predicates = append(predicates, actionplan.ReviewDueLT(*i.ReviewDueLT))
	}
	if i.ReviewDueLTE != nil {
		predicates = append(predicates, actionplan.ReviewDueLTE(*i.ReviewDueLTE))
	}
	if i.ReviewDueIsNil {
		predicates = append(predicates, actionplan.ReviewDueIsNil())
	}
	if i.ReviewDueNotNil {
		predicates = append(predicates, actionplan.ReviewDueNotNil())
	}
	if i.ReviewFrequency != nil {
		predicates = append(predicates, actionplan.ReviewFrequencyEQ(*i.ReviewFrequency))
	}
	if i.ReviewFrequencyNEQ != nil {
		predicates = append(predicates, actionplan.ReviewFrequencyNEQ(*i.ReviewFrequencyNEQ))
	}
	if len(i.ReviewFrequencyIn) > 0 {
		predicates = append(predicates, actionplan.ReviewFrequencyIn(i.ReviewFrequencyIn...))
	}
	if len(i.ReviewFrequencyNotIn) > 0 {
		predicates = append(predicates, actionplan.ReviewFrequencyNotIn(i.ReviewFrequencyNotIn...))
	}
	if i.ReviewFrequencyIsNil {
		predicates = append(predicates, actionplan.ReviewFrequencyIsNil())
	}
	if i.ReviewFrequencyNotNil {
		predicates = append(predicates, actionplan.ReviewFrequencyNotNil())
	}
	if i.ApproverID != nil {
		predicates = append(predicates, actionplan.ApproverIDEQ(*i.ApproverID))
	}
	if i.ApproverIDNEQ != nil {
		predicates = append(predicates, actionplan.ApproverIDNEQ(*i.ApproverIDNEQ))
	}
	if len(i.ApproverIDIn) > 0 {
		predicates = append(predicates, actionplan.ApproverIDIn(i.ApproverIDIn...))
	}
	if len(i.ApproverIDNotIn) > 0 {
		predicates = append(predicates, actionplan.ApproverIDNotIn(i.ApproverIDNotIn...))
	}
	if i.ApproverIDGT != nil {
		predicates = append(predicates, actionplan.ApproverIDGT(*i.ApproverIDGT))
	}
	if i.ApproverIDGTE != nil {
		predicates = append(predicates, actionplan.ApproverIDGTE(*i.ApproverIDGTE))
	}
	if i.ApproverIDLT != nil {
		predicates = append(predicates, actionplan.ApproverIDLT(*i.ApproverIDLT))
	}
	if i.ApproverIDLTE != nil {
		predicates = append(predicates, actionplan.ApproverIDLTE(*i.ApproverIDLTE))
	}
	if i.ApproverIDContains != nil {
		predicates = append(predicates, actionplan.ApproverIDContains(*i.ApproverIDContains))
	}
	if i.ApproverIDHasPrefix != nil {
		predicates = append(predicates, actionplan.ApproverIDHasPrefix(*i.ApproverIDHasPrefix))
	}
	if i.ApproverIDHasSuffix != nil {
		predicates = append(predicates, actionplan.ApproverIDHasSuffix(*i.ApproverIDHasSuffix))
	}
	if i.ApproverIDIsNil {
		predicates = append(predicates, actionplan.ApproverIDIsNil())
	}
	if i.ApproverIDNotNil {
		predicates = append(predicates, actionplan.ApproverIDNotNil())
	}
	if i.ApproverIDEqualFold != nil {
		predicates = append(predicates, actionplan.ApproverIDEqualFold(*i.ApproverIDEqualFold))
	}
	if i.ApproverIDContainsFold != nil {
		predicates = append(predicates, actionplan.ApproverIDContainsFold(*i.ApproverIDContainsFold))
	}
	if i.DelegateID != nil {
		predicates = append(predicates, actionplan.DelegateIDEQ(*i.DelegateID))
	}
	if i.DelegateIDNEQ != nil {
		predicates = append(predicates, actionplan.DelegateIDNEQ(*i.DelegateIDNEQ))
	}
	if len(i.DelegateIDIn) > 0 {
		predicates = append(predicates, actionplan.DelegateIDIn(i.DelegateIDIn...))
	}
	if len(i.DelegateIDNotIn) > 0 {
		predicates = append(predicates, actionplan.DelegateIDNotIn(i.DelegateIDNotIn...))
	}
	if i.DelegateIDGT != nil {
		predicates = append(predicates, actionplan.DelegateIDGT(*i.DelegateIDGT))
	}
	if i.DelegateIDGTE != nil {
		predicates = append(predicates, actionplan.DelegateIDGTE(*i.DelegateIDGTE))
	}
	if i.DelegateIDLT != nil {
		predicates = append(predicates, actionplan.DelegateIDLT(*i.DelegateIDLT))
	}
	if i.DelegateIDLTE != nil {
		predicates = append(predicates, actionplan.DelegateIDLTE(*i.DelegateIDLTE))
	}
	if i.DelegateIDContains != nil {
		predicates = append(predicates, actionplan.DelegateIDContains(*i.DelegateIDContains))
	}
	if i.DelegateIDHasPrefix != nil {
		predicates = append(predicates, actionplan.DelegateIDHasPrefix(*i.DelegateIDHasPrefix))
	}
	if i.DelegateIDHasSuffix != nil {
		predicates = append(predicates, actionplan.DelegateIDHasSuffix(*i.DelegateIDHasSuffix))
	}
	if i.DelegateIDIsNil {
		predicates = append(predicates, actionplan.DelegateIDIsNil())
	}
	if i.DelegateIDNotNil {
		predicates = append(predicates, actionplan.DelegateIDNotNil())
	}
	if i.DelegateIDEqualFold != nil {
		predicates = append(predicates, actionplan.DelegateIDEqualFold(*i.DelegateIDEqualFold))
	}
	if i.DelegateIDContainsFold != nil {
		predicates = append(predicates, actionplan.DelegateIDContainsFold(*i.DelegateIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, actionplan.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, actionplan.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, actionplan.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, actionplan.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, actionplan.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, actionplan.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, actionplan.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, actionplan.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, actionplan.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, actionplan.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, actionplan.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, actionplan.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, actionplan.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, actionplan.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, actionplan.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.DueDate != nil {
		predicates = append(predicates, actionplan.DueDateEQ(*i.DueDate))
	}
	if i.DueDateNEQ != nil {
		predicates = append(predicates, actionplan.DueDateNEQ(*i.DueDateNEQ))
	}
	if len(i.DueDateIn) > 0 {
		predicates = append(predicates, actionplan.DueDateIn(i.DueDateIn...))
	}
	if len(i.DueDateNotIn) > 0 {
		predicates = append(predicates, actionplan.DueDateNotIn(i.DueDateNotIn...))
	}
	if i.DueDateGT != nil {
		predicates = append(predicates, actionplan.DueDateGT(*i.DueDateGT))
	}
	if i.DueDateGTE != nil {
		predicates = append(predicates, actionplan.DueDateGTE(*i.DueDateGTE))
	}
	if i.DueDateLT != nil {
		predicates = append(predicates, actionplan.DueDateLT(*i.DueDateLT))
	}
	if i.DueDateLTE != nil {
		predicates = append(predicates, actionplan.DueDateLTE(*i.DueDateLTE))
	}
	if i.DueDateIsNil {
		predicates = append(predicates, actionplan.DueDateIsNil())
	}
	if i.DueDateNotNil {
		predicates = append(predicates, actionplan.DueDateNotNil())
	}
	if i.Priority != nil {
		predicates = append(predicates, actionplan.PriorityEQ(*i.Priority))
	}
	if i.PriorityNEQ != nil {
		predicates = append(predicates, actionplan.PriorityNEQ(*i.PriorityNEQ))
	}
	if len(i.PriorityIn) > 0 {
		predicates = append(predicates, actionplan.PriorityIn(i.PriorityIn...))
	}
	if len(i.PriorityNotIn) > 0 {
		predicates = append(predicates, actionplan.PriorityNotIn(i.PriorityNotIn...))
	}
	if i.PriorityIsNil {
		predicates = append(predicates, actionplan.PriorityIsNil())
	}
	if i.PriorityNotNil {
		predicates = append(predicates, actionplan.PriorityNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, actionplan.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, actionplan.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, actionplan.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, actionplan.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceGT != nil {
		predicates = append(predicates, actionplan.SourceGT(*i.SourceGT))
	}
	if i.SourceGTE != nil {
		predicates = append(predicates, actionplan.SourceGTE(*i.SourceGTE))
	}
	if i.SourceLT != nil {
		predicates = append(predicates, actionplan.SourceLT(*i.SourceLT))
	}
	if i.SourceLTE != nil {
		predicates = append(predicates, actionplan.SourceLTE(*i.SourceLTE))
	}
	if i.SourceContains != nil {
		predicates = append(predicates, actionplan.SourceContains(*i.SourceContains))
	}
	if i.SourceHasPrefix != nil {
		predicates = append(predicates, actionplan.SourceHasPrefix(*i.SourceHasPrefix))
	}
	if i.SourceHasSuffix != nil {
		predicates = append(predicates, actionplan.SourceHasSuffix(*i.SourceHasSuffix))
	}
	if i.SourceIsNil {
		predicates = append(predicates, actionplan.SourceIsNil())
	}
	if i.SourceNotNil {
		predicates = append(predicates, actionplan.SourceNotNil())
	}
	if i.SourceEqualFold != nil {
		predicates = append(predicates, actionplan.SourceEqualFold(*i.SourceEqualFold))
	}
	if i.SourceContainsFold != nil {
		predicates = append(predicates, actionplan.SourceContainsFold(*i.SourceContainsFold))
	}

	if i.HasApprover != nil {
		p := actionplan.HasApprover()
		if !*i.HasApprover {
			p = actionplan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasApproverWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasApproverWith))
		for _, w := range i.HasApproverWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasApproverWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, actionplan.HasApproverWith(with...))
	}
	if i.HasDelegate != nil {
		p := actionplan.HasDelegate()
		if !*i.HasDelegate {
			p = actionplan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDelegateWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasDelegateWith))
		for _, w := range i.HasDelegateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDelegateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, actionplan.HasDelegateWith(with...))
	}
	if i.HasOwner != nil {
		p := actionplan.HasOwner()
		if !*i.HasOwner {
			p = actionplan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, actionplan.HasOwnerWith(with...))
	}
	if i.HasRisks != nil {
		p := actionplan.HasRisks()
		if !*i.HasRisks {
			p = actionplan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRisksWith) > 0 {
		with := make([]predicate.Risk, 0, len(i.HasRisksWith))
		for _, w := range i.HasRisksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRisksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, actionplan.HasRisksWith(with...))
	}
	if i.HasControls != nil {
		p := actionplan.HasControls()
		if !*i.HasControls {
			p = actionplan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasControlsWith))
		for _, w := range i.HasControlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, actionplan.HasControlsWith(with...))
	}
	if i.HasUsers != nil {
		p := actionplan.HasUsers()
		if !*i.HasUsers {
			p = actionplan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, actionplan.HasUsersWith(with...))
	}
	if i.HasPrograms != nil {
		p := actionplan.HasPrograms()
		if !*i.HasPrograms {
			p = actionplan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramsWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramsWith))
		for _, w := range i.HasProgramsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, actionplan.HasProgramsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyActionPlanWhereInput
	case 1:
		return predicates[0], nil
	default:
		return actionplan.And(predicates...), nil
	}
}

// ActionPlanHistoryWhereInput represents a where input for filtering ActionPlanHistory queries.
type ActionPlanHistoryWhereInput struct {
	Predicates []predicate.ActionPlanHistory  `json:"-"`
	Not        *ActionPlanHistoryWhereInput   `json:"not,omitempty"`
	Or         []*ActionPlanHistoryWhereInput `json:"or,omitempty"`
	And        []*ActionPlanHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "revision" field predicates.
	Revision             *string  `json:"revision,omitempty"`
	RevisionNEQ          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGT           *string  `json:"revisionGT,omitempty"`
	RevisionGTE          *string  `json:"revisionGTE,omitempty"`
	RevisionLT           *string  `json:"revisionLT,omitempty"`
	RevisionLTE          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        bool     `json:"revisionIsNil,omitempty"`
	RevisionNotNil       bool     `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                   `json:"statusIsNil,omitempty"`
	StatusNotNil bool                   `json:"statusNotNil,omitempty"`

	// "action_plan_type" field predicates.
	ActionPlanType             *string  `json:"actionPlanType,omitempty"`
	ActionPlanTypeNEQ          *string  `json:"actionPlanTypeNEQ,omitempty"`
	ActionPlanTypeIn           []string `json:"actionPlanTypeIn,omitempty"`
	ActionPlanTypeNotIn        []string `json:"actionPlanTypeNotIn,omitempty"`
	ActionPlanTypeGT           *string  `json:"actionPlanTypeGT,omitempty"`
	ActionPlanTypeGTE          *string  `json:"actionPlanTypeGTE,omitempty"`
	ActionPlanTypeLT           *string  `json:"actionPlanTypeLT,omitempty"`
	ActionPlanTypeLTE          *string  `json:"actionPlanTypeLTE,omitempty"`
	ActionPlanTypeContains     *string  `json:"actionPlanTypeContains,omitempty"`
	ActionPlanTypeHasPrefix    *string  `json:"actionPlanTypeHasPrefix,omitempty"`
	ActionPlanTypeHasSuffix    *string  `json:"actionPlanTypeHasSuffix,omitempty"`
	ActionPlanTypeIsNil        bool     `json:"actionPlanTypeIsNil,omitempty"`
	ActionPlanTypeNotNil       bool     `json:"actionPlanTypeNotNil,omitempty"`
	ActionPlanTypeEqualFold    *string  `json:"actionPlanTypeEqualFold,omitempty"`
	ActionPlanTypeContainsFold *string  `json:"actionPlanTypeContainsFold,omitempty"`

	// "details" field predicates.
	Details             *string  `json:"details,omitempty"`
	DetailsNEQ          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGT           *string  `json:"detailsGT,omitempty"`
	DetailsGTE          *string  `json:"detailsGTE,omitempty"`
	DetailsLT           *string  `json:"detailsLT,omitempty"`
	DetailsLTE          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        bool     `json:"detailsIsNil,omitempty"`
	DetailsNotNil       bool     `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`

	// "approval_required" field predicates.
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNEQ    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  bool  `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil bool  `json:"approvalRequiredNotNil,omitempty"`

	// "review_due" field predicates.
	ReviewDue       *time.Time  `json:"reviewDue,omitempty"`
	ReviewDueNEQ    *time.Time  `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGT     *time.Time  `json:"reviewDueGT,omitempty"`
	ReviewDueGTE    *time.Time  `json:"reviewDueGTE,omitempty"`
	ReviewDueLT     *time.Time  `json:"reviewDueLT,omitempty"`
	ReviewDueLTE    *time.Time  `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil bool        `json:"reviewDueNotNil,omitempty"`

	// "review_frequency" field predicates.
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNEQ    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  bool              `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil bool              `json:"reviewFrequencyNotNil,omitempty"`

	// "approver_id" field predicates.
	ApproverID             *string  `json:"approverID,omitempty"`
	ApproverIDNEQ          *string  `json:"approverIDNEQ,omitempty"`
	ApproverIDIn           []string `json:"approverIDIn,omitempty"`
	ApproverIDNotIn        []string `json:"approverIDNotIn,omitempty"`
	ApproverIDGT           *string  `json:"approverIDGT,omitempty"`
	ApproverIDGTE          *string  `json:"approverIDGTE,omitempty"`
	ApproverIDLT           *string  `json:"approverIDLT,omitempty"`
	ApproverIDLTE          *string  `json:"approverIDLTE,omitempty"`
	ApproverIDContains     *string  `json:"approverIDContains,omitempty"`
	ApproverIDHasPrefix    *string  `json:"approverIDHasPrefix,omitempty"`
	ApproverIDHasSuffix    *string  `json:"approverIDHasSuffix,omitempty"`
	ApproverIDIsNil        bool     `json:"approverIDIsNil,omitempty"`
	ApproverIDNotNil       bool     `json:"approverIDNotNil,omitempty"`
	ApproverIDEqualFold    *string  `json:"approverIDEqualFold,omitempty"`
	ApproverIDContainsFold *string  `json:"approverIDContainsFold,omitempty"`

	// "delegate_id" field predicates.
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIDNEQ          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIDGT           *string  `json:"delegateIDGT,omitempty"`
	DelegateIDGTE          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIDLT           *string  `json:"delegateIDLT,omitempty"`
	DelegateIDLTE          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        bool     `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       bool     `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "due_date" field predicates.
	DueDate       *time.Time  `json:"dueDate,omitempty"`
	DueDateNEQ    *time.Time  `json:"dueDateNEQ,omitempty"`
	DueDateIn     []time.Time `json:"dueDateIn,omitempty"`
	DueDateNotIn  []time.Time `json:"dueDateNotIn,omitempty"`
	DueDateGT     *time.Time  `json:"dueDateGT,omitempty"`
	DueDateGTE    *time.Time  `json:"dueDateGTE,omitempty"`
	DueDateLT     *time.Time  `json:"dueDateLT,omitempty"`
	DueDateLTE    *time.Time  `json:"dueDateLTE,omitempty"`
	DueDateIsNil  bool        `json:"dueDateIsNil,omitempty"`
	DueDateNotNil bool        `json:"dueDateNotNil,omitempty"`

	// "priority" field predicates.
	Priority       *enums.Priority  `json:"priority,omitempty"`
	PriorityNEQ    *enums.Priority  `json:"priorityNEQ,omitempty"`
	PriorityIn     []enums.Priority `json:"priorityIn,omitempty"`
	PriorityNotIn  []enums.Priority `json:"priorityNotIn,omitempty"`
	PriorityIsNil  bool             `json:"priorityIsNil,omitempty"`
	PriorityNotNil bool             `json:"priorityNotNil,omitempty"`

	// "source" field predicates.
	Source             *string  `json:"source,omitempty"`
	SourceNEQ          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGT           *string  `json:"sourceGT,omitempty"`
	SourceGTE          *string  `json:"sourceGTE,omitempty"`
	SourceLT           *string  `json:"sourceLT,omitempty"`
	SourceLTE          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        bool     `json:"sourceIsNil,omitempty"`
	SourceNotNil       bool     `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ActionPlanHistoryWhereInput) AddPredicates(predicates ...predicate.ActionPlanHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ActionPlanHistoryWhereInput filter on the ActionPlanHistoryQuery builder.
func (i *ActionPlanHistoryWhereInput) Filter(q *ActionPlanHistoryQuery) (*ActionPlanHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyActionPlanHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyActionPlanHistoryWhereInput is returned in case the ActionPlanHistoryWhereInput is empty.
var ErrEmptyActionPlanHistoryWhereInput = errors.New("generated: empty predicate ActionPlanHistoryWhereInput")

// P returns a predicate for filtering actionplanhistories.
// An error is returned if the input is empty or invalid.
func (i *ActionPlanHistoryWhereInput) P() (predicate.ActionPlanHistory, error) {
	var predicates []predicate.ActionPlanHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, actionplanhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ActionPlanHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, actionplanhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ActionPlanHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, actionplanhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, actionplanhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, actionplanhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, actionplanhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, actionplanhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, actionplanhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, actionplanhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, actionplanhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, actionplanhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, actionplanhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, actionplanhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, actionplanhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, actionplanhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, actionplanhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, actionplanhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, actionplanhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, actionplanhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, actionplanhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, actionplanhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, actionplanhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, actionplanhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, actionplanhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, actionplanhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, actionplanhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, actionplanhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, actionplanhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, actionplanhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, actionplanhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, actionplanhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, actionplanhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, actionplanhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, actionplanhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, actionplanhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, actionplanhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, actionplanhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, actionplanhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, actionplanhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, actionplanhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, actionplanhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, actionplanhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, actionplanhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, actionplanhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, actionplanhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, actionplanhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, actionplanhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, actionplanhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, actionplanhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, actionplanhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, actionplanhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, actionplanhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, actionplanhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, actionplanhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, actionplanhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, actionplanhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, actionplanhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, actionplanhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, actionplanhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, actionplanhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, actionplanhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, actionplanhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, actionplanhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, actionplanhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, actionplanhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, actionplanhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, actionplanhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, actionplanhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, actionplanhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, actionplanhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, actionplanhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, actionplanhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, actionplanhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, actionplanhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, actionplanhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, actionplanhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, actionplanhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, actionplanhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, actionplanhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, actionplanhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, actionplanhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, actionplanhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Revision != nil {
		predicates = append(predicates, actionplanhistory.RevisionEQ(*i.Revision))
	}
	if i.RevisionNEQ != nil {
		predicates = append(predicates, actionplanhistory.RevisionNEQ(*i.RevisionNEQ))
	}
	if len(i.RevisionIn) > 0 {
		predicates = append(predicates, actionplanhistory.RevisionIn(i.RevisionIn...))
	}
	if len(i.RevisionNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.RevisionNotIn(i.RevisionNotIn...))
	}
	if i.RevisionGT != nil {
		predicates = append(predicates, actionplanhistory.RevisionGT(*i.RevisionGT))
	}
	if i.RevisionGTE != nil {
		predicates = append(predicates, actionplanhistory.RevisionGTE(*i.RevisionGTE))
	}
	if i.RevisionLT != nil {
		predicates = append(predicates, actionplanhistory.RevisionLT(*i.RevisionLT))
	}
	if i.RevisionLTE != nil {
		predicates = append(predicates, actionplanhistory.RevisionLTE(*i.RevisionLTE))
	}
	if i.RevisionContains != nil {
		predicates = append(predicates, actionplanhistory.RevisionContains(*i.RevisionContains))
	}
	if i.RevisionHasPrefix != nil {
		predicates = append(predicates, actionplanhistory.RevisionHasPrefix(*i.RevisionHasPrefix))
	}
	if i.RevisionHasSuffix != nil {
		predicates = append(predicates, actionplanhistory.RevisionHasSuffix(*i.RevisionHasSuffix))
	}
	if i.RevisionIsNil {
		predicates = append(predicates, actionplanhistory.RevisionIsNil())
	}
	if i.RevisionNotNil {
		predicates = append(predicates, actionplanhistory.RevisionNotNil())
	}
	if i.RevisionEqualFold != nil {
		predicates = append(predicates, actionplanhistory.RevisionEqualFold(*i.RevisionEqualFold))
	}
	if i.RevisionContainsFold != nil {
		predicates = append(predicates, actionplanhistory.RevisionContainsFold(*i.RevisionContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, actionplanhistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, actionplanhistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, actionplanhistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, actionplanhistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, actionplanhistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, actionplanhistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, actionplanhistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, actionplanhistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, actionplanhistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, actionplanhistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, actionplanhistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, actionplanhistory.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, actionplanhistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, actionplanhistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, actionplanhistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, actionplanhistory.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, actionplanhistory.StatusNotNil())
	}
	if i.ActionPlanType != nil {
		predicates = append(predicates, actionplanhistory.ActionPlanTypeEQ(*i.ActionPlanType))
	}
	if i.ActionPlanTypeNEQ != nil {
		predicates = append(predicates, actionplanhistory.ActionPlanTypeNEQ(*i.ActionPlanTypeNEQ))
	}
	if len(i.ActionPlanTypeIn) > 0 {
		predicates = append(predicates, actionplanhistory.ActionPlanTypeIn(i.ActionPlanTypeIn...))
	}
	if len(i.ActionPlanTypeNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.ActionPlanTypeNotIn(i.ActionPlanTypeNotIn...))
	}
	if i.ActionPlanTypeGT != nil {
		predicates = append(predicates, actionplanhistory.ActionPlanTypeGT(*i.ActionPlanTypeGT))
	}
	if i.ActionPlanTypeGTE != nil {
		predicates = append(predicates, actionplanhistory.ActionPlanTypeGTE(*i.ActionPlanTypeGTE))
	}
	if i.ActionPlanTypeLT != nil {
		predicates = append(predicates, actionplanhistory.ActionPlanTypeLT(*i.ActionPlanTypeLT))
	}
	if i.ActionPlanTypeLTE != nil {
		predicates = append(predicates, actionplanhistory.ActionPlanTypeLTE(*i.ActionPlanTypeLTE))
	}
	if i.ActionPlanTypeContains != nil {
		predicates = append(predicates, actionplanhistory.ActionPlanTypeContains(*i.ActionPlanTypeContains))
	}
	if i.ActionPlanTypeHasPrefix != nil {
		predicates = append(predicates, actionplanhistory.ActionPlanTypeHasPrefix(*i.ActionPlanTypeHasPrefix))
	}
	if i.ActionPlanTypeHasSuffix != nil {
		predicates = append(predicates, actionplanhistory.ActionPlanTypeHasSuffix(*i.ActionPlanTypeHasSuffix))
	}
	if i.ActionPlanTypeIsNil {
		predicates = append(predicates, actionplanhistory.ActionPlanTypeIsNil())
	}
	if i.ActionPlanTypeNotNil {
		predicates = append(predicates, actionplanhistory.ActionPlanTypeNotNil())
	}
	if i.ActionPlanTypeEqualFold != nil {
		predicates = append(predicates, actionplanhistory.ActionPlanTypeEqualFold(*i.ActionPlanTypeEqualFold))
	}
	if i.ActionPlanTypeContainsFold != nil {
		predicates = append(predicates, actionplanhistory.ActionPlanTypeContainsFold(*i.ActionPlanTypeContainsFold))
	}
	if i.Details != nil {
		predicates = append(predicates, actionplanhistory.DetailsEQ(*i.Details))
	}
	if i.DetailsNEQ != nil {
		predicates = append(predicates, actionplanhistory.DetailsNEQ(*i.DetailsNEQ))
	}
	if len(i.DetailsIn) > 0 {
		predicates = append(predicates, actionplanhistory.DetailsIn(i.DetailsIn...))
	}
	if len(i.DetailsNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.DetailsNotIn(i.DetailsNotIn...))
	}
	if i.DetailsGT != nil {
		predicates = append(predicates, actionplanhistory.DetailsGT(*i.DetailsGT))
	}
	if i.DetailsGTE != nil {
		predicates = append(predicates, actionplanhistory.DetailsGTE(*i.DetailsGTE))
	}
	if i.DetailsLT != nil {
		predicates = append(predicates, actionplanhistory.DetailsLT(*i.DetailsLT))
	}
	if i.DetailsLTE != nil {
		predicates = append(predicates, actionplanhistory.DetailsLTE(*i.DetailsLTE))
	}
	if i.DetailsContains != nil {
		predicates = append(predicates, actionplanhistory.DetailsContains(*i.DetailsContains))
	}
	if i.DetailsHasPrefix != nil {
		predicates = append(predicates, actionplanhistory.DetailsHasPrefix(*i.DetailsHasPrefix))
	}
	if i.DetailsHasSuffix != nil {
		predicates = append(predicates, actionplanhistory.DetailsHasSuffix(*i.DetailsHasSuffix))
	}
	if i.DetailsIsNil {
		predicates = append(predicates, actionplanhistory.DetailsIsNil())
	}
	if i.DetailsNotNil {
		predicates = append(predicates, actionplanhistory.DetailsNotNil())
	}
	if i.DetailsEqualFold != nil {
		predicates = append(predicates, actionplanhistory.DetailsEqualFold(*i.DetailsEqualFold))
	}
	if i.DetailsContainsFold != nil {
		predicates = append(predicates, actionplanhistory.DetailsContainsFold(*i.DetailsContainsFold))
	}
	if i.ApprovalRequired != nil {
		predicates = append(predicates, actionplanhistory.ApprovalRequiredEQ(*i.ApprovalRequired))
	}
	if i.ApprovalRequiredNEQ != nil {
		predicates = append(predicates, actionplanhistory.ApprovalRequiredNEQ(*i.ApprovalRequiredNEQ))
	}
	if i.ApprovalRequiredIsNil {
		predicates = append(predicates, actionplanhistory.ApprovalRequiredIsNil())
	}
	if i.ApprovalRequiredNotNil {
		predicates = append(predicates, actionplanhistory.ApprovalRequiredNotNil())
	}
	if i.ReviewDue != nil {
		predicates = append(predicates, actionplanhistory.ReviewDueEQ(*i.ReviewDue))
	}
	if i.ReviewDueNEQ != nil {
		predicates = append(predicates, actionplanhistory.ReviewDueNEQ(*i.ReviewDueNEQ))
	}
	if len(i.ReviewDueIn) > 0 {
		predicates = append(predicates, actionplanhistory.ReviewDueIn(i.ReviewDueIn...))
	}
	if len(i.ReviewDueNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.ReviewDueNotIn(i.ReviewDueNotIn...))
	}
	if i.ReviewDueGT != nil {
		predicates = append(predicates, actionplanhistory.ReviewDueGT(*i.ReviewDueGT))
	}
	if i.ReviewDueGTE != nil {
		predicates = append(predicates, actionplanhistory.ReviewDueGTE(*i.ReviewDueGTE))
	}
	if i.ReviewDueLT != nil {
		predicates = append(predicates, actionplanhistory.ReviewDueLT(*i.ReviewDueLT))
	}
	if i.ReviewDueLTE != nil {
		predicates = append(predicates, actionplanhistory.ReviewDueLTE(*i.ReviewDueLTE))
	}
	if i.ReviewDueIsNil {
		predicates = append(predicates, actionplanhistory.ReviewDueIsNil())
	}
	if i.ReviewDueNotNil {
		predicates = append(predicates, actionplanhistory.ReviewDueNotNil())
	}
	if i.ReviewFrequency != nil {
		predicates = append(predicates, actionplanhistory.ReviewFrequencyEQ(*i.ReviewFrequency))
	}
	if i.ReviewFrequencyNEQ != nil {
		predicates = append(predicates, actionplanhistory.ReviewFrequencyNEQ(*i.ReviewFrequencyNEQ))
	}
	if len(i.ReviewFrequencyIn) > 0 {
		predicates = append(predicates, actionplanhistory.ReviewFrequencyIn(i.ReviewFrequencyIn...))
	}
	if len(i.ReviewFrequencyNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.ReviewFrequencyNotIn(i.ReviewFrequencyNotIn...))
	}
	if i.ReviewFrequencyIsNil {
		predicates = append(predicates, actionplanhistory.ReviewFrequencyIsNil())
	}
	if i.ReviewFrequencyNotNil {
		predicates = append(predicates, actionplanhistory.ReviewFrequencyNotNil())
	}
	if i.ApproverID != nil {
		predicates = append(predicates, actionplanhistory.ApproverIDEQ(*i.ApproverID))
	}
	if i.ApproverIDNEQ != nil {
		predicates = append(predicates, actionplanhistory.ApproverIDNEQ(*i.ApproverIDNEQ))
	}
	if len(i.ApproverIDIn) > 0 {
		predicates = append(predicates, actionplanhistory.ApproverIDIn(i.ApproverIDIn...))
	}
	if len(i.ApproverIDNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.ApproverIDNotIn(i.ApproverIDNotIn...))
	}
	if i.ApproverIDGT != nil {
		predicates = append(predicates, actionplanhistory.ApproverIDGT(*i.ApproverIDGT))
	}
	if i.ApproverIDGTE != nil {
		predicates = append(predicates, actionplanhistory.ApproverIDGTE(*i.ApproverIDGTE))
	}
	if i.ApproverIDLT != nil {
		predicates = append(predicates, actionplanhistory.ApproverIDLT(*i.ApproverIDLT))
	}
	if i.ApproverIDLTE != nil {
		predicates = append(predicates, actionplanhistory.ApproverIDLTE(*i.ApproverIDLTE))
	}
	if i.ApproverIDContains != nil {
		predicates = append(predicates, actionplanhistory.ApproverIDContains(*i.ApproverIDContains))
	}
	if i.ApproverIDHasPrefix != nil {
		predicates = append(predicates, actionplanhistory.ApproverIDHasPrefix(*i.ApproverIDHasPrefix))
	}
	if i.ApproverIDHasSuffix != nil {
		predicates = append(predicates, actionplanhistory.ApproverIDHasSuffix(*i.ApproverIDHasSuffix))
	}
	if i.ApproverIDIsNil {
		predicates = append(predicates, actionplanhistory.ApproverIDIsNil())
	}
	if i.ApproverIDNotNil {
		predicates = append(predicates, actionplanhistory.ApproverIDNotNil())
	}
	if i.ApproverIDEqualFold != nil {
		predicates = append(predicates, actionplanhistory.ApproverIDEqualFold(*i.ApproverIDEqualFold))
	}
	if i.ApproverIDContainsFold != nil {
		predicates = append(predicates, actionplanhistory.ApproverIDContainsFold(*i.ApproverIDContainsFold))
	}
	if i.DelegateID != nil {
		predicates = append(predicates, actionplanhistory.DelegateIDEQ(*i.DelegateID))
	}
	if i.DelegateIDNEQ != nil {
		predicates = append(predicates, actionplanhistory.DelegateIDNEQ(*i.DelegateIDNEQ))
	}
	if len(i.DelegateIDIn) > 0 {
		predicates = append(predicates, actionplanhistory.DelegateIDIn(i.DelegateIDIn...))
	}
	if len(i.DelegateIDNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.DelegateIDNotIn(i.DelegateIDNotIn...))
	}
	if i.DelegateIDGT != nil {
		predicates = append(predicates, actionplanhistory.DelegateIDGT(*i.DelegateIDGT))
	}
	if i.DelegateIDGTE != nil {
		predicates = append(predicates, actionplanhistory.DelegateIDGTE(*i.DelegateIDGTE))
	}
	if i.DelegateIDLT != nil {
		predicates = append(predicates, actionplanhistory.DelegateIDLT(*i.DelegateIDLT))
	}
	if i.DelegateIDLTE != nil {
		predicates = append(predicates, actionplanhistory.DelegateIDLTE(*i.DelegateIDLTE))
	}
	if i.DelegateIDContains != nil {
		predicates = append(predicates, actionplanhistory.DelegateIDContains(*i.DelegateIDContains))
	}
	if i.DelegateIDHasPrefix != nil {
		predicates = append(predicates, actionplanhistory.DelegateIDHasPrefix(*i.DelegateIDHasPrefix))
	}
	if i.DelegateIDHasSuffix != nil {
		predicates = append(predicates, actionplanhistory.DelegateIDHasSuffix(*i.DelegateIDHasSuffix))
	}
	if i.DelegateIDIsNil {
		predicates = append(predicates, actionplanhistory.DelegateIDIsNil())
	}
	if i.DelegateIDNotNil {
		predicates = append(predicates, actionplanhistory.DelegateIDNotNil())
	}
	if i.DelegateIDEqualFold != nil {
		predicates = append(predicates, actionplanhistory.DelegateIDEqualFold(*i.DelegateIDEqualFold))
	}
	if i.DelegateIDContainsFold != nil {
		predicates = append(predicates, actionplanhistory.DelegateIDContainsFold(*i.DelegateIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, actionplanhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, actionplanhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, actionplanhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, actionplanhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, actionplanhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, actionplanhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, actionplanhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, actionplanhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, actionplanhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, actionplanhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, actionplanhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, actionplanhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, actionplanhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, actionplanhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.DueDate != nil {
		predicates = append(predicates, actionplanhistory.DueDateEQ(*i.DueDate))
	}
	if i.DueDateNEQ != nil {
		predicates = append(predicates, actionplanhistory.DueDateNEQ(*i.DueDateNEQ))
	}
	if len(i.DueDateIn) > 0 {
		predicates = append(predicates, actionplanhistory.DueDateIn(i.DueDateIn...))
	}
	if len(i.DueDateNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.DueDateNotIn(i.DueDateNotIn...))
	}
	if i.DueDateGT != nil {
		predicates = append(predicates, actionplanhistory.DueDateGT(*i.DueDateGT))
	}
	if i.DueDateGTE != nil {
		predicates = append(predicates, actionplanhistory.DueDateGTE(*i.DueDateGTE))
	}
	if i.DueDateLT != nil {
		predicates = append(predicates, actionplanhistory.DueDateLT(*i.DueDateLT))
	}
	if i.DueDateLTE != nil {
		predicates = append(predicates, actionplanhistory.DueDateLTE(*i.DueDateLTE))
	}
	if i.DueDateIsNil {
		predicates = append(predicates, actionplanhistory.DueDateIsNil())
	}
	if i.DueDateNotNil {
		predicates = append(predicates, actionplanhistory.DueDateNotNil())
	}
	if i.Priority != nil {
		predicates = append(predicates, actionplanhistory.PriorityEQ(*i.Priority))
	}
	if i.PriorityNEQ != nil {
		predicates = append(predicates, actionplanhistory.PriorityNEQ(*i.PriorityNEQ))
	}
	if len(i.PriorityIn) > 0 {
		predicates = append(predicates, actionplanhistory.PriorityIn(i.PriorityIn...))
	}
	if len(i.PriorityNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.PriorityNotIn(i.PriorityNotIn...))
	}
	if i.PriorityIsNil {
		predicates = append(predicates, actionplanhistory.PriorityIsNil())
	}
	if i.PriorityNotNil {
		predicates = append(predicates, actionplanhistory.PriorityNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, actionplanhistory.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, actionplanhistory.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, actionplanhistory.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, actionplanhistory.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceGT != nil {
		predicates = append(predicates, actionplanhistory.SourceGT(*i.SourceGT))
	}
	if i.SourceGTE != nil {
		predicates = append(predicates, actionplanhistory.SourceGTE(*i.SourceGTE))
	}
	if i.SourceLT != nil {
		predicates = append(predicates, actionplanhistory.SourceLT(*i.SourceLT))
	}
	if i.SourceLTE != nil {
		predicates = append(predicates, actionplanhistory.SourceLTE(*i.SourceLTE))
	}
	if i.SourceContains != nil {
		predicates = append(predicates, actionplanhistory.SourceContains(*i.SourceContains))
	}
	if i.SourceHasPrefix != nil {
		predicates = append(predicates, actionplanhistory.SourceHasPrefix(*i.SourceHasPrefix))
	}
	if i.SourceHasSuffix != nil {
		predicates = append(predicates, actionplanhistory.SourceHasSuffix(*i.SourceHasSuffix))
	}
	if i.SourceIsNil {
		predicates = append(predicates, actionplanhistory.SourceIsNil())
	}
	if i.SourceNotNil {
		predicates = append(predicates, actionplanhistory.SourceNotNil())
	}
	if i.SourceEqualFold != nil {
		predicates = append(predicates, actionplanhistory.SourceEqualFold(*i.SourceEqualFold))
	}
	if i.SourceContainsFold != nil {
		predicates = append(predicates, actionplanhistory.SourceContainsFold(*i.SourceContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyActionPlanHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return actionplanhistory.And(predicates...), nil
	}
}

// ContactWhereInput represents a where input for filtering Contact queries.
type ContactWhereInput struct {
	Predicates []predicate.Contact  `json:"-"`
	Not        *ContactWhereInput   `json:"not,omitempty"`
	Or         []*ContactWhereInput `json:"or,omitempty"`
	And        []*ContactWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "full_name" field predicates.
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNEQ          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGT           *string  `json:"fullNameGT,omitempty"`
	FullNameGTE          *string  `json:"fullNameGTE,omitempty"`
	FullNameLT           *string  `json:"fullNameLT,omitempty"`
	FullNameLTE          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        bool     `json:"titleIsNil,omitempty"`
	TitleNotNil       bool     `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "company" field predicates.
	Company             *string  `json:"company,omitempty"`
	CompanyNEQ          *string  `json:"companyNEQ,omitempty"`
	CompanyIn           []string `json:"companyIn,omitempty"`
	CompanyNotIn        []string `json:"companyNotIn,omitempty"`
	CompanyGT           *string  `json:"companyGT,omitempty"`
	CompanyGTE          *string  `json:"companyGTE,omitempty"`
	CompanyLT           *string  `json:"companyLT,omitempty"`
	CompanyLTE          *string  `json:"companyLTE,omitempty"`
	CompanyContains     *string  `json:"companyContains,omitempty"`
	CompanyHasPrefix    *string  `json:"companyHasPrefix,omitempty"`
	CompanyHasSuffix    *string  `json:"companyHasSuffix,omitempty"`
	CompanyIsNil        bool     `json:"companyIsNil,omitempty"`
	CompanyNotNil       bool     `json:"companyNotNil,omitempty"`
	CompanyEqualFold    *string  `json:"companyEqualFold,omitempty"`
	CompanyContainsFold *string  `json:"companyContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "phone_number" field predicates.
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNEQ          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGT           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGTE          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLT           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLTE          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        bool     `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       bool     `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "status" field predicates.
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNEQ   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "entities" edge predicates.
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ContactWhereInput) AddPredicates(predicates ...predicate.Contact) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ContactWhereInput filter on the ContactQuery builder.
func (i *ContactWhereInput) Filter(q *ContactQuery) (*ContactQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyContactWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyContactWhereInput is returned in case the ContactWhereInput is empty.
var ErrEmptyContactWhereInput = errors.New("generated: empty predicate ContactWhereInput")

// P returns a predicate for filtering contacts.
// An error is returned if the input is empty or invalid.
func (i *ContactWhereInput) P() (predicate.Contact, error) {
	var predicates []predicate.Contact
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, contact.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Contact, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, contact.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Contact, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, contact.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, contact.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, contact.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, contact.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, contact.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, contact.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, contact.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, contact.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, contact.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, contact.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, contact.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, contact.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, contact.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, contact.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, contact.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, contact.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, contact.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, contact.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, contact.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, contact.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, contact.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, contact.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, contact.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, contact.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, contact.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, contact.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, contact.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, contact.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, contact.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, contact.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, contact.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, contact.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, contact.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, contact.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, contact.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, contact.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, contact.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, contact.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, contact.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, contact.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, contact.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, contact.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, contact.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, contact.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, contact.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, contact.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, contact.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, contact.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, contact.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, contact.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, contact.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, contact.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, contact.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, contact.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, contact.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, contact.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, contact.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, contact.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, contact.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, contact.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, contact.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, contact.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, contact.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, contact.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, contact.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, contact.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, contact.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, contact.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, contact.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, contact.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, contact.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, contact.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, contact.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, contact.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, contact.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, contact.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.FullName != nil {
		predicates = append(predicates, contact.FullNameEQ(*i.FullName))
	}
	if i.FullNameNEQ != nil {
		predicates = append(predicates, contact.FullNameNEQ(*i.FullNameNEQ))
	}
	if len(i.FullNameIn) > 0 {
		predicates = append(predicates, contact.FullNameIn(i.FullNameIn...))
	}
	if len(i.FullNameNotIn) > 0 {
		predicates = append(predicates, contact.FullNameNotIn(i.FullNameNotIn...))
	}
	if i.FullNameGT != nil {
		predicates = append(predicates, contact.FullNameGT(*i.FullNameGT))
	}
	if i.FullNameGTE != nil {
		predicates = append(predicates, contact.FullNameGTE(*i.FullNameGTE))
	}
	if i.FullNameLT != nil {
		predicates = append(predicates, contact.FullNameLT(*i.FullNameLT))
	}
	if i.FullNameLTE != nil {
		predicates = append(predicates, contact.FullNameLTE(*i.FullNameLTE))
	}
	if i.FullNameContains != nil {
		predicates = append(predicates, contact.FullNameContains(*i.FullNameContains))
	}
	if i.FullNameHasPrefix != nil {
		predicates = append(predicates, contact.FullNameHasPrefix(*i.FullNameHasPrefix))
	}
	if i.FullNameHasSuffix != nil {
		predicates = append(predicates, contact.FullNameHasSuffix(*i.FullNameHasSuffix))
	}
	if i.FullNameEqualFold != nil {
		predicates = append(predicates, contact.FullNameEqualFold(*i.FullNameEqualFold))
	}
	if i.FullNameContainsFold != nil {
		predicates = append(predicates, contact.FullNameContainsFold(*i.FullNameContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, contact.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, contact.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, contact.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, contact.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, contact.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, contact.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, contact.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, contact.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, contact.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, contact.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, contact.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleIsNil {
		predicates = append(predicates, contact.TitleIsNil())
	}
	if i.TitleNotNil {
		predicates = append(predicates, contact.TitleNotNil())
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, contact.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, contact.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Company != nil {
		predicates = append(predicates, contact.CompanyEQ(*i.Company))
	}
	if i.CompanyNEQ != nil {
		predicates = append(predicates, contact.CompanyNEQ(*i.CompanyNEQ))
	}
	if len(i.CompanyIn) > 0 {
		predicates = append(predicates, contact.CompanyIn(i.CompanyIn...))
	}
	if len(i.CompanyNotIn) > 0 {
		predicates = append(predicates, contact.CompanyNotIn(i.CompanyNotIn...))
	}
	if i.CompanyGT != nil {
		predicates = append(predicates, contact.CompanyGT(*i.CompanyGT))
	}
	if i.CompanyGTE != nil {
		predicates = append(predicates, contact.CompanyGTE(*i.CompanyGTE))
	}
	if i.CompanyLT != nil {
		predicates = append(predicates, contact.CompanyLT(*i.CompanyLT))
	}
	if i.CompanyLTE != nil {
		predicates = append(predicates, contact.CompanyLTE(*i.CompanyLTE))
	}
	if i.CompanyContains != nil {
		predicates = append(predicates, contact.CompanyContains(*i.CompanyContains))
	}
	if i.CompanyHasPrefix != nil {
		predicates = append(predicates, contact.CompanyHasPrefix(*i.CompanyHasPrefix))
	}
	if i.CompanyHasSuffix != nil {
		predicates = append(predicates, contact.CompanyHasSuffix(*i.CompanyHasSuffix))
	}
	if i.CompanyIsNil {
		predicates = append(predicates, contact.CompanyIsNil())
	}
	if i.CompanyNotNil {
		predicates = append(predicates, contact.CompanyNotNil())
	}
	if i.CompanyEqualFold != nil {
		predicates = append(predicates, contact.CompanyEqualFold(*i.CompanyEqualFold))
	}
	if i.CompanyContainsFold != nil {
		predicates = append(predicates, contact.CompanyContainsFold(*i.CompanyContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, contact.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, contact.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, contact.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, contact.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, contact.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, contact.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, contact.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, contact.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, contact.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, contact.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, contact.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, contact.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, contact.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, contact.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, contact.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.PhoneNumber != nil {
		predicates = append(predicates, contact.PhoneNumberEQ(*i.PhoneNumber))
	}
	if i.PhoneNumberNEQ != nil {
		predicates = append(predicates, contact.PhoneNumberNEQ(*i.PhoneNumberNEQ))
	}
	if len(i.PhoneNumberIn) > 0 {
		predicates = append(predicates, contact.PhoneNumberIn(i.PhoneNumberIn...))
	}
	if len(i.PhoneNumberNotIn) > 0 {
		predicates = append(predicates, contact.PhoneNumberNotIn(i.PhoneNumberNotIn...))
	}
	if i.PhoneNumberGT != nil {
		predicates = append(predicates, contact.PhoneNumberGT(*i.PhoneNumberGT))
	}
	if i.PhoneNumberGTE != nil {
		predicates = append(predicates, contact.PhoneNumberGTE(*i.PhoneNumberGTE))
	}
	if i.PhoneNumberLT != nil {
		predicates = append(predicates, contact.PhoneNumberLT(*i.PhoneNumberLT))
	}
	if i.PhoneNumberLTE != nil {
		predicates = append(predicates, contact.PhoneNumberLTE(*i.PhoneNumberLTE))
	}
	if i.PhoneNumberContains != nil {
		predicates = append(predicates, contact.PhoneNumberContains(*i.PhoneNumberContains))
	}
	if i.PhoneNumberHasPrefix != nil {
		predicates = append(predicates, contact.PhoneNumberHasPrefix(*i.PhoneNumberHasPrefix))
	}
	if i.PhoneNumberHasSuffix != nil {
		predicates = append(predicates, contact.PhoneNumberHasSuffix(*i.PhoneNumberHasSuffix))
	}
	if i.PhoneNumberIsNil {
		predicates = append(predicates, contact.PhoneNumberIsNil())
	}
	if i.PhoneNumberNotNil {
		predicates = append(predicates, contact.PhoneNumberNotNil())
	}
	if i.PhoneNumberEqualFold != nil {
		predicates = append(predicates, contact.PhoneNumberEqualFold(*i.PhoneNumberEqualFold))
	}
	if i.PhoneNumberContainsFold != nil {
		predicates = append(predicates, contact.PhoneNumberContainsFold(*i.PhoneNumberContainsFold))
	}
	if i.Address != nil {
		predicates = append(predicates, contact.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, contact.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, contact.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, contact.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, contact.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, contact.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, contact.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, contact.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, contact.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, contact.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, contact.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, contact.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, contact.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, contact.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, contact.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, contact.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, contact.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, contact.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, contact.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasOwner != nil {
		p := contact.HasOwner()
		if !*i.HasOwner {
			p = contact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contact.HasOwnerWith(with...))
	}
	if i.HasEntities != nil {
		p := contact.HasEntities()
		if !*i.HasEntities {
			p = contact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEntitiesWith) > 0 {
		with := make([]predicate.Entity, 0, len(i.HasEntitiesWith))
		for _, w := range i.HasEntitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEntitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contact.HasEntitiesWith(with...))
	}
	if i.HasFiles != nil {
		p := contact.HasFiles()
		if !*i.HasFiles {
			p = contact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contact.HasFilesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyContactWhereInput
	case 1:
		return predicates[0], nil
	default:
		return contact.And(predicates...), nil
	}
}

// ContactHistoryWhereInput represents a where input for filtering ContactHistory queries.
type ContactHistoryWhereInput struct {
	Predicates []predicate.ContactHistory  `json:"-"`
	Not        *ContactHistoryWhereInput   `json:"not,omitempty"`
	Or         []*ContactHistoryWhereInput `json:"or,omitempty"`
	And        []*ContactHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "full_name" field predicates.
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNEQ          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGT           *string  `json:"fullNameGT,omitempty"`
	FullNameGTE          *string  `json:"fullNameGTE,omitempty"`
	FullNameLT           *string  `json:"fullNameLT,omitempty"`
	FullNameLTE          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        bool     `json:"titleIsNil,omitempty"`
	TitleNotNil       bool     `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "company" field predicates.
	Company             *string  `json:"company,omitempty"`
	CompanyNEQ          *string  `json:"companyNEQ,omitempty"`
	CompanyIn           []string `json:"companyIn,omitempty"`
	CompanyNotIn        []string `json:"companyNotIn,omitempty"`
	CompanyGT           *string  `json:"companyGT,omitempty"`
	CompanyGTE          *string  `json:"companyGTE,omitempty"`
	CompanyLT           *string  `json:"companyLT,omitempty"`
	CompanyLTE          *string  `json:"companyLTE,omitempty"`
	CompanyContains     *string  `json:"companyContains,omitempty"`
	CompanyHasPrefix    *string  `json:"companyHasPrefix,omitempty"`
	CompanyHasSuffix    *string  `json:"companyHasSuffix,omitempty"`
	CompanyIsNil        bool     `json:"companyIsNil,omitempty"`
	CompanyNotNil       bool     `json:"companyNotNil,omitempty"`
	CompanyEqualFold    *string  `json:"companyEqualFold,omitempty"`
	CompanyContainsFold *string  `json:"companyContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "phone_number" field predicates.
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNEQ          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGT           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGTE          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLT           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLTE          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        bool     `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       bool     `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "status" field predicates.
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNEQ   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ContactHistoryWhereInput) AddPredicates(predicates ...predicate.ContactHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ContactHistoryWhereInput filter on the ContactHistoryQuery builder.
func (i *ContactHistoryWhereInput) Filter(q *ContactHistoryQuery) (*ContactHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyContactHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyContactHistoryWhereInput is returned in case the ContactHistoryWhereInput is empty.
var ErrEmptyContactHistoryWhereInput = errors.New("generated: empty predicate ContactHistoryWhereInput")

// P returns a predicate for filtering contacthistories.
// An error is returned if the input is empty or invalid.
func (i *ContactHistoryWhereInput) P() (predicate.ContactHistory, error) {
	var predicates []predicate.ContactHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, contacthistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ContactHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, contacthistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ContactHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, contacthistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, contacthistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, contacthistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, contacthistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, contacthistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, contacthistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, contacthistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, contacthistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, contacthistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, contacthistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, contacthistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, contacthistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, contacthistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, contacthistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, contacthistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, contacthistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, contacthistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, contacthistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, contacthistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, contacthistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, contacthistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, contacthistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, contacthistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, contacthistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, contacthistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, contacthistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, contacthistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, contacthistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, contacthistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, contacthistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, contacthistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, contacthistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, contacthistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, contacthistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, contacthistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, contacthistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, contacthistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, contacthistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, contacthistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, contacthistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, contacthistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, contacthistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, contacthistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, contacthistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, contacthistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, contacthistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, contacthistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, contacthistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, contacthistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, contacthistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, contacthistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, contacthistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, contacthistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, contacthistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, contacthistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, contacthistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, contacthistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, contacthistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, contacthistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, contacthistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, contacthistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, contacthistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, contacthistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, contacthistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, contacthistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, contacthistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, contacthistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, contacthistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, contacthistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, contacthistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, contacthistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, contacthistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, contacthistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, contacthistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, contacthistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, contacthistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, contacthistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, contacthistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, contacthistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, contacthistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, contacthistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, contacthistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, contacthistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, contacthistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, contacthistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, contacthistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, contacthistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, contacthistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, contacthistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, contacthistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, contacthistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, contacthistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, contacthistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, contacthistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, contacthistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, contacthistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, contacthistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, contacthistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, contacthistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, contacthistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, contacthistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, contacthistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, contacthistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.FullName != nil {
		predicates = append(predicates, contacthistory.FullNameEQ(*i.FullName))
	}
	if i.FullNameNEQ != nil {
		predicates = append(predicates, contacthistory.FullNameNEQ(*i.FullNameNEQ))
	}
	if len(i.FullNameIn) > 0 {
		predicates = append(predicates, contacthistory.FullNameIn(i.FullNameIn...))
	}
	if len(i.FullNameNotIn) > 0 {
		predicates = append(predicates, contacthistory.FullNameNotIn(i.FullNameNotIn...))
	}
	if i.FullNameGT != nil {
		predicates = append(predicates, contacthistory.FullNameGT(*i.FullNameGT))
	}
	if i.FullNameGTE != nil {
		predicates = append(predicates, contacthistory.FullNameGTE(*i.FullNameGTE))
	}
	if i.FullNameLT != nil {
		predicates = append(predicates, contacthistory.FullNameLT(*i.FullNameLT))
	}
	if i.FullNameLTE != nil {
		predicates = append(predicates, contacthistory.FullNameLTE(*i.FullNameLTE))
	}
	if i.FullNameContains != nil {
		predicates = append(predicates, contacthistory.FullNameContains(*i.FullNameContains))
	}
	if i.FullNameHasPrefix != nil {
		predicates = append(predicates, contacthistory.FullNameHasPrefix(*i.FullNameHasPrefix))
	}
	if i.FullNameHasSuffix != nil {
		predicates = append(predicates, contacthistory.FullNameHasSuffix(*i.FullNameHasSuffix))
	}
	if i.FullNameEqualFold != nil {
		predicates = append(predicates, contacthistory.FullNameEqualFold(*i.FullNameEqualFold))
	}
	if i.FullNameContainsFold != nil {
		predicates = append(predicates, contacthistory.FullNameContainsFold(*i.FullNameContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, contacthistory.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, contacthistory.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, contacthistory.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, contacthistory.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, contacthistory.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, contacthistory.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, contacthistory.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, contacthistory.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, contacthistory.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, contacthistory.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, contacthistory.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleIsNil {
		predicates = append(predicates, contacthistory.TitleIsNil())
	}
	if i.TitleNotNil {
		predicates = append(predicates, contacthistory.TitleNotNil())
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, contacthistory.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, contacthistory.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Company != nil {
		predicates = append(predicates, contacthistory.CompanyEQ(*i.Company))
	}
	if i.CompanyNEQ != nil {
		predicates = append(predicates, contacthistory.CompanyNEQ(*i.CompanyNEQ))
	}
	if len(i.CompanyIn) > 0 {
		predicates = append(predicates, contacthistory.CompanyIn(i.CompanyIn...))
	}
	if len(i.CompanyNotIn) > 0 {
		predicates = append(predicates, contacthistory.CompanyNotIn(i.CompanyNotIn...))
	}
	if i.CompanyGT != nil {
		predicates = append(predicates, contacthistory.CompanyGT(*i.CompanyGT))
	}
	if i.CompanyGTE != nil {
		predicates = append(predicates, contacthistory.CompanyGTE(*i.CompanyGTE))
	}
	if i.CompanyLT != nil {
		predicates = append(predicates, contacthistory.CompanyLT(*i.CompanyLT))
	}
	if i.CompanyLTE != nil {
		predicates = append(predicates, contacthistory.CompanyLTE(*i.CompanyLTE))
	}
	if i.CompanyContains != nil {
		predicates = append(predicates, contacthistory.CompanyContains(*i.CompanyContains))
	}
	if i.CompanyHasPrefix != nil {
		predicates = append(predicates, contacthistory.CompanyHasPrefix(*i.CompanyHasPrefix))
	}
	if i.CompanyHasSuffix != nil {
		predicates = append(predicates, contacthistory.CompanyHasSuffix(*i.CompanyHasSuffix))
	}
	if i.CompanyIsNil {
		predicates = append(predicates, contacthistory.CompanyIsNil())
	}
	if i.CompanyNotNil {
		predicates = append(predicates, contacthistory.CompanyNotNil())
	}
	if i.CompanyEqualFold != nil {
		predicates = append(predicates, contacthistory.CompanyEqualFold(*i.CompanyEqualFold))
	}
	if i.CompanyContainsFold != nil {
		predicates = append(predicates, contacthistory.CompanyContainsFold(*i.CompanyContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, contacthistory.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, contacthistory.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, contacthistory.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, contacthistory.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, contacthistory.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, contacthistory.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, contacthistory.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, contacthistory.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, contacthistory.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, contacthistory.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, contacthistory.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, contacthistory.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, contacthistory.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, contacthistory.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, contacthistory.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.PhoneNumber != nil {
		predicates = append(predicates, contacthistory.PhoneNumberEQ(*i.PhoneNumber))
	}
	if i.PhoneNumberNEQ != nil {
		predicates = append(predicates, contacthistory.PhoneNumberNEQ(*i.PhoneNumberNEQ))
	}
	if len(i.PhoneNumberIn) > 0 {
		predicates = append(predicates, contacthistory.PhoneNumberIn(i.PhoneNumberIn...))
	}
	if len(i.PhoneNumberNotIn) > 0 {
		predicates = append(predicates, contacthistory.PhoneNumberNotIn(i.PhoneNumberNotIn...))
	}
	if i.PhoneNumberGT != nil {
		predicates = append(predicates, contacthistory.PhoneNumberGT(*i.PhoneNumberGT))
	}
	if i.PhoneNumberGTE != nil {
		predicates = append(predicates, contacthistory.PhoneNumberGTE(*i.PhoneNumberGTE))
	}
	if i.PhoneNumberLT != nil {
		predicates = append(predicates, contacthistory.PhoneNumberLT(*i.PhoneNumberLT))
	}
	if i.PhoneNumberLTE != nil {
		predicates = append(predicates, contacthistory.PhoneNumberLTE(*i.PhoneNumberLTE))
	}
	if i.PhoneNumberContains != nil {
		predicates = append(predicates, contacthistory.PhoneNumberContains(*i.PhoneNumberContains))
	}
	if i.PhoneNumberHasPrefix != nil {
		predicates = append(predicates, contacthistory.PhoneNumberHasPrefix(*i.PhoneNumberHasPrefix))
	}
	if i.PhoneNumberHasSuffix != nil {
		predicates = append(predicates, contacthistory.PhoneNumberHasSuffix(*i.PhoneNumberHasSuffix))
	}
	if i.PhoneNumberIsNil {
		predicates = append(predicates, contacthistory.PhoneNumberIsNil())
	}
	if i.PhoneNumberNotNil {
		predicates = append(predicates, contacthistory.PhoneNumberNotNil())
	}
	if i.PhoneNumberEqualFold != nil {
		predicates = append(predicates, contacthistory.PhoneNumberEqualFold(*i.PhoneNumberEqualFold))
	}
	if i.PhoneNumberContainsFold != nil {
		predicates = append(predicates, contacthistory.PhoneNumberContainsFold(*i.PhoneNumberContainsFold))
	}
	if i.Address != nil {
		predicates = append(predicates, contacthistory.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, contacthistory.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, contacthistory.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, contacthistory.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, contacthistory.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, contacthistory.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, contacthistory.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, contacthistory.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, contacthistory.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, contacthistory.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, contacthistory.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, contacthistory.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, contacthistory.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, contacthistory.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, contacthistory.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, contacthistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, contacthistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, contacthistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, contacthistory.StatusNotIn(i.StatusNotIn...))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyContactHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return contacthistory.And(predicates...), nil
	}
}

// ControlWhereInput represents a where input for filtering Control queries.
type ControlWhereInput struct {
	Predicates []predicate.Control  `json:"-"`
	Not        *ControlWhereInput   `json:"not,omitempty"`
	Or         []*ControlWhereInput `json:"or,omitempty"`
	And        []*ControlWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "reference_id" field predicates.
	ReferenceID             *string  `json:"referenceID,omitempty"`
	ReferenceIDNEQ          *string  `json:"referenceIDNEQ,omitempty"`
	ReferenceIDIn           []string `json:"referenceIDIn,omitempty"`
	ReferenceIDNotIn        []string `json:"referenceIDNotIn,omitempty"`
	ReferenceIDGT           *string  `json:"referenceIDGT,omitempty"`
	ReferenceIDGTE          *string  `json:"referenceIDGTE,omitempty"`
	ReferenceIDLT           *string  `json:"referenceIDLT,omitempty"`
	ReferenceIDLTE          *string  `json:"referenceIDLTE,omitempty"`
	ReferenceIDContains     *string  `json:"referenceIDContains,omitempty"`
	ReferenceIDHasPrefix    *string  `json:"referenceIDHasPrefix,omitempty"`
	ReferenceIDHasSuffix    *string  `json:"referenceIDHasSuffix,omitempty"`
	ReferenceIDIsNil        bool     `json:"referenceIDIsNil,omitempty"`
	ReferenceIDNotNil       bool     `json:"referenceIDNotNil,omitempty"`
	ReferenceIDEqualFold    *string  `json:"referenceIDEqualFold,omitempty"`
	ReferenceIDContainsFold *string  `json:"referenceIDContainsFold,omitempty"`

	// "auditor_reference_id" field predicates.
	AuditorReferenceID             *string  `json:"auditorReferenceID,omitempty"`
	AuditorReferenceIDNEQ          *string  `json:"auditorReferenceIDNEQ,omitempty"`
	AuditorReferenceIDIn           []string `json:"auditorReferenceIDIn,omitempty"`
	AuditorReferenceIDNotIn        []string `json:"auditorReferenceIDNotIn,omitempty"`
	AuditorReferenceIDGT           *string  `json:"auditorReferenceIDGT,omitempty"`
	AuditorReferenceIDGTE          *string  `json:"auditorReferenceIDGTE,omitempty"`
	AuditorReferenceIDLT           *string  `json:"auditorReferenceIDLT,omitempty"`
	AuditorReferenceIDLTE          *string  `json:"auditorReferenceIDLTE,omitempty"`
	AuditorReferenceIDContains     *string  `json:"auditorReferenceIDContains,omitempty"`
	AuditorReferenceIDHasPrefix    *string  `json:"auditorReferenceIDHasPrefix,omitempty"`
	AuditorReferenceIDHasSuffix    *string  `json:"auditorReferenceIDHasSuffix,omitempty"`
	AuditorReferenceIDIsNil        bool     `json:"auditorReferenceIDIsNil,omitempty"`
	AuditorReferenceIDNotNil       bool     `json:"auditorReferenceIDNotNil,omitempty"`
	AuditorReferenceIDEqualFold    *string  `json:"auditorReferenceIDEqualFold,omitempty"`
	AuditorReferenceIDContainsFold *string  `json:"auditorReferenceIDContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.ControlStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.ControlStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.ControlStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.ControlStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil bool                  `json:"statusNotNil,omitempty"`

	// "source" field predicates.
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNEQ    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  bool                  `json:"sourceIsNil,omitempty"`
	SourceNotNil bool                  `json:"sourceNotNil,omitempty"`

	// "reference_framework" field predicates.
	ReferenceFramework             *string  `json:"referenceFramework,omitempty"`
	ReferenceFrameworkNEQ          *string  `json:"referenceFrameworkNEQ,omitempty"`
	ReferenceFrameworkIn           []string `json:"referenceFrameworkIn,omitempty"`
	ReferenceFrameworkNotIn        []string `json:"referenceFrameworkNotIn,omitempty"`
	ReferenceFrameworkGT           *string  `json:"referenceFrameworkGT,omitempty"`
	ReferenceFrameworkGTE          *string  `json:"referenceFrameworkGTE,omitempty"`
	ReferenceFrameworkLT           *string  `json:"referenceFrameworkLT,omitempty"`
	ReferenceFrameworkLTE          *string  `json:"referenceFrameworkLTE,omitempty"`
	ReferenceFrameworkContains     *string  `json:"referenceFrameworkContains,omitempty"`
	ReferenceFrameworkHasPrefix    *string  `json:"referenceFrameworkHasPrefix,omitempty"`
	ReferenceFrameworkHasSuffix    *string  `json:"referenceFrameworkHasSuffix,omitempty"`
	ReferenceFrameworkIsNil        bool     `json:"referenceFrameworkIsNil,omitempty"`
	ReferenceFrameworkNotNil       bool     `json:"referenceFrameworkNotNil,omitempty"`
	ReferenceFrameworkEqualFold    *string  `json:"referenceFrameworkEqualFold,omitempty"`
	ReferenceFrameworkContainsFold *string  `json:"referenceFrameworkContainsFold,omitempty"`

	// "control_type" field predicates.
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNEQ    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  bool                `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil bool                `json:"controlTypeNotNil,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        bool     `json:"categoryIsNil,omitempty"`
	CategoryNotNil       bool     `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "category_id" field predicates.
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIDNEQ          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIDGT           *string  `json:"categoryIDGT,omitempty"`
	CategoryIDGTE          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIDLT           *string  `json:"categoryIDLT,omitempty"`
	CategoryIDLTE          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        bool     `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       bool     `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`

	// "subcategory" field predicates.
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNEQ          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGT           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGTE          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLT           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLTE          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        bool     `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       bool     `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`

	// "control_owner_id" field predicates.
	ControlOwnerID             *string  `json:"controlOwnerID,omitempty"`
	ControlOwnerIDNEQ          *string  `json:"controlOwnerIDNEQ,omitempty"`
	ControlOwnerIDIn           []string `json:"controlOwnerIDIn,omitempty"`
	ControlOwnerIDNotIn        []string `json:"controlOwnerIDNotIn,omitempty"`
	ControlOwnerIDGT           *string  `json:"controlOwnerIDGT,omitempty"`
	ControlOwnerIDGTE          *string  `json:"controlOwnerIDGTE,omitempty"`
	ControlOwnerIDLT           *string  `json:"controlOwnerIDLT,omitempty"`
	ControlOwnerIDLTE          *string  `json:"controlOwnerIDLTE,omitempty"`
	ControlOwnerIDContains     *string  `json:"controlOwnerIDContains,omitempty"`
	ControlOwnerIDHasPrefix    *string  `json:"controlOwnerIDHasPrefix,omitempty"`
	ControlOwnerIDHasSuffix    *string  `json:"controlOwnerIDHasSuffix,omitempty"`
	ControlOwnerIDIsNil        bool     `json:"controlOwnerIDIsNil,omitempty"`
	ControlOwnerIDNotNil       bool     `json:"controlOwnerIDNotNil,omitempty"`
	ControlOwnerIDEqualFold    *string  `json:"controlOwnerIDEqualFold,omitempty"`
	ControlOwnerIDContainsFold *string  `json:"controlOwnerIDContainsFold,omitempty"`

	// "delegate_id" field predicates.
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIDNEQ          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIDGT           *string  `json:"delegateIDGT,omitempty"`
	DelegateIDGTE          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIDLT           *string  `json:"delegateIDLT,omitempty"`
	DelegateIDLTE          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        bool     `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       bool     `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "ref_code" field predicates.
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNEQ          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGT           *string  `json:"refCodeGT,omitempty"`
	RefCodeGTE          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLT           *string  `json:"refCodeLT,omitempty"`
	RefCodeLTE          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`

	// "standard_id" field predicates.
	StandardID             *string  `json:"standardID,omitempty"`
	StandardIDNEQ          *string  `json:"standardIDNEQ,omitempty"`
	StandardIDIn           []string `json:"standardIDIn,omitempty"`
	StandardIDNotIn        []string `json:"standardIDNotIn,omitempty"`
	StandardIDGT           *string  `json:"standardIDGT,omitempty"`
	StandardIDGTE          *string  `json:"standardIDGTE,omitempty"`
	StandardIDLT           *string  `json:"standardIDLT,omitempty"`
	StandardIDLTE          *string  `json:"standardIDLTE,omitempty"`
	StandardIDContains     *string  `json:"standardIDContains,omitempty"`
	StandardIDHasPrefix    *string  `json:"standardIDHasPrefix,omitempty"`
	StandardIDHasSuffix    *string  `json:"standardIDHasSuffix,omitempty"`
	StandardIDIsNil        bool     `json:"standardIDIsNil,omitempty"`
	StandardIDNotNil       bool     `json:"standardIDNotNil,omitempty"`
	StandardIDEqualFold    *string  `json:"standardIDEqualFold,omitempty"`
	StandardIDContainsFold *string  `json:"standardIDContainsFold,omitempty"`

	// "evidence" edge predicates.
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`

	// "control_objectives" edge predicates.
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`

	// "narratives" edge predicates.
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`

	// "risks" edge predicates.
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`

	// "action_plans" edge predicates.
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`

	// "procedures" edge predicates.
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`

	// "internal_policies" edge predicates.
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`

	// "control_owner" edge predicates.
	HasControlOwner     *bool              `json:"hasControlOwner,omitempty"`
	HasControlOwnerWith []*GroupWhereInput `json:"hasControlOwnerWith,omitempty"`

	// "delegate" edge predicates.
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "blocked_groups" edge predicates.
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`

	// "editors" edge predicates.
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`

	// "standard" edge predicates.
	HasStandard     *bool                 `json:"hasStandard,omitempty"`
	HasStandardWith []*StandardWhereInput `json:"hasStandardWith,omitempty"`

	// "programs" edge predicates.
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`

	// "control_implementations" edge predicates.
	HasControlImplementations     *bool                              `json:"hasControlImplementations,omitempty"`
	HasControlImplementationsWith []*ControlImplementationWhereInput `json:"hasControlImplementationsWith,omitempty"`

	// "subcontrols" edge predicates.
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`

	// "scheduled_jobs" edge predicates.
	HasScheduledJobs     *bool                            `json:"hasScheduledJobs,omitempty"`
	HasScheduledJobsWith []*ControlScheduledJobWhereInput `json:"hasScheduledJobsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ControlWhereInput) AddPredicates(predicates ...predicate.Control) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ControlWhereInput filter on the ControlQuery builder.
func (i *ControlWhereInput) Filter(q *ControlQuery) (*ControlQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyControlWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyControlWhereInput is returned in case the ControlWhereInput is empty.
var ErrEmptyControlWhereInput = errors.New("generated: empty predicate ControlWhereInput")

// P returns a predicate for filtering controls.
// An error is returned if the input is empty or invalid.
func (i *ControlWhereInput) P() (predicate.Control, error) {
	var predicates []predicate.Control
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, control.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Control, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, control.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Control, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, control.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, control.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, control.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, control.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, control.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, control.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, control.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, control.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, control.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, control.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, control.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, control.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, control.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, control.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, control.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, control.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, control.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, control.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, control.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, control.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, control.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, control.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, control.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, control.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, control.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, control.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, control.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, control.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, control.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, control.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, control.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, control.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, control.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, control.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, control.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, control.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, control.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, control.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, control.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, control.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, control.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, control.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, control.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, control.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, control.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, control.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, control.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, control.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, control.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, control.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, control.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, control.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, control.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, control.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, control.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, control.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, control.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, control.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, control.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, control.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, control.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, control.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, control.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, control.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, control.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, control.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, control.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, control.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, control.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, control.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, control.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, control.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, control.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, control.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, control.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, control.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, control.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, control.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, control.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, control.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, control.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, control.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, control.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, control.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, control.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, control.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, control.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, control.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, control.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ReferenceID != nil {
		predicates = append(predicates, control.ReferenceIDEQ(*i.ReferenceID))
	}
	if i.ReferenceIDNEQ != nil {
		predicates = append(predicates, control.ReferenceIDNEQ(*i.ReferenceIDNEQ))
	}
	if len(i.ReferenceIDIn) > 0 {
		predicates = append(predicates, control.ReferenceIDIn(i.ReferenceIDIn...))
	}
	if len(i.ReferenceIDNotIn) > 0 {
		predicates = append(predicates, control.ReferenceIDNotIn(i.ReferenceIDNotIn...))
	}
	if i.ReferenceIDGT != nil {
		predicates = append(predicates, control.ReferenceIDGT(*i.ReferenceIDGT))
	}
	if i.ReferenceIDGTE != nil {
		predicates = append(predicates, control.ReferenceIDGTE(*i.ReferenceIDGTE))
	}
	if i.ReferenceIDLT != nil {
		predicates = append(predicates, control.ReferenceIDLT(*i.ReferenceIDLT))
	}
	if i.ReferenceIDLTE != nil {
		predicates = append(predicates, control.ReferenceIDLTE(*i.ReferenceIDLTE))
	}
	if i.ReferenceIDContains != nil {
		predicates = append(predicates, control.ReferenceIDContains(*i.ReferenceIDContains))
	}
	if i.ReferenceIDHasPrefix != nil {
		predicates = append(predicates, control.ReferenceIDHasPrefix(*i.ReferenceIDHasPrefix))
	}
	if i.ReferenceIDHasSuffix != nil {
		predicates = append(predicates, control.ReferenceIDHasSuffix(*i.ReferenceIDHasSuffix))
	}
	if i.ReferenceIDIsNil {
		predicates = append(predicates, control.ReferenceIDIsNil())
	}
	if i.ReferenceIDNotNil {
		predicates = append(predicates, control.ReferenceIDNotNil())
	}
	if i.ReferenceIDEqualFold != nil {
		predicates = append(predicates, control.ReferenceIDEqualFold(*i.ReferenceIDEqualFold))
	}
	if i.ReferenceIDContainsFold != nil {
		predicates = append(predicates, control.ReferenceIDContainsFold(*i.ReferenceIDContainsFold))
	}
	if i.AuditorReferenceID != nil {
		predicates = append(predicates, control.AuditorReferenceIDEQ(*i.AuditorReferenceID))
	}
	if i.AuditorReferenceIDNEQ != nil {
		predicates = append(predicates, control.AuditorReferenceIDNEQ(*i.AuditorReferenceIDNEQ))
	}
	if len(i.AuditorReferenceIDIn) > 0 {
		predicates = append(predicates, control.AuditorReferenceIDIn(i.AuditorReferenceIDIn...))
	}
	if len(i.AuditorReferenceIDNotIn) > 0 {
		predicates = append(predicates, control.AuditorReferenceIDNotIn(i.AuditorReferenceIDNotIn...))
	}
	if i.AuditorReferenceIDGT != nil {
		predicates = append(predicates, control.AuditorReferenceIDGT(*i.AuditorReferenceIDGT))
	}
	if i.AuditorReferenceIDGTE != nil {
		predicates = append(predicates, control.AuditorReferenceIDGTE(*i.AuditorReferenceIDGTE))
	}
	if i.AuditorReferenceIDLT != nil {
		predicates = append(predicates, control.AuditorReferenceIDLT(*i.AuditorReferenceIDLT))
	}
	if i.AuditorReferenceIDLTE != nil {
		predicates = append(predicates, control.AuditorReferenceIDLTE(*i.AuditorReferenceIDLTE))
	}
	if i.AuditorReferenceIDContains != nil {
		predicates = append(predicates, control.AuditorReferenceIDContains(*i.AuditorReferenceIDContains))
	}
	if i.AuditorReferenceIDHasPrefix != nil {
		predicates = append(predicates, control.AuditorReferenceIDHasPrefix(*i.AuditorReferenceIDHasPrefix))
	}
	if i.AuditorReferenceIDHasSuffix != nil {
		predicates = append(predicates, control.AuditorReferenceIDHasSuffix(*i.AuditorReferenceIDHasSuffix))
	}
	if i.AuditorReferenceIDIsNil {
		predicates = append(predicates, control.AuditorReferenceIDIsNil())
	}
	if i.AuditorReferenceIDNotNil {
		predicates = append(predicates, control.AuditorReferenceIDNotNil())
	}
	if i.AuditorReferenceIDEqualFold != nil {
		predicates = append(predicates, control.AuditorReferenceIDEqualFold(*i.AuditorReferenceIDEqualFold))
	}
	if i.AuditorReferenceIDContainsFold != nil {
		predicates = append(predicates, control.AuditorReferenceIDContainsFold(*i.AuditorReferenceIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, control.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, control.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, control.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, control.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, control.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, control.StatusNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, control.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, control.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, control.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, control.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceIsNil {
		predicates = append(predicates, control.SourceIsNil())
	}
	if i.SourceNotNil {
		predicates = append(predicates, control.SourceNotNil())
	}
	if i.ReferenceFramework != nil {
		predicates = append(predicates, control.ReferenceFrameworkEQ(*i.ReferenceFramework))
	}
	if i.ReferenceFrameworkNEQ != nil {
		predicates = append(predicates, control.ReferenceFrameworkNEQ(*i.ReferenceFrameworkNEQ))
	}
	if len(i.ReferenceFrameworkIn) > 0 {
		predicates = append(predicates, control.ReferenceFrameworkIn(i.ReferenceFrameworkIn...))
	}
	if len(i.ReferenceFrameworkNotIn) > 0 {
		predicates = append(predicates, control.ReferenceFrameworkNotIn(i.ReferenceFrameworkNotIn...))
	}
	if i.ReferenceFrameworkGT != nil {
		predicates = append(predicates, control.ReferenceFrameworkGT(*i.ReferenceFrameworkGT))
	}
	if i.ReferenceFrameworkGTE != nil {
		predicates = append(predicates, control.ReferenceFrameworkGTE(*i.ReferenceFrameworkGTE))
	}
	if i.ReferenceFrameworkLT != nil {
		predicates = append(predicates, control.ReferenceFrameworkLT(*i.ReferenceFrameworkLT))
	}
	if i.ReferenceFrameworkLTE != nil {
		predicates = append(predicates, control.ReferenceFrameworkLTE(*i.ReferenceFrameworkLTE))
	}
	if i.ReferenceFrameworkContains != nil {
		predicates = append(predicates, control.ReferenceFrameworkContains(*i.ReferenceFrameworkContains))
	}
	if i.ReferenceFrameworkHasPrefix != nil {
		predicates = append(predicates, control.ReferenceFrameworkHasPrefix(*i.ReferenceFrameworkHasPrefix))
	}
	if i.ReferenceFrameworkHasSuffix != nil {
		predicates = append(predicates, control.ReferenceFrameworkHasSuffix(*i.ReferenceFrameworkHasSuffix))
	}
	if i.ReferenceFrameworkIsNil {
		predicates = append(predicates, control.ReferenceFrameworkIsNil())
	}
	if i.ReferenceFrameworkNotNil {
		predicates = append(predicates, control.ReferenceFrameworkNotNil())
	}
	if i.ReferenceFrameworkEqualFold != nil {
		predicates = append(predicates, control.ReferenceFrameworkEqualFold(*i.ReferenceFrameworkEqualFold))
	}
	if i.ReferenceFrameworkContainsFold != nil {
		predicates = append(predicates, control.ReferenceFrameworkContainsFold(*i.ReferenceFrameworkContainsFold))
	}
	if i.ControlType != nil {
		predicates = append(predicates, control.ControlTypeEQ(*i.ControlType))
	}
	if i.ControlTypeNEQ != nil {
		predicates = append(predicates, control.ControlTypeNEQ(*i.ControlTypeNEQ))
	}
	if len(i.ControlTypeIn) > 0 {
		predicates = append(predicates, control.ControlTypeIn(i.ControlTypeIn...))
	}
	if len(i.ControlTypeNotIn) > 0 {
		predicates = append(predicates, control.ControlTypeNotIn(i.ControlTypeNotIn...))
	}
	if i.ControlTypeIsNil {
		predicates = append(predicates, control.ControlTypeIsNil())
	}
	if i.ControlTypeNotNil {
		predicates = append(predicates, control.ControlTypeNotNil())
	}
	if i.Category != nil {
		predicates = append(predicates, control.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, control.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, control.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, control.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, control.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, control.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, control.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, control.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, control.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, control.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, control.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryIsNil {
		predicates = append(predicates, control.CategoryIsNil())
	}
	if i.CategoryNotNil {
		predicates = append(predicates, control.CategoryNotNil())
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, control.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, control.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.CategoryID != nil {
		predicates = append(predicates, control.CategoryIDEQ(*i.CategoryID))
	}
	if i.CategoryIDNEQ != nil {
		predicates = append(predicates, control.CategoryIDNEQ(*i.CategoryIDNEQ))
	}
	if len(i.CategoryIDIn) > 0 {
		predicates = append(predicates, control.CategoryIDIn(i.CategoryIDIn...))
	}
	if len(i.CategoryIDNotIn) > 0 {
		predicates = append(predicates, control.CategoryIDNotIn(i.CategoryIDNotIn...))
	}
	if i.CategoryIDGT != nil {
		predicates = append(predicates, control.CategoryIDGT(*i.CategoryIDGT))
	}
	if i.CategoryIDGTE != nil {
		predicates = append(predicates, control.CategoryIDGTE(*i.CategoryIDGTE))
	}
	if i.CategoryIDLT != nil {
		predicates = append(predicates, control.CategoryIDLT(*i.CategoryIDLT))
	}
	if i.CategoryIDLTE != nil {
		predicates = append(predicates, control.CategoryIDLTE(*i.CategoryIDLTE))
	}
	if i.CategoryIDContains != nil {
		predicates = append(predicates, control.CategoryIDContains(*i.CategoryIDContains))
	}
	if i.CategoryIDHasPrefix != nil {
		predicates = append(predicates, control.CategoryIDHasPrefix(*i.CategoryIDHasPrefix))
	}
	if i.CategoryIDHasSuffix != nil {
		predicates = append(predicates, control.CategoryIDHasSuffix(*i.CategoryIDHasSuffix))
	}
	if i.CategoryIDIsNil {
		predicates = append(predicates, control.CategoryIDIsNil())
	}
	if i.CategoryIDNotNil {
		predicates = append(predicates, control.CategoryIDNotNil())
	}
	if i.CategoryIDEqualFold != nil {
		predicates = append(predicates, control.CategoryIDEqualFold(*i.CategoryIDEqualFold))
	}
	if i.CategoryIDContainsFold != nil {
		predicates = append(predicates, control.CategoryIDContainsFold(*i.CategoryIDContainsFold))
	}
	if i.Subcategory != nil {
		predicates = append(predicates, control.SubcategoryEQ(*i.Subcategory))
	}
	if i.SubcategoryNEQ != nil {
		predicates = append(predicates, control.SubcategoryNEQ(*i.SubcategoryNEQ))
	}
	if len(i.SubcategoryIn) > 0 {
		predicates = append(predicates, control.SubcategoryIn(i.SubcategoryIn...))
	}
	if len(i.SubcategoryNotIn) > 0 {
		predicates = append(predicates, control.SubcategoryNotIn(i.SubcategoryNotIn...))
	}
	if i.SubcategoryGT != nil {
		predicates = append(predicates, control.SubcategoryGT(*i.SubcategoryGT))
	}
	if i.SubcategoryGTE != nil {
		predicates = append(predicates, control.SubcategoryGTE(*i.SubcategoryGTE))
	}
	if i.SubcategoryLT != nil {
		predicates = append(predicates, control.SubcategoryLT(*i.SubcategoryLT))
	}
	if i.SubcategoryLTE != nil {
		predicates = append(predicates, control.SubcategoryLTE(*i.SubcategoryLTE))
	}
	if i.SubcategoryContains != nil {
		predicates = append(predicates, control.SubcategoryContains(*i.SubcategoryContains))
	}
	if i.SubcategoryHasPrefix != nil {
		predicates = append(predicates, control.SubcategoryHasPrefix(*i.SubcategoryHasPrefix))
	}
	if i.SubcategoryHasSuffix != nil {
		predicates = append(predicates, control.SubcategoryHasSuffix(*i.SubcategoryHasSuffix))
	}
	if i.SubcategoryIsNil {
		predicates = append(predicates, control.SubcategoryIsNil())
	}
	if i.SubcategoryNotNil {
		predicates = append(predicates, control.SubcategoryNotNil())
	}
	if i.SubcategoryEqualFold != nil {
		predicates = append(predicates, control.SubcategoryEqualFold(*i.SubcategoryEqualFold))
	}
	if i.SubcategoryContainsFold != nil {
		predicates = append(predicates, control.SubcategoryContainsFold(*i.SubcategoryContainsFold))
	}
	if i.ControlOwnerID != nil {
		predicates = append(predicates, control.ControlOwnerIDEQ(*i.ControlOwnerID))
	}
	if i.ControlOwnerIDNEQ != nil {
		predicates = append(predicates, control.ControlOwnerIDNEQ(*i.ControlOwnerIDNEQ))
	}
	if len(i.ControlOwnerIDIn) > 0 {
		predicates = append(predicates, control.ControlOwnerIDIn(i.ControlOwnerIDIn...))
	}
	if len(i.ControlOwnerIDNotIn) > 0 {
		predicates = append(predicates, control.ControlOwnerIDNotIn(i.ControlOwnerIDNotIn...))
	}
	if i.ControlOwnerIDGT != nil {
		predicates = append(predicates, control.ControlOwnerIDGT(*i.ControlOwnerIDGT))
	}
	if i.ControlOwnerIDGTE != nil {
		predicates = append(predicates, control.ControlOwnerIDGTE(*i.ControlOwnerIDGTE))
	}
	if i.ControlOwnerIDLT != nil {
		predicates = append(predicates, control.ControlOwnerIDLT(*i.ControlOwnerIDLT))
	}
	if i.ControlOwnerIDLTE != nil {
		predicates = append(predicates, control.ControlOwnerIDLTE(*i.ControlOwnerIDLTE))
	}
	if i.ControlOwnerIDContains != nil {
		predicates = append(predicates, control.ControlOwnerIDContains(*i.ControlOwnerIDContains))
	}
	if i.ControlOwnerIDHasPrefix != nil {
		predicates = append(predicates, control.ControlOwnerIDHasPrefix(*i.ControlOwnerIDHasPrefix))
	}
	if i.ControlOwnerIDHasSuffix != nil {
		predicates = append(predicates, control.ControlOwnerIDHasSuffix(*i.ControlOwnerIDHasSuffix))
	}
	if i.ControlOwnerIDIsNil {
		predicates = append(predicates, control.ControlOwnerIDIsNil())
	}
	if i.ControlOwnerIDNotNil {
		predicates = append(predicates, control.ControlOwnerIDNotNil())
	}
	if i.ControlOwnerIDEqualFold != nil {
		predicates = append(predicates, control.ControlOwnerIDEqualFold(*i.ControlOwnerIDEqualFold))
	}
	if i.ControlOwnerIDContainsFold != nil {
		predicates = append(predicates, control.ControlOwnerIDContainsFold(*i.ControlOwnerIDContainsFold))
	}
	if i.DelegateID != nil {
		predicates = append(predicates, control.DelegateIDEQ(*i.DelegateID))
	}
	if i.DelegateIDNEQ != nil {
		predicates = append(predicates, control.DelegateIDNEQ(*i.DelegateIDNEQ))
	}
	if len(i.DelegateIDIn) > 0 {
		predicates = append(predicates, control.DelegateIDIn(i.DelegateIDIn...))
	}
	if len(i.DelegateIDNotIn) > 0 {
		predicates = append(predicates, control.DelegateIDNotIn(i.DelegateIDNotIn...))
	}
	if i.DelegateIDGT != nil {
		predicates = append(predicates, control.DelegateIDGT(*i.DelegateIDGT))
	}
	if i.DelegateIDGTE != nil {
		predicates = append(predicates, control.DelegateIDGTE(*i.DelegateIDGTE))
	}
	if i.DelegateIDLT != nil {
		predicates = append(predicates, control.DelegateIDLT(*i.DelegateIDLT))
	}
	if i.DelegateIDLTE != nil {
		predicates = append(predicates, control.DelegateIDLTE(*i.DelegateIDLTE))
	}
	if i.DelegateIDContains != nil {
		predicates = append(predicates, control.DelegateIDContains(*i.DelegateIDContains))
	}
	if i.DelegateIDHasPrefix != nil {
		predicates = append(predicates, control.DelegateIDHasPrefix(*i.DelegateIDHasPrefix))
	}
	if i.DelegateIDHasSuffix != nil {
		predicates = append(predicates, control.DelegateIDHasSuffix(*i.DelegateIDHasSuffix))
	}
	if i.DelegateIDIsNil {
		predicates = append(predicates, control.DelegateIDIsNil())
	}
	if i.DelegateIDNotNil {
		predicates = append(predicates, control.DelegateIDNotNil())
	}
	if i.DelegateIDEqualFold != nil {
		predicates = append(predicates, control.DelegateIDEqualFold(*i.DelegateIDEqualFold))
	}
	if i.DelegateIDContainsFold != nil {
		predicates = append(predicates, control.DelegateIDContainsFold(*i.DelegateIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, control.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, control.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, control.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, control.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, control.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, control.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, control.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, control.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, control.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, control.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, control.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, control.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, control.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, control.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, control.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.RefCode != nil {
		predicates = append(predicates, control.RefCodeEQ(*i.RefCode))
	}
	if i.RefCodeNEQ != nil {
		predicates = append(predicates, control.RefCodeNEQ(*i.RefCodeNEQ))
	}
	if len(i.RefCodeIn) > 0 {
		predicates = append(predicates, control.RefCodeIn(i.RefCodeIn...))
	}
	if len(i.RefCodeNotIn) > 0 {
		predicates = append(predicates, control.RefCodeNotIn(i.RefCodeNotIn...))
	}
	if i.RefCodeGT != nil {
		predicates = append(predicates, control.RefCodeGT(*i.RefCodeGT))
	}
	if i.RefCodeGTE != nil {
		predicates = append(predicates, control.RefCodeGTE(*i.RefCodeGTE))
	}
	if i.RefCodeLT != nil {
		predicates = append(predicates, control.RefCodeLT(*i.RefCodeLT))
	}
	if i.RefCodeLTE != nil {
		predicates = append(predicates, control.RefCodeLTE(*i.RefCodeLTE))
	}
	if i.RefCodeContains != nil {
		predicates = append(predicates, control.RefCodeContains(*i.RefCodeContains))
	}
	if i.RefCodeHasPrefix != nil {
		predicates = append(predicates, control.RefCodeHasPrefix(*i.RefCodeHasPrefix))
	}
	if i.RefCodeHasSuffix != nil {
		predicates = append(predicates, control.RefCodeHasSuffix(*i.RefCodeHasSuffix))
	}
	if i.RefCodeEqualFold != nil {
		predicates = append(predicates, control.RefCodeEqualFold(*i.RefCodeEqualFold))
	}
	if i.RefCodeContainsFold != nil {
		predicates = append(predicates, control.RefCodeContainsFold(*i.RefCodeContainsFold))
	}
	if i.StandardID != nil {
		predicates = append(predicates, control.StandardIDEQ(*i.StandardID))
	}
	if i.StandardIDNEQ != nil {
		predicates = append(predicates, control.StandardIDNEQ(*i.StandardIDNEQ))
	}
	if len(i.StandardIDIn) > 0 {
		predicates = append(predicates, control.StandardIDIn(i.StandardIDIn...))
	}
	if len(i.StandardIDNotIn) > 0 {
		predicates = append(predicates, control.StandardIDNotIn(i.StandardIDNotIn...))
	}
	if i.StandardIDGT != nil {
		predicates = append(predicates, control.StandardIDGT(*i.StandardIDGT))
	}
	if i.StandardIDGTE != nil {
		predicates = append(predicates, control.StandardIDGTE(*i.StandardIDGTE))
	}
	if i.StandardIDLT != nil {
		predicates = append(predicates, control.StandardIDLT(*i.StandardIDLT))
	}
	if i.StandardIDLTE != nil {
		predicates = append(predicates, control.StandardIDLTE(*i.StandardIDLTE))
	}
	if i.StandardIDContains != nil {
		predicates = append(predicates, control.StandardIDContains(*i.StandardIDContains))
	}
	if i.StandardIDHasPrefix != nil {
		predicates = append(predicates, control.StandardIDHasPrefix(*i.StandardIDHasPrefix))
	}
	if i.StandardIDHasSuffix != nil {
		predicates = append(predicates, control.StandardIDHasSuffix(*i.StandardIDHasSuffix))
	}
	if i.StandardIDIsNil {
		predicates = append(predicates, control.StandardIDIsNil())
	}
	if i.StandardIDNotNil {
		predicates = append(predicates, control.StandardIDNotNil())
	}
	if i.StandardIDEqualFold != nil {
		predicates = append(predicates, control.StandardIDEqualFold(*i.StandardIDEqualFold))
	}
	if i.StandardIDContainsFold != nil {
		predicates = append(predicates, control.StandardIDContainsFold(*i.StandardIDContainsFold))
	}

	if i.HasEvidence != nil {
		p := control.HasEvidence()
		if !*i.HasEvidence {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEvidenceWith) > 0 {
		with := make([]predicate.Evidence, 0, len(i.HasEvidenceWith))
		for _, w := range i.HasEvidenceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEvidenceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasEvidenceWith(with...))
	}
	if i.HasControlObjectives != nil {
		p := control.HasControlObjectives()
		if !*i.HasControlObjectives {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlObjectivesWith) > 0 {
		with := make([]predicate.ControlObjective, 0, len(i.HasControlObjectivesWith))
		for _, w := range i.HasControlObjectivesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlObjectivesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasControlObjectivesWith(with...))
	}
	if i.HasTasks != nil {
		p := control.HasTasks()
		if !*i.HasTasks {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasTasksWith(with...))
	}
	if i.HasNarratives != nil {
		p := control.HasNarratives()
		if !*i.HasNarratives {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNarrativesWith) > 0 {
		with := make([]predicate.Narrative, 0, len(i.HasNarrativesWith))
		for _, w := range i.HasNarrativesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNarrativesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasNarrativesWith(with...))
	}
	if i.HasRisks != nil {
		p := control.HasRisks()
		if !*i.HasRisks {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRisksWith) > 0 {
		with := make([]predicate.Risk, 0, len(i.HasRisksWith))
		for _, w := range i.HasRisksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRisksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasRisksWith(with...))
	}
	if i.HasActionPlans != nil {
		p := control.HasActionPlans()
		if !*i.HasActionPlans {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionPlansWith) > 0 {
		with := make([]predicate.ActionPlan, 0, len(i.HasActionPlansWith))
		for _, w := range i.HasActionPlansWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionPlansWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasActionPlansWith(with...))
	}
	if i.HasProcedures != nil {
		p := control.HasProcedures()
		if !*i.HasProcedures {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProceduresWith) > 0 {
		with := make([]predicate.Procedure, 0, len(i.HasProceduresWith))
		for _, w := range i.HasProceduresWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProceduresWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasProceduresWith(with...))
	}
	if i.HasInternalPolicies != nil {
		p := control.HasInternalPolicies()
		if !*i.HasInternalPolicies {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInternalPoliciesWith) > 0 {
		with := make([]predicate.InternalPolicy, 0, len(i.HasInternalPoliciesWith))
		for _, w := range i.HasInternalPoliciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInternalPoliciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasInternalPoliciesWith(with...))
	}
	if i.HasControlOwner != nil {
		p := control.HasControlOwner()
		if !*i.HasControlOwner {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlOwnerWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasControlOwnerWith))
		for _, w := range i.HasControlOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasControlOwnerWith(with...))
	}
	if i.HasDelegate != nil {
		p := control.HasDelegate()
		if !*i.HasDelegate {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDelegateWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasDelegateWith))
		for _, w := range i.HasDelegateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDelegateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasDelegateWith(with...))
	}
	if i.HasOwner != nil {
		p := control.HasOwner()
		if !*i.HasOwner {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasOwnerWith(with...))
	}
	if i.HasBlockedGroups != nil {
		p := control.HasBlockedGroups()
		if !*i.HasBlockedGroups {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBlockedGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasBlockedGroupsWith))
		for _, w := range i.HasBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasBlockedGroupsWith(with...))
	}
	if i.HasEditors != nil {
		p := control.HasEditors()
		if !*i.HasEditors {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEditorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasEditorsWith))
		for _, w := range i.HasEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasEditorsWith(with...))
	}
	if i.HasStandard != nil {
		p := control.HasStandard()
		if !*i.HasStandard {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStandardWith) > 0 {
		with := make([]predicate.Standard, 0, len(i.HasStandardWith))
		for _, w := range i.HasStandardWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStandardWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasStandardWith(with...))
	}
	if i.HasPrograms != nil {
		p := control.HasPrograms()
		if !*i.HasPrograms {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramsWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramsWith))
		for _, w := range i.HasProgramsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasProgramsWith(with...))
	}
	if i.HasControlImplementations != nil {
		p := control.HasControlImplementations()
		if !*i.HasControlImplementations {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlImplementationsWith) > 0 {
		with := make([]predicate.ControlImplementation, 0, len(i.HasControlImplementationsWith))
		for _, w := range i.HasControlImplementationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlImplementationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasControlImplementationsWith(with...))
	}
	if i.HasSubcontrols != nil {
		p := control.HasSubcontrols()
		if !*i.HasSubcontrols {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubcontrolsWith) > 0 {
		with := make([]predicate.Subcontrol, 0, len(i.HasSubcontrolsWith))
		for _, w := range i.HasSubcontrolsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubcontrolsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasSubcontrolsWith(with...))
	}
	if i.HasScheduledJobs != nil {
		p := control.HasScheduledJobs()
		if !*i.HasScheduledJobs {
			p = control.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScheduledJobsWith) > 0 {
		with := make([]predicate.ControlScheduledJob, 0, len(i.HasScheduledJobsWith))
		for _, w := range i.HasScheduledJobsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasScheduledJobsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, control.HasScheduledJobsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyControlWhereInput
	case 1:
		return predicates[0], nil
	default:
		return control.And(predicates...), nil
	}
}

// ControlHistoryWhereInput represents a where input for filtering ControlHistory queries.
type ControlHistoryWhereInput struct {
	Predicates []predicate.ControlHistory  `json:"-"`
	Not        *ControlHistoryWhereInput   `json:"not,omitempty"`
	Or         []*ControlHistoryWhereInput `json:"or,omitempty"`
	And        []*ControlHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "reference_id" field predicates.
	ReferenceID             *string  `json:"referenceID,omitempty"`
	ReferenceIDNEQ          *string  `json:"referenceIDNEQ,omitempty"`
	ReferenceIDIn           []string `json:"referenceIDIn,omitempty"`
	ReferenceIDNotIn        []string `json:"referenceIDNotIn,omitempty"`
	ReferenceIDGT           *string  `json:"referenceIDGT,omitempty"`
	ReferenceIDGTE          *string  `json:"referenceIDGTE,omitempty"`
	ReferenceIDLT           *string  `json:"referenceIDLT,omitempty"`
	ReferenceIDLTE          *string  `json:"referenceIDLTE,omitempty"`
	ReferenceIDContains     *string  `json:"referenceIDContains,omitempty"`
	ReferenceIDHasPrefix    *string  `json:"referenceIDHasPrefix,omitempty"`
	ReferenceIDHasSuffix    *string  `json:"referenceIDHasSuffix,omitempty"`
	ReferenceIDIsNil        bool     `json:"referenceIDIsNil,omitempty"`
	ReferenceIDNotNil       bool     `json:"referenceIDNotNil,omitempty"`
	ReferenceIDEqualFold    *string  `json:"referenceIDEqualFold,omitempty"`
	ReferenceIDContainsFold *string  `json:"referenceIDContainsFold,omitempty"`

	// "auditor_reference_id" field predicates.
	AuditorReferenceID             *string  `json:"auditorReferenceID,omitempty"`
	AuditorReferenceIDNEQ          *string  `json:"auditorReferenceIDNEQ,omitempty"`
	AuditorReferenceIDIn           []string `json:"auditorReferenceIDIn,omitempty"`
	AuditorReferenceIDNotIn        []string `json:"auditorReferenceIDNotIn,omitempty"`
	AuditorReferenceIDGT           *string  `json:"auditorReferenceIDGT,omitempty"`
	AuditorReferenceIDGTE          *string  `json:"auditorReferenceIDGTE,omitempty"`
	AuditorReferenceIDLT           *string  `json:"auditorReferenceIDLT,omitempty"`
	AuditorReferenceIDLTE          *string  `json:"auditorReferenceIDLTE,omitempty"`
	AuditorReferenceIDContains     *string  `json:"auditorReferenceIDContains,omitempty"`
	AuditorReferenceIDHasPrefix    *string  `json:"auditorReferenceIDHasPrefix,omitempty"`
	AuditorReferenceIDHasSuffix    *string  `json:"auditorReferenceIDHasSuffix,omitempty"`
	AuditorReferenceIDIsNil        bool     `json:"auditorReferenceIDIsNil,omitempty"`
	AuditorReferenceIDNotNil       bool     `json:"auditorReferenceIDNotNil,omitempty"`
	AuditorReferenceIDEqualFold    *string  `json:"auditorReferenceIDEqualFold,omitempty"`
	AuditorReferenceIDContainsFold *string  `json:"auditorReferenceIDContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.ControlStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.ControlStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.ControlStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.ControlStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil bool                  `json:"statusNotNil,omitempty"`

	// "source" field predicates.
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNEQ    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  bool                  `json:"sourceIsNil,omitempty"`
	SourceNotNil bool                  `json:"sourceNotNil,omitempty"`

	// "reference_framework" field predicates.
	ReferenceFramework             *string  `json:"referenceFramework,omitempty"`
	ReferenceFrameworkNEQ          *string  `json:"referenceFrameworkNEQ,omitempty"`
	ReferenceFrameworkIn           []string `json:"referenceFrameworkIn,omitempty"`
	ReferenceFrameworkNotIn        []string `json:"referenceFrameworkNotIn,omitempty"`
	ReferenceFrameworkGT           *string  `json:"referenceFrameworkGT,omitempty"`
	ReferenceFrameworkGTE          *string  `json:"referenceFrameworkGTE,omitempty"`
	ReferenceFrameworkLT           *string  `json:"referenceFrameworkLT,omitempty"`
	ReferenceFrameworkLTE          *string  `json:"referenceFrameworkLTE,omitempty"`
	ReferenceFrameworkContains     *string  `json:"referenceFrameworkContains,omitempty"`
	ReferenceFrameworkHasPrefix    *string  `json:"referenceFrameworkHasPrefix,omitempty"`
	ReferenceFrameworkHasSuffix    *string  `json:"referenceFrameworkHasSuffix,omitempty"`
	ReferenceFrameworkIsNil        bool     `json:"referenceFrameworkIsNil,omitempty"`
	ReferenceFrameworkNotNil       bool     `json:"referenceFrameworkNotNil,omitempty"`
	ReferenceFrameworkEqualFold    *string  `json:"referenceFrameworkEqualFold,omitempty"`
	ReferenceFrameworkContainsFold *string  `json:"referenceFrameworkContainsFold,omitempty"`

	// "control_type" field predicates.
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNEQ    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  bool                `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil bool                `json:"controlTypeNotNil,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        bool     `json:"categoryIsNil,omitempty"`
	CategoryNotNil       bool     `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "category_id" field predicates.
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIDNEQ          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIDGT           *string  `json:"categoryIDGT,omitempty"`
	CategoryIDGTE          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIDLT           *string  `json:"categoryIDLT,omitempty"`
	CategoryIDLTE          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        bool     `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       bool     `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`

	// "subcategory" field predicates.
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNEQ          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGT           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGTE          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLT           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLTE          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        bool     `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       bool     `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`

	// "control_owner_id" field predicates.
	ControlOwnerID             *string  `json:"controlOwnerID,omitempty"`
	ControlOwnerIDNEQ          *string  `json:"controlOwnerIDNEQ,omitempty"`
	ControlOwnerIDIn           []string `json:"controlOwnerIDIn,omitempty"`
	ControlOwnerIDNotIn        []string `json:"controlOwnerIDNotIn,omitempty"`
	ControlOwnerIDGT           *string  `json:"controlOwnerIDGT,omitempty"`
	ControlOwnerIDGTE          *string  `json:"controlOwnerIDGTE,omitempty"`
	ControlOwnerIDLT           *string  `json:"controlOwnerIDLT,omitempty"`
	ControlOwnerIDLTE          *string  `json:"controlOwnerIDLTE,omitempty"`
	ControlOwnerIDContains     *string  `json:"controlOwnerIDContains,omitempty"`
	ControlOwnerIDHasPrefix    *string  `json:"controlOwnerIDHasPrefix,omitempty"`
	ControlOwnerIDHasSuffix    *string  `json:"controlOwnerIDHasSuffix,omitempty"`
	ControlOwnerIDIsNil        bool     `json:"controlOwnerIDIsNil,omitempty"`
	ControlOwnerIDNotNil       bool     `json:"controlOwnerIDNotNil,omitempty"`
	ControlOwnerIDEqualFold    *string  `json:"controlOwnerIDEqualFold,omitempty"`
	ControlOwnerIDContainsFold *string  `json:"controlOwnerIDContainsFold,omitempty"`

	// "delegate_id" field predicates.
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIDNEQ          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIDGT           *string  `json:"delegateIDGT,omitempty"`
	DelegateIDGTE          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIDLT           *string  `json:"delegateIDLT,omitempty"`
	DelegateIDLTE          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        bool     `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       bool     `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "ref_code" field predicates.
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNEQ          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGT           *string  `json:"refCodeGT,omitempty"`
	RefCodeGTE          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLT           *string  `json:"refCodeLT,omitempty"`
	RefCodeLTE          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`

	// "standard_id" field predicates.
	StandardID             *string  `json:"standardID,omitempty"`
	StandardIDNEQ          *string  `json:"standardIDNEQ,omitempty"`
	StandardIDIn           []string `json:"standardIDIn,omitempty"`
	StandardIDNotIn        []string `json:"standardIDNotIn,omitempty"`
	StandardIDGT           *string  `json:"standardIDGT,omitempty"`
	StandardIDGTE          *string  `json:"standardIDGTE,omitempty"`
	StandardIDLT           *string  `json:"standardIDLT,omitempty"`
	StandardIDLTE          *string  `json:"standardIDLTE,omitempty"`
	StandardIDContains     *string  `json:"standardIDContains,omitempty"`
	StandardIDHasPrefix    *string  `json:"standardIDHasPrefix,omitempty"`
	StandardIDHasSuffix    *string  `json:"standardIDHasSuffix,omitempty"`
	StandardIDIsNil        bool     `json:"standardIDIsNil,omitempty"`
	StandardIDNotNil       bool     `json:"standardIDNotNil,omitempty"`
	StandardIDEqualFold    *string  `json:"standardIDEqualFold,omitempty"`
	StandardIDContainsFold *string  `json:"standardIDContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ControlHistoryWhereInput) AddPredicates(predicates ...predicate.ControlHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ControlHistoryWhereInput filter on the ControlHistoryQuery builder.
func (i *ControlHistoryWhereInput) Filter(q *ControlHistoryQuery) (*ControlHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyControlHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyControlHistoryWhereInput is returned in case the ControlHistoryWhereInput is empty.
var ErrEmptyControlHistoryWhereInput = errors.New("generated: empty predicate ControlHistoryWhereInput")

// P returns a predicate for filtering controlhistories.
// An error is returned if the input is empty or invalid.
func (i *ControlHistoryWhereInput) P() (predicate.ControlHistory, error) {
	var predicates []predicate.ControlHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, controlhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ControlHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, controlhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ControlHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, controlhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, controlhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, controlhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, controlhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, controlhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, controlhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, controlhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, controlhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, controlhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, controlhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, controlhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, controlhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, controlhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, controlhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, controlhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, controlhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, controlhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, controlhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, controlhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, controlhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, controlhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, controlhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, controlhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, controlhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, controlhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, controlhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, controlhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, controlhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, controlhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, controlhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, controlhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, controlhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, controlhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, controlhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, controlhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, controlhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, controlhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, controlhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, controlhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, controlhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, controlhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, controlhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, controlhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, controlhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, controlhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, controlhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, controlhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, controlhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, controlhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, controlhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, controlhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, controlhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, controlhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, controlhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, controlhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, controlhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, controlhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, controlhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, controlhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, controlhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, controlhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, controlhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, controlhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, controlhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, controlhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, controlhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, controlhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, controlhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, controlhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, controlhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, controlhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, controlhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, controlhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, controlhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, controlhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, controlhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, controlhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, controlhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, controlhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, controlhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, controlhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, controlhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, controlhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, controlhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, controlhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, controlhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, controlhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, controlhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, controlhistory.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, controlhistory.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, controlhistory.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, controlhistory.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, controlhistory.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, controlhistory.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, controlhistory.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, controlhistory.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, controlhistory.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, controlhistory.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, controlhistory.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, controlhistory.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, controlhistory.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, controlhistory.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, controlhistory.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, controlhistory.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, controlhistory.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, controlhistory.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, controlhistory.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, controlhistory.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, controlhistory.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, controlhistory.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, controlhistory.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, controlhistory.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, controlhistory.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, controlhistory.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, controlhistory.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, controlhistory.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ReferenceID != nil {
		predicates = append(predicates, controlhistory.ReferenceIDEQ(*i.ReferenceID))
	}
	if i.ReferenceIDNEQ != nil {
		predicates = append(predicates, controlhistory.ReferenceIDNEQ(*i.ReferenceIDNEQ))
	}
	if len(i.ReferenceIDIn) > 0 {
		predicates = append(predicates, controlhistory.ReferenceIDIn(i.ReferenceIDIn...))
	}
	if len(i.ReferenceIDNotIn) > 0 {
		predicates = append(predicates, controlhistory.ReferenceIDNotIn(i.ReferenceIDNotIn...))
	}
	if i.ReferenceIDGT != nil {
		predicates = append(predicates, controlhistory.ReferenceIDGT(*i.ReferenceIDGT))
	}
	if i.ReferenceIDGTE != nil {
		predicates = append(predicates, controlhistory.ReferenceIDGTE(*i.ReferenceIDGTE))
	}
	if i.ReferenceIDLT != nil {
		predicates = append(predicates, controlhistory.ReferenceIDLT(*i.ReferenceIDLT))
	}
	if i.ReferenceIDLTE != nil {
		predicates = append(predicates, controlhistory.ReferenceIDLTE(*i.ReferenceIDLTE))
	}
	if i.ReferenceIDContains != nil {
		predicates = append(predicates, controlhistory.ReferenceIDContains(*i.ReferenceIDContains))
	}
	if i.ReferenceIDHasPrefix != nil {
		predicates = append(predicates, controlhistory.ReferenceIDHasPrefix(*i.ReferenceIDHasPrefix))
	}
	if i.ReferenceIDHasSuffix != nil {
		predicates = append(predicates, controlhistory.ReferenceIDHasSuffix(*i.ReferenceIDHasSuffix))
	}
	if i.ReferenceIDIsNil {
		predicates = append(predicates, controlhistory.ReferenceIDIsNil())
	}
	if i.ReferenceIDNotNil {
		predicates = append(predicates, controlhistory.ReferenceIDNotNil())
	}
	if i.ReferenceIDEqualFold != nil {
		predicates = append(predicates, controlhistory.ReferenceIDEqualFold(*i.ReferenceIDEqualFold))
	}
	if i.ReferenceIDContainsFold != nil {
		predicates = append(predicates, controlhistory.ReferenceIDContainsFold(*i.ReferenceIDContainsFold))
	}
	if i.AuditorReferenceID != nil {
		predicates = append(predicates, controlhistory.AuditorReferenceIDEQ(*i.AuditorReferenceID))
	}
	if i.AuditorReferenceIDNEQ != nil {
		predicates = append(predicates, controlhistory.AuditorReferenceIDNEQ(*i.AuditorReferenceIDNEQ))
	}
	if len(i.AuditorReferenceIDIn) > 0 {
		predicates = append(predicates, controlhistory.AuditorReferenceIDIn(i.AuditorReferenceIDIn...))
	}
	if len(i.AuditorReferenceIDNotIn) > 0 {
		predicates = append(predicates, controlhistory.AuditorReferenceIDNotIn(i.AuditorReferenceIDNotIn...))
	}
	if i.AuditorReferenceIDGT != nil {
		predicates = append(predicates, controlhistory.AuditorReferenceIDGT(*i.AuditorReferenceIDGT))
	}
	if i.AuditorReferenceIDGTE != nil {
		predicates = append(predicates, controlhistory.AuditorReferenceIDGTE(*i.AuditorReferenceIDGTE))
	}
	if i.AuditorReferenceIDLT != nil {
		predicates = append(predicates, controlhistory.AuditorReferenceIDLT(*i.AuditorReferenceIDLT))
	}
	if i.AuditorReferenceIDLTE != nil {
		predicates = append(predicates, controlhistory.AuditorReferenceIDLTE(*i.AuditorReferenceIDLTE))
	}
	if i.AuditorReferenceIDContains != nil {
		predicates = append(predicates, controlhistory.AuditorReferenceIDContains(*i.AuditorReferenceIDContains))
	}
	if i.AuditorReferenceIDHasPrefix != nil {
		predicates = append(predicates, controlhistory.AuditorReferenceIDHasPrefix(*i.AuditorReferenceIDHasPrefix))
	}
	if i.AuditorReferenceIDHasSuffix != nil {
		predicates = append(predicates, controlhistory.AuditorReferenceIDHasSuffix(*i.AuditorReferenceIDHasSuffix))
	}
	if i.AuditorReferenceIDIsNil {
		predicates = append(predicates, controlhistory.AuditorReferenceIDIsNil())
	}
	if i.AuditorReferenceIDNotNil {
		predicates = append(predicates, controlhistory.AuditorReferenceIDNotNil())
	}
	if i.AuditorReferenceIDEqualFold != nil {
		predicates = append(predicates, controlhistory.AuditorReferenceIDEqualFold(*i.AuditorReferenceIDEqualFold))
	}
	if i.AuditorReferenceIDContainsFold != nil {
		predicates = append(predicates, controlhistory.AuditorReferenceIDContainsFold(*i.AuditorReferenceIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, controlhistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, controlhistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, controlhistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, controlhistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, controlhistory.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, controlhistory.StatusNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, controlhistory.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, controlhistory.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, controlhistory.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, controlhistory.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceIsNil {
		predicates = append(predicates, controlhistory.SourceIsNil())
	}
	if i.SourceNotNil {
		predicates = append(predicates, controlhistory.SourceNotNil())
	}
	if i.ReferenceFramework != nil {
		predicates = append(predicates, controlhistory.ReferenceFrameworkEQ(*i.ReferenceFramework))
	}
	if i.ReferenceFrameworkNEQ != nil {
		predicates = append(predicates, controlhistory.ReferenceFrameworkNEQ(*i.ReferenceFrameworkNEQ))
	}
	if len(i.ReferenceFrameworkIn) > 0 {
		predicates = append(predicates, controlhistory.ReferenceFrameworkIn(i.ReferenceFrameworkIn...))
	}
	if len(i.ReferenceFrameworkNotIn) > 0 {
		predicates = append(predicates, controlhistory.ReferenceFrameworkNotIn(i.ReferenceFrameworkNotIn...))
	}
	if i.ReferenceFrameworkGT != nil {
		predicates = append(predicates, controlhistory.ReferenceFrameworkGT(*i.ReferenceFrameworkGT))
	}
	if i.ReferenceFrameworkGTE != nil {
		predicates = append(predicates, controlhistory.ReferenceFrameworkGTE(*i.ReferenceFrameworkGTE))
	}
	if i.ReferenceFrameworkLT != nil {
		predicates = append(predicates, controlhistory.ReferenceFrameworkLT(*i.ReferenceFrameworkLT))
	}
	if i.ReferenceFrameworkLTE != nil {
		predicates = append(predicates, controlhistory.ReferenceFrameworkLTE(*i.ReferenceFrameworkLTE))
	}
	if i.ReferenceFrameworkContains != nil {
		predicates = append(predicates, controlhistory.ReferenceFrameworkContains(*i.ReferenceFrameworkContains))
	}
	if i.ReferenceFrameworkHasPrefix != nil {
		predicates = append(predicates, controlhistory.ReferenceFrameworkHasPrefix(*i.ReferenceFrameworkHasPrefix))
	}
	if i.ReferenceFrameworkHasSuffix != nil {
		predicates = append(predicates, controlhistory.ReferenceFrameworkHasSuffix(*i.ReferenceFrameworkHasSuffix))
	}
	if i.ReferenceFrameworkIsNil {
		predicates = append(predicates, controlhistory.ReferenceFrameworkIsNil())
	}
	if i.ReferenceFrameworkNotNil {
		predicates = append(predicates, controlhistory.ReferenceFrameworkNotNil())
	}
	if i.ReferenceFrameworkEqualFold != nil {
		predicates = append(predicates, controlhistory.ReferenceFrameworkEqualFold(*i.ReferenceFrameworkEqualFold))
	}
	if i.ReferenceFrameworkContainsFold != nil {
		predicates = append(predicates, controlhistory.ReferenceFrameworkContainsFold(*i.ReferenceFrameworkContainsFold))
	}
	if i.ControlType != nil {
		predicates = append(predicates, controlhistory.ControlTypeEQ(*i.ControlType))
	}
	if i.ControlTypeNEQ != nil {
		predicates = append(predicates, controlhistory.ControlTypeNEQ(*i.ControlTypeNEQ))
	}
	if len(i.ControlTypeIn) > 0 {
		predicates = append(predicates, controlhistory.ControlTypeIn(i.ControlTypeIn...))
	}
	if len(i.ControlTypeNotIn) > 0 {
		predicates = append(predicates, controlhistory.ControlTypeNotIn(i.ControlTypeNotIn...))
	}
	if i.ControlTypeIsNil {
		predicates = append(predicates, controlhistory.ControlTypeIsNil())
	}
	if i.ControlTypeNotNil {
		predicates = append(predicates, controlhistory.ControlTypeNotNil())
	}
	if i.Category != nil {
		predicates = append(predicates, controlhistory.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, controlhistory.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, controlhistory.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, controlhistory.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, controlhistory.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, controlhistory.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, controlhistory.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, controlhistory.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, controlhistory.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, controlhistory.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, controlhistory.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryIsNil {
		predicates = append(predicates, controlhistory.CategoryIsNil())
	}
	if i.CategoryNotNil {
		predicates = append(predicates, controlhistory.CategoryNotNil())
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, controlhistory.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, controlhistory.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.CategoryID != nil {
		predicates = append(predicates, controlhistory.CategoryIDEQ(*i.CategoryID))
	}
	if i.CategoryIDNEQ != nil {
		predicates = append(predicates, controlhistory.CategoryIDNEQ(*i.CategoryIDNEQ))
	}
	if len(i.CategoryIDIn) > 0 {
		predicates = append(predicates, controlhistory.CategoryIDIn(i.CategoryIDIn...))
	}
	if len(i.CategoryIDNotIn) > 0 {
		predicates = append(predicates, controlhistory.CategoryIDNotIn(i.CategoryIDNotIn...))
	}
	if i.CategoryIDGT != nil {
		predicates = append(predicates, controlhistory.CategoryIDGT(*i.CategoryIDGT))
	}
	if i.CategoryIDGTE != nil {
		predicates = append(predicates, controlhistory.CategoryIDGTE(*i.CategoryIDGTE))
	}
	if i.CategoryIDLT != nil {
		predicates = append(predicates, controlhistory.CategoryIDLT(*i.CategoryIDLT))
	}
	if i.CategoryIDLTE != nil {
		predicates = append(predicates, controlhistory.CategoryIDLTE(*i.CategoryIDLTE))
	}
	if i.CategoryIDContains != nil {
		predicates = append(predicates, controlhistory.CategoryIDContains(*i.CategoryIDContains))
	}
	if i.CategoryIDHasPrefix != nil {
		predicates = append(predicates, controlhistory.CategoryIDHasPrefix(*i.CategoryIDHasPrefix))
	}
	if i.CategoryIDHasSuffix != nil {
		predicates = append(predicates, controlhistory.CategoryIDHasSuffix(*i.CategoryIDHasSuffix))
	}
	if i.CategoryIDIsNil {
		predicates = append(predicates, controlhistory.CategoryIDIsNil())
	}
	if i.CategoryIDNotNil {
		predicates = append(predicates, controlhistory.CategoryIDNotNil())
	}
	if i.CategoryIDEqualFold != nil {
		predicates = append(predicates, controlhistory.CategoryIDEqualFold(*i.CategoryIDEqualFold))
	}
	if i.CategoryIDContainsFold != nil {
		predicates = append(predicates, controlhistory.CategoryIDContainsFold(*i.CategoryIDContainsFold))
	}
	if i.Subcategory != nil {
		predicates = append(predicates, controlhistory.SubcategoryEQ(*i.Subcategory))
	}
	if i.SubcategoryNEQ != nil {
		predicates = append(predicates, controlhistory.SubcategoryNEQ(*i.SubcategoryNEQ))
	}
	if len(i.SubcategoryIn) > 0 {
		predicates = append(predicates, controlhistory.SubcategoryIn(i.SubcategoryIn...))
	}
	if len(i.SubcategoryNotIn) > 0 {
		predicates = append(predicates, controlhistory.SubcategoryNotIn(i.SubcategoryNotIn...))
	}
	if i.SubcategoryGT != nil {
		predicates = append(predicates, controlhistory.SubcategoryGT(*i.SubcategoryGT))
	}
	if i.SubcategoryGTE != nil {
		predicates = append(predicates, controlhistory.SubcategoryGTE(*i.SubcategoryGTE))
	}
	if i.SubcategoryLT != nil {
		predicates = append(predicates, controlhistory.SubcategoryLT(*i.SubcategoryLT))
	}
	if i.SubcategoryLTE != nil {
		predicates = append(predicates, controlhistory.SubcategoryLTE(*i.SubcategoryLTE))
	}
	if i.SubcategoryContains != nil {
		predicates = append(predicates, controlhistory.SubcategoryContains(*i.SubcategoryContains))
	}
	if i.SubcategoryHasPrefix != nil {
		predicates = append(predicates, controlhistory.SubcategoryHasPrefix(*i.SubcategoryHasPrefix))
	}
	if i.SubcategoryHasSuffix != nil {
		predicates = append(predicates, controlhistory.SubcategoryHasSuffix(*i.SubcategoryHasSuffix))
	}
	if i.SubcategoryIsNil {
		predicates = append(predicates, controlhistory.SubcategoryIsNil())
	}
	if i.SubcategoryNotNil {
		predicates = append(predicates, controlhistory.SubcategoryNotNil())
	}
	if i.SubcategoryEqualFold != nil {
		predicates = append(predicates, controlhistory.SubcategoryEqualFold(*i.SubcategoryEqualFold))
	}
	if i.SubcategoryContainsFold != nil {
		predicates = append(predicates, controlhistory.SubcategoryContainsFold(*i.SubcategoryContainsFold))
	}
	if i.ControlOwnerID != nil {
		predicates = append(predicates, controlhistory.ControlOwnerIDEQ(*i.ControlOwnerID))
	}
	if i.ControlOwnerIDNEQ != nil {
		predicates = append(predicates, controlhistory.ControlOwnerIDNEQ(*i.ControlOwnerIDNEQ))
	}
	if len(i.ControlOwnerIDIn) > 0 {
		predicates = append(predicates, controlhistory.ControlOwnerIDIn(i.ControlOwnerIDIn...))
	}
	if len(i.ControlOwnerIDNotIn) > 0 {
		predicates = append(predicates, controlhistory.ControlOwnerIDNotIn(i.ControlOwnerIDNotIn...))
	}
	if i.ControlOwnerIDGT != nil {
		predicates = append(predicates, controlhistory.ControlOwnerIDGT(*i.ControlOwnerIDGT))
	}
	if i.ControlOwnerIDGTE != nil {
		predicates = append(predicates, controlhistory.ControlOwnerIDGTE(*i.ControlOwnerIDGTE))
	}
	if i.ControlOwnerIDLT != nil {
		predicates = append(predicates, controlhistory.ControlOwnerIDLT(*i.ControlOwnerIDLT))
	}
	if i.ControlOwnerIDLTE != nil {
		predicates = append(predicates, controlhistory.ControlOwnerIDLTE(*i.ControlOwnerIDLTE))
	}
	if i.ControlOwnerIDContains != nil {
		predicates = append(predicates, controlhistory.ControlOwnerIDContains(*i.ControlOwnerIDContains))
	}
	if i.ControlOwnerIDHasPrefix != nil {
		predicates = append(predicates, controlhistory.ControlOwnerIDHasPrefix(*i.ControlOwnerIDHasPrefix))
	}
	if i.ControlOwnerIDHasSuffix != nil {
		predicates = append(predicates, controlhistory.ControlOwnerIDHasSuffix(*i.ControlOwnerIDHasSuffix))
	}
	if i.ControlOwnerIDIsNil {
		predicates = append(predicates, controlhistory.ControlOwnerIDIsNil())
	}
	if i.ControlOwnerIDNotNil {
		predicates = append(predicates, controlhistory.ControlOwnerIDNotNil())
	}
	if i.ControlOwnerIDEqualFold != nil {
		predicates = append(predicates, controlhistory.ControlOwnerIDEqualFold(*i.ControlOwnerIDEqualFold))
	}
	if i.ControlOwnerIDContainsFold != nil {
		predicates = append(predicates, controlhistory.ControlOwnerIDContainsFold(*i.ControlOwnerIDContainsFold))
	}
	if i.DelegateID != nil {
		predicates = append(predicates, controlhistory.DelegateIDEQ(*i.DelegateID))
	}
	if i.DelegateIDNEQ != nil {
		predicates = append(predicates, controlhistory.DelegateIDNEQ(*i.DelegateIDNEQ))
	}
	if len(i.DelegateIDIn) > 0 {
		predicates = append(predicates, controlhistory.DelegateIDIn(i.DelegateIDIn...))
	}
	if len(i.DelegateIDNotIn) > 0 {
		predicates = append(predicates, controlhistory.DelegateIDNotIn(i.DelegateIDNotIn...))
	}
	if i.DelegateIDGT != nil {
		predicates = append(predicates, controlhistory.DelegateIDGT(*i.DelegateIDGT))
	}
	if i.DelegateIDGTE != nil {
		predicates = append(predicates, controlhistory.DelegateIDGTE(*i.DelegateIDGTE))
	}
	if i.DelegateIDLT != nil {
		predicates = append(predicates, controlhistory.DelegateIDLT(*i.DelegateIDLT))
	}
	if i.DelegateIDLTE != nil {
		predicates = append(predicates, controlhistory.DelegateIDLTE(*i.DelegateIDLTE))
	}
	if i.DelegateIDContains != nil {
		predicates = append(predicates, controlhistory.DelegateIDContains(*i.DelegateIDContains))
	}
	if i.DelegateIDHasPrefix != nil {
		predicates = append(predicates, controlhistory.DelegateIDHasPrefix(*i.DelegateIDHasPrefix))
	}
	if i.DelegateIDHasSuffix != nil {
		predicates = append(predicates, controlhistory.DelegateIDHasSuffix(*i.DelegateIDHasSuffix))
	}
	if i.DelegateIDIsNil {
		predicates = append(predicates, controlhistory.DelegateIDIsNil())
	}
	if i.DelegateIDNotNil {
		predicates = append(predicates, controlhistory.DelegateIDNotNil())
	}
	if i.DelegateIDEqualFold != nil {
		predicates = append(predicates, controlhistory.DelegateIDEqualFold(*i.DelegateIDEqualFold))
	}
	if i.DelegateIDContainsFold != nil {
		predicates = append(predicates, controlhistory.DelegateIDContainsFold(*i.DelegateIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, controlhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, controlhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, controlhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, controlhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, controlhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, controlhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, controlhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, controlhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, controlhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, controlhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, controlhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, controlhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, controlhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, controlhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, controlhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.RefCode != nil {
		predicates = append(predicates, controlhistory.RefCodeEQ(*i.RefCode))
	}
	if i.RefCodeNEQ != nil {
		predicates = append(predicates, controlhistory.RefCodeNEQ(*i.RefCodeNEQ))
	}
	if len(i.RefCodeIn) > 0 {
		predicates = append(predicates, controlhistory.RefCodeIn(i.RefCodeIn...))
	}
	if len(i.RefCodeNotIn) > 0 {
		predicates = append(predicates, controlhistory.RefCodeNotIn(i.RefCodeNotIn...))
	}
	if i.RefCodeGT != nil {
		predicates = append(predicates, controlhistory.RefCodeGT(*i.RefCodeGT))
	}
	if i.RefCodeGTE != nil {
		predicates = append(predicates, controlhistory.RefCodeGTE(*i.RefCodeGTE))
	}
	if i.RefCodeLT != nil {
		predicates = append(predicates, controlhistory.RefCodeLT(*i.RefCodeLT))
	}
	if i.RefCodeLTE != nil {
		predicates = append(predicates, controlhistory.RefCodeLTE(*i.RefCodeLTE))
	}
	if i.RefCodeContains != nil {
		predicates = append(predicates, controlhistory.RefCodeContains(*i.RefCodeContains))
	}
	if i.RefCodeHasPrefix != nil {
		predicates = append(predicates, controlhistory.RefCodeHasPrefix(*i.RefCodeHasPrefix))
	}
	if i.RefCodeHasSuffix != nil {
		predicates = append(predicates, controlhistory.RefCodeHasSuffix(*i.RefCodeHasSuffix))
	}
	if i.RefCodeEqualFold != nil {
		predicates = append(predicates, controlhistory.RefCodeEqualFold(*i.RefCodeEqualFold))
	}
	if i.RefCodeContainsFold != nil {
		predicates = append(predicates, controlhistory.RefCodeContainsFold(*i.RefCodeContainsFold))
	}
	if i.StandardID != nil {
		predicates = append(predicates, controlhistory.StandardIDEQ(*i.StandardID))
	}
	if i.StandardIDNEQ != nil {
		predicates = append(predicates, controlhistory.StandardIDNEQ(*i.StandardIDNEQ))
	}
	if len(i.StandardIDIn) > 0 {
		predicates = append(predicates, controlhistory.StandardIDIn(i.StandardIDIn...))
	}
	if len(i.StandardIDNotIn) > 0 {
		predicates = append(predicates, controlhistory.StandardIDNotIn(i.StandardIDNotIn...))
	}
	if i.StandardIDGT != nil {
		predicates = append(predicates, controlhistory.StandardIDGT(*i.StandardIDGT))
	}
	if i.StandardIDGTE != nil {
		predicates = append(predicates, controlhistory.StandardIDGTE(*i.StandardIDGTE))
	}
	if i.StandardIDLT != nil {
		predicates = append(predicates, controlhistory.StandardIDLT(*i.StandardIDLT))
	}
	if i.StandardIDLTE != nil {
		predicates = append(predicates, controlhistory.StandardIDLTE(*i.StandardIDLTE))
	}
	if i.StandardIDContains != nil {
		predicates = append(predicates, controlhistory.StandardIDContains(*i.StandardIDContains))
	}
	if i.StandardIDHasPrefix != nil {
		predicates = append(predicates, controlhistory.StandardIDHasPrefix(*i.StandardIDHasPrefix))
	}
	if i.StandardIDHasSuffix != nil {
		predicates = append(predicates, controlhistory.StandardIDHasSuffix(*i.StandardIDHasSuffix))
	}
	if i.StandardIDIsNil {
		predicates = append(predicates, controlhistory.StandardIDIsNil())
	}
	if i.StandardIDNotNil {
		predicates = append(predicates, controlhistory.StandardIDNotNil())
	}
	if i.StandardIDEqualFold != nil {
		predicates = append(predicates, controlhistory.StandardIDEqualFold(*i.StandardIDEqualFold))
	}
	if i.StandardIDContainsFold != nil {
		predicates = append(predicates, controlhistory.StandardIDContainsFold(*i.StandardIDContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyControlHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return controlhistory.And(predicates...), nil
	}
}

// ControlImplementationWhereInput represents a where input for filtering ControlImplementation queries.
type ControlImplementationWhereInput struct {
	Predicates []predicate.ControlImplementation  `json:"-"`
	Not        *ControlImplementationWhereInput   `json:"not,omitempty"`
	Or         []*ControlImplementationWhereInput `json:"or,omitempty"`
	And        []*ControlImplementationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                   `json:"statusIsNil,omitempty"`
	StatusNotNil bool                   `json:"statusNotNil,omitempty"`

	// "implementation_date" field predicates.
	ImplementationDate       *time.Time  `json:"implementationDate,omitempty"`
	ImplementationDateNEQ    *time.Time  `json:"implementationDateNEQ,omitempty"`
	ImplementationDateIn     []time.Time `json:"implementationDateIn,omitempty"`
	ImplementationDateNotIn  []time.Time `json:"implementationDateNotIn,omitempty"`
	ImplementationDateGT     *time.Time  `json:"implementationDateGT,omitempty"`
	ImplementationDateGTE    *time.Time  `json:"implementationDateGTE,omitempty"`
	ImplementationDateLT     *time.Time  `json:"implementationDateLT,omitempty"`
	ImplementationDateLTE    *time.Time  `json:"implementationDateLTE,omitempty"`
	ImplementationDateIsNil  bool        `json:"implementationDateIsNil,omitempty"`
	ImplementationDateNotNil bool        `json:"implementationDateNotNil,omitempty"`

	// "verified" field predicates.
	Verified       *bool `json:"verified,omitempty"`
	VerifiedNEQ    *bool `json:"verifiedNEQ,omitempty"`
	VerifiedIsNil  bool  `json:"verifiedIsNil,omitempty"`
	VerifiedNotNil bool  `json:"verifiedNotNil,omitempty"`

	// "verification_date" field predicates.
	VerificationDate       *time.Time  `json:"verificationDate,omitempty"`
	VerificationDateNEQ    *time.Time  `json:"verificationDateNEQ,omitempty"`
	VerificationDateIn     []time.Time `json:"verificationDateIn,omitempty"`
	VerificationDateNotIn  []time.Time `json:"verificationDateNotIn,omitempty"`
	VerificationDateGT     *time.Time  `json:"verificationDateGT,omitempty"`
	VerificationDateGTE    *time.Time  `json:"verificationDateGTE,omitempty"`
	VerificationDateLT     *time.Time  `json:"verificationDateLT,omitempty"`
	VerificationDateLTE    *time.Time  `json:"verificationDateLTE,omitempty"`
	VerificationDateIsNil  bool        `json:"verificationDateIsNil,omitempty"`
	VerificationDateNotNil bool        `json:"verificationDateNotNil,omitempty"`

	// "details" field predicates.
	Details             *string  `json:"details,omitempty"`
	DetailsNEQ          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGT           *string  `json:"detailsGT,omitempty"`
	DetailsGTE          *string  `json:"detailsGTE,omitempty"`
	DetailsLT           *string  `json:"detailsLT,omitempty"`
	DetailsLTE          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        bool     `json:"detailsIsNil,omitempty"`
	DetailsNotNil       bool     `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "blocked_groups" edge predicates.
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`

	// "editors" edge predicates.
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`

	// "viewers" edge predicates.
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`

	// "controls" edge predicates.
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`

	// "subcontrols" edge predicates.
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ControlImplementationWhereInput) AddPredicates(predicates ...predicate.ControlImplementation) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ControlImplementationWhereInput filter on the ControlImplementationQuery builder.
func (i *ControlImplementationWhereInput) Filter(q *ControlImplementationQuery) (*ControlImplementationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyControlImplementationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyControlImplementationWhereInput is returned in case the ControlImplementationWhereInput is empty.
var ErrEmptyControlImplementationWhereInput = errors.New("generated: empty predicate ControlImplementationWhereInput")

// P returns a predicate for filtering controlimplementations.
// An error is returned if the input is empty or invalid.
func (i *ControlImplementationWhereInput) P() (predicate.ControlImplementation, error) {
	var predicates []predicate.ControlImplementation
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, controlimplementation.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ControlImplementation, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, controlimplementation.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ControlImplementation, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, controlimplementation.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, controlimplementation.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, controlimplementation.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, controlimplementation.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, controlimplementation.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, controlimplementation.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, controlimplementation.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, controlimplementation.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, controlimplementation.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, controlimplementation.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, controlimplementation.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, controlimplementation.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, controlimplementation.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, controlimplementation.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, controlimplementation.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, controlimplementation.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, controlimplementation.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, controlimplementation.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, controlimplementation.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, controlimplementation.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, controlimplementation.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, controlimplementation.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, controlimplementation.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, controlimplementation.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, controlimplementation.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, controlimplementation.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, controlimplementation.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, controlimplementation.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, controlimplementation.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, controlimplementation.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, controlimplementation.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, controlimplementation.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, controlimplementation.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, controlimplementation.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, controlimplementation.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, controlimplementation.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, controlimplementation.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, controlimplementation.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, controlimplementation.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, controlimplementation.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, controlimplementation.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, controlimplementation.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, controlimplementation.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, controlimplementation.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, controlimplementation.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, controlimplementation.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, controlimplementation.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, controlimplementation.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, controlimplementation.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, controlimplementation.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, controlimplementation.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, controlimplementation.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, controlimplementation.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, controlimplementation.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, controlimplementation.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, controlimplementation.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, controlimplementation.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, controlimplementation.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, controlimplementation.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, controlimplementation.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, controlimplementation.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, controlimplementation.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, controlimplementation.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, controlimplementation.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, controlimplementation.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, controlimplementation.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, controlimplementation.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, controlimplementation.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, controlimplementation.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, controlimplementation.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, controlimplementation.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, controlimplementation.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, controlimplementation.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, controlimplementation.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, controlimplementation.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, controlimplementation.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, controlimplementation.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, controlimplementation.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, controlimplementation.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, controlimplementation.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, controlimplementation.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, controlimplementation.StatusNotNil())
	}
	if i.ImplementationDate != nil {
		predicates = append(predicates, controlimplementation.ImplementationDateEQ(*i.ImplementationDate))
	}
	if i.ImplementationDateNEQ != nil {
		predicates = append(predicates, controlimplementation.ImplementationDateNEQ(*i.ImplementationDateNEQ))
	}
	if len(i.ImplementationDateIn) > 0 {
		predicates = append(predicates, controlimplementation.ImplementationDateIn(i.ImplementationDateIn...))
	}
	if len(i.ImplementationDateNotIn) > 0 {
		predicates = append(predicates, controlimplementation.ImplementationDateNotIn(i.ImplementationDateNotIn...))
	}
	if i.ImplementationDateGT != nil {
		predicates = append(predicates, controlimplementation.ImplementationDateGT(*i.ImplementationDateGT))
	}
	if i.ImplementationDateGTE != nil {
		predicates = append(predicates, controlimplementation.ImplementationDateGTE(*i.ImplementationDateGTE))
	}
	if i.ImplementationDateLT != nil {
		predicates = append(predicates, controlimplementation.ImplementationDateLT(*i.ImplementationDateLT))
	}
	if i.ImplementationDateLTE != nil {
		predicates = append(predicates, controlimplementation.ImplementationDateLTE(*i.ImplementationDateLTE))
	}
	if i.ImplementationDateIsNil {
		predicates = append(predicates, controlimplementation.ImplementationDateIsNil())
	}
	if i.ImplementationDateNotNil {
		predicates = append(predicates, controlimplementation.ImplementationDateNotNil())
	}
	if i.Verified != nil {
		predicates = append(predicates, controlimplementation.VerifiedEQ(*i.Verified))
	}
	if i.VerifiedNEQ != nil {
		predicates = append(predicates, controlimplementation.VerifiedNEQ(*i.VerifiedNEQ))
	}
	if i.VerifiedIsNil {
		predicates = append(predicates, controlimplementation.VerifiedIsNil())
	}
	if i.VerifiedNotNil {
		predicates = append(predicates, controlimplementation.VerifiedNotNil())
	}
	if i.VerificationDate != nil {
		predicates = append(predicates, controlimplementation.VerificationDateEQ(*i.VerificationDate))
	}
	if i.VerificationDateNEQ != nil {
		predicates = append(predicates, controlimplementation.VerificationDateNEQ(*i.VerificationDateNEQ))
	}
	if len(i.VerificationDateIn) > 0 {
		predicates = append(predicates, controlimplementation.VerificationDateIn(i.VerificationDateIn...))
	}
	if len(i.VerificationDateNotIn) > 0 {
		predicates = append(predicates, controlimplementation.VerificationDateNotIn(i.VerificationDateNotIn...))
	}
	if i.VerificationDateGT != nil {
		predicates = append(predicates, controlimplementation.VerificationDateGT(*i.VerificationDateGT))
	}
	if i.VerificationDateGTE != nil {
		predicates = append(predicates, controlimplementation.VerificationDateGTE(*i.VerificationDateGTE))
	}
	if i.VerificationDateLT != nil {
		predicates = append(predicates, controlimplementation.VerificationDateLT(*i.VerificationDateLT))
	}
	if i.VerificationDateLTE != nil {
		predicates = append(predicates, controlimplementation.VerificationDateLTE(*i.VerificationDateLTE))
	}
	if i.VerificationDateIsNil {
		predicates = append(predicates, controlimplementation.VerificationDateIsNil())
	}
	if i.VerificationDateNotNil {
		predicates = append(predicates, controlimplementation.VerificationDateNotNil())
	}
	if i.Details != nil {
		predicates = append(predicates, controlimplementation.DetailsEQ(*i.Details))
	}
	if i.DetailsNEQ != nil {
		predicates = append(predicates, controlimplementation.DetailsNEQ(*i.DetailsNEQ))
	}
	if len(i.DetailsIn) > 0 {
		predicates = append(predicates, controlimplementation.DetailsIn(i.DetailsIn...))
	}
	if len(i.DetailsNotIn) > 0 {
		predicates = append(predicates, controlimplementation.DetailsNotIn(i.DetailsNotIn...))
	}
	if i.DetailsGT != nil {
		predicates = append(predicates, controlimplementation.DetailsGT(*i.DetailsGT))
	}
	if i.DetailsGTE != nil {
		predicates = append(predicates, controlimplementation.DetailsGTE(*i.DetailsGTE))
	}
	if i.DetailsLT != nil {
		predicates = append(predicates, controlimplementation.DetailsLT(*i.DetailsLT))
	}
	if i.DetailsLTE != nil {
		predicates = append(predicates, controlimplementation.DetailsLTE(*i.DetailsLTE))
	}
	if i.DetailsContains != nil {
		predicates = append(predicates, controlimplementation.DetailsContains(*i.DetailsContains))
	}
	if i.DetailsHasPrefix != nil {
		predicates = append(predicates, controlimplementation.DetailsHasPrefix(*i.DetailsHasPrefix))
	}
	if i.DetailsHasSuffix != nil {
		predicates = append(predicates, controlimplementation.DetailsHasSuffix(*i.DetailsHasSuffix))
	}
	if i.DetailsIsNil {
		predicates = append(predicates, controlimplementation.DetailsIsNil())
	}
	if i.DetailsNotNil {
		predicates = append(predicates, controlimplementation.DetailsNotNil())
	}
	if i.DetailsEqualFold != nil {
		predicates = append(predicates, controlimplementation.DetailsEqualFold(*i.DetailsEqualFold))
	}
	if i.DetailsContainsFold != nil {
		predicates = append(predicates, controlimplementation.DetailsContainsFold(*i.DetailsContainsFold))
	}

	if i.HasOwner != nil {
		p := controlimplementation.HasOwner()
		if !*i.HasOwner {
			p = controlimplementation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlimplementation.HasOwnerWith(with...))
	}
	if i.HasBlockedGroups != nil {
		p := controlimplementation.HasBlockedGroups()
		if !*i.HasBlockedGroups {
			p = controlimplementation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBlockedGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasBlockedGroupsWith))
		for _, w := range i.HasBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlimplementation.HasBlockedGroupsWith(with...))
	}
	if i.HasEditors != nil {
		p := controlimplementation.HasEditors()
		if !*i.HasEditors {
			p = controlimplementation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEditorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasEditorsWith))
		for _, w := range i.HasEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlimplementation.HasEditorsWith(with...))
	}
	if i.HasViewers != nil {
		p := controlimplementation.HasViewers()
		if !*i.HasViewers {
			p = controlimplementation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasViewersWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasViewersWith))
		for _, w := range i.HasViewersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasViewersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlimplementation.HasViewersWith(with...))
	}
	if i.HasControls != nil {
		p := controlimplementation.HasControls()
		if !*i.HasControls {
			p = controlimplementation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasControlsWith))
		for _, w := range i.HasControlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlimplementation.HasControlsWith(with...))
	}
	if i.HasSubcontrols != nil {
		p := controlimplementation.HasSubcontrols()
		if !*i.HasSubcontrols {
			p = controlimplementation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubcontrolsWith) > 0 {
		with := make([]predicate.Subcontrol, 0, len(i.HasSubcontrolsWith))
		for _, w := range i.HasSubcontrolsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubcontrolsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlimplementation.HasSubcontrolsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyControlImplementationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return controlimplementation.And(predicates...), nil
	}
}

// ControlImplementationHistoryWhereInput represents a where input for filtering ControlImplementationHistory queries.
type ControlImplementationHistoryWhereInput struct {
	Predicates []predicate.ControlImplementationHistory  `json:"-"`
	Not        *ControlImplementationHistoryWhereInput   `json:"not,omitempty"`
	Or         []*ControlImplementationHistoryWhereInput `json:"or,omitempty"`
	And        []*ControlImplementationHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                   `json:"statusIsNil,omitempty"`
	StatusNotNil bool                   `json:"statusNotNil,omitempty"`

	// "implementation_date" field predicates.
	ImplementationDate       *time.Time  `json:"implementationDate,omitempty"`
	ImplementationDateNEQ    *time.Time  `json:"implementationDateNEQ,omitempty"`
	ImplementationDateIn     []time.Time `json:"implementationDateIn,omitempty"`
	ImplementationDateNotIn  []time.Time `json:"implementationDateNotIn,omitempty"`
	ImplementationDateGT     *time.Time  `json:"implementationDateGT,omitempty"`
	ImplementationDateGTE    *time.Time  `json:"implementationDateGTE,omitempty"`
	ImplementationDateLT     *time.Time  `json:"implementationDateLT,omitempty"`
	ImplementationDateLTE    *time.Time  `json:"implementationDateLTE,omitempty"`
	ImplementationDateIsNil  bool        `json:"implementationDateIsNil,omitempty"`
	ImplementationDateNotNil bool        `json:"implementationDateNotNil,omitempty"`

	// "verified" field predicates.
	Verified       *bool `json:"verified,omitempty"`
	VerifiedNEQ    *bool `json:"verifiedNEQ,omitempty"`
	VerifiedIsNil  bool  `json:"verifiedIsNil,omitempty"`
	VerifiedNotNil bool  `json:"verifiedNotNil,omitempty"`

	// "verification_date" field predicates.
	VerificationDate       *time.Time  `json:"verificationDate,omitempty"`
	VerificationDateNEQ    *time.Time  `json:"verificationDateNEQ,omitempty"`
	VerificationDateIn     []time.Time `json:"verificationDateIn,omitempty"`
	VerificationDateNotIn  []time.Time `json:"verificationDateNotIn,omitempty"`
	VerificationDateGT     *time.Time  `json:"verificationDateGT,omitempty"`
	VerificationDateGTE    *time.Time  `json:"verificationDateGTE,omitempty"`
	VerificationDateLT     *time.Time  `json:"verificationDateLT,omitempty"`
	VerificationDateLTE    *time.Time  `json:"verificationDateLTE,omitempty"`
	VerificationDateIsNil  bool        `json:"verificationDateIsNil,omitempty"`
	VerificationDateNotNil bool        `json:"verificationDateNotNil,omitempty"`

	// "details" field predicates.
	Details             *string  `json:"details,omitempty"`
	DetailsNEQ          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGT           *string  `json:"detailsGT,omitempty"`
	DetailsGTE          *string  `json:"detailsGTE,omitempty"`
	DetailsLT           *string  `json:"detailsLT,omitempty"`
	DetailsLTE          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        bool     `json:"detailsIsNil,omitempty"`
	DetailsNotNil       bool     `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ControlImplementationHistoryWhereInput) AddPredicates(predicates ...predicate.ControlImplementationHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ControlImplementationHistoryWhereInput filter on the ControlImplementationHistoryQuery builder.
func (i *ControlImplementationHistoryWhereInput) Filter(q *ControlImplementationHistoryQuery) (*ControlImplementationHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyControlImplementationHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyControlImplementationHistoryWhereInput is returned in case the ControlImplementationHistoryWhereInput is empty.
var ErrEmptyControlImplementationHistoryWhereInput = errors.New("generated: empty predicate ControlImplementationHistoryWhereInput")

// P returns a predicate for filtering controlimplementationhistories.
// An error is returned if the input is empty or invalid.
func (i *ControlImplementationHistoryWhereInput) P() (predicate.ControlImplementationHistory, error) {
	var predicates []predicate.ControlImplementationHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, controlimplementationhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ControlImplementationHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, controlimplementationhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ControlImplementationHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, controlimplementationhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, controlimplementationhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, controlimplementationhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, controlimplementationhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, controlimplementationhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, controlimplementationhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, controlimplementationhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, controlimplementationhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, controlimplementationhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, controlimplementationhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, controlimplementationhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, controlimplementationhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, controlimplementationhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, controlimplementationhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, controlimplementationhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, controlimplementationhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, controlimplementationhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, controlimplementationhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, controlimplementationhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, controlimplementationhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, controlimplementationhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, controlimplementationhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, controlimplementationhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, controlimplementationhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, controlimplementationhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, controlimplementationhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, controlimplementationhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, controlimplementationhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, controlimplementationhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, controlimplementationhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, controlimplementationhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, controlimplementationhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, controlimplementationhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, controlimplementationhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, controlimplementationhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, controlimplementationhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, controlimplementationhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, controlimplementationhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, controlimplementationhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, controlimplementationhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, controlimplementationhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, controlimplementationhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, controlimplementationhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, controlimplementationhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, controlimplementationhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, controlimplementationhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, controlimplementationhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, controlimplementationhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, controlimplementationhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, controlimplementationhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, controlimplementationhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, controlimplementationhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, controlimplementationhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, controlimplementationhistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, controlimplementationhistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, controlimplementationhistory.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, controlimplementationhistory.StatusNotNil())
	}
	if i.ImplementationDate != nil {
		predicates = append(predicates, controlimplementationhistory.ImplementationDateEQ(*i.ImplementationDate))
	}
	if i.ImplementationDateNEQ != nil {
		predicates = append(predicates, controlimplementationhistory.ImplementationDateNEQ(*i.ImplementationDateNEQ))
	}
	if len(i.ImplementationDateIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.ImplementationDateIn(i.ImplementationDateIn...))
	}
	if len(i.ImplementationDateNotIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.ImplementationDateNotIn(i.ImplementationDateNotIn...))
	}
	if i.ImplementationDateGT != nil {
		predicates = append(predicates, controlimplementationhistory.ImplementationDateGT(*i.ImplementationDateGT))
	}
	if i.ImplementationDateGTE != nil {
		predicates = append(predicates, controlimplementationhistory.ImplementationDateGTE(*i.ImplementationDateGTE))
	}
	if i.ImplementationDateLT != nil {
		predicates = append(predicates, controlimplementationhistory.ImplementationDateLT(*i.ImplementationDateLT))
	}
	if i.ImplementationDateLTE != nil {
		predicates = append(predicates, controlimplementationhistory.ImplementationDateLTE(*i.ImplementationDateLTE))
	}
	if i.ImplementationDateIsNil {
		predicates = append(predicates, controlimplementationhistory.ImplementationDateIsNil())
	}
	if i.ImplementationDateNotNil {
		predicates = append(predicates, controlimplementationhistory.ImplementationDateNotNil())
	}
	if i.Verified != nil {
		predicates = append(predicates, controlimplementationhistory.VerifiedEQ(*i.Verified))
	}
	if i.VerifiedNEQ != nil {
		predicates = append(predicates, controlimplementationhistory.VerifiedNEQ(*i.VerifiedNEQ))
	}
	if i.VerifiedIsNil {
		predicates = append(predicates, controlimplementationhistory.VerifiedIsNil())
	}
	if i.VerifiedNotNil {
		predicates = append(predicates, controlimplementationhistory.VerifiedNotNil())
	}
	if i.VerificationDate != nil {
		predicates = append(predicates, controlimplementationhistory.VerificationDateEQ(*i.VerificationDate))
	}
	if i.VerificationDateNEQ != nil {
		predicates = append(predicates, controlimplementationhistory.VerificationDateNEQ(*i.VerificationDateNEQ))
	}
	if len(i.VerificationDateIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.VerificationDateIn(i.VerificationDateIn...))
	}
	if len(i.VerificationDateNotIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.VerificationDateNotIn(i.VerificationDateNotIn...))
	}
	if i.VerificationDateGT != nil {
		predicates = append(predicates, controlimplementationhistory.VerificationDateGT(*i.VerificationDateGT))
	}
	if i.VerificationDateGTE != nil {
		predicates = append(predicates, controlimplementationhistory.VerificationDateGTE(*i.VerificationDateGTE))
	}
	if i.VerificationDateLT != nil {
		predicates = append(predicates, controlimplementationhistory.VerificationDateLT(*i.VerificationDateLT))
	}
	if i.VerificationDateLTE != nil {
		predicates = append(predicates, controlimplementationhistory.VerificationDateLTE(*i.VerificationDateLTE))
	}
	if i.VerificationDateIsNil {
		predicates = append(predicates, controlimplementationhistory.VerificationDateIsNil())
	}
	if i.VerificationDateNotNil {
		predicates = append(predicates, controlimplementationhistory.VerificationDateNotNil())
	}
	if i.Details != nil {
		predicates = append(predicates, controlimplementationhistory.DetailsEQ(*i.Details))
	}
	if i.DetailsNEQ != nil {
		predicates = append(predicates, controlimplementationhistory.DetailsNEQ(*i.DetailsNEQ))
	}
	if len(i.DetailsIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.DetailsIn(i.DetailsIn...))
	}
	if len(i.DetailsNotIn) > 0 {
		predicates = append(predicates, controlimplementationhistory.DetailsNotIn(i.DetailsNotIn...))
	}
	if i.DetailsGT != nil {
		predicates = append(predicates, controlimplementationhistory.DetailsGT(*i.DetailsGT))
	}
	if i.DetailsGTE != nil {
		predicates = append(predicates, controlimplementationhistory.DetailsGTE(*i.DetailsGTE))
	}
	if i.DetailsLT != nil {
		predicates = append(predicates, controlimplementationhistory.DetailsLT(*i.DetailsLT))
	}
	if i.DetailsLTE != nil {
		predicates = append(predicates, controlimplementationhistory.DetailsLTE(*i.DetailsLTE))
	}
	if i.DetailsContains != nil {
		predicates = append(predicates, controlimplementationhistory.DetailsContains(*i.DetailsContains))
	}
	if i.DetailsHasPrefix != nil {
		predicates = append(predicates, controlimplementationhistory.DetailsHasPrefix(*i.DetailsHasPrefix))
	}
	if i.DetailsHasSuffix != nil {
		predicates = append(predicates, controlimplementationhistory.DetailsHasSuffix(*i.DetailsHasSuffix))
	}
	if i.DetailsIsNil {
		predicates = append(predicates, controlimplementationhistory.DetailsIsNil())
	}
	if i.DetailsNotNil {
		predicates = append(predicates, controlimplementationhistory.DetailsNotNil())
	}
	if i.DetailsEqualFold != nil {
		predicates = append(predicates, controlimplementationhistory.DetailsEqualFold(*i.DetailsEqualFold))
	}
	if i.DetailsContainsFold != nil {
		predicates = append(predicates, controlimplementationhistory.DetailsContainsFold(*i.DetailsContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyControlImplementationHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return controlimplementationhistory.And(predicates...), nil
	}
}

// ControlObjectiveWhereInput represents a where input for filtering ControlObjective queries.
type ControlObjectiveWhereInput struct {
	Predicates []predicate.ControlObjective  `json:"-"`
	Not        *ControlObjectiveWhereInput   `json:"not,omitempty"`
	Or         []*ControlObjectiveWhereInput `json:"or,omitempty"`
	And        []*ControlObjectiveWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "revision" field predicates.
	Revision             *string  `json:"revision,omitempty"`
	RevisionNEQ          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGT           *string  `json:"revisionGT,omitempty"`
	RevisionGTE          *string  `json:"revisionGTE,omitempty"`
	RevisionLT           *string  `json:"revisionLT,omitempty"`
	RevisionLTE          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        bool     `json:"revisionIsNil,omitempty"`
	RevisionNotNil       bool     `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "desired_outcome" field predicates.
	DesiredOutcome             *string  `json:"desiredOutcome,omitempty"`
	DesiredOutcomeNEQ          *string  `json:"desiredOutcomeNEQ,omitempty"`
	DesiredOutcomeIn           []string `json:"desiredOutcomeIn,omitempty"`
	DesiredOutcomeNotIn        []string `json:"desiredOutcomeNotIn,omitempty"`
	DesiredOutcomeGT           *string  `json:"desiredOutcomeGT,omitempty"`
	DesiredOutcomeGTE          *string  `json:"desiredOutcomeGTE,omitempty"`
	DesiredOutcomeLT           *string  `json:"desiredOutcomeLT,omitempty"`
	DesiredOutcomeLTE          *string  `json:"desiredOutcomeLTE,omitempty"`
	DesiredOutcomeContains     *string  `json:"desiredOutcomeContains,omitempty"`
	DesiredOutcomeHasPrefix    *string  `json:"desiredOutcomeHasPrefix,omitempty"`
	DesiredOutcomeHasSuffix    *string  `json:"desiredOutcomeHasSuffix,omitempty"`
	DesiredOutcomeIsNil        bool     `json:"desiredOutcomeIsNil,omitempty"`
	DesiredOutcomeNotNil       bool     `json:"desiredOutcomeNotNil,omitempty"`
	DesiredOutcomeEqualFold    *string  `json:"desiredOutcomeEqualFold,omitempty"`
	DesiredOutcomeContainsFold *string  `json:"desiredOutcomeContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.ObjectiveStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.ObjectiveStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.ObjectiveStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.ObjectiveStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                    `json:"statusIsNil,omitempty"`
	StatusNotNil bool                    `json:"statusNotNil,omitempty"`

	// "source" field predicates.
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNEQ    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  bool                  `json:"sourceIsNil,omitempty"`
	SourceNotNil bool                  `json:"sourceNotNil,omitempty"`

	// "control_objective_type" field predicates.
	ControlObjectiveType             *string  `json:"controlObjectiveType,omitempty"`
	ControlObjectiveTypeNEQ          *string  `json:"controlObjectiveTypeNEQ,omitempty"`
	ControlObjectiveTypeIn           []string `json:"controlObjectiveTypeIn,omitempty"`
	ControlObjectiveTypeNotIn        []string `json:"controlObjectiveTypeNotIn,omitempty"`
	ControlObjectiveTypeGT           *string  `json:"controlObjectiveTypeGT,omitempty"`
	ControlObjectiveTypeGTE          *string  `json:"controlObjectiveTypeGTE,omitempty"`
	ControlObjectiveTypeLT           *string  `json:"controlObjectiveTypeLT,omitempty"`
	ControlObjectiveTypeLTE          *string  `json:"controlObjectiveTypeLTE,omitempty"`
	ControlObjectiveTypeContains     *string  `json:"controlObjectiveTypeContains,omitempty"`
	ControlObjectiveTypeHasPrefix    *string  `json:"controlObjectiveTypeHasPrefix,omitempty"`
	ControlObjectiveTypeHasSuffix    *string  `json:"controlObjectiveTypeHasSuffix,omitempty"`
	ControlObjectiveTypeIsNil        bool     `json:"controlObjectiveTypeIsNil,omitempty"`
	ControlObjectiveTypeNotNil       bool     `json:"controlObjectiveTypeNotNil,omitempty"`
	ControlObjectiveTypeEqualFold    *string  `json:"controlObjectiveTypeEqualFold,omitempty"`
	ControlObjectiveTypeContainsFold *string  `json:"controlObjectiveTypeContainsFold,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        bool     `json:"categoryIsNil,omitempty"`
	CategoryNotNil       bool     `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "subcategory" field predicates.
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNEQ          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGT           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGTE          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLT           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLTE          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        bool     `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       bool     `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "blocked_groups" edge predicates.
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`

	// "editors" edge predicates.
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`

	// "viewers" edge predicates.
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`

	// "programs" edge predicates.
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`

	// "evidence" edge predicates.
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`

	// "controls" edge predicates.
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`

	// "subcontrols" edge predicates.
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`

	// "internal_policies" edge predicates.
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`

	// "procedures" edge predicates.
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`

	// "risks" edge predicates.
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`

	// "narratives" edge predicates.
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ControlObjectiveWhereInput) AddPredicates(predicates ...predicate.ControlObjective) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ControlObjectiveWhereInput filter on the ControlObjectiveQuery builder.
func (i *ControlObjectiveWhereInput) Filter(q *ControlObjectiveQuery) (*ControlObjectiveQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyControlObjectiveWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyControlObjectiveWhereInput is returned in case the ControlObjectiveWhereInput is empty.
var ErrEmptyControlObjectiveWhereInput = errors.New("generated: empty predicate ControlObjectiveWhereInput")

// P returns a predicate for filtering controlobjectives.
// An error is returned if the input is empty or invalid.
func (i *ControlObjectiveWhereInput) P() (predicate.ControlObjective, error) {
	var predicates []predicate.ControlObjective
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, controlobjective.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ControlObjective, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, controlobjective.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ControlObjective, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, controlobjective.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, controlobjective.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, controlobjective.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, controlobjective.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, controlobjective.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, controlobjective.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, controlobjective.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, controlobjective.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, controlobjective.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, controlobjective.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, controlobjective.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, controlobjective.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, controlobjective.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, controlobjective.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, controlobjective.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, controlobjective.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, controlobjective.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, controlobjective.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, controlobjective.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, controlobjective.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, controlobjective.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, controlobjective.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, controlobjective.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, controlobjective.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, controlobjective.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, controlobjective.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, controlobjective.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, controlobjective.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, controlobjective.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, controlobjective.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, controlobjective.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, controlobjective.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, controlobjective.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, controlobjective.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, controlobjective.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, controlobjective.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, controlobjective.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, controlobjective.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, controlobjective.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, controlobjective.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, controlobjective.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, controlobjective.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, controlobjective.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, controlobjective.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, controlobjective.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, controlobjective.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, controlobjective.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, controlobjective.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, controlobjective.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, controlobjective.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, controlobjective.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, controlobjective.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, controlobjective.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, controlobjective.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, controlobjective.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, controlobjective.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, controlobjective.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, controlobjective.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, controlobjective.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, controlobjective.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, controlobjective.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, controlobjective.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, controlobjective.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, controlobjective.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, controlobjective.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, controlobjective.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, controlobjective.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, controlobjective.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, controlobjective.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, controlobjective.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, controlobjective.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, controlobjective.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, controlobjective.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, controlobjective.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.Revision != nil {
		predicates = append(predicates, controlobjective.RevisionEQ(*i.Revision))
	}
	if i.RevisionNEQ != nil {
		predicates = append(predicates, controlobjective.RevisionNEQ(*i.RevisionNEQ))
	}
	if len(i.RevisionIn) > 0 {
		predicates = append(predicates, controlobjective.RevisionIn(i.RevisionIn...))
	}
	if len(i.RevisionNotIn) > 0 {
		predicates = append(predicates, controlobjective.RevisionNotIn(i.RevisionNotIn...))
	}
	if i.RevisionGT != nil {
		predicates = append(predicates, controlobjective.RevisionGT(*i.RevisionGT))
	}
	if i.RevisionGTE != nil {
		predicates = append(predicates, controlobjective.RevisionGTE(*i.RevisionGTE))
	}
	if i.RevisionLT != nil {
		predicates = append(predicates, controlobjective.RevisionLT(*i.RevisionLT))
	}
	if i.RevisionLTE != nil {
		predicates = append(predicates, controlobjective.RevisionLTE(*i.RevisionLTE))
	}
	if i.RevisionContains != nil {
		predicates = append(predicates, controlobjective.RevisionContains(*i.RevisionContains))
	}
	if i.RevisionHasPrefix != nil {
		predicates = append(predicates, controlobjective.RevisionHasPrefix(*i.RevisionHasPrefix))
	}
	if i.RevisionHasSuffix != nil {
		predicates = append(predicates, controlobjective.RevisionHasSuffix(*i.RevisionHasSuffix))
	}
	if i.RevisionIsNil {
		predicates = append(predicates, controlobjective.RevisionIsNil())
	}
	if i.RevisionNotNil {
		predicates = append(predicates, controlobjective.RevisionNotNil())
	}
	if i.RevisionEqualFold != nil {
		predicates = append(predicates, controlobjective.RevisionEqualFold(*i.RevisionEqualFold))
	}
	if i.RevisionContainsFold != nil {
		predicates = append(predicates, controlobjective.RevisionContainsFold(*i.RevisionContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, controlobjective.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, controlobjective.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, controlobjective.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, controlobjective.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, controlobjective.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, controlobjective.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, controlobjective.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, controlobjective.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, controlobjective.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, controlobjective.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, controlobjective.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, controlobjective.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, controlobjective.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, controlobjective.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, controlobjective.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, controlobjective.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, controlobjective.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, controlobjective.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, controlobjective.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, controlobjective.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, controlobjective.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, controlobjective.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, controlobjective.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, controlobjective.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, controlobjective.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, controlobjective.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, controlobjective.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, controlobjective.NameContainsFold(*i.NameContainsFold))
	}
	if i.DesiredOutcome != nil {
		predicates = append(predicates, controlobjective.DesiredOutcomeEQ(*i.DesiredOutcome))
	}
	if i.DesiredOutcomeNEQ != nil {
		predicates = append(predicates, controlobjective.DesiredOutcomeNEQ(*i.DesiredOutcomeNEQ))
	}
	if len(i.DesiredOutcomeIn) > 0 {
		predicates = append(predicates, controlobjective.DesiredOutcomeIn(i.DesiredOutcomeIn...))
	}
	if len(i.DesiredOutcomeNotIn) > 0 {
		predicates = append(predicates, controlobjective.DesiredOutcomeNotIn(i.DesiredOutcomeNotIn...))
	}
	if i.DesiredOutcomeGT != nil {
		predicates = append(predicates, controlobjective.DesiredOutcomeGT(*i.DesiredOutcomeGT))
	}
	if i.DesiredOutcomeGTE != nil {
		predicates = append(predicates, controlobjective.DesiredOutcomeGTE(*i.DesiredOutcomeGTE))
	}
	if i.DesiredOutcomeLT != nil {
		predicates = append(predicates, controlobjective.DesiredOutcomeLT(*i.DesiredOutcomeLT))
	}
	if i.DesiredOutcomeLTE != nil {
		predicates = append(predicates, controlobjective.DesiredOutcomeLTE(*i.DesiredOutcomeLTE))
	}
	if i.DesiredOutcomeContains != nil {
		predicates = append(predicates, controlobjective.DesiredOutcomeContains(*i.DesiredOutcomeContains))
	}
	if i.DesiredOutcomeHasPrefix != nil {
		predicates = append(predicates, controlobjective.DesiredOutcomeHasPrefix(*i.DesiredOutcomeHasPrefix))
	}
	if i.DesiredOutcomeHasSuffix != nil {
		predicates = append(predicates, controlobjective.DesiredOutcomeHasSuffix(*i.DesiredOutcomeHasSuffix))
	}
	if i.DesiredOutcomeIsNil {
		predicates = append(predicates, controlobjective.DesiredOutcomeIsNil())
	}
	if i.DesiredOutcomeNotNil {
		predicates = append(predicates, controlobjective.DesiredOutcomeNotNil())
	}
	if i.DesiredOutcomeEqualFold != nil {
		predicates = append(predicates, controlobjective.DesiredOutcomeEqualFold(*i.DesiredOutcomeEqualFold))
	}
	if i.DesiredOutcomeContainsFold != nil {
		predicates = append(predicates, controlobjective.DesiredOutcomeContainsFold(*i.DesiredOutcomeContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, controlobjective.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, controlobjective.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, controlobjective.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, controlobjective.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, controlobjective.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, controlobjective.StatusNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, controlobjective.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, controlobjective.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, controlobjective.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, controlobjective.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceIsNil {
		predicates = append(predicates, controlobjective.SourceIsNil())
	}
	if i.SourceNotNil {
		predicates = append(predicates, controlobjective.SourceNotNil())
	}
	if i.ControlObjectiveType != nil {
		predicates = append(predicates, controlobjective.ControlObjectiveTypeEQ(*i.ControlObjectiveType))
	}
	if i.ControlObjectiveTypeNEQ != nil {
		predicates = append(predicates, controlobjective.ControlObjectiveTypeNEQ(*i.ControlObjectiveTypeNEQ))
	}
	if len(i.ControlObjectiveTypeIn) > 0 {
		predicates = append(predicates, controlobjective.ControlObjectiveTypeIn(i.ControlObjectiveTypeIn...))
	}
	if len(i.ControlObjectiveTypeNotIn) > 0 {
		predicates = append(predicates, controlobjective.ControlObjectiveTypeNotIn(i.ControlObjectiveTypeNotIn...))
	}
	if i.ControlObjectiveTypeGT != nil {
		predicates = append(predicates, controlobjective.ControlObjectiveTypeGT(*i.ControlObjectiveTypeGT))
	}
	if i.ControlObjectiveTypeGTE != nil {
		predicates = append(predicates, controlobjective.ControlObjectiveTypeGTE(*i.ControlObjectiveTypeGTE))
	}
	if i.ControlObjectiveTypeLT != nil {
		predicates = append(predicates, controlobjective.ControlObjectiveTypeLT(*i.ControlObjectiveTypeLT))
	}
	if i.ControlObjectiveTypeLTE != nil {
		predicates = append(predicates, controlobjective.ControlObjectiveTypeLTE(*i.ControlObjectiveTypeLTE))
	}
	if i.ControlObjectiveTypeContains != nil {
		predicates = append(predicates, controlobjective.ControlObjectiveTypeContains(*i.ControlObjectiveTypeContains))
	}
	if i.ControlObjectiveTypeHasPrefix != nil {
		predicates = append(predicates, controlobjective.ControlObjectiveTypeHasPrefix(*i.ControlObjectiveTypeHasPrefix))
	}
	if i.ControlObjectiveTypeHasSuffix != nil {
		predicates = append(predicates, controlobjective.ControlObjectiveTypeHasSuffix(*i.ControlObjectiveTypeHasSuffix))
	}
	if i.ControlObjectiveTypeIsNil {
		predicates = append(predicates, controlobjective.ControlObjectiveTypeIsNil())
	}
	if i.ControlObjectiveTypeNotNil {
		predicates = append(predicates, controlobjective.ControlObjectiveTypeNotNil())
	}
	if i.ControlObjectiveTypeEqualFold != nil {
		predicates = append(predicates, controlobjective.ControlObjectiveTypeEqualFold(*i.ControlObjectiveTypeEqualFold))
	}
	if i.ControlObjectiveTypeContainsFold != nil {
		predicates = append(predicates, controlobjective.ControlObjectiveTypeContainsFold(*i.ControlObjectiveTypeContainsFold))
	}
	if i.Category != nil {
		predicates = append(predicates, controlobjective.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, controlobjective.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, controlobjective.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, controlobjective.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, controlobjective.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, controlobjective.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, controlobjective.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, controlobjective.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, controlobjective.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, controlobjective.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, controlobjective.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryIsNil {
		predicates = append(predicates, controlobjective.CategoryIsNil())
	}
	if i.CategoryNotNil {
		predicates = append(predicates, controlobjective.CategoryNotNil())
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, controlobjective.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, controlobjective.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.Subcategory != nil {
		predicates = append(predicates, controlobjective.SubcategoryEQ(*i.Subcategory))
	}
	if i.SubcategoryNEQ != nil {
		predicates = append(predicates, controlobjective.SubcategoryNEQ(*i.SubcategoryNEQ))
	}
	if len(i.SubcategoryIn) > 0 {
		predicates = append(predicates, controlobjective.SubcategoryIn(i.SubcategoryIn...))
	}
	if len(i.SubcategoryNotIn) > 0 {
		predicates = append(predicates, controlobjective.SubcategoryNotIn(i.SubcategoryNotIn...))
	}
	if i.SubcategoryGT != nil {
		predicates = append(predicates, controlobjective.SubcategoryGT(*i.SubcategoryGT))
	}
	if i.SubcategoryGTE != nil {
		predicates = append(predicates, controlobjective.SubcategoryGTE(*i.SubcategoryGTE))
	}
	if i.SubcategoryLT != nil {
		predicates = append(predicates, controlobjective.SubcategoryLT(*i.SubcategoryLT))
	}
	if i.SubcategoryLTE != nil {
		predicates = append(predicates, controlobjective.SubcategoryLTE(*i.SubcategoryLTE))
	}
	if i.SubcategoryContains != nil {
		predicates = append(predicates, controlobjective.SubcategoryContains(*i.SubcategoryContains))
	}
	if i.SubcategoryHasPrefix != nil {
		predicates = append(predicates, controlobjective.SubcategoryHasPrefix(*i.SubcategoryHasPrefix))
	}
	if i.SubcategoryHasSuffix != nil {
		predicates = append(predicates, controlobjective.SubcategoryHasSuffix(*i.SubcategoryHasSuffix))
	}
	if i.SubcategoryIsNil {
		predicates = append(predicates, controlobjective.SubcategoryIsNil())
	}
	if i.SubcategoryNotNil {
		predicates = append(predicates, controlobjective.SubcategoryNotNil())
	}
	if i.SubcategoryEqualFold != nil {
		predicates = append(predicates, controlobjective.SubcategoryEqualFold(*i.SubcategoryEqualFold))
	}
	if i.SubcategoryContainsFold != nil {
		predicates = append(predicates, controlobjective.SubcategoryContainsFold(*i.SubcategoryContainsFold))
	}

	if i.HasOwner != nil {
		p := controlobjective.HasOwner()
		if !*i.HasOwner {
			p = controlobjective.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlobjective.HasOwnerWith(with...))
	}
	if i.HasBlockedGroups != nil {
		p := controlobjective.HasBlockedGroups()
		if !*i.HasBlockedGroups {
			p = controlobjective.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBlockedGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasBlockedGroupsWith))
		for _, w := range i.HasBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlobjective.HasBlockedGroupsWith(with...))
	}
	if i.HasEditors != nil {
		p := controlobjective.HasEditors()
		if !*i.HasEditors {
			p = controlobjective.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEditorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasEditorsWith))
		for _, w := range i.HasEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlobjective.HasEditorsWith(with...))
	}
	if i.HasViewers != nil {
		p := controlobjective.HasViewers()
		if !*i.HasViewers {
			p = controlobjective.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasViewersWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasViewersWith))
		for _, w := range i.HasViewersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasViewersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlobjective.HasViewersWith(with...))
	}
	if i.HasPrograms != nil {
		p := controlobjective.HasPrograms()
		if !*i.HasPrograms {
			p = controlobjective.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramsWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramsWith))
		for _, w := range i.HasProgramsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlobjective.HasProgramsWith(with...))
	}
	if i.HasEvidence != nil {
		p := controlobjective.HasEvidence()
		if !*i.HasEvidence {
			p = controlobjective.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEvidenceWith) > 0 {
		with := make([]predicate.Evidence, 0, len(i.HasEvidenceWith))
		for _, w := range i.HasEvidenceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEvidenceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlobjective.HasEvidenceWith(with...))
	}
	if i.HasControls != nil {
		p := controlobjective.HasControls()
		if !*i.HasControls {
			p = controlobjective.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasControlsWith))
		for _, w := range i.HasControlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlobjective.HasControlsWith(with...))
	}
	if i.HasSubcontrols != nil {
		p := controlobjective.HasSubcontrols()
		if !*i.HasSubcontrols {
			p = controlobjective.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubcontrolsWith) > 0 {
		with := make([]predicate.Subcontrol, 0, len(i.HasSubcontrolsWith))
		for _, w := range i.HasSubcontrolsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubcontrolsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlobjective.HasSubcontrolsWith(with...))
	}
	if i.HasInternalPolicies != nil {
		p := controlobjective.HasInternalPolicies()
		if !*i.HasInternalPolicies {
			p = controlobjective.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInternalPoliciesWith) > 0 {
		with := make([]predicate.InternalPolicy, 0, len(i.HasInternalPoliciesWith))
		for _, w := range i.HasInternalPoliciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInternalPoliciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlobjective.HasInternalPoliciesWith(with...))
	}
	if i.HasProcedures != nil {
		p := controlobjective.HasProcedures()
		if !*i.HasProcedures {
			p = controlobjective.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProceduresWith) > 0 {
		with := make([]predicate.Procedure, 0, len(i.HasProceduresWith))
		for _, w := range i.HasProceduresWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProceduresWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlobjective.HasProceduresWith(with...))
	}
	if i.HasRisks != nil {
		p := controlobjective.HasRisks()
		if !*i.HasRisks {
			p = controlobjective.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRisksWith) > 0 {
		with := make([]predicate.Risk, 0, len(i.HasRisksWith))
		for _, w := range i.HasRisksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRisksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlobjective.HasRisksWith(with...))
	}
	if i.HasNarratives != nil {
		p := controlobjective.HasNarratives()
		if !*i.HasNarratives {
			p = controlobjective.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNarrativesWith) > 0 {
		with := make([]predicate.Narrative, 0, len(i.HasNarrativesWith))
		for _, w := range i.HasNarrativesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNarrativesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlobjective.HasNarrativesWith(with...))
	}
	if i.HasTasks != nil {
		p := controlobjective.HasTasks()
		if !*i.HasTasks {
			p = controlobjective.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlobjective.HasTasksWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyControlObjectiveWhereInput
	case 1:
		return predicates[0], nil
	default:
		return controlobjective.And(predicates...), nil
	}
}

// ControlObjectiveHistoryWhereInput represents a where input for filtering ControlObjectiveHistory queries.
type ControlObjectiveHistoryWhereInput struct {
	Predicates []predicate.ControlObjectiveHistory  `json:"-"`
	Not        *ControlObjectiveHistoryWhereInput   `json:"not,omitempty"`
	Or         []*ControlObjectiveHistoryWhereInput `json:"or,omitempty"`
	And        []*ControlObjectiveHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "revision" field predicates.
	Revision             *string  `json:"revision,omitempty"`
	RevisionNEQ          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGT           *string  `json:"revisionGT,omitempty"`
	RevisionGTE          *string  `json:"revisionGTE,omitempty"`
	RevisionLT           *string  `json:"revisionLT,omitempty"`
	RevisionLTE          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        bool     `json:"revisionIsNil,omitempty"`
	RevisionNotNil       bool     `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "desired_outcome" field predicates.
	DesiredOutcome             *string  `json:"desiredOutcome,omitempty"`
	DesiredOutcomeNEQ          *string  `json:"desiredOutcomeNEQ,omitempty"`
	DesiredOutcomeIn           []string `json:"desiredOutcomeIn,omitempty"`
	DesiredOutcomeNotIn        []string `json:"desiredOutcomeNotIn,omitempty"`
	DesiredOutcomeGT           *string  `json:"desiredOutcomeGT,omitempty"`
	DesiredOutcomeGTE          *string  `json:"desiredOutcomeGTE,omitempty"`
	DesiredOutcomeLT           *string  `json:"desiredOutcomeLT,omitempty"`
	DesiredOutcomeLTE          *string  `json:"desiredOutcomeLTE,omitempty"`
	DesiredOutcomeContains     *string  `json:"desiredOutcomeContains,omitempty"`
	DesiredOutcomeHasPrefix    *string  `json:"desiredOutcomeHasPrefix,omitempty"`
	DesiredOutcomeHasSuffix    *string  `json:"desiredOutcomeHasSuffix,omitempty"`
	DesiredOutcomeIsNil        bool     `json:"desiredOutcomeIsNil,omitempty"`
	DesiredOutcomeNotNil       bool     `json:"desiredOutcomeNotNil,omitempty"`
	DesiredOutcomeEqualFold    *string  `json:"desiredOutcomeEqualFold,omitempty"`
	DesiredOutcomeContainsFold *string  `json:"desiredOutcomeContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.ObjectiveStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.ObjectiveStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.ObjectiveStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.ObjectiveStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                    `json:"statusIsNil,omitempty"`
	StatusNotNil bool                    `json:"statusNotNil,omitempty"`

	// "source" field predicates.
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNEQ    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  bool                  `json:"sourceIsNil,omitempty"`
	SourceNotNil bool                  `json:"sourceNotNil,omitempty"`

	// "control_objective_type" field predicates.
	ControlObjectiveType             *string  `json:"controlObjectiveType,omitempty"`
	ControlObjectiveTypeNEQ          *string  `json:"controlObjectiveTypeNEQ,omitempty"`
	ControlObjectiveTypeIn           []string `json:"controlObjectiveTypeIn,omitempty"`
	ControlObjectiveTypeNotIn        []string `json:"controlObjectiveTypeNotIn,omitempty"`
	ControlObjectiveTypeGT           *string  `json:"controlObjectiveTypeGT,omitempty"`
	ControlObjectiveTypeGTE          *string  `json:"controlObjectiveTypeGTE,omitempty"`
	ControlObjectiveTypeLT           *string  `json:"controlObjectiveTypeLT,omitempty"`
	ControlObjectiveTypeLTE          *string  `json:"controlObjectiveTypeLTE,omitempty"`
	ControlObjectiveTypeContains     *string  `json:"controlObjectiveTypeContains,omitempty"`
	ControlObjectiveTypeHasPrefix    *string  `json:"controlObjectiveTypeHasPrefix,omitempty"`
	ControlObjectiveTypeHasSuffix    *string  `json:"controlObjectiveTypeHasSuffix,omitempty"`
	ControlObjectiveTypeIsNil        bool     `json:"controlObjectiveTypeIsNil,omitempty"`
	ControlObjectiveTypeNotNil       bool     `json:"controlObjectiveTypeNotNil,omitempty"`
	ControlObjectiveTypeEqualFold    *string  `json:"controlObjectiveTypeEqualFold,omitempty"`
	ControlObjectiveTypeContainsFold *string  `json:"controlObjectiveTypeContainsFold,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        bool     `json:"categoryIsNil,omitempty"`
	CategoryNotNil       bool     `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "subcategory" field predicates.
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNEQ          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGT           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGTE          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLT           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLTE          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        bool     `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       bool     `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ControlObjectiveHistoryWhereInput) AddPredicates(predicates ...predicate.ControlObjectiveHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ControlObjectiveHistoryWhereInput filter on the ControlObjectiveHistoryQuery builder.
func (i *ControlObjectiveHistoryWhereInput) Filter(q *ControlObjectiveHistoryQuery) (*ControlObjectiveHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyControlObjectiveHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyControlObjectiveHistoryWhereInput is returned in case the ControlObjectiveHistoryWhereInput is empty.
var ErrEmptyControlObjectiveHistoryWhereInput = errors.New("generated: empty predicate ControlObjectiveHistoryWhereInput")

// P returns a predicate for filtering controlobjectivehistories.
// An error is returned if the input is empty or invalid.
func (i *ControlObjectiveHistoryWhereInput) P() (predicate.ControlObjectiveHistory, error) {
	var predicates []predicate.ControlObjectiveHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, controlobjectivehistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ControlObjectiveHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, controlobjectivehistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ControlObjectiveHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, controlobjectivehistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, controlobjectivehistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, controlobjectivehistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, controlobjectivehistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, controlobjectivehistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, controlobjectivehistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, controlobjectivehistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, controlobjectivehistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, controlobjectivehistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, controlobjectivehistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, controlobjectivehistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, controlobjectivehistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, controlobjectivehistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, controlobjectivehistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, controlobjectivehistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, controlobjectivehistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, controlobjectivehistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, controlobjectivehistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, controlobjectivehistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, controlobjectivehistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, controlobjectivehistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, controlobjectivehistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, controlobjectivehistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, controlobjectivehistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, controlobjectivehistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, controlobjectivehistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, controlobjectivehistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, controlobjectivehistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, controlobjectivehistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, controlobjectivehistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, controlobjectivehistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, controlobjectivehistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, controlobjectivehistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, controlobjectivehistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, controlobjectivehistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, controlobjectivehistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, controlobjectivehistory.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, controlobjectivehistory.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, controlobjectivehistory.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, controlobjectivehistory.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, controlobjectivehistory.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, controlobjectivehistory.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, controlobjectivehistory.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, controlobjectivehistory.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, controlobjectivehistory.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, controlobjectivehistory.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.Revision != nil {
		predicates = append(predicates, controlobjectivehistory.RevisionEQ(*i.Revision))
	}
	if i.RevisionNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.RevisionNEQ(*i.RevisionNEQ))
	}
	if len(i.RevisionIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.RevisionIn(i.RevisionIn...))
	}
	if len(i.RevisionNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.RevisionNotIn(i.RevisionNotIn...))
	}
	if i.RevisionGT != nil {
		predicates = append(predicates, controlobjectivehistory.RevisionGT(*i.RevisionGT))
	}
	if i.RevisionGTE != nil {
		predicates = append(predicates, controlobjectivehistory.RevisionGTE(*i.RevisionGTE))
	}
	if i.RevisionLT != nil {
		predicates = append(predicates, controlobjectivehistory.RevisionLT(*i.RevisionLT))
	}
	if i.RevisionLTE != nil {
		predicates = append(predicates, controlobjectivehistory.RevisionLTE(*i.RevisionLTE))
	}
	if i.RevisionContains != nil {
		predicates = append(predicates, controlobjectivehistory.RevisionContains(*i.RevisionContains))
	}
	if i.RevisionHasPrefix != nil {
		predicates = append(predicates, controlobjectivehistory.RevisionHasPrefix(*i.RevisionHasPrefix))
	}
	if i.RevisionHasSuffix != nil {
		predicates = append(predicates, controlobjectivehistory.RevisionHasSuffix(*i.RevisionHasSuffix))
	}
	if i.RevisionIsNil {
		predicates = append(predicates, controlobjectivehistory.RevisionIsNil())
	}
	if i.RevisionNotNil {
		predicates = append(predicates, controlobjectivehistory.RevisionNotNil())
	}
	if i.RevisionEqualFold != nil {
		predicates = append(predicates, controlobjectivehistory.RevisionEqualFold(*i.RevisionEqualFold))
	}
	if i.RevisionContainsFold != nil {
		predicates = append(predicates, controlobjectivehistory.RevisionContainsFold(*i.RevisionContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, controlobjectivehistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, controlobjectivehistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, controlobjectivehistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, controlobjectivehistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, controlobjectivehistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, controlobjectivehistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, controlobjectivehistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, controlobjectivehistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, controlobjectivehistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, controlobjectivehistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, controlobjectivehistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, controlobjectivehistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, controlobjectivehistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, controlobjectivehistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, controlobjectivehistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, controlobjectivehistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, controlobjectivehistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, controlobjectivehistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, controlobjectivehistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, controlobjectivehistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, controlobjectivehistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, controlobjectivehistory.NameContainsFold(*i.NameContainsFold))
	}
	if i.DesiredOutcome != nil {
		predicates = append(predicates, controlobjectivehistory.DesiredOutcomeEQ(*i.DesiredOutcome))
	}
	if i.DesiredOutcomeNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.DesiredOutcomeNEQ(*i.DesiredOutcomeNEQ))
	}
	if len(i.DesiredOutcomeIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.DesiredOutcomeIn(i.DesiredOutcomeIn...))
	}
	if len(i.DesiredOutcomeNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.DesiredOutcomeNotIn(i.DesiredOutcomeNotIn...))
	}
	if i.DesiredOutcomeGT != nil {
		predicates = append(predicates, controlobjectivehistory.DesiredOutcomeGT(*i.DesiredOutcomeGT))
	}
	if i.DesiredOutcomeGTE != nil {
		predicates = append(predicates, controlobjectivehistory.DesiredOutcomeGTE(*i.DesiredOutcomeGTE))
	}
	if i.DesiredOutcomeLT != nil {
		predicates = append(predicates, controlobjectivehistory.DesiredOutcomeLT(*i.DesiredOutcomeLT))
	}
	if i.DesiredOutcomeLTE != nil {
		predicates = append(predicates, controlobjectivehistory.DesiredOutcomeLTE(*i.DesiredOutcomeLTE))
	}
	if i.DesiredOutcomeContains != nil {
		predicates = append(predicates, controlobjectivehistory.DesiredOutcomeContains(*i.DesiredOutcomeContains))
	}
	if i.DesiredOutcomeHasPrefix != nil {
		predicates = append(predicates, controlobjectivehistory.DesiredOutcomeHasPrefix(*i.DesiredOutcomeHasPrefix))
	}
	if i.DesiredOutcomeHasSuffix != nil {
		predicates = append(predicates, controlobjectivehistory.DesiredOutcomeHasSuffix(*i.DesiredOutcomeHasSuffix))
	}
	if i.DesiredOutcomeIsNil {
		predicates = append(predicates, controlobjectivehistory.DesiredOutcomeIsNil())
	}
	if i.DesiredOutcomeNotNil {
		predicates = append(predicates, controlobjectivehistory.DesiredOutcomeNotNil())
	}
	if i.DesiredOutcomeEqualFold != nil {
		predicates = append(predicates, controlobjectivehistory.DesiredOutcomeEqualFold(*i.DesiredOutcomeEqualFold))
	}
	if i.DesiredOutcomeContainsFold != nil {
		predicates = append(predicates, controlobjectivehistory.DesiredOutcomeContainsFold(*i.DesiredOutcomeContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, controlobjectivehistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, controlobjectivehistory.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, controlobjectivehistory.StatusNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, controlobjectivehistory.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceIsNil {
		predicates = append(predicates, controlobjectivehistory.SourceIsNil())
	}
	if i.SourceNotNil {
		predicates = append(predicates, controlobjectivehistory.SourceNotNil())
	}
	if i.ControlObjectiveType != nil {
		predicates = append(predicates, controlobjectivehistory.ControlObjectiveTypeEQ(*i.ControlObjectiveType))
	}
	if i.ControlObjectiveTypeNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.ControlObjectiveTypeNEQ(*i.ControlObjectiveTypeNEQ))
	}
	if len(i.ControlObjectiveTypeIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.ControlObjectiveTypeIn(i.ControlObjectiveTypeIn...))
	}
	if len(i.ControlObjectiveTypeNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.ControlObjectiveTypeNotIn(i.ControlObjectiveTypeNotIn...))
	}
	if i.ControlObjectiveTypeGT != nil {
		predicates = append(predicates, controlobjectivehistory.ControlObjectiveTypeGT(*i.ControlObjectiveTypeGT))
	}
	if i.ControlObjectiveTypeGTE != nil {
		predicates = append(predicates, controlobjectivehistory.ControlObjectiveTypeGTE(*i.ControlObjectiveTypeGTE))
	}
	if i.ControlObjectiveTypeLT != nil {
		predicates = append(predicates, controlobjectivehistory.ControlObjectiveTypeLT(*i.ControlObjectiveTypeLT))
	}
	if i.ControlObjectiveTypeLTE != nil {
		predicates = append(predicates, controlobjectivehistory.ControlObjectiveTypeLTE(*i.ControlObjectiveTypeLTE))
	}
	if i.ControlObjectiveTypeContains != nil {
		predicates = append(predicates, controlobjectivehistory.ControlObjectiveTypeContains(*i.ControlObjectiveTypeContains))
	}
	if i.ControlObjectiveTypeHasPrefix != nil {
		predicates = append(predicates, controlobjectivehistory.ControlObjectiveTypeHasPrefix(*i.ControlObjectiveTypeHasPrefix))
	}
	if i.ControlObjectiveTypeHasSuffix != nil {
		predicates = append(predicates, controlobjectivehistory.ControlObjectiveTypeHasSuffix(*i.ControlObjectiveTypeHasSuffix))
	}
	if i.ControlObjectiveTypeIsNil {
		predicates = append(predicates, controlobjectivehistory.ControlObjectiveTypeIsNil())
	}
	if i.ControlObjectiveTypeNotNil {
		predicates = append(predicates, controlobjectivehistory.ControlObjectiveTypeNotNil())
	}
	if i.ControlObjectiveTypeEqualFold != nil {
		predicates = append(predicates, controlobjectivehistory.ControlObjectiveTypeEqualFold(*i.ControlObjectiveTypeEqualFold))
	}
	if i.ControlObjectiveTypeContainsFold != nil {
		predicates = append(predicates, controlobjectivehistory.ControlObjectiveTypeContainsFold(*i.ControlObjectiveTypeContainsFold))
	}
	if i.Category != nil {
		predicates = append(predicates, controlobjectivehistory.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, controlobjectivehistory.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, controlobjectivehistory.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, controlobjectivehistory.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, controlobjectivehistory.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, controlobjectivehistory.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, controlobjectivehistory.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, controlobjectivehistory.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryIsNil {
		predicates = append(predicates, controlobjectivehistory.CategoryIsNil())
	}
	if i.CategoryNotNil {
		predicates = append(predicates, controlobjectivehistory.CategoryNotNil())
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, controlobjectivehistory.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, controlobjectivehistory.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.Subcategory != nil {
		predicates = append(predicates, controlobjectivehistory.SubcategoryEQ(*i.Subcategory))
	}
	if i.SubcategoryNEQ != nil {
		predicates = append(predicates, controlobjectivehistory.SubcategoryNEQ(*i.SubcategoryNEQ))
	}
	if len(i.SubcategoryIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.SubcategoryIn(i.SubcategoryIn...))
	}
	if len(i.SubcategoryNotIn) > 0 {
		predicates = append(predicates, controlobjectivehistory.SubcategoryNotIn(i.SubcategoryNotIn...))
	}
	if i.SubcategoryGT != nil {
		predicates = append(predicates, controlobjectivehistory.SubcategoryGT(*i.SubcategoryGT))
	}
	if i.SubcategoryGTE != nil {
		predicates = append(predicates, controlobjectivehistory.SubcategoryGTE(*i.SubcategoryGTE))
	}
	if i.SubcategoryLT != nil {
		predicates = append(predicates, controlobjectivehistory.SubcategoryLT(*i.SubcategoryLT))
	}
	if i.SubcategoryLTE != nil {
		predicates = append(predicates, controlobjectivehistory.SubcategoryLTE(*i.SubcategoryLTE))
	}
	if i.SubcategoryContains != nil {
		predicates = append(predicates, controlobjectivehistory.SubcategoryContains(*i.SubcategoryContains))
	}
	if i.SubcategoryHasPrefix != nil {
		predicates = append(predicates, controlobjectivehistory.SubcategoryHasPrefix(*i.SubcategoryHasPrefix))
	}
	if i.SubcategoryHasSuffix != nil {
		predicates = append(predicates, controlobjectivehistory.SubcategoryHasSuffix(*i.SubcategoryHasSuffix))
	}
	if i.SubcategoryIsNil {
		predicates = append(predicates, controlobjectivehistory.SubcategoryIsNil())
	}
	if i.SubcategoryNotNil {
		predicates = append(predicates, controlobjectivehistory.SubcategoryNotNil())
	}
	if i.SubcategoryEqualFold != nil {
		predicates = append(predicates, controlobjectivehistory.SubcategoryEqualFold(*i.SubcategoryEqualFold))
	}
	if i.SubcategoryContainsFold != nil {
		predicates = append(predicates, controlobjectivehistory.SubcategoryContainsFold(*i.SubcategoryContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyControlObjectiveHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return controlobjectivehistory.And(predicates...), nil
	}
}

// ControlScheduledJobWhereInput represents a where input for filtering ControlScheduledJob queries.
type ControlScheduledJobWhereInput struct {
	Predicates []predicate.ControlScheduledJob  `json:"-"`
	Not        *ControlScheduledJobWhereInput   `json:"not,omitempty"`
	Or         []*ControlScheduledJobWhereInput `json:"or,omitempty"`
	And        []*ControlScheduledJobWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "job_id" field predicates.
	JobID             *string  `json:"jobID,omitempty"`
	JobIDNEQ          *string  `json:"jobIDNEQ,omitempty"`
	JobIDIn           []string `json:"jobIDIn,omitempty"`
	JobIDNotIn        []string `json:"jobIDNotIn,omitempty"`
	JobIDGT           *string  `json:"jobIDGT,omitempty"`
	JobIDGTE          *string  `json:"jobIDGTE,omitempty"`
	JobIDLT           *string  `json:"jobIDLT,omitempty"`
	JobIDLTE          *string  `json:"jobIDLTE,omitempty"`
	JobIDContains     *string  `json:"jobIDContains,omitempty"`
	JobIDHasPrefix    *string  `json:"jobIDHasPrefix,omitempty"`
	JobIDHasSuffix    *string  `json:"jobIDHasSuffix,omitempty"`
	JobIDEqualFold    *string  `json:"jobIDEqualFold,omitempty"`
	JobIDContainsFold *string  `json:"jobIDContainsFold,omitempty"`

	// "job_runner_id" field predicates.
	JobRunnerID             *string  `json:"jobRunnerID,omitempty"`
	JobRunnerIDNEQ          *string  `json:"jobRunnerIDNEQ,omitempty"`
	JobRunnerIDIn           []string `json:"jobRunnerIDIn,omitempty"`
	JobRunnerIDNotIn        []string `json:"jobRunnerIDNotIn,omitempty"`
	JobRunnerIDGT           *string  `json:"jobRunnerIDGT,omitempty"`
	JobRunnerIDGTE          *string  `json:"jobRunnerIDGTE,omitempty"`
	JobRunnerIDLT           *string  `json:"jobRunnerIDLT,omitempty"`
	JobRunnerIDLTE          *string  `json:"jobRunnerIDLTE,omitempty"`
	JobRunnerIDContains     *string  `json:"jobRunnerIDContains,omitempty"`
	JobRunnerIDHasPrefix    *string  `json:"jobRunnerIDHasPrefix,omitempty"`
	JobRunnerIDHasSuffix    *string  `json:"jobRunnerIDHasSuffix,omitempty"`
	JobRunnerIDIsNil        bool     `json:"jobRunnerIDIsNil,omitempty"`
	JobRunnerIDNotNil       bool     `json:"jobRunnerIDNotNil,omitempty"`
	JobRunnerIDEqualFold    *string  `json:"jobRunnerIDEqualFold,omitempty"`
	JobRunnerIDContainsFold *string  `json:"jobRunnerIDContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "job" edge predicates.
	HasJob     *bool                     `json:"hasJob,omitempty"`
	HasJobWith []*ScheduledJobWhereInput `json:"hasJobWith,omitempty"`

	// "controls" edge predicates.
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`

	// "subcontrols" edge predicates.
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`

	// "job_runner" edge predicates.
	HasJobRunner     *bool                  `json:"hasJobRunner,omitempty"`
	HasJobRunnerWith []*JobRunnerWhereInput `json:"hasJobRunnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ControlScheduledJobWhereInput) AddPredicates(predicates ...predicate.ControlScheduledJob) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ControlScheduledJobWhereInput filter on the ControlScheduledJobQuery builder.
func (i *ControlScheduledJobWhereInput) Filter(q *ControlScheduledJobQuery) (*ControlScheduledJobQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyControlScheduledJobWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyControlScheduledJobWhereInput is returned in case the ControlScheduledJobWhereInput is empty.
var ErrEmptyControlScheduledJobWhereInput = errors.New("generated: empty predicate ControlScheduledJobWhereInput")

// P returns a predicate for filtering controlscheduledjobs.
// An error is returned if the input is empty or invalid.
func (i *ControlScheduledJobWhereInput) P() (predicate.ControlScheduledJob, error) {
	var predicates []predicate.ControlScheduledJob
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, controlscheduledjob.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ControlScheduledJob, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, controlscheduledjob.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ControlScheduledJob, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, controlscheduledjob.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, controlscheduledjob.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, controlscheduledjob.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, controlscheduledjob.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, controlscheduledjob.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, controlscheduledjob.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, controlscheduledjob.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, controlscheduledjob.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, controlscheduledjob.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, controlscheduledjob.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, controlscheduledjob.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, controlscheduledjob.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, controlscheduledjob.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, controlscheduledjob.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, controlscheduledjob.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, controlscheduledjob.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, controlscheduledjob.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, controlscheduledjob.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, controlscheduledjob.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, controlscheduledjob.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, controlscheduledjob.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, controlscheduledjob.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, controlscheduledjob.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, controlscheduledjob.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, controlscheduledjob.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, controlscheduledjob.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, controlscheduledjob.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, controlscheduledjob.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, controlscheduledjob.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, controlscheduledjob.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, controlscheduledjob.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, controlscheduledjob.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, controlscheduledjob.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, controlscheduledjob.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, controlscheduledjob.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, controlscheduledjob.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, controlscheduledjob.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, controlscheduledjob.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, controlscheduledjob.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, controlscheduledjob.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, controlscheduledjob.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, controlscheduledjob.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, controlscheduledjob.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, controlscheduledjob.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, controlscheduledjob.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, controlscheduledjob.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, controlscheduledjob.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, controlscheduledjob.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, controlscheduledjob.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, controlscheduledjob.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, controlscheduledjob.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, controlscheduledjob.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, controlscheduledjob.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, controlscheduledjob.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, controlscheduledjob.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, controlscheduledjob.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, controlscheduledjob.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, controlscheduledjob.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, controlscheduledjob.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, controlscheduledjob.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.JobID != nil {
		predicates = append(predicates, controlscheduledjob.JobIDEQ(*i.JobID))
	}
	if i.JobIDNEQ != nil {
		predicates = append(predicates, controlscheduledjob.JobIDNEQ(*i.JobIDNEQ))
	}
	if len(i.JobIDIn) > 0 {
		predicates = append(predicates, controlscheduledjob.JobIDIn(i.JobIDIn...))
	}
	if len(i.JobIDNotIn) > 0 {
		predicates = append(predicates, controlscheduledjob.JobIDNotIn(i.JobIDNotIn...))
	}
	if i.JobIDGT != nil {
		predicates = append(predicates, controlscheduledjob.JobIDGT(*i.JobIDGT))
	}
	if i.JobIDGTE != nil {
		predicates = append(predicates, controlscheduledjob.JobIDGTE(*i.JobIDGTE))
	}
	if i.JobIDLT != nil {
		predicates = append(predicates, controlscheduledjob.JobIDLT(*i.JobIDLT))
	}
	if i.JobIDLTE != nil {
		predicates = append(predicates, controlscheduledjob.JobIDLTE(*i.JobIDLTE))
	}
	if i.JobIDContains != nil {
		predicates = append(predicates, controlscheduledjob.JobIDContains(*i.JobIDContains))
	}
	if i.JobIDHasPrefix != nil {
		predicates = append(predicates, controlscheduledjob.JobIDHasPrefix(*i.JobIDHasPrefix))
	}
	if i.JobIDHasSuffix != nil {
		predicates = append(predicates, controlscheduledjob.JobIDHasSuffix(*i.JobIDHasSuffix))
	}
	if i.JobIDEqualFold != nil {
		predicates = append(predicates, controlscheduledjob.JobIDEqualFold(*i.JobIDEqualFold))
	}
	if i.JobIDContainsFold != nil {
		predicates = append(predicates, controlscheduledjob.JobIDContainsFold(*i.JobIDContainsFold))
	}
	if i.JobRunnerID != nil {
		predicates = append(predicates, controlscheduledjob.JobRunnerIDEQ(*i.JobRunnerID))
	}
	if i.JobRunnerIDNEQ != nil {
		predicates = append(predicates, controlscheduledjob.JobRunnerIDNEQ(*i.JobRunnerIDNEQ))
	}
	if len(i.JobRunnerIDIn) > 0 {
		predicates = append(predicates, controlscheduledjob.JobRunnerIDIn(i.JobRunnerIDIn...))
	}
	if len(i.JobRunnerIDNotIn) > 0 {
		predicates = append(predicates, controlscheduledjob.JobRunnerIDNotIn(i.JobRunnerIDNotIn...))
	}
	if i.JobRunnerIDGT != nil {
		predicates = append(predicates, controlscheduledjob.JobRunnerIDGT(*i.JobRunnerIDGT))
	}
	if i.JobRunnerIDGTE != nil {
		predicates = append(predicates, controlscheduledjob.JobRunnerIDGTE(*i.JobRunnerIDGTE))
	}
	if i.JobRunnerIDLT != nil {
		predicates = append(predicates, controlscheduledjob.JobRunnerIDLT(*i.JobRunnerIDLT))
	}
	if i.JobRunnerIDLTE != nil {
		predicates = append(predicates, controlscheduledjob.JobRunnerIDLTE(*i.JobRunnerIDLTE))
	}
	if i.JobRunnerIDContains != nil {
		predicates = append(predicates, controlscheduledjob.JobRunnerIDContains(*i.JobRunnerIDContains))
	}
	if i.JobRunnerIDHasPrefix != nil {
		predicates = append(predicates, controlscheduledjob.JobRunnerIDHasPrefix(*i.JobRunnerIDHasPrefix))
	}
	if i.JobRunnerIDHasSuffix != nil {
		predicates = append(predicates, controlscheduledjob.JobRunnerIDHasSuffix(*i.JobRunnerIDHasSuffix))
	}
	if i.JobRunnerIDIsNil {
		predicates = append(predicates, controlscheduledjob.JobRunnerIDIsNil())
	}
	if i.JobRunnerIDNotNil {
		predicates = append(predicates, controlscheduledjob.JobRunnerIDNotNil())
	}
	if i.JobRunnerIDEqualFold != nil {
		predicates = append(predicates, controlscheduledjob.JobRunnerIDEqualFold(*i.JobRunnerIDEqualFold))
	}
	if i.JobRunnerIDContainsFold != nil {
		predicates = append(predicates, controlscheduledjob.JobRunnerIDContainsFold(*i.JobRunnerIDContainsFold))
	}

	if i.HasOwner != nil {
		p := controlscheduledjob.HasOwner()
		if !*i.HasOwner {
			p = controlscheduledjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlscheduledjob.HasOwnerWith(with...))
	}
	if i.HasJob != nil {
		p := controlscheduledjob.HasJob()
		if !*i.HasJob {
			p = controlscheduledjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobWith) > 0 {
		with := make([]predicate.ScheduledJob, 0, len(i.HasJobWith))
		for _, w := range i.HasJobWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlscheduledjob.HasJobWith(with...))
	}
	if i.HasControls != nil {
		p := controlscheduledjob.HasControls()
		if !*i.HasControls {
			p = controlscheduledjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasControlsWith))
		for _, w := range i.HasControlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlscheduledjob.HasControlsWith(with...))
	}
	if i.HasSubcontrols != nil {
		p := controlscheduledjob.HasSubcontrols()
		if !*i.HasSubcontrols {
			p = controlscheduledjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubcontrolsWith) > 0 {
		with := make([]predicate.Subcontrol, 0, len(i.HasSubcontrolsWith))
		for _, w := range i.HasSubcontrolsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubcontrolsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlscheduledjob.HasSubcontrolsWith(with...))
	}
	if i.HasJobRunner != nil {
		p := controlscheduledjob.HasJobRunner()
		if !*i.HasJobRunner {
			p = controlscheduledjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobRunnerWith) > 0 {
		with := make([]predicate.JobRunner, 0, len(i.HasJobRunnerWith))
		for _, w := range i.HasJobRunnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobRunnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, controlscheduledjob.HasJobRunnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyControlScheduledJobWhereInput
	case 1:
		return predicates[0], nil
	default:
		return controlscheduledjob.And(predicates...), nil
	}
}

// ControlScheduledJobHistoryWhereInput represents a where input for filtering ControlScheduledJobHistory queries.
type ControlScheduledJobHistoryWhereInput struct {
	Predicates []predicate.ControlScheduledJobHistory  `json:"-"`
	Not        *ControlScheduledJobHistoryWhereInput   `json:"not,omitempty"`
	Or         []*ControlScheduledJobHistoryWhereInput `json:"or,omitempty"`
	And        []*ControlScheduledJobHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "job_id" field predicates.
	JobID             *string  `json:"jobID,omitempty"`
	JobIDNEQ          *string  `json:"jobIDNEQ,omitempty"`
	JobIDIn           []string `json:"jobIDIn,omitempty"`
	JobIDNotIn        []string `json:"jobIDNotIn,omitempty"`
	JobIDGT           *string  `json:"jobIDGT,omitempty"`
	JobIDGTE          *string  `json:"jobIDGTE,omitempty"`
	JobIDLT           *string  `json:"jobIDLT,omitempty"`
	JobIDLTE          *string  `json:"jobIDLTE,omitempty"`
	JobIDContains     *string  `json:"jobIDContains,omitempty"`
	JobIDHasPrefix    *string  `json:"jobIDHasPrefix,omitempty"`
	JobIDHasSuffix    *string  `json:"jobIDHasSuffix,omitempty"`
	JobIDEqualFold    *string  `json:"jobIDEqualFold,omitempty"`
	JobIDContainsFold *string  `json:"jobIDContainsFold,omitempty"`

	// "job_runner_id" field predicates.
	JobRunnerID             *string  `json:"jobRunnerID,omitempty"`
	JobRunnerIDNEQ          *string  `json:"jobRunnerIDNEQ,omitempty"`
	JobRunnerIDIn           []string `json:"jobRunnerIDIn,omitempty"`
	JobRunnerIDNotIn        []string `json:"jobRunnerIDNotIn,omitempty"`
	JobRunnerIDGT           *string  `json:"jobRunnerIDGT,omitempty"`
	JobRunnerIDGTE          *string  `json:"jobRunnerIDGTE,omitempty"`
	JobRunnerIDLT           *string  `json:"jobRunnerIDLT,omitempty"`
	JobRunnerIDLTE          *string  `json:"jobRunnerIDLTE,omitempty"`
	JobRunnerIDContains     *string  `json:"jobRunnerIDContains,omitempty"`
	JobRunnerIDHasPrefix    *string  `json:"jobRunnerIDHasPrefix,omitempty"`
	JobRunnerIDHasSuffix    *string  `json:"jobRunnerIDHasSuffix,omitempty"`
	JobRunnerIDIsNil        bool     `json:"jobRunnerIDIsNil,omitempty"`
	JobRunnerIDNotNil       bool     `json:"jobRunnerIDNotNil,omitempty"`
	JobRunnerIDEqualFold    *string  `json:"jobRunnerIDEqualFold,omitempty"`
	JobRunnerIDContainsFold *string  `json:"jobRunnerIDContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ControlScheduledJobHistoryWhereInput) AddPredicates(predicates ...predicate.ControlScheduledJobHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ControlScheduledJobHistoryWhereInput filter on the ControlScheduledJobHistoryQuery builder.
func (i *ControlScheduledJobHistoryWhereInput) Filter(q *ControlScheduledJobHistoryQuery) (*ControlScheduledJobHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyControlScheduledJobHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyControlScheduledJobHistoryWhereInput is returned in case the ControlScheduledJobHistoryWhereInput is empty.
var ErrEmptyControlScheduledJobHistoryWhereInput = errors.New("generated: empty predicate ControlScheduledJobHistoryWhereInput")

// P returns a predicate for filtering controlscheduledjobhistories.
// An error is returned if the input is empty or invalid.
func (i *ControlScheduledJobHistoryWhereInput) P() (predicate.ControlScheduledJobHistory, error) {
	var predicates []predicate.ControlScheduledJobHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, controlscheduledjobhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ControlScheduledJobHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, controlscheduledjobhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ControlScheduledJobHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, controlscheduledjobhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, controlscheduledjobhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, controlscheduledjobhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, controlscheduledjobhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, controlscheduledjobhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, controlscheduledjobhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, controlscheduledjobhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, controlscheduledjobhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, controlscheduledjobhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, controlscheduledjobhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, controlscheduledjobhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, controlscheduledjobhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, controlscheduledjobhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, controlscheduledjobhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, controlscheduledjobhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, controlscheduledjobhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, controlscheduledjobhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, controlscheduledjobhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, controlscheduledjobhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, controlscheduledjobhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, controlscheduledjobhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, controlscheduledjobhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, controlscheduledjobhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, controlscheduledjobhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, controlscheduledjobhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, controlscheduledjobhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, controlscheduledjobhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, controlscheduledjobhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, controlscheduledjobhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, controlscheduledjobhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, controlscheduledjobhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, controlscheduledjobhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, controlscheduledjobhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, controlscheduledjobhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, controlscheduledjobhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, controlscheduledjobhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, controlscheduledjobhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.JobID != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobIDEQ(*i.JobID))
	}
	if i.JobIDNEQ != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobIDNEQ(*i.JobIDNEQ))
	}
	if len(i.JobIDIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.JobIDIn(i.JobIDIn...))
	}
	if len(i.JobIDNotIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.JobIDNotIn(i.JobIDNotIn...))
	}
	if i.JobIDGT != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobIDGT(*i.JobIDGT))
	}
	if i.JobIDGTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobIDGTE(*i.JobIDGTE))
	}
	if i.JobIDLT != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobIDLT(*i.JobIDLT))
	}
	if i.JobIDLTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobIDLTE(*i.JobIDLTE))
	}
	if i.JobIDContains != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobIDContains(*i.JobIDContains))
	}
	if i.JobIDHasPrefix != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobIDHasPrefix(*i.JobIDHasPrefix))
	}
	if i.JobIDHasSuffix != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobIDHasSuffix(*i.JobIDHasSuffix))
	}
	if i.JobIDEqualFold != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobIDEqualFold(*i.JobIDEqualFold))
	}
	if i.JobIDContainsFold != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobIDContainsFold(*i.JobIDContainsFold))
	}
	if i.JobRunnerID != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobRunnerIDEQ(*i.JobRunnerID))
	}
	if i.JobRunnerIDNEQ != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobRunnerIDNEQ(*i.JobRunnerIDNEQ))
	}
	if len(i.JobRunnerIDIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.JobRunnerIDIn(i.JobRunnerIDIn...))
	}
	if len(i.JobRunnerIDNotIn) > 0 {
		predicates = append(predicates, controlscheduledjobhistory.JobRunnerIDNotIn(i.JobRunnerIDNotIn...))
	}
	if i.JobRunnerIDGT != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobRunnerIDGT(*i.JobRunnerIDGT))
	}
	if i.JobRunnerIDGTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobRunnerIDGTE(*i.JobRunnerIDGTE))
	}
	if i.JobRunnerIDLT != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobRunnerIDLT(*i.JobRunnerIDLT))
	}
	if i.JobRunnerIDLTE != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobRunnerIDLTE(*i.JobRunnerIDLTE))
	}
	if i.JobRunnerIDContains != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobRunnerIDContains(*i.JobRunnerIDContains))
	}
	if i.JobRunnerIDHasPrefix != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobRunnerIDHasPrefix(*i.JobRunnerIDHasPrefix))
	}
	if i.JobRunnerIDHasSuffix != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobRunnerIDHasSuffix(*i.JobRunnerIDHasSuffix))
	}
	if i.JobRunnerIDIsNil {
		predicates = append(predicates, controlscheduledjobhistory.JobRunnerIDIsNil())
	}
	if i.JobRunnerIDNotNil {
		predicates = append(predicates, controlscheduledjobhistory.JobRunnerIDNotNil())
	}
	if i.JobRunnerIDEqualFold != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobRunnerIDEqualFold(*i.JobRunnerIDEqualFold))
	}
	if i.JobRunnerIDContainsFold != nil {
		predicates = append(predicates, controlscheduledjobhistory.JobRunnerIDContainsFold(*i.JobRunnerIDContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyControlScheduledJobHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return controlscheduledjobhistory.And(predicates...), nil
	}
}

// CustomDomainWhereInput represents a where input for filtering CustomDomain queries.
type CustomDomainWhereInput struct {
	Predicates []predicate.CustomDomain  `json:"-"`
	Not        *CustomDomainWhereInput   `json:"not,omitempty"`
	Or         []*CustomDomainWhereInput `json:"or,omitempty"`
	And        []*CustomDomainWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "cname_record" field predicates.
	CnameRecord             *string  `json:"cnameRecord,omitempty"`
	CnameRecordNEQ          *string  `json:"cnameRecordNEQ,omitempty"`
	CnameRecordIn           []string `json:"cnameRecordIn,omitempty"`
	CnameRecordNotIn        []string `json:"cnameRecordNotIn,omitempty"`
	CnameRecordGT           *string  `json:"cnameRecordGT,omitempty"`
	CnameRecordGTE          *string  `json:"cnameRecordGTE,omitempty"`
	CnameRecordLT           *string  `json:"cnameRecordLT,omitempty"`
	CnameRecordLTE          *string  `json:"cnameRecordLTE,omitempty"`
	CnameRecordContains     *string  `json:"cnameRecordContains,omitempty"`
	CnameRecordHasPrefix    *string  `json:"cnameRecordHasPrefix,omitempty"`
	CnameRecordHasSuffix    *string  `json:"cnameRecordHasSuffix,omitempty"`
	CnameRecordEqualFold    *string  `json:"cnameRecordEqualFold,omitempty"`
	CnameRecordContainsFold *string  `json:"cnameRecordContainsFold,omitempty"`

	// "mappable_domain_id" field predicates.
	MappableDomainID             *string  `json:"mappableDomainID,omitempty"`
	MappableDomainIDNEQ          *string  `json:"mappableDomainIDNEQ,omitempty"`
	MappableDomainIDIn           []string `json:"mappableDomainIDIn,omitempty"`
	MappableDomainIDNotIn        []string `json:"mappableDomainIDNotIn,omitempty"`
	MappableDomainIDGT           *string  `json:"mappableDomainIDGT,omitempty"`
	MappableDomainIDGTE          *string  `json:"mappableDomainIDGTE,omitempty"`
	MappableDomainIDLT           *string  `json:"mappableDomainIDLT,omitempty"`
	MappableDomainIDLTE          *string  `json:"mappableDomainIDLTE,omitempty"`
	MappableDomainIDContains     *string  `json:"mappableDomainIDContains,omitempty"`
	MappableDomainIDHasPrefix    *string  `json:"mappableDomainIDHasPrefix,omitempty"`
	MappableDomainIDHasSuffix    *string  `json:"mappableDomainIDHasSuffix,omitempty"`
	MappableDomainIDEqualFold    *string  `json:"mappableDomainIDEqualFold,omitempty"`
	MappableDomainIDContainsFold *string  `json:"mappableDomainIDContainsFold,omitempty"`

	// "dns_verification_id" field predicates.
	DNSVerificationID             *string  `json:"dnsVerificationID,omitempty"`
	DNSVerificationIDNEQ          *string  `json:"dnsVerificationIDNEQ,omitempty"`
	DNSVerificationIDIn           []string `json:"dnsVerificationIDIn,omitempty"`
	DNSVerificationIDNotIn        []string `json:"dnsVerificationIDNotIn,omitempty"`
	DNSVerificationIDGT           *string  `json:"dnsVerificationIDGT,omitempty"`
	DNSVerificationIDGTE          *string  `json:"dnsVerificationIDGTE,omitempty"`
	DNSVerificationIDLT           *string  `json:"dnsVerificationIDLT,omitempty"`
	DNSVerificationIDLTE          *string  `json:"dnsVerificationIDLTE,omitempty"`
	DNSVerificationIDContains     *string  `json:"dnsVerificationIDContains,omitempty"`
	DNSVerificationIDHasPrefix    *string  `json:"dnsVerificationIDHasPrefix,omitempty"`
	DNSVerificationIDHasSuffix    *string  `json:"dnsVerificationIDHasSuffix,omitempty"`
	DNSVerificationIDIsNil        bool     `json:"dnsVerificationIDIsNil,omitempty"`
	DNSVerificationIDNotNil       bool     `json:"dnsVerificationIDNotNil,omitempty"`
	DNSVerificationIDEqualFold    *string  `json:"dnsVerificationIDEqualFold,omitempty"`
	DNSVerificationIDContainsFold *string  `json:"dnsVerificationIDContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "mappable_domain" edge predicates.
	HasMappableDomain     *bool                       `json:"hasMappableDomain,omitempty"`
	HasMappableDomainWith []*MappableDomainWhereInput `json:"hasMappableDomainWith,omitempty"`

	// "dns_verification" edge predicates.
	HasDNSVerification     *bool                        `json:"hasDNSVerification,omitempty"`
	HasDNSVerificationWith []*DNSVerificationWhereInput `json:"hasDNSVerificationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CustomDomainWhereInput) AddPredicates(predicates ...predicate.CustomDomain) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CustomDomainWhereInput filter on the CustomDomainQuery builder.
func (i *CustomDomainWhereInput) Filter(q *CustomDomainQuery) (*CustomDomainQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCustomDomainWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCustomDomainWhereInput is returned in case the CustomDomainWhereInput is empty.
var ErrEmptyCustomDomainWhereInput = errors.New("generated: empty predicate CustomDomainWhereInput")

// P returns a predicate for filtering customdomains.
// An error is returned if the input is empty or invalid.
func (i *CustomDomainWhereInput) P() (predicate.CustomDomain, error) {
	var predicates []predicate.CustomDomain
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, customdomain.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CustomDomain, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, customdomain.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CustomDomain, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, customdomain.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, customdomain.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, customdomain.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, customdomain.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, customdomain.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, customdomain.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, customdomain.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, customdomain.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, customdomain.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, customdomain.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, customdomain.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, customdomain.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, customdomain.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, customdomain.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, customdomain.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, customdomain.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, customdomain.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, customdomain.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, customdomain.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, customdomain.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, customdomain.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, customdomain.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, customdomain.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, customdomain.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, customdomain.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, customdomain.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, customdomain.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, customdomain.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, customdomain.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, customdomain.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, customdomain.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, customdomain.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, customdomain.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, customdomain.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, customdomain.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, customdomain.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, customdomain.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, customdomain.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, customdomain.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, customdomain.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, customdomain.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, customdomain.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, customdomain.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, customdomain.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, customdomain.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, customdomain.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, customdomain.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, customdomain.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, customdomain.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, customdomain.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, customdomain.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, customdomain.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, customdomain.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, customdomain.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, customdomain.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, customdomain.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, customdomain.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, customdomain.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, customdomain.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, customdomain.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, customdomain.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, customdomain.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, customdomain.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, customdomain.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, customdomain.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, customdomain.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, customdomain.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, customdomain.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, customdomain.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, customdomain.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, customdomain.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, customdomain.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, customdomain.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, customdomain.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, customdomain.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, customdomain.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.CnameRecord != nil {
		predicates = append(predicates, customdomain.CnameRecordEQ(*i.CnameRecord))
	}
	if i.CnameRecordNEQ != nil {
		predicates = append(predicates, customdomain.CnameRecordNEQ(*i.CnameRecordNEQ))
	}
	if len(i.CnameRecordIn) > 0 {
		predicates = append(predicates, customdomain.CnameRecordIn(i.CnameRecordIn...))
	}
	if len(i.CnameRecordNotIn) > 0 {
		predicates = append(predicates, customdomain.CnameRecordNotIn(i.CnameRecordNotIn...))
	}
	if i.CnameRecordGT != nil {
		predicates = append(predicates, customdomain.CnameRecordGT(*i.CnameRecordGT))
	}
	if i.CnameRecordGTE != nil {
		predicates = append(predicates, customdomain.CnameRecordGTE(*i.CnameRecordGTE))
	}
	if i.CnameRecordLT != nil {
		predicates = append(predicates, customdomain.CnameRecordLT(*i.CnameRecordLT))
	}
	if i.CnameRecordLTE != nil {
		predicates = append(predicates, customdomain.CnameRecordLTE(*i.CnameRecordLTE))
	}
	if i.CnameRecordContains != nil {
		predicates = append(predicates, customdomain.CnameRecordContains(*i.CnameRecordContains))
	}
	if i.CnameRecordHasPrefix != nil {
		predicates = append(predicates, customdomain.CnameRecordHasPrefix(*i.CnameRecordHasPrefix))
	}
	if i.CnameRecordHasSuffix != nil {
		predicates = append(predicates, customdomain.CnameRecordHasSuffix(*i.CnameRecordHasSuffix))
	}
	if i.CnameRecordEqualFold != nil {
		predicates = append(predicates, customdomain.CnameRecordEqualFold(*i.CnameRecordEqualFold))
	}
	if i.CnameRecordContainsFold != nil {
		predicates = append(predicates, customdomain.CnameRecordContainsFold(*i.CnameRecordContainsFold))
	}
	if i.MappableDomainID != nil {
		predicates = append(predicates, customdomain.MappableDomainIDEQ(*i.MappableDomainID))
	}
	if i.MappableDomainIDNEQ != nil {
		predicates = append(predicates, customdomain.MappableDomainIDNEQ(*i.MappableDomainIDNEQ))
	}
	if len(i.MappableDomainIDIn) > 0 {
		predicates = append(predicates, customdomain.MappableDomainIDIn(i.MappableDomainIDIn...))
	}
	if len(i.MappableDomainIDNotIn) > 0 {
		predicates = append(predicates, customdomain.MappableDomainIDNotIn(i.MappableDomainIDNotIn...))
	}
	if i.MappableDomainIDGT != nil {
		predicates = append(predicates, customdomain.MappableDomainIDGT(*i.MappableDomainIDGT))
	}
	if i.MappableDomainIDGTE != nil {
		predicates = append(predicates, customdomain.MappableDomainIDGTE(*i.MappableDomainIDGTE))
	}
	if i.MappableDomainIDLT != nil {
		predicates = append(predicates, customdomain.MappableDomainIDLT(*i.MappableDomainIDLT))
	}
	if i.MappableDomainIDLTE != nil {
		predicates = append(predicates, customdomain.MappableDomainIDLTE(*i.MappableDomainIDLTE))
	}
	if i.MappableDomainIDContains != nil {
		predicates = append(predicates, customdomain.MappableDomainIDContains(*i.MappableDomainIDContains))
	}
	if i.MappableDomainIDHasPrefix != nil {
		predicates = append(predicates, customdomain.MappableDomainIDHasPrefix(*i.MappableDomainIDHasPrefix))
	}
	if i.MappableDomainIDHasSuffix != nil {
		predicates = append(predicates, customdomain.MappableDomainIDHasSuffix(*i.MappableDomainIDHasSuffix))
	}
	if i.MappableDomainIDEqualFold != nil {
		predicates = append(predicates, customdomain.MappableDomainIDEqualFold(*i.MappableDomainIDEqualFold))
	}
	if i.MappableDomainIDContainsFold != nil {
		predicates = append(predicates, customdomain.MappableDomainIDContainsFold(*i.MappableDomainIDContainsFold))
	}
	if i.DNSVerificationID != nil {
		predicates = append(predicates, customdomain.DNSVerificationIDEQ(*i.DNSVerificationID))
	}
	if i.DNSVerificationIDNEQ != nil {
		predicates = append(predicates, customdomain.DNSVerificationIDNEQ(*i.DNSVerificationIDNEQ))
	}
	if len(i.DNSVerificationIDIn) > 0 {
		predicates = append(predicates, customdomain.DNSVerificationIDIn(i.DNSVerificationIDIn...))
	}
	if len(i.DNSVerificationIDNotIn) > 0 {
		predicates = append(predicates, customdomain.DNSVerificationIDNotIn(i.DNSVerificationIDNotIn...))
	}
	if i.DNSVerificationIDGT != nil {
		predicates = append(predicates, customdomain.DNSVerificationIDGT(*i.DNSVerificationIDGT))
	}
	if i.DNSVerificationIDGTE != nil {
		predicates = append(predicates, customdomain.DNSVerificationIDGTE(*i.DNSVerificationIDGTE))
	}
	if i.DNSVerificationIDLT != nil {
		predicates = append(predicates, customdomain.DNSVerificationIDLT(*i.DNSVerificationIDLT))
	}
	if i.DNSVerificationIDLTE != nil {
		predicates = append(predicates, customdomain.DNSVerificationIDLTE(*i.DNSVerificationIDLTE))
	}
	if i.DNSVerificationIDContains != nil {
		predicates = append(predicates, customdomain.DNSVerificationIDContains(*i.DNSVerificationIDContains))
	}
	if i.DNSVerificationIDHasPrefix != nil {
		predicates = append(predicates, customdomain.DNSVerificationIDHasPrefix(*i.DNSVerificationIDHasPrefix))
	}
	if i.DNSVerificationIDHasSuffix != nil {
		predicates = append(predicates, customdomain.DNSVerificationIDHasSuffix(*i.DNSVerificationIDHasSuffix))
	}
	if i.DNSVerificationIDIsNil {
		predicates = append(predicates, customdomain.DNSVerificationIDIsNil())
	}
	if i.DNSVerificationIDNotNil {
		predicates = append(predicates, customdomain.DNSVerificationIDNotNil())
	}
	if i.DNSVerificationIDEqualFold != nil {
		predicates = append(predicates, customdomain.DNSVerificationIDEqualFold(*i.DNSVerificationIDEqualFold))
	}
	if i.DNSVerificationIDContainsFold != nil {
		predicates = append(predicates, customdomain.DNSVerificationIDContainsFold(*i.DNSVerificationIDContainsFold))
	}

	if i.HasOwner != nil {
		p := customdomain.HasOwner()
		if !*i.HasOwner {
			p = customdomain.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customdomain.HasOwnerWith(with...))
	}
	if i.HasMappableDomain != nil {
		p := customdomain.HasMappableDomain()
		if !*i.HasMappableDomain {
			p = customdomain.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMappableDomainWith) > 0 {
		with := make([]predicate.MappableDomain, 0, len(i.HasMappableDomainWith))
		for _, w := range i.HasMappableDomainWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMappableDomainWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customdomain.HasMappableDomainWith(with...))
	}
	if i.HasDNSVerification != nil {
		p := customdomain.HasDNSVerification()
		if !*i.HasDNSVerification {
			p = customdomain.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDNSVerificationWith) > 0 {
		with := make([]predicate.DNSVerification, 0, len(i.HasDNSVerificationWith))
		for _, w := range i.HasDNSVerificationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDNSVerificationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customdomain.HasDNSVerificationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCustomDomainWhereInput
	case 1:
		return predicates[0], nil
	default:
		return customdomain.And(predicates...), nil
	}
}

// CustomDomainHistoryWhereInput represents a where input for filtering CustomDomainHistory queries.
type CustomDomainHistoryWhereInput struct {
	Predicates []predicate.CustomDomainHistory  `json:"-"`
	Not        *CustomDomainHistoryWhereInput   `json:"not,omitempty"`
	Or         []*CustomDomainHistoryWhereInput `json:"or,omitempty"`
	And        []*CustomDomainHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "cname_record" field predicates.
	CnameRecord             *string  `json:"cnameRecord,omitempty"`
	CnameRecordNEQ          *string  `json:"cnameRecordNEQ,omitempty"`
	CnameRecordIn           []string `json:"cnameRecordIn,omitempty"`
	CnameRecordNotIn        []string `json:"cnameRecordNotIn,omitempty"`
	CnameRecordGT           *string  `json:"cnameRecordGT,omitempty"`
	CnameRecordGTE          *string  `json:"cnameRecordGTE,omitempty"`
	CnameRecordLT           *string  `json:"cnameRecordLT,omitempty"`
	CnameRecordLTE          *string  `json:"cnameRecordLTE,omitempty"`
	CnameRecordContains     *string  `json:"cnameRecordContains,omitempty"`
	CnameRecordHasPrefix    *string  `json:"cnameRecordHasPrefix,omitempty"`
	CnameRecordHasSuffix    *string  `json:"cnameRecordHasSuffix,omitempty"`
	CnameRecordEqualFold    *string  `json:"cnameRecordEqualFold,omitempty"`
	CnameRecordContainsFold *string  `json:"cnameRecordContainsFold,omitempty"`

	// "mappable_domain_id" field predicates.
	MappableDomainID             *string  `json:"mappableDomainID,omitempty"`
	MappableDomainIDNEQ          *string  `json:"mappableDomainIDNEQ,omitempty"`
	MappableDomainIDIn           []string `json:"mappableDomainIDIn,omitempty"`
	MappableDomainIDNotIn        []string `json:"mappableDomainIDNotIn,omitempty"`
	MappableDomainIDGT           *string  `json:"mappableDomainIDGT,omitempty"`
	MappableDomainIDGTE          *string  `json:"mappableDomainIDGTE,omitempty"`
	MappableDomainIDLT           *string  `json:"mappableDomainIDLT,omitempty"`
	MappableDomainIDLTE          *string  `json:"mappableDomainIDLTE,omitempty"`
	MappableDomainIDContains     *string  `json:"mappableDomainIDContains,omitempty"`
	MappableDomainIDHasPrefix    *string  `json:"mappableDomainIDHasPrefix,omitempty"`
	MappableDomainIDHasSuffix    *string  `json:"mappableDomainIDHasSuffix,omitempty"`
	MappableDomainIDEqualFold    *string  `json:"mappableDomainIDEqualFold,omitempty"`
	MappableDomainIDContainsFold *string  `json:"mappableDomainIDContainsFold,omitempty"`

	// "dns_verification_id" field predicates.
	DNSVerificationID             *string  `json:"dnsVerificationID,omitempty"`
	DNSVerificationIDNEQ          *string  `json:"dnsVerificationIDNEQ,omitempty"`
	DNSVerificationIDIn           []string `json:"dnsVerificationIDIn,omitempty"`
	DNSVerificationIDNotIn        []string `json:"dnsVerificationIDNotIn,omitempty"`
	DNSVerificationIDGT           *string  `json:"dnsVerificationIDGT,omitempty"`
	DNSVerificationIDGTE          *string  `json:"dnsVerificationIDGTE,omitempty"`
	DNSVerificationIDLT           *string  `json:"dnsVerificationIDLT,omitempty"`
	DNSVerificationIDLTE          *string  `json:"dnsVerificationIDLTE,omitempty"`
	DNSVerificationIDContains     *string  `json:"dnsVerificationIDContains,omitempty"`
	DNSVerificationIDHasPrefix    *string  `json:"dnsVerificationIDHasPrefix,omitempty"`
	DNSVerificationIDHasSuffix    *string  `json:"dnsVerificationIDHasSuffix,omitempty"`
	DNSVerificationIDIsNil        bool     `json:"dnsVerificationIDIsNil,omitempty"`
	DNSVerificationIDNotNil       bool     `json:"dnsVerificationIDNotNil,omitempty"`
	DNSVerificationIDEqualFold    *string  `json:"dnsVerificationIDEqualFold,omitempty"`
	DNSVerificationIDContainsFold *string  `json:"dnsVerificationIDContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CustomDomainHistoryWhereInput) AddPredicates(predicates ...predicate.CustomDomainHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CustomDomainHistoryWhereInput filter on the CustomDomainHistoryQuery builder.
func (i *CustomDomainHistoryWhereInput) Filter(q *CustomDomainHistoryQuery) (*CustomDomainHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCustomDomainHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCustomDomainHistoryWhereInput is returned in case the CustomDomainHistoryWhereInput is empty.
var ErrEmptyCustomDomainHistoryWhereInput = errors.New("generated: empty predicate CustomDomainHistoryWhereInput")

// P returns a predicate for filtering customdomainhistories.
// An error is returned if the input is empty or invalid.
func (i *CustomDomainHistoryWhereInput) P() (predicate.CustomDomainHistory, error) {
	var predicates []predicate.CustomDomainHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, customdomainhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CustomDomainHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, customdomainhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CustomDomainHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, customdomainhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, customdomainhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, customdomainhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, customdomainhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, customdomainhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, customdomainhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, customdomainhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, customdomainhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, customdomainhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, customdomainhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, customdomainhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, customdomainhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, customdomainhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, customdomainhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, customdomainhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, customdomainhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, customdomainhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, customdomainhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, customdomainhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, customdomainhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, customdomainhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, customdomainhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, customdomainhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, customdomainhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, customdomainhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, customdomainhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, customdomainhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, customdomainhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, customdomainhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, customdomainhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, customdomainhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, customdomainhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, customdomainhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, customdomainhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, customdomainhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, customdomainhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, customdomainhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, customdomainhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, customdomainhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, customdomainhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, customdomainhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, customdomainhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, customdomainhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, customdomainhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, customdomainhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, customdomainhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, customdomainhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, customdomainhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, customdomainhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, customdomainhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, customdomainhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, customdomainhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, customdomainhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, customdomainhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, customdomainhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, customdomainhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, customdomainhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, customdomainhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, customdomainhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, customdomainhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, customdomainhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, customdomainhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, customdomainhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, customdomainhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, customdomainhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, customdomainhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, customdomainhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, customdomainhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, customdomainhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, customdomainhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, customdomainhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, customdomainhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, customdomainhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, customdomainhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, customdomainhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, customdomainhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, customdomainhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, customdomainhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, customdomainhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, customdomainhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, customdomainhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, customdomainhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, customdomainhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, customdomainhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, customdomainhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, customdomainhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, customdomainhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, customdomainhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, customdomainhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, customdomainhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, customdomainhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, customdomainhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, customdomainhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, customdomainhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, customdomainhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, customdomainhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, customdomainhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, customdomainhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, customdomainhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, customdomainhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, customdomainhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, customdomainhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, customdomainhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.CnameRecord != nil {
		predicates = append(predicates, customdomainhistory.CnameRecordEQ(*i.CnameRecord))
	}
	if i.CnameRecordNEQ != nil {
		predicates = append(predicates, customdomainhistory.CnameRecordNEQ(*i.CnameRecordNEQ))
	}
	if len(i.CnameRecordIn) > 0 {
		predicates = append(predicates, customdomainhistory.CnameRecordIn(i.CnameRecordIn...))
	}
	if len(i.CnameRecordNotIn) > 0 {
		predicates = append(predicates, customdomainhistory.CnameRecordNotIn(i.CnameRecordNotIn...))
	}
	if i.CnameRecordGT != nil {
		predicates = append(predicates, customdomainhistory.CnameRecordGT(*i.CnameRecordGT))
	}
	if i.CnameRecordGTE != nil {
		predicates = append(predicates, customdomainhistory.CnameRecordGTE(*i.CnameRecordGTE))
	}
	if i.CnameRecordLT != nil {
		predicates = append(predicates, customdomainhistory.CnameRecordLT(*i.CnameRecordLT))
	}
	if i.CnameRecordLTE != nil {
		predicates = append(predicates, customdomainhistory.CnameRecordLTE(*i.CnameRecordLTE))
	}
	if i.CnameRecordContains != nil {
		predicates = append(predicates, customdomainhistory.CnameRecordContains(*i.CnameRecordContains))
	}
	if i.CnameRecordHasPrefix != nil {
		predicates = append(predicates, customdomainhistory.CnameRecordHasPrefix(*i.CnameRecordHasPrefix))
	}
	if i.CnameRecordHasSuffix != nil {
		predicates = append(predicates, customdomainhistory.CnameRecordHasSuffix(*i.CnameRecordHasSuffix))
	}
	if i.CnameRecordEqualFold != nil {
		predicates = append(predicates, customdomainhistory.CnameRecordEqualFold(*i.CnameRecordEqualFold))
	}
	if i.CnameRecordContainsFold != nil {
		predicates = append(predicates, customdomainhistory.CnameRecordContainsFold(*i.CnameRecordContainsFold))
	}
	if i.MappableDomainID != nil {
		predicates = append(predicates, customdomainhistory.MappableDomainIDEQ(*i.MappableDomainID))
	}
	if i.MappableDomainIDNEQ != nil {
		predicates = append(predicates, customdomainhistory.MappableDomainIDNEQ(*i.MappableDomainIDNEQ))
	}
	if len(i.MappableDomainIDIn) > 0 {
		predicates = append(predicates, customdomainhistory.MappableDomainIDIn(i.MappableDomainIDIn...))
	}
	if len(i.MappableDomainIDNotIn) > 0 {
		predicates = append(predicates, customdomainhistory.MappableDomainIDNotIn(i.MappableDomainIDNotIn...))
	}
	if i.MappableDomainIDGT != nil {
		predicates = append(predicates, customdomainhistory.MappableDomainIDGT(*i.MappableDomainIDGT))
	}
	if i.MappableDomainIDGTE != nil {
		predicates = append(predicates, customdomainhistory.MappableDomainIDGTE(*i.MappableDomainIDGTE))
	}
	if i.MappableDomainIDLT != nil {
		predicates = append(predicates, customdomainhistory.MappableDomainIDLT(*i.MappableDomainIDLT))
	}
	if i.MappableDomainIDLTE != nil {
		predicates = append(predicates, customdomainhistory.MappableDomainIDLTE(*i.MappableDomainIDLTE))
	}
	if i.MappableDomainIDContains != nil {
		predicates = append(predicates, customdomainhistory.MappableDomainIDContains(*i.MappableDomainIDContains))
	}
	if i.MappableDomainIDHasPrefix != nil {
		predicates = append(predicates, customdomainhistory.MappableDomainIDHasPrefix(*i.MappableDomainIDHasPrefix))
	}
	if i.MappableDomainIDHasSuffix != nil {
		predicates = append(predicates, customdomainhistory.MappableDomainIDHasSuffix(*i.MappableDomainIDHasSuffix))
	}
	if i.MappableDomainIDEqualFold != nil {
		predicates = append(predicates, customdomainhistory.MappableDomainIDEqualFold(*i.MappableDomainIDEqualFold))
	}
	if i.MappableDomainIDContainsFold != nil {
		predicates = append(predicates, customdomainhistory.MappableDomainIDContainsFold(*i.MappableDomainIDContainsFold))
	}
	if i.DNSVerificationID != nil {
		predicates = append(predicates, customdomainhistory.DNSVerificationIDEQ(*i.DNSVerificationID))
	}
	if i.DNSVerificationIDNEQ != nil {
		predicates = append(predicates, customdomainhistory.DNSVerificationIDNEQ(*i.DNSVerificationIDNEQ))
	}
	if len(i.DNSVerificationIDIn) > 0 {
		predicates = append(predicates, customdomainhistory.DNSVerificationIDIn(i.DNSVerificationIDIn...))
	}
	if len(i.DNSVerificationIDNotIn) > 0 {
		predicates = append(predicates, customdomainhistory.DNSVerificationIDNotIn(i.DNSVerificationIDNotIn...))
	}
	if i.DNSVerificationIDGT != nil {
		predicates = append(predicates, customdomainhistory.DNSVerificationIDGT(*i.DNSVerificationIDGT))
	}
	if i.DNSVerificationIDGTE != nil {
		predicates = append(predicates, customdomainhistory.DNSVerificationIDGTE(*i.DNSVerificationIDGTE))
	}
	if i.DNSVerificationIDLT != nil {
		predicates = append(predicates, customdomainhistory.DNSVerificationIDLT(*i.DNSVerificationIDLT))
	}
	if i.DNSVerificationIDLTE != nil {
		predicates = append(predicates, customdomainhistory.DNSVerificationIDLTE(*i.DNSVerificationIDLTE))
	}
	if i.DNSVerificationIDContains != nil {
		predicates = append(predicates, customdomainhistory.DNSVerificationIDContains(*i.DNSVerificationIDContains))
	}
	if i.DNSVerificationIDHasPrefix != nil {
		predicates = append(predicates, customdomainhistory.DNSVerificationIDHasPrefix(*i.DNSVerificationIDHasPrefix))
	}
	if i.DNSVerificationIDHasSuffix != nil {
		predicates = append(predicates, customdomainhistory.DNSVerificationIDHasSuffix(*i.DNSVerificationIDHasSuffix))
	}
	if i.DNSVerificationIDIsNil {
		predicates = append(predicates, customdomainhistory.DNSVerificationIDIsNil())
	}
	if i.DNSVerificationIDNotNil {
		predicates = append(predicates, customdomainhistory.DNSVerificationIDNotNil())
	}
	if i.DNSVerificationIDEqualFold != nil {
		predicates = append(predicates, customdomainhistory.DNSVerificationIDEqualFold(*i.DNSVerificationIDEqualFold))
	}
	if i.DNSVerificationIDContainsFold != nil {
		predicates = append(predicates, customdomainhistory.DNSVerificationIDContainsFold(*i.DNSVerificationIDContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCustomDomainHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return customdomainhistory.And(predicates...), nil
	}
}

// DNSVerificationWhereInput represents a where input for filtering DNSVerification queries.
type DNSVerificationWhereInput struct {
	Predicates []predicate.DNSVerification  `json:"-"`
	Not        *DNSVerificationWhereInput   `json:"not,omitempty"`
	Or         []*DNSVerificationWhereInput `json:"or,omitempty"`
	And        []*DNSVerificationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "cloudflare_hostname_id" field predicates.
	CloudflareHostnameID             *string  `json:"cloudflareHostnameID,omitempty"`
	CloudflareHostnameIDNEQ          *string  `json:"cloudflareHostnameIDNEQ,omitempty"`
	CloudflareHostnameIDIn           []string `json:"cloudflareHostnameIDIn,omitempty"`
	CloudflareHostnameIDNotIn        []string `json:"cloudflareHostnameIDNotIn,omitempty"`
	CloudflareHostnameIDGT           *string  `json:"cloudflareHostnameIDGT,omitempty"`
	CloudflareHostnameIDGTE          *string  `json:"cloudflareHostnameIDGTE,omitempty"`
	CloudflareHostnameIDLT           *string  `json:"cloudflareHostnameIDLT,omitempty"`
	CloudflareHostnameIDLTE          *string  `json:"cloudflareHostnameIDLTE,omitempty"`
	CloudflareHostnameIDContains     *string  `json:"cloudflareHostnameIDContains,omitempty"`
	CloudflareHostnameIDHasPrefix    *string  `json:"cloudflareHostnameIDHasPrefix,omitempty"`
	CloudflareHostnameIDHasSuffix    *string  `json:"cloudflareHostnameIDHasSuffix,omitempty"`
	CloudflareHostnameIDEqualFold    *string  `json:"cloudflareHostnameIDEqualFold,omitempty"`
	CloudflareHostnameIDContainsFold *string  `json:"cloudflareHostnameIDContainsFold,omitempty"`

	// "dns_txt_record" field predicates.
	DNSTxtRecord             *string  `json:"dnsTxtRecord,omitempty"`
	DNSTxtRecordNEQ          *string  `json:"dnsTxtRecordNEQ,omitempty"`
	DNSTxtRecordIn           []string `json:"dnsTxtRecordIn,omitempty"`
	DNSTxtRecordNotIn        []string `json:"dnsTxtRecordNotIn,omitempty"`
	DNSTxtRecordGT           *string  `json:"dnsTxtRecordGT,omitempty"`
	DNSTxtRecordGTE          *string  `json:"dnsTxtRecordGTE,omitempty"`
	DNSTxtRecordLT           *string  `json:"dnsTxtRecordLT,omitempty"`
	DNSTxtRecordLTE          *string  `json:"dnsTxtRecordLTE,omitempty"`
	DNSTxtRecordContains     *string  `json:"dnsTxtRecordContains,omitempty"`
	DNSTxtRecordHasPrefix    *string  `json:"dnsTxtRecordHasPrefix,omitempty"`
	DNSTxtRecordHasSuffix    *string  `json:"dnsTxtRecordHasSuffix,omitempty"`
	DNSTxtRecordEqualFold    *string  `json:"dnsTxtRecordEqualFold,omitempty"`
	DNSTxtRecordContainsFold *string  `json:"dnsTxtRecordContainsFold,omitempty"`

	// "dns_txt_value" field predicates.
	DNSTxtValue             *string  `json:"dnsTxtValue,omitempty"`
	DNSTxtValueNEQ          *string  `json:"dnsTxtValueNEQ,omitempty"`
	DNSTxtValueIn           []string `json:"dnsTxtValueIn,omitempty"`
	DNSTxtValueNotIn        []string `json:"dnsTxtValueNotIn,omitempty"`
	DNSTxtValueGT           *string  `json:"dnsTxtValueGT,omitempty"`
	DNSTxtValueGTE          *string  `json:"dnsTxtValueGTE,omitempty"`
	DNSTxtValueLT           *string  `json:"dnsTxtValueLT,omitempty"`
	DNSTxtValueLTE          *string  `json:"dnsTxtValueLTE,omitempty"`
	DNSTxtValueContains     *string  `json:"dnsTxtValueContains,omitempty"`
	DNSTxtValueHasPrefix    *string  `json:"dnsTxtValueHasPrefix,omitempty"`
	DNSTxtValueHasSuffix    *string  `json:"dnsTxtValueHasSuffix,omitempty"`
	DNSTxtValueEqualFold    *string  `json:"dnsTxtValueEqualFold,omitempty"`
	DNSTxtValueContainsFold *string  `json:"dnsTxtValueContainsFold,omitempty"`

	// "dns_verification_status" field predicates.
	DNSVerificationStatus      *enums.DNSVerificationStatus  `json:"dnsVerificationStatus,omitempty"`
	DNSVerificationStatusNEQ   *enums.DNSVerificationStatus  `json:"dnsVerificationStatusNEQ,omitempty"`
	DNSVerificationStatusIn    []enums.DNSVerificationStatus `json:"dnsVerificationStatusIn,omitempty"`
	DNSVerificationStatusNotIn []enums.DNSVerificationStatus `json:"dnsVerificationStatusNotIn,omitempty"`

	// "dns_verification_status_reason" field predicates.
	DNSVerificationStatusReason             *string  `json:"dnsVerificationStatusReason,omitempty"`
	DNSVerificationStatusReasonNEQ          *string  `json:"dnsVerificationStatusReasonNEQ,omitempty"`
	DNSVerificationStatusReasonIn           []string `json:"dnsVerificationStatusReasonIn,omitempty"`
	DNSVerificationStatusReasonNotIn        []string `json:"dnsVerificationStatusReasonNotIn,omitempty"`
	DNSVerificationStatusReasonGT           *string  `json:"dnsVerificationStatusReasonGT,omitempty"`
	DNSVerificationStatusReasonGTE          *string  `json:"dnsVerificationStatusReasonGTE,omitempty"`
	DNSVerificationStatusReasonLT           *string  `json:"dnsVerificationStatusReasonLT,omitempty"`
	DNSVerificationStatusReasonLTE          *string  `json:"dnsVerificationStatusReasonLTE,omitempty"`
	DNSVerificationStatusReasonContains     *string  `json:"dnsVerificationStatusReasonContains,omitempty"`
	DNSVerificationStatusReasonHasPrefix    *string  `json:"dnsVerificationStatusReasonHasPrefix,omitempty"`
	DNSVerificationStatusReasonHasSuffix    *string  `json:"dnsVerificationStatusReasonHasSuffix,omitempty"`
	DNSVerificationStatusReasonIsNil        bool     `json:"dnsVerificationStatusReasonIsNil,omitempty"`
	DNSVerificationStatusReasonNotNil       bool     `json:"dnsVerificationStatusReasonNotNil,omitempty"`
	DNSVerificationStatusReasonEqualFold    *string  `json:"dnsVerificationStatusReasonEqualFold,omitempty"`
	DNSVerificationStatusReasonContainsFold *string  `json:"dnsVerificationStatusReasonContainsFold,omitempty"`

	// "acme_challenge_path" field predicates.
	AcmeChallengePath             *string  `json:"acmeChallengePath,omitempty"`
	AcmeChallengePathNEQ          *string  `json:"acmeChallengePathNEQ,omitempty"`
	AcmeChallengePathIn           []string `json:"acmeChallengePathIn,omitempty"`
	AcmeChallengePathNotIn        []string `json:"acmeChallengePathNotIn,omitempty"`
	AcmeChallengePathGT           *string  `json:"acmeChallengePathGT,omitempty"`
	AcmeChallengePathGTE          *string  `json:"acmeChallengePathGTE,omitempty"`
	AcmeChallengePathLT           *string  `json:"acmeChallengePathLT,omitempty"`
	AcmeChallengePathLTE          *string  `json:"acmeChallengePathLTE,omitempty"`
	AcmeChallengePathContains     *string  `json:"acmeChallengePathContains,omitempty"`
	AcmeChallengePathHasPrefix    *string  `json:"acmeChallengePathHasPrefix,omitempty"`
	AcmeChallengePathHasSuffix    *string  `json:"acmeChallengePathHasSuffix,omitempty"`
	AcmeChallengePathIsNil        bool     `json:"acmeChallengePathIsNil,omitempty"`
	AcmeChallengePathNotNil       bool     `json:"acmeChallengePathNotNil,omitempty"`
	AcmeChallengePathEqualFold    *string  `json:"acmeChallengePathEqualFold,omitempty"`
	AcmeChallengePathContainsFold *string  `json:"acmeChallengePathContainsFold,omitempty"`

	// "expected_acme_challenge_value" field predicates.
	ExpectedAcmeChallengeValue             *string  `json:"expectedAcmeChallengeValue,omitempty"`
	ExpectedAcmeChallengeValueNEQ          *string  `json:"expectedAcmeChallengeValueNEQ,omitempty"`
	ExpectedAcmeChallengeValueIn           []string `json:"expectedAcmeChallengeValueIn,omitempty"`
	ExpectedAcmeChallengeValueNotIn        []string `json:"expectedAcmeChallengeValueNotIn,omitempty"`
	ExpectedAcmeChallengeValueGT           *string  `json:"expectedAcmeChallengeValueGT,omitempty"`
	ExpectedAcmeChallengeValueGTE          *string  `json:"expectedAcmeChallengeValueGTE,omitempty"`
	ExpectedAcmeChallengeValueLT           *string  `json:"expectedAcmeChallengeValueLT,omitempty"`
	ExpectedAcmeChallengeValueLTE          *string  `json:"expectedAcmeChallengeValueLTE,omitempty"`
	ExpectedAcmeChallengeValueContains     *string  `json:"expectedAcmeChallengeValueContains,omitempty"`
	ExpectedAcmeChallengeValueHasPrefix    *string  `json:"expectedAcmeChallengeValueHasPrefix,omitempty"`
	ExpectedAcmeChallengeValueHasSuffix    *string  `json:"expectedAcmeChallengeValueHasSuffix,omitempty"`
	ExpectedAcmeChallengeValueIsNil        bool     `json:"expectedAcmeChallengeValueIsNil,omitempty"`
	ExpectedAcmeChallengeValueNotNil       bool     `json:"expectedAcmeChallengeValueNotNil,omitempty"`
	ExpectedAcmeChallengeValueEqualFold    *string  `json:"expectedAcmeChallengeValueEqualFold,omitempty"`
	ExpectedAcmeChallengeValueContainsFold *string  `json:"expectedAcmeChallengeValueContainsFold,omitempty"`

	// "acme_challenge_status" field predicates.
	AcmeChallengeStatus      *enums.SSLVerificationStatus  `json:"acmeChallengeStatus,omitempty"`
	AcmeChallengeStatusNEQ   *enums.SSLVerificationStatus  `json:"acmeChallengeStatusNEQ,omitempty"`
	AcmeChallengeStatusIn    []enums.SSLVerificationStatus `json:"acmeChallengeStatusIn,omitempty"`
	AcmeChallengeStatusNotIn []enums.SSLVerificationStatus `json:"acmeChallengeStatusNotIn,omitempty"`

	// "acme_challenge_status_reason" field predicates.
	AcmeChallengeStatusReason             *string  `json:"acmeChallengeStatusReason,omitempty"`
	AcmeChallengeStatusReasonNEQ          *string  `json:"acmeChallengeStatusReasonNEQ,omitempty"`
	AcmeChallengeStatusReasonIn           []string `json:"acmeChallengeStatusReasonIn,omitempty"`
	AcmeChallengeStatusReasonNotIn        []string `json:"acmeChallengeStatusReasonNotIn,omitempty"`
	AcmeChallengeStatusReasonGT           *string  `json:"acmeChallengeStatusReasonGT,omitempty"`
	AcmeChallengeStatusReasonGTE          *string  `json:"acmeChallengeStatusReasonGTE,omitempty"`
	AcmeChallengeStatusReasonLT           *string  `json:"acmeChallengeStatusReasonLT,omitempty"`
	AcmeChallengeStatusReasonLTE          *string  `json:"acmeChallengeStatusReasonLTE,omitempty"`
	AcmeChallengeStatusReasonContains     *string  `json:"acmeChallengeStatusReasonContains,omitempty"`
	AcmeChallengeStatusReasonHasPrefix    *string  `json:"acmeChallengeStatusReasonHasPrefix,omitempty"`
	AcmeChallengeStatusReasonHasSuffix    *string  `json:"acmeChallengeStatusReasonHasSuffix,omitempty"`
	AcmeChallengeStatusReasonIsNil        bool     `json:"acmeChallengeStatusReasonIsNil,omitempty"`
	AcmeChallengeStatusReasonNotNil       bool     `json:"acmeChallengeStatusReasonNotNil,omitempty"`
	AcmeChallengeStatusReasonEqualFold    *string  `json:"acmeChallengeStatusReasonEqualFold,omitempty"`
	AcmeChallengeStatusReasonContainsFold *string  `json:"acmeChallengeStatusReasonContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "custom_domains" edge predicates.
	HasCustomDomains     *bool                     `json:"hasCustomDomains,omitempty"`
	HasCustomDomainsWith []*CustomDomainWhereInput `json:"hasCustomDomainsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DNSVerificationWhereInput) AddPredicates(predicates ...predicate.DNSVerification) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DNSVerificationWhereInput filter on the DNSVerificationQuery builder.
func (i *DNSVerificationWhereInput) Filter(q *DNSVerificationQuery) (*DNSVerificationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDNSVerificationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDNSVerificationWhereInput is returned in case the DNSVerificationWhereInput is empty.
var ErrEmptyDNSVerificationWhereInput = errors.New("generated: empty predicate DNSVerificationWhereInput")

// P returns a predicate for filtering dnsverifications.
// An error is returned if the input is empty or invalid.
func (i *DNSVerificationWhereInput) P() (predicate.DNSVerification, error) {
	var predicates []predicate.DNSVerification
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, dnsverification.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DNSVerification, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, dnsverification.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DNSVerification, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, dnsverification.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, dnsverification.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dnsverification.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dnsverification.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dnsverification.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dnsverification.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dnsverification.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dnsverification.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dnsverification.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, dnsverification.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, dnsverification.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, dnsverification.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, dnsverification.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, dnsverification.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, dnsverification.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, dnsverification.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, dnsverification.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, dnsverification.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, dnsverification.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, dnsverification.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, dnsverification.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, dnsverification.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, dnsverification.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, dnsverification.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, dnsverification.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, dnsverification.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, dnsverification.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, dnsverification.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, dnsverification.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, dnsverification.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, dnsverification.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, dnsverification.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, dnsverification.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, dnsverification.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, dnsverification.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, dnsverification.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, dnsverification.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, dnsverification.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, dnsverification.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, dnsverification.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, dnsverification.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, dnsverification.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, dnsverification.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, dnsverification.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, dnsverification.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, dnsverification.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, dnsverification.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, dnsverification.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, dnsverification.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, dnsverification.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, dnsverification.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, dnsverification.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, dnsverification.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, dnsverification.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, dnsverification.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, dnsverification.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, dnsverification.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, dnsverification.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, dnsverification.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, dnsverification.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, dnsverification.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, dnsverification.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, dnsverification.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, dnsverification.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, dnsverification.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, dnsverification.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, dnsverification.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, dnsverification.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, dnsverification.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, dnsverification.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, dnsverification.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, dnsverification.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, dnsverification.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, dnsverification.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, dnsverification.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, dnsverification.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.CloudflareHostnameID != nil {
		predicates = append(predicates, dnsverification.CloudflareHostnameIDEQ(*i.CloudflareHostnameID))
	}
	if i.CloudflareHostnameIDNEQ != nil {
		predicates = append(predicates, dnsverification.CloudflareHostnameIDNEQ(*i.CloudflareHostnameIDNEQ))
	}
	if len(i.CloudflareHostnameIDIn) > 0 {
		predicates = append(predicates, dnsverification.CloudflareHostnameIDIn(i.CloudflareHostnameIDIn...))
	}
	if len(i.CloudflareHostnameIDNotIn) > 0 {
		predicates = append(predicates, dnsverification.CloudflareHostnameIDNotIn(i.CloudflareHostnameIDNotIn...))
	}
	if i.CloudflareHostnameIDGT != nil {
		predicates = append(predicates, dnsverification.CloudflareHostnameIDGT(*i.CloudflareHostnameIDGT))
	}
	if i.CloudflareHostnameIDGTE != nil {
		predicates = append(predicates, dnsverification.CloudflareHostnameIDGTE(*i.CloudflareHostnameIDGTE))
	}
	if i.CloudflareHostnameIDLT != nil {
		predicates = append(predicates, dnsverification.CloudflareHostnameIDLT(*i.CloudflareHostnameIDLT))
	}
	if i.CloudflareHostnameIDLTE != nil {
		predicates = append(predicates, dnsverification.CloudflareHostnameIDLTE(*i.CloudflareHostnameIDLTE))
	}
	if i.CloudflareHostnameIDContains != nil {
		predicates = append(predicates, dnsverification.CloudflareHostnameIDContains(*i.CloudflareHostnameIDContains))
	}
	if i.CloudflareHostnameIDHasPrefix != nil {
		predicates = append(predicates, dnsverification.CloudflareHostnameIDHasPrefix(*i.CloudflareHostnameIDHasPrefix))
	}
	if i.CloudflareHostnameIDHasSuffix != nil {
		predicates = append(predicates, dnsverification.CloudflareHostnameIDHasSuffix(*i.CloudflareHostnameIDHasSuffix))
	}
	if i.CloudflareHostnameIDEqualFold != nil {
		predicates = append(predicates, dnsverification.CloudflareHostnameIDEqualFold(*i.CloudflareHostnameIDEqualFold))
	}
	if i.CloudflareHostnameIDContainsFold != nil {
		predicates = append(predicates, dnsverification.CloudflareHostnameIDContainsFold(*i.CloudflareHostnameIDContainsFold))
	}
	if i.DNSTxtRecord != nil {
		predicates = append(predicates, dnsverification.DNSTxtRecordEQ(*i.DNSTxtRecord))
	}
	if i.DNSTxtRecordNEQ != nil {
		predicates = append(predicates, dnsverification.DNSTxtRecordNEQ(*i.DNSTxtRecordNEQ))
	}
	if len(i.DNSTxtRecordIn) > 0 {
		predicates = append(predicates, dnsverification.DNSTxtRecordIn(i.DNSTxtRecordIn...))
	}
	if len(i.DNSTxtRecordNotIn) > 0 {
		predicates = append(predicates, dnsverification.DNSTxtRecordNotIn(i.DNSTxtRecordNotIn...))
	}
	if i.DNSTxtRecordGT != nil {
		predicates = append(predicates, dnsverification.DNSTxtRecordGT(*i.DNSTxtRecordGT))
	}
	if i.DNSTxtRecordGTE != nil {
		predicates = append(predicates, dnsverification.DNSTxtRecordGTE(*i.DNSTxtRecordGTE))
	}
	if i.DNSTxtRecordLT != nil {
		predicates = append(predicates, dnsverification.DNSTxtRecordLT(*i.DNSTxtRecordLT))
	}
	if i.DNSTxtRecordLTE != nil {
		predicates = append(predicates, dnsverification.DNSTxtRecordLTE(*i.DNSTxtRecordLTE))
	}
	if i.DNSTxtRecordContains != nil {
		predicates = append(predicates, dnsverification.DNSTxtRecordContains(*i.DNSTxtRecordContains))
	}
	if i.DNSTxtRecordHasPrefix != nil {
		predicates = append(predicates, dnsverification.DNSTxtRecordHasPrefix(*i.DNSTxtRecordHasPrefix))
	}
	if i.DNSTxtRecordHasSuffix != nil {
		predicates = append(predicates, dnsverification.DNSTxtRecordHasSuffix(*i.DNSTxtRecordHasSuffix))
	}
	if i.DNSTxtRecordEqualFold != nil {
		predicates = append(predicates, dnsverification.DNSTxtRecordEqualFold(*i.DNSTxtRecordEqualFold))
	}
	if i.DNSTxtRecordContainsFold != nil {
		predicates = append(predicates, dnsverification.DNSTxtRecordContainsFold(*i.DNSTxtRecordContainsFold))
	}
	if i.DNSTxtValue != nil {
		predicates = append(predicates, dnsverification.DNSTxtValueEQ(*i.DNSTxtValue))
	}
	if i.DNSTxtValueNEQ != nil {
		predicates = append(predicates, dnsverification.DNSTxtValueNEQ(*i.DNSTxtValueNEQ))
	}
	if len(i.DNSTxtValueIn) > 0 {
		predicates = append(predicates, dnsverification.DNSTxtValueIn(i.DNSTxtValueIn...))
	}
	if len(i.DNSTxtValueNotIn) > 0 {
		predicates = append(predicates, dnsverification.DNSTxtValueNotIn(i.DNSTxtValueNotIn...))
	}
	if i.DNSTxtValueGT != nil {
		predicates = append(predicates, dnsverification.DNSTxtValueGT(*i.DNSTxtValueGT))
	}
	if i.DNSTxtValueGTE != nil {
		predicates = append(predicates, dnsverification.DNSTxtValueGTE(*i.DNSTxtValueGTE))
	}
	if i.DNSTxtValueLT != nil {
		predicates = append(predicates, dnsverification.DNSTxtValueLT(*i.DNSTxtValueLT))
	}
	if i.DNSTxtValueLTE != nil {
		predicates = append(predicates, dnsverification.DNSTxtValueLTE(*i.DNSTxtValueLTE))
	}
	if i.DNSTxtValueContains != nil {
		predicates = append(predicates, dnsverification.DNSTxtValueContains(*i.DNSTxtValueContains))
	}
	if i.DNSTxtValueHasPrefix != nil {
		predicates = append(predicates, dnsverification.DNSTxtValueHasPrefix(*i.DNSTxtValueHasPrefix))
	}
	if i.DNSTxtValueHasSuffix != nil {
		predicates = append(predicates, dnsverification.DNSTxtValueHasSuffix(*i.DNSTxtValueHasSuffix))
	}
	if i.DNSTxtValueEqualFold != nil {
		predicates = append(predicates, dnsverification.DNSTxtValueEqualFold(*i.DNSTxtValueEqualFold))
	}
	if i.DNSTxtValueContainsFold != nil {
		predicates = append(predicates, dnsverification.DNSTxtValueContainsFold(*i.DNSTxtValueContainsFold))
	}
	if i.DNSVerificationStatus != nil {
		predicates = append(predicates, dnsverification.DNSVerificationStatusEQ(*i.DNSVerificationStatus))
	}
	if i.DNSVerificationStatusNEQ != nil {
		predicates = append(predicates, dnsverification.DNSVerificationStatusNEQ(*i.DNSVerificationStatusNEQ))
	}
	if len(i.DNSVerificationStatusIn) > 0 {
		predicates = append(predicates, dnsverification.DNSVerificationStatusIn(i.DNSVerificationStatusIn...))
	}
	if len(i.DNSVerificationStatusNotIn) > 0 {
		predicates = append(predicates, dnsverification.DNSVerificationStatusNotIn(i.DNSVerificationStatusNotIn...))
	}
	if i.DNSVerificationStatusReason != nil {
		predicates = append(predicates, dnsverification.DNSVerificationStatusReasonEQ(*i.DNSVerificationStatusReason))
	}
	if i.DNSVerificationStatusReasonNEQ != nil {
		predicates = append(predicates, dnsverification.DNSVerificationStatusReasonNEQ(*i.DNSVerificationStatusReasonNEQ))
	}
	if len(i.DNSVerificationStatusReasonIn) > 0 {
		predicates = append(predicates, dnsverification.DNSVerificationStatusReasonIn(i.DNSVerificationStatusReasonIn...))
	}
	if len(i.DNSVerificationStatusReasonNotIn) > 0 {
		predicates = append(predicates, dnsverification.DNSVerificationStatusReasonNotIn(i.DNSVerificationStatusReasonNotIn...))
	}
	if i.DNSVerificationStatusReasonGT != nil {
		predicates = append(predicates, dnsverification.DNSVerificationStatusReasonGT(*i.DNSVerificationStatusReasonGT))
	}
	if i.DNSVerificationStatusReasonGTE != nil {
		predicates = append(predicates, dnsverification.DNSVerificationStatusReasonGTE(*i.DNSVerificationStatusReasonGTE))
	}
	if i.DNSVerificationStatusReasonLT != nil {
		predicates = append(predicates, dnsverification.DNSVerificationStatusReasonLT(*i.DNSVerificationStatusReasonLT))
	}
	if i.DNSVerificationStatusReasonLTE != nil {
		predicates = append(predicates, dnsverification.DNSVerificationStatusReasonLTE(*i.DNSVerificationStatusReasonLTE))
	}
	if i.DNSVerificationStatusReasonContains != nil {
		predicates = append(predicates, dnsverification.DNSVerificationStatusReasonContains(*i.DNSVerificationStatusReasonContains))
	}
	if i.DNSVerificationStatusReasonHasPrefix != nil {
		predicates = append(predicates, dnsverification.DNSVerificationStatusReasonHasPrefix(*i.DNSVerificationStatusReasonHasPrefix))
	}
	if i.DNSVerificationStatusReasonHasSuffix != nil {
		predicates = append(predicates, dnsverification.DNSVerificationStatusReasonHasSuffix(*i.DNSVerificationStatusReasonHasSuffix))
	}
	if i.DNSVerificationStatusReasonIsNil {
		predicates = append(predicates, dnsverification.DNSVerificationStatusReasonIsNil())
	}
	if i.DNSVerificationStatusReasonNotNil {
		predicates = append(predicates, dnsverification.DNSVerificationStatusReasonNotNil())
	}
	if i.DNSVerificationStatusReasonEqualFold != nil {
		predicates = append(predicates, dnsverification.DNSVerificationStatusReasonEqualFold(*i.DNSVerificationStatusReasonEqualFold))
	}
	if i.DNSVerificationStatusReasonContainsFold != nil {
		predicates = append(predicates, dnsverification.DNSVerificationStatusReasonContainsFold(*i.DNSVerificationStatusReasonContainsFold))
	}
	if i.AcmeChallengePath != nil {
		predicates = append(predicates, dnsverification.AcmeChallengePathEQ(*i.AcmeChallengePath))
	}
	if i.AcmeChallengePathNEQ != nil {
		predicates = append(predicates, dnsverification.AcmeChallengePathNEQ(*i.AcmeChallengePathNEQ))
	}
	if len(i.AcmeChallengePathIn) > 0 {
		predicates = append(predicates, dnsverification.AcmeChallengePathIn(i.AcmeChallengePathIn...))
	}
	if len(i.AcmeChallengePathNotIn) > 0 {
		predicates = append(predicates, dnsverification.AcmeChallengePathNotIn(i.AcmeChallengePathNotIn...))
	}
	if i.AcmeChallengePathGT != nil {
		predicates = append(predicates, dnsverification.AcmeChallengePathGT(*i.AcmeChallengePathGT))
	}
	if i.AcmeChallengePathGTE != nil {
		predicates = append(predicates, dnsverification.AcmeChallengePathGTE(*i.AcmeChallengePathGTE))
	}
	if i.AcmeChallengePathLT != nil {
		predicates = append(predicates, dnsverification.AcmeChallengePathLT(*i.AcmeChallengePathLT))
	}
	if i.AcmeChallengePathLTE != nil {
		predicates = append(predicates, dnsverification.AcmeChallengePathLTE(*i.AcmeChallengePathLTE))
	}
	if i.AcmeChallengePathContains != nil {
		predicates = append(predicates, dnsverification.AcmeChallengePathContains(*i.AcmeChallengePathContains))
	}
	if i.AcmeChallengePathHasPrefix != nil {
		predicates = append(predicates, dnsverification.AcmeChallengePathHasPrefix(*i.AcmeChallengePathHasPrefix))
	}
	if i.AcmeChallengePathHasSuffix != nil {
		predicates = append(predicates, dnsverification.AcmeChallengePathHasSuffix(*i.AcmeChallengePathHasSuffix))
	}
	if i.AcmeChallengePathIsNil {
		predicates = append(predicates, dnsverification.AcmeChallengePathIsNil())
	}
	if i.AcmeChallengePathNotNil {
		predicates = append(predicates, dnsverification.AcmeChallengePathNotNil())
	}
	if i.AcmeChallengePathEqualFold != nil {
		predicates = append(predicates, dnsverification.AcmeChallengePathEqualFold(*i.AcmeChallengePathEqualFold))
	}
	if i.AcmeChallengePathContainsFold != nil {
		predicates = append(predicates, dnsverification.AcmeChallengePathContainsFold(*i.AcmeChallengePathContainsFold))
	}
	if i.ExpectedAcmeChallengeValue != nil {
		predicates = append(predicates, dnsverification.ExpectedAcmeChallengeValueEQ(*i.ExpectedAcmeChallengeValue))
	}
	if i.ExpectedAcmeChallengeValueNEQ != nil {
		predicates = append(predicates, dnsverification.ExpectedAcmeChallengeValueNEQ(*i.ExpectedAcmeChallengeValueNEQ))
	}
	if len(i.ExpectedAcmeChallengeValueIn) > 0 {
		predicates = append(predicates, dnsverification.ExpectedAcmeChallengeValueIn(i.ExpectedAcmeChallengeValueIn...))
	}
	if len(i.ExpectedAcmeChallengeValueNotIn) > 0 {
		predicates = append(predicates, dnsverification.ExpectedAcmeChallengeValueNotIn(i.ExpectedAcmeChallengeValueNotIn...))
	}
	if i.ExpectedAcmeChallengeValueGT != nil {
		predicates = append(predicates, dnsverification.ExpectedAcmeChallengeValueGT(*i.ExpectedAcmeChallengeValueGT))
	}
	if i.ExpectedAcmeChallengeValueGTE != nil {
		predicates = append(predicates, dnsverification.ExpectedAcmeChallengeValueGTE(*i.ExpectedAcmeChallengeValueGTE))
	}
	if i.ExpectedAcmeChallengeValueLT != nil {
		predicates = append(predicates, dnsverification.ExpectedAcmeChallengeValueLT(*i.ExpectedAcmeChallengeValueLT))
	}
	if i.ExpectedAcmeChallengeValueLTE != nil {
		predicates = append(predicates, dnsverification.ExpectedAcmeChallengeValueLTE(*i.ExpectedAcmeChallengeValueLTE))
	}
	if i.ExpectedAcmeChallengeValueContains != nil {
		predicates = append(predicates, dnsverification.ExpectedAcmeChallengeValueContains(*i.ExpectedAcmeChallengeValueContains))
	}
	if i.ExpectedAcmeChallengeValueHasPrefix != nil {
		predicates = append(predicates, dnsverification.ExpectedAcmeChallengeValueHasPrefix(*i.ExpectedAcmeChallengeValueHasPrefix))
	}
	if i.ExpectedAcmeChallengeValueHasSuffix != nil {
		predicates = append(predicates, dnsverification.ExpectedAcmeChallengeValueHasSuffix(*i.ExpectedAcmeChallengeValueHasSuffix))
	}
	if i.ExpectedAcmeChallengeValueIsNil {
		predicates = append(predicates, dnsverification.ExpectedAcmeChallengeValueIsNil())
	}
	if i.ExpectedAcmeChallengeValueNotNil {
		predicates = append(predicates, dnsverification.ExpectedAcmeChallengeValueNotNil())
	}
	if i.ExpectedAcmeChallengeValueEqualFold != nil {
		predicates = append(predicates, dnsverification.ExpectedAcmeChallengeValueEqualFold(*i.ExpectedAcmeChallengeValueEqualFold))
	}
	if i.ExpectedAcmeChallengeValueContainsFold != nil {
		predicates = append(predicates, dnsverification.ExpectedAcmeChallengeValueContainsFold(*i.ExpectedAcmeChallengeValueContainsFold))
	}
	if i.AcmeChallengeStatus != nil {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusEQ(*i.AcmeChallengeStatus))
	}
	if i.AcmeChallengeStatusNEQ != nil {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusNEQ(*i.AcmeChallengeStatusNEQ))
	}
	if len(i.AcmeChallengeStatusIn) > 0 {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusIn(i.AcmeChallengeStatusIn...))
	}
	if len(i.AcmeChallengeStatusNotIn) > 0 {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusNotIn(i.AcmeChallengeStatusNotIn...))
	}
	if i.AcmeChallengeStatusReason != nil {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusReasonEQ(*i.AcmeChallengeStatusReason))
	}
	if i.AcmeChallengeStatusReasonNEQ != nil {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusReasonNEQ(*i.AcmeChallengeStatusReasonNEQ))
	}
	if len(i.AcmeChallengeStatusReasonIn) > 0 {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusReasonIn(i.AcmeChallengeStatusReasonIn...))
	}
	if len(i.AcmeChallengeStatusReasonNotIn) > 0 {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusReasonNotIn(i.AcmeChallengeStatusReasonNotIn...))
	}
	if i.AcmeChallengeStatusReasonGT != nil {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusReasonGT(*i.AcmeChallengeStatusReasonGT))
	}
	if i.AcmeChallengeStatusReasonGTE != nil {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusReasonGTE(*i.AcmeChallengeStatusReasonGTE))
	}
	if i.AcmeChallengeStatusReasonLT != nil {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusReasonLT(*i.AcmeChallengeStatusReasonLT))
	}
	if i.AcmeChallengeStatusReasonLTE != nil {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusReasonLTE(*i.AcmeChallengeStatusReasonLTE))
	}
	if i.AcmeChallengeStatusReasonContains != nil {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusReasonContains(*i.AcmeChallengeStatusReasonContains))
	}
	if i.AcmeChallengeStatusReasonHasPrefix != nil {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusReasonHasPrefix(*i.AcmeChallengeStatusReasonHasPrefix))
	}
	if i.AcmeChallengeStatusReasonHasSuffix != nil {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusReasonHasSuffix(*i.AcmeChallengeStatusReasonHasSuffix))
	}
	if i.AcmeChallengeStatusReasonIsNil {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusReasonIsNil())
	}
	if i.AcmeChallengeStatusReasonNotNil {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusReasonNotNil())
	}
	if i.AcmeChallengeStatusReasonEqualFold != nil {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusReasonEqualFold(*i.AcmeChallengeStatusReasonEqualFold))
	}
	if i.AcmeChallengeStatusReasonContainsFold != nil {
		predicates = append(predicates, dnsverification.AcmeChallengeStatusReasonContainsFold(*i.AcmeChallengeStatusReasonContainsFold))
	}

	if i.HasOwner != nil {
		p := dnsverification.HasOwner()
		if !*i.HasOwner {
			p = dnsverification.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dnsverification.HasOwnerWith(with...))
	}
	if i.HasCustomDomains != nil {
		p := dnsverification.HasCustomDomains()
		if !*i.HasCustomDomains {
			p = dnsverification.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomDomainsWith) > 0 {
		with := make([]predicate.CustomDomain, 0, len(i.HasCustomDomainsWith))
		for _, w := range i.HasCustomDomainsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomDomainsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dnsverification.HasCustomDomainsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDNSVerificationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return dnsverification.And(predicates...), nil
	}
}

// DNSVerificationHistoryWhereInput represents a where input for filtering DNSVerificationHistory queries.
type DNSVerificationHistoryWhereInput struct {
	Predicates []predicate.DNSVerificationHistory  `json:"-"`
	Not        *DNSVerificationHistoryWhereInput   `json:"not,omitempty"`
	Or         []*DNSVerificationHistoryWhereInput `json:"or,omitempty"`
	And        []*DNSVerificationHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "cloudflare_hostname_id" field predicates.
	CloudflareHostnameID             *string  `json:"cloudflareHostnameID,omitempty"`
	CloudflareHostnameIDNEQ          *string  `json:"cloudflareHostnameIDNEQ,omitempty"`
	CloudflareHostnameIDIn           []string `json:"cloudflareHostnameIDIn,omitempty"`
	CloudflareHostnameIDNotIn        []string `json:"cloudflareHostnameIDNotIn,omitempty"`
	CloudflareHostnameIDGT           *string  `json:"cloudflareHostnameIDGT,omitempty"`
	CloudflareHostnameIDGTE          *string  `json:"cloudflareHostnameIDGTE,omitempty"`
	CloudflareHostnameIDLT           *string  `json:"cloudflareHostnameIDLT,omitempty"`
	CloudflareHostnameIDLTE          *string  `json:"cloudflareHostnameIDLTE,omitempty"`
	CloudflareHostnameIDContains     *string  `json:"cloudflareHostnameIDContains,omitempty"`
	CloudflareHostnameIDHasPrefix    *string  `json:"cloudflareHostnameIDHasPrefix,omitempty"`
	CloudflareHostnameIDHasSuffix    *string  `json:"cloudflareHostnameIDHasSuffix,omitempty"`
	CloudflareHostnameIDEqualFold    *string  `json:"cloudflareHostnameIDEqualFold,omitempty"`
	CloudflareHostnameIDContainsFold *string  `json:"cloudflareHostnameIDContainsFold,omitempty"`

	// "dns_txt_record" field predicates.
	DNSTxtRecord             *string  `json:"dnsTxtRecord,omitempty"`
	DNSTxtRecordNEQ          *string  `json:"dnsTxtRecordNEQ,omitempty"`
	DNSTxtRecordIn           []string `json:"dnsTxtRecordIn,omitempty"`
	DNSTxtRecordNotIn        []string `json:"dnsTxtRecordNotIn,omitempty"`
	DNSTxtRecordGT           *string  `json:"dnsTxtRecordGT,omitempty"`
	DNSTxtRecordGTE          *string  `json:"dnsTxtRecordGTE,omitempty"`
	DNSTxtRecordLT           *string  `json:"dnsTxtRecordLT,omitempty"`
	DNSTxtRecordLTE          *string  `json:"dnsTxtRecordLTE,omitempty"`
	DNSTxtRecordContains     *string  `json:"dnsTxtRecordContains,omitempty"`
	DNSTxtRecordHasPrefix    *string  `json:"dnsTxtRecordHasPrefix,omitempty"`
	DNSTxtRecordHasSuffix    *string  `json:"dnsTxtRecordHasSuffix,omitempty"`
	DNSTxtRecordEqualFold    *string  `json:"dnsTxtRecordEqualFold,omitempty"`
	DNSTxtRecordContainsFold *string  `json:"dnsTxtRecordContainsFold,omitempty"`

	// "dns_txt_value" field predicates.
	DNSTxtValue             *string  `json:"dnsTxtValue,omitempty"`
	DNSTxtValueNEQ          *string  `json:"dnsTxtValueNEQ,omitempty"`
	DNSTxtValueIn           []string `json:"dnsTxtValueIn,omitempty"`
	DNSTxtValueNotIn        []string `json:"dnsTxtValueNotIn,omitempty"`
	DNSTxtValueGT           *string  `json:"dnsTxtValueGT,omitempty"`
	DNSTxtValueGTE          *string  `json:"dnsTxtValueGTE,omitempty"`
	DNSTxtValueLT           *string  `json:"dnsTxtValueLT,omitempty"`
	DNSTxtValueLTE          *string  `json:"dnsTxtValueLTE,omitempty"`
	DNSTxtValueContains     *string  `json:"dnsTxtValueContains,omitempty"`
	DNSTxtValueHasPrefix    *string  `json:"dnsTxtValueHasPrefix,omitempty"`
	DNSTxtValueHasSuffix    *string  `json:"dnsTxtValueHasSuffix,omitempty"`
	DNSTxtValueEqualFold    *string  `json:"dnsTxtValueEqualFold,omitempty"`
	DNSTxtValueContainsFold *string  `json:"dnsTxtValueContainsFold,omitempty"`

	// "dns_verification_status" field predicates.
	DNSVerificationStatus      *enums.DNSVerificationStatus  `json:"dnsVerificationStatus,omitempty"`
	DNSVerificationStatusNEQ   *enums.DNSVerificationStatus  `json:"dnsVerificationStatusNEQ,omitempty"`
	DNSVerificationStatusIn    []enums.DNSVerificationStatus `json:"dnsVerificationStatusIn,omitempty"`
	DNSVerificationStatusNotIn []enums.DNSVerificationStatus `json:"dnsVerificationStatusNotIn,omitempty"`

	// "dns_verification_status_reason" field predicates.
	DNSVerificationStatusReason             *string  `json:"dnsVerificationStatusReason,omitempty"`
	DNSVerificationStatusReasonNEQ          *string  `json:"dnsVerificationStatusReasonNEQ,omitempty"`
	DNSVerificationStatusReasonIn           []string `json:"dnsVerificationStatusReasonIn,omitempty"`
	DNSVerificationStatusReasonNotIn        []string `json:"dnsVerificationStatusReasonNotIn,omitempty"`
	DNSVerificationStatusReasonGT           *string  `json:"dnsVerificationStatusReasonGT,omitempty"`
	DNSVerificationStatusReasonGTE          *string  `json:"dnsVerificationStatusReasonGTE,omitempty"`
	DNSVerificationStatusReasonLT           *string  `json:"dnsVerificationStatusReasonLT,omitempty"`
	DNSVerificationStatusReasonLTE          *string  `json:"dnsVerificationStatusReasonLTE,omitempty"`
	DNSVerificationStatusReasonContains     *string  `json:"dnsVerificationStatusReasonContains,omitempty"`
	DNSVerificationStatusReasonHasPrefix    *string  `json:"dnsVerificationStatusReasonHasPrefix,omitempty"`
	DNSVerificationStatusReasonHasSuffix    *string  `json:"dnsVerificationStatusReasonHasSuffix,omitempty"`
	DNSVerificationStatusReasonIsNil        bool     `json:"dnsVerificationStatusReasonIsNil,omitempty"`
	DNSVerificationStatusReasonNotNil       bool     `json:"dnsVerificationStatusReasonNotNil,omitempty"`
	DNSVerificationStatusReasonEqualFold    *string  `json:"dnsVerificationStatusReasonEqualFold,omitempty"`
	DNSVerificationStatusReasonContainsFold *string  `json:"dnsVerificationStatusReasonContainsFold,omitempty"`

	// "acme_challenge_path" field predicates.
	AcmeChallengePath             *string  `json:"acmeChallengePath,omitempty"`
	AcmeChallengePathNEQ          *string  `json:"acmeChallengePathNEQ,omitempty"`
	AcmeChallengePathIn           []string `json:"acmeChallengePathIn,omitempty"`
	AcmeChallengePathNotIn        []string `json:"acmeChallengePathNotIn,omitempty"`
	AcmeChallengePathGT           *string  `json:"acmeChallengePathGT,omitempty"`
	AcmeChallengePathGTE          *string  `json:"acmeChallengePathGTE,omitempty"`
	AcmeChallengePathLT           *string  `json:"acmeChallengePathLT,omitempty"`
	AcmeChallengePathLTE          *string  `json:"acmeChallengePathLTE,omitempty"`
	AcmeChallengePathContains     *string  `json:"acmeChallengePathContains,omitempty"`
	AcmeChallengePathHasPrefix    *string  `json:"acmeChallengePathHasPrefix,omitempty"`
	AcmeChallengePathHasSuffix    *string  `json:"acmeChallengePathHasSuffix,omitempty"`
	AcmeChallengePathIsNil        bool     `json:"acmeChallengePathIsNil,omitempty"`
	AcmeChallengePathNotNil       bool     `json:"acmeChallengePathNotNil,omitempty"`
	AcmeChallengePathEqualFold    *string  `json:"acmeChallengePathEqualFold,omitempty"`
	AcmeChallengePathContainsFold *string  `json:"acmeChallengePathContainsFold,omitempty"`

	// "expected_acme_challenge_value" field predicates.
	ExpectedAcmeChallengeValue             *string  `json:"expectedAcmeChallengeValue,omitempty"`
	ExpectedAcmeChallengeValueNEQ          *string  `json:"expectedAcmeChallengeValueNEQ,omitempty"`
	ExpectedAcmeChallengeValueIn           []string `json:"expectedAcmeChallengeValueIn,omitempty"`
	ExpectedAcmeChallengeValueNotIn        []string `json:"expectedAcmeChallengeValueNotIn,omitempty"`
	ExpectedAcmeChallengeValueGT           *string  `json:"expectedAcmeChallengeValueGT,omitempty"`
	ExpectedAcmeChallengeValueGTE          *string  `json:"expectedAcmeChallengeValueGTE,omitempty"`
	ExpectedAcmeChallengeValueLT           *string  `json:"expectedAcmeChallengeValueLT,omitempty"`
	ExpectedAcmeChallengeValueLTE          *string  `json:"expectedAcmeChallengeValueLTE,omitempty"`
	ExpectedAcmeChallengeValueContains     *string  `json:"expectedAcmeChallengeValueContains,omitempty"`
	ExpectedAcmeChallengeValueHasPrefix    *string  `json:"expectedAcmeChallengeValueHasPrefix,omitempty"`
	ExpectedAcmeChallengeValueHasSuffix    *string  `json:"expectedAcmeChallengeValueHasSuffix,omitempty"`
	ExpectedAcmeChallengeValueIsNil        bool     `json:"expectedAcmeChallengeValueIsNil,omitempty"`
	ExpectedAcmeChallengeValueNotNil       bool     `json:"expectedAcmeChallengeValueNotNil,omitempty"`
	ExpectedAcmeChallengeValueEqualFold    *string  `json:"expectedAcmeChallengeValueEqualFold,omitempty"`
	ExpectedAcmeChallengeValueContainsFold *string  `json:"expectedAcmeChallengeValueContainsFold,omitempty"`

	// "acme_challenge_status" field predicates.
	AcmeChallengeStatus      *enums.SSLVerificationStatus  `json:"acmeChallengeStatus,omitempty"`
	AcmeChallengeStatusNEQ   *enums.SSLVerificationStatus  `json:"acmeChallengeStatusNEQ,omitempty"`
	AcmeChallengeStatusIn    []enums.SSLVerificationStatus `json:"acmeChallengeStatusIn,omitempty"`
	AcmeChallengeStatusNotIn []enums.SSLVerificationStatus `json:"acmeChallengeStatusNotIn,omitempty"`

	// "acme_challenge_status_reason" field predicates.
	AcmeChallengeStatusReason             *string  `json:"acmeChallengeStatusReason,omitempty"`
	AcmeChallengeStatusReasonNEQ          *string  `json:"acmeChallengeStatusReasonNEQ,omitempty"`
	AcmeChallengeStatusReasonIn           []string `json:"acmeChallengeStatusReasonIn,omitempty"`
	AcmeChallengeStatusReasonNotIn        []string `json:"acmeChallengeStatusReasonNotIn,omitempty"`
	AcmeChallengeStatusReasonGT           *string  `json:"acmeChallengeStatusReasonGT,omitempty"`
	AcmeChallengeStatusReasonGTE          *string  `json:"acmeChallengeStatusReasonGTE,omitempty"`
	AcmeChallengeStatusReasonLT           *string  `json:"acmeChallengeStatusReasonLT,omitempty"`
	AcmeChallengeStatusReasonLTE          *string  `json:"acmeChallengeStatusReasonLTE,omitempty"`
	AcmeChallengeStatusReasonContains     *string  `json:"acmeChallengeStatusReasonContains,omitempty"`
	AcmeChallengeStatusReasonHasPrefix    *string  `json:"acmeChallengeStatusReasonHasPrefix,omitempty"`
	AcmeChallengeStatusReasonHasSuffix    *string  `json:"acmeChallengeStatusReasonHasSuffix,omitempty"`
	AcmeChallengeStatusReasonIsNil        bool     `json:"acmeChallengeStatusReasonIsNil,omitempty"`
	AcmeChallengeStatusReasonNotNil       bool     `json:"acmeChallengeStatusReasonNotNil,omitempty"`
	AcmeChallengeStatusReasonEqualFold    *string  `json:"acmeChallengeStatusReasonEqualFold,omitempty"`
	AcmeChallengeStatusReasonContainsFold *string  `json:"acmeChallengeStatusReasonContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DNSVerificationHistoryWhereInput) AddPredicates(predicates ...predicate.DNSVerificationHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DNSVerificationHistoryWhereInput filter on the DNSVerificationHistoryQuery builder.
func (i *DNSVerificationHistoryWhereInput) Filter(q *DNSVerificationHistoryQuery) (*DNSVerificationHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDNSVerificationHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDNSVerificationHistoryWhereInput is returned in case the DNSVerificationHistoryWhereInput is empty.
var ErrEmptyDNSVerificationHistoryWhereInput = errors.New("generated: empty predicate DNSVerificationHistoryWhereInput")

// P returns a predicate for filtering dnsverificationhistories.
// An error is returned if the input is empty or invalid.
func (i *DNSVerificationHistoryWhereInput) P() (predicate.DNSVerificationHistory, error) {
	var predicates []predicate.DNSVerificationHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, dnsverificationhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DNSVerificationHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, dnsverificationhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DNSVerificationHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, dnsverificationhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, dnsverificationhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dnsverificationhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dnsverificationhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dnsverificationhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dnsverificationhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, dnsverificationhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, dnsverificationhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, dnsverificationhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, dnsverificationhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, dnsverificationhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, dnsverificationhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, dnsverificationhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, dnsverificationhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, dnsverificationhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, dnsverificationhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, dnsverificationhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, dnsverificationhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, dnsverificationhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, dnsverificationhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, dnsverificationhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, dnsverificationhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, dnsverificationhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, dnsverificationhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, dnsverificationhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, dnsverificationhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, dnsverificationhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, dnsverificationhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, dnsverificationhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, dnsverificationhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, dnsverificationhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, dnsverificationhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, dnsverificationhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, dnsverificationhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, dnsverificationhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, dnsverificationhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, dnsverificationhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, dnsverificationhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, dnsverificationhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, dnsverificationhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, dnsverificationhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, dnsverificationhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, dnsverificationhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, dnsverificationhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, dnsverificationhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, dnsverificationhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, dnsverificationhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, dnsverificationhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.CloudflareHostnameID != nil {
		predicates = append(predicates, dnsverificationhistory.CloudflareHostnameIDEQ(*i.CloudflareHostnameID))
	}
	if i.CloudflareHostnameIDNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.CloudflareHostnameIDNEQ(*i.CloudflareHostnameIDNEQ))
	}
	if len(i.CloudflareHostnameIDIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.CloudflareHostnameIDIn(i.CloudflareHostnameIDIn...))
	}
	if len(i.CloudflareHostnameIDNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.CloudflareHostnameIDNotIn(i.CloudflareHostnameIDNotIn...))
	}
	if i.CloudflareHostnameIDGT != nil {
		predicates = append(predicates, dnsverificationhistory.CloudflareHostnameIDGT(*i.CloudflareHostnameIDGT))
	}
	if i.CloudflareHostnameIDGTE != nil {
		predicates = append(predicates, dnsverificationhistory.CloudflareHostnameIDGTE(*i.CloudflareHostnameIDGTE))
	}
	if i.CloudflareHostnameIDLT != nil {
		predicates = append(predicates, dnsverificationhistory.CloudflareHostnameIDLT(*i.CloudflareHostnameIDLT))
	}
	if i.CloudflareHostnameIDLTE != nil {
		predicates = append(predicates, dnsverificationhistory.CloudflareHostnameIDLTE(*i.CloudflareHostnameIDLTE))
	}
	if i.CloudflareHostnameIDContains != nil {
		predicates = append(predicates, dnsverificationhistory.CloudflareHostnameIDContains(*i.CloudflareHostnameIDContains))
	}
	if i.CloudflareHostnameIDHasPrefix != nil {
		predicates = append(predicates, dnsverificationhistory.CloudflareHostnameIDHasPrefix(*i.CloudflareHostnameIDHasPrefix))
	}
	if i.CloudflareHostnameIDHasSuffix != nil {
		predicates = append(predicates, dnsverificationhistory.CloudflareHostnameIDHasSuffix(*i.CloudflareHostnameIDHasSuffix))
	}
	if i.CloudflareHostnameIDEqualFold != nil {
		predicates = append(predicates, dnsverificationhistory.CloudflareHostnameIDEqualFold(*i.CloudflareHostnameIDEqualFold))
	}
	if i.CloudflareHostnameIDContainsFold != nil {
		predicates = append(predicates, dnsverificationhistory.CloudflareHostnameIDContainsFold(*i.CloudflareHostnameIDContainsFold))
	}
	if i.DNSTxtRecord != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtRecordEQ(*i.DNSTxtRecord))
	}
	if i.DNSTxtRecordNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtRecordNEQ(*i.DNSTxtRecordNEQ))
	}
	if len(i.DNSTxtRecordIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.DNSTxtRecordIn(i.DNSTxtRecordIn...))
	}
	if len(i.DNSTxtRecordNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.DNSTxtRecordNotIn(i.DNSTxtRecordNotIn...))
	}
	if i.DNSTxtRecordGT != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtRecordGT(*i.DNSTxtRecordGT))
	}
	if i.DNSTxtRecordGTE != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtRecordGTE(*i.DNSTxtRecordGTE))
	}
	if i.DNSTxtRecordLT != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtRecordLT(*i.DNSTxtRecordLT))
	}
	if i.DNSTxtRecordLTE != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtRecordLTE(*i.DNSTxtRecordLTE))
	}
	if i.DNSTxtRecordContains != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtRecordContains(*i.DNSTxtRecordContains))
	}
	if i.DNSTxtRecordHasPrefix != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtRecordHasPrefix(*i.DNSTxtRecordHasPrefix))
	}
	if i.DNSTxtRecordHasSuffix != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtRecordHasSuffix(*i.DNSTxtRecordHasSuffix))
	}
	if i.DNSTxtRecordEqualFold != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtRecordEqualFold(*i.DNSTxtRecordEqualFold))
	}
	if i.DNSTxtRecordContainsFold != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtRecordContainsFold(*i.DNSTxtRecordContainsFold))
	}
	if i.DNSTxtValue != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtValueEQ(*i.DNSTxtValue))
	}
	if i.DNSTxtValueNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtValueNEQ(*i.DNSTxtValueNEQ))
	}
	if len(i.DNSTxtValueIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.DNSTxtValueIn(i.DNSTxtValueIn...))
	}
	if len(i.DNSTxtValueNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.DNSTxtValueNotIn(i.DNSTxtValueNotIn...))
	}
	if i.DNSTxtValueGT != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtValueGT(*i.DNSTxtValueGT))
	}
	if i.DNSTxtValueGTE != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtValueGTE(*i.DNSTxtValueGTE))
	}
	if i.DNSTxtValueLT != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtValueLT(*i.DNSTxtValueLT))
	}
	if i.DNSTxtValueLTE != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtValueLTE(*i.DNSTxtValueLTE))
	}
	if i.DNSTxtValueContains != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtValueContains(*i.DNSTxtValueContains))
	}
	if i.DNSTxtValueHasPrefix != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtValueHasPrefix(*i.DNSTxtValueHasPrefix))
	}
	if i.DNSTxtValueHasSuffix != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtValueHasSuffix(*i.DNSTxtValueHasSuffix))
	}
	if i.DNSTxtValueEqualFold != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtValueEqualFold(*i.DNSTxtValueEqualFold))
	}
	if i.DNSTxtValueContainsFold != nil {
		predicates = append(predicates, dnsverificationhistory.DNSTxtValueContainsFold(*i.DNSTxtValueContainsFold))
	}
	if i.DNSVerificationStatus != nil {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusEQ(*i.DNSVerificationStatus))
	}
	if i.DNSVerificationStatusNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusNEQ(*i.DNSVerificationStatusNEQ))
	}
	if len(i.DNSVerificationStatusIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusIn(i.DNSVerificationStatusIn...))
	}
	if len(i.DNSVerificationStatusNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusNotIn(i.DNSVerificationStatusNotIn...))
	}
	if i.DNSVerificationStatusReason != nil {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusReasonEQ(*i.DNSVerificationStatusReason))
	}
	if i.DNSVerificationStatusReasonNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusReasonNEQ(*i.DNSVerificationStatusReasonNEQ))
	}
	if len(i.DNSVerificationStatusReasonIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusReasonIn(i.DNSVerificationStatusReasonIn...))
	}
	if len(i.DNSVerificationStatusReasonNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusReasonNotIn(i.DNSVerificationStatusReasonNotIn...))
	}
	if i.DNSVerificationStatusReasonGT != nil {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusReasonGT(*i.DNSVerificationStatusReasonGT))
	}
	if i.DNSVerificationStatusReasonGTE != nil {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusReasonGTE(*i.DNSVerificationStatusReasonGTE))
	}
	if i.DNSVerificationStatusReasonLT != nil {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusReasonLT(*i.DNSVerificationStatusReasonLT))
	}
	if i.DNSVerificationStatusReasonLTE != nil {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusReasonLTE(*i.DNSVerificationStatusReasonLTE))
	}
	if i.DNSVerificationStatusReasonContains != nil {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusReasonContains(*i.DNSVerificationStatusReasonContains))
	}
	if i.DNSVerificationStatusReasonHasPrefix != nil {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusReasonHasPrefix(*i.DNSVerificationStatusReasonHasPrefix))
	}
	if i.DNSVerificationStatusReasonHasSuffix != nil {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusReasonHasSuffix(*i.DNSVerificationStatusReasonHasSuffix))
	}
	if i.DNSVerificationStatusReasonIsNil {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusReasonIsNil())
	}
	if i.DNSVerificationStatusReasonNotNil {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusReasonNotNil())
	}
	if i.DNSVerificationStatusReasonEqualFold != nil {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusReasonEqualFold(*i.DNSVerificationStatusReasonEqualFold))
	}
	if i.DNSVerificationStatusReasonContainsFold != nil {
		predicates = append(predicates, dnsverificationhistory.DNSVerificationStatusReasonContainsFold(*i.DNSVerificationStatusReasonContainsFold))
	}
	if i.AcmeChallengePath != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengePathEQ(*i.AcmeChallengePath))
	}
	if i.AcmeChallengePathNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengePathNEQ(*i.AcmeChallengePathNEQ))
	}
	if len(i.AcmeChallengePathIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengePathIn(i.AcmeChallengePathIn...))
	}
	if len(i.AcmeChallengePathNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengePathNotIn(i.AcmeChallengePathNotIn...))
	}
	if i.AcmeChallengePathGT != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengePathGT(*i.AcmeChallengePathGT))
	}
	if i.AcmeChallengePathGTE != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengePathGTE(*i.AcmeChallengePathGTE))
	}
	if i.AcmeChallengePathLT != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengePathLT(*i.AcmeChallengePathLT))
	}
	if i.AcmeChallengePathLTE != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengePathLTE(*i.AcmeChallengePathLTE))
	}
	if i.AcmeChallengePathContains != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengePathContains(*i.AcmeChallengePathContains))
	}
	if i.AcmeChallengePathHasPrefix != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengePathHasPrefix(*i.AcmeChallengePathHasPrefix))
	}
	if i.AcmeChallengePathHasSuffix != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengePathHasSuffix(*i.AcmeChallengePathHasSuffix))
	}
	if i.AcmeChallengePathIsNil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengePathIsNil())
	}
	if i.AcmeChallengePathNotNil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengePathNotNil())
	}
	if i.AcmeChallengePathEqualFold != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengePathEqualFold(*i.AcmeChallengePathEqualFold))
	}
	if i.AcmeChallengePathContainsFold != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengePathContainsFold(*i.AcmeChallengePathContainsFold))
	}
	if i.ExpectedAcmeChallengeValue != nil {
		predicates = append(predicates, dnsverificationhistory.ExpectedAcmeChallengeValueEQ(*i.ExpectedAcmeChallengeValue))
	}
	if i.ExpectedAcmeChallengeValueNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.ExpectedAcmeChallengeValueNEQ(*i.ExpectedAcmeChallengeValueNEQ))
	}
	if len(i.ExpectedAcmeChallengeValueIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.ExpectedAcmeChallengeValueIn(i.ExpectedAcmeChallengeValueIn...))
	}
	if len(i.ExpectedAcmeChallengeValueNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.ExpectedAcmeChallengeValueNotIn(i.ExpectedAcmeChallengeValueNotIn...))
	}
	if i.ExpectedAcmeChallengeValueGT != nil {
		predicates = append(predicates, dnsverificationhistory.ExpectedAcmeChallengeValueGT(*i.ExpectedAcmeChallengeValueGT))
	}
	if i.ExpectedAcmeChallengeValueGTE != nil {
		predicates = append(predicates, dnsverificationhistory.ExpectedAcmeChallengeValueGTE(*i.ExpectedAcmeChallengeValueGTE))
	}
	if i.ExpectedAcmeChallengeValueLT != nil {
		predicates = append(predicates, dnsverificationhistory.ExpectedAcmeChallengeValueLT(*i.ExpectedAcmeChallengeValueLT))
	}
	if i.ExpectedAcmeChallengeValueLTE != nil {
		predicates = append(predicates, dnsverificationhistory.ExpectedAcmeChallengeValueLTE(*i.ExpectedAcmeChallengeValueLTE))
	}
	if i.ExpectedAcmeChallengeValueContains != nil {
		predicates = append(predicates, dnsverificationhistory.ExpectedAcmeChallengeValueContains(*i.ExpectedAcmeChallengeValueContains))
	}
	if i.ExpectedAcmeChallengeValueHasPrefix != nil {
		predicates = append(predicates, dnsverificationhistory.ExpectedAcmeChallengeValueHasPrefix(*i.ExpectedAcmeChallengeValueHasPrefix))
	}
	if i.ExpectedAcmeChallengeValueHasSuffix != nil {
		predicates = append(predicates, dnsverificationhistory.ExpectedAcmeChallengeValueHasSuffix(*i.ExpectedAcmeChallengeValueHasSuffix))
	}
	if i.ExpectedAcmeChallengeValueIsNil {
		predicates = append(predicates, dnsverificationhistory.ExpectedAcmeChallengeValueIsNil())
	}
	if i.ExpectedAcmeChallengeValueNotNil {
		predicates = append(predicates, dnsverificationhistory.ExpectedAcmeChallengeValueNotNil())
	}
	if i.ExpectedAcmeChallengeValueEqualFold != nil {
		predicates = append(predicates, dnsverificationhistory.ExpectedAcmeChallengeValueEqualFold(*i.ExpectedAcmeChallengeValueEqualFold))
	}
	if i.ExpectedAcmeChallengeValueContainsFold != nil {
		predicates = append(predicates, dnsverificationhistory.ExpectedAcmeChallengeValueContainsFold(*i.ExpectedAcmeChallengeValueContainsFold))
	}
	if i.AcmeChallengeStatus != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusEQ(*i.AcmeChallengeStatus))
	}
	if i.AcmeChallengeStatusNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusNEQ(*i.AcmeChallengeStatusNEQ))
	}
	if len(i.AcmeChallengeStatusIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusIn(i.AcmeChallengeStatusIn...))
	}
	if len(i.AcmeChallengeStatusNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusNotIn(i.AcmeChallengeStatusNotIn...))
	}
	if i.AcmeChallengeStatusReason != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusReasonEQ(*i.AcmeChallengeStatusReason))
	}
	if i.AcmeChallengeStatusReasonNEQ != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusReasonNEQ(*i.AcmeChallengeStatusReasonNEQ))
	}
	if len(i.AcmeChallengeStatusReasonIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusReasonIn(i.AcmeChallengeStatusReasonIn...))
	}
	if len(i.AcmeChallengeStatusReasonNotIn) > 0 {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusReasonNotIn(i.AcmeChallengeStatusReasonNotIn...))
	}
	if i.AcmeChallengeStatusReasonGT != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusReasonGT(*i.AcmeChallengeStatusReasonGT))
	}
	if i.AcmeChallengeStatusReasonGTE != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusReasonGTE(*i.AcmeChallengeStatusReasonGTE))
	}
	if i.AcmeChallengeStatusReasonLT != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusReasonLT(*i.AcmeChallengeStatusReasonLT))
	}
	if i.AcmeChallengeStatusReasonLTE != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusReasonLTE(*i.AcmeChallengeStatusReasonLTE))
	}
	if i.AcmeChallengeStatusReasonContains != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusReasonContains(*i.AcmeChallengeStatusReasonContains))
	}
	if i.AcmeChallengeStatusReasonHasPrefix != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusReasonHasPrefix(*i.AcmeChallengeStatusReasonHasPrefix))
	}
	if i.AcmeChallengeStatusReasonHasSuffix != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusReasonHasSuffix(*i.AcmeChallengeStatusReasonHasSuffix))
	}
	if i.AcmeChallengeStatusReasonIsNil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusReasonIsNil())
	}
	if i.AcmeChallengeStatusReasonNotNil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusReasonNotNil())
	}
	if i.AcmeChallengeStatusReasonEqualFold != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusReasonEqualFold(*i.AcmeChallengeStatusReasonEqualFold))
	}
	if i.AcmeChallengeStatusReasonContainsFold != nil {
		predicates = append(predicates, dnsverificationhistory.AcmeChallengeStatusReasonContainsFold(*i.AcmeChallengeStatusReasonContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDNSVerificationHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return dnsverificationhistory.And(predicates...), nil
	}
}

// DocumentDataWhereInput represents a where input for filtering DocumentData queries.
type DocumentDataWhereInput struct {
	Predicates []predicate.DocumentData  `json:"-"`
	Not        *DocumentDataWhereInput   `json:"not,omitempty"`
	Or         []*DocumentDataWhereInput `json:"or,omitempty"`
	And        []*DocumentDataWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "template_id" field predicates.
	TemplateID             *string  `json:"templateID,omitempty"`
	TemplateIDNEQ          *string  `json:"templateIDNEQ,omitempty"`
	TemplateIDIn           []string `json:"templateIDIn,omitempty"`
	TemplateIDNotIn        []string `json:"templateIDNotIn,omitempty"`
	TemplateIDGT           *string  `json:"templateIDGT,omitempty"`
	TemplateIDGTE          *string  `json:"templateIDGTE,omitempty"`
	TemplateIDLT           *string  `json:"templateIDLT,omitempty"`
	TemplateIDLTE          *string  `json:"templateIDLTE,omitempty"`
	TemplateIDContains     *string  `json:"templateIDContains,omitempty"`
	TemplateIDHasPrefix    *string  `json:"templateIDHasPrefix,omitempty"`
	TemplateIDHasSuffix    *string  `json:"templateIDHasSuffix,omitempty"`
	TemplateIDEqualFold    *string  `json:"templateIDEqualFold,omitempty"`
	TemplateIDContainsFold *string  `json:"templateIDContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "template" edge predicates.
	HasTemplate     *bool                 `json:"hasTemplate,omitempty"`
	HasTemplateWith []*TemplateWhereInput `json:"hasTemplateWith,omitempty"`

	// "entities" edge predicates.
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DocumentDataWhereInput) AddPredicates(predicates ...predicate.DocumentData) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DocumentDataWhereInput filter on the DocumentDataQuery builder.
func (i *DocumentDataWhereInput) Filter(q *DocumentDataQuery) (*DocumentDataQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDocumentDataWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDocumentDataWhereInput is returned in case the DocumentDataWhereInput is empty.
var ErrEmptyDocumentDataWhereInput = errors.New("generated: empty predicate DocumentDataWhereInput")

// P returns a predicate for filtering documentdataslice.
// An error is returned if the input is empty or invalid.
func (i *DocumentDataWhereInput) P() (predicate.DocumentData, error) {
	var predicates []predicate.DocumentData
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, documentdata.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DocumentData, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, documentdata.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DocumentData, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, documentdata.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, documentdata.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, documentdata.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, documentdata.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, documentdata.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, documentdata.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, documentdata.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, documentdata.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, documentdata.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, documentdata.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, documentdata.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, documentdata.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, documentdata.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, documentdata.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, documentdata.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, documentdata.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, documentdata.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, documentdata.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, documentdata.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, documentdata.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, documentdata.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, documentdata.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, documentdata.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, documentdata.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, documentdata.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, documentdata.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, documentdata.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, documentdata.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, documentdata.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, documentdata.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, documentdata.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, documentdata.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, documentdata.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, documentdata.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, documentdata.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, documentdata.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, documentdata.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, documentdata.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, documentdata.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, documentdata.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, documentdata.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, documentdata.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, documentdata.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, documentdata.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, documentdata.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, documentdata.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, documentdata.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, documentdata.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, documentdata.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, documentdata.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, documentdata.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, documentdata.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, documentdata.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, documentdata.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, documentdata.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, documentdata.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, documentdata.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, documentdata.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, documentdata.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, documentdata.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, documentdata.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, documentdata.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, documentdata.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, documentdata.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, documentdata.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, documentdata.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, documentdata.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, documentdata.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, documentdata.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, documentdata.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, documentdata.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, documentdata.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, documentdata.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, documentdata.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, documentdata.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, documentdata.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.TemplateID != nil {
		predicates = append(predicates, documentdata.TemplateIDEQ(*i.TemplateID))
	}
	if i.TemplateIDNEQ != nil {
		predicates = append(predicates, documentdata.TemplateIDNEQ(*i.TemplateIDNEQ))
	}
	if len(i.TemplateIDIn) > 0 {
		predicates = append(predicates, documentdata.TemplateIDIn(i.TemplateIDIn...))
	}
	if len(i.TemplateIDNotIn) > 0 {
		predicates = append(predicates, documentdata.TemplateIDNotIn(i.TemplateIDNotIn...))
	}
	if i.TemplateIDGT != nil {
		predicates = append(predicates, documentdata.TemplateIDGT(*i.TemplateIDGT))
	}
	if i.TemplateIDGTE != nil {
		predicates = append(predicates, documentdata.TemplateIDGTE(*i.TemplateIDGTE))
	}
	if i.TemplateIDLT != nil {
		predicates = append(predicates, documentdata.TemplateIDLT(*i.TemplateIDLT))
	}
	if i.TemplateIDLTE != nil {
		predicates = append(predicates, documentdata.TemplateIDLTE(*i.TemplateIDLTE))
	}
	if i.TemplateIDContains != nil {
		predicates = append(predicates, documentdata.TemplateIDContains(*i.TemplateIDContains))
	}
	if i.TemplateIDHasPrefix != nil {
		predicates = append(predicates, documentdata.TemplateIDHasPrefix(*i.TemplateIDHasPrefix))
	}
	if i.TemplateIDHasSuffix != nil {
		predicates = append(predicates, documentdata.TemplateIDHasSuffix(*i.TemplateIDHasSuffix))
	}
	if i.TemplateIDEqualFold != nil {
		predicates = append(predicates, documentdata.TemplateIDEqualFold(*i.TemplateIDEqualFold))
	}
	if i.TemplateIDContainsFold != nil {
		predicates = append(predicates, documentdata.TemplateIDContainsFold(*i.TemplateIDContainsFold))
	}

	if i.HasOwner != nil {
		p := documentdata.HasOwner()
		if !*i.HasOwner {
			p = documentdata.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, documentdata.HasOwnerWith(with...))
	}
	if i.HasTemplate != nil {
		p := documentdata.HasTemplate()
		if !*i.HasTemplate {
			p = documentdata.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTemplateWith) > 0 {
		with := make([]predicate.Template, 0, len(i.HasTemplateWith))
		for _, w := range i.HasTemplateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTemplateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, documentdata.HasTemplateWith(with...))
	}
	if i.HasEntities != nil {
		p := documentdata.HasEntities()
		if !*i.HasEntities {
			p = documentdata.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEntitiesWith) > 0 {
		with := make([]predicate.Entity, 0, len(i.HasEntitiesWith))
		for _, w := range i.HasEntitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEntitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, documentdata.HasEntitiesWith(with...))
	}
	if i.HasFiles != nil {
		p := documentdata.HasFiles()
		if !*i.HasFiles {
			p = documentdata.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, documentdata.HasFilesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDocumentDataWhereInput
	case 1:
		return predicates[0], nil
	default:
		return documentdata.And(predicates...), nil
	}
}

// DocumentDataHistoryWhereInput represents a where input for filtering DocumentDataHistory queries.
type DocumentDataHistoryWhereInput struct {
	Predicates []predicate.DocumentDataHistory  `json:"-"`
	Not        *DocumentDataHistoryWhereInput   `json:"not,omitempty"`
	Or         []*DocumentDataHistoryWhereInput `json:"or,omitempty"`
	And        []*DocumentDataHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "template_id" field predicates.
	TemplateID             *string  `json:"templateID,omitempty"`
	TemplateIDNEQ          *string  `json:"templateIDNEQ,omitempty"`
	TemplateIDIn           []string `json:"templateIDIn,omitempty"`
	TemplateIDNotIn        []string `json:"templateIDNotIn,omitempty"`
	TemplateIDGT           *string  `json:"templateIDGT,omitempty"`
	TemplateIDGTE          *string  `json:"templateIDGTE,omitempty"`
	TemplateIDLT           *string  `json:"templateIDLT,omitempty"`
	TemplateIDLTE          *string  `json:"templateIDLTE,omitempty"`
	TemplateIDContains     *string  `json:"templateIDContains,omitempty"`
	TemplateIDHasPrefix    *string  `json:"templateIDHasPrefix,omitempty"`
	TemplateIDHasSuffix    *string  `json:"templateIDHasSuffix,omitempty"`
	TemplateIDEqualFold    *string  `json:"templateIDEqualFold,omitempty"`
	TemplateIDContainsFold *string  `json:"templateIDContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DocumentDataHistoryWhereInput) AddPredicates(predicates ...predicate.DocumentDataHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DocumentDataHistoryWhereInput filter on the DocumentDataHistoryQuery builder.
func (i *DocumentDataHistoryWhereInput) Filter(q *DocumentDataHistoryQuery) (*DocumentDataHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDocumentDataHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDocumentDataHistoryWhereInput is returned in case the DocumentDataHistoryWhereInput is empty.
var ErrEmptyDocumentDataHistoryWhereInput = errors.New("generated: empty predicate DocumentDataHistoryWhereInput")

// P returns a predicate for filtering documentdatahistories.
// An error is returned if the input is empty or invalid.
func (i *DocumentDataHistoryWhereInput) P() (predicate.DocumentDataHistory, error) {
	var predicates []predicate.DocumentDataHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, documentdatahistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DocumentDataHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, documentdatahistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DocumentDataHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, documentdatahistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, documentdatahistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, documentdatahistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, documentdatahistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, documentdatahistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, documentdatahistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, documentdatahistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, documentdatahistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, documentdatahistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, documentdatahistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, documentdatahistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, documentdatahistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, documentdatahistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, documentdatahistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, documentdatahistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, documentdatahistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, documentdatahistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, documentdatahistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, documentdatahistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, documentdatahistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, documentdatahistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, documentdatahistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, documentdatahistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, documentdatahistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, documentdatahistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, documentdatahistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, documentdatahistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, documentdatahistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, documentdatahistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, documentdatahistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, documentdatahistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, documentdatahistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, documentdatahistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, documentdatahistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, documentdatahistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, documentdatahistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, documentdatahistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, documentdatahistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, documentdatahistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, documentdatahistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, documentdatahistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, documentdatahistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, documentdatahistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, documentdatahistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, documentdatahistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, documentdatahistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, documentdatahistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, documentdatahistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, documentdatahistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, documentdatahistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, documentdatahistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, documentdatahistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, documentdatahistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, documentdatahistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, documentdatahistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, documentdatahistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, documentdatahistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, documentdatahistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, documentdatahistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, documentdatahistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, documentdatahistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, documentdatahistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, documentdatahistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, documentdatahistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, documentdatahistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, documentdatahistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, documentdatahistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, documentdatahistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, documentdatahistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, documentdatahistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, documentdatahistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, documentdatahistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, documentdatahistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, documentdatahistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, documentdatahistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, documentdatahistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, documentdatahistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, documentdatahistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, documentdatahistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, documentdatahistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, documentdatahistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, documentdatahistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, documentdatahistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, documentdatahistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, documentdatahistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, documentdatahistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, documentdatahistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, documentdatahistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, documentdatahistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, documentdatahistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, documentdatahistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, documentdatahistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, documentdatahistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, documentdatahistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, documentdatahistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, documentdatahistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, documentdatahistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, documentdatahistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, documentdatahistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, documentdatahistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, documentdatahistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, documentdatahistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, documentdatahistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.TemplateID != nil {
		predicates = append(predicates, documentdatahistory.TemplateIDEQ(*i.TemplateID))
	}
	if i.TemplateIDNEQ != nil {
		predicates = append(predicates, documentdatahistory.TemplateIDNEQ(*i.TemplateIDNEQ))
	}
	if len(i.TemplateIDIn) > 0 {
		predicates = append(predicates, documentdatahistory.TemplateIDIn(i.TemplateIDIn...))
	}
	if len(i.TemplateIDNotIn) > 0 {
		predicates = append(predicates, documentdatahistory.TemplateIDNotIn(i.TemplateIDNotIn...))
	}
	if i.TemplateIDGT != nil {
		predicates = append(predicates, documentdatahistory.TemplateIDGT(*i.TemplateIDGT))
	}
	if i.TemplateIDGTE != nil {
		predicates = append(predicates, documentdatahistory.TemplateIDGTE(*i.TemplateIDGTE))
	}
	if i.TemplateIDLT != nil {
		predicates = append(predicates, documentdatahistory.TemplateIDLT(*i.TemplateIDLT))
	}
	if i.TemplateIDLTE != nil {
		predicates = append(predicates, documentdatahistory.TemplateIDLTE(*i.TemplateIDLTE))
	}
	if i.TemplateIDContains != nil {
		predicates = append(predicates, documentdatahistory.TemplateIDContains(*i.TemplateIDContains))
	}
	if i.TemplateIDHasPrefix != nil {
		predicates = append(predicates, documentdatahistory.TemplateIDHasPrefix(*i.TemplateIDHasPrefix))
	}
	if i.TemplateIDHasSuffix != nil {
		predicates = append(predicates, documentdatahistory.TemplateIDHasSuffix(*i.TemplateIDHasSuffix))
	}
	if i.TemplateIDEqualFold != nil {
		predicates = append(predicates, documentdatahistory.TemplateIDEqualFold(*i.TemplateIDEqualFold))
	}
	if i.TemplateIDContainsFold != nil {
		predicates = append(predicates, documentdatahistory.TemplateIDContainsFold(*i.TemplateIDContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDocumentDataHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return documentdatahistory.And(predicates...), nil
	}
}

// EntityWhereInput represents a where input for filtering Entity queries.
type EntityWhereInput struct {
	Predicates []predicate.Entity  `json:"-"`
	Not        *EntityWhereInput   `json:"not,omitempty"`
	Or         []*EntityWhereInput `json:"or,omitempty"`
	And        []*EntityWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "entity_type_id" field predicates.
	EntityTypeID             *string  `json:"entityTypeID,omitempty"`
	EntityTypeIDNEQ          *string  `json:"entityTypeIDNEQ,omitempty"`
	EntityTypeIDIn           []string `json:"entityTypeIDIn,omitempty"`
	EntityTypeIDNotIn        []string `json:"entityTypeIDNotIn,omitempty"`
	EntityTypeIDGT           *string  `json:"entityTypeIDGT,omitempty"`
	EntityTypeIDGTE          *string  `json:"entityTypeIDGTE,omitempty"`
	EntityTypeIDLT           *string  `json:"entityTypeIDLT,omitempty"`
	EntityTypeIDLTE          *string  `json:"entityTypeIDLTE,omitempty"`
	EntityTypeIDContains     *string  `json:"entityTypeIDContains,omitempty"`
	EntityTypeIDHasPrefix    *string  `json:"entityTypeIDHasPrefix,omitempty"`
	EntityTypeIDHasSuffix    *string  `json:"entityTypeIDHasSuffix,omitempty"`
	EntityTypeIDIsNil        bool     `json:"entityTypeIDIsNil,omitempty"`
	EntityTypeIDNotNil       bool     `json:"entityTypeIDNotNil,omitempty"`
	EntityTypeIDEqualFold    *string  `json:"entityTypeIDEqualFold,omitempty"`
	EntityTypeIDContainsFold *string  `json:"entityTypeIDContainsFold,omitempty"`

	// "status" field predicates.
	Status             *string  `json:"status,omitempty"`
	StatusNEQ          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGT           *string  `json:"statusGT,omitempty"`
	StatusGTE          *string  `json:"statusGTE,omitempty"`
	StatusLT           *string  `json:"statusLT,omitempty"`
	StatusLTE          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        bool     `json:"statusIsNil,omitempty"`
	StatusNotNil       bool     `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "contacts" edge predicates.
	HasContacts     *bool                `json:"hasContacts,omitempty"`
	HasContactsWith []*ContactWhereInput `json:"hasContactsWith,omitempty"`

	// "documents" edge predicates.
	HasDocuments     *bool                     `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentDataWhereInput `json:"hasDocumentsWith,omitempty"`

	// "notes" edge predicates.
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`

	// "entity_type" edge predicates.
	HasEntityType     *bool                   `json:"hasEntityType,omitempty"`
	HasEntityTypeWith []*EntityTypeWhereInput `json:"hasEntityTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EntityWhereInput) AddPredicates(predicates ...predicate.Entity) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EntityWhereInput filter on the EntityQuery builder.
func (i *EntityWhereInput) Filter(q *EntityQuery) (*EntityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEntityWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEntityWhereInput is returned in case the EntityWhereInput is empty.
var ErrEmptyEntityWhereInput = errors.New("generated: empty predicate EntityWhereInput")

// P returns a predicate for filtering entities.
// An error is returned if the input is empty or invalid.
func (i *EntityWhereInput) P() (predicate.Entity, error) {
	var predicates []predicate.Entity
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, entity.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Entity, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, entity.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Entity, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, entity.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, entity.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, entity.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, entity.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, entity.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, entity.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, entity.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, entity.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, entity.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, entity.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, entity.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, entity.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, entity.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, entity.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, entity.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, entity.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, entity.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, entity.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, entity.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, entity.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, entity.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, entity.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, entity.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, entity.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, entity.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, entity.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, entity.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, entity.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, entity.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, entity.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, entity.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, entity.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, entity.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, entity.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, entity.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, entity.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, entity.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, entity.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, entity.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, entity.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, entity.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, entity.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, entity.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, entity.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, entity.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, entity.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, entity.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, entity.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, entity.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, entity.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, entity.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, entity.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, entity.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, entity.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, entity.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, entity.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, entity.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, entity.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, entity.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, entity.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, entity.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, entity.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, entity.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, entity.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, entity.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, entity.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, entity.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, entity.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, entity.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, entity.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, entity.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, entity.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, entity.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, entity.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, entity.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, entity.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, entity.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, entity.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, entity.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, entity.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, entity.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, entity.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, entity.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, entity.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, entity.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, entity.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, entity.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, entity.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, entity.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, entity.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, entity.NameContainsFold(*i.NameContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, entity.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, entity.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, entity.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, entity.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, entity.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, entity.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, entity.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, entity.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, entity.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, entity.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, entity.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, entity.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, entity.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, entity.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, entity.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.EntityTypeID != nil {
		predicates = append(predicates, entity.EntityTypeIDEQ(*i.EntityTypeID))
	}
	if i.EntityTypeIDNEQ != nil {
		predicates = append(predicates, entity.EntityTypeIDNEQ(*i.EntityTypeIDNEQ))
	}
	if len(i.EntityTypeIDIn) > 0 {
		predicates = append(predicates, entity.EntityTypeIDIn(i.EntityTypeIDIn...))
	}
	if len(i.EntityTypeIDNotIn) > 0 {
		predicates = append(predicates, entity.EntityTypeIDNotIn(i.EntityTypeIDNotIn...))
	}
	if i.EntityTypeIDGT != nil {
		predicates = append(predicates, entity.EntityTypeIDGT(*i.EntityTypeIDGT))
	}
	if i.EntityTypeIDGTE != nil {
		predicates = append(predicates, entity.EntityTypeIDGTE(*i.EntityTypeIDGTE))
	}
	if i.EntityTypeIDLT != nil {
		predicates = append(predicates, entity.EntityTypeIDLT(*i.EntityTypeIDLT))
	}
	if i.EntityTypeIDLTE != nil {
		predicates = append(predicates, entity.EntityTypeIDLTE(*i.EntityTypeIDLTE))
	}
	if i.EntityTypeIDContains != nil {
		predicates = append(predicates, entity.EntityTypeIDContains(*i.EntityTypeIDContains))
	}
	if i.EntityTypeIDHasPrefix != nil {
		predicates = append(predicates, entity.EntityTypeIDHasPrefix(*i.EntityTypeIDHasPrefix))
	}
	if i.EntityTypeIDHasSuffix != nil {
		predicates = append(predicates, entity.EntityTypeIDHasSuffix(*i.EntityTypeIDHasSuffix))
	}
	if i.EntityTypeIDIsNil {
		predicates = append(predicates, entity.EntityTypeIDIsNil())
	}
	if i.EntityTypeIDNotNil {
		predicates = append(predicates, entity.EntityTypeIDNotNil())
	}
	if i.EntityTypeIDEqualFold != nil {
		predicates = append(predicates, entity.EntityTypeIDEqualFold(*i.EntityTypeIDEqualFold))
	}
	if i.EntityTypeIDContainsFold != nil {
		predicates = append(predicates, entity.EntityTypeIDContainsFold(*i.EntityTypeIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, entity.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, entity.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, entity.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, entity.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusGT != nil {
		predicates = append(predicates, entity.StatusGT(*i.StatusGT))
	}
	if i.StatusGTE != nil {
		predicates = append(predicates, entity.StatusGTE(*i.StatusGTE))
	}
	if i.StatusLT != nil {
		predicates = append(predicates, entity.StatusLT(*i.StatusLT))
	}
	if i.StatusLTE != nil {
		predicates = append(predicates, entity.StatusLTE(*i.StatusLTE))
	}
	if i.StatusContains != nil {
		predicates = append(predicates, entity.StatusContains(*i.StatusContains))
	}
	if i.StatusHasPrefix != nil {
		predicates = append(predicates, entity.StatusHasPrefix(*i.StatusHasPrefix))
	}
	if i.StatusHasSuffix != nil {
		predicates = append(predicates, entity.StatusHasSuffix(*i.StatusHasSuffix))
	}
	if i.StatusIsNil {
		predicates = append(predicates, entity.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, entity.StatusNotNil())
	}
	if i.StatusEqualFold != nil {
		predicates = append(predicates, entity.StatusEqualFold(*i.StatusEqualFold))
	}
	if i.StatusContainsFold != nil {
		predicates = append(predicates, entity.StatusContainsFold(*i.StatusContainsFold))
	}

	if i.HasOwner != nil {
		p := entity.HasOwner()
		if !*i.HasOwner {
			p = entity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, entity.HasOwnerWith(with...))
	}
	if i.HasContacts != nil {
		p := entity.HasContacts()
		if !*i.HasContacts {
			p = entity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasContactsWith) > 0 {
		with := make([]predicate.Contact, 0, len(i.HasContactsWith))
		for _, w := range i.HasContactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasContactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, entity.HasContactsWith(with...))
	}
	if i.HasDocuments != nil {
		p := entity.HasDocuments()
		if !*i.HasDocuments {
			p = entity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentsWith) > 0 {
		with := make([]predicate.DocumentData, 0, len(i.HasDocumentsWith))
		for _, w := range i.HasDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, entity.HasDocumentsWith(with...))
	}
	if i.HasNotes != nil {
		p := entity.HasNotes()
		if !*i.HasNotes {
			p = entity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNotesWith) > 0 {
		with := make([]predicate.Note, 0, len(i.HasNotesWith))
		for _, w := range i.HasNotesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNotesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, entity.HasNotesWith(with...))
	}
	if i.HasFiles != nil {
		p := entity.HasFiles()
		if !*i.HasFiles {
			p = entity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, entity.HasFilesWith(with...))
	}
	if i.HasEntityType != nil {
		p := entity.HasEntityType()
		if !*i.HasEntityType {
			p = entity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEntityTypeWith) > 0 {
		with := make([]predicate.EntityType, 0, len(i.HasEntityTypeWith))
		for _, w := range i.HasEntityTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEntityTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, entity.HasEntityTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEntityWhereInput
	case 1:
		return predicates[0], nil
	default:
		return entity.And(predicates...), nil
	}
}

// EntityHistoryWhereInput represents a where input for filtering EntityHistory queries.
type EntityHistoryWhereInput struct {
	Predicates []predicate.EntityHistory  `json:"-"`
	Not        *EntityHistoryWhereInput   `json:"not,omitempty"`
	Or         []*EntityHistoryWhereInput `json:"or,omitempty"`
	And        []*EntityHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "entity_type_id" field predicates.
	EntityTypeID             *string  `json:"entityTypeID,omitempty"`
	EntityTypeIDNEQ          *string  `json:"entityTypeIDNEQ,omitempty"`
	EntityTypeIDIn           []string `json:"entityTypeIDIn,omitempty"`
	EntityTypeIDNotIn        []string `json:"entityTypeIDNotIn,omitempty"`
	EntityTypeIDGT           *string  `json:"entityTypeIDGT,omitempty"`
	EntityTypeIDGTE          *string  `json:"entityTypeIDGTE,omitempty"`
	EntityTypeIDLT           *string  `json:"entityTypeIDLT,omitempty"`
	EntityTypeIDLTE          *string  `json:"entityTypeIDLTE,omitempty"`
	EntityTypeIDContains     *string  `json:"entityTypeIDContains,omitempty"`
	EntityTypeIDHasPrefix    *string  `json:"entityTypeIDHasPrefix,omitempty"`
	EntityTypeIDHasSuffix    *string  `json:"entityTypeIDHasSuffix,omitempty"`
	EntityTypeIDIsNil        bool     `json:"entityTypeIDIsNil,omitempty"`
	EntityTypeIDNotNil       bool     `json:"entityTypeIDNotNil,omitempty"`
	EntityTypeIDEqualFold    *string  `json:"entityTypeIDEqualFold,omitempty"`
	EntityTypeIDContainsFold *string  `json:"entityTypeIDContainsFold,omitempty"`

	// "status" field predicates.
	Status             *string  `json:"status,omitempty"`
	StatusNEQ          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGT           *string  `json:"statusGT,omitempty"`
	StatusGTE          *string  `json:"statusGTE,omitempty"`
	StatusLT           *string  `json:"statusLT,omitempty"`
	StatusLTE          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        bool     `json:"statusIsNil,omitempty"`
	StatusNotNil       bool     `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EntityHistoryWhereInput) AddPredicates(predicates ...predicate.EntityHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EntityHistoryWhereInput filter on the EntityHistoryQuery builder.
func (i *EntityHistoryWhereInput) Filter(q *EntityHistoryQuery) (*EntityHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEntityHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEntityHistoryWhereInput is returned in case the EntityHistoryWhereInput is empty.
var ErrEmptyEntityHistoryWhereInput = errors.New("generated: empty predicate EntityHistoryWhereInput")

// P returns a predicate for filtering entityhistories.
// An error is returned if the input is empty or invalid.
func (i *EntityHistoryWhereInput) P() (predicate.EntityHistory, error) {
	var predicates []predicate.EntityHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, entityhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.EntityHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, entityhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.EntityHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, entityhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, entityhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, entityhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, entityhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, entityhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, entityhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, entityhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, entityhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, entityhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, entityhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, entityhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, entityhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, entityhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, entityhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, entityhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, entityhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, entityhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, entityhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, entityhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, entityhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, entityhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, entityhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, entityhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, entityhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, entityhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, entityhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, entityhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, entityhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, entityhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, entityhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, entityhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, entityhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, entityhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, entityhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, entityhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, entityhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, entityhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, entityhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, entityhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, entityhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, entityhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, entityhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, entityhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, entityhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, entityhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, entityhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, entityhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, entityhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, entityhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, entityhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, entityhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, entityhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, entityhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, entityhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, entityhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, entityhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, entityhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, entityhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, entityhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, entityhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, entityhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, entityhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, entityhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, entityhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, entityhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, entityhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, entityhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, entityhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, entityhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, entityhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, entityhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, entityhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, entityhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, entityhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, entityhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, entityhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, entityhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, entityhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, entityhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, entityhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, entityhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, entityhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, entityhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, entityhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, entityhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, entityhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, entityhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, entityhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, entityhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, entityhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, entityhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, entityhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, entityhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, entityhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, entityhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, entityhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, entityhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, entityhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, entityhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, entityhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, entityhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, entityhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, entityhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, entityhistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, entityhistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, entityhistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, entityhistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, entityhistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, entityhistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, entityhistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, entityhistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, entityhistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, entityhistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, entityhistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, entityhistory.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, entityhistory.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, entityhistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, entityhistory.NameContainsFold(*i.NameContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, entityhistory.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, entityhistory.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, entityhistory.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, entityhistory.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, entityhistory.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, entityhistory.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, entityhistory.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, entityhistory.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, entityhistory.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, entityhistory.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, entityhistory.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, entityhistory.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, entityhistory.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, entityhistory.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, entityhistory.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.EntityTypeID != nil {
		predicates = append(predicates, entityhistory.EntityTypeIDEQ(*i.EntityTypeID))
	}
	if i.EntityTypeIDNEQ != nil {
		predicates = append(predicates, entityhistory.EntityTypeIDNEQ(*i.EntityTypeIDNEQ))
	}
	if len(i.EntityTypeIDIn) > 0 {
		predicates = append(predicates, entityhistory.EntityTypeIDIn(i.EntityTypeIDIn...))
	}
	if len(i.EntityTypeIDNotIn) > 0 {
		predicates = append(predicates, entityhistory.EntityTypeIDNotIn(i.EntityTypeIDNotIn...))
	}
	if i.EntityTypeIDGT != nil {
		predicates = append(predicates, entityhistory.EntityTypeIDGT(*i.EntityTypeIDGT))
	}
	if i.EntityTypeIDGTE != nil {
		predicates = append(predicates, entityhistory.EntityTypeIDGTE(*i.EntityTypeIDGTE))
	}
	if i.EntityTypeIDLT != nil {
		predicates = append(predicates, entityhistory.EntityTypeIDLT(*i.EntityTypeIDLT))
	}
	if i.EntityTypeIDLTE != nil {
		predicates = append(predicates, entityhistory.EntityTypeIDLTE(*i.EntityTypeIDLTE))
	}
	if i.EntityTypeIDContains != nil {
		predicates = append(predicates, entityhistory.EntityTypeIDContains(*i.EntityTypeIDContains))
	}
	if i.EntityTypeIDHasPrefix != nil {
		predicates = append(predicates, entityhistory.EntityTypeIDHasPrefix(*i.EntityTypeIDHasPrefix))
	}
	if i.EntityTypeIDHasSuffix != nil {
		predicates = append(predicates, entityhistory.EntityTypeIDHasSuffix(*i.EntityTypeIDHasSuffix))
	}
	if i.EntityTypeIDIsNil {
		predicates = append(predicates, entityhistory.EntityTypeIDIsNil())
	}
	if i.EntityTypeIDNotNil {
		predicates = append(predicates, entityhistory.EntityTypeIDNotNil())
	}
	if i.EntityTypeIDEqualFold != nil {
		predicates = append(predicates, entityhistory.EntityTypeIDEqualFold(*i.EntityTypeIDEqualFold))
	}
	if i.EntityTypeIDContainsFold != nil {
		predicates = append(predicates, entityhistory.EntityTypeIDContainsFold(*i.EntityTypeIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, entityhistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, entityhistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, entityhistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, entityhistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusGT != nil {
		predicates = append(predicates, entityhistory.StatusGT(*i.StatusGT))
	}
	if i.StatusGTE != nil {
		predicates = append(predicates, entityhistory.StatusGTE(*i.StatusGTE))
	}
	if i.StatusLT != nil {
		predicates = append(predicates, entityhistory.StatusLT(*i.StatusLT))
	}
	if i.StatusLTE != nil {
		predicates = append(predicates, entityhistory.StatusLTE(*i.StatusLTE))
	}
	if i.StatusContains != nil {
		predicates = append(predicates, entityhistory.StatusContains(*i.StatusContains))
	}
	if i.StatusHasPrefix != nil {
		predicates = append(predicates, entityhistory.StatusHasPrefix(*i.StatusHasPrefix))
	}
	if i.StatusHasSuffix != nil {
		predicates = append(predicates, entityhistory.StatusHasSuffix(*i.StatusHasSuffix))
	}
	if i.StatusIsNil {
		predicates = append(predicates, entityhistory.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, entityhistory.StatusNotNil())
	}
	if i.StatusEqualFold != nil {
		predicates = append(predicates, entityhistory.StatusEqualFold(*i.StatusEqualFold))
	}
	if i.StatusContainsFold != nil {
		predicates = append(predicates, entityhistory.StatusContainsFold(*i.StatusContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEntityHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return entityhistory.And(predicates...), nil
	}
}

// EntityTypeWhereInput represents a where input for filtering EntityType queries.
type EntityTypeWhereInput struct {
	Predicates []predicate.EntityType  `json:"-"`
	Not        *EntityTypeWhereInput   `json:"not,omitempty"`
	Or         []*EntityTypeWhereInput `json:"or,omitempty"`
	And        []*EntityTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "entities" edge predicates.
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EntityTypeWhereInput) AddPredicates(predicates ...predicate.EntityType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EntityTypeWhereInput filter on the EntityTypeQuery builder.
func (i *EntityTypeWhereInput) Filter(q *EntityTypeQuery) (*EntityTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEntityTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEntityTypeWhereInput is returned in case the EntityTypeWhereInput is empty.
var ErrEmptyEntityTypeWhereInput = errors.New("generated: empty predicate EntityTypeWhereInput")

// P returns a predicate for filtering entitytypes.
// An error is returned if the input is empty or invalid.
func (i *EntityTypeWhereInput) P() (predicate.EntityType, error) {
	var predicates []predicate.EntityType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, entitytype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.EntityType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, entitytype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.EntityType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, entitytype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, entitytype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, entitytype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, entitytype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, entitytype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, entitytype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, entitytype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, entitytype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, entitytype.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, entitytype.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, entitytype.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, entitytype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, entitytype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, entitytype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, entitytype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, entitytype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, entitytype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, entitytype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, entitytype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, entitytype.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, entitytype.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, entitytype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, entitytype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, entitytype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, entitytype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, entitytype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, entitytype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, entitytype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, entitytype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, entitytype.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, entitytype.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, entitytype.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, entitytype.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, entitytype.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, entitytype.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, entitytype.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, entitytype.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, entitytype.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, entitytype.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, entitytype.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, entitytype.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, entitytype.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, entitytype.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, entitytype.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, entitytype.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, entitytype.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, entitytype.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, entitytype.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, entitytype.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, entitytype.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, entitytype.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, entitytype.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, entitytype.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, entitytype.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, entitytype.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, entitytype.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, entitytype.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, entitytype.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, entitytype.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, entitytype.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, entitytype.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, entitytype.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, entitytype.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, entitytype.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, entitytype.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, entitytype.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, entitytype.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, entitytype.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, entitytype.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, entitytype.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, entitytype.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, entitytype.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, entitytype.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, entitytype.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, entitytype.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, entitytype.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, entitytype.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, entitytype.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, entitytype.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, entitytype.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, entitytype.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, entitytype.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, entitytype.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, entitytype.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, entitytype.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, entitytype.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, entitytype.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, entitytype.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, entitytype.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasOwner != nil {
		p := entitytype.HasOwner()
		if !*i.HasOwner {
			p = entitytype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, entitytype.HasOwnerWith(with...))
	}
	if i.HasEntities != nil {
		p := entitytype.HasEntities()
		if !*i.HasEntities {
			p = entitytype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEntitiesWith) > 0 {
		with := make([]predicate.Entity, 0, len(i.HasEntitiesWith))
		for _, w := range i.HasEntitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEntitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, entitytype.HasEntitiesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEntityTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return entitytype.And(predicates...), nil
	}
}

// EntityTypeHistoryWhereInput represents a where input for filtering EntityTypeHistory queries.
type EntityTypeHistoryWhereInput struct {
	Predicates []predicate.EntityTypeHistory  `json:"-"`
	Not        *EntityTypeHistoryWhereInput   `json:"not,omitempty"`
	Or         []*EntityTypeHistoryWhereInput `json:"or,omitempty"`
	And        []*EntityTypeHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EntityTypeHistoryWhereInput) AddPredicates(predicates ...predicate.EntityTypeHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EntityTypeHistoryWhereInput filter on the EntityTypeHistoryQuery builder.
func (i *EntityTypeHistoryWhereInput) Filter(q *EntityTypeHistoryQuery) (*EntityTypeHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEntityTypeHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEntityTypeHistoryWhereInput is returned in case the EntityTypeHistoryWhereInput is empty.
var ErrEmptyEntityTypeHistoryWhereInput = errors.New("generated: empty predicate EntityTypeHistoryWhereInput")

// P returns a predicate for filtering entitytypehistories.
// An error is returned if the input is empty or invalid.
func (i *EntityTypeHistoryWhereInput) P() (predicate.EntityTypeHistory, error) {
	var predicates []predicate.EntityTypeHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, entitytypehistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.EntityTypeHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, entitytypehistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.EntityTypeHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, entitytypehistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, entitytypehistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, entitytypehistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, entitytypehistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, entitytypehistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, entitytypehistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, entitytypehistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, entitytypehistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, entitytypehistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, entitytypehistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, entitytypehistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, entitytypehistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, entitytypehistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, entitytypehistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, entitytypehistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, entitytypehistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, entitytypehistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, entitytypehistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, entitytypehistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, entitytypehistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, entitytypehistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, entitytypehistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, entitytypehistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, entitytypehistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, entitytypehistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, entitytypehistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, entitytypehistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, entitytypehistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, entitytypehistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, entitytypehistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, entitytypehistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, entitytypehistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, entitytypehistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, entitytypehistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, entitytypehistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, entitytypehistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, entitytypehistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, entitytypehistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, entitytypehistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, entitytypehistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, entitytypehistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, entitytypehistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, entitytypehistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, entitytypehistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, entitytypehistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, entitytypehistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, entitytypehistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, entitytypehistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, entitytypehistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, entitytypehistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, entitytypehistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, entitytypehistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, entitytypehistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, entitytypehistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, entitytypehistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, entitytypehistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, entitytypehistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, entitytypehistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, entitytypehistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, entitytypehistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, entitytypehistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, entitytypehistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, entitytypehistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, entitytypehistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, entitytypehistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, entitytypehistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, entitytypehistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, entitytypehistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, entitytypehistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, entitytypehistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, entitytypehistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, entitytypehistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, entitytypehistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, entitytypehistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, entitytypehistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, entitytypehistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, entitytypehistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, entitytypehistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, entitytypehistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, entitytypehistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, entitytypehistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, entitytypehistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, entitytypehistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, entitytypehistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, entitytypehistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, entitytypehistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, entitytypehistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, entitytypehistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, entitytypehistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, entitytypehistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, entitytypehistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, entitytypehistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, entitytypehistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, entitytypehistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, entitytypehistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, entitytypehistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, entitytypehistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, entitytypehistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, entitytypehistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, entitytypehistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, entitytypehistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, entitytypehistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, entitytypehistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, entitytypehistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, entitytypehistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, entitytypehistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, entitytypehistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, entitytypehistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, entitytypehistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, entitytypehistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, entitytypehistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, entitytypehistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, entitytypehistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, entitytypehistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, entitytypehistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, entitytypehistory.NameContainsFold(*i.NameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEntityTypeHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return entitytypehistory.And(predicates...), nil
	}
}

// EventWhereInput represents a where input for filtering Event queries.
type EventWhereInput struct {
	Predicates []predicate.Event  `json:"-"`
	Not        *EventWhereInput   `json:"not,omitempty"`
	Or         []*EventWhereInput `json:"or,omitempty"`
	And        []*EventWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "event_id" field predicates.
	EventID             *string  `json:"eventID,omitempty"`
	EventIDNEQ          *string  `json:"eventIDNEQ,omitempty"`
	EventIDIn           []string `json:"eventIDIn,omitempty"`
	EventIDNotIn        []string `json:"eventIDNotIn,omitempty"`
	EventIDGT           *string  `json:"eventIDGT,omitempty"`
	EventIDGTE          *string  `json:"eventIDGTE,omitempty"`
	EventIDLT           *string  `json:"eventIDLT,omitempty"`
	EventIDLTE          *string  `json:"eventIDLTE,omitempty"`
	EventIDContains     *string  `json:"eventIDContains,omitempty"`
	EventIDHasPrefix    *string  `json:"eventIDHasPrefix,omitempty"`
	EventIDHasSuffix    *string  `json:"eventIDHasSuffix,omitempty"`
	EventIDIsNil        bool     `json:"eventIDIsNil,omitempty"`
	EventIDNotNil       bool     `json:"eventIDNotNil,omitempty"`
	EventIDEqualFold    *string  `json:"eventIDEqualFold,omitempty"`
	EventIDContainsFold *string  `json:"eventIDContainsFold,omitempty"`

	// "correlation_id" field predicates.
	CorrelationID             *string  `json:"correlationID,omitempty"`
	CorrelationIDNEQ          *string  `json:"correlationIDNEQ,omitempty"`
	CorrelationIDIn           []string `json:"correlationIDIn,omitempty"`
	CorrelationIDNotIn        []string `json:"correlationIDNotIn,omitempty"`
	CorrelationIDGT           *string  `json:"correlationIDGT,omitempty"`
	CorrelationIDGTE          *string  `json:"correlationIDGTE,omitempty"`
	CorrelationIDLT           *string  `json:"correlationIDLT,omitempty"`
	CorrelationIDLTE          *string  `json:"correlationIDLTE,omitempty"`
	CorrelationIDContains     *string  `json:"correlationIDContains,omitempty"`
	CorrelationIDHasPrefix    *string  `json:"correlationIDHasPrefix,omitempty"`
	CorrelationIDHasSuffix    *string  `json:"correlationIDHasSuffix,omitempty"`
	CorrelationIDIsNil        bool     `json:"correlationIDIsNil,omitempty"`
	CorrelationIDNotNil       bool     `json:"correlationIDNotNil,omitempty"`
	CorrelationIDEqualFold    *string  `json:"correlationIDEqualFold,omitempty"`
	CorrelationIDContainsFold *string  `json:"correlationIDContainsFold,omitempty"`

	// "event_type" field predicates.
	EventType             *string  `json:"eventType,omitempty"`
	EventTypeNEQ          *string  `json:"eventTypeNEQ,omitempty"`
	EventTypeIn           []string `json:"eventTypeIn,omitempty"`
	EventTypeNotIn        []string `json:"eventTypeNotIn,omitempty"`
	EventTypeGT           *string  `json:"eventTypeGT,omitempty"`
	EventTypeGTE          *string  `json:"eventTypeGTE,omitempty"`
	EventTypeLT           *string  `json:"eventTypeLT,omitempty"`
	EventTypeLTE          *string  `json:"eventTypeLTE,omitempty"`
	EventTypeContains     *string  `json:"eventTypeContains,omitempty"`
	EventTypeHasPrefix    *string  `json:"eventTypeHasPrefix,omitempty"`
	EventTypeHasSuffix    *string  `json:"eventTypeHasSuffix,omitempty"`
	EventTypeEqualFold    *string  `json:"eventTypeEqualFold,omitempty"`
	EventTypeContainsFold *string  `json:"eventTypeContainsFold,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "groups" edge predicates.
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`

	// "integrations" edge predicates.
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`

	// "organizations" edge predicates.
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`

	// "invites" edge predicates.
	HasInvites     *bool               `json:"hasInvites,omitempty"`
	HasInvitesWith []*InviteWhereInput `json:"hasInvitesWith,omitempty"`

	// "personal_access_tokens" edge predicates.
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`

	// "secrets" edge predicates.
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`

	// "orgmemberships" edge predicates.
	HasOrgmemberships     *bool                      `json:"hasOrgmemberships,omitempty"`
	HasOrgmembershipsWith []*OrgMembershipWhereInput `json:"hasOrgmembershipsWith,omitempty"`

	// "groupmemberships" edge predicates.
	HasGroupmemberships     *bool                        `json:"hasGroupmemberships,omitempty"`
	HasGroupmembershipsWith []*GroupMembershipWhereInput `json:"hasGroupmembershipsWith,omitempty"`

	// "subscribers" edge predicates.
	HasSubscribers     *bool                   `json:"hasSubscribers,omitempty"`
	HasSubscribersWith []*SubscriberWhereInput `json:"hasSubscribersWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`

	// "org_subscriptions" edge predicates.
	HasOrgSubscriptions     *bool                        `json:"hasOrgSubscriptions,omitempty"`
	HasOrgSubscriptionsWith []*OrgSubscriptionWhereInput `json:"hasOrgSubscriptionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EventWhereInput) AddPredicates(predicates ...predicate.Event) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EventWhereInput filter on the EventQuery builder.
func (i *EventWhereInput) Filter(q *EventQuery) (*EventQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEventWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEventWhereInput is returned in case the EventWhereInput is empty.
var ErrEmptyEventWhereInput = errors.New("generated: empty predicate EventWhereInput")

// P returns a predicate for filtering events.
// An error is returned if the input is empty or invalid.
func (i *EventWhereInput) P() (predicate.Event, error) {
	var predicates []predicate.Event
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, event.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Event, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, event.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Event, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, event.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, event.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, event.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, event.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, event.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, event.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, event.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, event.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, event.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, event.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, event.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, event.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, event.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, event.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, event.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, event.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, event.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, event.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, event.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, event.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, event.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, event.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, event.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, event.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, event.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, event.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, event.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, event.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, event.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, event.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, event.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, event.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, event.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, event.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, event.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, event.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, event.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, event.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, event.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, event.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, event.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, event.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, event.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, event.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, event.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, event.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, event.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, event.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, event.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, event.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, event.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, event.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, event.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, event.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, event.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, event.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, event.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, event.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, event.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, event.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, event.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.EventID != nil {
		predicates = append(predicates, event.EventIDEQ(*i.EventID))
	}
	if i.EventIDNEQ != nil {
		predicates = append(predicates, event.EventIDNEQ(*i.EventIDNEQ))
	}
	if len(i.EventIDIn) > 0 {
		predicates = append(predicates, event.EventIDIn(i.EventIDIn...))
	}
	if len(i.EventIDNotIn) > 0 {
		predicates = append(predicates, event.EventIDNotIn(i.EventIDNotIn...))
	}
	if i.EventIDGT != nil {
		predicates = append(predicates, event.EventIDGT(*i.EventIDGT))
	}
	if i.EventIDGTE != nil {
		predicates = append(predicates, event.EventIDGTE(*i.EventIDGTE))
	}
	if i.EventIDLT != nil {
		predicates = append(predicates, event.EventIDLT(*i.EventIDLT))
	}
	if i.EventIDLTE != nil {
		predicates = append(predicates, event.EventIDLTE(*i.EventIDLTE))
	}
	if i.EventIDContains != nil {
		predicates = append(predicates, event.EventIDContains(*i.EventIDContains))
	}
	if i.EventIDHasPrefix != nil {
		predicates = append(predicates, event.EventIDHasPrefix(*i.EventIDHasPrefix))
	}
	if i.EventIDHasSuffix != nil {
		predicates = append(predicates, event.EventIDHasSuffix(*i.EventIDHasSuffix))
	}
	if i.EventIDIsNil {
		predicates = append(predicates, event.EventIDIsNil())
	}
	if i.EventIDNotNil {
		predicates = append(predicates, event.EventIDNotNil())
	}
	if i.EventIDEqualFold != nil {
		predicates = append(predicates, event.EventIDEqualFold(*i.EventIDEqualFold))
	}
	if i.EventIDContainsFold != nil {
		predicates = append(predicates, event.EventIDContainsFold(*i.EventIDContainsFold))
	}
	if i.CorrelationID != nil {
		predicates = append(predicates, event.CorrelationIDEQ(*i.CorrelationID))
	}
	if i.CorrelationIDNEQ != nil {
		predicates = append(predicates, event.CorrelationIDNEQ(*i.CorrelationIDNEQ))
	}
	if len(i.CorrelationIDIn) > 0 {
		predicates = append(predicates, event.CorrelationIDIn(i.CorrelationIDIn...))
	}
	if len(i.CorrelationIDNotIn) > 0 {
		predicates = append(predicates, event.CorrelationIDNotIn(i.CorrelationIDNotIn...))
	}
	if i.CorrelationIDGT != nil {
		predicates = append(predicates, event.CorrelationIDGT(*i.CorrelationIDGT))
	}
	if i.CorrelationIDGTE != nil {
		predicates = append(predicates, event.CorrelationIDGTE(*i.CorrelationIDGTE))
	}
	if i.CorrelationIDLT != nil {
		predicates = append(predicates, event.CorrelationIDLT(*i.CorrelationIDLT))
	}
	if i.CorrelationIDLTE != nil {
		predicates = append(predicates, event.CorrelationIDLTE(*i.CorrelationIDLTE))
	}
	if i.CorrelationIDContains != nil {
		predicates = append(predicates, event.CorrelationIDContains(*i.CorrelationIDContains))
	}
	if i.CorrelationIDHasPrefix != nil {
		predicates = append(predicates, event.CorrelationIDHasPrefix(*i.CorrelationIDHasPrefix))
	}
	if i.CorrelationIDHasSuffix != nil {
		predicates = append(predicates, event.CorrelationIDHasSuffix(*i.CorrelationIDHasSuffix))
	}
	if i.CorrelationIDIsNil {
		predicates = append(predicates, event.CorrelationIDIsNil())
	}
	if i.CorrelationIDNotNil {
		predicates = append(predicates, event.CorrelationIDNotNil())
	}
	if i.CorrelationIDEqualFold != nil {
		predicates = append(predicates, event.CorrelationIDEqualFold(*i.CorrelationIDEqualFold))
	}
	if i.CorrelationIDContainsFold != nil {
		predicates = append(predicates, event.CorrelationIDContainsFold(*i.CorrelationIDContainsFold))
	}
	if i.EventType != nil {
		predicates = append(predicates, event.EventTypeEQ(*i.EventType))
	}
	if i.EventTypeNEQ != nil {
		predicates = append(predicates, event.EventTypeNEQ(*i.EventTypeNEQ))
	}
	if len(i.EventTypeIn) > 0 {
		predicates = append(predicates, event.EventTypeIn(i.EventTypeIn...))
	}
	if len(i.EventTypeNotIn) > 0 {
		predicates = append(predicates, event.EventTypeNotIn(i.EventTypeNotIn...))
	}
	if i.EventTypeGT != nil {
		predicates = append(predicates, event.EventTypeGT(*i.EventTypeGT))
	}
	if i.EventTypeGTE != nil {
		predicates = append(predicates, event.EventTypeGTE(*i.EventTypeGTE))
	}
	if i.EventTypeLT != nil {
		predicates = append(predicates, event.EventTypeLT(*i.EventTypeLT))
	}
	if i.EventTypeLTE != nil {
		predicates = append(predicates, event.EventTypeLTE(*i.EventTypeLTE))
	}
	if i.EventTypeContains != nil {
		predicates = append(predicates, event.EventTypeContains(*i.EventTypeContains))
	}
	if i.EventTypeHasPrefix != nil {
		predicates = append(predicates, event.EventTypeHasPrefix(*i.EventTypeHasPrefix))
	}
	if i.EventTypeHasSuffix != nil {
		predicates = append(predicates, event.EventTypeHasSuffix(*i.EventTypeHasSuffix))
	}
	if i.EventTypeEqualFold != nil {
		predicates = append(predicates, event.EventTypeEqualFold(*i.EventTypeEqualFold))
	}
	if i.EventTypeContainsFold != nil {
		predicates = append(predicates, event.EventTypeContainsFold(*i.EventTypeContainsFold))
	}

	if i.HasUsers != nil {
		p := event.HasUsers()
		if !*i.HasUsers {
			p = event.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, event.HasUsersWith(with...))
	}
	if i.HasGroups != nil {
		p := event.HasGroups()
		if !*i.HasGroups {
			p = event.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasGroupsWith))
		for _, w := range i.HasGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, event.HasGroupsWith(with...))
	}
	if i.HasIntegrations != nil {
		p := event.HasIntegrations()
		if !*i.HasIntegrations {
			p = event.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIntegrationsWith) > 0 {
		with := make([]predicate.Integration, 0, len(i.HasIntegrationsWith))
		for _, w := range i.HasIntegrationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasIntegrationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, event.HasIntegrationsWith(with...))
	}
	if i.HasOrganizations != nil {
		p := event.HasOrganizations()
		if !*i.HasOrganizations {
			p = event.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrganizationsWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOrganizationsWith))
		for _, w := range i.HasOrganizationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrganizationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, event.HasOrganizationsWith(with...))
	}
	if i.HasInvites != nil {
		p := event.HasInvites()
		if !*i.HasInvites {
			p = event.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInvitesWith) > 0 {
		with := make([]predicate.Invite, 0, len(i.HasInvitesWith))
		for _, w := range i.HasInvitesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInvitesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, event.HasInvitesWith(with...))
	}
	if i.HasPersonalAccessTokens != nil {
		p := event.HasPersonalAccessTokens()
		if !*i.HasPersonalAccessTokens {
			p = event.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPersonalAccessTokensWith) > 0 {
		with := make([]predicate.PersonalAccessToken, 0, len(i.HasPersonalAccessTokensWith))
		for _, w := range i.HasPersonalAccessTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPersonalAccessTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, event.HasPersonalAccessTokensWith(with...))
	}
	if i.HasSecrets != nil {
		p := event.HasSecrets()
		if !*i.HasSecrets {
			p = event.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSecretsWith) > 0 {
		with := make([]predicate.Hush, 0, len(i.HasSecretsWith))
		for _, w := range i.HasSecretsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSecretsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, event.HasSecretsWith(with...))
	}
	if i.HasOrgmemberships != nil {
		p := event.HasOrgmemberships()
		if !*i.HasOrgmemberships {
			p = event.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrgmembershipsWith) > 0 {
		with := make([]predicate.OrgMembership, 0, len(i.HasOrgmembershipsWith))
		for _, w := range i.HasOrgmembershipsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrgmembershipsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, event.HasOrgmembershipsWith(with...))
	}
	if i.HasGroupmemberships != nil {
		p := event.HasGroupmemberships()
		if !*i.HasGroupmemberships {
			p = event.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupmembershipsWith) > 0 {
		with := make([]predicate.GroupMembership, 0, len(i.HasGroupmembershipsWith))
		for _, w := range i.HasGroupmembershipsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGroupmembershipsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, event.HasGroupmembershipsWith(with...))
	}
	if i.HasSubscribers != nil {
		p := event.HasSubscribers()
		if !*i.HasSubscribers {
			p = event.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubscribersWith) > 0 {
		with := make([]predicate.Subscriber, 0, len(i.HasSubscribersWith))
		for _, w := range i.HasSubscribersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubscribersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, event.HasSubscribersWith(with...))
	}
	if i.HasFiles != nil {
		p := event.HasFiles()
		if !*i.HasFiles {
			p = event.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, event.HasFilesWith(with...))
	}
	if i.HasOrgSubscriptions != nil {
		p := event.HasOrgSubscriptions()
		if !*i.HasOrgSubscriptions {
			p = event.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrgSubscriptionsWith) > 0 {
		with := make([]predicate.OrgSubscription, 0, len(i.HasOrgSubscriptionsWith))
		for _, w := range i.HasOrgSubscriptionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrgSubscriptionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, event.HasOrgSubscriptionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEventWhereInput
	case 1:
		return predicates[0], nil
	default:
		return event.And(predicates...), nil
	}
}

// EvidenceWhereInput represents a where input for filtering Evidence queries.
type EvidenceWhereInput struct {
	Predicates []predicate.Evidence  `json:"-"`
	Not        *EvidenceWhereInput   `json:"not,omitempty"`
	Or         []*EvidenceWhereInput `json:"or,omitempty"`
	And        []*EvidenceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "collection_procedure" field predicates.
	CollectionProcedure             *string  `json:"collectionProcedure,omitempty"`
	CollectionProcedureNEQ          *string  `json:"collectionProcedureNEQ,omitempty"`
	CollectionProcedureIn           []string `json:"collectionProcedureIn,omitempty"`
	CollectionProcedureNotIn        []string `json:"collectionProcedureNotIn,omitempty"`
	CollectionProcedureGT           *string  `json:"collectionProcedureGT,omitempty"`
	CollectionProcedureGTE          *string  `json:"collectionProcedureGTE,omitempty"`
	CollectionProcedureLT           *string  `json:"collectionProcedureLT,omitempty"`
	CollectionProcedureLTE          *string  `json:"collectionProcedureLTE,omitempty"`
	CollectionProcedureContains     *string  `json:"collectionProcedureContains,omitempty"`
	CollectionProcedureHasPrefix    *string  `json:"collectionProcedureHasPrefix,omitempty"`
	CollectionProcedureHasSuffix    *string  `json:"collectionProcedureHasSuffix,omitempty"`
	CollectionProcedureIsNil        bool     `json:"collectionProcedureIsNil,omitempty"`
	CollectionProcedureNotNil       bool     `json:"collectionProcedureNotNil,omitempty"`
	CollectionProcedureEqualFold    *string  `json:"collectionProcedureEqualFold,omitempty"`
	CollectionProcedureContainsFold *string  `json:"collectionProcedureContainsFold,omitempty"`

	// "creation_date" field predicates.
	CreationDate      *time.Time  `json:"creationDate,omitempty"`
	CreationDateNEQ   *time.Time  `json:"creationDateNEQ,omitempty"`
	CreationDateIn    []time.Time `json:"creationDateIn,omitempty"`
	CreationDateNotIn []time.Time `json:"creationDateNotIn,omitempty"`
	CreationDateGT    *time.Time  `json:"creationDateGT,omitempty"`
	CreationDateGTE   *time.Time  `json:"creationDateGTE,omitempty"`
	CreationDateLT    *time.Time  `json:"creationDateLT,omitempty"`
	CreationDateLTE   *time.Time  `json:"creationDateLTE,omitempty"`

	// "renewal_date" field predicates.
	RenewalDate       *time.Time  `json:"renewalDate,omitempty"`
	RenewalDateNEQ    *time.Time  `json:"renewalDateNEQ,omitempty"`
	RenewalDateIn     []time.Time `json:"renewalDateIn,omitempty"`
	RenewalDateNotIn  []time.Time `json:"renewalDateNotIn,omitempty"`
	RenewalDateGT     *time.Time  `json:"renewalDateGT,omitempty"`
	RenewalDateGTE    *time.Time  `json:"renewalDateGTE,omitempty"`
	RenewalDateLT     *time.Time  `json:"renewalDateLT,omitempty"`
	RenewalDateLTE    *time.Time  `json:"renewalDateLTE,omitempty"`
	RenewalDateIsNil  bool        `json:"renewalDateIsNil,omitempty"`
	RenewalDateNotNil bool        `json:"renewalDateNotNil,omitempty"`

	// "source" field predicates.
	Source             *string  `json:"source,omitempty"`
	SourceNEQ          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGT           *string  `json:"sourceGT,omitempty"`
	SourceGTE          *string  `json:"sourceGTE,omitempty"`
	SourceLT           *string  `json:"sourceLT,omitempty"`
	SourceLTE          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        bool     `json:"sourceIsNil,omitempty"`
	SourceNotNil       bool     `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`

	// "is_automated" field predicates.
	IsAutomated       *bool `json:"isAutomated,omitempty"`
	IsAutomatedNEQ    *bool `json:"isAutomatedNEQ,omitempty"`
	IsAutomatedIsNil  bool  `json:"isAutomatedIsNil,omitempty"`
	IsAutomatedNotNil bool  `json:"isAutomatedNotNil,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        bool     `json:"urlIsNil,omitempty"`
	URLNotNil       bool     `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.EvidenceStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.EvidenceStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.EvidenceStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.EvidenceStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                   `json:"statusIsNil,omitempty"`
	StatusNotNil bool                   `json:"statusNotNil,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "control_objectives" edge predicates.
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`

	// "controls" edge predicates.
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`

	// "subcontrols" edge predicates.
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`

	// "programs" edge predicates.
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EvidenceWhereInput) AddPredicates(predicates ...predicate.Evidence) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EvidenceWhereInput filter on the EvidenceQuery builder.
func (i *EvidenceWhereInput) Filter(q *EvidenceQuery) (*EvidenceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEvidenceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEvidenceWhereInput is returned in case the EvidenceWhereInput is empty.
var ErrEmptyEvidenceWhereInput = errors.New("generated: empty predicate EvidenceWhereInput")

// P returns a predicate for filtering evidences.
// An error is returned if the input is empty or invalid.
func (i *EvidenceWhereInput) P() (predicate.Evidence, error) {
	var predicates []predicate.Evidence
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, evidence.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Evidence, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, evidence.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Evidence, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, evidence.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, evidence.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, evidence.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, evidence.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, evidence.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, evidence.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, evidence.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, evidence.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, evidence.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, evidence.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, evidence.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, evidence.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, evidence.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, evidence.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, evidence.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, evidence.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, evidence.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, evidence.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, evidence.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, evidence.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, evidence.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, evidence.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, evidence.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, evidence.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, evidence.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, evidence.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, evidence.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, evidence.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, evidence.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, evidence.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, evidence.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, evidence.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, evidence.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, evidence.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, evidence.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, evidence.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, evidence.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, evidence.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, evidence.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, evidence.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, evidence.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, evidence.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, evidence.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, evidence.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, evidence.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, evidence.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, evidence.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, evidence.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, evidence.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, evidence.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, evidence.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, evidence.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, evidence.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, evidence.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, evidence.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, evidence.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, evidence.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, evidence.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, evidence.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, evidence.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, evidence.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, evidence.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, evidence.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, evidence.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, evidence.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, evidence.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, evidence.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, evidence.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, evidence.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, evidence.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, evidence.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, evidence.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, evidence.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, evidence.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, evidence.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, evidence.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, evidence.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, evidence.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, evidence.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, evidence.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, evidence.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, evidence.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, evidence.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, evidence.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, evidence.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, evidence.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, evidence.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, evidence.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, evidence.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, evidence.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, evidence.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, evidence.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, evidence.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, evidence.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, evidence.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, evidence.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, evidence.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, evidence.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, evidence.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, evidence.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, evidence.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, evidence.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, evidence.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, evidence.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, evidence.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, evidence.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, evidence.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, evidence.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, evidence.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, evidence.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, evidence.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, evidence.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, evidence.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, evidence.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, evidence.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, evidence.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, evidence.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.CollectionProcedure != nil {
		predicates = append(predicates, evidence.CollectionProcedureEQ(*i.CollectionProcedure))
	}
	if i.CollectionProcedureNEQ != nil {
		predicates = append(predicates, evidence.CollectionProcedureNEQ(*i.CollectionProcedureNEQ))
	}
	if len(i.CollectionProcedureIn) > 0 {
		predicates = append(predicates, evidence.CollectionProcedureIn(i.CollectionProcedureIn...))
	}
	if len(i.CollectionProcedureNotIn) > 0 {
		predicates = append(predicates, evidence.CollectionProcedureNotIn(i.CollectionProcedureNotIn...))
	}
	if i.CollectionProcedureGT != nil {
		predicates = append(predicates, evidence.CollectionProcedureGT(*i.CollectionProcedureGT))
	}
	if i.CollectionProcedureGTE != nil {
		predicates = append(predicates, evidence.CollectionProcedureGTE(*i.CollectionProcedureGTE))
	}
	if i.CollectionProcedureLT != nil {
		predicates = append(predicates, evidence.CollectionProcedureLT(*i.CollectionProcedureLT))
	}
	if i.CollectionProcedureLTE != nil {
		predicates = append(predicates, evidence.CollectionProcedureLTE(*i.CollectionProcedureLTE))
	}
	if i.CollectionProcedureContains != nil {
		predicates = append(predicates, evidence.CollectionProcedureContains(*i.CollectionProcedureContains))
	}
	if i.CollectionProcedureHasPrefix != nil {
		predicates = append(predicates, evidence.CollectionProcedureHasPrefix(*i.CollectionProcedureHasPrefix))
	}
	if i.CollectionProcedureHasSuffix != nil {
		predicates = append(predicates, evidence.CollectionProcedureHasSuffix(*i.CollectionProcedureHasSuffix))
	}
	if i.CollectionProcedureIsNil {
		predicates = append(predicates, evidence.CollectionProcedureIsNil())
	}
	if i.CollectionProcedureNotNil {
		predicates = append(predicates, evidence.CollectionProcedureNotNil())
	}
	if i.CollectionProcedureEqualFold != nil {
		predicates = append(predicates, evidence.CollectionProcedureEqualFold(*i.CollectionProcedureEqualFold))
	}
	if i.CollectionProcedureContainsFold != nil {
		predicates = append(predicates, evidence.CollectionProcedureContainsFold(*i.CollectionProcedureContainsFold))
	}
	if i.CreationDate != nil {
		predicates = append(predicates, evidence.CreationDateEQ(*i.CreationDate))
	}
	if i.CreationDateNEQ != nil {
		predicates = append(predicates, evidence.CreationDateNEQ(*i.CreationDateNEQ))
	}
	if len(i.CreationDateIn) > 0 {
		predicates = append(predicates, evidence.CreationDateIn(i.CreationDateIn...))
	}
	if len(i.CreationDateNotIn) > 0 {
		predicates = append(predicates, evidence.CreationDateNotIn(i.CreationDateNotIn...))
	}
	if i.CreationDateGT != nil {
		predicates = append(predicates, evidence.CreationDateGT(*i.CreationDateGT))
	}
	if i.CreationDateGTE != nil {
		predicates = append(predicates, evidence.CreationDateGTE(*i.CreationDateGTE))
	}
	if i.CreationDateLT != nil {
		predicates = append(predicates, evidence.CreationDateLT(*i.CreationDateLT))
	}
	if i.CreationDateLTE != nil {
		predicates = append(predicates, evidence.CreationDateLTE(*i.CreationDateLTE))
	}
	if i.RenewalDate != nil {
		predicates = append(predicates, evidence.RenewalDateEQ(*i.RenewalDate))
	}
	if i.RenewalDateNEQ != nil {
		predicates = append(predicates, evidence.RenewalDateNEQ(*i.RenewalDateNEQ))
	}
	if len(i.RenewalDateIn) > 0 {
		predicates = append(predicates, evidence.RenewalDateIn(i.RenewalDateIn...))
	}
	if len(i.RenewalDateNotIn) > 0 {
		predicates = append(predicates, evidence.RenewalDateNotIn(i.RenewalDateNotIn...))
	}
	if i.RenewalDateGT != nil {
		predicates = append(predicates, evidence.RenewalDateGT(*i.RenewalDateGT))
	}
	if i.RenewalDateGTE != nil {
		predicates = append(predicates, evidence.RenewalDateGTE(*i.RenewalDateGTE))
	}
	if i.RenewalDateLT != nil {
		predicates = append(predicates, evidence.RenewalDateLT(*i.RenewalDateLT))
	}
	if i.RenewalDateLTE != nil {
		predicates = append(predicates, evidence.RenewalDateLTE(*i.RenewalDateLTE))
	}
	if i.RenewalDateIsNil {
		predicates = append(predicates, evidence.RenewalDateIsNil())
	}
	if i.RenewalDateNotNil {
		predicates = append(predicates, evidence.RenewalDateNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, evidence.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, evidence.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, evidence.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, evidence.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceGT != nil {
		predicates = append(predicates, evidence.SourceGT(*i.SourceGT))
	}
	if i.SourceGTE != nil {
		predicates = append(predicates, evidence.SourceGTE(*i.SourceGTE))
	}
	if i.SourceLT != nil {
		predicates = append(predicates, evidence.SourceLT(*i.SourceLT))
	}
	if i.SourceLTE != nil {
		predicates = append(predicates, evidence.SourceLTE(*i.SourceLTE))
	}
	if i.SourceContains != nil {
		predicates = append(predicates, evidence.SourceContains(*i.SourceContains))
	}
	if i.SourceHasPrefix != nil {
		predicates = append(predicates, evidence.SourceHasPrefix(*i.SourceHasPrefix))
	}
	if i.SourceHasSuffix != nil {
		predicates = append(predicates, evidence.SourceHasSuffix(*i.SourceHasSuffix))
	}
	if i.SourceIsNil {
		predicates = append(predicates, evidence.SourceIsNil())
	}
	if i.SourceNotNil {
		predicates = append(predicates, evidence.SourceNotNil())
	}
	if i.SourceEqualFold != nil {
		predicates = append(predicates, evidence.SourceEqualFold(*i.SourceEqualFold))
	}
	if i.SourceContainsFold != nil {
		predicates = append(predicates, evidence.SourceContainsFold(*i.SourceContainsFold))
	}
	if i.IsAutomated != nil {
		predicates = append(predicates, evidence.IsAutomatedEQ(*i.IsAutomated))
	}
	if i.IsAutomatedNEQ != nil {
		predicates = append(predicates, evidence.IsAutomatedNEQ(*i.IsAutomatedNEQ))
	}
	if i.IsAutomatedIsNil {
		predicates = append(predicates, evidence.IsAutomatedIsNil())
	}
	if i.IsAutomatedNotNil {
		predicates = append(predicates, evidence.IsAutomatedNotNil())
	}
	if i.URL != nil {
		predicates = append(predicates, evidence.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, evidence.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, evidence.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, evidence.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, evidence.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, evidence.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, evidence.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, evidence.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, evidence.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, evidence.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, evidence.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLIsNil {
		predicates = append(predicates, evidence.URLIsNil())
	}
	if i.URLNotNil {
		predicates = append(predicates, evidence.URLNotNil())
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, evidence.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, evidence.URLContainsFold(*i.URLContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, evidence.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, evidence.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, evidence.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, evidence.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, evidence.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, evidence.StatusNotNil())
	}

	if i.HasOwner != nil {
		p := evidence.HasOwner()
		if !*i.HasOwner {
			p = evidence.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, evidence.HasOwnerWith(with...))
	}
	if i.HasControlObjectives != nil {
		p := evidence.HasControlObjectives()
		if !*i.HasControlObjectives {
			p = evidence.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlObjectivesWith) > 0 {
		with := make([]predicate.ControlObjective, 0, len(i.HasControlObjectivesWith))
		for _, w := range i.HasControlObjectivesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlObjectivesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, evidence.HasControlObjectivesWith(with...))
	}
	if i.HasControls != nil {
		p := evidence.HasControls()
		if !*i.HasControls {
			p = evidence.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasControlsWith))
		for _, w := range i.HasControlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, evidence.HasControlsWith(with...))
	}
	if i.HasSubcontrols != nil {
		p := evidence.HasSubcontrols()
		if !*i.HasSubcontrols {
			p = evidence.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubcontrolsWith) > 0 {
		with := make([]predicate.Subcontrol, 0, len(i.HasSubcontrolsWith))
		for _, w := range i.HasSubcontrolsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubcontrolsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, evidence.HasSubcontrolsWith(with...))
	}
	if i.HasFiles != nil {
		p := evidence.HasFiles()
		if !*i.HasFiles {
			p = evidence.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, evidence.HasFilesWith(with...))
	}
	if i.HasPrograms != nil {
		p := evidence.HasPrograms()
		if !*i.HasPrograms {
			p = evidence.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramsWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramsWith))
		for _, w := range i.HasProgramsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, evidence.HasProgramsWith(with...))
	}
	if i.HasTasks != nil {
		p := evidence.HasTasks()
		if !*i.HasTasks {
			p = evidence.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, evidence.HasTasksWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEvidenceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return evidence.And(predicates...), nil
	}
}

// EvidenceHistoryWhereInput represents a where input for filtering EvidenceHistory queries.
type EvidenceHistoryWhereInput struct {
	Predicates []predicate.EvidenceHistory  `json:"-"`
	Not        *EvidenceHistoryWhereInput   `json:"not,omitempty"`
	Or         []*EvidenceHistoryWhereInput `json:"or,omitempty"`
	And        []*EvidenceHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "collection_procedure" field predicates.
	CollectionProcedure             *string  `json:"collectionProcedure,omitempty"`
	CollectionProcedureNEQ          *string  `json:"collectionProcedureNEQ,omitempty"`
	CollectionProcedureIn           []string `json:"collectionProcedureIn,omitempty"`
	CollectionProcedureNotIn        []string `json:"collectionProcedureNotIn,omitempty"`
	CollectionProcedureGT           *string  `json:"collectionProcedureGT,omitempty"`
	CollectionProcedureGTE          *string  `json:"collectionProcedureGTE,omitempty"`
	CollectionProcedureLT           *string  `json:"collectionProcedureLT,omitempty"`
	CollectionProcedureLTE          *string  `json:"collectionProcedureLTE,omitempty"`
	CollectionProcedureContains     *string  `json:"collectionProcedureContains,omitempty"`
	CollectionProcedureHasPrefix    *string  `json:"collectionProcedureHasPrefix,omitempty"`
	CollectionProcedureHasSuffix    *string  `json:"collectionProcedureHasSuffix,omitempty"`
	CollectionProcedureIsNil        bool     `json:"collectionProcedureIsNil,omitempty"`
	CollectionProcedureNotNil       bool     `json:"collectionProcedureNotNil,omitempty"`
	CollectionProcedureEqualFold    *string  `json:"collectionProcedureEqualFold,omitempty"`
	CollectionProcedureContainsFold *string  `json:"collectionProcedureContainsFold,omitempty"`

	// "creation_date" field predicates.
	CreationDate      *time.Time  `json:"creationDate,omitempty"`
	CreationDateNEQ   *time.Time  `json:"creationDateNEQ,omitempty"`
	CreationDateIn    []time.Time `json:"creationDateIn,omitempty"`
	CreationDateNotIn []time.Time `json:"creationDateNotIn,omitempty"`
	CreationDateGT    *time.Time  `json:"creationDateGT,omitempty"`
	CreationDateGTE   *time.Time  `json:"creationDateGTE,omitempty"`
	CreationDateLT    *time.Time  `json:"creationDateLT,omitempty"`
	CreationDateLTE   *time.Time  `json:"creationDateLTE,omitempty"`

	// "renewal_date" field predicates.
	RenewalDate       *time.Time  `json:"renewalDate,omitempty"`
	RenewalDateNEQ    *time.Time  `json:"renewalDateNEQ,omitempty"`
	RenewalDateIn     []time.Time `json:"renewalDateIn,omitempty"`
	RenewalDateNotIn  []time.Time `json:"renewalDateNotIn,omitempty"`
	RenewalDateGT     *time.Time  `json:"renewalDateGT,omitempty"`
	RenewalDateGTE    *time.Time  `json:"renewalDateGTE,omitempty"`
	RenewalDateLT     *time.Time  `json:"renewalDateLT,omitempty"`
	RenewalDateLTE    *time.Time  `json:"renewalDateLTE,omitempty"`
	RenewalDateIsNil  bool        `json:"renewalDateIsNil,omitempty"`
	RenewalDateNotNil bool        `json:"renewalDateNotNil,omitempty"`

	// "source" field predicates.
	Source             *string  `json:"source,omitempty"`
	SourceNEQ          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGT           *string  `json:"sourceGT,omitempty"`
	SourceGTE          *string  `json:"sourceGTE,omitempty"`
	SourceLT           *string  `json:"sourceLT,omitempty"`
	SourceLTE          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        bool     `json:"sourceIsNil,omitempty"`
	SourceNotNil       bool     `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`

	// "is_automated" field predicates.
	IsAutomated       *bool `json:"isAutomated,omitempty"`
	IsAutomatedNEQ    *bool `json:"isAutomatedNEQ,omitempty"`
	IsAutomatedIsNil  bool  `json:"isAutomatedIsNil,omitempty"`
	IsAutomatedNotNil bool  `json:"isAutomatedNotNil,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        bool     `json:"urlIsNil,omitempty"`
	URLNotNil       bool     `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.EvidenceStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.EvidenceStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.EvidenceStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.EvidenceStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                   `json:"statusIsNil,omitempty"`
	StatusNotNil bool                   `json:"statusNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EvidenceHistoryWhereInput) AddPredicates(predicates ...predicate.EvidenceHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EvidenceHistoryWhereInput filter on the EvidenceHistoryQuery builder.
func (i *EvidenceHistoryWhereInput) Filter(q *EvidenceHistoryQuery) (*EvidenceHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEvidenceHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEvidenceHistoryWhereInput is returned in case the EvidenceHistoryWhereInput is empty.
var ErrEmptyEvidenceHistoryWhereInput = errors.New("generated: empty predicate EvidenceHistoryWhereInput")

// P returns a predicate for filtering evidencehistories.
// An error is returned if the input is empty or invalid.
func (i *EvidenceHistoryWhereInput) P() (predicate.EvidenceHistory, error) {
	var predicates []predicate.EvidenceHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, evidencehistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.EvidenceHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, evidencehistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.EvidenceHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, evidencehistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, evidencehistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, evidencehistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, evidencehistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, evidencehistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, evidencehistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, evidencehistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, evidencehistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, evidencehistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, evidencehistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, evidencehistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, evidencehistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, evidencehistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, evidencehistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, evidencehistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, evidencehistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, evidencehistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, evidencehistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, evidencehistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, evidencehistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, evidencehistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, evidencehistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, evidencehistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, evidencehistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, evidencehistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, evidencehistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, evidencehistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, evidencehistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, evidencehistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, evidencehistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, evidencehistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, evidencehistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, evidencehistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, evidencehistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, evidencehistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, evidencehistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, evidencehistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, evidencehistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, evidencehistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, evidencehistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, evidencehistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, evidencehistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, evidencehistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, evidencehistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, evidencehistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, evidencehistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, evidencehistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, evidencehistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, evidencehistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, evidencehistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, evidencehistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, evidencehistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, evidencehistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, evidencehistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, evidencehistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, evidencehistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, evidencehistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, evidencehistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, evidencehistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, evidencehistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, evidencehistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, evidencehistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, evidencehistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, evidencehistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, evidencehistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, evidencehistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, evidencehistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, evidencehistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, evidencehistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, evidencehistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, evidencehistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, evidencehistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, evidencehistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, evidencehistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, evidencehistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, evidencehistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, evidencehistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, evidencehistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, evidencehistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, evidencehistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, evidencehistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, evidencehistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, evidencehistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, evidencehistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, evidencehistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, evidencehistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, evidencehistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, evidencehistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, evidencehistory.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, evidencehistory.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, evidencehistory.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, evidencehistory.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, evidencehistory.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, evidencehistory.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, evidencehistory.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, evidencehistory.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, evidencehistory.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, evidencehistory.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, evidencehistory.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, evidencehistory.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, evidencehistory.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, evidencehistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, evidencehistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, evidencehistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, evidencehistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, evidencehistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, evidencehistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, evidencehistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, evidencehistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, evidencehistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, evidencehistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, evidencehistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, evidencehistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, evidencehistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, evidencehistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, evidencehistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, evidencehistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, evidencehistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, evidencehistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, evidencehistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, evidencehistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, evidencehistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, evidencehistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, evidencehistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, evidencehistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, evidencehistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, evidencehistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, evidencehistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, evidencehistory.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, evidencehistory.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, evidencehistory.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, evidencehistory.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, evidencehistory.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, evidencehistory.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, evidencehistory.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, evidencehistory.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, evidencehistory.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, evidencehistory.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, evidencehistory.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, evidencehistory.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, evidencehistory.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, evidencehistory.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, evidencehistory.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, evidencehistory.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.CollectionProcedure != nil {
		predicates = append(predicates, evidencehistory.CollectionProcedureEQ(*i.CollectionProcedure))
	}
	if i.CollectionProcedureNEQ != nil {
		predicates = append(predicates, evidencehistory.CollectionProcedureNEQ(*i.CollectionProcedureNEQ))
	}
	if len(i.CollectionProcedureIn) > 0 {
		predicates = append(predicates, evidencehistory.CollectionProcedureIn(i.CollectionProcedureIn...))
	}
	if len(i.CollectionProcedureNotIn) > 0 {
		predicates = append(predicates, evidencehistory.CollectionProcedureNotIn(i.CollectionProcedureNotIn...))
	}
	if i.CollectionProcedureGT != nil {
		predicates = append(predicates, evidencehistory.CollectionProcedureGT(*i.CollectionProcedureGT))
	}
	if i.CollectionProcedureGTE != nil {
		predicates = append(predicates, evidencehistory.CollectionProcedureGTE(*i.CollectionProcedureGTE))
	}
	if i.CollectionProcedureLT != nil {
		predicates = append(predicates, evidencehistory.CollectionProcedureLT(*i.CollectionProcedureLT))
	}
	if i.CollectionProcedureLTE != nil {
		predicates = append(predicates, evidencehistory.CollectionProcedureLTE(*i.CollectionProcedureLTE))
	}
	if i.CollectionProcedureContains != nil {
		predicates = append(predicates, evidencehistory.CollectionProcedureContains(*i.CollectionProcedureContains))
	}
	if i.CollectionProcedureHasPrefix != nil {
		predicates = append(predicates, evidencehistory.CollectionProcedureHasPrefix(*i.CollectionProcedureHasPrefix))
	}
	if i.CollectionProcedureHasSuffix != nil {
		predicates = append(predicates, evidencehistory.CollectionProcedureHasSuffix(*i.CollectionProcedureHasSuffix))
	}
	if i.CollectionProcedureIsNil {
		predicates = append(predicates, evidencehistory.CollectionProcedureIsNil())
	}
	if i.CollectionProcedureNotNil {
		predicates = append(predicates, evidencehistory.CollectionProcedureNotNil())
	}
	if i.CollectionProcedureEqualFold != nil {
		predicates = append(predicates, evidencehistory.CollectionProcedureEqualFold(*i.CollectionProcedureEqualFold))
	}
	if i.CollectionProcedureContainsFold != nil {
		predicates = append(predicates, evidencehistory.CollectionProcedureContainsFold(*i.CollectionProcedureContainsFold))
	}
	if i.CreationDate != nil {
		predicates = append(predicates, evidencehistory.CreationDateEQ(*i.CreationDate))
	}
	if i.CreationDateNEQ != nil {
		predicates = append(predicates, evidencehistory.CreationDateNEQ(*i.CreationDateNEQ))
	}
	if len(i.CreationDateIn) > 0 {
		predicates = append(predicates, evidencehistory.CreationDateIn(i.CreationDateIn...))
	}
	if len(i.CreationDateNotIn) > 0 {
		predicates = append(predicates, evidencehistory.CreationDateNotIn(i.CreationDateNotIn...))
	}
	if i.CreationDateGT != nil {
		predicates = append(predicates, evidencehistory.CreationDateGT(*i.CreationDateGT))
	}
	if i.CreationDateGTE != nil {
		predicates = append(predicates, evidencehistory.CreationDateGTE(*i.CreationDateGTE))
	}
	if i.CreationDateLT != nil {
		predicates = append(predicates, evidencehistory.CreationDateLT(*i.CreationDateLT))
	}
	if i.CreationDateLTE != nil {
		predicates = append(predicates, evidencehistory.CreationDateLTE(*i.CreationDateLTE))
	}
	if i.RenewalDate != nil {
		predicates = append(predicates, evidencehistory.RenewalDateEQ(*i.RenewalDate))
	}
	if i.RenewalDateNEQ != nil {
		predicates = append(predicates, evidencehistory.RenewalDateNEQ(*i.RenewalDateNEQ))
	}
	if len(i.RenewalDateIn) > 0 {
		predicates = append(predicates, evidencehistory.RenewalDateIn(i.RenewalDateIn...))
	}
	if len(i.RenewalDateNotIn) > 0 {
		predicates = append(predicates, evidencehistory.RenewalDateNotIn(i.RenewalDateNotIn...))
	}
	if i.RenewalDateGT != nil {
		predicates = append(predicates, evidencehistory.RenewalDateGT(*i.RenewalDateGT))
	}
	if i.RenewalDateGTE != nil {
		predicates = append(predicates, evidencehistory.RenewalDateGTE(*i.RenewalDateGTE))
	}
	if i.RenewalDateLT != nil {
		predicates = append(predicates, evidencehistory.RenewalDateLT(*i.RenewalDateLT))
	}
	if i.RenewalDateLTE != nil {
		predicates = append(predicates, evidencehistory.RenewalDateLTE(*i.RenewalDateLTE))
	}
	if i.RenewalDateIsNil {
		predicates = append(predicates, evidencehistory.RenewalDateIsNil())
	}
	if i.RenewalDateNotNil {
		predicates = append(predicates, evidencehistory.RenewalDateNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, evidencehistory.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, evidencehistory.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, evidencehistory.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, evidencehistory.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceGT != nil {
		predicates = append(predicates, evidencehistory.SourceGT(*i.SourceGT))
	}
	if i.SourceGTE != nil {
		predicates = append(predicates, evidencehistory.SourceGTE(*i.SourceGTE))
	}
	if i.SourceLT != nil {
		predicates = append(predicates, evidencehistory.SourceLT(*i.SourceLT))
	}
	if i.SourceLTE != nil {
		predicates = append(predicates, evidencehistory.SourceLTE(*i.SourceLTE))
	}
	if i.SourceContains != nil {
		predicates = append(predicates, evidencehistory.SourceContains(*i.SourceContains))
	}
	if i.SourceHasPrefix != nil {
		predicates = append(predicates, evidencehistory.SourceHasPrefix(*i.SourceHasPrefix))
	}
	if i.SourceHasSuffix != nil {
		predicates = append(predicates, evidencehistory.SourceHasSuffix(*i.SourceHasSuffix))
	}
	if i.SourceIsNil {
		predicates = append(predicates, evidencehistory.SourceIsNil())
	}
	if i.SourceNotNil {
		predicates = append(predicates, evidencehistory.SourceNotNil())
	}
	if i.SourceEqualFold != nil {
		predicates = append(predicates, evidencehistory.SourceEqualFold(*i.SourceEqualFold))
	}
	if i.SourceContainsFold != nil {
		predicates = append(predicates, evidencehistory.SourceContainsFold(*i.SourceContainsFold))
	}
	if i.IsAutomated != nil {
		predicates = append(predicates, evidencehistory.IsAutomatedEQ(*i.IsAutomated))
	}
	if i.IsAutomatedNEQ != nil {
		predicates = append(predicates, evidencehistory.IsAutomatedNEQ(*i.IsAutomatedNEQ))
	}
	if i.IsAutomatedIsNil {
		predicates = append(predicates, evidencehistory.IsAutomatedIsNil())
	}
	if i.IsAutomatedNotNil {
		predicates = append(predicates, evidencehistory.IsAutomatedNotNil())
	}
	if i.URL != nil {
		predicates = append(predicates, evidencehistory.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, evidencehistory.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, evidencehistory.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, evidencehistory.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, evidencehistory.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, evidencehistory.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, evidencehistory.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, evidencehistory.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, evidencehistory.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, evidencehistory.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, evidencehistory.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLIsNil {
		predicates = append(predicates, evidencehistory.URLIsNil())
	}
	if i.URLNotNil {
		predicates = append(predicates, evidencehistory.URLNotNil())
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, evidencehistory.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, evidencehistory.URLContainsFold(*i.URLContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, evidencehistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, evidencehistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, evidencehistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, evidencehistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, evidencehistory.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, evidencehistory.StatusNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEvidenceHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return evidencehistory.And(predicates...), nil
	}
}

// FileWhereInput represents a where input for filtering File queries.
type FileWhereInput struct {
	Predicates []predicate.File  `json:"-"`
	Not        *FileWhereInput   `json:"not,omitempty"`
	Or         []*FileWhereInput `json:"or,omitempty"`
	And        []*FileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "provided_file_name" field predicates.
	ProvidedFileName             *string  `json:"providedFileName,omitempty"`
	ProvidedFileNameNEQ          *string  `json:"providedFileNameNEQ,omitempty"`
	ProvidedFileNameIn           []string `json:"providedFileNameIn,omitempty"`
	ProvidedFileNameNotIn        []string `json:"providedFileNameNotIn,omitempty"`
	ProvidedFileNameGT           *string  `json:"providedFileNameGT,omitempty"`
	ProvidedFileNameGTE          *string  `json:"providedFileNameGTE,omitempty"`
	ProvidedFileNameLT           *string  `json:"providedFileNameLT,omitempty"`
	ProvidedFileNameLTE          *string  `json:"providedFileNameLTE,omitempty"`
	ProvidedFileNameContains     *string  `json:"providedFileNameContains,omitempty"`
	ProvidedFileNameHasPrefix    *string  `json:"providedFileNameHasPrefix,omitempty"`
	ProvidedFileNameHasSuffix    *string  `json:"providedFileNameHasSuffix,omitempty"`
	ProvidedFileNameEqualFold    *string  `json:"providedFileNameEqualFold,omitempty"`
	ProvidedFileNameContainsFold *string  `json:"providedFileNameContainsFold,omitempty"`

	// "provided_file_extension" field predicates.
	ProvidedFileExtension             *string  `json:"providedFileExtension,omitempty"`
	ProvidedFileExtensionNEQ          *string  `json:"providedFileExtensionNEQ,omitempty"`
	ProvidedFileExtensionIn           []string `json:"providedFileExtensionIn,omitempty"`
	ProvidedFileExtensionNotIn        []string `json:"providedFileExtensionNotIn,omitempty"`
	ProvidedFileExtensionGT           *string  `json:"providedFileExtensionGT,omitempty"`
	ProvidedFileExtensionGTE          *string  `json:"providedFileExtensionGTE,omitempty"`
	ProvidedFileExtensionLT           *string  `json:"providedFileExtensionLT,omitempty"`
	ProvidedFileExtensionLTE          *string  `json:"providedFileExtensionLTE,omitempty"`
	ProvidedFileExtensionContains     *string  `json:"providedFileExtensionContains,omitempty"`
	ProvidedFileExtensionHasPrefix    *string  `json:"providedFileExtensionHasPrefix,omitempty"`
	ProvidedFileExtensionHasSuffix    *string  `json:"providedFileExtensionHasSuffix,omitempty"`
	ProvidedFileExtensionEqualFold    *string  `json:"providedFileExtensionEqualFold,omitempty"`
	ProvidedFileExtensionContainsFold *string  `json:"providedFileExtensionContainsFold,omitempty"`

	// "provided_file_size" field predicates.
	ProvidedFileSize       *int64  `json:"providedFileSize,omitempty"`
	ProvidedFileSizeNEQ    *int64  `json:"providedFileSizeNEQ,omitempty"`
	ProvidedFileSizeIn     []int64 `json:"providedFileSizeIn,omitempty"`
	ProvidedFileSizeNotIn  []int64 `json:"providedFileSizeNotIn,omitempty"`
	ProvidedFileSizeGT     *int64  `json:"providedFileSizeGT,omitempty"`
	ProvidedFileSizeGTE    *int64  `json:"providedFileSizeGTE,omitempty"`
	ProvidedFileSizeLT     *int64  `json:"providedFileSizeLT,omitempty"`
	ProvidedFileSizeLTE    *int64  `json:"providedFileSizeLTE,omitempty"`
	ProvidedFileSizeIsNil  bool    `json:"providedFileSizeIsNil,omitempty"`
	ProvidedFileSizeNotNil bool    `json:"providedFileSizeNotNil,omitempty"`

	// "persisted_file_size" field predicates.
	PersistedFileSize       *int64  `json:"persistedFileSize,omitempty"`
	PersistedFileSizeNEQ    *int64  `json:"persistedFileSizeNEQ,omitempty"`
	PersistedFileSizeIn     []int64 `json:"persistedFileSizeIn,omitempty"`
	PersistedFileSizeNotIn  []int64 `json:"persistedFileSizeNotIn,omitempty"`
	PersistedFileSizeGT     *int64  `json:"persistedFileSizeGT,omitempty"`
	PersistedFileSizeGTE    *int64  `json:"persistedFileSizeGTE,omitempty"`
	PersistedFileSizeLT     *int64  `json:"persistedFileSizeLT,omitempty"`
	PersistedFileSizeLTE    *int64  `json:"persistedFileSizeLTE,omitempty"`
	PersistedFileSizeIsNil  bool    `json:"persistedFileSizeIsNil,omitempty"`
	PersistedFileSizeNotNil bool    `json:"persistedFileSizeNotNil,omitempty"`

	// "detected_mime_type" field predicates.
	DetectedMimeType             *string  `json:"detectedMimeType,omitempty"`
	DetectedMimeTypeNEQ          *string  `json:"detectedMimeTypeNEQ,omitempty"`
	DetectedMimeTypeIn           []string `json:"detectedMimeTypeIn,omitempty"`
	DetectedMimeTypeNotIn        []string `json:"detectedMimeTypeNotIn,omitempty"`
	DetectedMimeTypeGT           *string  `json:"detectedMimeTypeGT,omitempty"`
	DetectedMimeTypeGTE          *string  `json:"detectedMimeTypeGTE,omitempty"`
	DetectedMimeTypeLT           *string  `json:"detectedMimeTypeLT,omitempty"`
	DetectedMimeTypeLTE          *string  `json:"detectedMimeTypeLTE,omitempty"`
	DetectedMimeTypeContains     *string  `json:"detectedMimeTypeContains,omitempty"`
	DetectedMimeTypeHasPrefix    *string  `json:"detectedMimeTypeHasPrefix,omitempty"`
	DetectedMimeTypeHasSuffix    *string  `json:"detectedMimeTypeHasSuffix,omitempty"`
	DetectedMimeTypeIsNil        bool     `json:"detectedMimeTypeIsNil,omitempty"`
	DetectedMimeTypeNotNil       bool     `json:"detectedMimeTypeNotNil,omitempty"`
	DetectedMimeTypeEqualFold    *string  `json:"detectedMimeTypeEqualFold,omitempty"`
	DetectedMimeTypeContainsFold *string  `json:"detectedMimeTypeContainsFold,omitempty"`

	// "md5_hash" field predicates.
	Md5Hash             *string  `json:"md5Hash,omitempty"`
	Md5HashNEQ          *string  `json:"md5HashNEQ,omitempty"`
	Md5HashIn           []string `json:"md5HashIn,omitempty"`
	Md5HashNotIn        []string `json:"md5HashNotIn,omitempty"`
	Md5HashGT           *string  `json:"md5HashGT,omitempty"`
	Md5HashGTE          *string  `json:"md5HashGTE,omitempty"`
	Md5HashLT           *string  `json:"md5HashLT,omitempty"`
	Md5HashLTE          *string  `json:"md5HashLTE,omitempty"`
	Md5HashContains     *string  `json:"md5HashContains,omitempty"`
	Md5HashHasPrefix    *string  `json:"md5HashHasPrefix,omitempty"`
	Md5HashHasSuffix    *string  `json:"md5HashHasSuffix,omitempty"`
	Md5HashIsNil        bool     `json:"md5HashIsNil,omitempty"`
	Md5HashNotNil       bool     `json:"md5HashNotNil,omitempty"`
	Md5HashEqualFold    *string  `json:"md5HashEqualFold,omitempty"`
	Md5HashContainsFold *string  `json:"md5HashContainsFold,omitempty"`

	// "detected_content_type" field predicates.
	DetectedContentType             *string  `json:"detectedContentType,omitempty"`
	DetectedContentTypeNEQ          *string  `json:"detectedContentTypeNEQ,omitempty"`
	DetectedContentTypeIn           []string `json:"detectedContentTypeIn,omitempty"`
	DetectedContentTypeNotIn        []string `json:"detectedContentTypeNotIn,omitempty"`
	DetectedContentTypeGT           *string  `json:"detectedContentTypeGT,omitempty"`
	DetectedContentTypeGTE          *string  `json:"detectedContentTypeGTE,omitempty"`
	DetectedContentTypeLT           *string  `json:"detectedContentTypeLT,omitempty"`
	DetectedContentTypeLTE          *string  `json:"detectedContentTypeLTE,omitempty"`
	DetectedContentTypeContains     *string  `json:"detectedContentTypeContains,omitempty"`
	DetectedContentTypeHasPrefix    *string  `json:"detectedContentTypeHasPrefix,omitempty"`
	DetectedContentTypeHasSuffix    *string  `json:"detectedContentTypeHasSuffix,omitempty"`
	DetectedContentTypeEqualFold    *string  `json:"detectedContentTypeEqualFold,omitempty"`
	DetectedContentTypeContainsFold *string  `json:"detectedContentTypeContainsFold,omitempty"`

	// "store_key" field predicates.
	StoreKey             *string  `json:"storeKey,omitempty"`
	StoreKeyNEQ          *string  `json:"storeKeyNEQ,omitempty"`
	StoreKeyIn           []string `json:"storeKeyIn,omitempty"`
	StoreKeyNotIn        []string `json:"storeKeyNotIn,omitempty"`
	StoreKeyGT           *string  `json:"storeKeyGT,omitempty"`
	StoreKeyGTE          *string  `json:"storeKeyGTE,omitempty"`
	StoreKeyLT           *string  `json:"storeKeyLT,omitempty"`
	StoreKeyLTE          *string  `json:"storeKeyLTE,omitempty"`
	StoreKeyContains     *string  `json:"storeKeyContains,omitempty"`
	StoreKeyHasPrefix    *string  `json:"storeKeyHasPrefix,omitempty"`
	StoreKeyHasSuffix    *string  `json:"storeKeyHasSuffix,omitempty"`
	StoreKeyIsNil        bool     `json:"storeKeyIsNil,omitempty"`
	StoreKeyNotNil       bool     `json:"storeKeyNotNil,omitempty"`
	StoreKeyEqualFold    *string  `json:"storeKeyEqualFold,omitempty"`
	StoreKeyContainsFold *string  `json:"storeKeyContainsFold,omitempty"`

	// "category_type" field predicates.
	CategoryType             *string  `json:"categoryType,omitempty"`
	CategoryTypeNEQ          *string  `json:"categoryTypeNEQ,omitempty"`
	CategoryTypeIn           []string `json:"categoryTypeIn,omitempty"`
	CategoryTypeNotIn        []string `json:"categoryTypeNotIn,omitempty"`
	CategoryTypeGT           *string  `json:"categoryTypeGT,omitempty"`
	CategoryTypeGTE          *string  `json:"categoryTypeGTE,omitempty"`
	CategoryTypeLT           *string  `json:"categoryTypeLT,omitempty"`
	CategoryTypeLTE          *string  `json:"categoryTypeLTE,omitempty"`
	CategoryTypeContains     *string  `json:"categoryTypeContains,omitempty"`
	CategoryTypeHasPrefix    *string  `json:"categoryTypeHasPrefix,omitempty"`
	CategoryTypeHasSuffix    *string  `json:"categoryTypeHasSuffix,omitempty"`
	CategoryTypeIsNil        bool     `json:"categoryTypeIsNil,omitempty"`
	CategoryTypeNotNil       bool     `json:"categoryTypeNotNil,omitempty"`
	CategoryTypeEqualFold    *string  `json:"categoryTypeEqualFold,omitempty"`
	CategoryTypeContainsFold *string  `json:"categoryTypeContainsFold,omitempty"`

	// "uri" field predicates.
	URI             *string  `json:"uri,omitempty"`
	URINEQ          *string  `json:"uriNEQ,omitempty"`
	URIIn           []string `json:"uriIn,omitempty"`
	URINotIn        []string `json:"uriNotIn,omitempty"`
	URIGT           *string  `json:"uriGT,omitempty"`
	URIGTE          *string  `json:"uriGTE,omitempty"`
	URILT           *string  `json:"uriLT,omitempty"`
	URILTE          *string  `json:"uriLTE,omitempty"`
	URIContains     *string  `json:"uriContains,omitempty"`
	URIHasPrefix    *string  `json:"uriHasPrefix,omitempty"`
	URIHasSuffix    *string  `json:"uriHasSuffix,omitempty"`
	URIIsNil        bool     `json:"uriIsNil,omitempty"`
	URINotNil       bool     `json:"uriNotNil,omitempty"`
	URIEqualFold    *string  `json:"uriEqualFold,omitempty"`
	URIContainsFold *string  `json:"uriContainsFold,omitempty"`

	// "storage_scheme" field predicates.
	StorageScheme             *string  `json:"storageScheme,omitempty"`
	StorageSchemeNEQ          *string  `json:"storageSchemeNEQ,omitempty"`
	StorageSchemeIn           []string `json:"storageSchemeIn,omitempty"`
	StorageSchemeNotIn        []string `json:"storageSchemeNotIn,omitempty"`
	StorageSchemeGT           *string  `json:"storageSchemeGT,omitempty"`
	StorageSchemeGTE          *string  `json:"storageSchemeGTE,omitempty"`
	StorageSchemeLT           *string  `json:"storageSchemeLT,omitempty"`
	StorageSchemeLTE          *string  `json:"storageSchemeLTE,omitempty"`
	StorageSchemeContains     *string  `json:"storageSchemeContains,omitempty"`
	StorageSchemeHasPrefix    *string  `json:"storageSchemeHasPrefix,omitempty"`
	StorageSchemeHasSuffix    *string  `json:"storageSchemeHasSuffix,omitempty"`
	StorageSchemeIsNil        bool     `json:"storageSchemeIsNil,omitempty"`
	StorageSchemeNotNil       bool     `json:"storageSchemeNotNil,omitempty"`
	StorageSchemeEqualFold    *string  `json:"storageSchemeEqualFold,omitempty"`
	StorageSchemeContainsFold *string  `json:"storageSchemeContainsFold,omitempty"`

	// "storage_volume" field predicates.
	StorageVolume             *string  `json:"storageVolume,omitempty"`
	StorageVolumeNEQ          *string  `json:"storageVolumeNEQ,omitempty"`
	StorageVolumeIn           []string `json:"storageVolumeIn,omitempty"`
	StorageVolumeNotIn        []string `json:"storageVolumeNotIn,omitempty"`
	StorageVolumeGT           *string  `json:"storageVolumeGT,omitempty"`
	StorageVolumeGTE          *string  `json:"storageVolumeGTE,omitempty"`
	StorageVolumeLT           *string  `json:"storageVolumeLT,omitempty"`
	StorageVolumeLTE          *string  `json:"storageVolumeLTE,omitempty"`
	StorageVolumeContains     *string  `json:"storageVolumeContains,omitempty"`
	StorageVolumeHasPrefix    *string  `json:"storageVolumeHasPrefix,omitempty"`
	StorageVolumeHasSuffix    *string  `json:"storageVolumeHasSuffix,omitempty"`
	StorageVolumeIsNil        bool     `json:"storageVolumeIsNil,omitempty"`
	StorageVolumeNotNil       bool     `json:"storageVolumeNotNil,omitempty"`
	StorageVolumeEqualFold    *string  `json:"storageVolumeEqualFold,omitempty"`
	StorageVolumeContainsFold *string  `json:"storageVolumeContainsFold,omitempty"`

	// "storage_path" field predicates.
	StoragePath             *string  `json:"storagePath,omitempty"`
	StoragePathNEQ          *string  `json:"storagePathNEQ,omitempty"`
	StoragePathIn           []string `json:"storagePathIn,omitempty"`
	StoragePathNotIn        []string `json:"storagePathNotIn,omitempty"`
	StoragePathGT           *string  `json:"storagePathGT,omitempty"`
	StoragePathGTE          *string  `json:"storagePathGTE,omitempty"`
	StoragePathLT           *string  `json:"storagePathLT,omitempty"`
	StoragePathLTE          *string  `json:"storagePathLTE,omitempty"`
	StoragePathContains     *string  `json:"storagePathContains,omitempty"`
	StoragePathHasPrefix    *string  `json:"storagePathHasPrefix,omitempty"`
	StoragePathHasSuffix    *string  `json:"storagePathHasSuffix,omitempty"`
	StoragePathIsNil        bool     `json:"storagePathIsNil,omitempty"`
	StoragePathNotNil       bool     `json:"storagePathNotNil,omitempty"`
	StoragePathEqualFold    *string  `json:"storagePathEqualFold,omitempty"`
	StoragePathContainsFold *string  `json:"storagePathContainsFold,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "organization" edge predicates.
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`

	// "groups" edge predicates.
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`

	// "contact" edge predicates.
	HasContact     *bool                `json:"hasContact,omitempty"`
	HasContactWith []*ContactWhereInput `json:"hasContactWith,omitempty"`

	// "entity" edge predicates.
	HasEntity     *bool               `json:"hasEntity,omitempty"`
	HasEntityWith []*EntityWhereInput `json:"hasEntityWith,omitempty"`

	// "user_setting" edge predicates.
	HasUserSetting     *bool                    `json:"hasUserSetting,omitempty"`
	HasUserSettingWith []*UserSettingWhereInput `json:"hasUserSettingWith,omitempty"`

	// "organization_setting" edge predicates.
	HasOrganizationSetting     *bool                            `json:"hasOrganizationSetting,omitempty"`
	HasOrganizationSettingWith []*OrganizationSettingWhereInput `json:"hasOrganizationSettingWith,omitempty"`

	// "template" edge predicates.
	HasTemplate     *bool                 `json:"hasTemplate,omitempty"`
	HasTemplateWith []*TemplateWhereInput `json:"hasTemplateWith,omitempty"`

	// "document" edge predicates.
	HasDocument     *bool                     `json:"hasDocument,omitempty"`
	HasDocumentWith []*DocumentDataWhereInput `json:"hasDocumentWith,omitempty"`

	// "program" edge predicates.
	HasProgram     *bool                `json:"hasProgram,omitempty"`
	HasProgramWith []*ProgramWhereInput `json:"hasProgramWith,omitempty"`

	// "evidence" edge predicates.
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`

	// "events" edge predicates.
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FileWhereInput) AddPredicates(predicates ...predicate.File) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FileWhereInput filter on the FileQuery builder.
func (i *FileWhereInput) Filter(q *FileQuery) (*FileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFileWhereInput is returned in case the FileWhereInput is empty.
var ErrEmptyFileWhereInput = errors.New("generated: empty predicate FileWhereInput")

// P returns a predicate for filtering files.
// An error is returned if the input is empty or invalid.
func (i *FileWhereInput) P() (predicate.File, error) {
	var predicates []predicate.File
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, file.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.File, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, file.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.File, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, file.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, file.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, file.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, file.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, file.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, file.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, file.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, file.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, file.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, file.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, file.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, file.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, file.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, file.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, file.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, file.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, file.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, file.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, file.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, file.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, file.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, file.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, file.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, file.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, file.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, file.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, file.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, file.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, file.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, file.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, file.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, file.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, file.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, file.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, file.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, file.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, file.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, file.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, file.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, file.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, file.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, file.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, file.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, file.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, file.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, file.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, file.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, file.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, file.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, file.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, file.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, file.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, file.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, file.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, file.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, file.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, file.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, file.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, file.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, file.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, file.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.ProvidedFileName != nil {
		predicates = append(predicates, file.ProvidedFileNameEQ(*i.ProvidedFileName))
	}
	if i.ProvidedFileNameNEQ != nil {
		predicates = append(predicates, file.ProvidedFileNameNEQ(*i.ProvidedFileNameNEQ))
	}
	if len(i.ProvidedFileNameIn) > 0 {
		predicates = append(predicates, file.ProvidedFileNameIn(i.ProvidedFileNameIn...))
	}
	if len(i.ProvidedFileNameNotIn) > 0 {
		predicates = append(predicates, file.ProvidedFileNameNotIn(i.ProvidedFileNameNotIn...))
	}
	if i.ProvidedFileNameGT != nil {
		predicates = append(predicates, file.ProvidedFileNameGT(*i.ProvidedFileNameGT))
	}
	if i.ProvidedFileNameGTE != nil {
		predicates = append(predicates, file.ProvidedFileNameGTE(*i.ProvidedFileNameGTE))
	}
	if i.ProvidedFileNameLT != nil {
		predicates = append(predicates, file.ProvidedFileNameLT(*i.ProvidedFileNameLT))
	}
	if i.ProvidedFileNameLTE != nil {
		predicates = append(predicates, file.ProvidedFileNameLTE(*i.ProvidedFileNameLTE))
	}
	if i.ProvidedFileNameContains != nil {
		predicates = append(predicates, file.ProvidedFileNameContains(*i.ProvidedFileNameContains))
	}
	if i.ProvidedFileNameHasPrefix != nil {
		predicates = append(predicates, file.ProvidedFileNameHasPrefix(*i.ProvidedFileNameHasPrefix))
	}
	if i.ProvidedFileNameHasSuffix != nil {
		predicates = append(predicates, file.ProvidedFileNameHasSuffix(*i.ProvidedFileNameHasSuffix))
	}
	if i.ProvidedFileNameEqualFold != nil {
		predicates = append(predicates, file.ProvidedFileNameEqualFold(*i.ProvidedFileNameEqualFold))
	}
	if i.ProvidedFileNameContainsFold != nil {
		predicates = append(predicates, file.ProvidedFileNameContainsFold(*i.ProvidedFileNameContainsFold))
	}
	if i.ProvidedFileExtension != nil {
		predicates = append(predicates, file.ProvidedFileExtensionEQ(*i.ProvidedFileExtension))
	}
	if i.ProvidedFileExtensionNEQ != nil {
		predicates = append(predicates, file.ProvidedFileExtensionNEQ(*i.ProvidedFileExtensionNEQ))
	}
	if len(i.ProvidedFileExtensionIn) > 0 {
		predicates = append(predicates, file.ProvidedFileExtensionIn(i.ProvidedFileExtensionIn...))
	}
	if len(i.ProvidedFileExtensionNotIn) > 0 {
		predicates = append(predicates, file.ProvidedFileExtensionNotIn(i.ProvidedFileExtensionNotIn...))
	}
	if i.ProvidedFileExtensionGT != nil {
		predicates = append(predicates, file.ProvidedFileExtensionGT(*i.ProvidedFileExtensionGT))
	}
	if i.ProvidedFileExtensionGTE != nil {
		predicates = append(predicates, file.ProvidedFileExtensionGTE(*i.ProvidedFileExtensionGTE))
	}
	if i.ProvidedFileExtensionLT != nil {
		predicates = append(predicates, file.ProvidedFileExtensionLT(*i.ProvidedFileExtensionLT))
	}
	if i.ProvidedFileExtensionLTE != nil {
		predicates = append(predicates, file.ProvidedFileExtensionLTE(*i.ProvidedFileExtensionLTE))
	}
	if i.ProvidedFileExtensionContains != nil {
		predicates = append(predicates, file.ProvidedFileExtensionContains(*i.ProvidedFileExtensionContains))
	}
	if i.ProvidedFileExtensionHasPrefix != nil {
		predicates = append(predicates, file.ProvidedFileExtensionHasPrefix(*i.ProvidedFileExtensionHasPrefix))
	}
	if i.ProvidedFileExtensionHasSuffix != nil {
		predicates = append(predicates, file.ProvidedFileExtensionHasSuffix(*i.ProvidedFileExtensionHasSuffix))
	}
	if i.ProvidedFileExtensionEqualFold != nil {
		predicates = append(predicates, file.ProvidedFileExtensionEqualFold(*i.ProvidedFileExtensionEqualFold))
	}
	if i.ProvidedFileExtensionContainsFold != nil {
		predicates = append(predicates, file.ProvidedFileExtensionContainsFold(*i.ProvidedFileExtensionContainsFold))
	}
	if i.ProvidedFileSize != nil {
		predicates = append(predicates, file.ProvidedFileSizeEQ(*i.ProvidedFileSize))
	}
	if i.ProvidedFileSizeNEQ != nil {
		predicates = append(predicates, file.ProvidedFileSizeNEQ(*i.ProvidedFileSizeNEQ))
	}
	if len(i.ProvidedFileSizeIn) > 0 {
		predicates = append(predicates, file.ProvidedFileSizeIn(i.ProvidedFileSizeIn...))
	}
	if len(i.ProvidedFileSizeNotIn) > 0 {
		predicates = append(predicates, file.ProvidedFileSizeNotIn(i.ProvidedFileSizeNotIn...))
	}
	if i.ProvidedFileSizeGT != nil {
		predicates = append(predicates, file.ProvidedFileSizeGT(*i.ProvidedFileSizeGT))
	}
	if i.ProvidedFileSizeGTE != nil {
		predicates = append(predicates, file.ProvidedFileSizeGTE(*i.ProvidedFileSizeGTE))
	}
	if i.ProvidedFileSizeLT != nil {
		predicates = append(predicates, file.ProvidedFileSizeLT(*i.ProvidedFileSizeLT))
	}
	if i.ProvidedFileSizeLTE != nil {
		predicates = append(predicates, file.ProvidedFileSizeLTE(*i.ProvidedFileSizeLTE))
	}
	if i.ProvidedFileSizeIsNil {
		predicates = append(predicates, file.ProvidedFileSizeIsNil())
	}
	if i.ProvidedFileSizeNotNil {
		predicates = append(predicates, file.ProvidedFileSizeNotNil())
	}
	if i.PersistedFileSize != nil {
		predicates = append(predicates, file.PersistedFileSizeEQ(*i.PersistedFileSize))
	}
	if i.PersistedFileSizeNEQ != nil {
		predicates = append(predicates, file.PersistedFileSizeNEQ(*i.PersistedFileSizeNEQ))
	}
	if len(i.PersistedFileSizeIn) > 0 {
		predicates = append(predicates, file.PersistedFileSizeIn(i.PersistedFileSizeIn...))
	}
	if len(i.PersistedFileSizeNotIn) > 0 {
		predicates = append(predicates, file.PersistedFileSizeNotIn(i.PersistedFileSizeNotIn...))
	}
	if i.PersistedFileSizeGT != nil {
		predicates = append(predicates, file.PersistedFileSizeGT(*i.PersistedFileSizeGT))
	}
	if i.PersistedFileSizeGTE != nil {
		predicates = append(predicates, file.PersistedFileSizeGTE(*i.PersistedFileSizeGTE))
	}
	if i.PersistedFileSizeLT != nil {
		predicates = append(predicates, file.PersistedFileSizeLT(*i.PersistedFileSizeLT))
	}
	if i.PersistedFileSizeLTE != nil {
		predicates = append(predicates, file.PersistedFileSizeLTE(*i.PersistedFileSizeLTE))
	}
	if i.PersistedFileSizeIsNil {
		predicates = append(predicates, file.PersistedFileSizeIsNil())
	}
	if i.PersistedFileSizeNotNil {
		predicates = append(predicates, file.PersistedFileSizeNotNil())
	}
	if i.DetectedMimeType != nil {
		predicates = append(predicates, file.DetectedMimeTypeEQ(*i.DetectedMimeType))
	}
	if i.DetectedMimeTypeNEQ != nil {
		predicates = append(predicates, file.DetectedMimeTypeNEQ(*i.DetectedMimeTypeNEQ))
	}
	if len(i.DetectedMimeTypeIn) > 0 {
		predicates = append(predicates, file.DetectedMimeTypeIn(i.DetectedMimeTypeIn...))
	}
	if len(i.DetectedMimeTypeNotIn) > 0 {
		predicates = append(predicates, file.DetectedMimeTypeNotIn(i.DetectedMimeTypeNotIn...))
	}
	if i.DetectedMimeTypeGT != nil {
		predicates = append(predicates, file.DetectedMimeTypeGT(*i.DetectedMimeTypeGT))
	}
	if i.DetectedMimeTypeGTE != nil {
		predicates = append(predicates, file.DetectedMimeTypeGTE(*i.DetectedMimeTypeGTE))
	}
	if i.DetectedMimeTypeLT != nil {
		predicates = append(predicates, file.DetectedMimeTypeLT(*i.DetectedMimeTypeLT))
	}
	if i.DetectedMimeTypeLTE != nil {
		predicates = append(predicates, file.DetectedMimeTypeLTE(*i.DetectedMimeTypeLTE))
	}
	if i.DetectedMimeTypeContains != nil {
		predicates = append(predicates, file.DetectedMimeTypeContains(*i.DetectedMimeTypeContains))
	}
	if i.DetectedMimeTypeHasPrefix != nil {
		predicates = append(predicates, file.DetectedMimeTypeHasPrefix(*i.DetectedMimeTypeHasPrefix))
	}
	if i.DetectedMimeTypeHasSuffix != nil {
		predicates = append(predicates, file.DetectedMimeTypeHasSuffix(*i.DetectedMimeTypeHasSuffix))
	}
	if i.DetectedMimeTypeIsNil {
		predicates = append(predicates, file.DetectedMimeTypeIsNil())
	}
	if i.DetectedMimeTypeNotNil {
		predicates = append(predicates, file.DetectedMimeTypeNotNil())
	}
	if i.DetectedMimeTypeEqualFold != nil {
		predicates = append(predicates, file.DetectedMimeTypeEqualFold(*i.DetectedMimeTypeEqualFold))
	}
	if i.DetectedMimeTypeContainsFold != nil {
		predicates = append(predicates, file.DetectedMimeTypeContainsFold(*i.DetectedMimeTypeContainsFold))
	}
	if i.Md5Hash != nil {
		predicates = append(predicates, file.Md5HashEQ(*i.Md5Hash))
	}
	if i.Md5HashNEQ != nil {
		predicates = append(predicates, file.Md5HashNEQ(*i.Md5HashNEQ))
	}
	if len(i.Md5HashIn) > 0 {
		predicates = append(predicates, file.Md5HashIn(i.Md5HashIn...))
	}
	if len(i.Md5HashNotIn) > 0 {
		predicates = append(predicates, file.Md5HashNotIn(i.Md5HashNotIn...))
	}
	if i.Md5HashGT != nil {
		predicates = append(predicates, file.Md5HashGT(*i.Md5HashGT))
	}
	if i.Md5HashGTE != nil {
		predicates = append(predicates, file.Md5HashGTE(*i.Md5HashGTE))
	}
	if i.Md5HashLT != nil {
		predicates = append(predicates, file.Md5HashLT(*i.Md5HashLT))
	}
	if i.Md5HashLTE != nil {
		predicates = append(predicates, file.Md5HashLTE(*i.Md5HashLTE))
	}
	if i.Md5HashContains != nil {
		predicates = append(predicates, file.Md5HashContains(*i.Md5HashContains))
	}
	if i.Md5HashHasPrefix != nil {
		predicates = append(predicates, file.Md5HashHasPrefix(*i.Md5HashHasPrefix))
	}
	if i.Md5HashHasSuffix != nil {
		predicates = append(predicates, file.Md5HashHasSuffix(*i.Md5HashHasSuffix))
	}
	if i.Md5HashIsNil {
		predicates = append(predicates, file.Md5HashIsNil())
	}
	if i.Md5HashNotNil {
		predicates = append(predicates, file.Md5HashNotNil())
	}
	if i.Md5HashEqualFold != nil {
		predicates = append(predicates, file.Md5HashEqualFold(*i.Md5HashEqualFold))
	}
	if i.Md5HashContainsFold != nil {
		predicates = append(predicates, file.Md5HashContainsFold(*i.Md5HashContainsFold))
	}
	if i.DetectedContentType != nil {
		predicates = append(predicates, file.DetectedContentTypeEQ(*i.DetectedContentType))
	}
	if i.DetectedContentTypeNEQ != nil {
		predicates = append(predicates, file.DetectedContentTypeNEQ(*i.DetectedContentTypeNEQ))
	}
	if len(i.DetectedContentTypeIn) > 0 {
		predicates = append(predicates, file.DetectedContentTypeIn(i.DetectedContentTypeIn...))
	}
	if len(i.DetectedContentTypeNotIn) > 0 {
		predicates = append(predicates, file.DetectedContentTypeNotIn(i.DetectedContentTypeNotIn...))
	}
	if i.DetectedContentTypeGT != nil {
		predicates = append(predicates, file.DetectedContentTypeGT(*i.DetectedContentTypeGT))
	}
	if i.DetectedContentTypeGTE != nil {
		predicates = append(predicates, file.DetectedContentTypeGTE(*i.DetectedContentTypeGTE))
	}
	if i.DetectedContentTypeLT != nil {
		predicates = append(predicates, file.DetectedContentTypeLT(*i.DetectedContentTypeLT))
	}
	if i.DetectedContentTypeLTE != nil {
		predicates = append(predicates, file.DetectedContentTypeLTE(*i.DetectedContentTypeLTE))
	}
	if i.DetectedContentTypeContains != nil {
		predicates = append(predicates, file.DetectedContentTypeContains(*i.DetectedContentTypeContains))
	}
	if i.DetectedContentTypeHasPrefix != nil {
		predicates = append(predicates, file.DetectedContentTypeHasPrefix(*i.DetectedContentTypeHasPrefix))
	}
	if i.DetectedContentTypeHasSuffix != nil {
		predicates = append(predicates, file.DetectedContentTypeHasSuffix(*i.DetectedContentTypeHasSuffix))
	}
	if i.DetectedContentTypeEqualFold != nil {
		predicates = append(predicates, file.DetectedContentTypeEqualFold(*i.DetectedContentTypeEqualFold))
	}
	if i.DetectedContentTypeContainsFold != nil {
		predicates = append(predicates, file.DetectedContentTypeContainsFold(*i.DetectedContentTypeContainsFold))
	}
	if i.StoreKey != nil {
		predicates = append(predicates, file.StoreKeyEQ(*i.StoreKey))
	}
	if i.StoreKeyNEQ != nil {
		predicates = append(predicates, file.StoreKeyNEQ(*i.StoreKeyNEQ))
	}
	if len(i.StoreKeyIn) > 0 {
		predicates = append(predicates, file.StoreKeyIn(i.StoreKeyIn...))
	}
	if len(i.StoreKeyNotIn) > 0 {
		predicates = append(predicates, file.StoreKeyNotIn(i.StoreKeyNotIn...))
	}
	if i.StoreKeyGT != nil {
		predicates = append(predicates, file.StoreKeyGT(*i.StoreKeyGT))
	}
	if i.StoreKeyGTE != nil {
		predicates = append(predicates, file.StoreKeyGTE(*i.StoreKeyGTE))
	}
	if i.StoreKeyLT != nil {
		predicates = append(predicates, file.StoreKeyLT(*i.StoreKeyLT))
	}
	if i.StoreKeyLTE != nil {
		predicates = append(predicates, file.StoreKeyLTE(*i.StoreKeyLTE))
	}
	if i.StoreKeyContains != nil {
		predicates = append(predicates, file.StoreKeyContains(*i.StoreKeyContains))
	}
	if i.StoreKeyHasPrefix != nil {
		predicates = append(predicates, file.StoreKeyHasPrefix(*i.StoreKeyHasPrefix))
	}
	if i.StoreKeyHasSuffix != nil {
		predicates = append(predicates, file.StoreKeyHasSuffix(*i.StoreKeyHasSuffix))
	}
	if i.StoreKeyIsNil {
		predicates = append(predicates, file.StoreKeyIsNil())
	}
	if i.StoreKeyNotNil {
		predicates = append(predicates, file.StoreKeyNotNil())
	}
	if i.StoreKeyEqualFold != nil {
		predicates = append(predicates, file.StoreKeyEqualFold(*i.StoreKeyEqualFold))
	}
	if i.StoreKeyContainsFold != nil {
		predicates = append(predicates, file.StoreKeyContainsFold(*i.StoreKeyContainsFold))
	}
	if i.CategoryType != nil {
		predicates = append(predicates, file.CategoryTypeEQ(*i.CategoryType))
	}
	if i.CategoryTypeNEQ != nil {
		predicates = append(predicates, file.CategoryTypeNEQ(*i.CategoryTypeNEQ))
	}
	if len(i.CategoryTypeIn) > 0 {
		predicates = append(predicates, file.CategoryTypeIn(i.CategoryTypeIn...))
	}
	if len(i.CategoryTypeNotIn) > 0 {
		predicates = append(predicates, file.CategoryTypeNotIn(i.CategoryTypeNotIn...))
	}
	if i.CategoryTypeGT != nil {
		predicates = append(predicates, file.CategoryTypeGT(*i.CategoryTypeGT))
	}
	if i.CategoryTypeGTE != nil {
		predicates = append(predicates, file.CategoryTypeGTE(*i.CategoryTypeGTE))
	}
	if i.CategoryTypeLT != nil {
		predicates = append(predicates, file.CategoryTypeLT(*i.CategoryTypeLT))
	}
	if i.CategoryTypeLTE != nil {
		predicates = append(predicates, file.CategoryTypeLTE(*i.CategoryTypeLTE))
	}
	if i.CategoryTypeContains != nil {
		predicates = append(predicates, file.CategoryTypeContains(*i.CategoryTypeContains))
	}
	if i.CategoryTypeHasPrefix != nil {
		predicates = append(predicates, file.CategoryTypeHasPrefix(*i.CategoryTypeHasPrefix))
	}
	if i.CategoryTypeHasSuffix != nil {
		predicates = append(predicates, file.CategoryTypeHasSuffix(*i.CategoryTypeHasSuffix))
	}
	if i.CategoryTypeIsNil {
		predicates = append(predicates, file.CategoryTypeIsNil())
	}
	if i.CategoryTypeNotNil {
		predicates = append(predicates, file.CategoryTypeNotNil())
	}
	if i.CategoryTypeEqualFold != nil {
		predicates = append(predicates, file.CategoryTypeEqualFold(*i.CategoryTypeEqualFold))
	}
	if i.CategoryTypeContainsFold != nil {
		predicates = append(predicates, file.CategoryTypeContainsFold(*i.CategoryTypeContainsFold))
	}
	if i.URI != nil {
		predicates = append(predicates, file.URIEQ(*i.URI))
	}
	if i.URINEQ != nil {
		predicates = append(predicates, file.URINEQ(*i.URINEQ))
	}
	if len(i.URIIn) > 0 {
		predicates = append(predicates, file.URIIn(i.URIIn...))
	}
	if len(i.URINotIn) > 0 {
		predicates = append(predicates, file.URINotIn(i.URINotIn...))
	}
	if i.URIGT != nil {
		predicates = append(predicates, file.URIGT(*i.URIGT))
	}
	if i.URIGTE != nil {
		predicates = append(predicates, file.URIGTE(*i.URIGTE))
	}
	if i.URILT != nil {
		predicates = append(predicates, file.URILT(*i.URILT))
	}
	if i.URILTE != nil {
		predicates = append(predicates, file.URILTE(*i.URILTE))
	}
	if i.URIContains != nil {
		predicates = append(predicates, file.URIContains(*i.URIContains))
	}
	if i.URIHasPrefix != nil {
		predicates = append(predicates, file.URIHasPrefix(*i.URIHasPrefix))
	}
	if i.URIHasSuffix != nil {
		predicates = append(predicates, file.URIHasSuffix(*i.URIHasSuffix))
	}
	if i.URIIsNil {
		predicates = append(predicates, file.URIIsNil())
	}
	if i.URINotNil {
		predicates = append(predicates, file.URINotNil())
	}
	if i.URIEqualFold != nil {
		predicates = append(predicates, file.URIEqualFold(*i.URIEqualFold))
	}
	if i.URIContainsFold != nil {
		predicates = append(predicates, file.URIContainsFold(*i.URIContainsFold))
	}
	if i.StorageScheme != nil {
		predicates = append(predicates, file.StorageSchemeEQ(*i.StorageScheme))
	}
	if i.StorageSchemeNEQ != nil {
		predicates = append(predicates, file.StorageSchemeNEQ(*i.StorageSchemeNEQ))
	}
	if len(i.StorageSchemeIn) > 0 {
		predicates = append(predicates, file.StorageSchemeIn(i.StorageSchemeIn...))
	}
	if len(i.StorageSchemeNotIn) > 0 {
		predicates = append(predicates, file.StorageSchemeNotIn(i.StorageSchemeNotIn...))
	}
	if i.StorageSchemeGT != nil {
		predicates = append(predicates, file.StorageSchemeGT(*i.StorageSchemeGT))
	}
	if i.StorageSchemeGTE != nil {
		predicates = append(predicates, file.StorageSchemeGTE(*i.StorageSchemeGTE))
	}
	if i.StorageSchemeLT != nil {
		predicates = append(predicates, file.StorageSchemeLT(*i.StorageSchemeLT))
	}
	if i.StorageSchemeLTE != nil {
		predicates = append(predicates, file.StorageSchemeLTE(*i.StorageSchemeLTE))
	}
	if i.StorageSchemeContains != nil {
		predicates = append(predicates, file.StorageSchemeContains(*i.StorageSchemeContains))
	}
	if i.StorageSchemeHasPrefix != nil {
		predicates = append(predicates, file.StorageSchemeHasPrefix(*i.StorageSchemeHasPrefix))
	}
	if i.StorageSchemeHasSuffix != nil {
		predicates = append(predicates, file.StorageSchemeHasSuffix(*i.StorageSchemeHasSuffix))
	}
	if i.StorageSchemeIsNil {
		predicates = append(predicates, file.StorageSchemeIsNil())
	}
	if i.StorageSchemeNotNil {
		predicates = append(predicates, file.StorageSchemeNotNil())
	}
	if i.StorageSchemeEqualFold != nil {
		predicates = append(predicates, file.StorageSchemeEqualFold(*i.StorageSchemeEqualFold))
	}
	if i.StorageSchemeContainsFold != nil {
		predicates = append(predicates, file.StorageSchemeContainsFold(*i.StorageSchemeContainsFold))
	}
	if i.StorageVolume != nil {
		predicates = append(predicates, file.StorageVolumeEQ(*i.StorageVolume))
	}
	if i.StorageVolumeNEQ != nil {
		predicates = append(predicates, file.StorageVolumeNEQ(*i.StorageVolumeNEQ))
	}
	if len(i.StorageVolumeIn) > 0 {
		predicates = append(predicates, file.StorageVolumeIn(i.StorageVolumeIn...))
	}
	if len(i.StorageVolumeNotIn) > 0 {
		predicates = append(predicates, file.StorageVolumeNotIn(i.StorageVolumeNotIn...))
	}
	if i.StorageVolumeGT != nil {
		predicates = append(predicates, file.StorageVolumeGT(*i.StorageVolumeGT))
	}
	if i.StorageVolumeGTE != nil {
		predicates = append(predicates, file.StorageVolumeGTE(*i.StorageVolumeGTE))
	}
	if i.StorageVolumeLT != nil {
		predicates = append(predicates, file.StorageVolumeLT(*i.StorageVolumeLT))
	}
	if i.StorageVolumeLTE != nil {
		predicates = append(predicates, file.StorageVolumeLTE(*i.StorageVolumeLTE))
	}
	if i.StorageVolumeContains != nil {
		predicates = append(predicates, file.StorageVolumeContains(*i.StorageVolumeContains))
	}
	if i.StorageVolumeHasPrefix != nil {
		predicates = append(predicates, file.StorageVolumeHasPrefix(*i.StorageVolumeHasPrefix))
	}
	if i.StorageVolumeHasSuffix != nil {
		predicates = append(predicates, file.StorageVolumeHasSuffix(*i.StorageVolumeHasSuffix))
	}
	if i.StorageVolumeIsNil {
		predicates = append(predicates, file.StorageVolumeIsNil())
	}
	if i.StorageVolumeNotNil {
		predicates = append(predicates, file.StorageVolumeNotNil())
	}
	if i.StorageVolumeEqualFold != nil {
		predicates = append(predicates, file.StorageVolumeEqualFold(*i.StorageVolumeEqualFold))
	}
	if i.StorageVolumeContainsFold != nil {
		predicates = append(predicates, file.StorageVolumeContainsFold(*i.StorageVolumeContainsFold))
	}
	if i.StoragePath != nil {
		predicates = append(predicates, file.StoragePathEQ(*i.StoragePath))
	}
	if i.StoragePathNEQ != nil {
		predicates = append(predicates, file.StoragePathNEQ(*i.StoragePathNEQ))
	}
	if len(i.StoragePathIn) > 0 {
		predicates = append(predicates, file.StoragePathIn(i.StoragePathIn...))
	}
	if len(i.StoragePathNotIn) > 0 {
		predicates = append(predicates, file.StoragePathNotIn(i.StoragePathNotIn...))
	}
	if i.StoragePathGT != nil {
		predicates = append(predicates, file.StoragePathGT(*i.StoragePathGT))
	}
	if i.StoragePathGTE != nil {
		predicates = append(predicates, file.StoragePathGTE(*i.StoragePathGTE))
	}
	if i.StoragePathLT != nil {
		predicates = append(predicates, file.StoragePathLT(*i.StoragePathLT))
	}
	if i.StoragePathLTE != nil {
		predicates = append(predicates, file.StoragePathLTE(*i.StoragePathLTE))
	}
	if i.StoragePathContains != nil {
		predicates = append(predicates, file.StoragePathContains(*i.StoragePathContains))
	}
	if i.StoragePathHasPrefix != nil {
		predicates = append(predicates, file.StoragePathHasPrefix(*i.StoragePathHasPrefix))
	}
	if i.StoragePathHasSuffix != nil {
		predicates = append(predicates, file.StoragePathHasSuffix(*i.StoragePathHasSuffix))
	}
	if i.StoragePathIsNil {
		predicates = append(predicates, file.StoragePathIsNil())
	}
	if i.StoragePathNotNil {
		predicates = append(predicates, file.StoragePathNotNil())
	}
	if i.StoragePathEqualFold != nil {
		predicates = append(predicates, file.StoragePathEqualFold(*i.StoragePathEqualFold))
	}
	if i.StoragePathContainsFold != nil {
		predicates = append(predicates, file.StoragePathContainsFold(*i.StoragePathContainsFold))
	}

	if i.HasUser != nil {
		p := file.HasUser()
		if !*i.HasUser {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasUserWith(with...))
	}
	if i.HasOrganization != nil {
		p := file.HasOrganization()
		if !*i.HasOrganization {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrganizationWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOrganizationWith))
		for _, w := range i.HasOrganizationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrganizationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasOrganizationWith(with...))
	}
	if i.HasGroups != nil {
		p := file.HasGroups()
		if !*i.HasGroups {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasGroupsWith))
		for _, w := range i.HasGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasGroupsWith(with...))
	}
	if i.HasContact != nil {
		p := file.HasContact()
		if !*i.HasContact {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasContactWith) > 0 {
		with := make([]predicate.Contact, 0, len(i.HasContactWith))
		for _, w := range i.HasContactWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasContactWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasContactWith(with...))
	}
	if i.HasEntity != nil {
		p := file.HasEntity()
		if !*i.HasEntity {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEntityWith) > 0 {
		with := make([]predicate.Entity, 0, len(i.HasEntityWith))
		for _, w := range i.HasEntityWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEntityWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasEntityWith(with...))
	}
	if i.HasUserSetting != nil {
		p := file.HasUserSetting()
		if !*i.HasUserSetting {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserSettingWith) > 0 {
		with := make([]predicate.UserSetting, 0, len(i.HasUserSettingWith))
		for _, w := range i.HasUserSettingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserSettingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasUserSettingWith(with...))
	}
	if i.HasOrganizationSetting != nil {
		p := file.HasOrganizationSetting()
		if !*i.HasOrganizationSetting {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrganizationSettingWith) > 0 {
		with := make([]predicate.OrganizationSetting, 0, len(i.HasOrganizationSettingWith))
		for _, w := range i.HasOrganizationSettingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrganizationSettingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasOrganizationSettingWith(with...))
	}
	if i.HasTemplate != nil {
		p := file.HasTemplate()
		if !*i.HasTemplate {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTemplateWith) > 0 {
		with := make([]predicate.Template, 0, len(i.HasTemplateWith))
		for _, w := range i.HasTemplateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTemplateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasTemplateWith(with...))
	}
	if i.HasDocument != nil {
		p := file.HasDocument()
		if !*i.HasDocument {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentWith) > 0 {
		with := make([]predicate.DocumentData, 0, len(i.HasDocumentWith))
		for _, w := range i.HasDocumentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasDocumentWith(with...))
	}
	if i.HasProgram != nil {
		p := file.HasProgram()
		if !*i.HasProgram {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramWith))
		for _, w := range i.HasProgramWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasProgramWith(with...))
	}
	if i.HasEvidence != nil {
		p := file.HasEvidence()
		if !*i.HasEvidence {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEvidenceWith) > 0 {
		with := make([]predicate.Evidence, 0, len(i.HasEvidenceWith))
		for _, w := range i.HasEvidenceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEvidenceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasEvidenceWith(with...))
	}
	if i.HasEvents != nil {
		p := file.HasEvents()
		if !*i.HasEvents {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventsWith) > 0 {
		with := make([]predicate.Event, 0, len(i.HasEventsWith))
		for _, w := range i.HasEventsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasEventsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return file.And(predicates...), nil
	}
}

// FileHistoryWhereInput represents a where input for filtering FileHistory queries.
type FileHistoryWhereInput struct {
	Predicates []predicate.FileHistory  `json:"-"`
	Not        *FileHistoryWhereInput   `json:"not,omitempty"`
	Or         []*FileHistoryWhereInput `json:"or,omitempty"`
	And        []*FileHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "provided_file_name" field predicates.
	ProvidedFileName             *string  `json:"providedFileName,omitempty"`
	ProvidedFileNameNEQ          *string  `json:"providedFileNameNEQ,omitempty"`
	ProvidedFileNameIn           []string `json:"providedFileNameIn,omitempty"`
	ProvidedFileNameNotIn        []string `json:"providedFileNameNotIn,omitempty"`
	ProvidedFileNameGT           *string  `json:"providedFileNameGT,omitempty"`
	ProvidedFileNameGTE          *string  `json:"providedFileNameGTE,omitempty"`
	ProvidedFileNameLT           *string  `json:"providedFileNameLT,omitempty"`
	ProvidedFileNameLTE          *string  `json:"providedFileNameLTE,omitempty"`
	ProvidedFileNameContains     *string  `json:"providedFileNameContains,omitempty"`
	ProvidedFileNameHasPrefix    *string  `json:"providedFileNameHasPrefix,omitempty"`
	ProvidedFileNameHasSuffix    *string  `json:"providedFileNameHasSuffix,omitempty"`
	ProvidedFileNameEqualFold    *string  `json:"providedFileNameEqualFold,omitempty"`
	ProvidedFileNameContainsFold *string  `json:"providedFileNameContainsFold,omitempty"`

	// "provided_file_extension" field predicates.
	ProvidedFileExtension             *string  `json:"providedFileExtension,omitempty"`
	ProvidedFileExtensionNEQ          *string  `json:"providedFileExtensionNEQ,omitempty"`
	ProvidedFileExtensionIn           []string `json:"providedFileExtensionIn,omitempty"`
	ProvidedFileExtensionNotIn        []string `json:"providedFileExtensionNotIn,omitempty"`
	ProvidedFileExtensionGT           *string  `json:"providedFileExtensionGT,omitempty"`
	ProvidedFileExtensionGTE          *string  `json:"providedFileExtensionGTE,omitempty"`
	ProvidedFileExtensionLT           *string  `json:"providedFileExtensionLT,omitempty"`
	ProvidedFileExtensionLTE          *string  `json:"providedFileExtensionLTE,omitempty"`
	ProvidedFileExtensionContains     *string  `json:"providedFileExtensionContains,omitempty"`
	ProvidedFileExtensionHasPrefix    *string  `json:"providedFileExtensionHasPrefix,omitempty"`
	ProvidedFileExtensionHasSuffix    *string  `json:"providedFileExtensionHasSuffix,omitempty"`
	ProvidedFileExtensionEqualFold    *string  `json:"providedFileExtensionEqualFold,omitempty"`
	ProvidedFileExtensionContainsFold *string  `json:"providedFileExtensionContainsFold,omitempty"`

	// "provided_file_size" field predicates.
	ProvidedFileSize       *int64  `json:"providedFileSize,omitempty"`
	ProvidedFileSizeNEQ    *int64  `json:"providedFileSizeNEQ,omitempty"`
	ProvidedFileSizeIn     []int64 `json:"providedFileSizeIn,omitempty"`
	ProvidedFileSizeNotIn  []int64 `json:"providedFileSizeNotIn,omitempty"`
	ProvidedFileSizeGT     *int64  `json:"providedFileSizeGT,omitempty"`
	ProvidedFileSizeGTE    *int64  `json:"providedFileSizeGTE,omitempty"`
	ProvidedFileSizeLT     *int64  `json:"providedFileSizeLT,omitempty"`
	ProvidedFileSizeLTE    *int64  `json:"providedFileSizeLTE,omitempty"`
	ProvidedFileSizeIsNil  bool    `json:"providedFileSizeIsNil,omitempty"`
	ProvidedFileSizeNotNil bool    `json:"providedFileSizeNotNil,omitempty"`

	// "persisted_file_size" field predicates.
	PersistedFileSize       *int64  `json:"persistedFileSize,omitempty"`
	PersistedFileSizeNEQ    *int64  `json:"persistedFileSizeNEQ,omitempty"`
	PersistedFileSizeIn     []int64 `json:"persistedFileSizeIn,omitempty"`
	PersistedFileSizeNotIn  []int64 `json:"persistedFileSizeNotIn,omitempty"`
	PersistedFileSizeGT     *int64  `json:"persistedFileSizeGT,omitempty"`
	PersistedFileSizeGTE    *int64  `json:"persistedFileSizeGTE,omitempty"`
	PersistedFileSizeLT     *int64  `json:"persistedFileSizeLT,omitempty"`
	PersistedFileSizeLTE    *int64  `json:"persistedFileSizeLTE,omitempty"`
	PersistedFileSizeIsNil  bool    `json:"persistedFileSizeIsNil,omitempty"`
	PersistedFileSizeNotNil bool    `json:"persistedFileSizeNotNil,omitempty"`

	// "detected_mime_type" field predicates.
	DetectedMimeType             *string  `json:"detectedMimeType,omitempty"`
	DetectedMimeTypeNEQ          *string  `json:"detectedMimeTypeNEQ,omitempty"`
	DetectedMimeTypeIn           []string `json:"detectedMimeTypeIn,omitempty"`
	DetectedMimeTypeNotIn        []string `json:"detectedMimeTypeNotIn,omitempty"`
	DetectedMimeTypeGT           *string  `json:"detectedMimeTypeGT,omitempty"`
	DetectedMimeTypeGTE          *string  `json:"detectedMimeTypeGTE,omitempty"`
	DetectedMimeTypeLT           *string  `json:"detectedMimeTypeLT,omitempty"`
	DetectedMimeTypeLTE          *string  `json:"detectedMimeTypeLTE,omitempty"`
	DetectedMimeTypeContains     *string  `json:"detectedMimeTypeContains,omitempty"`
	DetectedMimeTypeHasPrefix    *string  `json:"detectedMimeTypeHasPrefix,omitempty"`
	DetectedMimeTypeHasSuffix    *string  `json:"detectedMimeTypeHasSuffix,omitempty"`
	DetectedMimeTypeIsNil        bool     `json:"detectedMimeTypeIsNil,omitempty"`
	DetectedMimeTypeNotNil       bool     `json:"detectedMimeTypeNotNil,omitempty"`
	DetectedMimeTypeEqualFold    *string  `json:"detectedMimeTypeEqualFold,omitempty"`
	DetectedMimeTypeContainsFold *string  `json:"detectedMimeTypeContainsFold,omitempty"`

	// "md5_hash" field predicates.
	Md5Hash             *string  `json:"md5Hash,omitempty"`
	Md5HashNEQ          *string  `json:"md5HashNEQ,omitempty"`
	Md5HashIn           []string `json:"md5HashIn,omitempty"`
	Md5HashNotIn        []string `json:"md5HashNotIn,omitempty"`
	Md5HashGT           *string  `json:"md5HashGT,omitempty"`
	Md5HashGTE          *string  `json:"md5HashGTE,omitempty"`
	Md5HashLT           *string  `json:"md5HashLT,omitempty"`
	Md5HashLTE          *string  `json:"md5HashLTE,omitempty"`
	Md5HashContains     *string  `json:"md5HashContains,omitempty"`
	Md5HashHasPrefix    *string  `json:"md5HashHasPrefix,omitempty"`
	Md5HashHasSuffix    *string  `json:"md5HashHasSuffix,omitempty"`
	Md5HashIsNil        bool     `json:"md5HashIsNil,omitempty"`
	Md5HashNotNil       bool     `json:"md5HashNotNil,omitempty"`
	Md5HashEqualFold    *string  `json:"md5HashEqualFold,omitempty"`
	Md5HashContainsFold *string  `json:"md5HashContainsFold,omitempty"`

	// "detected_content_type" field predicates.
	DetectedContentType             *string  `json:"detectedContentType,omitempty"`
	DetectedContentTypeNEQ          *string  `json:"detectedContentTypeNEQ,omitempty"`
	DetectedContentTypeIn           []string `json:"detectedContentTypeIn,omitempty"`
	DetectedContentTypeNotIn        []string `json:"detectedContentTypeNotIn,omitempty"`
	DetectedContentTypeGT           *string  `json:"detectedContentTypeGT,omitempty"`
	DetectedContentTypeGTE          *string  `json:"detectedContentTypeGTE,omitempty"`
	DetectedContentTypeLT           *string  `json:"detectedContentTypeLT,omitempty"`
	DetectedContentTypeLTE          *string  `json:"detectedContentTypeLTE,omitempty"`
	DetectedContentTypeContains     *string  `json:"detectedContentTypeContains,omitempty"`
	DetectedContentTypeHasPrefix    *string  `json:"detectedContentTypeHasPrefix,omitempty"`
	DetectedContentTypeHasSuffix    *string  `json:"detectedContentTypeHasSuffix,omitempty"`
	DetectedContentTypeEqualFold    *string  `json:"detectedContentTypeEqualFold,omitempty"`
	DetectedContentTypeContainsFold *string  `json:"detectedContentTypeContainsFold,omitempty"`

	// "store_key" field predicates.
	StoreKey             *string  `json:"storeKey,omitempty"`
	StoreKeyNEQ          *string  `json:"storeKeyNEQ,omitempty"`
	StoreKeyIn           []string `json:"storeKeyIn,omitempty"`
	StoreKeyNotIn        []string `json:"storeKeyNotIn,omitempty"`
	StoreKeyGT           *string  `json:"storeKeyGT,omitempty"`
	StoreKeyGTE          *string  `json:"storeKeyGTE,omitempty"`
	StoreKeyLT           *string  `json:"storeKeyLT,omitempty"`
	StoreKeyLTE          *string  `json:"storeKeyLTE,omitempty"`
	StoreKeyContains     *string  `json:"storeKeyContains,omitempty"`
	StoreKeyHasPrefix    *string  `json:"storeKeyHasPrefix,omitempty"`
	StoreKeyHasSuffix    *string  `json:"storeKeyHasSuffix,omitempty"`
	StoreKeyIsNil        bool     `json:"storeKeyIsNil,omitempty"`
	StoreKeyNotNil       bool     `json:"storeKeyNotNil,omitempty"`
	StoreKeyEqualFold    *string  `json:"storeKeyEqualFold,omitempty"`
	StoreKeyContainsFold *string  `json:"storeKeyContainsFold,omitempty"`

	// "category_type" field predicates.
	CategoryType             *string  `json:"categoryType,omitempty"`
	CategoryTypeNEQ          *string  `json:"categoryTypeNEQ,omitempty"`
	CategoryTypeIn           []string `json:"categoryTypeIn,omitempty"`
	CategoryTypeNotIn        []string `json:"categoryTypeNotIn,omitempty"`
	CategoryTypeGT           *string  `json:"categoryTypeGT,omitempty"`
	CategoryTypeGTE          *string  `json:"categoryTypeGTE,omitempty"`
	CategoryTypeLT           *string  `json:"categoryTypeLT,omitempty"`
	CategoryTypeLTE          *string  `json:"categoryTypeLTE,omitempty"`
	CategoryTypeContains     *string  `json:"categoryTypeContains,omitempty"`
	CategoryTypeHasPrefix    *string  `json:"categoryTypeHasPrefix,omitempty"`
	CategoryTypeHasSuffix    *string  `json:"categoryTypeHasSuffix,omitempty"`
	CategoryTypeIsNil        bool     `json:"categoryTypeIsNil,omitempty"`
	CategoryTypeNotNil       bool     `json:"categoryTypeNotNil,omitempty"`
	CategoryTypeEqualFold    *string  `json:"categoryTypeEqualFold,omitempty"`
	CategoryTypeContainsFold *string  `json:"categoryTypeContainsFold,omitempty"`

	// "uri" field predicates.
	URI             *string  `json:"uri,omitempty"`
	URINEQ          *string  `json:"uriNEQ,omitempty"`
	URIIn           []string `json:"uriIn,omitempty"`
	URINotIn        []string `json:"uriNotIn,omitempty"`
	URIGT           *string  `json:"uriGT,omitempty"`
	URIGTE          *string  `json:"uriGTE,omitempty"`
	URILT           *string  `json:"uriLT,omitempty"`
	URILTE          *string  `json:"uriLTE,omitempty"`
	URIContains     *string  `json:"uriContains,omitempty"`
	URIHasPrefix    *string  `json:"uriHasPrefix,omitempty"`
	URIHasSuffix    *string  `json:"uriHasSuffix,omitempty"`
	URIIsNil        bool     `json:"uriIsNil,omitempty"`
	URINotNil       bool     `json:"uriNotNil,omitempty"`
	URIEqualFold    *string  `json:"uriEqualFold,omitempty"`
	URIContainsFold *string  `json:"uriContainsFold,omitempty"`

	// "storage_scheme" field predicates.
	StorageScheme             *string  `json:"storageScheme,omitempty"`
	StorageSchemeNEQ          *string  `json:"storageSchemeNEQ,omitempty"`
	StorageSchemeIn           []string `json:"storageSchemeIn,omitempty"`
	StorageSchemeNotIn        []string `json:"storageSchemeNotIn,omitempty"`
	StorageSchemeGT           *string  `json:"storageSchemeGT,omitempty"`
	StorageSchemeGTE          *string  `json:"storageSchemeGTE,omitempty"`
	StorageSchemeLT           *string  `json:"storageSchemeLT,omitempty"`
	StorageSchemeLTE          *string  `json:"storageSchemeLTE,omitempty"`
	StorageSchemeContains     *string  `json:"storageSchemeContains,omitempty"`
	StorageSchemeHasPrefix    *string  `json:"storageSchemeHasPrefix,omitempty"`
	StorageSchemeHasSuffix    *string  `json:"storageSchemeHasSuffix,omitempty"`
	StorageSchemeIsNil        bool     `json:"storageSchemeIsNil,omitempty"`
	StorageSchemeNotNil       bool     `json:"storageSchemeNotNil,omitempty"`
	StorageSchemeEqualFold    *string  `json:"storageSchemeEqualFold,omitempty"`
	StorageSchemeContainsFold *string  `json:"storageSchemeContainsFold,omitempty"`

	// "storage_volume" field predicates.
	StorageVolume             *string  `json:"storageVolume,omitempty"`
	StorageVolumeNEQ          *string  `json:"storageVolumeNEQ,omitempty"`
	StorageVolumeIn           []string `json:"storageVolumeIn,omitempty"`
	StorageVolumeNotIn        []string `json:"storageVolumeNotIn,omitempty"`
	StorageVolumeGT           *string  `json:"storageVolumeGT,omitempty"`
	StorageVolumeGTE          *string  `json:"storageVolumeGTE,omitempty"`
	StorageVolumeLT           *string  `json:"storageVolumeLT,omitempty"`
	StorageVolumeLTE          *string  `json:"storageVolumeLTE,omitempty"`
	StorageVolumeContains     *string  `json:"storageVolumeContains,omitempty"`
	StorageVolumeHasPrefix    *string  `json:"storageVolumeHasPrefix,omitempty"`
	StorageVolumeHasSuffix    *string  `json:"storageVolumeHasSuffix,omitempty"`
	StorageVolumeIsNil        bool     `json:"storageVolumeIsNil,omitempty"`
	StorageVolumeNotNil       bool     `json:"storageVolumeNotNil,omitempty"`
	StorageVolumeEqualFold    *string  `json:"storageVolumeEqualFold,omitempty"`
	StorageVolumeContainsFold *string  `json:"storageVolumeContainsFold,omitempty"`

	// "storage_path" field predicates.
	StoragePath             *string  `json:"storagePath,omitempty"`
	StoragePathNEQ          *string  `json:"storagePathNEQ,omitempty"`
	StoragePathIn           []string `json:"storagePathIn,omitempty"`
	StoragePathNotIn        []string `json:"storagePathNotIn,omitempty"`
	StoragePathGT           *string  `json:"storagePathGT,omitempty"`
	StoragePathGTE          *string  `json:"storagePathGTE,omitempty"`
	StoragePathLT           *string  `json:"storagePathLT,omitempty"`
	StoragePathLTE          *string  `json:"storagePathLTE,omitempty"`
	StoragePathContains     *string  `json:"storagePathContains,omitempty"`
	StoragePathHasPrefix    *string  `json:"storagePathHasPrefix,omitempty"`
	StoragePathHasSuffix    *string  `json:"storagePathHasSuffix,omitempty"`
	StoragePathIsNil        bool     `json:"storagePathIsNil,omitempty"`
	StoragePathNotNil       bool     `json:"storagePathNotNil,omitempty"`
	StoragePathEqualFold    *string  `json:"storagePathEqualFold,omitempty"`
	StoragePathContainsFold *string  `json:"storagePathContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FileHistoryWhereInput) AddPredicates(predicates ...predicate.FileHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FileHistoryWhereInput filter on the FileHistoryQuery builder.
func (i *FileHistoryWhereInput) Filter(q *FileHistoryQuery) (*FileHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFileHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFileHistoryWhereInput is returned in case the FileHistoryWhereInput is empty.
var ErrEmptyFileHistoryWhereInput = errors.New("generated: empty predicate FileHistoryWhereInput")

// P returns a predicate for filtering filehistories.
// An error is returned if the input is empty or invalid.
func (i *FileHistoryWhereInput) P() (predicate.FileHistory, error) {
	var predicates []predicate.FileHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, filehistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.FileHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, filehistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.FileHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, filehistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, filehistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, filehistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, filehistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, filehistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, filehistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, filehistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, filehistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, filehistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, filehistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, filehistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, filehistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, filehistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, filehistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, filehistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, filehistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, filehistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, filehistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, filehistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, filehistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, filehistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, filehistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, filehistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, filehistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, filehistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, filehistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, filehistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, filehistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, filehistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, filehistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, filehistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, filehistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, filehistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, filehistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, filehistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, filehistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, filehistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, filehistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, filehistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, filehistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, filehistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, filehistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, filehistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, filehistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, filehistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, filehistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, filehistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, filehistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, filehistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, filehistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, filehistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, filehistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, filehistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, filehistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, filehistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, filehistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, filehistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, filehistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, filehistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, filehistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, filehistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, filehistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, filehistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, filehistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, filehistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, filehistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, filehistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, filehistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, filehistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, filehistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, filehistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, filehistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, filehistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, filehistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, filehistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, filehistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, filehistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, filehistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, filehistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, filehistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, filehistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, filehistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, filehistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, filehistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, filehistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, filehistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, filehistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, filehistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.ProvidedFileName != nil {
		predicates = append(predicates, filehistory.ProvidedFileNameEQ(*i.ProvidedFileName))
	}
	if i.ProvidedFileNameNEQ != nil {
		predicates = append(predicates, filehistory.ProvidedFileNameNEQ(*i.ProvidedFileNameNEQ))
	}
	if len(i.ProvidedFileNameIn) > 0 {
		predicates = append(predicates, filehistory.ProvidedFileNameIn(i.ProvidedFileNameIn...))
	}
	if len(i.ProvidedFileNameNotIn) > 0 {
		predicates = append(predicates, filehistory.ProvidedFileNameNotIn(i.ProvidedFileNameNotIn...))
	}
	if i.ProvidedFileNameGT != nil {
		predicates = append(predicates, filehistory.ProvidedFileNameGT(*i.ProvidedFileNameGT))
	}
	if i.ProvidedFileNameGTE != nil {
		predicates = append(predicates, filehistory.ProvidedFileNameGTE(*i.ProvidedFileNameGTE))
	}
	if i.ProvidedFileNameLT != nil {
		predicates = append(predicates, filehistory.ProvidedFileNameLT(*i.ProvidedFileNameLT))
	}
	if i.ProvidedFileNameLTE != nil {
		predicates = append(predicates, filehistory.ProvidedFileNameLTE(*i.ProvidedFileNameLTE))
	}
	if i.ProvidedFileNameContains != nil {
		predicates = append(predicates, filehistory.ProvidedFileNameContains(*i.ProvidedFileNameContains))
	}
	if i.ProvidedFileNameHasPrefix != nil {
		predicates = append(predicates, filehistory.ProvidedFileNameHasPrefix(*i.ProvidedFileNameHasPrefix))
	}
	if i.ProvidedFileNameHasSuffix != nil {
		predicates = append(predicates, filehistory.ProvidedFileNameHasSuffix(*i.ProvidedFileNameHasSuffix))
	}
	if i.ProvidedFileNameEqualFold != nil {
		predicates = append(predicates, filehistory.ProvidedFileNameEqualFold(*i.ProvidedFileNameEqualFold))
	}
	if i.ProvidedFileNameContainsFold != nil {
		predicates = append(predicates, filehistory.ProvidedFileNameContainsFold(*i.ProvidedFileNameContainsFold))
	}
	if i.ProvidedFileExtension != nil {
		predicates = append(predicates, filehistory.ProvidedFileExtensionEQ(*i.ProvidedFileExtension))
	}
	if i.ProvidedFileExtensionNEQ != nil {
		predicates = append(predicates, filehistory.ProvidedFileExtensionNEQ(*i.ProvidedFileExtensionNEQ))
	}
	if len(i.ProvidedFileExtensionIn) > 0 {
		predicates = append(predicates, filehistory.ProvidedFileExtensionIn(i.ProvidedFileExtensionIn...))
	}
	if len(i.ProvidedFileExtensionNotIn) > 0 {
		predicates = append(predicates, filehistory.ProvidedFileExtensionNotIn(i.ProvidedFileExtensionNotIn...))
	}
	if i.ProvidedFileExtensionGT != nil {
		predicates = append(predicates, filehistory.ProvidedFileExtensionGT(*i.ProvidedFileExtensionGT))
	}
	if i.ProvidedFileExtensionGTE != nil {
		predicates = append(predicates, filehistory.ProvidedFileExtensionGTE(*i.ProvidedFileExtensionGTE))
	}
	if i.ProvidedFileExtensionLT != nil {
		predicates = append(predicates, filehistory.ProvidedFileExtensionLT(*i.ProvidedFileExtensionLT))
	}
	if i.ProvidedFileExtensionLTE != nil {
		predicates = append(predicates, filehistory.ProvidedFileExtensionLTE(*i.ProvidedFileExtensionLTE))
	}
	if i.ProvidedFileExtensionContains != nil {
		predicates = append(predicates, filehistory.ProvidedFileExtensionContains(*i.ProvidedFileExtensionContains))
	}
	if i.ProvidedFileExtensionHasPrefix != nil {
		predicates = append(predicates, filehistory.ProvidedFileExtensionHasPrefix(*i.ProvidedFileExtensionHasPrefix))
	}
	if i.ProvidedFileExtensionHasSuffix != nil {
		predicates = append(predicates, filehistory.ProvidedFileExtensionHasSuffix(*i.ProvidedFileExtensionHasSuffix))
	}
	if i.ProvidedFileExtensionEqualFold != nil {
		predicates = append(predicates, filehistory.ProvidedFileExtensionEqualFold(*i.ProvidedFileExtensionEqualFold))
	}
	if i.ProvidedFileExtensionContainsFold != nil {
		predicates = append(predicates, filehistory.ProvidedFileExtensionContainsFold(*i.ProvidedFileExtensionContainsFold))
	}
	if i.ProvidedFileSize != nil {
		predicates = append(predicates, filehistory.ProvidedFileSizeEQ(*i.ProvidedFileSize))
	}
	if i.ProvidedFileSizeNEQ != nil {
		predicates = append(predicates, filehistory.ProvidedFileSizeNEQ(*i.ProvidedFileSizeNEQ))
	}
	if len(i.ProvidedFileSizeIn) > 0 {
		predicates = append(predicates, filehistory.ProvidedFileSizeIn(i.ProvidedFileSizeIn...))
	}
	if len(i.ProvidedFileSizeNotIn) > 0 {
		predicates = append(predicates, filehistory.ProvidedFileSizeNotIn(i.ProvidedFileSizeNotIn...))
	}
	if i.ProvidedFileSizeGT != nil {
		predicates = append(predicates, filehistory.ProvidedFileSizeGT(*i.ProvidedFileSizeGT))
	}
	if i.ProvidedFileSizeGTE != nil {
		predicates = append(predicates, filehistory.ProvidedFileSizeGTE(*i.ProvidedFileSizeGTE))
	}
	if i.ProvidedFileSizeLT != nil {
		predicates = append(predicates, filehistory.ProvidedFileSizeLT(*i.ProvidedFileSizeLT))
	}
	if i.ProvidedFileSizeLTE != nil {
		predicates = append(predicates, filehistory.ProvidedFileSizeLTE(*i.ProvidedFileSizeLTE))
	}
	if i.ProvidedFileSizeIsNil {
		predicates = append(predicates, filehistory.ProvidedFileSizeIsNil())
	}
	if i.ProvidedFileSizeNotNil {
		predicates = append(predicates, filehistory.ProvidedFileSizeNotNil())
	}
	if i.PersistedFileSize != nil {
		predicates = append(predicates, filehistory.PersistedFileSizeEQ(*i.PersistedFileSize))
	}
	if i.PersistedFileSizeNEQ != nil {
		predicates = append(predicates, filehistory.PersistedFileSizeNEQ(*i.PersistedFileSizeNEQ))
	}
	if len(i.PersistedFileSizeIn) > 0 {
		predicates = append(predicates, filehistory.PersistedFileSizeIn(i.PersistedFileSizeIn...))
	}
	if len(i.PersistedFileSizeNotIn) > 0 {
		predicates = append(predicates, filehistory.PersistedFileSizeNotIn(i.PersistedFileSizeNotIn...))
	}
	if i.PersistedFileSizeGT != nil {
		predicates = append(predicates, filehistory.PersistedFileSizeGT(*i.PersistedFileSizeGT))
	}
	if i.PersistedFileSizeGTE != nil {
		predicates = append(predicates, filehistory.PersistedFileSizeGTE(*i.PersistedFileSizeGTE))
	}
	if i.PersistedFileSizeLT != nil {
		predicates = append(predicates, filehistory.PersistedFileSizeLT(*i.PersistedFileSizeLT))
	}
	if i.PersistedFileSizeLTE != nil {
		predicates = append(predicates, filehistory.PersistedFileSizeLTE(*i.PersistedFileSizeLTE))
	}
	if i.PersistedFileSizeIsNil {
		predicates = append(predicates, filehistory.PersistedFileSizeIsNil())
	}
	if i.PersistedFileSizeNotNil {
		predicates = append(predicates, filehistory.PersistedFileSizeNotNil())
	}
	if i.DetectedMimeType != nil {
		predicates = append(predicates, filehistory.DetectedMimeTypeEQ(*i.DetectedMimeType))
	}
	if i.DetectedMimeTypeNEQ != nil {
		predicates = append(predicates, filehistory.DetectedMimeTypeNEQ(*i.DetectedMimeTypeNEQ))
	}
	if len(i.DetectedMimeTypeIn) > 0 {
		predicates = append(predicates, filehistory.DetectedMimeTypeIn(i.DetectedMimeTypeIn...))
	}
	if len(i.DetectedMimeTypeNotIn) > 0 {
		predicates = append(predicates, filehistory.DetectedMimeTypeNotIn(i.DetectedMimeTypeNotIn...))
	}
	if i.DetectedMimeTypeGT != nil {
		predicates = append(predicates, filehistory.DetectedMimeTypeGT(*i.DetectedMimeTypeGT))
	}
	if i.DetectedMimeTypeGTE != nil {
		predicates = append(predicates, filehistory.DetectedMimeTypeGTE(*i.DetectedMimeTypeGTE))
	}
	if i.DetectedMimeTypeLT != nil {
		predicates = append(predicates, filehistory.DetectedMimeTypeLT(*i.DetectedMimeTypeLT))
	}
	if i.DetectedMimeTypeLTE != nil {
		predicates = append(predicates, filehistory.DetectedMimeTypeLTE(*i.DetectedMimeTypeLTE))
	}
	if i.DetectedMimeTypeContains != nil {
		predicates = append(predicates, filehistory.DetectedMimeTypeContains(*i.DetectedMimeTypeContains))
	}
	if i.DetectedMimeTypeHasPrefix != nil {
		predicates = append(predicates, filehistory.DetectedMimeTypeHasPrefix(*i.DetectedMimeTypeHasPrefix))
	}
	if i.DetectedMimeTypeHasSuffix != nil {
		predicates = append(predicates, filehistory.DetectedMimeTypeHasSuffix(*i.DetectedMimeTypeHasSuffix))
	}
	if i.DetectedMimeTypeIsNil {
		predicates = append(predicates, filehistory.DetectedMimeTypeIsNil())
	}
	if i.DetectedMimeTypeNotNil {
		predicates = append(predicates, filehistory.DetectedMimeTypeNotNil())
	}
	if i.DetectedMimeTypeEqualFold != nil {
		predicates = append(predicates, filehistory.DetectedMimeTypeEqualFold(*i.DetectedMimeTypeEqualFold))
	}
	if i.DetectedMimeTypeContainsFold != nil {
		predicates = append(predicates, filehistory.DetectedMimeTypeContainsFold(*i.DetectedMimeTypeContainsFold))
	}
	if i.Md5Hash != nil {
		predicates = append(predicates, filehistory.Md5HashEQ(*i.Md5Hash))
	}
	if i.Md5HashNEQ != nil {
		predicates = append(predicates, filehistory.Md5HashNEQ(*i.Md5HashNEQ))
	}
	if len(i.Md5HashIn) > 0 {
		predicates = append(predicates, filehistory.Md5HashIn(i.Md5HashIn...))
	}
	if len(i.Md5HashNotIn) > 0 {
		predicates = append(predicates, filehistory.Md5HashNotIn(i.Md5HashNotIn...))
	}
	if i.Md5HashGT != nil {
		predicates = append(predicates, filehistory.Md5HashGT(*i.Md5HashGT))
	}
	if i.Md5HashGTE != nil {
		predicates = append(predicates, filehistory.Md5HashGTE(*i.Md5HashGTE))
	}
	if i.Md5HashLT != nil {
		predicates = append(predicates, filehistory.Md5HashLT(*i.Md5HashLT))
	}
	if i.Md5HashLTE != nil {
		predicates = append(predicates, filehistory.Md5HashLTE(*i.Md5HashLTE))
	}
	if i.Md5HashContains != nil {
		predicates = append(predicates, filehistory.Md5HashContains(*i.Md5HashContains))
	}
	if i.Md5HashHasPrefix != nil {
		predicates = append(predicates, filehistory.Md5HashHasPrefix(*i.Md5HashHasPrefix))
	}
	if i.Md5HashHasSuffix != nil {
		predicates = append(predicates, filehistory.Md5HashHasSuffix(*i.Md5HashHasSuffix))
	}
	if i.Md5HashIsNil {
		predicates = append(predicates, filehistory.Md5HashIsNil())
	}
	if i.Md5HashNotNil {
		predicates = append(predicates, filehistory.Md5HashNotNil())
	}
	if i.Md5HashEqualFold != nil {
		predicates = append(predicates, filehistory.Md5HashEqualFold(*i.Md5HashEqualFold))
	}
	if i.Md5HashContainsFold != nil {
		predicates = append(predicates, filehistory.Md5HashContainsFold(*i.Md5HashContainsFold))
	}
	if i.DetectedContentType != nil {
		predicates = append(predicates, filehistory.DetectedContentTypeEQ(*i.DetectedContentType))
	}
	if i.DetectedContentTypeNEQ != nil {
		predicates = append(predicates, filehistory.DetectedContentTypeNEQ(*i.DetectedContentTypeNEQ))
	}
	if len(i.DetectedContentTypeIn) > 0 {
		predicates = append(predicates, filehistory.DetectedContentTypeIn(i.DetectedContentTypeIn...))
	}
	if len(i.DetectedContentTypeNotIn) > 0 {
		predicates = append(predicates, filehistory.DetectedContentTypeNotIn(i.DetectedContentTypeNotIn...))
	}
	if i.DetectedContentTypeGT != nil {
		predicates = append(predicates, filehistory.DetectedContentTypeGT(*i.DetectedContentTypeGT))
	}
	if i.DetectedContentTypeGTE != nil {
		predicates = append(predicates, filehistory.DetectedContentTypeGTE(*i.DetectedContentTypeGTE))
	}
	if i.DetectedContentTypeLT != nil {
		predicates = append(predicates, filehistory.DetectedContentTypeLT(*i.DetectedContentTypeLT))
	}
	if i.DetectedContentTypeLTE != nil {
		predicates = append(predicates, filehistory.DetectedContentTypeLTE(*i.DetectedContentTypeLTE))
	}
	if i.DetectedContentTypeContains != nil {
		predicates = append(predicates, filehistory.DetectedContentTypeContains(*i.DetectedContentTypeContains))
	}
	if i.DetectedContentTypeHasPrefix != nil {
		predicates = append(predicates, filehistory.DetectedContentTypeHasPrefix(*i.DetectedContentTypeHasPrefix))
	}
	if i.DetectedContentTypeHasSuffix != nil {
		predicates = append(predicates, filehistory.DetectedContentTypeHasSuffix(*i.DetectedContentTypeHasSuffix))
	}
	if i.DetectedContentTypeEqualFold != nil {
		predicates = append(predicates, filehistory.DetectedContentTypeEqualFold(*i.DetectedContentTypeEqualFold))
	}
	if i.DetectedContentTypeContainsFold != nil {
		predicates = append(predicates, filehistory.DetectedContentTypeContainsFold(*i.DetectedContentTypeContainsFold))
	}
	if i.StoreKey != nil {
		predicates = append(predicates, filehistory.StoreKeyEQ(*i.StoreKey))
	}
	if i.StoreKeyNEQ != nil {
		predicates = append(predicates, filehistory.StoreKeyNEQ(*i.StoreKeyNEQ))
	}
	if len(i.StoreKeyIn) > 0 {
		predicates = append(predicates, filehistory.StoreKeyIn(i.StoreKeyIn...))
	}
	if len(i.StoreKeyNotIn) > 0 {
		predicates = append(predicates, filehistory.StoreKeyNotIn(i.StoreKeyNotIn...))
	}
	if i.StoreKeyGT != nil {
		predicates = append(predicates, filehistory.StoreKeyGT(*i.StoreKeyGT))
	}
	if i.StoreKeyGTE != nil {
		predicates = append(predicates, filehistory.StoreKeyGTE(*i.StoreKeyGTE))
	}
	if i.StoreKeyLT != nil {
		predicates = append(predicates, filehistory.StoreKeyLT(*i.StoreKeyLT))
	}
	if i.StoreKeyLTE != nil {
		predicates = append(predicates, filehistory.StoreKeyLTE(*i.StoreKeyLTE))
	}
	if i.StoreKeyContains != nil {
		predicates = append(predicates, filehistory.StoreKeyContains(*i.StoreKeyContains))
	}
	if i.StoreKeyHasPrefix != nil {
		predicates = append(predicates, filehistory.StoreKeyHasPrefix(*i.StoreKeyHasPrefix))
	}
	if i.StoreKeyHasSuffix != nil {
		predicates = append(predicates, filehistory.StoreKeyHasSuffix(*i.StoreKeyHasSuffix))
	}
	if i.StoreKeyIsNil {
		predicates = append(predicates, filehistory.StoreKeyIsNil())
	}
	if i.StoreKeyNotNil {
		predicates = append(predicates, filehistory.StoreKeyNotNil())
	}
	if i.StoreKeyEqualFold != nil {
		predicates = append(predicates, filehistory.StoreKeyEqualFold(*i.StoreKeyEqualFold))
	}
	if i.StoreKeyContainsFold != nil {
		predicates = append(predicates, filehistory.StoreKeyContainsFold(*i.StoreKeyContainsFold))
	}
	if i.CategoryType != nil {
		predicates = append(predicates, filehistory.CategoryTypeEQ(*i.CategoryType))
	}
	if i.CategoryTypeNEQ != nil {
		predicates = append(predicates, filehistory.CategoryTypeNEQ(*i.CategoryTypeNEQ))
	}
	if len(i.CategoryTypeIn) > 0 {
		predicates = append(predicates, filehistory.CategoryTypeIn(i.CategoryTypeIn...))
	}
	if len(i.CategoryTypeNotIn) > 0 {
		predicates = append(predicates, filehistory.CategoryTypeNotIn(i.CategoryTypeNotIn...))
	}
	if i.CategoryTypeGT != nil {
		predicates = append(predicates, filehistory.CategoryTypeGT(*i.CategoryTypeGT))
	}
	if i.CategoryTypeGTE != nil {
		predicates = append(predicates, filehistory.CategoryTypeGTE(*i.CategoryTypeGTE))
	}
	if i.CategoryTypeLT != nil {
		predicates = append(predicates, filehistory.CategoryTypeLT(*i.CategoryTypeLT))
	}
	if i.CategoryTypeLTE != nil {
		predicates = append(predicates, filehistory.CategoryTypeLTE(*i.CategoryTypeLTE))
	}
	if i.CategoryTypeContains != nil {
		predicates = append(predicates, filehistory.CategoryTypeContains(*i.CategoryTypeContains))
	}
	if i.CategoryTypeHasPrefix != nil {
		predicates = append(predicates, filehistory.CategoryTypeHasPrefix(*i.CategoryTypeHasPrefix))
	}
	if i.CategoryTypeHasSuffix != nil {
		predicates = append(predicates, filehistory.CategoryTypeHasSuffix(*i.CategoryTypeHasSuffix))
	}
	if i.CategoryTypeIsNil {
		predicates = append(predicates, filehistory.CategoryTypeIsNil())
	}
	if i.CategoryTypeNotNil {
		predicates = append(predicates, filehistory.CategoryTypeNotNil())
	}
	if i.CategoryTypeEqualFold != nil {
		predicates = append(predicates, filehistory.CategoryTypeEqualFold(*i.CategoryTypeEqualFold))
	}
	if i.CategoryTypeContainsFold != nil {
		predicates = append(predicates, filehistory.CategoryTypeContainsFold(*i.CategoryTypeContainsFold))
	}
	if i.URI != nil {
		predicates = append(predicates, filehistory.URIEQ(*i.URI))
	}
	if i.URINEQ != nil {
		predicates = append(predicates, filehistory.URINEQ(*i.URINEQ))
	}
	if len(i.URIIn) > 0 {
		predicates = append(predicates, filehistory.URIIn(i.URIIn...))
	}
	if len(i.URINotIn) > 0 {
		predicates = append(predicates, filehistory.URINotIn(i.URINotIn...))
	}
	if i.URIGT != nil {
		predicates = append(predicates, filehistory.URIGT(*i.URIGT))
	}
	if i.URIGTE != nil {
		predicates = append(predicates, filehistory.URIGTE(*i.URIGTE))
	}
	if i.URILT != nil {
		predicates = append(predicates, filehistory.URILT(*i.URILT))
	}
	if i.URILTE != nil {
		predicates = append(predicates, filehistory.URILTE(*i.URILTE))
	}
	if i.URIContains != nil {
		predicates = append(predicates, filehistory.URIContains(*i.URIContains))
	}
	if i.URIHasPrefix != nil {
		predicates = append(predicates, filehistory.URIHasPrefix(*i.URIHasPrefix))
	}
	if i.URIHasSuffix != nil {
		predicates = append(predicates, filehistory.URIHasSuffix(*i.URIHasSuffix))
	}
	if i.URIIsNil {
		predicates = append(predicates, filehistory.URIIsNil())
	}
	if i.URINotNil {
		predicates = append(predicates, filehistory.URINotNil())
	}
	if i.URIEqualFold != nil {
		predicates = append(predicates, filehistory.URIEqualFold(*i.URIEqualFold))
	}
	if i.URIContainsFold != nil {
		predicates = append(predicates, filehistory.URIContainsFold(*i.URIContainsFold))
	}
	if i.StorageScheme != nil {
		predicates = append(predicates, filehistory.StorageSchemeEQ(*i.StorageScheme))
	}
	if i.StorageSchemeNEQ != nil {
		predicates = append(predicates, filehistory.StorageSchemeNEQ(*i.StorageSchemeNEQ))
	}
	if len(i.StorageSchemeIn) > 0 {
		predicates = append(predicates, filehistory.StorageSchemeIn(i.StorageSchemeIn...))
	}
	if len(i.StorageSchemeNotIn) > 0 {
		predicates = append(predicates, filehistory.StorageSchemeNotIn(i.StorageSchemeNotIn...))
	}
	if i.StorageSchemeGT != nil {
		predicates = append(predicates, filehistory.StorageSchemeGT(*i.StorageSchemeGT))
	}
	if i.StorageSchemeGTE != nil {
		predicates = append(predicates, filehistory.StorageSchemeGTE(*i.StorageSchemeGTE))
	}
	if i.StorageSchemeLT != nil {
		predicates = append(predicates, filehistory.StorageSchemeLT(*i.StorageSchemeLT))
	}
	if i.StorageSchemeLTE != nil {
		predicates = append(predicates, filehistory.StorageSchemeLTE(*i.StorageSchemeLTE))
	}
	if i.StorageSchemeContains != nil {
		predicates = append(predicates, filehistory.StorageSchemeContains(*i.StorageSchemeContains))
	}
	if i.StorageSchemeHasPrefix != nil {
		predicates = append(predicates, filehistory.StorageSchemeHasPrefix(*i.StorageSchemeHasPrefix))
	}
	if i.StorageSchemeHasSuffix != nil {
		predicates = append(predicates, filehistory.StorageSchemeHasSuffix(*i.StorageSchemeHasSuffix))
	}
	if i.StorageSchemeIsNil {
		predicates = append(predicates, filehistory.StorageSchemeIsNil())
	}
	if i.StorageSchemeNotNil {
		predicates = append(predicates, filehistory.StorageSchemeNotNil())
	}
	if i.StorageSchemeEqualFold != nil {
		predicates = append(predicates, filehistory.StorageSchemeEqualFold(*i.StorageSchemeEqualFold))
	}
	if i.StorageSchemeContainsFold != nil {
		predicates = append(predicates, filehistory.StorageSchemeContainsFold(*i.StorageSchemeContainsFold))
	}
	if i.StorageVolume != nil {
		predicates = append(predicates, filehistory.StorageVolumeEQ(*i.StorageVolume))
	}
	if i.StorageVolumeNEQ != nil {
		predicates = append(predicates, filehistory.StorageVolumeNEQ(*i.StorageVolumeNEQ))
	}
	if len(i.StorageVolumeIn) > 0 {
		predicates = append(predicates, filehistory.StorageVolumeIn(i.StorageVolumeIn...))
	}
	if len(i.StorageVolumeNotIn) > 0 {
		predicates = append(predicates, filehistory.StorageVolumeNotIn(i.StorageVolumeNotIn...))
	}
	if i.StorageVolumeGT != nil {
		predicates = append(predicates, filehistory.StorageVolumeGT(*i.StorageVolumeGT))
	}
	if i.StorageVolumeGTE != nil {
		predicates = append(predicates, filehistory.StorageVolumeGTE(*i.StorageVolumeGTE))
	}
	if i.StorageVolumeLT != nil {
		predicates = append(predicates, filehistory.StorageVolumeLT(*i.StorageVolumeLT))
	}
	if i.StorageVolumeLTE != nil {
		predicates = append(predicates, filehistory.StorageVolumeLTE(*i.StorageVolumeLTE))
	}
	if i.StorageVolumeContains != nil {
		predicates = append(predicates, filehistory.StorageVolumeContains(*i.StorageVolumeContains))
	}
	if i.StorageVolumeHasPrefix != nil {
		predicates = append(predicates, filehistory.StorageVolumeHasPrefix(*i.StorageVolumeHasPrefix))
	}
	if i.StorageVolumeHasSuffix != nil {
		predicates = append(predicates, filehistory.StorageVolumeHasSuffix(*i.StorageVolumeHasSuffix))
	}
	if i.StorageVolumeIsNil {
		predicates = append(predicates, filehistory.StorageVolumeIsNil())
	}
	if i.StorageVolumeNotNil {
		predicates = append(predicates, filehistory.StorageVolumeNotNil())
	}
	if i.StorageVolumeEqualFold != nil {
		predicates = append(predicates, filehistory.StorageVolumeEqualFold(*i.StorageVolumeEqualFold))
	}
	if i.StorageVolumeContainsFold != nil {
		predicates = append(predicates, filehistory.StorageVolumeContainsFold(*i.StorageVolumeContainsFold))
	}
	if i.StoragePath != nil {
		predicates = append(predicates, filehistory.StoragePathEQ(*i.StoragePath))
	}
	if i.StoragePathNEQ != nil {
		predicates = append(predicates, filehistory.StoragePathNEQ(*i.StoragePathNEQ))
	}
	if len(i.StoragePathIn) > 0 {
		predicates = append(predicates, filehistory.StoragePathIn(i.StoragePathIn...))
	}
	if len(i.StoragePathNotIn) > 0 {
		predicates = append(predicates, filehistory.StoragePathNotIn(i.StoragePathNotIn...))
	}
	if i.StoragePathGT != nil {
		predicates = append(predicates, filehistory.StoragePathGT(*i.StoragePathGT))
	}
	if i.StoragePathGTE != nil {
		predicates = append(predicates, filehistory.StoragePathGTE(*i.StoragePathGTE))
	}
	if i.StoragePathLT != nil {
		predicates = append(predicates, filehistory.StoragePathLT(*i.StoragePathLT))
	}
	if i.StoragePathLTE != nil {
		predicates = append(predicates, filehistory.StoragePathLTE(*i.StoragePathLTE))
	}
	if i.StoragePathContains != nil {
		predicates = append(predicates, filehistory.StoragePathContains(*i.StoragePathContains))
	}
	if i.StoragePathHasPrefix != nil {
		predicates = append(predicates, filehistory.StoragePathHasPrefix(*i.StoragePathHasPrefix))
	}
	if i.StoragePathHasSuffix != nil {
		predicates = append(predicates, filehistory.StoragePathHasSuffix(*i.StoragePathHasSuffix))
	}
	if i.StoragePathIsNil {
		predicates = append(predicates, filehistory.StoragePathIsNil())
	}
	if i.StoragePathNotNil {
		predicates = append(predicates, filehistory.StoragePathNotNil())
	}
	if i.StoragePathEqualFold != nil {
		predicates = append(predicates, filehistory.StoragePathEqualFold(*i.StoragePathEqualFold))
	}
	if i.StoragePathContainsFold != nil {
		predicates = append(predicates, filehistory.StoragePathContainsFold(*i.StoragePathContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFileHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return filehistory.And(predicates...), nil
	}
}

// GroupWhereInput represents a where input for filtering Group queries.
type GroupWhereInput struct {
	Predicates []predicate.Group  `json:"-"`
	Not        *GroupWhereInput   `json:"not,omitempty"`
	Or         []*GroupWhereInput `json:"or,omitempty"`
	And        []*GroupWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "is_managed" field predicates.
	IsManaged       *bool `json:"isManaged,omitempty"`
	IsManagedNEQ    *bool `json:"isManagedNEQ,omitempty"`
	IsManagedIsNil  bool  `json:"isManagedIsNil,omitempty"`
	IsManagedNotNil bool  `json:"isManagedNotNil,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "program_editors" edge predicates.
	HasProgramEditors     *bool                `json:"hasProgramEditors,omitempty"`
	HasProgramEditorsWith []*ProgramWhereInput `json:"hasProgramEditorsWith,omitempty"`

	// "program_blocked_groups" edge predicates.
	HasProgramBlockedGroups     *bool                `json:"hasProgramBlockedGroups,omitempty"`
	HasProgramBlockedGroupsWith []*ProgramWhereInput `json:"hasProgramBlockedGroupsWith,omitempty"`

	// "program_viewers" edge predicates.
	HasProgramViewers     *bool                `json:"hasProgramViewers,omitempty"`
	HasProgramViewersWith []*ProgramWhereInput `json:"hasProgramViewersWith,omitempty"`

	// "risk_editors" edge predicates.
	HasRiskEditors     *bool             `json:"hasRiskEditors,omitempty"`
	HasRiskEditorsWith []*RiskWhereInput `json:"hasRiskEditorsWith,omitempty"`

	// "risk_blocked_groups" edge predicates.
	HasRiskBlockedGroups     *bool             `json:"hasRiskBlockedGroups,omitempty"`
	HasRiskBlockedGroupsWith []*RiskWhereInput `json:"hasRiskBlockedGroupsWith,omitempty"`

	// "risk_viewers" edge predicates.
	HasRiskViewers     *bool             `json:"hasRiskViewers,omitempty"`
	HasRiskViewersWith []*RiskWhereInput `json:"hasRiskViewersWith,omitempty"`

	// "control_objective_editors" edge predicates.
	HasControlObjectiveEditors     *bool                         `json:"hasControlObjectiveEditors,omitempty"`
	HasControlObjectiveEditorsWith []*ControlObjectiveWhereInput `json:"hasControlObjectiveEditorsWith,omitempty"`

	// "control_objective_blocked_groups" edge predicates.
	HasControlObjectiveBlockedGroups     *bool                         `json:"hasControlObjectiveBlockedGroups,omitempty"`
	HasControlObjectiveBlockedGroupsWith []*ControlObjectiveWhereInput `json:"hasControlObjectiveBlockedGroupsWith,omitempty"`

	// "control_objective_viewers" edge predicates.
	HasControlObjectiveViewers     *bool                         `json:"hasControlObjectiveViewers,omitempty"`
	HasControlObjectiveViewersWith []*ControlObjectiveWhereInput `json:"hasControlObjectiveViewersWith,omitempty"`

	// "narrative_editors" edge predicates.
	HasNarrativeEditors     *bool                  `json:"hasNarrativeEditors,omitempty"`
	HasNarrativeEditorsWith []*NarrativeWhereInput `json:"hasNarrativeEditorsWith,omitempty"`

	// "narrative_blocked_groups" edge predicates.
	HasNarrativeBlockedGroups     *bool                  `json:"hasNarrativeBlockedGroups,omitempty"`
	HasNarrativeBlockedGroupsWith []*NarrativeWhereInput `json:"hasNarrativeBlockedGroupsWith,omitempty"`

	// "narrative_viewers" edge predicates.
	HasNarrativeViewers     *bool                  `json:"hasNarrativeViewers,omitempty"`
	HasNarrativeViewersWith []*NarrativeWhereInput `json:"hasNarrativeViewersWith,omitempty"`

	// "control_implementation_editors" edge predicates.
	HasControlImplementationEditors     *bool                              `json:"hasControlImplementationEditors,omitempty"`
	HasControlImplementationEditorsWith []*ControlImplementationWhereInput `json:"hasControlImplementationEditorsWith,omitempty"`

	// "control_implementation_blocked_groups" edge predicates.
	HasControlImplementationBlockedGroups     *bool                              `json:"hasControlImplementationBlockedGroups,omitempty"`
	HasControlImplementationBlockedGroupsWith []*ControlImplementationWhereInput `json:"hasControlImplementationBlockedGroupsWith,omitempty"`

	// "control_implementation_viewers" edge predicates.
	HasControlImplementationViewers     *bool                              `json:"hasControlImplementationViewers,omitempty"`
	HasControlImplementationViewersWith []*ControlImplementationWhereInput `json:"hasControlImplementationViewersWith,omitempty"`

	// "procedure_editors" edge predicates.
	HasProcedureEditors     *bool                  `json:"hasProcedureEditors,omitempty"`
	HasProcedureEditorsWith []*ProcedureWhereInput `json:"hasProcedureEditorsWith,omitempty"`

	// "procedure_blocked_groups" edge predicates.
	HasProcedureBlockedGroups     *bool                  `json:"hasProcedureBlockedGroups,omitempty"`
	HasProcedureBlockedGroupsWith []*ProcedureWhereInput `json:"hasProcedureBlockedGroupsWith,omitempty"`

	// "internal_policy_editors" edge predicates.
	HasInternalPolicyEditors     *bool                       `json:"hasInternalPolicyEditors,omitempty"`
	HasInternalPolicyEditorsWith []*InternalPolicyWhereInput `json:"hasInternalPolicyEditorsWith,omitempty"`

	// "internal_policy_blocked_groups" edge predicates.
	HasInternalPolicyBlockedGroups     *bool                       `json:"hasInternalPolicyBlockedGroups,omitempty"`
	HasInternalPolicyBlockedGroupsWith []*InternalPolicyWhereInput `json:"hasInternalPolicyBlockedGroupsWith,omitempty"`

	// "control_editors" edge predicates.
	HasControlEditors     *bool                `json:"hasControlEditors,omitempty"`
	HasControlEditorsWith []*ControlWhereInput `json:"hasControlEditorsWith,omitempty"`

	// "control_blocked_groups" edge predicates.
	HasControlBlockedGroups     *bool                `json:"hasControlBlockedGroups,omitempty"`
	HasControlBlockedGroupsWith []*ControlWhereInput `json:"hasControlBlockedGroupsWith,omitempty"`

	// "mapped_control_editors" edge predicates.
	HasMappedControlEditors     *bool                      `json:"hasMappedControlEditors,omitempty"`
	HasMappedControlEditorsWith []*MappedControlWhereInput `json:"hasMappedControlEditorsWith,omitempty"`

	// "mapped_control_blocked_groups" edge predicates.
	HasMappedControlBlockedGroups     *bool                      `json:"hasMappedControlBlockedGroups,omitempty"`
	HasMappedControlBlockedGroupsWith []*MappedControlWhereInput `json:"hasMappedControlBlockedGroupsWith,omitempty"`

	// "setting" edge predicates.
	HasSetting     *bool                     `json:"hasSetting,omitempty"`
	HasSettingWith []*GroupSettingWhereInput `json:"hasSettingWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "events" edge predicates.
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`

	// "integrations" edge predicates.
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`

	// "members" edge predicates.
	HasMembers     *bool                        `json:"hasMembers,omitempty"`
	HasMembersWith []*GroupMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GroupWhereInput) AddPredicates(predicates ...predicate.Group) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GroupWhereInput filter on the GroupQuery builder.
func (i *GroupWhereInput) Filter(q *GroupQuery) (*GroupQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGroupWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGroupWhereInput is returned in case the GroupWhereInput is empty.
var ErrEmptyGroupWhereInput = errors.New("generated: empty predicate GroupWhereInput")

// P returns a predicate for filtering groups.
// An error is returned if the input is empty or invalid.
func (i *GroupWhereInput) P() (predicate.Group, error) {
	var predicates []predicate.Group
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, group.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Group, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, group.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Group, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, group.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, group.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, group.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, group.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, group.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, group.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, group.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, group.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, group.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, group.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, group.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, group.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, group.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, group.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, group.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, group.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, group.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, group.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, group.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, group.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, group.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, group.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, group.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, group.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, group.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, group.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, group.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, group.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, group.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, group.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, group.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, group.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, group.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, group.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, group.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, group.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, group.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, group.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, group.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, group.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, group.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, group.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, group.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, group.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, group.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, group.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, group.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, group.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, group.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, group.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, group.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, group.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, group.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, group.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, group.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, group.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, group.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, group.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, group.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, group.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, group.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, group.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, group.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, group.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, group.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, group.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, group.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, group.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, group.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, group.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, group.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, group.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, group.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, group.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, group.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, group.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, group.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, group.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, group.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, group.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, group.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, group.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, group.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, group.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, group.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, group.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, group.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, group.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, group.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, group.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, group.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, group.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, group.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, group.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, group.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, group.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, group.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, group.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, group.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, group.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, group.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, group.NameContainsFold(*i.NameContainsFold))
	}
	if i.IsManaged != nil {
		predicates = append(predicates, group.IsManagedEQ(*i.IsManaged))
	}
	if i.IsManagedNEQ != nil {
		predicates = append(predicates, group.IsManagedNEQ(*i.IsManagedNEQ))
	}
	if i.IsManagedIsNil {
		predicates = append(predicates, group.IsManagedIsNil())
	}
	if i.IsManagedNotNil {
		predicates = append(predicates, group.IsManagedNotNil())
	}
	if i.DisplayName != nil {
		predicates = append(predicates, group.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, group.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, group.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, group.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, group.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, group.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, group.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, group.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, group.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, group.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, group.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, group.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, group.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}

	if i.HasOwner != nil {
		p := group.HasOwner()
		if !*i.HasOwner {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasOwnerWith(with...))
	}
	if i.HasProgramEditors != nil {
		p := group.HasProgramEditors()
		if !*i.HasProgramEditors {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramEditorsWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramEditorsWith))
		for _, w := range i.HasProgramEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasProgramEditorsWith(with...))
	}
	if i.HasProgramBlockedGroups != nil {
		p := group.HasProgramBlockedGroups()
		if !*i.HasProgramBlockedGroups {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramBlockedGroupsWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramBlockedGroupsWith))
		for _, w := range i.HasProgramBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasProgramBlockedGroupsWith(with...))
	}
	if i.HasProgramViewers != nil {
		p := group.HasProgramViewers()
		if !*i.HasProgramViewers {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramViewersWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramViewersWith))
		for _, w := range i.HasProgramViewersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramViewersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasProgramViewersWith(with...))
	}
	if i.HasRiskEditors != nil {
		p := group.HasRiskEditors()
		if !*i.HasRiskEditors {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRiskEditorsWith) > 0 {
		with := make([]predicate.Risk, 0, len(i.HasRiskEditorsWith))
		for _, w := range i.HasRiskEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRiskEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasRiskEditorsWith(with...))
	}
	if i.HasRiskBlockedGroups != nil {
		p := group.HasRiskBlockedGroups()
		if !*i.HasRiskBlockedGroups {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRiskBlockedGroupsWith) > 0 {
		with := make([]predicate.Risk, 0, len(i.HasRiskBlockedGroupsWith))
		for _, w := range i.HasRiskBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRiskBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasRiskBlockedGroupsWith(with...))
	}
	if i.HasRiskViewers != nil {
		p := group.HasRiskViewers()
		if !*i.HasRiskViewers {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRiskViewersWith) > 0 {
		with := make([]predicate.Risk, 0, len(i.HasRiskViewersWith))
		for _, w := range i.HasRiskViewersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRiskViewersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasRiskViewersWith(with...))
	}
	if i.HasControlObjectiveEditors != nil {
		p := group.HasControlObjectiveEditors()
		if !*i.HasControlObjectiveEditors {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlObjectiveEditorsWith) > 0 {
		with := make([]predicate.ControlObjective, 0, len(i.HasControlObjectiveEditorsWith))
		for _, w := range i.HasControlObjectiveEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlObjectiveEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasControlObjectiveEditorsWith(with...))
	}
	if i.HasControlObjectiveBlockedGroups != nil {
		p := group.HasControlObjectiveBlockedGroups()
		if !*i.HasControlObjectiveBlockedGroups {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlObjectiveBlockedGroupsWith) > 0 {
		with := make([]predicate.ControlObjective, 0, len(i.HasControlObjectiveBlockedGroupsWith))
		for _, w := range i.HasControlObjectiveBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlObjectiveBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasControlObjectiveBlockedGroupsWith(with...))
	}
	if i.HasControlObjectiveViewers != nil {
		p := group.HasControlObjectiveViewers()
		if !*i.HasControlObjectiveViewers {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlObjectiveViewersWith) > 0 {
		with := make([]predicate.ControlObjective, 0, len(i.HasControlObjectiveViewersWith))
		for _, w := range i.HasControlObjectiveViewersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlObjectiveViewersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasControlObjectiveViewersWith(with...))
	}
	if i.HasNarrativeEditors != nil {
		p := group.HasNarrativeEditors()
		if !*i.HasNarrativeEditors {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNarrativeEditorsWith) > 0 {
		with := make([]predicate.Narrative, 0, len(i.HasNarrativeEditorsWith))
		for _, w := range i.HasNarrativeEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNarrativeEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasNarrativeEditorsWith(with...))
	}
	if i.HasNarrativeBlockedGroups != nil {
		p := group.HasNarrativeBlockedGroups()
		if !*i.HasNarrativeBlockedGroups {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNarrativeBlockedGroupsWith) > 0 {
		with := make([]predicate.Narrative, 0, len(i.HasNarrativeBlockedGroupsWith))
		for _, w := range i.HasNarrativeBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNarrativeBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasNarrativeBlockedGroupsWith(with...))
	}
	if i.HasNarrativeViewers != nil {
		p := group.HasNarrativeViewers()
		if !*i.HasNarrativeViewers {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNarrativeViewersWith) > 0 {
		with := make([]predicate.Narrative, 0, len(i.HasNarrativeViewersWith))
		for _, w := range i.HasNarrativeViewersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNarrativeViewersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasNarrativeViewersWith(with...))
	}
	if i.HasControlImplementationEditors != nil {
		p := group.HasControlImplementationEditors()
		if !*i.HasControlImplementationEditors {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlImplementationEditorsWith) > 0 {
		with := make([]predicate.ControlImplementation, 0, len(i.HasControlImplementationEditorsWith))
		for _, w := range i.HasControlImplementationEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlImplementationEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasControlImplementationEditorsWith(with...))
	}
	if i.HasControlImplementationBlockedGroups != nil {
		p := group.HasControlImplementationBlockedGroups()
		if !*i.HasControlImplementationBlockedGroups {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlImplementationBlockedGroupsWith) > 0 {
		with := make([]predicate.ControlImplementation, 0, len(i.HasControlImplementationBlockedGroupsWith))
		for _, w := range i.HasControlImplementationBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlImplementationBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasControlImplementationBlockedGroupsWith(with...))
	}
	if i.HasControlImplementationViewers != nil {
		p := group.HasControlImplementationViewers()
		if !*i.HasControlImplementationViewers {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlImplementationViewersWith) > 0 {
		with := make([]predicate.ControlImplementation, 0, len(i.HasControlImplementationViewersWith))
		for _, w := range i.HasControlImplementationViewersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlImplementationViewersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasControlImplementationViewersWith(with...))
	}
	if i.HasProcedureEditors != nil {
		p := group.HasProcedureEditors()
		if !*i.HasProcedureEditors {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProcedureEditorsWith) > 0 {
		with := make([]predicate.Procedure, 0, len(i.HasProcedureEditorsWith))
		for _, w := range i.HasProcedureEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProcedureEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasProcedureEditorsWith(with...))
	}
	if i.HasProcedureBlockedGroups != nil {
		p := group.HasProcedureBlockedGroups()
		if !*i.HasProcedureBlockedGroups {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProcedureBlockedGroupsWith) > 0 {
		with := make([]predicate.Procedure, 0, len(i.HasProcedureBlockedGroupsWith))
		for _, w := range i.HasProcedureBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProcedureBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasProcedureBlockedGroupsWith(with...))
	}
	if i.HasInternalPolicyEditors != nil {
		p := group.HasInternalPolicyEditors()
		if !*i.HasInternalPolicyEditors {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInternalPolicyEditorsWith) > 0 {
		with := make([]predicate.InternalPolicy, 0, len(i.HasInternalPolicyEditorsWith))
		for _, w := range i.HasInternalPolicyEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInternalPolicyEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasInternalPolicyEditorsWith(with...))
	}
	if i.HasInternalPolicyBlockedGroups != nil {
		p := group.HasInternalPolicyBlockedGroups()
		if !*i.HasInternalPolicyBlockedGroups {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInternalPolicyBlockedGroupsWith) > 0 {
		with := make([]predicate.InternalPolicy, 0, len(i.HasInternalPolicyBlockedGroupsWith))
		for _, w := range i.HasInternalPolicyBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInternalPolicyBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasInternalPolicyBlockedGroupsWith(with...))
	}
	if i.HasControlEditors != nil {
		p := group.HasControlEditors()
		if !*i.HasControlEditors {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlEditorsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasControlEditorsWith))
		for _, w := range i.HasControlEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasControlEditorsWith(with...))
	}
	if i.HasControlBlockedGroups != nil {
		p := group.HasControlBlockedGroups()
		if !*i.HasControlBlockedGroups {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlBlockedGroupsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasControlBlockedGroupsWith))
		for _, w := range i.HasControlBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasControlBlockedGroupsWith(with...))
	}
	if i.HasMappedControlEditors != nil {
		p := group.HasMappedControlEditors()
		if !*i.HasMappedControlEditors {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMappedControlEditorsWith) > 0 {
		with := make([]predicate.MappedControl, 0, len(i.HasMappedControlEditorsWith))
		for _, w := range i.HasMappedControlEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMappedControlEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasMappedControlEditorsWith(with...))
	}
	if i.HasMappedControlBlockedGroups != nil {
		p := group.HasMappedControlBlockedGroups()
		if !*i.HasMappedControlBlockedGroups {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMappedControlBlockedGroupsWith) > 0 {
		with := make([]predicate.MappedControl, 0, len(i.HasMappedControlBlockedGroupsWith))
		for _, w := range i.HasMappedControlBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMappedControlBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasMappedControlBlockedGroupsWith(with...))
	}
	if i.HasSetting != nil {
		p := group.HasSetting()
		if !*i.HasSetting {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSettingWith) > 0 {
		with := make([]predicate.GroupSetting, 0, len(i.HasSettingWith))
		for _, w := range i.HasSettingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSettingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasSettingWith(with...))
	}
	if i.HasUsers != nil {
		p := group.HasUsers()
		if !*i.HasUsers {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasUsersWith(with...))
	}
	if i.HasEvents != nil {
		p := group.HasEvents()
		if !*i.HasEvents {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventsWith) > 0 {
		with := make([]predicate.Event, 0, len(i.HasEventsWith))
		for _, w := range i.HasEventsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasEventsWith(with...))
	}
	if i.HasIntegrations != nil {
		p := group.HasIntegrations()
		if !*i.HasIntegrations {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIntegrationsWith) > 0 {
		with := make([]predicate.Integration, 0, len(i.HasIntegrationsWith))
		for _, w := range i.HasIntegrationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasIntegrationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasIntegrationsWith(with...))
	}
	if i.HasFiles != nil {
		p := group.HasFiles()
		if !*i.HasFiles {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasFilesWith(with...))
	}
	if i.HasTasks != nil {
		p := group.HasTasks()
		if !*i.HasTasks {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasTasksWith(with...))
	}
	if i.HasMembers != nil {
		p := group.HasMembers()
		if !*i.HasMembers {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMembersWith) > 0 {
		with := make([]predicate.GroupMembership, 0, len(i.HasMembersWith))
		for _, w := range i.HasMembersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMembersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasMembersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGroupWhereInput
	case 1:
		return predicates[0], nil
	default:
		return group.And(predicates...), nil
	}
}

// GroupHistoryWhereInput represents a where input for filtering GroupHistory queries.
type GroupHistoryWhereInput struct {
	Predicates []predicate.GroupHistory  `json:"-"`
	Not        *GroupHistoryWhereInput   `json:"not,omitempty"`
	Or         []*GroupHistoryWhereInput `json:"or,omitempty"`
	And        []*GroupHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "is_managed" field predicates.
	IsManaged       *bool `json:"isManaged,omitempty"`
	IsManagedNEQ    *bool `json:"isManagedNEQ,omitempty"`
	IsManagedIsNil  bool  `json:"isManagedIsNil,omitempty"`
	IsManagedNotNil bool  `json:"isManagedNotNil,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GroupHistoryWhereInput) AddPredicates(predicates ...predicate.GroupHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GroupHistoryWhereInput filter on the GroupHistoryQuery builder.
func (i *GroupHistoryWhereInput) Filter(q *GroupHistoryQuery) (*GroupHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGroupHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGroupHistoryWhereInput is returned in case the GroupHistoryWhereInput is empty.
var ErrEmptyGroupHistoryWhereInput = errors.New("generated: empty predicate GroupHistoryWhereInput")

// P returns a predicate for filtering grouphistories.
// An error is returned if the input is empty or invalid.
func (i *GroupHistoryWhereInput) P() (predicate.GroupHistory, error) {
	var predicates []predicate.GroupHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, grouphistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GroupHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, grouphistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GroupHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, grouphistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, grouphistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, grouphistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, grouphistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, grouphistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, grouphistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, grouphistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, grouphistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, grouphistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, grouphistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, grouphistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, grouphistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, grouphistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, grouphistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, grouphistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, grouphistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, grouphistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, grouphistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, grouphistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, grouphistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, grouphistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, grouphistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, grouphistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, grouphistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, grouphistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, grouphistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, grouphistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, grouphistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, grouphistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, grouphistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, grouphistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, grouphistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, grouphistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, grouphistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, grouphistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, grouphistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, grouphistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, grouphistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, grouphistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, grouphistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, grouphistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, grouphistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, grouphistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, grouphistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, grouphistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, grouphistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, grouphistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, grouphistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, grouphistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, grouphistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, grouphistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, grouphistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, grouphistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, grouphistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, grouphistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, grouphistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, grouphistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, grouphistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, grouphistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, grouphistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, grouphistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, grouphistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, grouphistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, grouphistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, grouphistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, grouphistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, grouphistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, grouphistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, grouphistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, grouphistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, grouphistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, grouphistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, grouphistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, grouphistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, grouphistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, grouphistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, grouphistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, grouphistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, grouphistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, grouphistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, grouphistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, grouphistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, grouphistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, grouphistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, grouphistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, grouphistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, grouphistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, grouphistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, grouphistory.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, grouphistory.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, grouphistory.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, grouphistory.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, grouphistory.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, grouphistory.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, grouphistory.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, grouphistory.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, grouphistory.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, grouphistory.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, grouphistory.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, grouphistory.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, grouphistory.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, grouphistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, grouphistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, grouphistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, grouphistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, grouphistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, grouphistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, grouphistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, grouphistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, grouphistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, grouphistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, grouphistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, grouphistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, grouphistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, grouphistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, grouphistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, grouphistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, grouphistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, grouphistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, grouphistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, grouphistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, grouphistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, grouphistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, grouphistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, grouphistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, grouphistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, grouphistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, grouphistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, grouphistory.NameContainsFold(*i.NameContainsFold))
	}
	if i.IsManaged != nil {
		predicates = append(predicates, grouphistory.IsManagedEQ(*i.IsManaged))
	}
	if i.IsManagedNEQ != nil {
		predicates = append(predicates, grouphistory.IsManagedNEQ(*i.IsManagedNEQ))
	}
	if i.IsManagedIsNil {
		predicates = append(predicates, grouphistory.IsManagedIsNil())
	}
	if i.IsManagedNotNil {
		predicates = append(predicates, grouphistory.IsManagedNotNil())
	}
	if i.DisplayName != nil {
		predicates = append(predicates, grouphistory.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, grouphistory.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, grouphistory.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, grouphistory.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, grouphistory.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, grouphistory.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, grouphistory.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, grouphistory.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, grouphistory.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, grouphistory.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, grouphistory.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, grouphistory.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, grouphistory.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGroupHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return grouphistory.And(predicates...), nil
	}
}

// GroupMembershipWhereInput represents a where input for filtering GroupMembership queries.
type GroupMembershipWhereInput struct {
	Predicates []predicate.GroupMembership  `json:"-"`
	Not        *GroupMembershipWhereInput   `json:"not,omitempty"`
	Or         []*GroupMembershipWhereInput `json:"or,omitempty"`
	And        []*GroupMembershipWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "role" field predicates.
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNEQ   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`

	// "group_id" field predicates.
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIDNEQ          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIDGT           *string  `json:"groupIDGT,omitempty"`
	GroupIDGTE          *string  `json:"groupIDGTE,omitempty"`
	GroupIDLT           *string  `json:"groupIDLT,omitempty"`
	GroupIDLTE          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "group" edge predicates.
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "events" edge predicates.
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GroupMembershipWhereInput) AddPredicates(predicates ...predicate.GroupMembership) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GroupMembershipWhereInput filter on the GroupMembershipQuery builder.
func (i *GroupMembershipWhereInput) Filter(q *GroupMembershipQuery) (*GroupMembershipQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGroupMembershipWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGroupMembershipWhereInput is returned in case the GroupMembershipWhereInput is empty.
var ErrEmptyGroupMembershipWhereInput = errors.New("generated: empty predicate GroupMembershipWhereInput")

// P returns a predicate for filtering groupmemberships.
// An error is returned if the input is empty or invalid.
func (i *GroupMembershipWhereInput) P() (predicate.GroupMembership, error) {
	var predicates []predicate.GroupMembership
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, groupmembership.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GroupMembership, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, groupmembership.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GroupMembership, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, groupmembership.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, groupmembership.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, groupmembership.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, groupmembership.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, groupmembership.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, groupmembership.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, groupmembership.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, groupmembership.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, groupmembership.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, groupmembership.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, groupmembership.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, groupmembership.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, groupmembership.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, groupmembership.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, groupmembership.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, groupmembership.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, groupmembership.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, groupmembership.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, groupmembership.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, groupmembership.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, groupmembership.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, groupmembership.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, groupmembership.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, groupmembership.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, groupmembership.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, groupmembership.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, groupmembership.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, groupmembership.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, groupmembership.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, groupmembership.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, groupmembership.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, groupmembership.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, groupmembership.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, groupmembership.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, groupmembership.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, groupmembership.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, groupmembership.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, groupmembership.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, groupmembership.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, groupmembership.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, groupmembership.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, groupmembership.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, groupmembership.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, groupmembership.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, groupmembership.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, groupmembership.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, groupmembership.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, groupmembership.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, groupmembership.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, groupmembership.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, groupmembership.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, groupmembership.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, groupmembership.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, groupmembership.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, groupmembership.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, groupmembership.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, groupmembership.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, groupmembership.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, groupmembership.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, groupmembership.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, groupmembership.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Role != nil {
		predicates = append(predicates, groupmembership.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, groupmembership.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, groupmembership.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, groupmembership.RoleNotIn(i.RoleNotIn...))
	}
	if i.GroupID != nil {
		predicates = append(predicates, groupmembership.GroupIDEQ(*i.GroupID))
	}
	if i.GroupIDNEQ != nil {
		predicates = append(predicates, groupmembership.GroupIDNEQ(*i.GroupIDNEQ))
	}
	if len(i.GroupIDIn) > 0 {
		predicates = append(predicates, groupmembership.GroupIDIn(i.GroupIDIn...))
	}
	if len(i.GroupIDNotIn) > 0 {
		predicates = append(predicates, groupmembership.GroupIDNotIn(i.GroupIDNotIn...))
	}
	if i.GroupIDGT != nil {
		predicates = append(predicates, groupmembership.GroupIDGT(*i.GroupIDGT))
	}
	if i.GroupIDGTE != nil {
		predicates = append(predicates, groupmembership.GroupIDGTE(*i.GroupIDGTE))
	}
	if i.GroupIDLT != nil {
		predicates = append(predicates, groupmembership.GroupIDLT(*i.GroupIDLT))
	}
	if i.GroupIDLTE != nil {
		predicates = append(predicates, groupmembership.GroupIDLTE(*i.GroupIDLTE))
	}
	if i.GroupIDContains != nil {
		predicates = append(predicates, groupmembership.GroupIDContains(*i.GroupIDContains))
	}
	if i.GroupIDHasPrefix != nil {
		predicates = append(predicates, groupmembership.GroupIDHasPrefix(*i.GroupIDHasPrefix))
	}
	if i.GroupIDHasSuffix != nil {
		predicates = append(predicates, groupmembership.GroupIDHasSuffix(*i.GroupIDHasSuffix))
	}
	if i.GroupIDEqualFold != nil {
		predicates = append(predicates, groupmembership.GroupIDEqualFold(*i.GroupIDEqualFold))
	}
	if i.GroupIDContainsFold != nil {
		predicates = append(predicates, groupmembership.GroupIDContainsFold(*i.GroupIDContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, groupmembership.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, groupmembership.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, groupmembership.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, groupmembership.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, groupmembership.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, groupmembership.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, groupmembership.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, groupmembership.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, groupmembership.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, groupmembership.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, groupmembership.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, groupmembership.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, groupmembership.UserIDContainsFold(*i.UserIDContainsFold))
	}

	if i.HasGroup != nil {
		p := groupmembership.HasGroup()
		if !*i.HasGroup {
			p = groupmembership.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasGroupWith))
		for _, w := range i.HasGroupWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGroupWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, groupmembership.HasGroupWith(with...))
	}
	if i.HasUser != nil {
		p := groupmembership.HasUser()
		if !*i.HasUser {
			p = groupmembership.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, groupmembership.HasUserWith(with...))
	}
	if i.HasEvents != nil {
		p := groupmembership.HasEvents()
		if !*i.HasEvents {
			p = groupmembership.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventsWith) > 0 {
		with := make([]predicate.Event, 0, len(i.HasEventsWith))
		for _, w := range i.HasEventsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, groupmembership.HasEventsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGroupMembershipWhereInput
	case 1:
		return predicates[0], nil
	default:
		return groupmembership.And(predicates...), nil
	}
}

// GroupMembershipHistoryWhereInput represents a where input for filtering GroupMembershipHistory queries.
type GroupMembershipHistoryWhereInput struct {
	Predicates []predicate.GroupMembershipHistory  `json:"-"`
	Not        *GroupMembershipHistoryWhereInput   `json:"not,omitempty"`
	Or         []*GroupMembershipHistoryWhereInput `json:"or,omitempty"`
	And        []*GroupMembershipHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "role" field predicates.
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNEQ   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`

	// "group_id" field predicates.
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIDNEQ          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIDGT           *string  `json:"groupIDGT,omitempty"`
	GroupIDGTE          *string  `json:"groupIDGTE,omitempty"`
	GroupIDLT           *string  `json:"groupIDLT,omitempty"`
	GroupIDLTE          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GroupMembershipHistoryWhereInput) AddPredicates(predicates ...predicate.GroupMembershipHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GroupMembershipHistoryWhereInput filter on the GroupMembershipHistoryQuery builder.
func (i *GroupMembershipHistoryWhereInput) Filter(q *GroupMembershipHistoryQuery) (*GroupMembershipHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGroupMembershipHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGroupMembershipHistoryWhereInput is returned in case the GroupMembershipHistoryWhereInput is empty.
var ErrEmptyGroupMembershipHistoryWhereInput = errors.New("generated: empty predicate GroupMembershipHistoryWhereInput")

// P returns a predicate for filtering groupmembershiphistories.
// An error is returned if the input is empty or invalid.
func (i *GroupMembershipHistoryWhereInput) P() (predicate.GroupMembershipHistory, error) {
	var predicates []predicate.GroupMembershipHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, groupmembershiphistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GroupMembershipHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, groupmembershiphistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GroupMembershipHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, groupmembershiphistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, groupmembershiphistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, groupmembershiphistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, groupmembershiphistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, groupmembershiphistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, groupmembershiphistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, groupmembershiphistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, groupmembershiphistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, groupmembershiphistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, groupmembershiphistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, groupmembershiphistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, groupmembershiphistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, groupmembershiphistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, groupmembershiphistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, groupmembershiphistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, groupmembershiphistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, groupmembershiphistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, groupmembershiphistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, groupmembershiphistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, groupmembershiphistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, groupmembershiphistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, groupmembershiphistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, groupmembershiphistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, groupmembershiphistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, groupmembershiphistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, groupmembershiphistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, groupmembershiphistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, groupmembershiphistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, groupmembershiphistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, groupmembershiphistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, groupmembershiphistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, groupmembershiphistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, groupmembershiphistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, groupmembershiphistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, groupmembershiphistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, groupmembershiphistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, groupmembershiphistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, groupmembershiphistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, groupmembershiphistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, groupmembershiphistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Role != nil {
		predicates = append(predicates, groupmembershiphistory.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, groupmembershiphistory.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.RoleNotIn(i.RoleNotIn...))
	}
	if i.GroupID != nil {
		predicates = append(predicates, groupmembershiphistory.GroupIDEQ(*i.GroupID))
	}
	if i.GroupIDNEQ != nil {
		predicates = append(predicates, groupmembershiphistory.GroupIDNEQ(*i.GroupIDNEQ))
	}
	if len(i.GroupIDIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.GroupIDIn(i.GroupIDIn...))
	}
	if len(i.GroupIDNotIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.GroupIDNotIn(i.GroupIDNotIn...))
	}
	if i.GroupIDGT != nil {
		predicates = append(predicates, groupmembershiphistory.GroupIDGT(*i.GroupIDGT))
	}
	if i.GroupIDGTE != nil {
		predicates = append(predicates, groupmembershiphistory.GroupIDGTE(*i.GroupIDGTE))
	}
	if i.GroupIDLT != nil {
		predicates = append(predicates, groupmembershiphistory.GroupIDLT(*i.GroupIDLT))
	}
	if i.GroupIDLTE != nil {
		predicates = append(predicates, groupmembershiphistory.GroupIDLTE(*i.GroupIDLTE))
	}
	if i.GroupIDContains != nil {
		predicates = append(predicates, groupmembershiphistory.GroupIDContains(*i.GroupIDContains))
	}
	if i.GroupIDHasPrefix != nil {
		predicates = append(predicates, groupmembershiphistory.GroupIDHasPrefix(*i.GroupIDHasPrefix))
	}
	if i.GroupIDHasSuffix != nil {
		predicates = append(predicates, groupmembershiphistory.GroupIDHasSuffix(*i.GroupIDHasSuffix))
	}
	if i.GroupIDEqualFold != nil {
		predicates = append(predicates, groupmembershiphistory.GroupIDEqualFold(*i.GroupIDEqualFold))
	}
	if i.GroupIDContainsFold != nil {
		predicates = append(predicates, groupmembershiphistory.GroupIDContainsFold(*i.GroupIDContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, groupmembershiphistory.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, groupmembershiphistory.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, groupmembershiphistory.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, groupmembershiphistory.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, groupmembershiphistory.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, groupmembershiphistory.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, groupmembershiphistory.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, groupmembershiphistory.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, groupmembershiphistory.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, groupmembershiphistory.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, groupmembershiphistory.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, groupmembershiphistory.UserIDContainsFold(*i.UserIDContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGroupMembershipHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return groupmembershiphistory.And(predicates...), nil
	}
}

// GroupSettingWhereInput represents a where input for filtering GroupSetting queries.
type GroupSettingWhereInput struct {
	Predicates []predicate.GroupSetting  `json:"-"`
	Not        *GroupSettingWhereInput   `json:"not,omitempty"`
	Or         []*GroupSettingWhereInput `json:"or,omitempty"`
	And        []*GroupSettingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "visibility" field predicates.
	Visibility      *enums.Visibility  `json:"visibility,omitempty"`
	VisibilityNEQ   *enums.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []enums.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []enums.Visibility `json:"visibilityNotIn,omitempty"`

	// "join_policy" field predicates.
	JoinPolicy      *enums.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNEQ   *enums.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []enums.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []enums.JoinPolicy `json:"joinPolicyNotIn,omitempty"`

	// "sync_to_slack" field predicates.
	SyncToSlack       *bool `json:"syncToSlack,omitempty"`
	SyncToSlackNEQ    *bool `json:"syncToSlackNEQ,omitempty"`
	SyncToSlackIsNil  bool  `json:"syncToSlackIsNil,omitempty"`
	SyncToSlackNotNil bool  `json:"syncToSlackNotNil,omitempty"`

	// "sync_to_github" field predicates.
	SyncToGithub       *bool `json:"syncToGithub,omitempty"`
	SyncToGithubNEQ    *bool `json:"syncToGithubNEQ,omitempty"`
	SyncToGithubIsNil  bool  `json:"syncToGithubIsNil,omitempty"`
	SyncToGithubNotNil bool  `json:"syncToGithubNotNil,omitempty"`

	// "group_id" field predicates.
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIDNEQ          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIDGT           *string  `json:"groupIDGT,omitempty"`
	GroupIDGTE          *string  `json:"groupIDGTE,omitempty"`
	GroupIDLT           *string  `json:"groupIDLT,omitempty"`
	GroupIDLTE          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDIsNil        bool     `json:"groupIDIsNil,omitempty"`
	GroupIDNotNil       bool     `json:"groupIDNotNil,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`

	// "group" edge predicates.
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GroupSettingWhereInput) AddPredicates(predicates ...predicate.GroupSetting) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GroupSettingWhereInput filter on the GroupSettingQuery builder.
func (i *GroupSettingWhereInput) Filter(q *GroupSettingQuery) (*GroupSettingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGroupSettingWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGroupSettingWhereInput is returned in case the GroupSettingWhereInput is empty.
var ErrEmptyGroupSettingWhereInput = errors.New("generated: empty predicate GroupSettingWhereInput")

// P returns a predicate for filtering groupsettings.
// An error is returned if the input is empty or invalid.
func (i *GroupSettingWhereInput) P() (predicate.GroupSetting, error) {
	var predicates []predicate.GroupSetting
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, groupsetting.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GroupSetting, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, groupsetting.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GroupSetting, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, groupsetting.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, groupsetting.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, groupsetting.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, groupsetting.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, groupsetting.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, groupsetting.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, groupsetting.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, groupsetting.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, groupsetting.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, groupsetting.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, groupsetting.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, groupsetting.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, groupsetting.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, groupsetting.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, groupsetting.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, groupsetting.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, groupsetting.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, groupsetting.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, groupsetting.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, groupsetting.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, groupsetting.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, groupsetting.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, groupsetting.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, groupsetting.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, groupsetting.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, groupsetting.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, groupsetting.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, groupsetting.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, groupsetting.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, groupsetting.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, groupsetting.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, groupsetting.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, groupsetting.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, groupsetting.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, groupsetting.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, groupsetting.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, groupsetting.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, groupsetting.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, groupsetting.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, groupsetting.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, groupsetting.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, groupsetting.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, groupsetting.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, groupsetting.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, groupsetting.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, groupsetting.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, groupsetting.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, groupsetting.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, groupsetting.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, groupsetting.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, groupsetting.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, groupsetting.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, groupsetting.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, groupsetting.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, groupsetting.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, groupsetting.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, groupsetting.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, groupsetting.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, groupsetting.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, groupsetting.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, groupsetting.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Visibility != nil {
		predicates = append(predicates, groupsetting.VisibilityEQ(*i.Visibility))
	}
	if i.VisibilityNEQ != nil {
		predicates = append(predicates, groupsetting.VisibilityNEQ(*i.VisibilityNEQ))
	}
	if len(i.VisibilityIn) > 0 {
		predicates = append(predicates, groupsetting.VisibilityIn(i.VisibilityIn...))
	}
	if len(i.VisibilityNotIn) > 0 {
		predicates = append(predicates, groupsetting.VisibilityNotIn(i.VisibilityNotIn...))
	}
	if i.JoinPolicy != nil {
		predicates = append(predicates, groupsetting.JoinPolicyEQ(*i.JoinPolicy))
	}
	if i.JoinPolicyNEQ != nil {
		predicates = append(predicates, groupsetting.JoinPolicyNEQ(*i.JoinPolicyNEQ))
	}
	if len(i.JoinPolicyIn) > 0 {
		predicates = append(predicates, groupsetting.JoinPolicyIn(i.JoinPolicyIn...))
	}
	if len(i.JoinPolicyNotIn) > 0 {
		predicates = append(predicates, groupsetting.JoinPolicyNotIn(i.JoinPolicyNotIn...))
	}
	if i.SyncToSlack != nil {
		predicates = append(predicates, groupsetting.SyncToSlackEQ(*i.SyncToSlack))
	}
	if i.SyncToSlackNEQ != nil {
		predicates = append(predicates, groupsetting.SyncToSlackNEQ(*i.SyncToSlackNEQ))
	}
	if i.SyncToSlackIsNil {
		predicates = append(predicates, groupsetting.SyncToSlackIsNil())
	}
	if i.SyncToSlackNotNil {
		predicates = append(predicates, groupsetting.SyncToSlackNotNil())
	}
	if i.SyncToGithub != nil {
		predicates = append(predicates, groupsetting.SyncToGithubEQ(*i.SyncToGithub))
	}
	if i.SyncToGithubNEQ != nil {
		predicates = append(predicates, groupsetting.SyncToGithubNEQ(*i.SyncToGithubNEQ))
	}
	if i.SyncToGithubIsNil {
		predicates = append(predicates, groupsetting.SyncToGithubIsNil())
	}
	if i.SyncToGithubNotNil {
		predicates = append(predicates, groupsetting.SyncToGithubNotNil())
	}
	if i.GroupID != nil {
		predicates = append(predicates, groupsetting.GroupIDEQ(*i.GroupID))
	}
	if i.GroupIDNEQ != nil {
		predicates = append(predicates, groupsetting.GroupIDNEQ(*i.GroupIDNEQ))
	}
	if len(i.GroupIDIn) > 0 {
		predicates = append(predicates, groupsetting.GroupIDIn(i.GroupIDIn...))
	}
	if len(i.GroupIDNotIn) > 0 {
		predicates = append(predicates, groupsetting.GroupIDNotIn(i.GroupIDNotIn...))
	}
	if i.GroupIDGT != nil {
		predicates = append(predicates, groupsetting.GroupIDGT(*i.GroupIDGT))
	}
	if i.GroupIDGTE != nil {
		predicates = append(predicates, groupsetting.GroupIDGTE(*i.GroupIDGTE))
	}
	if i.GroupIDLT != nil {
		predicates = append(predicates, groupsetting.GroupIDLT(*i.GroupIDLT))
	}
	if i.GroupIDLTE != nil {
		predicates = append(predicates, groupsetting.GroupIDLTE(*i.GroupIDLTE))
	}
	if i.GroupIDContains != nil {
		predicates = append(predicates, groupsetting.GroupIDContains(*i.GroupIDContains))
	}
	if i.GroupIDHasPrefix != nil {
		predicates = append(predicates, groupsetting.GroupIDHasPrefix(*i.GroupIDHasPrefix))
	}
	if i.GroupIDHasSuffix != nil {
		predicates = append(predicates, groupsetting.GroupIDHasSuffix(*i.GroupIDHasSuffix))
	}
	if i.GroupIDIsNil {
		predicates = append(predicates, groupsetting.GroupIDIsNil())
	}
	if i.GroupIDNotNil {
		predicates = append(predicates, groupsetting.GroupIDNotNil())
	}
	if i.GroupIDEqualFold != nil {
		predicates = append(predicates, groupsetting.GroupIDEqualFold(*i.GroupIDEqualFold))
	}
	if i.GroupIDContainsFold != nil {
		predicates = append(predicates, groupsetting.GroupIDContainsFold(*i.GroupIDContainsFold))
	}

	if i.HasGroup != nil {
		p := groupsetting.HasGroup()
		if !*i.HasGroup {
			p = groupsetting.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasGroupWith))
		for _, w := range i.HasGroupWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGroupWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, groupsetting.HasGroupWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGroupSettingWhereInput
	case 1:
		return predicates[0], nil
	default:
		return groupsetting.And(predicates...), nil
	}
}

// GroupSettingHistoryWhereInput represents a where input for filtering GroupSettingHistory queries.
type GroupSettingHistoryWhereInput struct {
	Predicates []predicate.GroupSettingHistory  `json:"-"`
	Not        *GroupSettingHistoryWhereInput   `json:"not,omitempty"`
	Or         []*GroupSettingHistoryWhereInput `json:"or,omitempty"`
	And        []*GroupSettingHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "visibility" field predicates.
	Visibility      *enums.Visibility  `json:"visibility,omitempty"`
	VisibilityNEQ   *enums.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []enums.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []enums.Visibility `json:"visibilityNotIn,omitempty"`

	// "join_policy" field predicates.
	JoinPolicy      *enums.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNEQ   *enums.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []enums.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []enums.JoinPolicy `json:"joinPolicyNotIn,omitempty"`

	// "sync_to_slack" field predicates.
	SyncToSlack       *bool `json:"syncToSlack,omitempty"`
	SyncToSlackNEQ    *bool `json:"syncToSlackNEQ,omitempty"`
	SyncToSlackIsNil  bool  `json:"syncToSlackIsNil,omitempty"`
	SyncToSlackNotNil bool  `json:"syncToSlackNotNil,omitempty"`

	// "sync_to_github" field predicates.
	SyncToGithub       *bool `json:"syncToGithub,omitempty"`
	SyncToGithubNEQ    *bool `json:"syncToGithubNEQ,omitempty"`
	SyncToGithubIsNil  bool  `json:"syncToGithubIsNil,omitempty"`
	SyncToGithubNotNil bool  `json:"syncToGithubNotNil,omitempty"`

	// "group_id" field predicates.
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIDNEQ          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIDGT           *string  `json:"groupIDGT,omitempty"`
	GroupIDGTE          *string  `json:"groupIDGTE,omitempty"`
	GroupIDLT           *string  `json:"groupIDLT,omitempty"`
	GroupIDLTE          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDIsNil        bool     `json:"groupIDIsNil,omitempty"`
	GroupIDNotNil       bool     `json:"groupIDNotNil,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GroupSettingHistoryWhereInput) AddPredicates(predicates ...predicate.GroupSettingHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GroupSettingHistoryWhereInput filter on the GroupSettingHistoryQuery builder.
func (i *GroupSettingHistoryWhereInput) Filter(q *GroupSettingHistoryQuery) (*GroupSettingHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGroupSettingHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGroupSettingHistoryWhereInput is returned in case the GroupSettingHistoryWhereInput is empty.
var ErrEmptyGroupSettingHistoryWhereInput = errors.New("generated: empty predicate GroupSettingHistoryWhereInput")

// P returns a predicate for filtering groupsettinghistories.
// An error is returned if the input is empty or invalid.
func (i *GroupSettingHistoryWhereInput) P() (predicate.GroupSettingHistory, error) {
	var predicates []predicate.GroupSettingHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, groupsettinghistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GroupSettingHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, groupsettinghistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GroupSettingHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, groupsettinghistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, groupsettinghistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, groupsettinghistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, groupsettinghistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, groupsettinghistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, groupsettinghistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, groupsettinghistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, groupsettinghistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, groupsettinghistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, groupsettinghistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, groupsettinghistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, groupsettinghistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, groupsettinghistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, groupsettinghistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, groupsettinghistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, groupsettinghistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, groupsettinghistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, groupsettinghistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, groupsettinghistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, groupsettinghistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, groupsettinghistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, groupsettinghistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, groupsettinghistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, groupsettinghistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, groupsettinghistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, groupsettinghistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, groupsettinghistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, groupsettinghistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, groupsettinghistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, groupsettinghistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, groupsettinghistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, groupsettinghistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, groupsettinghistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, groupsettinghistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, groupsettinghistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, groupsettinghistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, groupsettinghistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, groupsettinghistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, groupsettinghistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, groupsettinghistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, groupsettinghistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, groupsettinghistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, groupsettinghistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, groupsettinghistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, groupsettinghistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, groupsettinghistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, groupsettinghistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, groupsettinghistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, groupsettinghistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, groupsettinghistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, groupsettinghistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, groupsettinghistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, groupsettinghistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, groupsettinghistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, groupsettinghistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, groupsettinghistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, groupsettinghistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, groupsettinghistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, groupsettinghistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, groupsettinghistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, groupsettinghistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, groupsettinghistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, groupsettinghistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, groupsettinghistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, groupsettinghistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, groupsettinghistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, groupsettinghistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, groupsettinghistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, groupsettinghistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, groupsettinghistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, groupsettinghistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, groupsettinghistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Visibility != nil {
		predicates = append(predicates, groupsettinghistory.VisibilityEQ(*i.Visibility))
	}
	if i.VisibilityNEQ != nil {
		predicates = append(predicates, groupsettinghistory.VisibilityNEQ(*i.VisibilityNEQ))
	}
	if len(i.VisibilityIn) > 0 {
		predicates = append(predicates, groupsettinghistory.VisibilityIn(i.VisibilityIn...))
	}
	if len(i.VisibilityNotIn) > 0 {
		predicates = append(predicates, groupsettinghistory.VisibilityNotIn(i.VisibilityNotIn...))
	}
	if i.JoinPolicy != nil {
		predicates = append(predicates, groupsettinghistory.JoinPolicyEQ(*i.JoinPolicy))
	}
	if i.JoinPolicyNEQ != nil {
		predicates = append(predicates, groupsettinghistory.JoinPolicyNEQ(*i.JoinPolicyNEQ))
	}
	if len(i.JoinPolicyIn) > 0 {
		predicates = append(predicates, groupsettinghistory.JoinPolicyIn(i.JoinPolicyIn...))
	}
	if len(i.JoinPolicyNotIn) > 0 {
		predicates = append(predicates, groupsettinghistory.JoinPolicyNotIn(i.JoinPolicyNotIn...))
	}
	if i.SyncToSlack != nil {
		predicates = append(predicates, groupsettinghistory.SyncToSlackEQ(*i.SyncToSlack))
	}
	if i.SyncToSlackNEQ != nil {
		predicates = append(predicates, groupsettinghistory.SyncToSlackNEQ(*i.SyncToSlackNEQ))
	}
	if i.SyncToSlackIsNil {
		predicates = append(predicates, groupsettinghistory.SyncToSlackIsNil())
	}
	if i.SyncToSlackNotNil {
		predicates = append(predicates, groupsettinghistory.SyncToSlackNotNil())
	}
	if i.SyncToGithub != nil {
		predicates = append(predicates, groupsettinghistory.SyncToGithubEQ(*i.SyncToGithub))
	}
	if i.SyncToGithubNEQ != nil {
		predicates = append(predicates, groupsettinghistory.SyncToGithubNEQ(*i.SyncToGithubNEQ))
	}
	if i.SyncToGithubIsNil {
		predicates = append(predicates, groupsettinghistory.SyncToGithubIsNil())
	}
	if i.SyncToGithubNotNil {
		predicates = append(predicates, groupsettinghistory.SyncToGithubNotNil())
	}
	if i.GroupID != nil {
		predicates = append(predicates, groupsettinghistory.GroupIDEQ(*i.GroupID))
	}
	if i.GroupIDNEQ != nil {
		predicates = append(predicates, groupsettinghistory.GroupIDNEQ(*i.GroupIDNEQ))
	}
	if len(i.GroupIDIn) > 0 {
		predicates = append(predicates, groupsettinghistory.GroupIDIn(i.GroupIDIn...))
	}
	if len(i.GroupIDNotIn) > 0 {
		predicates = append(predicates, groupsettinghistory.GroupIDNotIn(i.GroupIDNotIn...))
	}
	if i.GroupIDGT != nil {
		predicates = append(predicates, groupsettinghistory.GroupIDGT(*i.GroupIDGT))
	}
	if i.GroupIDGTE != nil {
		predicates = append(predicates, groupsettinghistory.GroupIDGTE(*i.GroupIDGTE))
	}
	if i.GroupIDLT != nil {
		predicates = append(predicates, groupsettinghistory.GroupIDLT(*i.GroupIDLT))
	}
	if i.GroupIDLTE != nil {
		predicates = append(predicates, groupsettinghistory.GroupIDLTE(*i.GroupIDLTE))
	}
	if i.GroupIDContains != nil {
		predicates = append(predicates, groupsettinghistory.GroupIDContains(*i.GroupIDContains))
	}
	if i.GroupIDHasPrefix != nil {
		predicates = append(predicates, groupsettinghistory.GroupIDHasPrefix(*i.GroupIDHasPrefix))
	}
	if i.GroupIDHasSuffix != nil {
		predicates = append(predicates, groupsettinghistory.GroupIDHasSuffix(*i.GroupIDHasSuffix))
	}
	if i.GroupIDIsNil {
		predicates = append(predicates, groupsettinghistory.GroupIDIsNil())
	}
	if i.GroupIDNotNil {
		predicates = append(predicates, groupsettinghistory.GroupIDNotNil())
	}
	if i.GroupIDEqualFold != nil {
		predicates = append(predicates, groupsettinghistory.GroupIDEqualFold(*i.GroupIDEqualFold))
	}
	if i.GroupIDContainsFold != nil {
		predicates = append(predicates, groupsettinghistory.GroupIDContainsFold(*i.GroupIDContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGroupSettingHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return groupsettinghistory.And(predicates...), nil
	}
}

// HushWhereInput represents a where input for filtering Hush queries.
type HushWhereInput struct {
	Predicates []predicate.Hush  `json:"-"`
	Not        *HushWhereInput   `json:"not,omitempty"`
	Or         []*HushWhereInput `json:"or,omitempty"`
	And        []*HushWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "kind" field predicates.
	Kind             *string  `json:"kind,omitempty"`
	KindNEQ          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGT           *string  `json:"kindGT,omitempty"`
	KindGTE          *string  `json:"kindGTE,omitempty"`
	KindLT           *string  `json:"kindLT,omitempty"`
	KindLTE          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        bool     `json:"kindIsNil,omitempty"`
	KindNotNil       bool     `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`

	// "secret_name" field predicates.
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNEQ          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGT           *string  `json:"secretNameGT,omitempty"`
	SecretNameGTE          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLT           *string  `json:"secretNameLT,omitempty"`
	SecretNameLTE          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameIsNil        bool     `json:"secretNameIsNil,omitempty"`
	SecretNameNotNil       bool     `json:"secretNameNotNil,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "integrations" edge predicates.
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`

	// "events" edge predicates.
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HushWhereInput) AddPredicates(predicates ...predicate.Hush) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HushWhereInput filter on the HushQuery builder.
func (i *HushWhereInput) Filter(q *HushQuery) (*HushQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHushWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHushWhereInput is returned in case the HushWhereInput is empty.
var ErrEmptyHushWhereInput = errors.New("generated: empty predicate HushWhereInput")

// P returns a predicate for filtering hushes.
// An error is returned if the input is empty or invalid.
func (i *HushWhereInput) P() (predicate.Hush, error) {
	var predicates []predicate.Hush
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, hush.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Hush, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, hush.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Hush, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, hush.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, hush.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, hush.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, hush.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, hush.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, hush.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, hush.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, hush.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, hush.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, hush.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, hush.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, hush.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, hush.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, hush.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, hush.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, hush.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, hush.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, hush.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, hush.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, hush.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, hush.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, hush.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, hush.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, hush.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, hush.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, hush.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, hush.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, hush.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, hush.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, hush.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, hush.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, hush.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, hush.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, hush.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, hush.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, hush.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, hush.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, hush.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, hush.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, hush.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, hush.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, hush.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, hush.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, hush.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, hush.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, hush.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, hush.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, hush.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, hush.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, hush.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, hush.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, hush.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, hush.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, hush.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, hush.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, hush.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, hush.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, hush.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, hush.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, hush.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, hush.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, hush.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, hush.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, hush.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, hush.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, hush.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, hush.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, hush.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, hush.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, hush.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, hush.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, hush.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, hush.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, hush.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, hush.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, hush.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, hush.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, hush.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, hush.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, hush.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, hush.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, hush.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, hush.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, hush.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, hush.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, hush.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, hush.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, hush.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, hush.NameContainsFold(*i.NameContainsFold))
	}
	if i.Kind != nil {
		predicates = append(predicates, hush.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, hush.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, hush.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, hush.KindNotIn(i.KindNotIn...))
	}
	if i.KindGT != nil {
		predicates = append(predicates, hush.KindGT(*i.KindGT))
	}
	if i.KindGTE != nil {
		predicates = append(predicates, hush.KindGTE(*i.KindGTE))
	}
	if i.KindLT != nil {
		predicates = append(predicates, hush.KindLT(*i.KindLT))
	}
	if i.KindLTE != nil {
		predicates = append(predicates, hush.KindLTE(*i.KindLTE))
	}
	if i.KindContains != nil {
		predicates = append(predicates, hush.KindContains(*i.KindContains))
	}
	if i.KindHasPrefix != nil {
		predicates = append(predicates, hush.KindHasPrefix(*i.KindHasPrefix))
	}
	if i.KindHasSuffix != nil {
		predicates = append(predicates, hush.KindHasSuffix(*i.KindHasSuffix))
	}
	if i.KindIsNil {
		predicates = append(predicates, hush.KindIsNil())
	}
	if i.KindNotNil {
		predicates = append(predicates, hush.KindNotNil())
	}
	if i.KindEqualFold != nil {
		predicates = append(predicates, hush.KindEqualFold(*i.KindEqualFold))
	}
	if i.KindContainsFold != nil {
		predicates = append(predicates, hush.KindContainsFold(*i.KindContainsFold))
	}
	if i.SecretName != nil {
		predicates = append(predicates, hush.SecretNameEQ(*i.SecretName))
	}
	if i.SecretNameNEQ != nil {
		predicates = append(predicates, hush.SecretNameNEQ(*i.SecretNameNEQ))
	}
	if len(i.SecretNameIn) > 0 {
		predicates = append(predicates, hush.SecretNameIn(i.SecretNameIn...))
	}
	if len(i.SecretNameNotIn) > 0 {
		predicates = append(predicates, hush.SecretNameNotIn(i.SecretNameNotIn...))
	}
	if i.SecretNameGT != nil {
		predicates = append(predicates, hush.SecretNameGT(*i.SecretNameGT))
	}
	if i.SecretNameGTE != nil {
		predicates = append(predicates, hush.SecretNameGTE(*i.SecretNameGTE))
	}
	if i.SecretNameLT != nil {
		predicates = append(predicates, hush.SecretNameLT(*i.SecretNameLT))
	}
	if i.SecretNameLTE != nil {
		predicates = append(predicates, hush.SecretNameLTE(*i.SecretNameLTE))
	}
	if i.SecretNameContains != nil {
		predicates = append(predicates, hush.SecretNameContains(*i.SecretNameContains))
	}
	if i.SecretNameHasPrefix != nil {
		predicates = append(predicates, hush.SecretNameHasPrefix(*i.SecretNameHasPrefix))
	}
	if i.SecretNameHasSuffix != nil {
		predicates = append(predicates, hush.SecretNameHasSuffix(*i.SecretNameHasSuffix))
	}
	if i.SecretNameIsNil {
		predicates = append(predicates, hush.SecretNameIsNil())
	}
	if i.SecretNameNotNil {
		predicates = append(predicates, hush.SecretNameNotNil())
	}
	if i.SecretNameEqualFold != nil {
		predicates = append(predicates, hush.SecretNameEqualFold(*i.SecretNameEqualFold))
	}
	if i.SecretNameContainsFold != nil {
		predicates = append(predicates, hush.SecretNameContainsFold(*i.SecretNameContainsFold))
	}

	if i.HasOwner != nil {
		p := hush.HasOwner()
		if !*i.HasOwner {
			p = hush.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hush.HasOwnerWith(with...))
	}
	if i.HasIntegrations != nil {
		p := hush.HasIntegrations()
		if !*i.HasIntegrations {
			p = hush.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIntegrationsWith) > 0 {
		with := make([]predicate.Integration, 0, len(i.HasIntegrationsWith))
		for _, w := range i.HasIntegrationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasIntegrationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hush.HasIntegrationsWith(with...))
	}
	if i.HasEvents != nil {
		p := hush.HasEvents()
		if !*i.HasEvents {
			p = hush.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventsWith) > 0 {
		with := make([]predicate.Event, 0, len(i.HasEventsWith))
		for _, w := range i.HasEventsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hush.HasEventsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHushWhereInput
	case 1:
		return predicates[0], nil
	default:
		return hush.And(predicates...), nil
	}
}

// HushHistoryWhereInput represents a where input for filtering HushHistory queries.
type HushHistoryWhereInput struct {
	Predicates []predicate.HushHistory  `json:"-"`
	Not        *HushHistoryWhereInput   `json:"not,omitempty"`
	Or         []*HushHistoryWhereInput `json:"or,omitempty"`
	And        []*HushHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "kind" field predicates.
	Kind             *string  `json:"kind,omitempty"`
	KindNEQ          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGT           *string  `json:"kindGT,omitempty"`
	KindGTE          *string  `json:"kindGTE,omitempty"`
	KindLT           *string  `json:"kindLT,omitempty"`
	KindLTE          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        bool     `json:"kindIsNil,omitempty"`
	KindNotNil       bool     `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`

	// "secret_name" field predicates.
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNEQ          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGT           *string  `json:"secretNameGT,omitempty"`
	SecretNameGTE          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLT           *string  `json:"secretNameLT,omitempty"`
	SecretNameLTE          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameIsNil        bool     `json:"secretNameIsNil,omitempty"`
	SecretNameNotNil       bool     `json:"secretNameNotNil,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HushHistoryWhereInput) AddPredicates(predicates ...predicate.HushHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HushHistoryWhereInput filter on the HushHistoryQuery builder.
func (i *HushHistoryWhereInput) Filter(q *HushHistoryQuery) (*HushHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHushHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHushHistoryWhereInput is returned in case the HushHistoryWhereInput is empty.
var ErrEmptyHushHistoryWhereInput = errors.New("generated: empty predicate HushHistoryWhereInput")

// P returns a predicate for filtering hushhistories.
// An error is returned if the input is empty or invalid.
func (i *HushHistoryWhereInput) P() (predicate.HushHistory, error) {
	var predicates []predicate.HushHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, hushhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.HushHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, hushhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.HushHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, hushhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, hushhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, hushhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, hushhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, hushhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, hushhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, hushhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, hushhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, hushhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, hushhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, hushhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, hushhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, hushhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, hushhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, hushhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, hushhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, hushhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, hushhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, hushhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, hushhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, hushhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, hushhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, hushhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, hushhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, hushhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, hushhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, hushhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, hushhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, hushhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, hushhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, hushhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, hushhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, hushhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, hushhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, hushhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, hushhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, hushhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, hushhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, hushhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, hushhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, hushhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, hushhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, hushhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, hushhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, hushhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, hushhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, hushhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, hushhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, hushhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, hushhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, hushhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, hushhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, hushhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, hushhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, hushhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, hushhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, hushhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, hushhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, hushhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, hushhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, hushhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, hushhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, hushhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, hushhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, hushhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, hushhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, hushhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, hushhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, hushhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, hushhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, hushhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, hushhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, hushhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, hushhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, hushhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, hushhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, hushhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, hushhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, hushhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, hushhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, hushhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, hushhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, hushhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, hushhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, hushhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, hushhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, hushhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, hushhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, hushhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, hushhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, hushhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, hushhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, hushhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, hushhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, hushhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, hushhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, hushhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, hushhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, hushhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, hushhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, hushhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, hushhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, hushhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, hushhistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, hushhistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, hushhistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, hushhistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, hushhistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, hushhistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, hushhistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, hushhistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, hushhistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, hushhistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, hushhistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, hushhistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, hushhistory.NameContainsFold(*i.NameContainsFold))
	}
	if i.Kind != nil {
		predicates = append(predicates, hushhistory.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, hushhistory.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, hushhistory.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, hushhistory.KindNotIn(i.KindNotIn...))
	}
	if i.KindGT != nil {
		predicates = append(predicates, hushhistory.KindGT(*i.KindGT))
	}
	if i.KindGTE != nil {
		predicates = append(predicates, hushhistory.KindGTE(*i.KindGTE))
	}
	if i.KindLT != nil {
		predicates = append(predicates, hushhistory.KindLT(*i.KindLT))
	}
	if i.KindLTE != nil {
		predicates = append(predicates, hushhistory.KindLTE(*i.KindLTE))
	}
	if i.KindContains != nil {
		predicates = append(predicates, hushhistory.KindContains(*i.KindContains))
	}
	if i.KindHasPrefix != nil {
		predicates = append(predicates, hushhistory.KindHasPrefix(*i.KindHasPrefix))
	}
	if i.KindHasSuffix != nil {
		predicates = append(predicates, hushhistory.KindHasSuffix(*i.KindHasSuffix))
	}
	if i.KindIsNil {
		predicates = append(predicates, hushhistory.KindIsNil())
	}
	if i.KindNotNil {
		predicates = append(predicates, hushhistory.KindNotNil())
	}
	if i.KindEqualFold != nil {
		predicates = append(predicates, hushhistory.KindEqualFold(*i.KindEqualFold))
	}
	if i.KindContainsFold != nil {
		predicates = append(predicates, hushhistory.KindContainsFold(*i.KindContainsFold))
	}
	if i.SecretName != nil {
		predicates = append(predicates, hushhistory.SecretNameEQ(*i.SecretName))
	}
	if i.SecretNameNEQ != nil {
		predicates = append(predicates, hushhistory.SecretNameNEQ(*i.SecretNameNEQ))
	}
	if len(i.SecretNameIn) > 0 {
		predicates = append(predicates, hushhistory.SecretNameIn(i.SecretNameIn...))
	}
	if len(i.SecretNameNotIn) > 0 {
		predicates = append(predicates, hushhistory.SecretNameNotIn(i.SecretNameNotIn...))
	}
	if i.SecretNameGT != nil {
		predicates = append(predicates, hushhistory.SecretNameGT(*i.SecretNameGT))
	}
	if i.SecretNameGTE != nil {
		predicates = append(predicates, hushhistory.SecretNameGTE(*i.SecretNameGTE))
	}
	if i.SecretNameLT != nil {
		predicates = append(predicates, hushhistory.SecretNameLT(*i.SecretNameLT))
	}
	if i.SecretNameLTE != nil {
		predicates = append(predicates, hushhistory.SecretNameLTE(*i.SecretNameLTE))
	}
	if i.SecretNameContains != nil {
		predicates = append(predicates, hushhistory.SecretNameContains(*i.SecretNameContains))
	}
	if i.SecretNameHasPrefix != nil {
		predicates = append(predicates, hushhistory.SecretNameHasPrefix(*i.SecretNameHasPrefix))
	}
	if i.SecretNameHasSuffix != nil {
		predicates = append(predicates, hushhistory.SecretNameHasSuffix(*i.SecretNameHasSuffix))
	}
	if i.SecretNameIsNil {
		predicates = append(predicates, hushhistory.SecretNameIsNil())
	}
	if i.SecretNameNotNil {
		predicates = append(predicates, hushhistory.SecretNameNotNil())
	}
	if i.SecretNameEqualFold != nil {
		predicates = append(predicates, hushhistory.SecretNameEqualFold(*i.SecretNameEqualFold))
	}
	if i.SecretNameContainsFold != nil {
		predicates = append(predicates, hushhistory.SecretNameContainsFold(*i.SecretNameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHushHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return hushhistory.And(predicates...), nil
	}
}

// IntegrationWhereInput represents a where input for filtering Integration queries.
type IntegrationWhereInput struct {
	Predicates []predicate.Integration  `json:"-"`
	Not        *IntegrationWhereInput   `json:"not,omitempty"`
	Or         []*IntegrationWhereInput `json:"or,omitempty"`
	And        []*IntegrationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "kind" field predicates.
	Kind             *string  `json:"kind,omitempty"`
	KindNEQ          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGT           *string  `json:"kindGT,omitempty"`
	KindGTE          *string  `json:"kindGTE,omitempty"`
	KindLT           *string  `json:"kindLT,omitempty"`
	KindLTE          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        bool     `json:"kindIsNil,omitempty"`
	KindNotNil       bool     `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "secrets" edge predicates.
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`

	// "events" edge predicates.
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *IntegrationWhereInput) AddPredicates(predicates ...predicate.Integration) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the IntegrationWhereInput filter on the IntegrationQuery builder.
func (i *IntegrationWhereInput) Filter(q *IntegrationQuery) (*IntegrationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyIntegrationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyIntegrationWhereInput is returned in case the IntegrationWhereInput is empty.
var ErrEmptyIntegrationWhereInput = errors.New("generated: empty predicate IntegrationWhereInput")

// P returns a predicate for filtering integrations.
// An error is returned if the input is empty or invalid.
func (i *IntegrationWhereInput) P() (predicate.Integration, error) {
	var predicates []predicate.Integration
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, integration.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Integration, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, integration.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Integration, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, integration.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, integration.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, integration.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, integration.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, integration.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, integration.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, integration.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, integration.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, integration.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, integration.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, integration.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, integration.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, integration.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, integration.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, integration.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, integration.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, integration.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, integration.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, integration.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, integration.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, integration.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, integration.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, integration.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, integration.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, integration.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, integration.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, integration.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, integration.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, integration.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, integration.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, integration.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, integration.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, integration.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, integration.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, integration.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, integration.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, integration.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, integration.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, integration.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, integration.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, integration.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, integration.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, integration.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, integration.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, integration.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, integration.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, integration.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, integration.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, integration.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, integration.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, integration.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, integration.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, integration.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, integration.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, integration.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, integration.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, integration.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, integration.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, integration.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, integration.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, integration.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, integration.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, integration.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, integration.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, integration.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, integration.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, integration.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, integration.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, integration.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, integration.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, integration.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, integration.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, integration.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, integration.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, integration.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, integration.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, integration.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, integration.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, integration.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, integration.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, integration.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, integration.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, integration.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, integration.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, integration.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, integration.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, integration.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, integration.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, integration.NameContainsFold(*i.NameContainsFold))
	}
	if i.Kind != nil {
		predicates = append(predicates, integration.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, integration.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, integration.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, integration.KindNotIn(i.KindNotIn...))
	}
	if i.KindGT != nil {
		predicates = append(predicates, integration.KindGT(*i.KindGT))
	}
	if i.KindGTE != nil {
		predicates = append(predicates, integration.KindGTE(*i.KindGTE))
	}
	if i.KindLT != nil {
		predicates = append(predicates, integration.KindLT(*i.KindLT))
	}
	if i.KindLTE != nil {
		predicates = append(predicates, integration.KindLTE(*i.KindLTE))
	}
	if i.KindContains != nil {
		predicates = append(predicates, integration.KindContains(*i.KindContains))
	}
	if i.KindHasPrefix != nil {
		predicates = append(predicates, integration.KindHasPrefix(*i.KindHasPrefix))
	}
	if i.KindHasSuffix != nil {
		predicates = append(predicates, integration.KindHasSuffix(*i.KindHasSuffix))
	}
	if i.KindIsNil {
		predicates = append(predicates, integration.KindIsNil())
	}
	if i.KindNotNil {
		predicates = append(predicates, integration.KindNotNil())
	}
	if i.KindEqualFold != nil {
		predicates = append(predicates, integration.KindEqualFold(*i.KindEqualFold))
	}
	if i.KindContainsFold != nil {
		predicates = append(predicates, integration.KindContainsFold(*i.KindContainsFold))
	}

	if i.HasOwner != nil {
		p := integration.HasOwner()
		if !*i.HasOwner {
			p = integration.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, integration.HasOwnerWith(with...))
	}
	if i.HasSecrets != nil {
		p := integration.HasSecrets()
		if !*i.HasSecrets {
			p = integration.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSecretsWith) > 0 {
		with := make([]predicate.Hush, 0, len(i.HasSecretsWith))
		for _, w := range i.HasSecretsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSecretsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, integration.HasSecretsWith(with...))
	}
	if i.HasEvents != nil {
		p := integration.HasEvents()
		if !*i.HasEvents {
			p = integration.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventsWith) > 0 {
		with := make([]predicate.Event, 0, len(i.HasEventsWith))
		for _, w := range i.HasEventsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, integration.HasEventsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyIntegrationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return integration.And(predicates...), nil
	}
}

// IntegrationHistoryWhereInput represents a where input for filtering IntegrationHistory queries.
type IntegrationHistoryWhereInput struct {
	Predicates []predicate.IntegrationHistory  `json:"-"`
	Not        *IntegrationHistoryWhereInput   `json:"not,omitempty"`
	Or         []*IntegrationHistoryWhereInput `json:"or,omitempty"`
	And        []*IntegrationHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "kind" field predicates.
	Kind             *string  `json:"kind,omitempty"`
	KindNEQ          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGT           *string  `json:"kindGT,omitempty"`
	KindGTE          *string  `json:"kindGTE,omitempty"`
	KindLT           *string  `json:"kindLT,omitempty"`
	KindLTE          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        bool     `json:"kindIsNil,omitempty"`
	KindNotNil       bool     `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *IntegrationHistoryWhereInput) AddPredicates(predicates ...predicate.IntegrationHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the IntegrationHistoryWhereInput filter on the IntegrationHistoryQuery builder.
func (i *IntegrationHistoryWhereInput) Filter(q *IntegrationHistoryQuery) (*IntegrationHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyIntegrationHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyIntegrationHistoryWhereInput is returned in case the IntegrationHistoryWhereInput is empty.
var ErrEmptyIntegrationHistoryWhereInput = errors.New("generated: empty predicate IntegrationHistoryWhereInput")

// P returns a predicate for filtering integrationhistories.
// An error is returned if the input is empty or invalid.
func (i *IntegrationHistoryWhereInput) P() (predicate.IntegrationHistory, error) {
	var predicates []predicate.IntegrationHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, integrationhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.IntegrationHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, integrationhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.IntegrationHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, integrationhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, integrationhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, integrationhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, integrationhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, integrationhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, integrationhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, integrationhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, integrationhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, integrationhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, integrationhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, integrationhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, integrationhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, integrationhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, integrationhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, integrationhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, integrationhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, integrationhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, integrationhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, integrationhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, integrationhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, integrationhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, integrationhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, integrationhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, integrationhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, integrationhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, integrationhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, integrationhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, integrationhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, integrationhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, integrationhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, integrationhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, integrationhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, integrationhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, integrationhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, integrationhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, integrationhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, integrationhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, integrationhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, integrationhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, integrationhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, integrationhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, integrationhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, integrationhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, integrationhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, integrationhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, integrationhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, integrationhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, integrationhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, integrationhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, integrationhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, integrationhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, integrationhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, integrationhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, integrationhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, integrationhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, integrationhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, integrationhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, integrationhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, integrationhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, integrationhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, integrationhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, integrationhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, integrationhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, integrationhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, integrationhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, integrationhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, integrationhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, integrationhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, integrationhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, integrationhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, integrationhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, integrationhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, integrationhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, integrationhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, integrationhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, integrationhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, integrationhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, integrationhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, integrationhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, integrationhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, integrationhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, integrationhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, integrationhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, integrationhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, integrationhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, integrationhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, integrationhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, integrationhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, integrationhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, integrationhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, integrationhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, integrationhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, integrationhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, integrationhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, integrationhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, integrationhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, integrationhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, integrationhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, integrationhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, integrationhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, integrationhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, integrationhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, integrationhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, integrationhistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, integrationhistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, integrationhistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, integrationhistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, integrationhistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, integrationhistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, integrationhistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, integrationhistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, integrationhistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, integrationhistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, integrationhistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, integrationhistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, integrationhistory.NameContainsFold(*i.NameContainsFold))
	}
	if i.Kind != nil {
		predicates = append(predicates, integrationhistory.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, integrationhistory.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, integrationhistory.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, integrationhistory.KindNotIn(i.KindNotIn...))
	}
	if i.KindGT != nil {
		predicates = append(predicates, integrationhistory.KindGT(*i.KindGT))
	}
	if i.KindGTE != nil {
		predicates = append(predicates, integrationhistory.KindGTE(*i.KindGTE))
	}
	if i.KindLT != nil {
		predicates = append(predicates, integrationhistory.KindLT(*i.KindLT))
	}
	if i.KindLTE != nil {
		predicates = append(predicates, integrationhistory.KindLTE(*i.KindLTE))
	}
	if i.KindContains != nil {
		predicates = append(predicates, integrationhistory.KindContains(*i.KindContains))
	}
	if i.KindHasPrefix != nil {
		predicates = append(predicates, integrationhistory.KindHasPrefix(*i.KindHasPrefix))
	}
	if i.KindHasSuffix != nil {
		predicates = append(predicates, integrationhistory.KindHasSuffix(*i.KindHasSuffix))
	}
	if i.KindIsNil {
		predicates = append(predicates, integrationhistory.KindIsNil())
	}
	if i.KindNotNil {
		predicates = append(predicates, integrationhistory.KindNotNil())
	}
	if i.KindEqualFold != nil {
		predicates = append(predicates, integrationhistory.KindEqualFold(*i.KindEqualFold))
	}
	if i.KindContainsFold != nil {
		predicates = append(predicates, integrationhistory.KindContainsFold(*i.KindContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyIntegrationHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return integrationhistory.And(predicates...), nil
	}
}

// InternalPolicyWhereInput represents a where input for filtering InternalPolicy queries.
type InternalPolicyWhereInput struct {
	Predicates []predicate.InternalPolicy  `json:"-"`
	Not        *InternalPolicyWhereInput   `json:"not,omitempty"`
	Or         []*InternalPolicyWhereInput `json:"or,omitempty"`
	And        []*InternalPolicyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "revision" field predicates.
	Revision             *string  `json:"revision,omitempty"`
	RevisionNEQ          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGT           *string  `json:"revisionGT,omitempty"`
	RevisionGTE          *string  `json:"revisionGTE,omitempty"`
	RevisionLT           *string  `json:"revisionLT,omitempty"`
	RevisionLTE          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        bool     `json:"revisionIsNil,omitempty"`
	RevisionNotNil       bool     `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                   `json:"statusIsNil,omitempty"`
	StatusNotNil bool                   `json:"statusNotNil,omitempty"`

	// "policy_type" field predicates.
	PolicyType             *string  `json:"policyType,omitempty"`
	PolicyTypeNEQ          *string  `json:"policyTypeNEQ,omitempty"`
	PolicyTypeIn           []string `json:"policyTypeIn,omitempty"`
	PolicyTypeNotIn        []string `json:"policyTypeNotIn,omitempty"`
	PolicyTypeGT           *string  `json:"policyTypeGT,omitempty"`
	PolicyTypeGTE          *string  `json:"policyTypeGTE,omitempty"`
	PolicyTypeLT           *string  `json:"policyTypeLT,omitempty"`
	PolicyTypeLTE          *string  `json:"policyTypeLTE,omitempty"`
	PolicyTypeContains     *string  `json:"policyTypeContains,omitempty"`
	PolicyTypeHasPrefix    *string  `json:"policyTypeHasPrefix,omitempty"`
	PolicyTypeHasSuffix    *string  `json:"policyTypeHasSuffix,omitempty"`
	PolicyTypeIsNil        bool     `json:"policyTypeIsNil,omitempty"`
	PolicyTypeNotNil       bool     `json:"policyTypeNotNil,omitempty"`
	PolicyTypeEqualFold    *string  `json:"policyTypeEqualFold,omitempty"`
	PolicyTypeContainsFold *string  `json:"policyTypeContainsFold,omitempty"`

	// "details" field predicates.
	Details             *string  `json:"details,omitempty"`
	DetailsNEQ          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGT           *string  `json:"detailsGT,omitempty"`
	DetailsGTE          *string  `json:"detailsGTE,omitempty"`
	DetailsLT           *string  `json:"detailsLT,omitempty"`
	DetailsLTE          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        bool     `json:"detailsIsNil,omitempty"`
	DetailsNotNil       bool     `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`

	// "approval_required" field predicates.
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNEQ    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  bool  `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil bool  `json:"approvalRequiredNotNil,omitempty"`

	// "review_due" field predicates.
	ReviewDue       *time.Time  `json:"reviewDue,omitempty"`
	ReviewDueNEQ    *time.Time  `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGT     *time.Time  `json:"reviewDueGT,omitempty"`
	ReviewDueGTE    *time.Time  `json:"reviewDueGTE,omitempty"`
	ReviewDueLT     *time.Time  `json:"reviewDueLT,omitempty"`
	ReviewDueLTE    *time.Time  `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil bool        `json:"reviewDueNotNil,omitempty"`

	// "review_frequency" field predicates.
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNEQ    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  bool              `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil bool              `json:"reviewFrequencyNotNil,omitempty"`

	// "approver_id" field predicates.
	ApproverID             *string  `json:"approverID,omitempty"`
	ApproverIDNEQ          *string  `json:"approverIDNEQ,omitempty"`
	ApproverIDIn           []string `json:"approverIDIn,omitempty"`
	ApproverIDNotIn        []string `json:"approverIDNotIn,omitempty"`
	ApproverIDGT           *string  `json:"approverIDGT,omitempty"`
	ApproverIDGTE          *string  `json:"approverIDGTE,omitempty"`
	ApproverIDLT           *string  `json:"approverIDLT,omitempty"`
	ApproverIDLTE          *string  `json:"approverIDLTE,omitempty"`
	ApproverIDContains     *string  `json:"approverIDContains,omitempty"`
	ApproverIDHasPrefix    *string  `json:"approverIDHasPrefix,omitempty"`
	ApproverIDHasSuffix    *string  `json:"approverIDHasSuffix,omitempty"`
	ApproverIDIsNil        bool     `json:"approverIDIsNil,omitempty"`
	ApproverIDNotNil       bool     `json:"approverIDNotNil,omitempty"`
	ApproverIDEqualFold    *string  `json:"approverIDEqualFold,omitempty"`
	ApproverIDContainsFold *string  `json:"approverIDContainsFold,omitempty"`

	// "delegate_id" field predicates.
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIDNEQ          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIDGT           *string  `json:"delegateIDGT,omitempty"`
	DelegateIDGTE          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIDLT           *string  `json:"delegateIDLT,omitempty"`
	DelegateIDLTE          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        bool     `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       bool     `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "blocked_groups" edge predicates.
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`

	// "editors" edge predicates.
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`

	// "approver" edge predicates.
	HasApprover     *bool              `json:"hasApprover,omitempty"`
	HasApproverWith []*GroupWhereInput `json:"hasApproverWith,omitempty"`

	// "delegate" edge predicates.
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`

	// "control_objectives" edge predicates.
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`

	// "controls" edge predicates.
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`

	// "subcontrols" edge predicates.
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`

	// "procedures" edge predicates.
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`

	// "narratives" edge predicates.
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`

	// "risks" edge predicates.
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`

	// "programs" edge predicates.
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *InternalPolicyWhereInput) AddPredicates(predicates ...predicate.InternalPolicy) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the InternalPolicyWhereInput filter on the InternalPolicyQuery builder.
func (i *InternalPolicyWhereInput) Filter(q *InternalPolicyQuery) (*InternalPolicyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyInternalPolicyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyInternalPolicyWhereInput is returned in case the InternalPolicyWhereInput is empty.
var ErrEmptyInternalPolicyWhereInput = errors.New("generated: empty predicate InternalPolicyWhereInput")

// P returns a predicate for filtering internalpolicies.
// An error is returned if the input is empty or invalid.
func (i *InternalPolicyWhereInput) P() (predicate.InternalPolicy, error) {
	var predicates []predicate.InternalPolicy
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, internalpolicy.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.InternalPolicy, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, internalpolicy.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.InternalPolicy, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, internalpolicy.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, internalpolicy.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, internalpolicy.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, internalpolicy.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, internalpolicy.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, internalpolicy.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, internalpolicy.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, internalpolicy.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, internalpolicy.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, internalpolicy.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, internalpolicy.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, internalpolicy.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, internalpolicy.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, internalpolicy.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, internalpolicy.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, internalpolicy.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, internalpolicy.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, internalpolicy.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, internalpolicy.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, internalpolicy.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, internalpolicy.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, internalpolicy.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, internalpolicy.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, internalpolicy.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, internalpolicy.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, internalpolicy.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, internalpolicy.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, internalpolicy.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, internalpolicy.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, internalpolicy.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, internalpolicy.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, internalpolicy.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, internalpolicy.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, internalpolicy.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, internalpolicy.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, internalpolicy.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, internalpolicy.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, internalpolicy.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, internalpolicy.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, internalpolicy.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, internalpolicy.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, internalpolicy.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, internalpolicy.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, internalpolicy.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, internalpolicy.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, internalpolicy.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, internalpolicy.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, internalpolicy.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, internalpolicy.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, internalpolicy.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, internalpolicy.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, internalpolicy.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, internalpolicy.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, internalpolicy.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, internalpolicy.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, internalpolicy.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, internalpolicy.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, internalpolicy.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, internalpolicy.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, internalpolicy.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, internalpolicy.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, internalpolicy.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, internalpolicy.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, internalpolicy.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, internalpolicy.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, internalpolicy.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, internalpolicy.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, internalpolicy.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, internalpolicy.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, internalpolicy.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, internalpolicy.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, internalpolicy.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, internalpolicy.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, internalpolicy.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.Revision != nil {
		predicates = append(predicates, internalpolicy.RevisionEQ(*i.Revision))
	}
	if i.RevisionNEQ != nil {
		predicates = append(predicates, internalpolicy.RevisionNEQ(*i.RevisionNEQ))
	}
	if len(i.RevisionIn) > 0 {
		predicates = append(predicates, internalpolicy.RevisionIn(i.RevisionIn...))
	}
	if len(i.RevisionNotIn) > 0 {
		predicates = append(predicates, internalpolicy.RevisionNotIn(i.RevisionNotIn...))
	}
	if i.RevisionGT != nil {
		predicates = append(predicates, internalpolicy.RevisionGT(*i.RevisionGT))
	}
	if i.RevisionGTE != nil {
		predicates = append(predicates, internalpolicy.RevisionGTE(*i.RevisionGTE))
	}
	if i.RevisionLT != nil {
		predicates = append(predicates, internalpolicy.RevisionLT(*i.RevisionLT))
	}
	if i.RevisionLTE != nil {
		predicates = append(predicates, internalpolicy.RevisionLTE(*i.RevisionLTE))
	}
	if i.RevisionContains != nil {
		predicates = append(predicates, internalpolicy.RevisionContains(*i.RevisionContains))
	}
	if i.RevisionHasPrefix != nil {
		predicates = append(predicates, internalpolicy.RevisionHasPrefix(*i.RevisionHasPrefix))
	}
	if i.RevisionHasSuffix != nil {
		predicates = append(predicates, internalpolicy.RevisionHasSuffix(*i.RevisionHasSuffix))
	}
	if i.RevisionIsNil {
		predicates = append(predicates, internalpolicy.RevisionIsNil())
	}
	if i.RevisionNotNil {
		predicates = append(predicates, internalpolicy.RevisionNotNil())
	}
	if i.RevisionEqualFold != nil {
		predicates = append(predicates, internalpolicy.RevisionEqualFold(*i.RevisionEqualFold))
	}
	if i.RevisionContainsFold != nil {
		predicates = append(predicates, internalpolicy.RevisionContainsFold(*i.RevisionContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, internalpolicy.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, internalpolicy.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, internalpolicy.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, internalpolicy.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, internalpolicy.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, internalpolicy.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, internalpolicy.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, internalpolicy.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, internalpolicy.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, internalpolicy.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, internalpolicy.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, internalpolicy.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, internalpolicy.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, internalpolicy.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, internalpolicy.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, internalpolicy.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, internalpolicy.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, internalpolicy.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, internalpolicy.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, internalpolicy.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, internalpolicy.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, internalpolicy.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, internalpolicy.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, internalpolicy.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, internalpolicy.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, internalpolicy.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, internalpolicy.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, internalpolicy.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, internalpolicy.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, internalpolicy.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, internalpolicy.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, internalpolicy.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, internalpolicy.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, internalpolicy.StatusNotNil())
	}
	if i.PolicyType != nil {
		predicates = append(predicates, internalpolicy.PolicyTypeEQ(*i.PolicyType))
	}
	if i.PolicyTypeNEQ != nil {
		predicates = append(predicates, internalpolicy.PolicyTypeNEQ(*i.PolicyTypeNEQ))
	}
	if len(i.PolicyTypeIn) > 0 {
		predicates = append(predicates, internalpolicy.PolicyTypeIn(i.PolicyTypeIn...))
	}
	if len(i.PolicyTypeNotIn) > 0 {
		predicates = append(predicates, internalpolicy.PolicyTypeNotIn(i.PolicyTypeNotIn...))
	}
	if i.PolicyTypeGT != nil {
		predicates = append(predicates, internalpolicy.PolicyTypeGT(*i.PolicyTypeGT))
	}
	if i.PolicyTypeGTE != nil {
		predicates = append(predicates, internalpolicy.PolicyTypeGTE(*i.PolicyTypeGTE))
	}
	if i.PolicyTypeLT != nil {
		predicates = append(predicates, internalpolicy.PolicyTypeLT(*i.PolicyTypeLT))
	}
	if i.PolicyTypeLTE != nil {
		predicates = append(predicates, internalpolicy.PolicyTypeLTE(*i.PolicyTypeLTE))
	}
	if i.PolicyTypeContains != nil {
		predicates = append(predicates, internalpolicy.PolicyTypeContains(*i.PolicyTypeContains))
	}
	if i.PolicyTypeHasPrefix != nil {
		predicates = append(predicates, internalpolicy.PolicyTypeHasPrefix(*i.PolicyTypeHasPrefix))
	}
	if i.PolicyTypeHasSuffix != nil {
		predicates = append(predicates, internalpolicy.PolicyTypeHasSuffix(*i.PolicyTypeHasSuffix))
	}
	if i.PolicyTypeIsNil {
		predicates = append(predicates, internalpolicy.PolicyTypeIsNil())
	}
	if i.PolicyTypeNotNil {
		predicates = append(predicates, internalpolicy.PolicyTypeNotNil())
	}
	if i.PolicyTypeEqualFold != nil {
		predicates = append(predicates, internalpolicy.PolicyTypeEqualFold(*i.PolicyTypeEqualFold))
	}
	if i.PolicyTypeContainsFold != nil {
		predicates = append(predicates, internalpolicy.PolicyTypeContainsFold(*i.PolicyTypeContainsFold))
	}
	if i.Details != nil {
		predicates = append(predicates, internalpolicy.DetailsEQ(*i.Details))
	}
	if i.DetailsNEQ != nil {
		predicates = append(predicates, internalpolicy.DetailsNEQ(*i.DetailsNEQ))
	}
	if len(i.DetailsIn) > 0 {
		predicates = append(predicates, internalpolicy.DetailsIn(i.DetailsIn...))
	}
	if len(i.DetailsNotIn) > 0 {
		predicates = append(predicates, internalpolicy.DetailsNotIn(i.DetailsNotIn...))
	}
	if i.DetailsGT != nil {
		predicates = append(predicates, internalpolicy.DetailsGT(*i.DetailsGT))
	}
	if i.DetailsGTE != nil {
		predicates = append(predicates, internalpolicy.DetailsGTE(*i.DetailsGTE))
	}
	if i.DetailsLT != nil {
		predicates = append(predicates, internalpolicy.DetailsLT(*i.DetailsLT))
	}
	if i.DetailsLTE != nil {
		predicates = append(predicates, internalpolicy.DetailsLTE(*i.DetailsLTE))
	}
	if i.DetailsContains != nil {
		predicates = append(predicates, internalpolicy.DetailsContains(*i.DetailsContains))
	}
	if i.DetailsHasPrefix != nil {
		predicates = append(predicates, internalpolicy.DetailsHasPrefix(*i.DetailsHasPrefix))
	}
	if i.DetailsHasSuffix != nil {
		predicates = append(predicates, internalpolicy.DetailsHasSuffix(*i.DetailsHasSuffix))
	}
	if i.DetailsIsNil {
		predicates = append(predicates, internalpolicy.DetailsIsNil())
	}
	if i.DetailsNotNil {
		predicates = append(predicates, internalpolicy.DetailsNotNil())
	}
	if i.DetailsEqualFold != nil {
		predicates = append(predicates, internalpolicy.DetailsEqualFold(*i.DetailsEqualFold))
	}
	if i.DetailsContainsFold != nil {
		predicates = append(predicates, internalpolicy.DetailsContainsFold(*i.DetailsContainsFold))
	}
	if i.ApprovalRequired != nil {
		predicates = append(predicates, internalpolicy.ApprovalRequiredEQ(*i.ApprovalRequired))
	}
	if i.ApprovalRequiredNEQ != nil {
		predicates = append(predicates, internalpolicy.ApprovalRequiredNEQ(*i.ApprovalRequiredNEQ))
	}
	if i.ApprovalRequiredIsNil {
		predicates = append(predicates, internalpolicy.ApprovalRequiredIsNil())
	}
	if i.ApprovalRequiredNotNil {
		predicates = append(predicates, internalpolicy.ApprovalRequiredNotNil())
	}
	if i.ReviewDue != nil {
		predicates = append(predicates, internalpolicy.ReviewDueEQ(*i.ReviewDue))
	}
	if i.ReviewDueNEQ != nil {
		predicates = append(predicates, internalpolicy.ReviewDueNEQ(*i.ReviewDueNEQ))
	}
	if len(i.ReviewDueIn) > 0 {
		predicates = append(predicates, internalpolicy.ReviewDueIn(i.ReviewDueIn...))
	}
	if len(i.ReviewDueNotIn) > 0 {
		predicates = append(predicates, internalpolicy.ReviewDueNotIn(i.ReviewDueNotIn...))
	}
	if i.ReviewDueGT != nil {
		predicates = append(predicates, internalpolicy.ReviewDueGT(*i.ReviewDueGT))
	}
	if i.ReviewDueGTE != nil {
		predicates = append(predicates, internalpolicy.ReviewDueGTE(*i.ReviewDueGTE))
	}
	if i.ReviewDueLT != nil {
		predicates = append(predicates, internalpolicy.ReviewDueLT(*i.ReviewDueLT))
	}
	if i.ReviewDueLTE != nil {
		predicates = append(predicates, internalpolicy.ReviewDueLTE(*i.ReviewDueLTE))
	}
	if i.ReviewDueIsNil {
		predicates = append(predicates, internalpolicy.ReviewDueIsNil())
	}
	if i.ReviewDueNotNil {
		predicates = append(predicates, internalpolicy.ReviewDueNotNil())
	}
	if i.ReviewFrequency != nil {
		predicates = append(predicates, internalpolicy.ReviewFrequencyEQ(*i.ReviewFrequency))
	}
	if i.ReviewFrequencyNEQ != nil {
		predicates = append(predicates, internalpolicy.ReviewFrequencyNEQ(*i.ReviewFrequencyNEQ))
	}
	if len(i.ReviewFrequencyIn) > 0 {
		predicates = append(predicates, internalpolicy.ReviewFrequencyIn(i.ReviewFrequencyIn...))
	}
	if len(i.ReviewFrequencyNotIn) > 0 {
		predicates = append(predicates, internalpolicy.ReviewFrequencyNotIn(i.ReviewFrequencyNotIn...))
	}
	if i.ReviewFrequencyIsNil {
		predicates = append(predicates, internalpolicy.ReviewFrequencyIsNil())
	}
	if i.ReviewFrequencyNotNil {
		predicates = append(predicates, internalpolicy.ReviewFrequencyNotNil())
	}
	if i.ApproverID != nil {
		predicates = append(predicates, internalpolicy.ApproverIDEQ(*i.ApproverID))
	}
	if i.ApproverIDNEQ != nil {
		predicates = append(predicates, internalpolicy.ApproverIDNEQ(*i.ApproverIDNEQ))
	}
	if len(i.ApproverIDIn) > 0 {
		predicates = append(predicates, internalpolicy.ApproverIDIn(i.ApproverIDIn...))
	}
	if len(i.ApproverIDNotIn) > 0 {
		predicates = append(predicates, internalpolicy.ApproverIDNotIn(i.ApproverIDNotIn...))
	}
	if i.ApproverIDGT != nil {
		predicates = append(predicates, internalpolicy.ApproverIDGT(*i.ApproverIDGT))
	}
	if i.ApproverIDGTE != nil {
		predicates = append(predicates, internalpolicy.ApproverIDGTE(*i.ApproverIDGTE))
	}
	if i.ApproverIDLT != nil {
		predicates = append(predicates, internalpolicy.ApproverIDLT(*i.ApproverIDLT))
	}
	if i.ApproverIDLTE != nil {
		predicates = append(predicates, internalpolicy.ApproverIDLTE(*i.ApproverIDLTE))
	}
	if i.ApproverIDContains != nil {
		predicates = append(predicates, internalpolicy.ApproverIDContains(*i.ApproverIDContains))
	}
	if i.ApproverIDHasPrefix != nil {
		predicates = append(predicates, internalpolicy.ApproverIDHasPrefix(*i.ApproverIDHasPrefix))
	}
	if i.ApproverIDHasSuffix != nil {
		predicates = append(predicates, internalpolicy.ApproverIDHasSuffix(*i.ApproverIDHasSuffix))
	}
	if i.ApproverIDIsNil {
		predicates = append(predicates, internalpolicy.ApproverIDIsNil())
	}
	if i.ApproverIDNotNil {
		predicates = append(predicates, internalpolicy.ApproverIDNotNil())
	}
	if i.ApproverIDEqualFold != nil {
		predicates = append(predicates, internalpolicy.ApproverIDEqualFold(*i.ApproverIDEqualFold))
	}
	if i.ApproverIDContainsFold != nil {
		predicates = append(predicates, internalpolicy.ApproverIDContainsFold(*i.ApproverIDContainsFold))
	}
	if i.DelegateID != nil {
		predicates = append(predicates, internalpolicy.DelegateIDEQ(*i.DelegateID))
	}
	if i.DelegateIDNEQ != nil {
		predicates = append(predicates, internalpolicy.DelegateIDNEQ(*i.DelegateIDNEQ))
	}
	if len(i.DelegateIDIn) > 0 {
		predicates = append(predicates, internalpolicy.DelegateIDIn(i.DelegateIDIn...))
	}
	if len(i.DelegateIDNotIn) > 0 {
		predicates = append(predicates, internalpolicy.DelegateIDNotIn(i.DelegateIDNotIn...))
	}
	if i.DelegateIDGT != nil {
		predicates = append(predicates, internalpolicy.DelegateIDGT(*i.DelegateIDGT))
	}
	if i.DelegateIDGTE != nil {
		predicates = append(predicates, internalpolicy.DelegateIDGTE(*i.DelegateIDGTE))
	}
	if i.DelegateIDLT != nil {
		predicates = append(predicates, internalpolicy.DelegateIDLT(*i.DelegateIDLT))
	}
	if i.DelegateIDLTE != nil {
		predicates = append(predicates, internalpolicy.DelegateIDLTE(*i.DelegateIDLTE))
	}
	if i.DelegateIDContains != nil {
		predicates = append(predicates, internalpolicy.DelegateIDContains(*i.DelegateIDContains))
	}
	if i.DelegateIDHasPrefix != nil {
		predicates = append(predicates, internalpolicy.DelegateIDHasPrefix(*i.DelegateIDHasPrefix))
	}
	if i.DelegateIDHasSuffix != nil {
		predicates = append(predicates, internalpolicy.DelegateIDHasSuffix(*i.DelegateIDHasSuffix))
	}
	if i.DelegateIDIsNil {
		predicates = append(predicates, internalpolicy.DelegateIDIsNil())
	}
	if i.DelegateIDNotNil {
		predicates = append(predicates, internalpolicy.DelegateIDNotNil())
	}
	if i.DelegateIDEqualFold != nil {
		predicates = append(predicates, internalpolicy.DelegateIDEqualFold(*i.DelegateIDEqualFold))
	}
	if i.DelegateIDContainsFold != nil {
		predicates = append(predicates, internalpolicy.DelegateIDContainsFold(*i.DelegateIDContainsFold))
	}

	if i.HasOwner != nil {
		p := internalpolicy.HasOwner()
		if !*i.HasOwner {
			p = internalpolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, internalpolicy.HasOwnerWith(with...))
	}
	if i.HasBlockedGroups != nil {
		p := internalpolicy.HasBlockedGroups()
		if !*i.HasBlockedGroups {
			p = internalpolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBlockedGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasBlockedGroupsWith))
		for _, w := range i.HasBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, internalpolicy.HasBlockedGroupsWith(with...))
	}
	if i.HasEditors != nil {
		p := internalpolicy.HasEditors()
		if !*i.HasEditors {
			p = internalpolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEditorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasEditorsWith))
		for _, w := range i.HasEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, internalpolicy.HasEditorsWith(with...))
	}
	if i.HasApprover != nil {
		p := internalpolicy.HasApprover()
		if !*i.HasApprover {
			p = internalpolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasApproverWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasApproverWith))
		for _, w := range i.HasApproverWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasApproverWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, internalpolicy.HasApproverWith(with...))
	}
	if i.HasDelegate != nil {
		p := internalpolicy.HasDelegate()
		if !*i.HasDelegate {
			p = internalpolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDelegateWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasDelegateWith))
		for _, w := range i.HasDelegateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDelegateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, internalpolicy.HasDelegateWith(with...))
	}
	if i.HasControlObjectives != nil {
		p := internalpolicy.HasControlObjectives()
		if !*i.HasControlObjectives {
			p = internalpolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlObjectivesWith) > 0 {
		with := make([]predicate.ControlObjective, 0, len(i.HasControlObjectivesWith))
		for _, w := range i.HasControlObjectivesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlObjectivesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, internalpolicy.HasControlObjectivesWith(with...))
	}
	if i.HasControls != nil {
		p := internalpolicy.HasControls()
		if !*i.HasControls {
			p = internalpolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasControlsWith))
		for _, w := range i.HasControlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, internalpolicy.HasControlsWith(with...))
	}
	if i.HasSubcontrols != nil {
		p := internalpolicy.HasSubcontrols()
		if !*i.HasSubcontrols {
			p = internalpolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubcontrolsWith) > 0 {
		with := make([]predicate.Subcontrol, 0, len(i.HasSubcontrolsWith))
		for _, w := range i.HasSubcontrolsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubcontrolsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, internalpolicy.HasSubcontrolsWith(with...))
	}
	if i.HasProcedures != nil {
		p := internalpolicy.HasProcedures()
		if !*i.HasProcedures {
			p = internalpolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProceduresWith) > 0 {
		with := make([]predicate.Procedure, 0, len(i.HasProceduresWith))
		for _, w := range i.HasProceduresWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProceduresWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, internalpolicy.HasProceduresWith(with...))
	}
	if i.HasNarratives != nil {
		p := internalpolicy.HasNarratives()
		if !*i.HasNarratives {
			p = internalpolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNarrativesWith) > 0 {
		with := make([]predicate.Narrative, 0, len(i.HasNarrativesWith))
		for _, w := range i.HasNarrativesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNarrativesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, internalpolicy.HasNarrativesWith(with...))
	}
	if i.HasTasks != nil {
		p := internalpolicy.HasTasks()
		if !*i.HasTasks {
			p = internalpolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, internalpolicy.HasTasksWith(with...))
	}
	if i.HasRisks != nil {
		p := internalpolicy.HasRisks()
		if !*i.HasRisks {
			p = internalpolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRisksWith) > 0 {
		with := make([]predicate.Risk, 0, len(i.HasRisksWith))
		for _, w := range i.HasRisksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRisksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, internalpolicy.HasRisksWith(with...))
	}
	if i.HasPrograms != nil {
		p := internalpolicy.HasPrograms()
		if !*i.HasPrograms {
			p = internalpolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramsWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramsWith))
		for _, w := range i.HasProgramsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, internalpolicy.HasProgramsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyInternalPolicyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return internalpolicy.And(predicates...), nil
	}
}

// InternalPolicyHistoryWhereInput represents a where input for filtering InternalPolicyHistory queries.
type InternalPolicyHistoryWhereInput struct {
	Predicates []predicate.InternalPolicyHistory  `json:"-"`
	Not        *InternalPolicyHistoryWhereInput   `json:"not,omitempty"`
	Or         []*InternalPolicyHistoryWhereInput `json:"or,omitempty"`
	And        []*InternalPolicyHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "revision" field predicates.
	Revision             *string  `json:"revision,omitempty"`
	RevisionNEQ          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGT           *string  `json:"revisionGT,omitempty"`
	RevisionGTE          *string  `json:"revisionGTE,omitempty"`
	RevisionLT           *string  `json:"revisionLT,omitempty"`
	RevisionLTE          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        bool     `json:"revisionIsNil,omitempty"`
	RevisionNotNil       bool     `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                   `json:"statusIsNil,omitempty"`
	StatusNotNil bool                   `json:"statusNotNil,omitempty"`

	// "policy_type" field predicates.
	PolicyType             *string  `json:"policyType,omitempty"`
	PolicyTypeNEQ          *string  `json:"policyTypeNEQ,omitempty"`
	PolicyTypeIn           []string `json:"policyTypeIn,omitempty"`
	PolicyTypeNotIn        []string `json:"policyTypeNotIn,omitempty"`
	PolicyTypeGT           *string  `json:"policyTypeGT,omitempty"`
	PolicyTypeGTE          *string  `json:"policyTypeGTE,omitempty"`
	PolicyTypeLT           *string  `json:"policyTypeLT,omitempty"`
	PolicyTypeLTE          *string  `json:"policyTypeLTE,omitempty"`
	PolicyTypeContains     *string  `json:"policyTypeContains,omitempty"`
	PolicyTypeHasPrefix    *string  `json:"policyTypeHasPrefix,omitempty"`
	PolicyTypeHasSuffix    *string  `json:"policyTypeHasSuffix,omitempty"`
	PolicyTypeIsNil        bool     `json:"policyTypeIsNil,omitempty"`
	PolicyTypeNotNil       bool     `json:"policyTypeNotNil,omitempty"`
	PolicyTypeEqualFold    *string  `json:"policyTypeEqualFold,omitempty"`
	PolicyTypeContainsFold *string  `json:"policyTypeContainsFold,omitempty"`

	// "details" field predicates.
	Details             *string  `json:"details,omitempty"`
	DetailsNEQ          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGT           *string  `json:"detailsGT,omitempty"`
	DetailsGTE          *string  `json:"detailsGTE,omitempty"`
	DetailsLT           *string  `json:"detailsLT,omitempty"`
	DetailsLTE          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        bool     `json:"detailsIsNil,omitempty"`
	DetailsNotNil       bool     `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`

	// "approval_required" field predicates.
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNEQ    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  bool  `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil bool  `json:"approvalRequiredNotNil,omitempty"`

	// "review_due" field predicates.
	ReviewDue       *time.Time  `json:"reviewDue,omitempty"`
	ReviewDueNEQ    *time.Time  `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGT     *time.Time  `json:"reviewDueGT,omitempty"`
	ReviewDueGTE    *time.Time  `json:"reviewDueGTE,omitempty"`
	ReviewDueLT     *time.Time  `json:"reviewDueLT,omitempty"`
	ReviewDueLTE    *time.Time  `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil bool        `json:"reviewDueNotNil,omitempty"`

	// "review_frequency" field predicates.
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNEQ    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  bool              `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil bool              `json:"reviewFrequencyNotNil,omitempty"`

	// "approver_id" field predicates.
	ApproverID             *string  `json:"approverID,omitempty"`
	ApproverIDNEQ          *string  `json:"approverIDNEQ,omitempty"`
	ApproverIDIn           []string `json:"approverIDIn,omitempty"`
	ApproverIDNotIn        []string `json:"approverIDNotIn,omitempty"`
	ApproverIDGT           *string  `json:"approverIDGT,omitempty"`
	ApproverIDGTE          *string  `json:"approverIDGTE,omitempty"`
	ApproverIDLT           *string  `json:"approverIDLT,omitempty"`
	ApproverIDLTE          *string  `json:"approverIDLTE,omitempty"`
	ApproverIDContains     *string  `json:"approverIDContains,omitempty"`
	ApproverIDHasPrefix    *string  `json:"approverIDHasPrefix,omitempty"`
	ApproverIDHasSuffix    *string  `json:"approverIDHasSuffix,omitempty"`
	ApproverIDIsNil        bool     `json:"approverIDIsNil,omitempty"`
	ApproverIDNotNil       bool     `json:"approverIDNotNil,omitempty"`
	ApproverIDEqualFold    *string  `json:"approverIDEqualFold,omitempty"`
	ApproverIDContainsFold *string  `json:"approverIDContainsFold,omitempty"`

	// "delegate_id" field predicates.
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIDNEQ          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIDGT           *string  `json:"delegateIDGT,omitempty"`
	DelegateIDGTE          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIDLT           *string  `json:"delegateIDLT,omitempty"`
	DelegateIDLTE          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        bool     `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       bool     `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *InternalPolicyHistoryWhereInput) AddPredicates(predicates ...predicate.InternalPolicyHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the InternalPolicyHistoryWhereInput filter on the InternalPolicyHistoryQuery builder.
func (i *InternalPolicyHistoryWhereInput) Filter(q *InternalPolicyHistoryQuery) (*InternalPolicyHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyInternalPolicyHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyInternalPolicyHistoryWhereInput is returned in case the InternalPolicyHistoryWhereInput is empty.
var ErrEmptyInternalPolicyHistoryWhereInput = errors.New("generated: empty predicate InternalPolicyHistoryWhereInput")

// P returns a predicate for filtering internalpolicyhistories.
// An error is returned if the input is empty or invalid.
func (i *InternalPolicyHistoryWhereInput) P() (predicate.InternalPolicyHistory, error) {
	var predicates []predicate.InternalPolicyHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, internalpolicyhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.InternalPolicyHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, internalpolicyhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.InternalPolicyHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, internalpolicyhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, internalpolicyhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, internalpolicyhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, internalpolicyhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, internalpolicyhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, internalpolicyhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, internalpolicyhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, internalpolicyhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, internalpolicyhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, internalpolicyhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, internalpolicyhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, internalpolicyhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, internalpolicyhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, internalpolicyhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, internalpolicyhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, internalpolicyhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, internalpolicyhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, internalpolicyhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, internalpolicyhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, internalpolicyhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, internalpolicyhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, internalpolicyhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, internalpolicyhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, internalpolicyhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, internalpolicyhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, internalpolicyhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, internalpolicyhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, internalpolicyhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, internalpolicyhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, internalpolicyhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, internalpolicyhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, internalpolicyhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, internalpolicyhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, internalpolicyhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, internalpolicyhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, internalpolicyhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, internalpolicyhistory.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, internalpolicyhistory.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, internalpolicyhistory.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, internalpolicyhistory.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, internalpolicyhistory.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, internalpolicyhistory.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, internalpolicyhistory.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, internalpolicyhistory.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, internalpolicyhistory.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, internalpolicyhistory.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.Revision != nil {
		predicates = append(predicates, internalpolicyhistory.RevisionEQ(*i.Revision))
	}
	if i.RevisionNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.RevisionNEQ(*i.RevisionNEQ))
	}
	if len(i.RevisionIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.RevisionIn(i.RevisionIn...))
	}
	if len(i.RevisionNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.RevisionNotIn(i.RevisionNotIn...))
	}
	if i.RevisionGT != nil {
		predicates = append(predicates, internalpolicyhistory.RevisionGT(*i.RevisionGT))
	}
	if i.RevisionGTE != nil {
		predicates = append(predicates, internalpolicyhistory.RevisionGTE(*i.RevisionGTE))
	}
	if i.RevisionLT != nil {
		predicates = append(predicates, internalpolicyhistory.RevisionLT(*i.RevisionLT))
	}
	if i.RevisionLTE != nil {
		predicates = append(predicates, internalpolicyhistory.RevisionLTE(*i.RevisionLTE))
	}
	if i.RevisionContains != nil {
		predicates = append(predicates, internalpolicyhistory.RevisionContains(*i.RevisionContains))
	}
	if i.RevisionHasPrefix != nil {
		predicates = append(predicates, internalpolicyhistory.RevisionHasPrefix(*i.RevisionHasPrefix))
	}
	if i.RevisionHasSuffix != nil {
		predicates = append(predicates, internalpolicyhistory.RevisionHasSuffix(*i.RevisionHasSuffix))
	}
	if i.RevisionIsNil {
		predicates = append(predicates, internalpolicyhistory.RevisionIsNil())
	}
	if i.RevisionNotNil {
		predicates = append(predicates, internalpolicyhistory.RevisionNotNil())
	}
	if i.RevisionEqualFold != nil {
		predicates = append(predicates, internalpolicyhistory.RevisionEqualFold(*i.RevisionEqualFold))
	}
	if i.RevisionContainsFold != nil {
		predicates = append(predicates, internalpolicyhistory.RevisionContainsFold(*i.RevisionContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, internalpolicyhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, internalpolicyhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, internalpolicyhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, internalpolicyhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, internalpolicyhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, internalpolicyhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, internalpolicyhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, internalpolicyhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, internalpolicyhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, internalpolicyhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, internalpolicyhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, internalpolicyhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, internalpolicyhistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, internalpolicyhistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, internalpolicyhistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, internalpolicyhistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, internalpolicyhistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, internalpolicyhistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, internalpolicyhistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, internalpolicyhistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, internalpolicyhistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, internalpolicyhistory.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, internalpolicyhistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, internalpolicyhistory.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, internalpolicyhistory.StatusNotNil())
	}
	if i.PolicyType != nil {
		predicates = append(predicates, internalpolicyhistory.PolicyTypeEQ(*i.PolicyType))
	}
	if i.PolicyTypeNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.PolicyTypeNEQ(*i.PolicyTypeNEQ))
	}
	if len(i.PolicyTypeIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.PolicyTypeIn(i.PolicyTypeIn...))
	}
	if len(i.PolicyTypeNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.PolicyTypeNotIn(i.PolicyTypeNotIn...))
	}
	if i.PolicyTypeGT != nil {
		predicates = append(predicates, internalpolicyhistory.PolicyTypeGT(*i.PolicyTypeGT))
	}
	if i.PolicyTypeGTE != nil {
		predicates = append(predicates, internalpolicyhistory.PolicyTypeGTE(*i.PolicyTypeGTE))
	}
	if i.PolicyTypeLT != nil {
		predicates = append(predicates, internalpolicyhistory.PolicyTypeLT(*i.PolicyTypeLT))
	}
	if i.PolicyTypeLTE != nil {
		predicates = append(predicates, internalpolicyhistory.PolicyTypeLTE(*i.PolicyTypeLTE))
	}
	if i.PolicyTypeContains != nil {
		predicates = append(predicates, internalpolicyhistory.PolicyTypeContains(*i.PolicyTypeContains))
	}
	if i.PolicyTypeHasPrefix != nil {
		predicates = append(predicates, internalpolicyhistory.PolicyTypeHasPrefix(*i.PolicyTypeHasPrefix))
	}
	if i.PolicyTypeHasSuffix != nil {
		predicates = append(predicates, internalpolicyhistory.PolicyTypeHasSuffix(*i.PolicyTypeHasSuffix))
	}
	if i.PolicyTypeIsNil {
		predicates = append(predicates, internalpolicyhistory.PolicyTypeIsNil())
	}
	if i.PolicyTypeNotNil {
		predicates = append(predicates, internalpolicyhistory.PolicyTypeNotNil())
	}
	if i.PolicyTypeEqualFold != nil {
		predicates = append(predicates, internalpolicyhistory.PolicyTypeEqualFold(*i.PolicyTypeEqualFold))
	}
	if i.PolicyTypeContainsFold != nil {
		predicates = append(predicates, internalpolicyhistory.PolicyTypeContainsFold(*i.PolicyTypeContainsFold))
	}
	if i.Details != nil {
		predicates = append(predicates, internalpolicyhistory.DetailsEQ(*i.Details))
	}
	if i.DetailsNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.DetailsNEQ(*i.DetailsNEQ))
	}
	if len(i.DetailsIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.DetailsIn(i.DetailsIn...))
	}
	if len(i.DetailsNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.DetailsNotIn(i.DetailsNotIn...))
	}
	if i.DetailsGT != nil {
		predicates = append(predicates, internalpolicyhistory.DetailsGT(*i.DetailsGT))
	}
	if i.DetailsGTE != nil {
		predicates = append(predicates, internalpolicyhistory.DetailsGTE(*i.DetailsGTE))
	}
	if i.DetailsLT != nil {
		predicates = append(predicates, internalpolicyhistory.DetailsLT(*i.DetailsLT))
	}
	if i.DetailsLTE != nil {
		predicates = append(predicates, internalpolicyhistory.DetailsLTE(*i.DetailsLTE))
	}
	if i.DetailsContains != nil {
		predicates = append(predicates, internalpolicyhistory.DetailsContains(*i.DetailsContains))
	}
	if i.DetailsHasPrefix != nil {
		predicates = append(predicates, internalpolicyhistory.DetailsHasPrefix(*i.DetailsHasPrefix))
	}
	if i.DetailsHasSuffix != nil {
		predicates = append(predicates, internalpolicyhistory.DetailsHasSuffix(*i.DetailsHasSuffix))
	}
	if i.DetailsIsNil {
		predicates = append(predicates, internalpolicyhistory.DetailsIsNil())
	}
	if i.DetailsNotNil {
		predicates = append(predicates, internalpolicyhistory.DetailsNotNil())
	}
	if i.DetailsEqualFold != nil {
		predicates = append(predicates, internalpolicyhistory.DetailsEqualFold(*i.DetailsEqualFold))
	}
	if i.DetailsContainsFold != nil {
		predicates = append(predicates, internalpolicyhistory.DetailsContainsFold(*i.DetailsContainsFold))
	}
	if i.ApprovalRequired != nil {
		predicates = append(predicates, internalpolicyhistory.ApprovalRequiredEQ(*i.ApprovalRequired))
	}
	if i.ApprovalRequiredNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.ApprovalRequiredNEQ(*i.ApprovalRequiredNEQ))
	}
	if i.ApprovalRequiredIsNil {
		predicates = append(predicates, internalpolicyhistory.ApprovalRequiredIsNil())
	}
	if i.ApprovalRequiredNotNil {
		predicates = append(predicates, internalpolicyhistory.ApprovalRequiredNotNil())
	}
	if i.ReviewDue != nil {
		predicates = append(predicates, internalpolicyhistory.ReviewDueEQ(*i.ReviewDue))
	}
	if i.ReviewDueNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.ReviewDueNEQ(*i.ReviewDueNEQ))
	}
	if len(i.ReviewDueIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.ReviewDueIn(i.ReviewDueIn...))
	}
	if len(i.ReviewDueNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.ReviewDueNotIn(i.ReviewDueNotIn...))
	}
	if i.ReviewDueGT != nil {
		predicates = append(predicates, internalpolicyhistory.ReviewDueGT(*i.ReviewDueGT))
	}
	if i.ReviewDueGTE != nil {
		predicates = append(predicates, internalpolicyhistory.ReviewDueGTE(*i.ReviewDueGTE))
	}
	if i.ReviewDueLT != nil {
		predicates = append(predicates, internalpolicyhistory.ReviewDueLT(*i.ReviewDueLT))
	}
	if i.ReviewDueLTE != nil {
		predicates = append(predicates, internalpolicyhistory.ReviewDueLTE(*i.ReviewDueLTE))
	}
	if i.ReviewDueIsNil {
		predicates = append(predicates, internalpolicyhistory.ReviewDueIsNil())
	}
	if i.ReviewDueNotNil {
		predicates = append(predicates, internalpolicyhistory.ReviewDueNotNil())
	}
	if i.ReviewFrequency != nil {
		predicates = append(predicates, internalpolicyhistory.ReviewFrequencyEQ(*i.ReviewFrequency))
	}
	if i.ReviewFrequencyNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.ReviewFrequencyNEQ(*i.ReviewFrequencyNEQ))
	}
	if len(i.ReviewFrequencyIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.ReviewFrequencyIn(i.ReviewFrequencyIn...))
	}
	if len(i.ReviewFrequencyNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.ReviewFrequencyNotIn(i.ReviewFrequencyNotIn...))
	}
	if i.ReviewFrequencyIsNil {
		predicates = append(predicates, internalpolicyhistory.ReviewFrequencyIsNil())
	}
	if i.ReviewFrequencyNotNil {
		predicates = append(predicates, internalpolicyhistory.ReviewFrequencyNotNil())
	}
	if i.ApproverID != nil {
		predicates = append(predicates, internalpolicyhistory.ApproverIDEQ(*i.ApproverID))
	}
	if i.ApproverIDNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.ApproverIDNEQ(*i.ApproverIDNEQ))
	}
	if len(i.ApproverIDIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.ApproverIDIn(i.ApproverIDIn...))
	}
	if len(i.ApproverIDNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.ApproverIDNotIn(i.ApproverIDNotIn...))
	}
	if i.ApproverIDGT != nil {
		predicates = append(predicates, internalpolicyhistory.ApproverIDGT(*i.ApproverIDGT))
	}
	if i.ApproverIDGTE != nil {
		predicates = append(predicates, internalpolicyhistory.ApproverIDGTE(*i.ApproverIDGTE))
	}
	if i.ApproverIDLT != nil {
		predicates = append(predicates, internalpolicyhistory.ApproverIDLT(*i.ApproverIDLT))
	}
	if i.ApproverIDLTE != nil {
		predicates = append(predicates, internalpolicyhistory.ApproverIDLTE(*i.ApproverIDLTE))
	}
	if i.ApproverIDContains != nil {
		predicates = append(predicates, internalpolicyhistory.ApproverIDContains(*i.ApproverIDContains))
	}
	if i.ApproverIDHasPrefix != nil {
		predicates = append(predicates, internalpolicyhistory.ApproverIDHasPrefix(*i.ApproverIDHasPrefix))
	}
	if i.ApproverIDHasSuffix != nil {
		predicates = append(predicates, internalpolicyhistory.ApproverIDHasSuffix(*i.ApproverIDHasSuffix))
	}
	if i.ApproverIDIsNil {
		predicates = append(predicates, internalpolicyhistory.ApproverIDIsNil())
	}
	if i.ApproverIDNotNil {
		predicates = append(predicates, internalpolicyhistory.ApproverIDNotNil())
	}
	if i.ApproverIDEqualFold != nil {
		predicates = append(predicates, internalpolicyhistory.ApproverIDEqualFold(*i.ApproverIDEqualFold))
	}
	if i.ApproverIDContainsFold != nil {
		predicates = append(predicates, internalpolicyhistory.ApproverIDContainsFold(*i.ApproverIDContainsFold))
	}
	if i.DelegateID != nil {
		predicates = append(predicates, internalpolicyhistory.DelegateIDEQ(*i.DelegateID))
	}
	if i.DelegateIDNEQ != nil {
		predicates = append(predicates, internalpolicyhistory.DelegateIDNEQ(*i.DelegateIDNEQ))
	}
	if len(i.DelegateIDIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.DelegateIDIn(i.DelegateIDIn...))
	}
	if len(i.DelegateIDNotIn) > 0 {
		predicates = append(predicates, internalpolicyhistory.DelegateIDNotIn(i.DelegateIDNotIn...))
	}
	if i.DelegateIDGT != nil {
		predicates = append(predicates, internalpolicyhistory.DelegateIDGT(*i.DelegateIDGT))
	}
	if i.DelegateIDGTE != nil {
		predicates = append(predicates, internalpolicyhistory.DelegateIDGTE(*i.DelegateIDGTE))
	}
	if i.DelegateIDLT != nil {
		predicates = append(predicates, internalpolicyhistory.DelegateIDLT(*i.DelegateIDLT))
	}
	if i.DelegateIDLTE != nil {
		predicates = append(predicates, internalpolicyhistory.DelegateIDLTE(*i.DelegateIDLTE))
	}
	if i.DelegateIDContains != nil {
		predicates = append(predicates, internalpolicyhistory.DelegateIDContains(*i.DelegateIDContains))
	}
	if i.DelegateIDHasPrefix != nil {
		predicates = append(predicates, internalpolicyhistory.DelegateIDHasPrefix(*i.DelegateIDHasPrefix))
	}
	if i.DelegateIDHasSuffix != nil {
		predicates = append(predicates, internalpolicyhistory.DelegateIDHasSuffix(*i.DelegateIDHasSuffix))
	}
	if i.DelegateIDIsNil {
		predicates = append(predicates, internalpolicyhistory.DelegateIDIsNil())
	}
	if i.DelegateIDNotNil {
		predicates = append(predicates, internalpolicyhistory.DelegateIDNotNil())
	}
	if i.DelegateIDEqualFold != nil {
		predicates = append(predicates, internalpolicyhistory.DelegateIDEqualFold(*i.DelegateIDEqualFold))
	}
	if i.DelegateIDContainsFold != nil {
		predicates = append(predicates, internalpolicyhistory.DelegateIDContainsFold(*i.DelegateIDContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyInternalPolicyHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return internalpolicyhistory.And(predicates...), nil
	}
}

// InviteWhereInput represents a where input for filtering Invite queries.
type InviteWhereInput struct {
	Predicates []predicate.Invite  `json:"-"`
	Not        *InviteWhereInput   `json:"not,omitempty"`
	Or         []*InviteWhereInput `json:"or,omitempty"`
	And        []*InviteWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "expires" field predicates.
	Expires       *time.Time  `json:"expires,omitempty"`
	ExpiresNEQ    *time.Time  `json:"expiresNEQ,omitempty"`
	ExpiresIn     []time.Time `json:"expiresIn,omitempty"`
	ExpiresNotIn  []time.Time `json:"expiresNotIn,omitempty"`
	ExpiresGT     *time.Time  `json:"expiresGT,omitempty"`
	ExpiresGTE    *time.Time  `json:"expiresGTE,omitempty"`
	ExpiresLT     *time.Time  `json:"expiresLT,omitempty"`
	ExpiresLTE    *time.Time  `json:"expiresLTE,omitempty"`
	ExpiresIsNil  bool        `json:"expiresIsNil,omitempty"`
	ExpiresNotNil bool        `json:"expiresNotNil,omitempty"`

	// "recipient" field predicates.
	Recipient             *string  `json:"recipient,omitempty"`
	RecipientNEQ          *string  `json:"recipientNEQ,omitempty"`
	RecipientIn           []string `json:"recipientIn,omitempty"`
	RecipientNotIn        []string `json:"recipientNotIn,omitempty"`
	RecipientGT           *string  `json:"recipientGT,omitempty"`
	RecipientGTE          *string  `json:"recipientGTE,omitempty"`
	RecipientLT           *string  `json:"recipientLT,omitempty"`
	RecipientLTE          *string  `json:"recipientLTE,omitempty"`
	RecipientContains     *string  `json:"recipientContains,omitempty"`
	RecipientHasPrefix    *string  `json:"recipientHasPrefix,omitempty"`
	RecipientHasSuffix    *string  `json:"recipientHasSuffix,omitempty"`
	RecipientEqualFold    *string  `json:"recipientEqualFold,omitempty"`
	RecipientContainsFold *string  `json:"recipientContainsFold,omitempty"`

	// "status" field predicates.
	Status      *enums.InviteStatus  `json:"status,omitempty"`
	StatusNEQ   *enums.InviteStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.InviteStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.InviteStatus `json:"statusNotIn,omitempty"`

	// "role" field predicates.
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNEQ   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`

	// "send_attempts" field predicates.
	SendAttempts      *int  `json:"sendAttempts,omitempty"`
	SendAttemptsNEQ   *int  `json:"sendAttemptsNEQ,omitempty"`
	SendAttemptsIn    []int `json:"sendAttemptsIn,omitempty"`
	SendAttemptsNotIn []int `json:"sendAttemptsNotIn,omitempty"`
	SendAttemptsGT    *int  `json:"sendAttemptsGT,omitempty"`
	SendAttemptsGTE   *int  `json:"sendAttemptsGTE,omitempty"`
	SendAttemptsLT    *int  `json:"sendAttemptsLT,omitempty"`
	SendAttemptsLTE   *int  `json:"sendAttemptsLTE,omitempty"`

	// "requestor_id" field predicates.
	RequestorID             *string  `json:"requestorID,omitempty"`
	RequestorIDNEQ          *string  `json:"requestorIDNEQ,omitempty"`
	RequestorIDIn           []string `json:"requestorIDIn,omitempty"`
	RequestorIDNotIn        []string `json:"requestorIDNotIn,omitempty"`
	RequestorIDGT           *string  `json:"requestorIDGT,omitempty"`
	RequestorIDGTE          *string  `json:"requestorIDGTE,omitempty"`
	RequestorIDLT           *string  `json:"requestorIDLT,omitempty"`
	RequestorIDLTE          *string  `json:"requestorIDLTE,omitempty"`
	RequestorIDContains     *string  `json:"requestorIDContains,omitempty"`
	RequestorIDHasPrefix    *string  `json:"requestorIDHasPrefix,omitempty"`
	RequestorIDHasSuffix    *string  `json:"requestorIDHasSuffix,omitempty"`
	RequestorIDIsNil        bool     `json:"requestorIDIsNil,omitempty"`
	RequestorIDNotNil       bool     `json:"requestorIDNotNil,omitempty"`
	RequestorIDEqualFold    *string  `json:"requestorIDEqualFold,omitempty"`
	RequestorIDContainsFold *string  `json:"requestorIDContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "events" edge predicates.
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *InviteWhereInput) AddPredicates(predicates ...predicate.Invite) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the InviteWhereInput filter on the InviteQuery builder.
func (i *InviteWhereInput) Filter(q *InviteQuery) (*InviteQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyInviteWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyInviteWhereInput is returned in case the InviteWhereInput is empty.
var ErrEmptyInviteWhereInput = errors.New("generated: empty predicate InviteWhereInput")

// P returns a predicate for filtering invites.
// An error is returned if the input is empty or invalid.
func (i *InviteWhereInput) P() (predicate.Invite, error) {
	var predicates []predicate.Invite
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, invite.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Invite, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, invite.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Invite, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, invite.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, invite.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, invite.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, invite.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, invite.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, invite.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, invite.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, invite.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, invite.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, invite.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, invite.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, invite.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, invite.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, invite.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, invite.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, invite.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, invite.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, invite.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, invite.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, invite.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, invite.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, invite.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, invite.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, invite.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, invite.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, invite.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, invite.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, invite.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, invite.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, invite.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, invite.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, invite.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, invite.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, invite.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, invite.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, invite.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, invite.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, invite.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, invite.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, invite.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, invite.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, invite.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, invite.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, invite.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, invite.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, invite.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, invite.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, invite.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, invite.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, invite.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, invite.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, invite.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, invite.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, invite.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, invite.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, invite.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, invite.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, invite.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, invite.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, invite.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, invite.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, invite.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, invite.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, invite.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, invite.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, invite.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, invite.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, invite.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, invite.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, invite.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, invite.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, invite.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, invite.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, invite.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, invite.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, invite.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Expires != nil {
		predicates = append(predicates, invite.ExpiresEQ(*i.Expires))
	}
	if i.ExpiresNEQ != nil {
		predicates = append(predicates, invite.ExpiresNEQ(*i.ExpiresNEQ))
	}
	if len(i.ExpiresIn) > 0 {
		predicates = append(predicates, invite.ExpiresIn(i.ExpiresIn...))
	}
	if len(i.ExpiresNotIn) > 0 {
		predicates = append(predicates, invite.ExpiresNotIn(i.ExpiresNotIn...))
	}
	if i.ExpiresGT != nil {
		predicates = append(predicates, invite.ExpiresGT(*i.ExpiresGT))
	}
	if i.ExpiresGTE != nil {
		predicates = append(predicates, invite.ExpiresGTE(*i.ExpiresGTE))
	}
	if i.ExpiresLT != nil {
		predicates = append(predicates, invite.ExpiresLT(*i.ExpiresLT))
	}
	if i.ExpiresLTE != nil {
		predicates = append(predicates, invite.ExpiresLTE(*i.ExpiresLTE))
	}
	if i.ExpiresIsNil {
		predicates = append(predicates, invite.ExpiresIsNil())
	}
	if i.ExpiresNotNil {
		predicates = append(predicates, invite.ExpiresNotNil())
	}
	if i.Recipient != nil {
		predicates = append(predicates, invite.RecipientEQ(*i.Recipient))
	}
	if i.RecipientNEQ != nil {
		predicates = append(predicates, invite.RecipientNEQ(*i.RecipientNEQ))
	}
	if len(i.RecipientIn) > 0 {
		predicates = append(predicates, invite.RecipientIn(i.RecipientIn...))
	}
	if len(i.RecipientNotIn) > 0 {
		predicates = append(predicates, invite.RecipientNotIn(i.RecipientNotIn...))
	}
	if i.RecipientGT != nil {
		predicates = append(predicates, invite.RecipientGT(*i.RecipientGT))
	}
	if i.RecipientGTE != nil {
		predicates = append(predicates, invite.RecipientGTE(*i.RecipientGTE))
	}
	if i.RecipientLT != nil {
		predicates = append(predicates, invite.RecipientLT(*i.RecipientLT))
	}
	if i.RecipientLTE != nil {
		predicates = append(predicates, invite.RecipientLTE(*i.RecipientLTE))
	}
	if i.RecipientContains != nil {
		predicates = append(predicates, invite.RecipientContains(*i.RecipientContains))
	}
	if i.RecipientHasPrefix != nil {
		predicates = append(predicates, invite.RecipientHasPrefix(*i.RecipientHasPrefix))
	}
	if i.RecipientHasSuffix != nil {
		predicates = append(predicates, invite.RecipientHasSuffix(*i.RecipientHasSuffix))
	}
	if i.RecipientEqualFold != nil {
		predicates = append(predicates, invite.RecipientEqualFold(*i.RecipientEqualFold))
	}
	if i.RecipientContainsFold != nil {
		predicates = append(predicates, invite.RecipientContainsFold(*i.RecipientContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, invite.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, invite.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, invite.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, invite.StatusNotIn(i.StatusNotIn...))
	}
	if i.Role != nil {
		predicates = append(predicates, invite.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, invite.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, invite.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, invite.RoleNotIn(i.RoleNotIn...))
	}
	if i.SendAttempts != nil {
		predicates = append(predicates, invite.SendAttemptsEQ(*i.SendAttempts))
	}
	if i.SendAttemptsNEQ != nil {
		predicates = append(predicates, invite.SendAttemptsNEQ(*i.SendAttemptsNEQ))
	}
	if len(i.SendAttemptsIn) > 0 {
		predicates = append(predicates, invite.SendAttemptsIn(i.SendAttemptsIn...))
	}
	if len(i.SendAttemptsNotIn) > 0 {
		predicates = append(predicates, invite.SendAttemptsNotIn(i.SendAttemptsNotIn...))
	}
	if i.SendAttemptsGT != nil {
		predicates = append(predicates, invite.SendAttemptsGT(*i.SendAttemptsGT))
	}
	if i.SendAttemptsGTE != nil {
		predicates = append(predicates, invite.SendAttemptsGTE(*i.SendAttemptsGTE))
	}
	if i.SendAttemptsLT != nil {
		predicates = append(predicates, invite.SendAttemptsLT(*i.SendAttemptsLT))
	}
	if i.SendAttemptsLTE != nil {
		predicates = append(predicates, invite.SendAttemptsLTE(*i.SendAttemptsLTE))
	}
	if i.RequestorID != nil {
		predicates = append(predicates, invite.RequestorIDEQ(*i.RequestorID))
	}
	if i.RequestorIDNEQ != nil {
		predicates = append(predicates, invite.RequestorIDNEQ(*i.RequestorIDNEQ))
	}
	if len(i.RequestorIDIn) > 0 {
		predicates = append(predicates, invite.RequestorIDIn(i.RequestorIDIn...))
	}
	if len(i.RequestorIDNotIn) > 0 {
		predicates = append(predicates, invite.RequestorIDNotIn(i.RequestorIDNotIn...))
	}
	if i.RequestorIDGT != nil {
		predicates = append(predicates, invite.RequestorIDGT(*i.RequestorIDGT))
	}
	if i.RequestorIDGTE != nil {
		predicates = append(predicates, invite.RequestorIDGTE(*i.RequestorIDGTE))
	}
	if i.RequestorIDLT != nil {
		predicates = append(predicates, invite.RequestorIDLT(*i.RequestorIDLT))
	}
	if i.RequestorIDLTE != nil {
		predicates = append(predicates, invite.RequestorIDLTE(*i.RequestorIDLTE))
	}
	if i.RequestorIDContains != nil {
		predicates = append(predicates, invite.RequestorIDContains(*i.RequestorIDContains))
	}
	if i.RequestorIDHasPrefix != nil {
		predicates = append(predicates, invite.RequestorIDHasPrefix(*i.RequestorIDHasPrefix))
	}
	if i.RequestorIDHasSuffix != nil {
		predicates = append(predicates, invite.RequestorIDHasSuffix(*i.RequestorIDHasSuffix))
	}
	if i.RequestorIDIsNil {
		predicates = append(predicates, invite.RequestorIDIsNil())
	}
	if i.RequestorIDNotNil {
		predicates = append(predicates, invite.RequestorIDNotNil())
	}
	if i.RequestorIDEqualFold != nil {
		predicates = append(predicates, invite.RequestorIDEqualFold(*i.RequestorIDEqualFold))
	}
	if i.RequestorIDContainsFold != nil {
		predicates = append(predicates, invite.RequestorIDContainsFold(*i.RequestorIDContainsFold))
	}

	if i.HasOwner != nil {
		p := invite.HasOwner()
		if !*i.HasOwner {
			p = invite.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, invite.HasOwnerWith(with...))
	}
	if i.HasEvents != nil {
		p := invite.HasEvents()
		if !*i.HasEvents {
			p = invite.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventsWith) > 0 {
		with := make([]predicate.Event, 0, len(i.HasEventsWith))
		for _, w := range i.HasEventsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, invite.HasEventsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyInviteWhereInput
	case 1:
		return predicates[0], nil
	default:
		return invite.And(predicates...), nil
	}
}

// JobResultWhereInput represents a where input for filtering JobResult queries.
type JobResultWhereInput struct {
	Predicates []predicate.JobResult  `json:"-"`
	Not        *JobResultWhereInput   `json:"not,omitempty"`
	Or         []*JobResultWhereInput `json:"or,omitempty"`
	And        []*JobResultWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "scheduled_job_id" field predicates.
	ScheduledJobID             *string  `json:"scheduledJobID,omitempty"`
	ScheduledJobIDNEQ          *string  `json:"scheduledJobIDNEQ,omitempty"`
	ScheduledJobIDIn           []string `json:"scheduledJobIDIn,omitempty"`
	ScheduledJobIDNotIn        []string `json:"scheduledJobIDNotIn,omitempty"`
	ScheduledJobIDGT           *string  `json:"scheduledJobIDGT,omitempty"`
	ScheduledJobIDGTE          *string  `json:"scheduledJobIDGTE,omitempty"`
	ScheduledJobIDLT           *string  `json:"scheduledJobIDLT,omitempty"`
	ScheduledJobIDLTE          *string  `json:"scheduledJobIDLTE,omitempty"`
	ScheduledJobIDContains     *string  `json:"scheduledJobIDContains,omitempty"`
	ScheduledJobIDHasPrefix    *string  `json:"scheduledJobIDHasPrefix,omitempty"`
	ScheduledJobIDHasSuffix    *string  `json:"scheduledJobIDHasSuffix,omitempty"`
	ScheduledJobIDEqualFold    *string  `json:"scheduledJobIDEqualFold,omitempty"`
	ScheduledJobIDContainsFold *string  `json:"scheduledJobIDContainsFold,omitempty"`

	// "status" field predicates.
	Status      *enums.JobExecutionStatus  `json:"status,omitempty"`
	StatusNEQ   *enums.JobExecutionStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.JobExecutionStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.JobExecutionStatus `json:"statusNotIn,omitempty"`

	// "exit_code" field predicates.
	ExitCode      *int  `json:"exitCode,omitempty"`
	ExitCodeNEQ   *int  `json:"exitCodeNEQ,omitempty"`
	ExitCodeIn    []int `json:"exitCodeIn,omitempty"`
	ExitCodeNotIn []int `json:"exitCodeNotIn,omitempty"`
	ExitCodeGT    *int  `json:"exitCodeGT,omitempty"`
	ExitCodeGTE   *int  `json:"exitCodeGTE,omitempty"`
	ExitCodeLT    *int  `json:"exitCodeLT,omitempty"`
	ExitCodeLTE   *int  `json:"exitCodeLTE,omitempty"`

	// "finished_at" field predicates.
	FinishedAt      *time.Time  `json:"finishedAt,omitempty"`
	FinishedAtNEQ   *time.Time  `json:"finishedAtNEQ,omitempty"`
	FinishedAtIn    []time.Time `json:"finishedAtIn,omitempty"`
	FinishedAtNotIn []time.Time `json:"finishedAtNotIn,omitempty"`
	FinishedAtGT    *time.Time  `json:"finishedAtGT,omitempty"`
	FinishedAtGTE   *time.Time  `json:"finishedAtGTE,omitempty"`
	FinishedAtLT    *time.Time  `json:"finishedAtLT,omitempty"`
	FinishedAtLTE   *time.Time  `json:"finishedAtLTE,omitempty"`

	// "started_at" field predicates.
	StartedAt      *time.Time  `json:"startedAt,omitempty"`
	StartedAtNEQ   *time.Time  `json:"startedAtNEQ,omitempty"`
	StartedAtIn    []time.Time `json:"startedAtIn,omitempty"`
	StartedAtNotIn []time.Time `json:"startedAtNotIn,omitempty"`
	StartedAtGT    *time.Time  `json:"startedAtGT,omitempty"`
	StartedAtGTE   *time.Time  `json:"startedAtGTE,omitempty"`
	StartedAtLT    *time.Time  `json:"startedAtLT,omitempty"`
	StartedAtLTE   *time.Time  `json:"startedAtLTE,omitempty"`

	// "file_id" field predicates.
	FileID             *string  `json:"fileID,omitempty"`
	FileIDNEQ          *string  `json:"fileIDNEQ,omitempty"`
	FileIDIn           []string `json:"fileIDIn,omitempty"`
	FileIDNotIn        []string `json:"fileIDNotIn,omitempty"`
	FileIDGT           *string  `json:"fileIDGT,omitempty"`
	FileIDGTE          *string  `json:"fileIDGTE,omitempty"`
	FileIDLT           *string  `json:"fileIDLT,omitempty"`
	FileIDLTE          *string  `json:"fileIDLTE,omitempty"`
	FileIDContains     *string  `json:"fileIDContains,omitempty"`
	FileIDHasPrefix    *string  `json:"fileIDHasPrefix,omitempty"`
	FileIDHasSuffix    *string  `json:"fileIDHasSuffix,omitempty"`
	FileIDEqualFold    *string  `json:"fileIDEqualFold,omitempty"`
	FileIDContainsFold *string  `json:"fileIDContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "scheduled_job" edge predicates.
	HasScheduledJob     *bool                            `json:"hasScheduledJob,omitempty"`
	HasScheduledJobWith []*ControlScheduledJobWhereInput `json:"hasScheduledJobWith,omitempty"`

	// "file" edge predicates.
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JobResultWhereInput) AddPredicates(predicates ...predicate.JobResult) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JobResultWhereInput filter on the JobResultQuery builder.
func (i *JobResultWhereInput) Filter(q *JobResultQuery) (*JobResultQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJobResultWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJobResultWhereInput is returned in case the JobResultWhereInput is empty.
var ErrEmptyJobResultWhereInput = errors.New("generated: empty predicate JobResultWhereInput")

// P returns a predicate for filtering jobresults.
// An error is returned if the input is empty or invalid.
func (i *JobResultWhereInput) P() (predicate.JobResult, error) {
	var predicates []predicate.JobResult
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, jobresult.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.JobResult, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, jobresult.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.JobResult, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, jobresult.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, jobresult.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, jobresult.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, jobresult.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, jobresult.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, jobresult.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, jobresult.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, jobresult.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, jobresult.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, jobresult.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, jobresult.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, jobresult.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, jobresult.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, jobresult.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, jobresult.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, jobresult.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, jobresult.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, jobresult.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, jobresult.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, jobresult.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, jobresult.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, jobresult.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, jobresult.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, jobresult.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, jobresult.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, jobresult.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, jobresult.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, jobresult.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, jobresult.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, jobresult.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, jobresult.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, jobresult.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, jobresult.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, jobresult.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, jobresult.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, jobresult.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, jobresult.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, jobresult.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, jobresult.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, jobresult.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, jobresult.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, jobresult.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, jobresult.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, jobresult.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, jobresult.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, jobresult.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, jobresult.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, jobresult.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, jobresult.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, jobresult.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, jobresult.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, jobresult.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, jobresult.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, jobresult.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, jobresult.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, jobresult.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, jobresult.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, jobresult.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, jobresult.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, jobresult.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, jobresult.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, jobresult.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, jobresult.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, jobresult.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, jobresult.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, jobresult.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, jobresult.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, jobresult.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, jobresult.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, jobresult.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, jobresult.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, jobresult.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, jobresult.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, jobresult.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, jobresult.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, jobresult.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.ScheduledJobID != nil {
		predicates = append(predicates, jobresult.ScheduledJobIDEQ(*i.ScheduledJobID))
	}
	if i.ScheduledJobIDNEQ != nil {
		predicates = append(predicates, jobresult.ScheduledJobIDNEQ(*i.ScheduledJobIDNEQ))
	}
	if len(i.ScheduledJobIDIn) > 0 {
		predicates = append(predicates, jobresult.ScheduledJobIDIn(i.ScheduledJobIDIn...))
	}
	if len(i.ScheduledJobIDNotIn) > 0 {
		predicates = append(predicates, jobresult.ScheduledJobIDNotIn(i.ScheduledJobIDNotIn...))
	}
	if i.ScheduledJobIDGT != nil {
		predicates = append(predicates, jobresult.ScheduledJobIDGT(*i.ScheduledJobIDGT))
	}
	if i.ScheduledJobIDGTE != nil {
		predicates = append(predicates, jobresult.ScheduledJobIDGTE(*i.ScheduledJobIDGTE))
	}
	if i.ScheduledJobIDLT != nil {
		predicates = append(predicates, jobresult.ScheduledJobIDLT(*i.ScheduledJobIDLT))
	}
	if i.ScheduledJobIDLTE != nil {
		predicates = append(predicates, jobresult.ScheduledJobIDLTE(*i.ScheduledJobIDLTE))
	}
	if i.ScheduledJobIDContains != nil {
		predicates = append(predicates, jobresult.ScheduledJobIDContains(*i.ScheduledJobIDContains))
	}
	if i.ScheduledJobIDHasPrefix != nil {
		predicates = append(predicates, jobresult.ScheduledJobIDHasPrefix(*i.ScheduledJobIDHasPrefix))
	}
	if i.ScheduledJobIDHasSuffix != nil {
		predicates = append(predicates, jobresult.ScheduledJobIDHasSuffix(*i.ScheduledJobIDHasSuffix))
	}
	if i.ScheduledJobIDEqualFold != nil {
		predicates = append(predicates, jobresult.ScheduledJobIDEqualFold(*i.ScheduledJobIDEqualFold))
	}
	if i.ScheduledJobIDContainsFold != nil {
		predicates = append(predicates, jobresult.ScheduledJobIDContainsFold(*i.ScheduledJobIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, jobresult.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, jobresult.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, jobresult.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, jobresult.StatusNotIn(i.StatusNotIn...))
	}
	if i.ExitCode != nil {
		predicates = append(predicates, jobresult.ExitCodeEQ(*i.ExitCode))
	}
	if i.ExitCodeNEQ != nil {
		predicates = append(predicates, jobresult.ExitCodeNEQ(*i.ExitCodeNEQ))
	}
	if len(i.ExitCodeIn) > 0 {
		predicates = append(predicates, jobresult.ExitCodeIn(i.ExitCodeIn...))
	}
	if len(i.ExitCodeNotIn) > 0 {
		predicates = append(predicates, jobresult.ExitCodeNotIn(i.ExitCodeNotIn...))
	}
	if i.ExitCodeGT != nil {
		predicates = append(predicates, jobresult.ExitCodeGT(*i.ExitCodeGT))
	}
	if i.ExitCodeGTE != nil {
		predicates = append(predicates, jobresult.ExitCodeGTE(*i.ExitCodeGTE))
	}
	if i.ExitCodeLT != nil {
		predicates = append(predicates, jobresult.ExitCodeLT(*i.ExitCodeLT))
	}
	if i.ExitCodeLTE != nil {
		predicates = append(predicates, jobresult.ExitCodeLTE(*i.ExitCodeLTE))
	}
	if i.FinishedAt != nil {
		predicates = append(predicates, jobresult.FinishedAtEQ(*i.FinishedAt))
	}
	if i.FinishedAtNEQ != nil {
		predicates = append(predicates, jobresult.FinishedAtNEQ(*i.FinishedAtNEQ))
	}
	if len(i.FinishedAtIn) > 0 {
		predicates = append(predicates, jobresult.FinishedAtIn(i.FinishedAtIn...))
	}
	if len(i.FinishedAtNotIn) > 0 {
		predicates = append(predicates, jobresult.FinishedAtNotIn(i.FinishedAtNotIn...))
	}
	if i.FinishedAtGT != nil {
		predicates = append(predicates, jobresult.FinishedAtGT(*i.FinishedAtGT))
	}
	if i.FinishedAtGTE != nil {
		predicates = append(predicates, jobresult.FinishedAtGTE(*i.FinishedAtGTE))
	}
	if i.FinishedAtLT != nil {
		predicates = append(predicates, jobresult.FinishedAtLT(*i.FinishedAtLT))
	}
	if i.FinishedAtLTE != nil {
		predicates = append(predicates, jobresult.FinishedAtLTE(*i.FinishedAtLTE))
	}
	if i.StartedAt != nil {
		predicates = append(predicates, jobresult.StartedAtEQ(*i.StartedAt))
	}
	if i.StartedAtNEQ != nil {
		predicates = append(predicates, jobresult.StartedAtNEQ(*i.StartedAtNEQ))
	}
	if len(i.StartedAtIn) > 0 {
		predicates = append(predicates, jobresult.StartedAtIn(i.StartedAtIn...))
	}
	if len(i.StartedAtNotIn) > 0 {
		predicates = append(predicates, jobresult.StartedAtNotIn(i.StartedAtNotIn...))
	}
	if i.StartedAtGT != nil {
		predicates = append(predicates, jobresult.StartedAtGT(*i.StartedAtGT))
	}
	if i.StartedAtGTE != nil {
		predicates = append(predicates, jobresult.StartedAtGTE(*i.StartedAtGTE))
	}
	if i.StartedAtLT != nil {
		predicates = append(predicates, jobresult.StartedAtLT(*i.StartedAtLT))
	}
	if i.StartedAtLTE != nil {
		predicates = append(predicates, jobresult.StartedAtLTE(*i.StartedAtLTE))
	}
	if i.FileID != nil {
		predicates = append(predicates, jobresult.FileIDEQ(*i.FileID))
	}
	if i.FileIDNEQ != nil {
		predicates = append(predicates, jobresult.FileIDNEQ(*i.FileIDNEQ))
	}
	if len(i.FileIDIn) > 0 {
		predicates = append(predicates, jobresult.FileIDIn(i.FileIDIn...))
	}
	if len(i.FileIDNotIn) > 0 {
		predicates = append(predicates, jobresult.FileIDNotIn(i.FileIDNotIn...))
	}
	if i.FileIDGT != nil {
		predicates = append(predicates, jobresult.FileIDGT(*i.FileIDGT))
	}
	if i.FileIDGTE != nil {
		predicates = append(predicates, jobresult.FileIDGTE(*i.FileIDGTE))
	}
	if i.FileIDLT != nil {
		predicates = append(predicates, jobresult.FileIDLT(*i.FileIDLT))
	}
	if i.FileIDLTE != nil {
		predicates = append(predicates, jobresult.FileIDLTE(*i.FileIDLTE))
	}
	if i.FileIDContains != nil {
		predicates = append(predicates, jobresult.FileIDContains(*i.FileIDContains))
	}
	if i.FileIDHasPrefix != nil {
		predicates = append(predicates, jobresult.FileIDHasPrefix(*i.FileIDHasPrefix))
	}
	if i.FileIDHasSuffix != nil {
		predicates = append(predicates, jobresult.FileIDHasSuffix(*i.FileIDHasSuffix))
	}
	if i.FileIDEqualFold != nil {
		predicates = append(predicates, jobresult.FileIDEqualFold(*i.FileIDEqualFold))
	}
	if i.FileIDContainsFold != nil {
		predicates = append(predicates, jobresult.FileIDContainsFold(*i.FileIDContainsFold))
	}

	if i.HasOwner != nil {
		p := jobresult.HasOwner()
		if !*i.HasOwner {
			p = jobresult.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobresult.HasOwnerWith(with...))
	}
	if i.HasScheduledJob != nil {
		p := jobresult.HasScheduledJob()
		if !*i.HasScheduledJob {
			p = jobresult.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScheduledJobWith) > 0 {
		with := make([]predicate.ControlScheduledJob, 0, len(i.HasScheduledJobWith))
		for _, w := range i.HasScheduledJobWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasScheduledJobWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobresult.HasScheduledJobWith(with...))
	}
	if i.HasFile != nil {
		p := jobresult.HasFile()
		if !*i.HasFile {
			p = jobresult.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFileWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFileWith))
		for _, w := range i.HasFileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobresult.HasFileWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJobResultWhereInput
	case 1:
		return predicates[0], nil
	default:
		return jobresult.And(predicates...), nil
	}
}

// JobRunnerWhereInput represents a where input for filtering JobRunner queries.
type JobRunnerWhereInput struct {
	Predicates []predicate.JobRunner  `json:"-"`
	Not        *JobRunnerWhereInput   `json:"not,omitempty"`
	Or         []*JobRunnerWhereInput `json:"or,omitempty"`
	And        []*JobRunnerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "system_owned" field predicates.
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNEQ    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  bool  `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil bool  `json:"systemOwnedNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status      *enums.JobRunnerStatus  `json:"status,omitempty"`
	StatusNEQ   *enums.JobRunnerStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.JobRunnerStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.JobRunnerStatus `json:"statusNotIn,omitempty"`

	// "ip_address" field predicates.
	IPAddress             *string  `json:"ipAddress,omitempty"`
	IPAddressNEQ          *string  `json:"ipAddressNEQ,omitempty"`
	IPAddressIn           []string `json:"ipAddressIn,omitempty"`
	IPAddressNotIn        []string `json:"ipAddressNotIn,omitempty"`
	IPAddressGT           *string  `json:"ipAddressGT,omitempty"`
	IPAddressGTE          *string  `json:"ipAddressGTE,omitempty"`
	IPAddressLT           *string  `json:"ipAddressLT,omitempty"`
	IPAddressLTE          *string  `json:"ipAddressLTE,omitempty"`
	IPAddressContains     *string  `json:"ipAddressContains,omitempty"`
	IPAddressHasPrefix    *string  `json:"ipAddressHasPrefix,omitempty"`
	IPAddressHasSuffix    *string  `json:"ipAddressHasSuffix,omitempty"`
	IPAddressEqualFold    *string  `json:"ipAddressEqualFold,omitempty"`
	IPAddressContainsFold *string  `json:"ipAddressContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "job_runner_tokens" edge predicates.
	HasJobRunnerTokens     *bool                       `json:"hasJobRunnerTokens,omitempty"`
	HasJobRunnerTokensWith []*JobRunnerTokenWhereInput `json:"hasJobRunnerTokensWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JobRunnerWhereInput) AddPredicates(predicates ...predicate.JobRunner) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JobRunnerWhereInput filter on the JobRunnerQuery builder.
func (i *JobRunnerWhereInput) Filter(q *JobRunnerQuery) (*JobRunnerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJobRunnerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJobRunnerWhereInput is returned in case the JobRunnerWhereInput is empty.
var ErrEmptyJobRunnerWhereInput = errors.New("generated: empty predicate JobRunnerWhereInput")

// P returns a predicate for filtering jobrunners.
// An error is returned if the input is empty or invalid.
func (i *JobRunnerWhereInput) P() (predicate.JobRunner, error) {
	var predicates []predicate.JobRunner
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, jobrunner.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.JobRunner, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, jobrunner.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.JobRunner, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, jobrunner.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, jobrunner.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, jobrunner.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, jobrunner.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, jobrunner.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, jobrunner.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, jobrunner.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, jobrunner.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, jobrunner.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, jobrunner.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, jobrunner.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, jobrunner.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, jobrunner.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, jobrunner.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, jobrunner.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, jobrunner.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, jobrunner.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, jobrunner.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, jobrunner.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, jobrunner.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, jobrunner.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, jobrunner.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, jobrunner.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, jobrunner.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, jobrunner.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, jobrunner.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, jobrunner.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, jobrunner.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, jobrunner.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, jobrunner.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, jobrunner.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, jobrunner.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, jobrunner.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, jobrunner.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, jobrunner.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, jobrunner.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, jobrunner.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, jobrunner.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, jobrunner.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, jobrunner.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, jobrunner.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, jobrunner.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, jobrunner.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, jobrunner.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, jobrunner.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, jobrunner.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, jobrunner.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, jobrunner.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, jobrunner.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, jobrunner.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, jobrunner.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, jobrunner.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, jobrunner.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, jobrunner.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, jobrunner.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, jobrunner.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, jobrunner.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, jobrunner.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, jobrunner.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, jobrunner.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, jobrunner.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, jobrunner.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, jobrunner.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, jobrunner.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, jobrunner.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, jobrunner.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, jobrunner.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, jobrunner.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, jobrunner.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, jobrunner.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, jobrunner.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, jobrunner.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, jobrunner.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, jobrunner.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, jobrunner.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, jobrunner.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, jobrunner.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, jobrunner.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, jobrunner.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, jobrunner.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, jobrunner.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, jobrunner.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, jobrunner.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, jobrunner.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, jobrunner.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, jobrunner.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, jobrunner.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, jobrunner.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, jobrunner.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.SystemOwned != nil {
		predicates = append(predicates, jobrunner.SystemOwnedEQ(*i.SystemOwned))
	}
	if i.SystemOwnedNEQ != nil {
		predicates = append(predicates, jobrunner.SystemOwnedNEQ(*i.SystemOwnedNEQ))
	}
	if i.SystemOwnedIsNil {
		predicates = append(predicates, jobrunner.SystemOwnedIsNil())
	}
	if i.SystemOwnedNotNil {
		predicates = append(predicates, jobrunner.SystemOwnedNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, jobrunner.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, jobrunner.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, jobrunner.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, jobrunner.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, jobrunner.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, jobrunner.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, jobrunner.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, jobrunner.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, jobrunner.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, jobrunner.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, jobrunner.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, jobrunner.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, jobrunner.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, jobrunner.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, jobrunner.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, jobrunner.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, jobrunner.StatusNotIn(i.StatusNotIn...))
	}
	if i.IPAddress != nil {
		predicates = append(predicates, jobrunner.IPAddressEQ(*i.IPAddress))
	}
	if i.IPAddressNEQ != nil {
		predicates = append(predicates, jobrunner.IPAddressNEQ(*i.IPAddressNEQ))
	}
	if len(i.IPAddressIn) > 0 {
		predicates = append(predicates, jobrunner.IPAddressIn(i.IPAddressIn...))
	}
	if len(i.IPAddressNotIn) > 0 {
		predicates = append(predicates, jobrunner.IPAddressNotIn(i.IPAddressNotIn...))
	}
	if i.IPAddressGT != nil {
		predicates = append(predicates, jobrunner.IPAddressGT(*i.IPAddressGT))
	}
	if i.IPAddressGTE != nil {
		predicates = append(predicates, jobrunner.IPAddressGTE(*i.IPAddressGTE))
	}
	if i.IPAddressLT != nil {
		predicates = append(predicates, jobrunner.IPAddressLT(*i.IPAddressLT))
	}
	if i.IPAddressLTE != nil {
		predicates = append(predicates, jobrunner.IPAddressLTE(*i.IPAddressLTE))
	}
	if i.IPAddressContains != nil {
		predicates = append(predicates, jobrunner.IPAddressContains(*i.IPAddressContains))
	}
	if i.IPAddressHasPrefix != nil {
		predicates = append(predicates, jobrunner.IPAddressHasPrefix(*i.IPAddressHasPrefix))
	}
	if i.IPAddressHasSuffix != nil {
		predicates = append(predicates, jobrunner.IPAddressHasSuffix(*i.IPAddressHasSuffix))
	}
	if i.IPAddressEqualFold != nil {
		predicates = append(predicates, jobrunner.IPAddressEqualFold(*i.IPAddressEqualFold))
	}
	if i.IPAddressContainsFold != nil {
		predicates = append(predicates, jobrunner.IPAddressContainsFold(*i.IPAddressContainsFold))
	}

	if i.HasOwner != nil {
		p := jobrunner.HasOwner()
		if !*i.HasOwner {
			p = jobrunner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobrunner.HasOwnerWith(with...))
	}
	if i.HasJobRunnerTokens != nil {
		p := jobrunner.HasJobRunnerTokens()
		if !*i.HasJobRunnerTokens {
			p = jobrunner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobRunnerTokensWith) > 0 {
		with := make([]predicate.JobRunnerToken, 0, len(i.HasJobRunnerTokensWith))
		for _, w := range i.HasJobRunnerTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobRunnerTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobrunner.HasJobRunnerTokensWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJobRunnerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return jobrunner.And(predicates...), nil
	}
}

// JobRunnerRegistrationTokenWhereInput represents a where input for filtering JobRunnerRegistrationToken queries.
type JobRunnerRegistrationTokenWhereInput struct {
	Predicates []predicate.JobRunnerRegistrationToken  `json:"-"`
	Not        *JobRunnerRegistrationTokenWhereInput   `json:"not,omitempty"`
	Or         []*JobRunnerRegistrationTokenWhereInput `json:"or,omitempty"`
	And        []*JobRunnerRegistrationTokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "last_used_at" field predicates.
	LastUsedAt       *time.Time  `json:"lastUsedAt,omitempty"`
	LastUsedAtNEQ    *time.Time  `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGT     *time.Time  `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGTE    *time.Time  `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLT     *time.Time  `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLTE    *time.Time  `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil bool        `json:"lastUsedAtNotNil,omitempty"`

	// "job_runner_id" field predicates.
	JobRunnerID             *string  `json:"jobRunnerID,omitempty"`
	JobRunnerIDNEQ          *string  `json:"jobRunnerIDNEQ,omitempty"`
	JobRunnerIDIn           []string `json:"jobRunnerIDIn,omitempty"`
	JobRunnerIDNotIn        []string `json:"jobRunnerIDNotIn,omitempty"`
	JobRunnerIDGT           *string  `json:"jobRunnerIDGT,omitempty"`
	JobRunnerIDGTE          *string  `json:"jobRunnerIDGTE,omitempty"`
	JobRunnerIDLT           *string  `json:"jobRunnerIDLT,omitempty"`
	JobRunnerIDLTE          *string  `json:"jobRunnerIDLTE,omitempty"`
	JobRunnerIDContains     *string  `json:"jobRunnerIDContains,omitempty"`
	JobRunnerIDHasPrefix    *string  `json:"jobRunnerIDHasPrefix,omitempty"`
	JobRunnerIDHasSuffix    *string  `json:"jobRunnerIDHasSuffix,omitempty"`
	JobRunnerIDIsNil        bool     `json:"jobRunnerIDIsNil,omitempty"`
	JobRunnerIDNotNil       bool     `json:"jobRunnerIDNotNil,omitempty"`
	JobRunnerIDEqualFold    *string  `json:"jobRunnerIDEqualFold,omitempty"`
	JobRunnerIDContainsFold *string  `json:"jobRunnerIDContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "job_runner" edge predicates.
	HasJobRunner     *bool                  `json:"hasJobRunner,omitempty"`
	HasJobRunnerWith []*JobRunnerWhereInput `json:"hasJobRunnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JobRunnerRegistrationTokenWhereInput) AddPredicates(predicates ...predicate.JobRunnerRegistrationToken) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JobRunnerRegistrationTokenWhereInput filter on the JobRunnerRegistrationTokenQuery builder.
func (i *JobRunnerRegistrationTokenWhereInput) Filter(q *JobRunnerRegistrationTokenQuery) (*JobRunnerRegistrationTokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJobRunnerRegistrationTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJobRunnerRegistrationTokenWhereInput is returned in case the JobRunnerRegistrationTokenWhereInput is empty.
var ErrEmptyJobRunnerRegistrationTokenWhereInput = errors.New("generated: empty predicate JobRunnerRegistrationTokenWhereInput")

// P returns a predicate for filtering jobrunnerregistrationtokens.
// An error is returned if the input is empty or invalid.
func (i *JobRunnerRegistrationTokenWhereInput) P() (predicate.JobRunnerRegistrationToken, error) {
	var predicates []predicate.JobRunnerRegistrationToken
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, jobrunnerregistrationtoken.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.JobRunnerRegistrationToken, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, jobrunnerregistrationtoken.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.JobRunnerRegistrationToken, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, jobrunnerregistrationtoken.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, jobrunnerregistrationtoken.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, jobrunnerregistrationtoken.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.LastUsedAt != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.LastUsedAtEQ(*i.LastUsedAt))
	}
	if i.LastUsedAtNEQ != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.LastUsedAtNEQ(*i.LastUsedAtNEQ))
	}
	if len(i.LastUsedAtIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.LastUsedAtIn(i.LastUsedAtIn...))
	}
	if len(i.LastUsedAtNotIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.LastUsedAtNotIn(i.LastUsedAtNotIn...))
	}
	if i.LastUsedAtGT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.LastUsedAtGT(*i.LastUsedAtGT))
	}
	if i.LastUsedAtGTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.LastUsedAtGTE(*i.LastUsedAtGTE))
	}
	if i.LastUsedAtLT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.LastUsedAtLT(*i.LastUsedAtLT))
	}
	if i.LastUsedAtLTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.LastUsedAtLTE(*i.LastUsedAtLTE))
	}
	if i.LastUsedAtIsNil {
		predicates = append(predicates, jobrunnerregistrationtoken.LastUsedAtIsNil())
	}
	if i.LastUsedAtNotNil {
		predicates = append(predicates, jobrunnerregistrationtoken.LastUsedAtNotNil())
	}
	if i.JobRunnerID != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.JobRunnerIDEQ(*i.JobRunnerID))
	}
	if i.JobRunnerIDNEQ != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.JobRunnerIDNEQ(*i.JobRunnerIDNEQ))
	}
	if len(i.JobRunnerIDIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.JobRunnerIDIn(i.JobRunnerIDIn...))
	}
	if len(i.JobRunnerIDNotIn) > 0 {
		predicates = append(predicates, jobrunnerregistrationtoken.JobRunnerIDNotIn(i.JobRunnerIDNotIn...))
	}
	if i.JobRunnerIDGT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.JobRunnerIDGT(*i.JobRunnerIDGT))
	}
	if i.JobRunnerIDGTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.JobRunnerIDGTE(*i.JobRunnerIDGTE))
	}
	if i.JobRunnerIDLT != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.JobRunnerIDLT(*i.JobRunnerIDLT))
	}
	if i.JobRunnerIDLTE != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.JobRunnerIDLTE(*i.JobRunnerIDLTE))
	}
	if i.JobRunnerIDContains != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.JobRunnerIDContains(*i.JobRunnerIDContains))
	}
	if i.JobRunnerIDHasPrefix != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.JobRunnerIDHasPrefix(*i.JobRunnerIDHasPrefix))
	}
	if i.JobRunnerIDHasSuffix != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.JobRunnerIDHasSuffix(*i.JobRunnerIDHasSuffix))
	}
	if i.JobRunnerIDIsNil {
		predicates = append(predicates, jobrunnerregistrationtoken.JobRunnerIDIsNil())
	}
	if i.JobRunnerIDNotNil {
		predicates = append(predicates, jobrunnerregistrationtoken.JobRunnerIDNotNil())
	}
	if i.JobRunnerIDEqualFold != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.JobRunnerIDEqualFold(*i.JobRunnerIDEqualFold))
	}
	if i.JobRunnerIDContainsFold != nil {
		predicates = append(predicates, jobrunnerregistrationtoken.JobRunnerIDContainsFold(*i.JobRunnerIDContainsFold))
	}

	if i.HasOwner != nil {
		p := jobrunnerregistrationtoken.HasOwner()
		if !*i.HasOwner {
			p = jobrunnerregistrationtoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobrunnerregistrationtoken.HasOwnerWith(with...))
	}
	if i.HasJobRunner != nil {
		p := jobrunnerregistrationtoken.HasJobRunner()
		if !*i.HasJobRunner {
			p = jobrunnerregistrationtoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobRunnerWith) > 0 {
		with := make([]predicate.JobRunner, 0, len(i.HasJobRunnerWith))
		for _, w := range i.HasJobRunnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobRunnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobrunnerregistrationtoken.HasJobRunnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJobRunnerRegistrationTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return jobrunnerregistrationtoken.And(predicates...), nil
	}
}

// JobRunnerTokenWhereInput represents a where input for filtering JobRunnerToken queries.
type JobRunnerTokenWhereInput struct {
	Predicates []predicate.JobRunnerToken  `json:"-"`
	Not        *JobRunnerTokenWhereInput   `json:"not,omitempty"`
	Or         []*JobRunnerTokenWhereInput `json:"or,omitempty"`
	And        []*JobRunnerTokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "expires_at" field predicates.
	ExpiresAt       *time.Time  `json:"expiresAt,omitempty"`
	ExpiresAtNEQ    *time.Time  `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGT     *time.Time  `json:"expiresAtGT,omitempty"`
	ExpiresAtGTE    *time.Time  `json:"expiresAtGTE,omitempty"`
	ExpiresAtLT     *time.Time  `json:"expiresAtLT,omitempty"`
	ExpiresAtLTE    *time.Time  `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil bool        `json:"expiresAtNotNil,omitempty"`

	// "last_used_at" field predicates.
	LastUsedAt       *time.Time  `json:"lastUsedAt,omitempty"`
	LastUsedAtNEQ    *time.Time  `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGT     *time.Time  `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGTE    *time.Time  `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLT     *time.Time  `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLTE    *time.Time  `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil bool        `json:"lastUsedAtNotNil,omitempty"`

	// "is_active" field predicates.
	IsActive       *bool `json:"isActive,omitempty"`
	IsActiveNEQ    *bool `json:"isActiveNEQ,omitempty"`
	IsActiveIsNil  bool  `json:"isActiveIsNil,omitempty"`
	IsActiveNotNil bool  `json:"isActiveNotNil,omitempty"`

	// "revoked_reason" field predicates.
	RevokedReason             *string  `json:"revokedReason,omitempty"`
	RevokedReasonNEQ          *string  `json:"revokedReasonNEQ,omitempty"`
	RevokedReasonIn           []string `json:"revokedReasonIn,omitempty"`
	RevokedReasonNotIn        []string `json:"revokedReasonNotIn,omitempty"`
	RevokedReasonGT           *string  `json:"revokedReasonGT,omitempty"`
	RevokedReasonGTE          *string  `json:"revokedReasonGTE,omitempty"`
	RevokedReasonLT           *string  `json:"revokedReasonLT,omitempty"`
	RevokedReasonLTE          *string  `json:"revokedReasonLTE,omitempty"`
	RevokedReasonContains     *string  `json:"revokedReasonContains,omitempty"`
	RevokedReasonHasPrefix    *string  `json:"revokedReasonHasPrefix,omitempty"`
	RevokedReasonHasSuffix    *string  `json:"revokedReasonHasSuffix,omitempty"`
	RevokedReasonIsNil        bool     `json:"revokedReasonIsNil,omitempty"`
	RevokedReasonNotNil       bool     `json:"revokedReasonNotNil,omitempty"`
	RevokedReasonEqualFold    *string  `json:"revokedReasonEqualFold,omitempty"`
	RevokedReasonContainsFold *string  `json:"revokedReasonContainsFold,omitempty"`

	// "revoked_by" field predicates.
	RevokedBy             *string  `json:"revokedBy,omitempty"`
	RevokedByNEQ          *string  `json:"revokedByNEQ,omitempty"`
	RevokedByIn           []string `json:"revokedByIn,omitempty"`
	RevokedByNotIn        []string `json:"revokedByNotIn,omitempty"`
	RevokedByGT           *string  `json:"revokedByGT,omitempty"`
	RevokedByGTE          *string  `json:"revokedByGTE,omitempty"`
	RevokedByLT           *string  `json:"revokedByLT,omitempty"`
	RevokedByLTE          *string  `json:"revokedByLTE,omitempty"`
	RevokedByContains     *string  `json:"revokedByContains,omitempty"`
	RevokedByHasPrefix    *string  `json:"revokedByHasPrefix,omitempty"`
	RevokedByHasSuffix    *string  `json:"revokedByHasSuffix,omitempty"`
	RevokedByIsNil        bool     `json:"revokedByIsNil,omitempty"`
	RevokedByNotNil       bool     `json:"revokedByNotNil,omitempty"`
	RevokedByEqualFold    *string  `json:"revokedByEqualFold,omitempty"`
	RevokedByContainsFold *string  `json:"revokedByContainsFold,omitempty"`

	// "revoked_at" field predicates.
	RevokedAt       *time.Time  `json:"revokedAt,omitempty"`
	RevokedAtNEQ    *time.Time  `json:"revokedAtNEQ,omitempty"`
	RevokedAtIn     []time.Time `json:"revokedAtIn,omitempty"`
	RevokedAtNotIn  []time.Time `json:"revokedAtNotIn,omitempty"`
	RevokedAtGT     *time.Time  `json:"revokedAtGT,omitempty"`
	RevokedAtGTE    *time.Time  `json:"revokedAtGTE,omitempty"`
	RevokedAtLT     *time.Time  `json:"revokedAtLT,omitempty"`
	RevokedAtLTE    *time.Time  `json:"revokedAtLTE,omitempty"`
	RevokedAtIsNil  bool        `json:"revokedAtIsNil,omitempty"`
	RevokedAtNotNil bool        `json:"revokedAtNotNil,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "job_runners" edge predicates.
	HasJobRunners     *bool                  `json:"hasJobRunners,omitempty"`
	HasJobRunnersWith []*JobRunnerWhereInput `json:"hasJobRunnersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JobRunnerTokenWhereInput) AddPredicates(predicates ...predicate.JobRunnerToken) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JobRunnerTokenWhereInput filter on the JobRunnerTokenQuery builder.
func (i *JobRunnerTokenWhereInput) Filter(q *JobRunnerTokenQuery) (*JobRunnerTokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJobRunnerTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJobRunnerTokenWhereInput is returned in case the JobRunnerTokenWhereInput is empty.
var ErrEmptyJobRunnerTokenWhereInput = errors.New("generated: empty predicate JobRunnerTokenWhereInput")

// P returns a predicate for filtering jobrunnertokens.
// An error is returned if the input is empty or invalid.
func (i *JobRunnerTokenWhereInput) P() (predicate.JobRunnerToken, error) {
	var predicates []predicate.JobRunnerToken
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, jobrunnertoken.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.JobRunnerToken, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, jobrunnertoken.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.JobRunnerToken, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, jobrunnertoken.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, jobrunnertoken.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, jobrunnertoken.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, jobrunnertoken.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, jobrunnertoken.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, jobrunnertoken.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, jobrunnertoken.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, jobrunnertoken.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, jobrunnertoken.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, jobrunnertoken.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, jobrunnertoken.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, jobrunnertoken.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, jobrunnertoken.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, jobrunnertoken.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, jobrunnertoken.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, jobrunnertoken.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, jobrunnertoken.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, jobrunnertoken.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, jobrunnertoken.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, jobrunnertoken.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, jobrunnertoken.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, jobrunnertoken.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, jobrunnertoken.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, jobrunnertoken.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, jobrunnertoken.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, jobrunnertoken.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, jobrunnertoken.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, jobrunnertoken.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, jobrunnertoken.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, jobrunnertoken.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, jobrunnertoken.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, jobrunnertoken.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, jobrunnertoken.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, jobrunnertoken.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, jobrunnertoken.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, jobrunnertoken.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, jobrunnertoken.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, jobrunnertoken.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, jobrunnertoken.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, jobrunnertoken.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, jobrunnertoken.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, jobrunnertoken.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, jobrunnertoken.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, jobrunnertoken.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, jobrunnertoken.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, jobrunnertoken.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, jobrunnertoken.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, jobrunnertoken.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, jobrunnertoken.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, jobrunnertoken.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, jobrunnertoken.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, jobrunnertoken.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, jobrunnertoken.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, jobrunnertoken.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, jobrunnertoken.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, jobrunnertoken.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, jobrunnertoken.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, jobrunnertoken.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, jobrunnertoken.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, jobrunnertoken.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.ExpiresAt != nil {
		predicates = append(predicates, jobrunnertoken.ExpiresAtEQ(*i.ExpiresAt))
	}
	if i.ExpiresAtNEQ != nil {
		predicates = append(predicates, jobrunnertoken.ExpiresAtNEQ(*i.ExpiresAtNEQ))
	}
	if len(i.ExpiresAtIn) > 0 {
		predicates = append(predicates, jobrunnertoken.ExpiresAtIn(i.ExpiresAtIn...))
	}
	if len(i.ExpiresAtNotIn) > 0 {
		predicates = append(predicates, jobrunnertoken.ExpiresAtNotIn(i.ExpiresAtNotIn...))
	}
	if i.ExpiresAtGT != nil {
		predicates = append(predicates, jobrunnertoken.ExpiresAtGT(*i.ExpiresAtGT))
	}
	if i.ExpiresAtGTE != nil {
		predicates = append(predicates, jobrunnertoken.ExpiresAtGTE(*i.ExpiresAtGTE))
	}
	if i.ExpiresAtLT != nil {
		predicates = append(predicates, jobrunnertoken.ExpiresAtLT(*i.ExpiresAtLT))
	}
	if i.ExpiresAtLTE != nil {
		predicates = append(predicates, jobrunnertoken.ExpiresAtLTE(*i.ExpiresAtLTE))
	}
	if i.ExpiresAtIsNil {
		predicates = append(predicates, jobrunnertoken.ExpiresAtIsNil())
	}
	if i.ExpiresAtNotNil {
		predicates = append(predicates, jobrunnertoken.ExpiresAtNotNil())
	}
	if i.LastUsedAt != nil {
		predicates = append(predicates, jobrunnertoken.LastUsedAtEQ(*i.LastUsedAt))
	}
	if i.LastUsedAtNEQ != nil {
		predicates = append(predicates, jobrunnertoken.LastUsedAtNEQ(*i.LastUsedAtNEQ))
	}
	if len(i.LastUsedAtIn) > 0 {
		predicates = append(predicates, jobrunnertoken.LastUsedAtIn(i.LastUsedAtIn...))
	}
	if len(i.LastUsedAtNotIn) > 0 {
		predicates = append(predicates, jobrunnertoken.LastUsedAtNotIn(i.LastUsedAtNotIn...))
	}
	if i.LastUsedAtGT != nil {
		predicates = append(predicates, jobrunnertoken.LastUsedAtGT(*i.LastUsedAtGT))
	}
	if i.LastUsedAtGTE != nil {
		predicates = append(predicates, jobrunnertoken.LastUsedAtGTE(*i.LastUsedAtGTE))
	}
	if i.LastUsedAtLT != nil {
		predicates = append(predicates, jobrunnertoken.LastUsedAtLT(*i.LastUsedAtLT))
	}
	if i.LastUsedAtLTE != nil {
		predicates = append(predicates, jobrunnertoken.LastUsedAtLTE(*i.LastUsedAtLTE))
	}
	if i.LastUsedAtIsNil {
		predicates = append(predicates, jobrunnertoken.LastUsedAtIsNil())
	}
	if i.LastUsedAtNotNil {
		predicates = append(predicates, jobrunnertoken.LastUsedAtNotNil())
	}
	if i.IsActive != nil {
		predicates = append(predicates, jobrunnertoken.IsActiveEQ(*i.IsActive))
	}
	if i.IsActiveNEQ != nil {
		predicates = append(predicates, jobrunnertoken.IsActiveNEQ(*i.IsActiveNEQ))
	}
	if i.IsActiveIsNil {
		predicates = append(predicates, jobrunnertoken.IsActiveIsNil())
	}
	if i.IsActiveNotNil {
		predicates = append(predicates, jobrunnertoken.IsActiveNotNil())
	}
	if i.RevokedReason != nil {
		predicates = append(predicates, jobrunnertoken.RevokedReasonEQ(*i.RevokedReason))
	}
	if i.RevokedReasonNEQ != nil {
		predicates = append(predicates, jobrunnertoken.RevokedReasonNEQ(*i.RevokedReasonNEQ))
	}
	if len(i.RevokedReasonIn) > 0 {
		predicates = append(predicates, jobrunnertoken.RevokedReasonIn(i.RevokedReasonIn...))
	}
	if len(i.RevokedReasonNotIn) > 0 {
		predicates = append(predicates, jobrunnertoken.RevokedReasonNotIn(i.RevokedReasonNotIn...))
	}
	if i.RevokedReasonGT != nil {
		predicates = append(predicates, jobrunnertoken.RevokedReasonGT(*i.RevokedReasonGT))
	}
	if i.RevokedReasonGTE != nil {
		predicates = append(predicates, jobrunnertoken.RevokedReasonGTE(*i.RevokedReasonGTE))
	}
	if i.RevokedReasonLT != nil {
		predicates = append(predicates, jobrunnertoken.RevokedReasonLT(*i.RevokedReasonLT))
	}
	if i.RevokedReasonLTE != nil {
		predicates = append(predicates, jobrunnertoken.RevokedReasonLTE(*i.RevokedReasonLTE))
	}
	if i.RevokedReasonContains != nil {
		predicates = append(predicates, jobrunnertoken.RevokedReasonContains(*i.RevokedReasonContains))
	}
	if i.RevokedReasonHasPrefix != nil {
		predicates = append(predicates, jobrunnertoken.RevokedReasonHasPrefix(*i.RevokedReasonHasPrefix))
	}
	if i.RevokedReasonHasSuffix != nil {
		predicates = append(predicates, jobrunnertoken.RevokedReasonHasSuffix(*i.RevokedReasonHasSuffix))
	}
	if i.RevokedReasonIsNil {
		predicates = append(predicates, jobrunnertoken.RevokedReasonIsNil())
	}
	if i.RevokedReasonNotNil {
		predicates = append(predicates, jobrunnertoken.RevokedReasonNotNil())
	}
	if i.RevokedReasonEqualFold != nil {
		predicates = append(predicates, jobrunnertoken.RevokedReasonEqualFold(*i.RevokedReasonEqualFold))
	}
	if i.RevokedReasonContainsFold != nil {
		predicates = append(predicates, jobrunnertoken.RevokedReasonContainsFold(*i.RevokedReasonContainsFold))
	}
	if i.RevokedBy != nil {
		predicates = append(predicates, jobrunnertoken.RevokedByEQ(*i.RevokedBy))
	}
	if i.RevokedByNEQ != nil {
		predicates = append(predicates, jobrunnertoken.RevokedByNEQ(*i.RevokedByNEQ))
	}
	if len(i.RevokedByIn) > 0 {
		predicates = append(predicates, jobrunnertoken.RevokedByIn(i.RevokedByIn...))
	}
	if len(i.RevokedByNotIn) > 0 {
		predicates = append(predicates, jobrunnertoken.RevokedByNotIn(i.RevokedByNotIn...))
	}
	if i.RevokedByGT != nil {
		predicates = append(predicates, jobrunnertoken.RevokedByGT(*i.RevokedByGT))
	}
	if i.RevokedByGTE != nil {
		predicates = append(predicates, jobrunnertoken.RevokedByGTE(*i.RevokedByGTE))
	}
	if i.RevokedByLT != nil {
		predicates = append(predicates, jobrunnertoken.RevokedByLT(*i.RevokedByLT))
	}
	if i.RevokedByLTE != nil {
		predicates = append(predicates, jobrunnertoken.RevokedByLTE(*i.RevokedByLTE))
	}
	if i.RevokedByContains != nil {
		predicates = append(predicates, jobrunnertoken.RevokedByContains(*i.RevokedByContains))
	}
	if i.RevokedByHasPrefix != nil {
		predicates = append(predicates, jobrunnertoken.RevokedByHasPrefix(*i.RevokedByHasPrefix))
	}
	if i.RevokedByHasSuffix != nil {
		predicates = append(predicates, jobrunnertoken.RevokedByHasSuffix(*i.RevokedByHasSuffix))
	}
	if i.RevokedByIsNil {
		predicates = append(predicates, jobrunnertoken.RevokedByIsNil())
	}
	if i.RevokedByNotNil {
		predicates = append(predicates, jobrunnertoken.RevokedByNotNil())
	}
	if i.RevokedByEqualFold != nil {
		predicates = append(predicates, jobrunnertoken.RevokedByEqualFold(*i.RevokedByEqualFold))
	}
	if i.RevokedByContainsFold != nil {
		predicates = append(predicates, jobrunnertoken.RevokedByContainsFold(*i.RevokedByContainsFold))
	}
	if i.RevokedAt != nil {
		predicates = append(predicates, jobrunnertoken.RevokedAtEQ(*i.RevokedAt))
	}
	if i.RevokedAtNEQ != nil {
		predicates = append(predicates, jobrunnertoken.RevokedAtNEQ(*i.RevokedAtNEQ))
	}
	if len(i.RevokedAtIn) > 0 {
		predicates = append(predicates, jobrunnertoken.RevokedAtIn(i.RevokedAtIn...))
	}
	if len(i.RevokedAtNotIn) > 0 {
		predicates = append(predicates, jobrunnertoken.RevokedAtNotIn(i.RevokedAtNotIn...))
	}
	if i.RevokedAtGT != nil {
		predicates = append(predicates, jobrunnertoken.RevokedAtGT(*i.RevokedAtGT))
	}
	if i.RevokedAtGTE != nil {
		predicates = append(predicates, jobrunnertoken.RevokedAtGTE(*i.RevokedAtGTE))
	}
	if i.RevokedAtLT != nil {
		predicates = append(predicates, jobrunnertoken.RevokedAtLT(*i.RevokedAtLT))
	}
	if i.RevokedAtLTE != nil {
		predicates = append(predicates, jobrunnertoken.RevokedAtLTE(*i.RevokedAtLTE))
	}
	if i.RevokedAtIsNil {
		predicates = append(predicates, jobrunnertoken.RevokedAtIsNil())
	}
	if i.RevokedAtNotNil {
		predicates = append(predicates, jobrunnertoken.RevokedAtNotNil())
	}

	if i.HasOwner != nil {
		p := jobrunnertoken.HasOwner()
		if !*i.HasOwner {
			p = jobrunnertoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobrunnertoken.HasOwnerWith(with...))
	}
	if i.HasJobRunners != nil {
		p := jobrunnertoken.HasJobRunners()
		if !*i.HasJobRunners {
			p = jobrunnertoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobRunnersWith) > 0 {
		with := make([]predicate.JobRunner, 0, len(i.HasJobRunnersWith))
		for _, w := range i.HasJobRunnersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobRunnersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobrunnertoken.HasJobRunnersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJobRunnerTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return jobrunnertoken.And(predicates...), nil
	}
}

// MappableDomainWhereInput represents a where input for filtering MappableDomain queries.
type MappableDomainWhereInput struct {
	Predicates []predicate.MappableDomain  `json:"-"`
	Not        *MappableDomainWhereInput   `json:"not,omitempty"`
	Or         []*MappableDomainWhereInput `json:"or,omitempty"`
	And        []*MappableDomainWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "zone_id" field predicates.
	ZoneID             *string  `json:"zoneID,omitempty"`
	ZoneIDNEQ          *string  `json:"zoneIDNEQ,omitempty"`
	ZoneIDIn           []string `json:"zoneIDIn,omitempty"`
	ZoneIDNotIn        []string `json:"zoneIDNotIn,omitempty"`
	ZoneIDGT           *string  `json:"zoneIDGT,omitempty"`
	ZoneIDGTE          *string  `json:"zoneIDGTE,omitempty"`
	ZoneIDLT           *string  `json:"zoneIDLT,omitempty"`
	ZoneIDLTE          *string  `json:"zoneIDLTE,omitempty"`
	ZoneIDContains     *string  `json:"zoneIDContains,omitempty"`
	ZoneIDHasPrefix    *string  `json:"zoneIDHasPrefix,omitempty"`
	ZoneIDHasSuffix    *string  `json:"zoneIDHasSuffix,omitempty"`
	ZoneIDEqualFold    *string  `json:"zoneIDEqualFold,omitempty"`
	ZoneIDContainsFold *string  `json:"zoneIDContainsFold,omitempty"`

	// "custom_domains" edge predicates.
	HasCustomDomains     *bool                     `json:"hasCustomDomains,omitempty"`
	HasCustomDomainsWith []*CustomDomainWhereInput `json:"hasCustomDomainsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MappableDomainWhereInput) AddPredicates(predicates ...predicate.MappableDomain) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MappableDomainWhereInput filter on the MappableDomainQuery builder.
func (i *MappableDomainWhereInput) Filter(q *MappableDomainQuery) (*MappableDomainQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMappableDomainWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMappableDomainWhereInput is returned in case the MappableDomainWhereInput is empty.
var ErrEmptyMappableDomainWhereInput = errors.New("generated: empty predicate MappableDomainWhereInput")

// P returns a predicate for filtering mappabledomains.
// An error is returned if the input is empty or invalid.
func (i *MappableDomainWhereInput) P() (predicate.MappableDomain, error) {
	var predicates []predicate.MappableDomain
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, mappabledomain.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MappableDomain, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, mappabledomain.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MappableDomain, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, mappabledomain.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, mappabledomain.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, mappabledomain.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, mappabledomain.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, mappabledomain.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, mappabledomain.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, mappabledomain.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, mappabledomain.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, mappabledomain.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, mappabledomain.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, mappabledomain.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, mappabledomain.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, mappabledomain.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, mappabledomain.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, mappabledomain.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, mappabledomain.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, mappabledomain.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, mappabledomain.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, mappabledomain.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, mappabledomain.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, mappabledomain.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, mappabledomain.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, mappabledomain.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, mappabledomain.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, mappabledomain.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, mappabledomain.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, mappabledomain.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, mappabledomain.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, mappabledomain.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, mappabledomain.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, mappabledomain.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, mappabledomain.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, mappabledomain.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, mappabledomain.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, mappabledomain.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, mappabledomain.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, mappabledomain.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, mappabledomain.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, mappabledomain.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, mappabledomain.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, mappabledomain.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, mappabledomain.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, mappabledomain.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, mappabledomain.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, mappabledomain.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, mappabledomain.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, mappabledomain.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, mappabledomain.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, mappabledomain.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, mappabledomain.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, mappabledomain.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, mappabledomain.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, mappabledomain.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, mappabledomain.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, mappabledomain.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, mappabledomain.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, mappabledomain.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, mappabledomain.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, mappabledomain.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, mappabledomain.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, mappabledomain.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, mappabledomain.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, mappabledomain.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, mappabledomain.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, mappabledomain.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, mappabledomain.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, mappabledomain.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, mappabledomain.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, mappabledomain.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, mappabledomain.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, mappabledomain.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, mappabledomain.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, mappabledomain.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, mappabledomain.NameContainsFold(*i.NameContainsFold))
	}
	if i.ZoneID != nil {
		predicates = append(predicates, mappabledomain.ZoneIDEQ(*i.ZoneID))
	}
	if i.ZoneIDNEQ != nil {
		predicates = append(predicates, mappabledomain.ZoneIDNEQ(*i.ZoneIDNEQ))
	}
	if len(i.ZoneIDIn) > 0 {
		predicates = append(predicates, mappabledomain.ZoneIDIn(i.ZoneIDIn...))
	}
	if len(i.ZoneIDNotIn) > 0 {
		predicates = append(predicates, mappabledomain.ZoneIDNotIn(i.ZoneIDNotIn...))
	}
	if i.ZoneIDGT != nil {
		predicates = append(predicates, mappabledomain.ZoneIDGT(*i.ZoneIDGT))
	}
	if i.ZoneIDGTE != nil {
		predicates = append(predicates, mappabledomain.ZoneIDGTE(*i.ZoneIDGTE))
	}
	if i.ZoneIDLT != nil {
		predicates = append(predicates, mappabledomain.ZoneIDLT(*i.ZoneIDLT))
	}
	if i.ZoneIDLTE != nil {
		predicates = append(predicates, mappabledomain.ZoneIDLTE(*i.ZoneIDLTE))
	}
	if i.ZoneIDContains != nil {
		predicates = append(predicates, mappabledomain.ZoneIDContains(*i.ZoneIDContains))
	}
	if i.ZoneIDHasPrefix != nil {
		predicates = append(predicates, mappabledomain.ZoneIDHasPrefix(*i.ZoneIDHasPrefix))
	}
	if i.ZoneIDHasSuffix != nil {
		predicates = append(predicates, mappabledomain.ZoneIDHasSuffix(*i.ZoneIDHasSuffix))
	}
	if i.ZoneIDEqualFold != nil {
		predicates = append(predicates, mappabledomain.ZoneIDEqualFold(*i.ZoneIDEqualFold))
	}
	if i.ZoneIDContainsFold != nil {
		predicates = append(predicates, mappabledomain.ZoneIDContainsFold(*i.ZoneIDContainsFold))
	}

	if i.HasCustomDomains != nil {
		p := mappabledomain.HasCustomDomains()
		if !*i.HasCustomDomains {
			p = mappabledomain.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomDomainsWith) > 0 {
		with := make([]predicate.CustomDomain, 0, len(i.HasCustomDomainsWith))
		for _, w := range i.HasCustomDomainsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomDomainsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, mappabledomain.HasCustomDomainsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMappableDomainWhereInput
	case 1:
		return predicates[0], nil
	default:
		return mappabledomain.And(predicates...), nil
	}
}

// MappableDomainHistoryWhereInput represents a where input for filtering MappableDomainHistory queries.
type MappableDomainHistoryWhereInput struct {
	Predicates []predicate.MappableDomainHistory  `json:"-"`
	Not        *MappableDomainHistoryWhereInput   `json:"not,omitempty"`
	Or         []*MappableDomainHistoryWhereInput `json:"or,omitempty"`
	And        []*MappableDomainHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "zone_id" field predicates.
	ZoneID             *string  `json:"zoneID,omitempty"`
	ZoneIDNEQ          *string  `json:"zoneIDNEQ,omitempty"`
	ZoneIDIn           []string `json:"zoneIDIn,omitempty"`
	ZoneIDNotIn        []string `json:"zoneIDNotIn,omitempty"`
	ZoneIDGT           *string  `json:"zoneIDGT,omitempty"`
	ZoneIDGTE          *string  `json:"zoneIDGTE,omitempty"`
	ZoneIDLT           *string  `json:"zoneIDLT,omitempty"`
	ZoneIDLTE          *string  `json:"zoneIDLTE,omitempty"`
	ZoneIDContains     *string  `json:"zoneIDContains,omitempty"`
	ZoneIDHasPrefix    *string  `json:"zoneIDHasPrefix,omitempty"`
	ZoneIDHasSuffix    *string  `json:"zoneIDHasSuffix,omitempty"`
	ZoneIDEqualFold    *string  `json:"zoneIDEqualFold,omitempty"`
	ZoneIDContainsFold *string  `json:"zoneIDContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MappableDomainHistoryWhereInput) AddPredicates(predicates ...predicate.MappableDomainHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MappableDomainHistoryWhereInput filter on the MappableDomainHistoryQuery builder.
func (i *MappableDomainHistoryWhereInput) Filter(q *MappableDomainHistoryQuery) (*MappableDomainHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMappableDomainHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMappableDomainHistoryWhereInput is returned in case the MappableDomainHistoryWhereInput is empty.
var ErrEmptyMappableDomainHistoryWhereInput = errors.New("generated: empty predicate MappableDomainHistoryWhereInput")

// P returns a predicate for filtering mappabledomainhistories.
// An error is returned if the input is empty or invalid.
func (i *MappableDomainHistoryWhereInput) P() (predicate.MappableDomainHistory, error) {
	var predicates []predicate.MappableDomainHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, mappabledomainhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MappableDomainHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, mappabledomainhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MappableDomainHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, mappabledomainhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, mappabledomainhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, mappabledomainhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, mappabledomainhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, mappabledomainhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, mappabledomainhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, mappabledomainhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, mappabledomainhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, mappabledomainhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, mappabledomainhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, mappabledomainhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, mappabledomainhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, mappabledomainhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, mappabledomainhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, mappabledomainhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, mappabledomainhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, mappabledomainhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, mappabledomainhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, mappabledomainhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, mappabledomainhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, mappabledomainhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, mappabledomainhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, mappabledomainhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, mappabledomainhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, mappabledomainhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, mappabledomainhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, mappabledomainhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, mappabledomainhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, mappabledomainhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, mappabledomainhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, mappabledomainhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, mappabledomainhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, mappabledomainhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, mappabledomainhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, mappabledomainhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, mappabledomainhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, mappabledomainhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, mappabledomainhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, mappabledomainhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, mappabledomainhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, mappabledomainhistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, mappabledomainhistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, mappabledomainhistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, mappabledomainhistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, mappabledomainhistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, mappabledomainhistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, mappabledomainhistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, mappabledomainhistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, mappabledomainhistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, mappabledomainhistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, mappabledomainhistory.NameContainsFold(*i.NameContainsFold))
	}
	if i.ZoneID != nil {
		predicates = append(predicates, mappabledomainhistory.ZoneIDEQ(*i.ZoneID))
	}
	if i.ZoneIDNEQ != nil {
		predicates = append(predicates, mappabledomainhistory.ZoneIDNEQ(*i.ZoneIDNEQ))
	}
	if len(i.ZoneIDIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.ZoneIDIn(i.ZoneIDIn...))
	}
	if len(i.ZoneIDNotIn) > 0 {
		predicates = append(predicates, mappabledomainhistory.ZoneIDNotIn(i.ZoneIDNotIn...))
	}
	if i.ZoneIDGT != nil {
		predicates = append(predicates, mappabledomainhistory.ZoneIDGT(*i.ZoneIDGT))
	}
	if i.ZoneIDGTE != nil {
		predicates = append(predicates, mappabledomainhistory.ZoneIDGTE(*i.ZoneIDGTE))
	}
	if i.ZoneIDLT != nil {
		predicates = append(predicates, mappabledomainhistory.ZoneIDLT(*i.ZoneIDLT))
	}
	if i.ZoneIDLTE != nil {
		predicates = append(predicates, mappabledomainhistory.ZoneIDLTE(*i.ZoneIDLTE))
	}
	if i.ZoneIDContains != nil {
		predicates = append(predicates, mappabledomainhistory.ZoneIDContains(*i.ZoneIDContains))
	}
	if i.ZoneIDHasPrefix != nil {
		predicates = append(predicates, mappabledomainhistory.ZoneIDHasPrefix(*i.ZoneIDHasPrefix))
	}
	if i.ZoneIDHasSuffix != nil {
		predicates = append(predicates, mappabledomainhistory.ZoneIDHasSuffix(*i.ZoneIDHasSuffix))
	}
	if i.ZoneIDEqualFold != nil {
		predicates = append(predicates, mappabledomainhistory.ZoneIDEqualFold(*i.ZoneIDEqualFold))
	}
	if i.ZoneIDContainsFold != nil {
		predicates = append(predicates, mappabledomainhistory.ZoneIDContainsFold(*i.ZoneIDContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMappableDomainHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return mappabledomainhistory.And(predicates...), nil
	}
}

// MappedControlWhereInput represents a where input for filtering MappedControl queries.
type MappedControlWhereInput struct {
	Predicates []predicate.MappedControl  `json:"-"`
	Not        *MappedControlWhereInput   `json:"not,omitempty"`
	Or         []*MappedControlWhereInput `json:"or,omitempty"`
	And        []*MappedControlWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "mapping_type" field predicates.
	MappingType      *enums.MappingType  `json:"mappingType,omitempty"`
	MappingTypeNEQ   *enums.MappingType  `json:"mappingTypeNEQ,omitempty"`
	MappingTypeIn    []enums.MappingType `json:"mappingTypeIn,omitempty"`
	MappingTypeNotIn []enums.MappingType `json:"mappingTypeNotIn,omitempty"`

	// "relation" field predicates.
	Relation             *string  `json:"relation,omitempty"`
	RelationNEQ          *string  `json:"relationNEQ,omitempty"`
	RelationIn           []string `json:"relationIn,omitempty"`
	RelationNotIn        []string `json:"relationNotIn,omitempty"`
	RelationGT           *string  `json:"relationGT,omitempty"`
	RelationGTE          *string  `json:"relationGTE,omitempty"`
	RelationLT           *string  `json:"relationLT,omitempty"`
	RelationLTE          *string  `json:"relationLTE,omitempty"`
	RelationContains     *string  `json:"relationContains,omitempty"`
	RelationHasPrefix    *string  `json:"relationHasPrefix,omitempty"`
	RelationHasSuffix    *string  `json:"relationHasSuffix,omitempty"`
	RelationIsNil        bool     `json:"relationIsNil,omitempty"`
	RelationNotNil       bool     `json:"relationNotNil,omitempty"`
	RelationEqualFold    *string  `json:"relationEqualFold,omitempty"`
	RelationContainsFold *string  `json:"relationContainsFold,omitempty"`

	// "confidence" field predicates.
	Confidence       *int  `json:"confidence,omitempty"`
	ConfidenceNEQ    *int  `json:"confidenceNEQ,omitempty"`
	ConfidenceIn     []int `json:"confidenceIn,omitempty"`
	ConfidenceNotIn  []int `json:"confidenceNotIn,omitempty"`
	ConfidenceGT     *int  `json:"confidenceGT,omitempty"`
	ConfidenceGTE    *int  `json:"confidenceGTE,omitempty"`
	ConfidenceLT     *int  `json:"confidenceLT,omitempty"`
	ConfidenceLTE    *int  `json:"confidenceLTE,omitempty"`
	ConfidenceIsNil  bool  `json:"confidenceIsNil,omitempty"`
	ConfidenceNotNil bool  `json:"confidenceNotNil,omitempty"`

	// "source" field predicates.
	Source       *enums.MappingSource  `json:"source,omitempty"`
	SourceNEQ    *enums.MappingSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.MappingSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.MappingSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  bool                  `json:"sourceIsNil,omitempty"`
	SourceNotNil bool                  `json:"sourceNotNil,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "blocked_groups" edge predicates.
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`

	// "editors" edge predicates.
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`

	// "from_controls" edge predicates.
	HasFromControls     *bool                `json:"hasFromControls,omitempty"`
	HasFromControlsWith []*ControlWhereInput `json:"hasFromControlsWith,omitempty"`

	// "to_controls" edge predicates.
	HasToControls     *bool                `json:"hasToControls,omitempty"`
	HasToControlsWith []*ControlWhereInput `json:"hasToControlsWith,omitempty"`

	// "from_subcontrols" edge predicates.
	HasFromSubcontrols     *bool                   `json:"hasFromSubcontrols,omitempty"`
	HasFromSubcontrolsWith []*SubcontrolWhereInput `json:"hasFromSubcontrolsWith,omitempty"`

	// "to_subcontrols" edge predicates.
	HasToSubcontrols     *bool                   `json:"hasToSubcontrols,omitempty"`
	HasToSubcontrolsWith []*SubcontrolWhereInput `json:"hasToSubcontrolsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MappedControlWhereInput) AddPredicates(predicates ...predicate.MappedControl) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MappedControlWhereInput filter on the MappedControlQuery builder.
func (i *MappedControlWhereInput) Filter(q *MappedControlQuery) (*MappedControlQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMappedControlWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMappedControlWhereInput is returned in case the MappedControlWhereInput is empty.
var ErrEmptyMappedControlWhereInput = errors.New("generated: empty predicate MappedControlWhereInput")

// P returns a predicate for filtering mappedcontrols.
// An error is returned if the input is empty or invalid.
func (i *MappedControlWhereInput) P() (predicate.MappedControl, error) {
	var predicates []predicate.MappedControl
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, mappedcontrol.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MappedControl, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, mappedcontrol.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MappedControl, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, mappedcontrol.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, mappedcontrol.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, mappedcontrol.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, mappedcontrol.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, mappedcontrol.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, mappedcontrol.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, mappedcontrol.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, mappedcontrol.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, mappedcontrol.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, mappedcontrol.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, mappedcontrol.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, mappedcontrol.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, mappedcontrol.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, mappedcontrol.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, mappedcontrol.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, mappedcontrol.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, mappedcontrol.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, mappedcontrol.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, mappedcontrol.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, mappedcontrol.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, mappedcontrol.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, mappedcontrol.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, mappedcontrol.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, mappedcontrol.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, mappedcontrol.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, mappedcontrol.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, mappedcontrol.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, mappedcontrol.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, mappedcontrol.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, mappedcontrol.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, mappedcontrol.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, mappedcontrol.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, mappedcontrol.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, mappedcontrol.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, mappedcontrol.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, mappedcontrol.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, mappedcontrol.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, mappedcontrol.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, mappedcontrol.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, mappedcontrol.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, mappedcontrol.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, mappedcontrol.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, mappedcontrol.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, mappedcontrol.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, mappedcontrol.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, mappedcontrol.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, mappedcontrol.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, mappedcontrol.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, mappedcontrol.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, mappedcontrol.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, mappedcontrol.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, mappedcontrol.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, mappedcontrol.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, mappedcontrol.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, mappedcontrol.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, mappedcontrol.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, mappedcontrol.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, mappedcontrol.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, mappedcontrol.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, mappedcontrol.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, mappedcontrol.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, mappedcontrol.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, mappedcontrol.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, mappedcontrol.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, mappedcontrol.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, mappedcontrol.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, mappedcontrol.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, mappedcontrol.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, mappedcontrol.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, mappedcontrol.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, mappedcontrol.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, mappedcontrol.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, mappedcontrol.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, mappedcontrol.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, mappedcontrol.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, mappedcontrol.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.MappingType != nil {
		predicates = append(predicates, mappedcontrol.MappingTypeEQ(*i.MappingType))
	}
	if i.MappingTypeNEQ != nil {
		predicates = append(predicates, mappedcontrol.MappingTypeNEQ(*i.MappingTypeNEQ))
	}
	if len(i.MappingTypeIn) > 0 {
		predicates = append(predicates, mappedcontrol.MappingTypeIn(i.MappingTypeIn...))
	}
	if len(i.MappingTypeNotIn) > 0 {
		predicates = append(predicates, mappedcontrol.MappingTypeNotIn(i.MappingTypeNotIn...))
	}
	if i.Relation != nil {
		predicates = append(predicates, mappedcontrol.RelationEQ(*i.Relation))
	}
	if i.RelationNEQ != nil {
		predicates = append(predicates, mappedcontrol.RelationNEQ(*i.RelationNEQ))
	}
	if len(i.RelationIn) > 0 {
		predicates = append(predicates, mappedcontrol.RelationIn(i.RelationIn...))
	}
	if len(i.RelationNotIn) > 0 {
		predicates = append(predicates, mappedcontrol.RelationNotIn(i.RelationNotIn...))
	}
	if i.RelationGT != nil {
		predicates = append(predicates, mappedcontrol.RelationGT(*i.RelationGT))
	}
	if i.RelationGTE != nil {
		predicates = append(predicates, mappedcontrol.RelationGTE(*i.RelationGTE))
	}
	if i.RelationLT != nil {
		predicates = append(predicates, mappedcontrol.RelationLT(*i.RelationLT))
	}
	if i.RelationLTE != nil {
		predicates = append(predicates, mappedcontrol.RelationLTE(*i.RelationLTE))
	}
	if i.RelationContains != nil {
		predicates = append(predicates, mappedcontrol.RelationContains(*i.RelationContains))
	}
	if i.RelationHasPrefix != nil {
		predicates = append(predicates, mappedcontrol.RelationHasPrefix(*i.RelationHasPrefix))
	}
	if i.RelationHasSuffix != nil {
		predicates = append(predicates, mappedcontrol.RelationHasSuffix(*i.RelationHasSuffix))
	}
	if i.RelationIsNil {
		predicates = append(predicates, mappedcontrol.RelationIsNil())
	}
	if i.RelationNotNil {
		predicates = append(predicates, mappedcontrol.RelationNotNil())
	}
	if i.RelationEqualFold != nil {
		predicates = append(predicates, mappedcontrol.RelationEqualFold(*i.RelationEqualFold))
	}
	if i.RelationContainsFold != nil {
		predicates = append(predicates, mappedcontrol.RelationContainsFold(*i.RelationContainsFold))
	}
	if i.Confidence != nil {
		predicates = append(predicates, mappedcontrol.ConfidenceEQ(*i.Confidence))
	}
	if i.ConfidenceNEQ != nil {
		predicates = append(predicates, mappedcontrol.ConfidenceNEQ(*i.ConfidenceNEQ))
	}
	if len(i.ConfidenceIn) > 0 {
		predicates = append(predicates, mappedcontrol.ConfidenceIn(i.ConfidenceIn...))
	}
	if len(i.ConfidenceNotIn) > 0 {
		predicates = append(predicates, mappedcontrol.ConfidenceNotIn(i.ConfidenceNotIn...))
	}
	if i.ConfidenceGT != nil {
		predicates = append(predicates, mappedcontrol.ConfidenceGT(*i.ConfidenceGT))
	}
	if i.ConfidenceGTE != nil {
		predicates = append(predicates, mappedcontrol.ConfidenceGTE(*i.ConfidenceGTE))
	}
	if i.ConfidenceLT != nil {
		predicates = append(predicates, mappedcontrol.ConfidenceLT(*i.ConfidenceLT))
	}
	if i.ConfidenceLTE != nil {
		predicates = append(predicates, mappedcontrol.ConfidenceLTE(*i.ConfidenceLTE))
	}
	if i.ConfidenceIsNil {
		predicates = append(predicates, mappedcontrol.ConfidenceIsNil())
	}
	if i.ConfidenceNotNil {
		predicates = append(predicates, mappedcontrol.ConfidenceNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, mappedcontrol.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, mappedcontrol.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, mappedcontrol.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, mappedcontrol.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceIsNil {
		predicates = append(predicates, mappedcontrol.SourceIsNil())
	}
	if i.SourceNotNil {
		predicates = append(predicates, mappedcontrol.SourceNotNil())
	}

	if i.HasOwner != nil {
		p := mappedcontrol.HasOwner()
		if !*i.HasOwner {
			p = mappedcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, mappedcontrol.HasOwnerWith(with...))
	}
	if i.HasBlockedGroups != nil {
		p := mappedcontrol.HasBlockedGroups()
		if !*i.HasBlockedGroups {
			p = mappedcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBlockedGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasBlockedGroupsWith))
		for _, w := range i.HasBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, mappedcontrol.HasBlockedGroupsWith(with...))
	}
	if i.HasEditors != nil {
		p := mappedcontrol.HasEditors()
		if !*i.HasEditors {
			p = mappedcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEditorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasEditorsWith))
		for _, w := range i.HasEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, mappedcontrol.HasEditorsWith(with...))
	}
	if i.HasFromControls != nil {
		p := mappedcontrol.HasFromControls()
		if !*i.HasFromControls {
			p = mappedcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFromControlsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasFromControlsWith))
		for _, w := range i.HasFromControlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFromControlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, mappedcontrol.HasFromControlsWith(with...))
	}
	if i.HasToControls != nil {
		p := mappedcontrol.HasToControls()
		if !*i.HasToControls {
			p = mappedcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasToControlsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasToControlsWith))
		for _, w := range i.HasToControlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasToControlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, mappedcontrol.HasToControlsWith(with...))
	}
	if i.HasFromSubcontrols != nil {
		p := mappedcontrol.HasFromSubcontrols()
		if !*i.HasFromSubcontrols {
			p = mappedcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFromSubcontrolsWith) > 0 {
		with := make([]predicate.Subcontrol, 0, len(i.HasFromSubcontrolsWith))
		for _, w := range i.HasFromSubcontrolsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFromSubcontrolsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, mappedcontrol.HasFromSubcontrolsWith(with...))
	}
	if i.HasToSubcontrols != nil {
		p := mappedcontrol.HasToSubcontrols()
		if !*i.HasToSubcontrols {
			p = mappedcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasToSubcontrolsWith) > 0 {
		with := make([]predicate.Subcontrol, 0, len(i.HasToSubcontrolsWith))
		for _, w := range i.HasToSubcontrolsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasToSubcontrolsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, mappedcontrol.HasToSubcontrolsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMappedControlWhereInput
	case 1:
		return predicates[0], nil
	default:
		return mappedcontrol.And(predicates...), nil
	}
}

// MappedControlHistoryWhereInput represents a where input for filtering MappedControlHistory queries.
type MappedControlHistoryWhereInput struct {
	Predicates []predicate.MappedControlHistory  `json:"-"`
	Not        *MappedControlHistoryWhereInput   `json:"not,omitempty"`
	Or         []*MappedControlHistoryWhereInput `json:"or,omitempty"`
	And        []*MappedControlHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "mapping_type" field predicates.
	MappingType      *enums.MappingType  `json:"mappingType,omitempty"`
	MappingTypeNEQ   *enums.MappingType  `json:"mappingTypeNEQ,omitempty"`
	MappingTypeIn    []enums.MappingType `json:"mappingTypeIn,omitempty"`
	MappingTypeNotIn []enums.MappingType `json:"mappingTypeNotIn,omitempty"`

	// "relation" field predicates.
	Relation             *string  `json:"relation,omitempty"`
	RelationNEQ          *string  `json:"relationNEQ,omitempty"`
	RelationIn           []string `json:"relationIn,omitempty"`
	RelationNotIn        []string `json:"relationNotIn,omitempty"`
	RelationGT           *string  `json:"relationGT,omitempty"`
	RelationGTE          *string  `json:"relationGTE,omitempty"`
	RelationLT           *string  `json:"relationLT,omitempty"`
	RelationLTE          *string  `json:"relationLTE,omitempty"`
	RelationContains     *string  `json:"relationContains,omitempty"`
	RelationHasPrefix    *string  `json:"relationHasPrefix,omitempty"`
	RelationHasSuffix    *string  `json:"relationHasSuffix,omitempty"`
	RelationIsNil        bool     `json:"relationIsNil,omitempty"`
	RelationNotNil       bool     `json:"relationNotNil,omitempty"`
	RelationEqualFold    *string  `json:"relationEqualFold,omitempty"`
	RelationContainsFold *string  `json:"relationContainsFold,omitempty"`

	// "confidence" field predicates.
	Confidence       *int  `json:"confidence,omitempty"`
	ConfidenceNEQ    *int  `json:"confidenceNEQ,omitempty"`
	ConfidenceIn     []int `json:"confidenceIn,omitempty"`
	ConfidenceNotIn  []int `json:"confidenceNotIn,omitempty"`
	ConfidenceGT     *int  `json:"confidenceGT,omitempty"`
	ConfidenceGTE    *int  `json:"confidenceGTE,omitempty"`
	ConfidenceLT     *int  `json:"confidenceLT,omitempty"`
	ConfidenceLTE    *int  `json:"confidenceLTE,omitempty"`
	ConfidenceIsNil  bool  `json:"confidenceIsNil,omitempty"`
	ConfidenceNotNil bool  `json:"confidenceNotNil,omitempty"`

	// "source" field predicates.
	Source       *enums.MappingSource  `json:"source,omitempty"`
	SourceNEQ    *enums.MappingSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.MappingSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.MappingSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  bool                  `json:"sourceIsNil,omitempty"`
	SourceNotNil bool                  `json:"sourceNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MappedControlHistoryWhereInput) AddPredicates(predicates ...predicate.MappedControlHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MappedControlHistoryWhereInput filter on the MappedControlHistoryQuery builder.
func (i *MappedControlHistoryWhereInput) Filter(q *MappedControlHistoryQuery) (*MappedControlHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMappedControlHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMappedControlHistoryWhereInput is returned in case the MappedControlHistoryWhereInput is empty.
var ErrEmptyMappedControlHistoryWhereInput = errors.New("generated: empty predicate MappedControlHistoryWhereInput")

// P returns a predicate for filtering mappedcontrolhistories.
// An error is returned if the input is empty or invalid.
func (i *MappedControlHistoryWhereInput) P() (predicate.MappedControlHistory, error) {
	var predicates []predicate.MappedControlHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, mappedcontrolhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MappedControlHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, mappedcontrolhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MappedControlHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, mappedcontrolhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, mappedcontrolhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, mappedcontrolhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, mappedcontrolhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, mappedcontrolhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, mappedcontrolhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, mappedcontrolhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, mappedcontrolhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, mappedcontrolhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, mappedcontrolhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, mappedcontrolhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, mappedcontrolhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, mappedcontrolhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, mappedcontrolhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, mappedcontrolhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, mappedcontrolhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, mappedcontrolhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, mappedcontrolhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, mappedcontrolhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, mappedcontrolhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, mappedcontrolhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, mappedcontrolhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, mappedcontrolhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, mappedcontrolhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, mappedcontrolhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, mappedcontrolhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, mappedcontrolhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, mappedcontrolhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, mappedcontrolhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, mappedcontrolhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, mappedcontrolhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, mappedcontrolhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, mappedcontrolhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, mappedcontrolhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, mappedcontrolhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, mappedcontrolhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, mappedcontrolhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, mappedcontrolhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, mappedcontrolhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, mappedcontrolhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, mappedcontrolhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, mappedcontrolhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, mappedcontrolhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, mappedcontrolhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, mappedcontrolhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, mappedcontrolhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, mappedcontrolhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, mappedcontrolhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, mappedcontrolhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.MappingType != nil {
		predicates = append(predicates, mappedcontrolhistory.MappingTypeEQ(*i.MappingType))
	}
	if i.MappingTypeNEQ != nil {
		predicates = append(predicates, mappedcontrolhistory.MappingTypeNEQ(*i.MappingTypeNEQ))
	}
	if len(i.MappingTypeIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.MappingTypeIn(i.MappingTypeIn...))
	}
	if len(i.MappingTypeNotIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.MappingTypeNotIn(i.MappingTypeNotIn...))
	}
	if i.Relation != nil {
		predicates = append(predicates, mappedcontrolhistory.RelationEQ(*i.Relation))
	}
	if i.RelationNEQ != nil {
		predicates = append(predicates, mappedcontrolhistory.RelationNEQ(*i.RelationNEQ))
	}
	if len(i.RelationIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.RelationIn(i.RelationIn...))
	}
	if len(i.RelationNotIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.RelationNotIn(i.RelationNotIn...))
	}
	if i.RelationGT != nil {
		predicates = append(predicates, mappedcontrolhistory.RelationGT(*i.RelationGT))
	}
	if i.RelationGTE != nil {
		predicates = append(predicates, mappedcontrolhistory.RelationGTE(*i.RelationGTE))
	}
	if i.RelationLT != nil {
		predicates = append(predicates, mappedcontrolhistory.RelationLT(*i.RelationLT))
	}
	if i.RelationLTE != nil {
		predicates = append(predicates, mappedcontrolhistory.RelationLTE(*i.RelationLTE))
	}
	if i.RelationContains != nil {
		predicates = append(predicates, mappedcontrolhistory.RelationContains(*i.RelationContains))
	}
	if i.RelationHasPrefix != nil {
		predicates = append(predicates, mappedcontrolhistory.RelationHasPrefix(*i.RelationHasPrefix))
	}
	if i.RelationHasSuffix != nil {
		predicates = append(predicates, mappedcontrolhistory.RelationHasSuffix(*i.RelationHasSuffix))
	}
	if i.RelationIsNil {
		predicates = append(predicates, mappedcontrolhistory.RelationIsNil())
	}
	if i.RelationNotNil {
		predicates = append(predicates, mappedcontrolhistory.RelationNotNil())
	}
	if i.RelationEqualFold != nil {
		predicates = append(predicates, mappedcontrolhistory.RelationEqualFold(*i.RelationEqualFold))
	}
	if i.RelationContainsFold != nil {
		predicates = append(predicates, mappedcontrolhistory.RelationContainsFold(*i.RelationContainsFold))
	}
	if i.Confidence != nil {
		predicates = append(predicates, mappedcontrolhistory.ConfidenceEQ(*i.Confidence))
	}
	if i.ConfidenceNEQ != nil {
		predicates = append(predicates, mappedcontrolhistory.ConfidenceNEQ(*i.ConfidenceNEQ))
	}
	if len(i.ConfidenceIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.ConfidenceIn(i.ConfidenceIn...))
	}
	if len(i.ConfidenceNotIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.ConfidenceNotIn(i.ConfidenceNotIn...))
	}
	if i.ConfidenceGT != nil {
		predicates = append(predicates, mappedcontrolhistory.ConfidenceGT(*i.ConfidenceGT))
	}
	if i.ConfidenceGTE != nil {
		predicates = append(predicates, mappedcontrolhistory.ConfidenceGTE(*i.ConfidenceGTE))
	}
	if i.ConfidenceLT != nil {
		predicates = append(predicates, mappedcontrolhistory.ConfidenceLT(*i.ConfidenceLT))
	}
	if i.ConfidenceLTE != nil {
		predicates = append(predicates, mappedcontrolhistory.ConfidenceLTE(*i.ConfidenceLTE))
	}
	if i.ConfidenceIsNil {
		predicates = append(predicates, mappedcontrolhistory.ConfidenceIsNil())
	}
	if i.ConfidenceNotNil {
		predicates = append(predicates, mappedcontrolhistory.ConfidenceNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, mappedcontrolhistory.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, mappedcontrolhistory.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, mappedcontrolhistory.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceIsNil {
		predicates = append(predicates, mappedcontrolhistory.SourceIsNil())
	}
	if i.SourceNotNil {
		predicates = append(predicates, mappedcontrolhistory.SourceNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMappedControlHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return mappedcontrolhistory.And(predicates...), nil
	}
}

// NarrativeWhereInput represents a where input for filtering Narrative queries.
type NarrativeWhereInput struct {
	Predicates []predicate.Narrative  `json:"-"`
	Not        *NarrativeWhereInput   `json:"not,omitempty"`
	Or         []*NarrativeWhereInput `json:"or,omitempty"`
	And        []*NarrativeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "details" field predicates.
	Details             *string  `json:"details,omitempty"`
	DetailsNEQ          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGT           *string  `json:"detailsGT,omitempty"`
	DetailsGTE          *string  `json:"detailsGTE,omitempty"`
	DetailsLT           *string  `json:"detailsLT,omitempty"`
	DetailsLTE          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        bool     `json:"detailsIsNil,omitempty"`
	DetailsNotNil       bool     `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "blocked_groups" edge predicates.
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`

	// "editors" edge predicates.
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`

	// "viewers" edge predicates.
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`

	// "satisfies" edge predicates.
	HasSatisfies     *bool                `json:"hasSatisfies,omitempty"`
	HasSatisfiesWith []*ControlWhereInput `json:"hasSatisfiesWith,omitempty"`

	// "programs" edge predicates.
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`

	// "internal_policies" edge predicates.
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`

	// "procedures" edge predicates.
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *NarrativeWhereInput) AddPredicates(predicates ...predicate.Narrative) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the NarrativeWhereInput filter on the NarrativeQuery builder.
func (i *NarrativeWhereInput) Filter(q *NarrativeQuery) (*NarrativeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyNarrativeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyNarrativeWhereInput is returned in case the NarrativeWhereInput is empty.
var ErrEmptyNarrativeWhereInput = errors.New("generated: empty predicate NarrativeWhereInput")

// P returns a predicate for filtering narratives.
// An error is returned if the input is empty or invalid.
func (i *NarrativeWhereInput) P() (predicate.Narrative, error) {
	var predicates []predicate.Narrative
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, narrative.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Narrative, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, narrative.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Narrative, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, narrative.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, narrative.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, narrative.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, narrative.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, narrative.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, narrative.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, narrative.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, narrative.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, narrative.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, narrative.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, narrative.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, narrative.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, narrative.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, narrative.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, narrative.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, narrative.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, narrative.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, narrative.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, narrative.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, narrative.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, narrative.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, narrative.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, narrative.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, narrative.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, narrative.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, narrative.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, narrative.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, narrative.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, narrative.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, narrative.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, narrative.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, narrative.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, narrative.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, narrative.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, narrative.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, narrative.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, narrative.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, narrative.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, narrative.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, narrative.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, narrative.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, narrative.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, narrative.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, narrative.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, narrative.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, narrative.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, narrative.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, narrative.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, narrative.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, narrative.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, narrative.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, narrative.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, narrative.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, narrative.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, narrative.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, narrative.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, narrative.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, narrative.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, narrative.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, narrative.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, narrative.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, narrative.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, narrative.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, narrative.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, narrative.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, narrative.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, narrative.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, narrative.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, narrative.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, narrative.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, narrative.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, narrative.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, narrative.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, narrative.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, narrative.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, narrative.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, narrative.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, narrative.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, narrative.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, narrative.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, narrative.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, narrative.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, narrative.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, narrative.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, narrative.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, narrative.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, narrative.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, narrative.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, narrative.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, narrative.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, narrative.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, narrative.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, narrative.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, narrative.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, narrative.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, narrative.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, narrative.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, narrative.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, narrative.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, narrative.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, narrative.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, narrative.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, narrative.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, narrative.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, narrative.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, narrative.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, narrative.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, narrative.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, narrative.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, narrative.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, narrative.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, narrative.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, narrative.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, narrative.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, narrative.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, narrative.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, narrative.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Details != nil {
		predicates = append(predicates, narrative.DetailsEQ(*i.Details))
	}
	if i.DetailsNEQ != nil {
		predicates = append(predicates, narrative.DetailsNEQ(*i.DetailsNEQ))
	}
	if len(i.DetailsIn) > 0 {
		predicates = append(predicates, narrative.DetailsIn(i.DetailsIn...))
	}
	if len(i.DetailsNotIn) > 0 {
		predicates = append(predicates, narrative.DetailsNotIn(i.DetailsNotIn...))
	}
	if i.DetailsGT != nil {
		predicates = append(predicates, narrative.DetailsGT(*i.DetailsGT))
	}
	if i.DetailsGTE != nil {
		predicates = append(predicates, narrative.DetailsGTE(*i.DetailsGTE))
	}
	if i.DetailsLT != nil {
		predicates = append(predicates, narrative.DetailsLT(*i.DetailsLT))
	}
	if i.DetailsLTE != nil {
		predicates = append(predicates, narrative.DetailsLTE(*i.DetailsLTE))
	}
	if i.DetailsContains != nil {
		predicates = append(predicates, narrative.DetailsContains(*i.DetailsContains))
	}
	if i.DetailsHasPrefix != nil {
		predicates = append(predicates, narrative.DetailsHasPrefix(*i.DetailsHasPrefix))
	}
	if i.DetailsHasSuffix != nil {
		predicates = append(predicates, narrative.DetailsHasSuffix(*i.DetailsHasSuffix))
	}
	if i.DetailsIsNil {
		predicates = append(predicates, narrative.DetailsIsNil())
	}
	if i.DetailsNotNil {
		predicates = append(predicates, narrative.DetailsNotNil())
	}
	if i.DetailsEqualFold != nil {
		predicates = append(predicates, narrative.DetailsEqualFold(*i.DetailsEqualFold))
	}
	if i.DetailsContainsFold != nil {
		predicates = append(predicates, narrative.DetailsContainsFold(*i.DetailsContainsFold))
	}

	if i.HasOwner != nil {
		p := narrative.HasOwner()
		if !*i.HasOwner {
			p = narrative.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, narrative.HasOwnerWith(with...))
	}
	if i.HasBlockedGroups != nil {
		p := narrative.HasBlockedGroups()
		if !*i.HasBlockedGroups {
			p = narrative.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBlockedGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasBlockedGroupsWith))
		for _, w := range i.HasBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, narrative.HasBlockedGroupsWith(with...))
	}
	if i.HasEditors != nil {
		p := narrative.HasEditors()
		if !*i.HasEditors {
			p = narrative.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEditorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasEditorsWith))
		for _, w := range i.HasEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, narrative.HasEditorsWith(with...))
	}
	if i.HasViewers != nil {
		p := narrative.HasViewers()
		if !*i.HasViewers {
			p = narrative.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasViewersWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasViewersWith))
		for _, w := range i.HasViewersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasViewersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, narrative.HasViewersWith(with...))
	}
	if i.HasSatisfies != nil {
		p := narrative.HasSatisfies()
		if !*i.HasSatisfies {
			p = narrative.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSatisfiesWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasSatisfiesWith))
		for _, w := range i.HasSatisfiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSatisfiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, narrative.HasSatisfiesWith(with...))
	}
	if i.HasPrograms != nil {
		p := narrative.HasPrograms()
		if !*i.HasPrograms {
			p = narrative.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramsWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramsWith))
		for _, w := range i.HasProgramsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, narrative.HasProgramsWith(with...))
	}
	if i.HasInternalPolicies != nil {
		p := narrative.HasInternalPolicies()
		if !*i.HasInternalPolicies {
			p = narrative.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInternalPoliciesWith) > 0 {
		with := make([]predicate.InternalPolicy, 0, len(i.HasInternalPoliciesWith))
		for _, w := range i.HasInternalPoliciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInternalPoliciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, narrative.HasInternalPoliciesWith(with...))
	}
	if i.HasProcedures != nil {
		p := narrative.HasProcedures()
		if !*i.HasProcedures {
			p = narrative.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProceduresWith) > 0 {
		with := make([]predicate.Procedure, 0, len(i.HasProceduresWith))
		for _, w := range i.HasProceduresWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProceduresWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, narrative.HasProceduresWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyNarrativeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return narrative.And(predicates...), nil
	}
}

// NarrativeHistoryWhereInput represents a where input for filtering NarrativeHistory queries.
type NarrativeHistoryWhereInput struct {
	Predicates []predicate.NarrativeHistory  `json:"-"`
	Not        *NarrativeHistoryWhereInput   `json:"not,omitempty"`
	Or         []*NarrativeHistoryWhereInput `json:"or,omitempty"`
	And        []*NarrativeHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "details" field predicates.
	Details             *string  `json:"details,omitempty"`
	DetailsNEQ          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGT           *string  `json:"detailsGT,omitempty"`
	DetailsGTE          *string  `json:"detailsGTE,omitempty"`
	DetailsLT           *string  `json:"detailsLT,omitempty"`
	DetailsLTE          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        bool     `json:"detailsIsNil,omitempty"`
	DetailsNotNil       bool     `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *NarrativeHistoryWhereInput) AddPredicates(predicates ...predicate.NarrativeHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the NarrativeHistoryWhereInput filter on the NarrativeHistoryQuery builder.
func (i *NarrativeHistoryWhereInput) Filter(q *NarrativeHistoryQuery) (*NarrativeHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyNarrativeHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyNarrativeHistoryWhereInput is returned in case the NarrativeHistoryWhereInput is empty.
var ErrEmptyNarrativeHistoryWhereInput = errors.New("generated: empty predicate NarrativeHistoryWhereInput")

// P returns a predicate for filtering narrativehistories.
// An error is returned if the input is empty or invalid.
func (i *NarrativeHistoryWhereInput) P() (predicate.NarrativeHistory, error) {
	var predicates []predicate.NarrativeHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, narrativehistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.NarrativeHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, narrativehistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.NarrativeHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, narrativehistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, narrativehistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, narrativehistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, narrativehistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, narrativehistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, narrativehistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, narrativehistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, narrativehistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, narrativehistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, narrativehistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, narrativehistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, narrativehistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, narrativehistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, narrativehistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, narrativehistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, narrativehistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, narrativehistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, narrativehistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, narrativehistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, narrativehistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, narrativehistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, narrativehistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, narrativehistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, narrativehistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, narrativehistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, narrativehistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, narrativehistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, narrativehistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, narrativehistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, narrativehistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, narrativehistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, narrativehistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, narrativehistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, narrativehistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, narrativehistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, narrativehistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, narrativehistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, narrativehistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, narrativehistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, narrativehistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, narrativehistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, narrativehistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, narrativehistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, narrativehistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, narrativehistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, narrativehistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, narrativehistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, narrativehistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, narrativehistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, narrativehistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, narrativehistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, narrativehistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, narrativehistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, narrativehistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, narrativehistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, narrativehistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, narrativehistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, narrativehistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, narrativehistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, narrativehistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, narrativehistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, narrativehistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, narrativehistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, narrativehistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, narrativehistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, narrativehistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, narrativehistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, narrativehistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, narrativehistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, narrativehistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, narrativehistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, narrativehistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, narrativehistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, narrativehistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, narrativehistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, narrativehistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, narrativehistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, narrativehistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, narrativehistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, narrativehistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, narrativehistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, narrativehistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, narrativehistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, narrativehistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, narrativehistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, narrativehistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, narrativehistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, narrativehistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, narrativehistory.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, narrativehistory.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, narrativehistory.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, narrativehistory.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, narrativehistory.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, narrativehistory.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, narrativehistory.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, narrativehistory.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, narrativehistory.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, narrativehistory.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, narrativehistory.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, narrativehistory.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, narrativehistory.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, narrativehistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, narrativehistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, narrativehistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, narrativehistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, narrativehistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, narrativehistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, narrativehistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, narrativehistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, narrativehistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, narrativehistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, narrativehistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, narrativehistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, narrativehistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, narrativehistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, narrativehistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, narrativehistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, narrativehistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, narrativehistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, narrativehistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, narrativehistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, narrativehistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, narrativehistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, narrativehistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, narrativehistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, narrativehistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, narrativehistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, narrativehistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, narrativehistory.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, narrativehistory.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, narrativehistory.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, narrativehistory.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, narrativehistory.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, narrativehistory.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, narrativehistory.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, narrativehistory.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, narrativehistory.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, narrativehistory.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, narrativehistory.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, narrativehistory.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, narrativehistory.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, narrativehistory.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, narrativehistory.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, narrativehistory.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Details != nil {
		predicates = append(predicates, narrativehistory.DetailsEQ(*i.Details))
	}
	if i.DetailsNEQ != nil {
		predicates = append(predicates, narrativehistory.DetailsNEQ(*i.DetailsNEQ))
	}
	if len(i.DetailsIn) > 0 {
		predicates = append(predicates, narrativehistory.DetailsIn(i.DetailsIn...))
	}
	if len(i.DetailsNotIn) > 0 {
		predicates = append(predicates, narrativehistory.DetailsNotIn(i.DetailsNotIn...))
	}
	if i.DetailsGT != nil {
		predicates = append(predicates, narrativehistory.DetailsGT(*i.DetailsGT))
	}
	if i.DetailsGTE != nil {
		predicates = append(predicates, narrativehistory.DetailsGTE(*i.DetailsGTE))
	}
	if i.DetailsLT != nil {
		predicates = append(predicates, narrativehistory.DetailsLT(*i.DetailsLT))
	}
	if i.DetailsLTE != nil {
		predicates = append(predicates, narrativehistory.DetailsLTE(*i.DetailsLTE))
	}
	if i.DetailsContains != nil {
		predicates = append(predicates, narrativehistory.DetailsContains(*i.DetailsContains))
	}
	if i.DetailsHasPrefix != nil {
		predicates = append(predicates, narrativehistory.DetailsHasPrefix(*i.DetailsHasPrefix))
	}
	if i.DetailsHasSuffix != nil {
		predicates = append(predicates, narrativehistory.DetailsHasSuffix(*i.DetailsHasSuffix))
	}
	if i.DetailsIsNil {
		predicates = append(predicates, narrativehistory.DetailsIsNil())
	}
	if i.DetailsNotNil {
		predicates = append(predicates, narrativehistory.DetailsNotNil())
	}
	if i.DetailsEqualFold != nil {
		predicates = append(predicates, narrativehistory.DetailsEqualFold(*i.DetailsEqualFold))
	}
	if i.DetailsContainsFold != nil {
		predicates = append(predicates, narrativehistory.DetailsContainsFold(*i.DetailsContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyNarrativeHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return narrativehistory.And(predicates...), nil
	}
}

// NoteWhereInput represents a where input for filtering Note queries.
type NoteWhereInput struct {
	Predicates []predicate.Note  `json:"-"`
	Not        *NoteWhereInput   `json:"not,omitempty"`
	Or         []*NoteWhereInput `json:"or,omitempty"`
	And        []*NoteWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "text" field predicates.
	Text             *string  `json:"text,omitempty"`
	TextNEQ          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGT           *string  `json:"textGT,omitempty"`
	TextGTE          *string  `json:"textGTE,omitempty"`
	TextLT           *string  `json:"textLT,omitempty"`
	TextLTE          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "task" edge predicates.
	HasTask     *bool             `json:"hasTask,omitempty"`
	HasTaskWith []*TaskWhereInput `json:"hasTaskWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *NoteWhereInput) AddPredicates(predicates ...predicate.Note) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the NoteWhereInput filter on the NoteQuery builder.
func (i *NoteWhereInput) Filter(q *NoteQuery) (*NoteQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyNoteWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyNoteWhereInput is returned in case the NoteWhereInput is empty.
var ErrEmptyNoteWhereInput = errors.New("generated: empty predicate NoteWhereInput")

// P returns a predicate for filtering notes.
// An error is returned if the input is empty or invalid.
func (i *NoteWhereInput) P() (predicate.Note, error) {
	var predicates []predicate.Note
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, note.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Note, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, note.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Note, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, note.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, note.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, note.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, note.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, note.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, note.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, note.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, note.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, note.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, note.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, note.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, note.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, note.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, note.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, note.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, note.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, note.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, note.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, note.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, note.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, note.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, note.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, note.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, note.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, note.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, note.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, note.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, note.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, note.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, note.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, note.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, note.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, note.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, note.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, note.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, note.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, note.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, note.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, note.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, note.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, note.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, note.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, note.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, note.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, note.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, note.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, note.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, note.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, note.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, note.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, note.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, note.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, note.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, note.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, note.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, note.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, note.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, note.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, note.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, note.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, note.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, note.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, note.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, note.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, note.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, note.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, note.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, note.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, note.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, note.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, note.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, note.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, note.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, note.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, note.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, note.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, note.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, note.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, note.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, note.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, note.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, note.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, note.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, note.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, note.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, note.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, note.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, note.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, note.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Text != nil {
		predicates = append(predicates, note.TextEQ(*i.Text))
	}
	if i.TextNEQ != nil {
		predicates = append(predicates, note.TextNEQ(*i.TextNEQ))
	}
	if len(i.TextIn) > 0 {
		predicates = append(predicates, note.TextIn(i.TextIn...))
	}
	if len(i.TextNotIn) > 0 {
		predicates = append(predicates, note.TextNotIn(i.TextNotIn...))
	}
	if i.TextGT != nil {
		predicates = append(predicates, note.TextGT(*i.TextGT))
	}
	if i.TextGTE != nil {
		predicates = append(predicates, note.TextGTE(*i.TextGTE))
	}
	if i.TextLT != nil {
		predicates = append(predicates, note.TextLT(*i.TextLT))
	}
	if i.TextLTE != nil {
		predicates = append(predicates, note.TextLTE(*i.TextLTE))
	}
	if i.TextContains != nil {
		predicates = append(predicates, note.TextContains(*i.TextContains))
	}
	if i.TextHasPrefix != nil {
		predicates = append(predicates, note.TextHasPrefix(*i.TextHasPrefix))
	}
	if i.TextHasSuffix != nil {
		predicates = append(predicates, note.TextHasSuffix(*i.TextHasSuffix))
	}
	if i.TextEqualFold != nil {
		predicates = append(predicates, note.TextEqualFold(*i.TextEqualFold))
	}
	if i.TextContainsFold != nil {
		predicates = append(predicates, note.TextContainsFold(*i.TextContainsFold))
	}

	if i.HasOwner != nil {
		p := note.HasOwner()
		if !*i.HasOwner {
			p = note.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, note.HasOwnerWith(with...))
	}
	if i.HasTask != nil {
		p := note.HasTask()
		if !*i.HasTask {
			p = note.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTaskWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTaskWith))
		for _, w := range i.HasTaskWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTaskWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, note.HasTaskWith(with...))
	}
	if i.HasFiles != nil {
		p := note.HasFiles()
		if !*i.HasFiles {
			p = note.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, note.HasFilesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyNoteWhereInput
	case 1:
		return predicates[0], nil
	default:
		return note.And(predicates...), nil
	}
}

// NoteHistoryWhereInput represents a where input for filtering NoteHistory queries.
type NoteHistoryWhereInput struct {
	Predicates []predicate.NoteHistory  `json:"-"`
	Not        *NoteHistoryWhereInput   `json:"not,omitempty"`
	Or         []*NoteHistoryWhereInput `json:"or,omitempty"`
	And        []*NoteHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "text" field predicates.
	Text             *string  `json:"text,omitempty"`
	TextNEQ          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGT           *string  `json:"textGT,omitempty"`
	TextGTE          *string  `json:"textGTE,omitempty"`
	TextLT           *string  `json:"textLT,omitempty"`
	TextLTE          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *NoteHistoryWhereInput) AddPredicates(predicates ...predicate.NoteHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the NoteHistoryWhereInput filter on the NoteHistoryQuery builder.
func (i *NoteHistoryWhereInput) Filter(q *NoteHistoryQuery) (*NoteHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyNoteHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyNoteHistoryWhereInput is returned in case the NoteHistoryWhereInput is empty.
var ErrEmptyNoteHistoryWhereInput = errors.New("generated: empty predicate NoteHistoryWhereInput")

// P returns a predicate for filtering notehistories.
// An error is returned if the input is empty or invalid.
func (i *NoteHistoryWhereInput) P() (predicate.NoteHistory, error) {
	var predicates []predicate.NoteHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, notehistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.NoteHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, notehistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.NoteHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, notehistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, notehistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, notehistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, notehistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, notehistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, notehistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, notehistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, notehistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, notehistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, notehistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, notehistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, notehistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, notehistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, notehistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, notehistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, notehistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, notehistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, notehistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, notehistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, notehistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, notehistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, notehistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, notehistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, notehistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, notehistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, notehistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, notehistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, notehistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, notehistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, notehistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, notehistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, notehistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, notehistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, notehistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, notehistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, notehistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, notehistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, notehistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, notehistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, notehistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, notehistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, notehistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, notehistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, notehistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, notehistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, notehistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, notehistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, notehistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, notehistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, notehistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, notehistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, notehistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, notehistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, notehistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, notehistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, notehistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, notehistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, notehistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, notehistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, notehistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, notehistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, notehistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, notehistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, notehistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, notehistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, notehistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, notehistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, notehistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, notehistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, notehistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, notehistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, notehistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, notehistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, notehistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, notehistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, notehistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, notehistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, notehistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, notehistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, notehistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, notehistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, notehistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, notehistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, notehistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, notehistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, notehistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, notehistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, notehistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, notehistory.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, notehistory.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, notehistory.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, notehistory.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, notehistory.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, notehistory.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, notehistory.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, notehistory.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, notehistory.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, notehistory.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, notehistory.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, notehistory.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, notehistory.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, notehistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, notehistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, notehistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, notehistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, notehistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, notehistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, notehistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, notehistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, notehistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, notehistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, notehistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, notehistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, notehistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, notehistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, notehistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Text != nil {
		predicates = append(predicates, notehistory.TextEQ(*i.Text))
	}
	if i.TextNEQ != nil {
		predicates = append(predicates, notehistory.TextNEQ(*i.TextNEQ))
	}
	if len(i.TextIn) > 0 {
		predicates = append(predicates, notehistory.TextIn(i.TextIn...))
	}
	if len(i.TextNotIn) > 0 {
		predicates = append(predicates, notehistory.TextNotIn(i.TextNotIn...))
	}
	if i.TextGT != nil {
		predicates = append(predicates, notehistory.TextGT(*i.TextGT))
	}
	if i.TextGTE != nil {
		predicates = append(predicates, notehistory.TextGTE(*i.TextGTE))
	}
	if i.TextLT != nil {
		predicates = append(predicates, notehistory.TextLT(*i.TextLT))
	}
	if i.TextLTE != nil {
		predicates = append(predicates, notehistory.TextLTE(*i.TextLTE))
	}
	if i.TextContains != nil {
		predicates = append(predicates, notehistory.TextContains(*i.TextContains))
	}
	if i.TextHasPrefix != nil {
		predicates = append(predicates, notehistory.TextHasPrefix(*i.TextHasPrefix))
	}
	if i.TextHasSuffix != nil {
		predicates = append(predicates, notehistory.TextHasSuffix(*i.TextHasSuffix))
	}
	if i.TextEqualFold != nil {
		predicates = append(predicates, notehistory.TextEqualFold(*i.TextEqualFold))
	}
	if i.TextContainsFold != nil {
		predicates = append(predicates, notehistory.TextContainsFold(*i.TextContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyNoteHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return notehistory.And(predicates...), nil
	}
}

// OnboardingWhereInput represents a where input for filtering Onboarding queries.
type OnboardingWhereInput struct {
	Predicates []predicate.Onboarding  `json:"-"`
	Not        *OnboardingWhereInput   `json:"not,omitempty"`
	Or         []*OnboardingWhereInput `json:"or,omitempty"`
	And        []*OnboardingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "organization_id" field predicates.
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIDNEQ          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIDGT           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIDGTE          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIDLT           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIDLTE          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        bool     `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       bool     `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`

	// "company_name" field predicates.
	CompanyName             *string  `json:"companyName,omitempty"`
	CompanyNameNEQ          *string  `json:"companyNameNEQ,omitempty"`
	CompanyNameIn           []string `json:"companyNameIn,omitempty"`
	CompanyNameNotIn        []string `json:"companyNameNotIn,omitempty"`
	CompanyNameGT           *string  `json:"companyNameGT,omitempty"`
	CompanyNameGTE          *string  `json:"companyNameGTE,omitempty"`
	CompanyNameLT           *string  `json:"companyNameLT,omitempty"`
	CompanyNameLTE          *string  `json:"companyNameLTE,omitempty"`
	CompanyNameContains     *string  `json:"companyNameContains,omitempty"`
	CompanyNameHasPrefix    *string  `json:"companyNameHasPrefix,omitempty"`
	CompanyNameHasSuffix    *string  `json:"companyNameHasSuffix,omitempty"`
	CompanyNameEqualFold    *string  `json:"companyNameEqualFold,omitempty"`
	CompanyNameContainsFold *string  `json:"companyNameContainsFold,omitempty"`

	// "organization" edge predicates.
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OnboardingWhereInput) AddPredicates(predicates ...predicate.Onboarding) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OnboardingWhereInput filter on the OnboardingQuery builder.
func (i *OnboardingWhereInput) Filter(q *OnboardingQuery) (*OnboardingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOnboardingWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOnboardingWhereInput is returned in case the OnboardingWhereInput is empty.
var ErrEmptyOnboardingWhereInput = errors.New("generated: empty predicate OnboardingWhereInput")

// P returns a predicate for filtering onboardings.
// An error is returned if the input is empty or invalid.
func (i *OnboardingWhereInput) P() (predicate.Onboarding, error) {
	var predicates []predicate.Onboarding
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, onboarding.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Onboarding, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, onboarding.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Onboarding, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, onboarding.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, onboarding.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, onboarding.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, onboarding.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, onboarding.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, onboarding.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, onboarding.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, onboarding.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, onboarding.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, onboarding.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, onboarding.IDContainsFold(*i.IDContainsFold))
	}
	if i.OrganizationID != nil {
		predicates = append(predicates, onboarding.OrganizationIDEQ(*i.OrganizationID))
	}
	if i.OrganizationIDNEQ != nil {
		predicates = append(predicates, onboarding.OrganizationIDNEQ(*i.OrganizationIDNEQ))
	}
	if len(i.OrganizationIDIn) > 0 {
		predicates = append(predicates, onboarding.OrganizationIDIn(i.OrganizationIDIn...))
	}
	if len(i.OrganizationIDNotIn) > 0 {
		predicates = append(predicates, onboarding.OrganizationIDNotIn(i.OrganizationIDNotIn...))
	}
	if i.OrganizationIDGT != nil {
		predicates = append(predicates, onboarding.OrganizationIDGT(*i.OrganizationIDGT))
	}
	if i.OrganizationIDGTE != nil {
		predicates = append(predicates, onboarding.OrganizationIDGTE(*i.OrganizationIDGTE))
	}
	if i.OrganizationIDLT != nil {
		predicates = append(predicates, onboarding.OrganizationIDLT(*i.OrganizationIDLT))
	}
	if i.OrganizationIDLTE != nil {
		predicates = append(predicates, onboarding.OrganizationIDLTE(*i.OrganizationIDLTE))
	}
	if i.OrganizationIDContains != nil {
		predicates = append(predicates, onboarding.OrganizationIDContains(*i.OrganizationIDContains))
	}
	if i.OrganizationIDHasPrefix != nil {
		predicates = append(predicates, onboarding.OrganizationIDHasPrefix(*i.OrganizationIDHasPrefix))
	}
	if i.OrganizationIDHasSuffix != nil {
		predicates = append(predicates, onboarding.OrganizationIDHasSuffix(*i.OrganizationIDHasSuffix))
	}
	if i.OrganizationIDIsNil {
		predicates = append(predicates, onboarding.OrganizationIDIsNil())
	}
	if i.OrganizationIDNotNil {
		predicates = append(predicates, onboarding.OrganizationIDNotNil())
	}
	if i.OrganizationIDEqualFold != nil {
		predicates = append(predicates, onboarding.OrganizationIDEqualFold(*i.OrganizationIDEqualFold))
	}
	if i.OrganizationIDContainsFold != nil {
		predicates = append(predicates, onboarding.OrganizationIDContainsFold(*i.OrganizationIDContainsFold))
	}
	if i.CompanyName != nil {
		predicates = append(predicates, onboarding.CompanyNameEQ(*i.CompanyName))
	}
	if i.CompanyNameNEQ != nil {
		predicates = append(predicates, onboarding.CompanyNameNEQ(*i.CompanyNameNEQ))
	}
	if len(i.CompanyNameIn) > 0 {
		predicates = append(predicates, onboarding.CompanyNameIn(i.CompanyNameIn...))
	}
	if len(i.CompanyNameNotIn) > 0 {
		predicates = append(predicates, onboarding.CompanyNameNotIn(i.CompanyNameNotIn...))
	}
	if i.CompanyNameGT != nil {
		predicates = append(predicates, onboarding.CompanyNameGT(*i.CompanyNameGT))
	}
	if i.CompanyNameGTE != nil {
		predicates = append(predicates, onboarding.CompanyNameGTE(*i.CompanyNameGTE))
	}
	if i.CompanyNameLT != nil {
		predicates = append(predicates, onboarding.CompanyNameLT(*i.CompanyNameLT))
	}
	if i.CompanyNameLTE != nil {
		predicates = append(predicates, onboarding.CompanyNameLTE(*i.CompanyNameLTE))
	}
	if i.CompanyNameContains != nil {
		predicates = append(predicates, onboarding.CompanyNameContains(*i.CompanyNameContains))
	}
	if i.CompanyNameHasPrefix != nil {
		predicates = append(predicates, onboarding.CompanyNameHasPrefix(*i.CompanyNameHasPrefix))
	}
	if i.CompanyNameHasSuffix != nil {
		predicates = append(predicates, onboarding.CompanyNameHasSuffix(*i.CompanyNameHasSuffix))
	}
	if i.CompanyNameEqualFold != nil {
		predicates = append(predicates, onboarding.CompanyNameEqualFold(*i.CompanyNameEqualFold))
	}
	if i.CompanyNameContainsFold != nil {
		predicates = append(predicates, onboarding.CompanyNameContainsFold(*i.CompanyNameContainsFold))
	}

	if i.HasOrganization != nil {
		p := onboarding.HasOrganization()
		if !*i.HasOrganization {
			p = onboarding.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrganizationWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOrganizationWith))
		for _, w := range i.HasOrganizationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrganizationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, onboarding.HasOrganizationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOnboardingWhereInput
	case 1:
		return predicates[0], nil
	default:
		return onboarding.And(predicates...), nil
	}
}

// OrgMembershipWhereInput represents a where input for filtering OrgMembership queries.
type OrgMembershipWhereInput struct {
	Predicates []predicate.OrgMembership  `json:"-"`
	Not        *OrgMembershipWhereInput   `json:"not,omitempty"`
	Or         []*OrgMembershipWhereInput `json:"or,omitempty"`
	And        []*OrgMembershipWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "role" field predicates.
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNEQ   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`

	// "organization_id" field predicates.
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIDNEQ          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIDGT           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIDGTE          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIDLT           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIDLTE          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "organization" edge predicates.
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "events" edge predicates.
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrgMembershipWhereInput) AddPredicates(predicates ...predicate.OrgMembership) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrgMembershipWhereInput filter on the OrgMembershipQuery builder.
func (i *OrgMembershipWhereInput) Filter(q *OrgMembershipQuery) (*OrgMembershipQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrgMembershipWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrgMembershipWhereInput is returned in case the OrgMembershipWhereInput is empty.
var ErrEmptyOrgMembershipWhereInput = errors.New("generated: empty predicate OrgMembershipWhereInput")

// P returns a predicate for filtering orgmemberships.
// An error is returned if the input is empty or invalid.
func (i *OrgMembershipWhereInput) P() (predicate.OrgMembership, error) {
	var predicates []predicate.OrgMembership
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, orgmembership.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrgMembership, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, orgmembership.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrgMembership, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, orgmembership.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, orgmembership.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, orgmembership.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, orgmembership.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, orgmembership.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, orgmembership.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, orgmembership.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, orgmembership.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, orgmembership.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, orgmembership.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, orgmembership.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, orgmembership.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, orgmembership.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, orgmembership.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, orgmembership.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, orgmembership.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, orgmembership.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, orgmembership.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, orgmembership.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, orgmembership.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, orgmembership.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, orgmembership.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, orgmembership.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, orgmembership.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, orgmembership.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, orgmembership.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, orgmembership.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, orgmembership.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, orgmembership.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, orgmembership.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, orgmembership.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, orgmembership.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, orgmembership.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, orgmembership.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, orgmembership.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, orgmembership.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, orgmembership.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, orgmembership.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, orgmembership.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, orgmembership.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, orgmembership.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, orgmembership.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, orgmembership.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, orgmembership.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, orgmembership.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, orgmembership.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, orgmembership.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, orgmembership.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, orgmembership.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, orgmembership.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, orgmembership.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, orgmembership.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, orgmembership.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, orgmembership.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, orgmembership.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, orgmembership.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, orgmembership.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, orgmembership.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, orgmembership.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, orgmembership.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, orgmembership.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Role != nil {
		predicates = append(predicates, orgmembership.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, orgmembership.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, orgmembership.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, orgmembership.RoleNotIn(i.RoleNotIn...))
	}
	if i.OrganizationID != nil {
		predicates = append(predicates, orgmembership.OrganizationIDEQ(*i.OrganizationID))
	}
	if i.OrganizationIDNEQ != nil {
		predicates = append(predicates, orgmembership.OrganizationIDNEQ(*i.OrganizationIDNEQ))
	}
	if len(i.OrganizationIDIn) > 0 {
		predicates = append(predicates, orgmembership.OrganizationIDIn(i.OrganizationIDIn...))
	}
	if len(i.OrganizationIDNotIn) > 0 {
		predicates = append(predicates, orgmembership.OrganizationIDNotIn(i.OrganizationIDNotIn...))
	}
	if i.OrganizationIDGT != nil {
		predicates = append(predicates, orgmembership.OrganizationIDGT(*i.OrganizationIDGT))
	}
	if i.OrganizationIDGTE != nil {
		predicates = append(predicates, orgmembership.OrganizationIDGTE(*i.OrganizationIDGTE))
	}
	if i.OrganizationIDLT != nil {
		predicates = append(predicates, orgmembership.OrganizationIDLT(*i.OrganizationIDLT))
	}
	if i.OrganizationIDLTE != nil {
		predicates = append(predicates, orgmembership.OrganizationIDLTE(*i.OrganizationIDLTE))
	}
	if i.OrganizationIDContains != nil {
		predicates = append(predicates, orgmembership.OrganizationIDContains(*i.OrganizationIDContains))
	}
	if i.OrganizationIDHasPrefix != nil {
		predicates = append(predicates, orgmembership.OrganizationIDHasPrefix(*i.OrganizationIDHasPrefix))
	}
	if i.OrganizationIDHasSuffix != nil {
		predicates = append(predicates, orgmembership.OrganizationIDHasSuffix(*i.OrganizationIDHasSuffix))
	}
	if i.OrganizationIDEqualFold != nil {
		predicates = append(predicates, orgmembership.OrganizationIDEqualFold(*i.OrganizationIDEqualFold))
	}
	if i.OrganizationIDContainsFold != nil {
		predicates = append(predicates, orgmembership.OrganizationIDContainsFold(*i.OrganizationIDContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, orgmembership.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, orgmembership.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, orgmembership.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, orgmembership.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, orgmembership.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, orgmembership.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, orgmembership.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, orgmembership.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, orgmembership.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, orgmembership.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, orgmembership.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, orgmembership.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, orgmembership.UserIDContainsFold(*i.UserIDContainsFold))
	}

	if i.HasOrganization != nil {
		p := orgmembership.HasOrganization()
		if !*i.HasOrganization {
			p = orgmembership.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrganizationWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOrganizationWith))
		for _, w := range i.HasOrganizationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrganizationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgmembership.HasOrganizationWith(with...))
	}
	if i.HasUser != nil {
		p := orgmembership.HasUser()
		if !*i.HasUser {
			p = orgmembership.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgmembership.HasUserWith(with...))
	}
	if i.HasEvents != nil {
		p := orgmembership.HasEvents()
		if !*i.HasEvents {
			p = orgmembership.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventsWith) > 0 {
		with := make([]predicate.Event, 0, len(i.HasEventsWith))
		for _, w := range i.HasEventsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgmembership.HasEventsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrgMembershipWhereInput
	case 1:
		return predicates[0], nil
	default:
		return orgmembership.And(predicates...), nil
	}
}

// OrgMembershipHistoryWhereInput represents a where input for filtering OrgMembershipHistory queries.
type OrgMembershipHistoryWhereInput struct {
	Predicates []predicate.OrgMembershipHistory  `json:"-"`
	Not        *OrgMembershipHistoryWhereInput   `json:"not,omitempty"`
	Or         []*OrgMembershipHistoryWhereInput `json:"or,omitempty"`
	And        []*OrgMembershipHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "role" field predicates.
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNEQ   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`

	// "organization_id" field predicates.
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIDNEQ          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIDGT           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIDGTE          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIDLT           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIDLTE          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrgMembershipHistoryWhereInput) AddPredicates(predicates ...predicate.OrgMembershipHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrgMembershipHistoryWhereInput filter on the OrgMembershipHistoryQuery builder.
func (i *OrgMembershipHistoryWhereInput) Filter(q *OrgMembershipHistoryQuery) (*OrgMembershipHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrgMembershipHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrgMembershipHistoryWhereInput is returned in case the OrgMembershipHistoryWhereInput is empty.
var ErrEmptyOrgMembershipHistoryWhereInput = errors.New("generated: empty predicate OrgMembershipHistoryWhereInput")

// P returns a predicate for filtering orgmembershiphistories.
// An error is returned if the input is empty or invalid.
func (i *OrgMembershipHistoryWhereInput) P() (predicate.OrgMembershipHistory, error) {
	var predicates []predicate.OrgMembershipHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, orgmembershiphistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrgMembershipHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, orgmembershiphistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrgMembershipHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, orgmembershiphistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, orgmembershiphistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, orgmembershiphistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, orgmembershiphistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, orgmembershiphistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, orgmembershiphistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, orgmembershiphistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, orgmembershiphistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, orgmembershiphistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, orgmembershiphistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, orgmembershiphistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, orgmembershiphistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, orgmembershiphistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, orgmembershiphistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, orgmembershiphistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, orgmembershiphistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, orgmembershiphistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, orgmembershiphistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, orgmembershiphistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, orgmembershiphistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, orgmembershiphistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, orgmembershiphistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, orgmembershiphistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, orgmembershiphistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, orgmembershiphistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, orgmembershiphistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, orgmembershiphistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, orgmembershiphistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, orgmembershiphistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, orgmembershiphistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, orgmembershiphistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, orgmembershiphistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, orgmembershiphistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, orgmembershiphistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, orgmembershiphistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, orgmembershiphistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, orgmembershiphistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, orgmembershiphistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, orgmembershiphistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, orgmembershiphistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Role != nil {
		predicates = append(predicates, orgmembershiphistory.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, orgmembershiphistory.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.RoleNotIn(i.RoleNotIn...))
	}
	if i.OrganizationID != nil {
		predicates = append(predicates, orgmembershiphistory.OrganizationIDEQ(*i.OrganizationID))
	}
	if i.OrganizationIDNEQ != nil {
		predicates = append(predicates, orgmembershiphistory.OrganizationIDNEQ(*i.OrganizationIDNEQ))
	}
	if len(i.OrganizationIDIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.OrganizationIDIn(i.OrganizationIDIn...))
	}
	if len(i.OrganizationIDNotIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.OrganizationIDNotIn(i.OrganizationIDNotIn...))
	}
	if i.OrganizationIDGT != nil {
		predicates = append(predicates, orgmembershiphistory.OrganizationIDGT(*i.OrganizationIDGT))
	}
	if i.OrganizationIDGTE != nil {
		predicates = append(predicates, orgmembershiphistory.OrganizationIDGTE(*i.OrganizationIDGTE))
	}
	if i.OrganizationIDLT != nil {
		predicates = append(predicates, orgmembershiphistory.OrganizationIDLT(*i.OrganizationIDLT))
	}
	if i.OrganizationIDLTE != nil {
		predicates = append(predicates, orgmembershiphistory.OrganizationIDLTE(*i.OrganizationIDLTE))
	}
	if i.OrganizationIDContains != nil {
		predicates = append(predicates, orgmembershiphistory.OrganizationIDContains(*i.OrganizationIDContains))
	}
	if i.OrganizationIDHasPrefix != nil {
		predicates = append(predicates, orgmembershiphistory.OrganizationIDHasPrefix(*i.OrganizationIDHasPrefix))
	}
	if i.OrganizationIDHasSuffix != nil {
		predicates = append(predicates, orgmembershiphistory.OrganizationIDHasSuffix(*i.OrganizationIDHasSuffix))
	}
	if i.OrganizationIDEqualFold != nil {
		predicates = append(predicates, orgmembershiphistory.OrganizationIDEqualFold(*i.OrganizationIDEqualFold))
	}
	if i.OrganizationIDContainsFold != nil {
		predicates = append(predicates, orgmembershiphistory.OrganizationIDContainsFold(*i.OrganizationIDContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, orgmembershiphistory.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, orgmembershiphistory.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, orgmembershiphistory.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, orgmembershiphistory.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, orgmembershiphistory.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, orgmembershiphistory.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, orgmembershiphistory.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, orgmembershiphistory.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, orgmembershiphistory.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, orgmembershiphistory.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, orgmembershiphistory.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, orgmembershiphistory.UserIDContainsFold(*i.UserIDContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrgMembershipHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return orgmembershiphistory.And(predicates...), nil
	}
}

// OrgSubscriptionWhereInput represents a where input for filtering OrgSubscription queries.
type OrgSubscriptionWhereInput struct {
	Predicates []predicate.OrgSubscription  `json:"-"`
	Not        *OrgSubscriptionWhereInput   `json:"not,omitempty"`
	Or         []*OrgSubscriptionWhereInput `json:"or,omitempty"`
	And        []*OrgSubscriptionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "stripe_subscription_id" field predicates.
	StripeSubscriptionID             *string  `json:"stripeSubscriptionID,omitempty"`
	StripeSubscriptionIDNEQ          *string  `json:"stripeSubscriptionIDNEQ,omitempty"`
	StripeSubscriptionIDIn           []string `json:"stripeSubscriptionIDIn,omitempty"`
	StripeSubscriptionIDNotIn        []string `json:"stripeSubscriptionIDNotIn,omitempty"`
	StripeSubscriptionIDGT           *string  `json:"stripeSubscriptionIDGT,omitempty"`
	StripeSubscriptionIDGTE          *string  `json:"stripeSubscriptionIDGTE,omitempty"`
	StripeSubscriptionIDLT           *string  `json:"stripeSubscriptionIDLT,omitempty"`
	StripeSubscriptionIDLTE          *string  `json:"stripeSubscriptionIDLTE,omitempty"`
	StripeSubscriptionIDContains     *string  `json:"stripeSubscriptionIDContains,omitempty"`
	StripeSubscriptionIDHasPrefix    *string  `json:"stripeSubscriptionIDHasPrefix,omitempty"`
	StripeSubscriptionIDHasSuffix    *string  `json:"stripeSubscriptionIDHasSuffix,omitempty"`
	StripeSubscriptionIDIsNil        bool     `json:"stripeSubscriptionIDIsNil,omitempty"`
	StripeSubscriptionIDNotNil       bool     `json:"stripeSubscriptionIDNotNil,omitempty"`
	StripeSubscriptionIDEqualFold    *string  `json:"stripeSubscriptionIDEqualFold,omitempty"`
	StripeSubscriptionIDContainsFold *string  `json:"stripeSubscriptionIDContainsFold,omitempty"`

	// "product_tier" field predicates.
	ProductTier             *string  `json:"productTier,omitempty"`
	ProductTierNEQ          *string  `json:"productTierNEQ,omitempty"`
	ProductTierIn           []string `json:"productTierIn,omitempty"`
	ProductTierNotIn        []string `json:"productTierNotIn,omitempty"`
	ProductTierGT           *string  `json:"productTierGT,omitempty"`
	ProductTierGTE          *string  `json:"productTierGTE,omitempty"`
	ProductTierLT           *string  `json:"productTierLT,omitempty"`
	ProductTierLTE          *string  `json:"productTierLTE,omitempty"`
	ProductTierContains     *string  `json:"productTierContains,omitempty"`
	ProductTierHasPrefix    *string  `json:"productTierHasPrefix,omitempty"`
	ProductTierHasSuffix    *string  `json:"productTierHasSuffix,omitempty"`
	ProductTierIsNil        bool     `json:"productTierIsNil,omitempty"`
	ProductTierNotNil       bool     `json:"productTierNotNil,omitempty"`
	ProductTierEqualFold    *string  `json:"productTierEqualFold,omitempty"`
	ProductTierContainsFold *string  `json:"productTierContainsFold,omitempty"`

	// "stripe_product_tier_id" field predicates.
	StripeProductTierID             *string  `json:"stripeProductTierID,omitempty"`
	StripeProductTierIDNEQ          *string  `json:"stripeProductTierIDNEQ,omitempty"`
	StripeProductTierIDIn           []string `json:"stripeProductTierIDIn,omitempty"`
	StripeProductTierIDNotIn        []string `json:"stripeProductTierIDNotIn,omitempty"`
	StripeProductTierIDGT           *string  `json:"stripeProductTierIDGT,omitempty"`
	StripeProductTierIDGTE          *string  `json:"stripeProductTierIDGTE,omitempty"`
	StripeProductTierIDLT           *string  `json:"stripeProductTierIDLT,omitempty"`
	StripeProductTierIDLTE          *string  `json:"stripeProductTierIDLTE,omitempty"`
	StripeProductTierIDContains     *string  `json:"stripeProductTierIDContains,omitempty"`
	StripeProductTierIDHasPrefix    *string  `json:"stripeProductTierIDHasPrefix,omitempty"`
	StripeProductTierIDHasSuffix    *string  `json:"stripeProductTierIDHasSuffix,omitempty"`
	StripeProductTierIDIsNil        bool     `json:"stripeProductTierIDIsNil,omitempty"`
	StripeProductTierIDNotNil       bool     `json:"stripeProductTierIDNotNil,omitempty"`
	StripeProductTierIDEqualFold    *string  `json:"stripeProductTierIDEqualFold,omitempty"`
	StripeProductTierIDContainsFold *string  `json:"stripeProductTierIDContainsFold,omitempty"`

	// "stripe_subscription_status" field predicates.
	StripeSubscriptionStatus             *string  `json:"stripeSubscriptionStatus,omitempty"`
	StripeSubscriptionStatusNEQ          *string  `json:"stripeSubscriptionStatusNEQ,omitempty"`
	StripeSubscriptionStatusIn           []string `json:"stripeSubscriptionStatusIn,omitempty"`
	StripeSubscriptionStatusNotIn        []string `json:"stripeSubscriptionStatusNotIn,omitempty"`
	StripeSubscriptionStatusGT           *string  `json:"stripeSubscriptionStatusGT,omitempty"`
	StripeSubscriptionStatusGTE          *string  `json:"stripeSubscriptionStatusGTE,omitempty"`
	StripeSubscriptionStatusLT           *string  `json:"stripeSubscriptionStatusLT,omitempty"`
	StripeSubscriptionStatusLTE          *string  `json:"stripeSubscriptionStatusLTE,omitempty"`
	StripeSubscriptionStatusContains     *string  `json:"stripeSubscriptionStatusContains,omitempty"`
	StripeSubscriptionStatusHasPrefix    *string  `json:"stripeSubscriptionStatusHasPrefix,omitempty"`
	StripeSubscriptionStatusHasSuffix    *string  `json:"stripeSubscriptionStatusHasSuffix,omitempty"`
	StripeSubscriptionStatusIsNil        bool     `json:"stripeSubscriptionStatusIsNil,omitempty"`
	StripeSubscriptionStatusNotNil       bool     `json:"stripeSubscriptionStatusNotNil,omitempty"`
	StripeSubscriptionStatusEqualFold    *string  `json:"stripeSubscriptionStatusEqualFold,omitempty"`
	StripeSubscriptionStatusContainsFold *string  `json:"stripeSubscriptionStatusContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "stripe_customer_id" field predicates.
	StripeCustomerID             *string  `json:"stripeCustomerID,omitempty"`
	StripeCustomerIDNEQ          *string  `json:"stripeCustomerIDNEQ,omitempty"`
	StripeCustomerIDIn           []string `json:"stripeCustomerIDIn,omitempty"`
	StripeCustomerIDNotIn        []string `json:"stripeCustomerIDNotIn,omitempty"`
	StripeCustomerIDGT           *string  `json:"stripeCustomerIDGT,omitempty"`
	StripeCustomerIDGTE          *string  `json:"stripeCustomerIDGTE,omitempty"`
	StripeCustomerIDLT           *string  `json:"stripeCustomerIDLT,omitempty"`
	StripeCustomerIDLTE          *string  `json:"stripeCustomerIDLTE,omitempty"`
	StripeCustomerIDContains     *string  `json:"stripeCustomerIDContains,omitempty"`
	StripeCustomerIDHasPrefix    *string  `json:"stripeCustomerIDHasPrefix,omitempty"`
	StripeCustomerIDHasSuffix    *string  `json:"stripeCustomerIDHasSuffix,omitempty"`
	StripeCustomerIDIsNil        bool     `json:"stripeCustomerIDIsNil,omitempty"`
	StripeCustomerIDNotNil       bool     `json:"stripeCustomerIDNotNil,omitempty"`
	StripeCustomerIDEqualFold    *string  `json:"stripeCustomerIDEqualFold,omitempty"`
	StripeCustomerIDContainsFold *string  `json:"stripeCustomerIDContainsFold,omitempty"`

	// "expires_at" field predicates.
	ExpiresAt       *time.Time  `json:"expiresAt,omitempty"`
	ExpiresAtNEQ    *time.Time  `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGT     *time.Time  `json:"expiresAtGT,omitempty"`
	ExpiresAtGTE    *time.Time  `json:"expiresAtGTE,omitempty"`
	ExpiresAtLT     *time.Time  `json:"expiresAtLT,omitempty"`
	ExpiresAtLTE    *time.Time  `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil bool        `json:"expiresAtNotNil,omitempty"`

	// "trial_expires_at" field predicates.
	TrialExpiresAt       *time.Time  `json:"trialExpiresAt,omitempty"`
	TrialExpiresAtNEQ    *time.Time  `json:"trialExpiresAtNEQ,omitempty"`
	TrialExpiresAtIn     []time.Time `json:"trialExpiresAtIn,omitempty"`
	TrialExpiresAtNotIn  []time.Time `json:"trialExpiresAtNotIn,omitempty"`
	TrialExpiresAtGT     *time.Time  `json:"trialExpiresAtGT,omitempty"`
	TrialExpiresAtGTE    *time.Time  `json:"trialExpiresAtGTE,omitempty"`
	TrialExpiresAtLT     *time.Time  `json:"trialExpiresAtLT,omitempty"`
	TrialExpiresAtLTE    *time.Time  `json:"trialExpiresAtLTE,omitempty"`
	TrialExpiresAtIsNil  bool        `json:"trialExpiresAtIsNil,omitempty"`
	TrialExpiresAtNotNil bool        `json:"trialExpiresAtNotNil,omitempty"`

	// "days_until_due" field predicates.
	DaysUntilDue             *string  `json:"daysUntilDue,omitempty"`
	DaysUntilDueNEQ          *string  `json:"daysUntilDueNEQ,omitempty"`
	DaysUntilDueIn           []string `json:"daysUntilDueIn,omitempty"`
	DaysUntilDueNotIn        []string `json:"daysUntilDueNotIn,omitempty"`
	DaysUntilDueGT           *string  `json:"daysUntilDueGT,omitempty"`
	DaysUntilDueGTE          *string  `json:"daysUntilDueGTE,omitempty"`
	DaysUntilDueLT           *string  `json:"daysUntilDueLT,omitempty"`
	DaysUntilDueLTE          *string  `json:"daysUntilDueLTE,omitempty"`
	DaysUntilDueContains     *string  `json:"daysUntilDueContains,omitempty"`
	DaysUntilDueHasPrefix    *string  `json:"daysUntilDueHasPrefix,omitempty"`
	DaysUntilDueHasSuffix    *string  `json:"daysUntilDueHasSuffix,omitempty"`
	DaysUntilDueIsNil        bool     `json:"daysUntilDueIsNil,omitempty"`
	DaysUntilDueNotNil       bool     `json:"daysUntilDueNotNil,omitempty"`
	DaysUntilDueEqualFold    *string  `json:"daysUntilDueEqualFold,omitempty"`
	DaysUntilDueContainsFold *string  `json:"daysUntilDueContainsFold,omitempty"`

	// "payment_method_added" field predicates.
	PaymentMethodAdded       *bool `json:"paymentMethodAdded,omitempty"`
	PaymentMethodAddedNEQ    *bool `json:"paymentMethodAddedNEQ,omitempty"`
	PaymentMethodAddedIsNil  bool  `json:"paymentMethodAddedIsNil,omitempty"`
	PaymentMethodAddedNotNil bool  `json:"paymentMethodAddedNotNil,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "events" edge predicates.
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrgSubscriptionWhereInput) AddPredicates(predicates ...predicate.OrgSubscription) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrgSubscriptionWhereInput filter on the OrgSubscriptionQuery builder.
func (i *OrgSubscriptionWhereInput) Filter(q *OrgSubscriptionQuery) (*OrgSubscriptionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrgSubscriptionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrgSubscriptionWhereInput is returned in case the OrgSubscriptionWhereInput is empty.
var ErrEmptyOrgSubscriptionWhereInput = errors.New("generated: empty predicate OrgSubscriptionWhereInput")

// P returns a predicate for filtering orgsubscriptions.
// An error is returned if the input is empty or invalid.
func (i *OrgSubscriptionWhereInput) P() (predicate.OrgSubscription, error) {
	var predicates []predicate.OrgSubscription
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, orgsubscription.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrgSubscription, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, orgsubscription.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrgSubscription, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, orgsubscription.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, orgsubscription.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, orgsubscription.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, orgsubscription.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, orgsubscription.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, orgsubscription.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, orgsubscription.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, orgsubscription.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, orgsubscription.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, orgsubscription.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, orgsubscription.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, orgsubscription.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, orgsubscription.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, orgsubscription.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, orgsubscription.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, orgsubscription.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, orgsubscription.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, orgsubscription.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, orgsubscription.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, orgsubscription.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, orgsubscription.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, orgsubscription.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, orgsubscription.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, orgsubscription.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, orgsubscription.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, orgsubscription.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, orgsubscription.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, orgsubscription.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, orgsubscription.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, orgsubscription.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, orgsubscription.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, orgsubscription.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, orgsubscription.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, orgsubscription.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, orgsubscription.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, orgsubscription.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, orgsubscription.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, orgsubscription.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, orgsubscription.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, orgsubscription.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, orgsubscription.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, orgsubscription.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, orgsubscription.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, orgsubscription.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, orgsubscription.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, orgsubscription.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, orgsubscription.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, orgsubscription.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, orgsubscription.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, orgsubscription.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, orgsubscription.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, orgsubscription.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, orgsubscription.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, orgsubscription.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, orgsubscription.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, orgsubscription.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, orgsubscription.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, orgsubscription.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, orgsubscription.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, orgsubscription.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, orgsubscription.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, orgsubscription.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, orgsubscription.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, orgsubscription.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, orgsubscription.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, orgsubscription.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, orgsubscription.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, orgsubscription.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, orgsubscription.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, orgsubscription.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, orgsubscription.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, orgsubscription.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, orgsubscription.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, orgsubscription.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, orgsubscription.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, orgsubscription.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.StripeSubscriptionID != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionIDEQ(*i.StripeSubscriptionID))
	}
	if i.StripeSubscriptionIDNEQ != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionIDNEQ(*i.StripeSubscriptionIDNEQ))
	}
	if len(i.StripeSubscriptionIDIn) > 0 {
		predicates = append(predicates, orgsubscription.StripeSubscriptionIDIn(i.StripeSubscriptionIDIn...))
	}
	if len(i.StripeSubscriptionIDNotIn) > 0 {
		predicates = append(predicates, orgsubscription.StripeSubscriptionIDNotIn(i.StripeSubscriptionIDNotIn...))
	}
	if i.StripeSubscriptionIDGT != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionIDGT(*i.StripeSubscriptionIDGT))
	}
	if i.StripeSubscriptionIDGTE != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionIDGTE(*i.StripeSubscriptionIDGTE))
	}
	if i.StripeSubscriptionIDLT != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionIDLT(*i.StripeSubscriptionIDLT))
	}
	if i.StripeSubscriptionIDLTE != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionIDLTE(*i.StripeSubscriptionIDLTE))
	}
	if i.StripeSubscriptionIDContains != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionIDContains(*i.StripeSubscriptionIDContains))
	}
	if i.StripeSubscriptionIDHasPrefix != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionIDHasPrefix(*i.StripeSubscriptionIDHasPrefix))
	}
	if i.StripeSubscriptionIDHasSuffix != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionIDHasSuffix(*i.StripeSubscriptionIDHasSuffix))
	}
	if i.StripeSubscriptionIDIsNil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionIDIsNil())
	}
	if i.StripeSubscriptionIDNotNil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionIDNotNil())
	}
	if i.StripeSubscriptionIDEqualFold != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionIDEqualFold(*i.StripeSubscriptionIDEqualFold))
	}
	if i.StripeSubscriptionIDContainsFold != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionIDContainsFold(*i.StripeSubscriptionIDContainsFold))
	}
	if i.ProductTier != nil {
		predicates = append(predicates, orgsubscription.ProductTierEQ(*i.ProductTier))
	}
	if i.ProductTierNEQ != nil {
		predicates = append(predicates, orgsubscription.ProductTierNEQ(*i.ProductTierNEQ))
	}
	if len(i.ProductTierIn) > 0 {
		predicates = append(predicates, orgsubscription.ProductTierIn(i.ProductTierIn...))
	}
	if len(i.ProductTierNotIn) > 0 {
		predicates = append(predicates, orgsubscription.ProductTierNotIn(i.ProductTierNotIn...))
	}
	if i.ProductTierGT != nil {
		predicates = append(predicates, orgsubscription.ProductTierGT(*i.ProductTierGT))
	}
	if i.ProductTierGTE != nil {
		predicates = append(predicates, orgsubscription.ProductTierGTE(*i.ProductTierGTE))
	}
	if i.ProductTierLT != nil {
		predicates = append(predicates, orgsubscription.ProductTierLT(*i.ProductTierLT))
	}
	if i.ProductTierLTE != nil {
		predicates = append(predicates, orgsubscription.ProductTierLTE(*i.ProductTierLTE))
	}
	if i.ProductTierContains != nil {
		predicates = append(predicates, orgsubscription.ProductTierContains(*i.ProductTierContains))
	}
	if i.ProductTierHasPrefix != nil {
		predicates = append(predicates, orgsubscription.ProductTierHasPrefix(*i.ProductTierHasPrefix))
	}
	if i.ProductTierHasSuffix != nil {
		predicates = append(predicates, orgsubscription.ProductTierHasSuffix(*i.ProductTierHasSuffix))
	}
	if i.ProductTierIsNil {
		predicates = append(predicates, orgsubscription.ProductTierIsNil())
	}
	if i.ProductTierNotNil {
		predicates = append(predicates, orgsubscription.ProductTierNotNil())
	}
	if i.ProductTierEqualFold != nil {
		predicates = append(predicates, orgsubscription.ProductTierEqualFold(*i.ProductTierEqualFold))
	}
	if i.ProductTierContainsFold != nil {
		predicates = append(predicates, orgsubscription.ProductTierContainsFold(*i.ProductTierContainsFold))
	}
	if i.StripeProductTierID != nil {
		predicates = append(predicates, orgsubscription.StripeProductTierIDEQ(*i.StripeProductTierID))
	}
	if i.StripeProductTierIDNEQ != nil {
		predicates = append(predicates, orgsubscription.StripeProductTierIDNEQ(*i.StripeProductTierIDNEQ))
	}
	if len(i.StripeProductTierIDIn) > 0 {
		predicates = append(predicates, orgsubscription.StripeProductTierIDIn(i.StripeProductTierIDIn...))
	}
	if len(i.StripeProductTierIDNotIn) > 0 {
		predicates = append(predicates, orgsubscription.StripeProductTierIDNotIn(i.StripeProductTierIDNotIn...))
	}
	if i.StripeProductTierIDGT != nil {
		predicates = append(predicates, orgsubscription.StripeProductTierIDGT(*i.StripeProductTierIDGT))
	}
	if i.StripeProductTierIDGTE != nil {
		predicates = append(predicates, orgsubscription.StripeProductTierIDGTE(*i.StripeProductTierIDGTE))
	}
	if i.StripeProductTierIDLT != nil {
		predicates = append(predicates, orgsubscription.StripeProductTierIDLT(*i.StripeProductTierIDLT))
	}
	if i.StripeProductTierIDLTE != nil {
		predicates = append(predicates, orgsubscription.StripeProductTierIDLTE(*i.StripeProductTierIDLTE))
	}
	if i.StripeProductTierIDContains != nil {
		predicates = append(predicates, orgsubscription.StripeProductTierIDContains(*i.StripeProductTierIDContains))
	}
	if i.StripeProductTierIDHasPrefix != nil {
		predicates = append(predicates, orgsubscription.StripeProductTierIDHasPrefix(*i.StripeProductTierIDHasPrefix))
	}
	if i.StripeProductTierIDHasSuffix != nil {
		predicates = append(predicates, orgsubscription.StripeProductTierIDHasSuffix(*i.StripeProductTierIDHasSuffix))
	}
	if i.StripeProductTierIDIsNil {
		predicates = append(predicates, orgsubscription.StripeProductTierIDIsNil())
	}
	if i.StripeProductTierIDNotNil {
		predicates = append(predicates, orgsubscription.StripeProductTierIDNotNil())
	}
	if i.StripeProductTierIDEqualFold != nil {
		predicates = append(predicates, orgsubscription.StripeProductTierIDEqualFold(*i.StripeProductTierIDEqualFold))
	}
	if i.StripeProductTierIDContainsFold != nil {
		predicates = append(predicates, orgsubscription.StripeProductTierIDContainsFold(*i.StripeProductTierIDContainsFold))
	}
	if i.StripeSubscriptionStatus != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionStatusEQ(*i.StripeSubscriptionStatus))
	}
	if i.StripeSubscriptionStatusNEQ != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionStatusNEQ(*i.StripeSubscriptionStatusNEQ))
	}
	if len(i.StripeSubscriptionStatusIn) > 0 {
		predicates = append(predicates, orgsubscription.StripeSubscriptionStatusIn(i.StripeSubscriptionStatusIn...))
	}
	if len(i.StripeSubscriptionStatusNotIn) > 0 {
		predicates = append(predicates, orgsubscription.StripeSubscriptionStatusNotIn(i.StripeSubscriptionStatusNotIn...))
	}
	if i.StripeSubscriptionStatusGT != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionStatusGT(*i.StripeSubscriptionStatusGT))
	}
	if i.StripeSubscriptionStatusGTE != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionStatusGTE(*i.StripeSubscriptionStatusGTE))
	}
	if i.StripeSubscriptionStatusLT != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionStatusLT(*i.StripeSubscriptionStatusLT))
	}
	if i.StripeSubscriptionStatusLTE != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionStatusLTE(*i.StripeSubscriptionStatusLTE))
	}
	if i.StripeSubscriptionStatusContains != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionStatusContains(*i.StripeSubscriptionStatusContains))
	}
	if i.StripeSubscriptionStatusHasPrefix != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionStatusHasPrefix(*i.StripeSubscriptionStatusHasPrefix))
	}
	if i.StripeSubscriptionStatusHasSuffix != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionStatusHasSuffix(*i.StripeSubscriptionStatusHasSuffix))
	}
	if i.StripeSubscriptionStatusIsNil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionStatusIsNil())
	}
	if i.StripeSubscriptionStatusNotNil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionStatusNotNil())
	}
	if i.StripeSubscriptionStatusEqualFold != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionStatusEqualFold(*i.StripeSubscriptionStatusEqualFold))
	}
	if i.StripeSubscriptionStatusContainsFold != nil {
		predicates = append(predicates, orgsubscription.StripeSubscriptionStatusContainsFold(*i.StripeSubscriptionStatusContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, orgsubscription.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, orgsubscription.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.StripeCustomerID != nil {
		predicates = append(predicates, orgsubscription.StripeCustomerIDEQ(*i.StripeCustomerID))
	}
	if i.StripeCustomerIDNEQ != nil {
		predicates = append(predicates, orgsubscription.StripeCustomerIDNEQ(*i.StripeCustomerIDNEQ))
	}
	if len(i.StripeCustomerIDIn) > 0 {
		predicates = append(predicates, orgsubscription.StripeCustomerIDIn(i.StripeCustomerIDIn...))
	}
	if len(i.StripeCustomerIDNotIn) > 0 {
		predicates = append(predicates, orgsubscription.StripeCustomerIDNotIn(i.StripeCustomerIDNotIn...))
	}
	if i.StripeCustomerIDGT != nil {
		predicates = append(predicates, orgsubscription.StripeCustomerIDGT(*i.StripeCustomerIDGT))
	}
	if i.StripeCustomerIDGTE != nil {
		predicates = append(predicates, orgsubscription.StripeCustomerIDGTE(*i.StripeCustomerIDGTE))
	}
	if i.StripeCustomerIDLT != nil {
		predicates = append(predicates, orgsubscription.StripeCustomerIDLT(*i.StripeCustomerIDLT))
	}
	if i.StripeCustomerIDLTE != nil {
		predicates = append(predicates, orgsubscription.StripeCustomerIDLTE(*i.StripeCustomerIDLTE))
	}
	if i.StripeCustomerIDContains != nil {
		predicates = append(predicates, orgsubscription.StripeCustomerIDContains(*i.StripeCustomerIDContains))
	}
	if i.StripeCustomerIDHasPrefix != nil {
		predicates = append(predicates, orgsubscription.StripeCustomerIDHasPrefix(*i.StripeCustomerIDHasPrefix))
	}
	if i.StripeCustomerIDHasSuffix != nil {
		predicates = append(predicates, orgsubscription.StripeCustomerIDHasSuffix(*i.StripeCustomerIDHasSuffix))
	}
	if i.StripeCustomerIDIsNil {
		predicates = append(predicates, orgsubscription.StripeCustomerIDIsNil())
	}
	if i.StripeCustomerIDNotNil {
		predicates = append(predicates, orgsubscription.StripeCustomerIDNotNil())
	}
	if i.StripeCustomerIDEqualFold != nil {
		predicates = append(predicates, orgsubscription.StripeCustomerIDEqualFold(*i.StripeCustomerIDEqualFold))
	}
	if i.StripeCustomerIDContainsFold != nil {
		predicates = append(predicates, orgsubscription.StripeCustomerIDContainsFold(*i.StripeCustomerIDContainsFold))
	}
	if i.ExpiresAt != nil {
		predicates = append(predicates, orgsubscription.ExpiresAtEQ(*i.ExpiresAt))
	}
	if i.ExpiresAtNEQ != nil {
		predicates = append(predicates, orgsubscription.ExpiresAtNEQ(*i.ExpiresAtNEQ))
	}
	if len(i.ExpiresAtIn) > 0 {
		predicates = append(predicates, orgsubscription.ExpiresAtIn(i.ExpiresAtIn...))
	}
	if len(i.ExpiresAtNotIn) > 0 {
		predicates = append(predicates, orgsubscription.ExpiresAtNotIn(i.ExpiresAtNotIn...))
	}
	if i.ExpiresAtGT != nil {
		predicates = append(predicates, orgsubscription.ExpiresAtGT(*i.ExpiresAtGT))
	}
	if i.ExpiresAtGTE != nil {
		predicates = append(predicates, orgsubscription.ExpiresAtGTE(*i.ExpiresAtGTE))
	}
	if i.ExpiresAtLT != nil {
		predicates = append(predicates, orgsubscription.ExpiresAtLT(*i.ExpiresAtLT))
	}
	if i.ExpiresAtLTE != nil {
		predicates = append(predicates, orgsubscription.ExpiresAtLTE(*i.ExpiresAtLTE))
	}
	if i.ExpiresAtIsNil {
		predicates = append(predicates, orgsubscription.ExpiresAtIsNil())
	}
	if i.ExpiresAtNotNil {
		predicates = append(predicates, orgsubscription.ExpiresAtNotNil())
	}
	if i.TrialExpiresAt != nil {
		predicates = append(predicates, orgsubscription.TrialExpiresAtEQ(*i.TrialExpiresAt))
	}
	if i.TrialExpiresAtNEQ != nil {
		predicates = append(predicates, orgsubscription.TrialExpiresAtNEQ(*i.TrialExpiresAtNEQ))
	}
	if len(i.TrialExpiresAtIn) > 0 {
		predicates = append(predicates, orgsubscription.TrialExpiresAtIn(i.TrialExpiresAtIn...))
	}
	if len(i.TrialExpiresAtNotIn) > 0 {
		predicates = append(predicates, orgsubscription.TrialExpiresAtNotIn(i.TrialExpiresAtNotIn...))
	}
	if i.TrialExpiresAtGT != nil {
		predicates = append(predicates, orgsubscription.TrialExpiresAtGT(*i.TrialExpiresAtGT))
	}
	if i.TrialExpiresAtGTE != nil {
		predicates = append(predicates, orgsubscription.TrialExpiresAtGTE(*i.TrialExpiresAtGTE))
	}
	if i.TrialExpiresAtLT != nil {
		predicates = append(predicates, orgsubscription.TrialExpiresAtLT(*i.TrialExpiresAtLT))
	}
	if i.TrialExpiresAtLTE != nil {
		predicates = append(predicates, orgsubscription.TrialExpiresAtLTE(*i.TrialExpiresAtLTE))
	}
	if i.TrialExpiresAtIsNil {
		predicates = append(predicates, orgsubscription.TrialExpiresAtIsNil())
	}
	if i.TrialExpiresAtNotNil {
		predicates = append(predicates, orgsubscription.TrialExpiresAtNotNil())
	}
	if i.DaysUntilDue != nil {
		predicates = append(predicates, orgsubscription.DaysUntilDueEQ(*i.DaysUntilDue))
	}
	if i.DaysUntilDueNEQ != nil {
		predicates = append(predicates, orgsubscription.DaysUntilDueNEQ(*i.DaysUntilDueNEQ))
	}
	if len(i.DaysUntilDueIn) > 0 {
		predicates = append(predicates, orgsubscription.DaysUntilDueIn(i.DaysUntilDueIn...))
	}
	if len(i.DaysUntilDueNotIn) > 0 {
		predicates = append(predicates, orgsubscription.DaysUntilDueNotIn(i.DaysUntilDueNotIn...))
	}
	if i.DaysUntilDueGT != nil {
		predicates = append(predicates, orgsubscription.DaysUntilDueGT(*i.DaysUntilDueGT))
	}
	if i.DaysUntilDueGTE != nil {
		predicates = append(predicates, orgsubscription.DaysUntilDueGTE(*i.DaysUntilDueGTE))
	}
	if i.DaysUntilDueLT != nil {
		predicates = append(predicates, orgsubscription.DaysUntilDueLT(*i.DaysUntilDueLT))
	}
	if i.DaysUntilDueLTE != nil {
		predicates = append(predicates, orgsubscription.DaysUntilDueLTE(*i.DaysUntilDueLTE))
	}
	if i.DaysUntilDueContains != nil {
		predicates = append(predicates, orgsubscription.DaysUntilDueContains(*i.DaysUntilDueContains))
	}
	if i.DaysUntilDueHasPrefix != nil {
		predicates = append(predicates, orgsubscription.DaysUntilDueHasPrefix(*i.DaysUntilDueHasPrefix))
	}
	if i.DaysUntilDueHasSuffix != nil {
		predicates = append(predicates, orgsubscription.DaysUntilDueHasSuffix(*i.DaysUntilDueHasSuffix))
	}
	if i.DaysUntilDueIsNil {
		predicates = append(predicates, orgsubscription.DaysUntilDueIsNil())
	}
	if i.DaysUntilDueNotNil {
		predicates = append(predicates, orgsubscription.DaysUntilDueNotNil())
	}
	if i.DaysUntilDueEqualFold != nil {
		predicates = append(predicates, orgsubscription.DaysUntilDueEqualFold(*i.DaysUntilDueEqualFold))
	}
	if i.DaysUntilDueContainsFold != nil {
		predicates = append(predicates, orgsubscription.DaysUntilDueContainsFold(*i.DaysUntilDueContainsFold))
	}
	if i.PaymentMethodAdded != nil {
		predicates = append(predicates, orgsubscription.PaymentMethodAddedEQ(*i.PaymentMethodAdded))
	}
	if i.PaymentMethodAddedNEQ != nil {
		predicates = append(predicates, orgsubscription.PaymentMethodAddedNEQ(*i.PaymentMethodAddedNEQ))
	}
	if i.PaymentMethodAddedIsNil {
		predicates = append(predicates, orgsubscription.PaymentMethodAddedIsNil())
	}
	if i.PaymentMethodAddedNotNil {
		predicates = append(predicates, orgsubscription.PaymentMethodAddedNotNil())
	}

	if i.HasOwner != nil {
		p := orgsubscription.HasOwner()
		if !*i.HasOwner {
			p = orgsubscription.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgsubscription.HasOwnerWith(with...))
	}
	if i.HasEvents != nil {
		p := orgsubscription.HasEvents()
		if !*i.HasEvents {
			p = orgsubscription.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventsWith) > 0 {
		with := make([]predicate.Event, 0, len(i.HasEventsWith))
		for _, w := range i.HasEventsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgsubscription.HasEventsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrgSubscriptionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return orgsubscription.And(predicates...), nil
	}
}

// OrgSubscriptionHistoryWhereInput represents a where input for filtering OrgSubscriptionHistory queries.
type OrgSubscriptionHistoryWhereInput struct {
	Predicates []predicate.OrgSubscriptionHistory  `json:"-"`
	Not        *OrgSubscriptionHistoryWhereInput   `json:"not,omitempty"`
	Or         []*OrgSubscriptionHistoryWhereInput `json:"or,omitempty"`
	And        []*OrgSubscriptionHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "stripe_subscription_id" field predicates.
	StripeSubscriptionID             *string  `json:"stripeSubscriptionID,omitempty"`
	StripeSubscriptionIDNEQ          *string  `json:"stripeSubscriptionIDNEQ,omitempty"`
	StripeSubscriptionIDIn           []string `json:"stripeSubscriptionIDIn,omitempty"`
	StripeSubscriptionIDNotIn        []string `json:"stripeSubscriptionIDNotIn,omitempty"`
	StripeSubscriptionIDGT           *string  `json:"stripeSubscriptionIDGT,omitempty"`
	StripeSubscriptionIDGTE          *string  `json:"stripeSubscriptionIDGTE,omitempty"`
	StripeSubscriptionIDLT           *string  `json:"stripeSubscriptionIDLT,omitempty"`
	StripeSubscriptionIDLTE          *string  `json:"stripeSubscriptionIDLTE,omitempty"`
	StripeSubscriptionIDContains     *string  `json:"stripeSubscriptionIDContains,omitempty"`
	StripeSubscriptionIDHasPrefix    *string  `json:"stripeSubscriptionIDHasPrefix,omitempty"`
	StripeSubscriptionIDHasSuffix    *string  `json:"stripeSubscriptionIDHasSuffix,omitempty"`
	StripeSubscriptionIDIsNil        bool     `json:"stripeSubscriptionIDIsNil,omitempty"`
	StripeSubscriptionIDNotNil       bool     `json:"stripeSubscriptionIDNotNil,omitempty"`
	StripeSubscriptionIDEqualFold    *string  `json:"stripeSubscriptionIDEqualFold,omitempty"`
	StripeSubscriptionIDContainsFold *string  `json:"stripeSubscriptionIDContainsFold,omitempty"`

	// "product_tier" field predicates.
	ProductTier             *string  `json:"productTier,omitempty"`
	ProductTierNEQ          *string  `json:"productTierNEQ,omitempty"`
	ProductTierIn           []string `json:"productTierIn,omitempty"`
	ProductTierNotIn        []string `json:"productTierNotIn,omitempty"`
	ProductTierGT           *string  `json:"productTierGT,omitempty"`
	ProductTierGTE          *string  `json:"productTierGTE,omitempty"`
	ProductTierLT           *string  `json:"productTierLT,omitempty"`
	ProductTierLTE          *string  `json:"productTierLTE,omitempty"`
	ProductTierContains     *string  `json:"productTierContains,omitempty"`
	ProductTierHasPrefix    *string  `json:"productTierHasPrefix,omitempty"`
	ProductTierHasSuffix    *string  `json:"productTierHasSuffix,omitempty"`
	ProductTierIsNil        bool     `json:"productTierIsNil,omitempty"`
	ProductTierNotNil       bool     `json:"productTierNotNil,omitempty"`
	ProductTierEqualFold    *string  `json:"productTierEqualFold,omitempty"`
	ProductTierContainsFold *string  `json:"productTierContainsFold,omitempty"`

	// "stripe_product_tier_id" field predicates.
	StripeProductTierID             *string  `json:"stripeProductTierID,omitempty"`
	StripeProductTierIDNEQ          *string  `json:"stripeProductTierIDNEQ,omitempty"`
	StripeProductTierIDIn           []string `json:"stripeProductTierIDIn,omitempty"`
	StripeProductTierIDNotIn        []string `json:"stripeProductTierIDNotIn,omitempty"`
	StripeProductTierIDGT           *string  `json:"stripeProductTierIDGT,omitempty"`
	StripeProductTierIDGTE          *string  `json:"stripeProductTierIDGTE,omitempty"`
	StripeProductTierIDLT           *string  `json:"stripeProductTierIDLT,omitempty"`
	StripeProductTierIDLTE          *string  `json:"stripeProductTierIDLTE,omitempty"`
	StripeProductTierIDContains     *string  `json:"stripeProductTierIDContains,omitempty"`
	StripeProductTierIDHasPrefix    *string  `json:"stripeProductTierIDHasPrefix,omitempty"`
	StripeProductTierIDHasSuffix    *string  `json:"stripeProductTierIDHasSuffix,omitempty"`
	StripeProductTierIDIsNil        bool     `json:"stripeProductTierIDIsNil,omitempty"`
	StripeProductTierIDNotNil       bool     `json:"stripeProductTierIDNotNil,omitempty"`
	StripeProductTierIDEqualFold    *string  `json:"stripeProductTierIDEqualFold,omitempty"`
	StripeProductTierIDContainsFold *string  `json:"stripeProductTierIDContainsFold,omitempty"`

	// "stripe_subscription_status" field predicates.
	StripeSubscriptionStatus             *string  `json:"stripeSubscriptionStatus,omitempty"`
	StripeSubscriptionStatusNEQ          *string  `json:"stripeSubscriptionStatusNEQ,omitempty"`
	StripeSubscriptionStatusIn           []string `json:"stripeSubscriptionStatusIn,omitempty"`
	StripeSubscriptionStatusNotIn        []string `json:"stripeSubscriptionStatusNotIn,omitempty"`
	StripeSubscriptionStatusGT           *string  `json:"stripeSubscriptionStatusGT,omitempty"`
	StripeSubscriptionStatusGTE          *string  `json:"stripeSubscriptionStatusGTE,omitempty"`
	StripeSubscriptionStatusLT           *string  `json:"stripeSubscriptionStatusLT,omitempty"`
	StripeSubscriptionStatusLTE          *string  `json:"stripeSubscriptionStatusLTE,omitempty"`
	StripeSubscriptionStatusContains     *string  `json:"stripeSubscriptionStatusContains,omitempty"`
	StripeSubscriptionStatusHasPrefix    *string  `json:"stripeSubscriptionStatusHasPrefix,omitempty"`
	StripeSubscriptionStatusHasSuffix    *string  `json:"stripeSubscriptionStatusHasSuffix,omitempty"`
	StripeSubscriptionStatusIsNil        bool     `json:"stripeSubscriptionStatusIsNil,omitempty"`
	StripeSubscriptionStatusNotNil       bool     `json:"stripeSubscriptionStatusNotNil,omitempty"`
	StripeSubscriptionStatusEqualFold    *string  `json:"stripeSubscriptionStatusEqualFold,omitempty"`
	StripeSubscriptionStatusContainsFold *string  `json:"stripeSubscriptionStatusContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "stripe_customer_id" field predicates.
	StripeCustomerID             *string  `json:"stripeCustomerID,omitempty"`
	StripeCustomerIDNEQ          *string  `json:"stripeCustomerIDNEQ,omitempty"`
	StripeCustomerIDIn           []string `json:"stripeCustomerIDIn,omitempty"`
	StripeCustomerIDNotIn        []string `json:"stripeCustomerIDNotIn,omitempty"`
	StripeCustomerIDGT           *string  `json:"stripeCustomerIDGT,omitempty"`
	StripeCustomerIDGTE          *string  `json:"stripeCustomerIDGTE,omitempty"`
	StripeCustomerIDLT           *string  `json:"stripeCustomerIDLT,omitempty"`
	StripeCustomerIDLTE          *string  `json:"stripeCustomerIDLTE,omitempty"`
	StripeCustomerIDContains     *string  `json:"stripeCustomerIDContains,omitempty"`
	StripeCustomerIDHasPrefix    *string  `json:"stripeCustomerIDHasPrefix,omitempty"`
	StripeCustomerIDHasSuffix    *string  `json:"stripeCustomerIDHasSuffix,omitempty"`
	StripeCustomerIDIsNil        bool     `json:"stripeCustomerIDIsNil,omitempty"`
	StripeCustomerIDNotNil       bool     `json:"stripeCustomerIDNotNil,omitempty"`
	StripeCustomerIDEqualFold    *string  `json:"stripeCustomerIDEqualFold,omitempty"`
	StripeCustomerIDContainsFold *string  `json:"stripeCustomerIDContainsFold,omitempty"`

	// "expires_at" field predicates.
	ExpiresAt       *time.Time  `json:"expiresAt,omitempty"`
	ExpiresAtNEQ    *time.Time  `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGT     *time.Time  `json:"expiresAtGT,omitempty"`
	ExpiresAtGTE    *time.Time  `json:"expiresAtGTE,omitempty"`
	ExpiresAtLT     *time.Time  `json:"expiresAtLT,omitempty"`
	ExpiresAtLTE    *time.Time  `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil bool        `json:"expiresAtNotNil,omitempty"`

	// "trial_expires_at" field predicates.
	TrialExpiresAt       *time.Time  `json:"trialExpiresAt,omitempty"`
	TrialExpiresAtNEQ    *time.Time  `json:"trialExpiresAtNEQ,omitempty"`
	TrialExpiresAtIn     []time.Time `json:"trialExpiresAtIn,omitempty"`
	TrialExpiresAtNotIn  []time.Time `json:"trialExpiresAtNotIn,omitempty"`
	TrialExpiresAtGT     *time.Time  `json:"trialExpiresAtGT,omitempty"`
	TrialExpiresAtGTE    *time.Time  `json:"trialExpiresAtGTE,omitempty"`
	TrialExpiresAtLT     *time.Time  `json:"trialExpiresAtLT,omitempty"`
	TrialExpiresAtLTE    *time.Time  `json:"trialExpiresAtLTE,omitempty"`
	TrialExpiresAtIsNil  bool        `json:"trialExpiresAtIsNil,omitempty"`
	TrialExpiresAtNotNil bool        `json:"trialExpiresAtNotNil,omitempty"`

	// "days_until_due" field predicates.
	DaysUntilDue             *string  `json:"daysUntilDue,omitempty"`
	DaysUntilDueNEQ          *string  `json:"daysUntilDueNEQ,omitempty"`
	DaysUntilDueIn           []string `json:"daysUntilDueIn,omitempty"`
	DaysUntilDueNotIn        []string `json:"daysUntilDueNotIn,omitempty"`
	DaysUntilDueGT           *string  `json:"daysUntilDueGT,omitempty"`
	DaysUntilDueGTE          *string  `json:"daysUntilDueGTE,omitempty"`
	DaysUntilDueLT           *string  `json:"daysUntilDueLT,omitempty"`
	DaysUntilDueLTE          *string  `json:"daysUntilDueLTE,omitempty"`
	DaysUntilDueContains     *string  `json:"daysUntilDueContains,omitempty"`
	DaysUntilDueHasPrefix    *string  `json:"daysUntilDueHasPrefix,omitempty"`
	DaysUntilDueHasSuffix    *string  `json:"daysUntilDueHasSuffix,omitempty"`
	DaysUntilDueIsNil        bool     `json:"daysUntilDueIsNil,omitempty"`
	DaysUntilDueNotNil       bool     `json:"daysUntilDueNotNil,omitempty"`
	DaysUntilDueEqualFold    *string  `json:"daysUntilDueEqualFold,omitempty"`
	DaysUntilDueContainsFold *string  `json:"daysUntilDueContainsFold,omitempty"`

	// "payment_method_added" field predicates.
	PaymentMethodAdded       *bool `json:"paymentMethodAdded,omitempty"`
	PaymentMethodAddedNEQ    *bool `json:"paymentMethodAddedNEQ,omitempty"`
	PaymentMethodAddedIsNil  bool  `json:"paymentMethodAddedIsNil,omitempty"`
	PaymentMethodAddedNotNil bool  `json:"paymentMethodAddedNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrgSubscriptionHistoryWhereInput) AddPredicates(predicates ...predicate.OrgSubscriptionHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrgSubscriptionHistoryWhereInput filter on the OrgSubscriptionHistoryQuery builder.
func (i *OrgSubscriptionHistoryWhereInput) Filter(q *OrgSubscriptionHistoryQuery) (*OrgSubscriptionHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrgSubscriptionHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrgSubscriptionHistoryWhereInput is returned in case the OrgSubscriptionHistoryWhereInput is empty.
var ErrEmptyOrgSubscriptionHistoryWhereInput = errors.New("generated: empty predicate OrgSubscriptionHistoryWhereInput")

// P returns a predicate for filtering orgsubscriptionhistories.
// An error is returned if the input is empty or invalid.
func (i *OrgSubscriptionHistoryWhereInput) P() (predicate.OrgSubscriptionHistory, error) {
	var predicates []predicate.OrgSubscriptionHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, orgsubscriptionhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrgSubscriptionHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, orgsubscriptionhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrgSubscriptionHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, orgsubscriptionhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, orgsubscriptionhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, orgsubscriptionhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, orgsubscriptionhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, orgsubscriptionhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, orgsubscriptionhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, orgsubscriptionhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, orgsubscriptionhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, orgsubscriptionhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, orgsubscriptionhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, orgsubscriptionhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, orgsubscriptionhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, orgsubscriptionhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, orgsubscriptionhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, orgsubscriptionhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, orgsubscriptionhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.StripeSubscriptionID != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionIDEQ(*i.StripeSubscriptionID))
	}
	if i.StripeSubscriptionIDNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionIDNEQ(*i.StripeSubscriptionIDNEQ))
	}
	if len(i.StripeSubscriptionIDIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionIDIn(i.StripeSubscriptionIDIn...))
	}
	if len(i.StripeSubscriptionIDNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionIDNotIn(i.StripeSubscriptionIDNotIn...))
	}
	if i.StripeSubscriptionIDGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionIDGT(*i.StripeSubscriptionIDGT))
	}
	if i.StripeSubscriptionIDGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionIDGTE(*i.StripeSubscriptionIDGTE))
	}
	if i.StripeSubscriptionIDLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionIDLT(*i.StripeSubscriptionIDLT))
	}
	if i.StripeSubscriptionIDLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionIDLTE(*i.StripeSubscriptionIDLTE))
	}
	if i.StripeSubscriptionIDContains != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionIDContains(*i.StripeSubscriptionIDContains))
	}
	if i.StripeSubscriptionIDHasPrefix != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionIDHasPrefix(*i.StripeSubscriptionIDHasPrefix))
	}
	if i.StripeSubscriptionIDHasSuffix != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionIDHasSuffix(*i.StripeSubscriptionIDHasSuffix))
	}
	if i.StripeSubscriptionIDIsNil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionIDIsNil())
	}
	if i.StripeSubscriptionIDNotNil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionIDNotNil())
	}
	if i.StripeSubscriptionIDEqualFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionIDEqualFold(*i.StripeSubscriptionIDEqualFold))
	}
	if i.StripeSubscriptionIDContainsFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionIDContainsFold(*i.StripeSubscriptionIDContainsFold))
	}
	if i.ProductTier != nil {
		predicates = append(predicates, orgsubscriptionhistory.ProductTierEQ(*i.ProductTier))
	}
	if i.ProductTierNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.ProductTierNEQ(*i.ProductTierNEQ))
	}
	if len(i.ProductTierIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.ProductTierIn(i.ProductTierIn...))
	}
	if len(i.ProductTierNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.ProductTierNotIn(i.ProductTierNotIn...))
	}
	if i.ProductTierGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.ProductTierGT(*i.ProductTierGT))
	}
	if i.ProductTierGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.ProductTierGTE(*i.ProductTierGTE))
	}
	if i.ProductTierLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.ProductTierLT(*i.ProductTierLT))
	}
	if i.ProductTierLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.ProductTierLTE(*i.ProductTierLTE))
	}
	if i.ProductTierContains != nil {
		predicates = append(predicates, orgsubscriptionhistory.ProductTierContains(*i.ProductTierContains))
	}
	if i.ProductTierHasPrefix != nil {
		predicates = append(predicates, orgsubscriptionhistory.ProductTierHasPrefix(*i.ProductTierHasPrefix))
	}
	if i.ProductTierHasSuffix != nil {
		predicates = append(predicates, orgsubscriptionhistory.ProductTierHasSuffix(*i.ProductTierHasSuffix))
	}
	if i.ProductTierIsNil {
		predicates = append(predicates, orgsubscriptionhistory.ProductTierIsNil())
	}
	if i.ProductTierNotNil {
		predicates = append(predicates, orgsubscriptionhistory.ProductTierNotNil())
	}
	if i.ProductTierEqualFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.ProductTierEqualFold(*i.ProductTierEqualFold))
	}
	if i.ProductTierContainsFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.ProductTierContainsFold(*i.ProductTierContainsFold))
	}
	if i.StripeProductTierID != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeProductTierIDEQ(*i.StripeProductTierID))
	}
	if i.StripeProductTierIDNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeProductTierIDNEQ(*i.StripeProductTierIDNEQ))
	}
	if len(i.StripeProductTierIDIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.StripeProductTierIDIn(i.StripeProductTierIDIn...))
	}
	if len(i.StripeProductTierIDNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.StripeProductTierIDNotIn(i.StripeProductTierIDNotIn...))
	}
	if i.StripeProductTierIDGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeProductTierIDGT(*i.StripeProductTierIDGT))
	}
	if i.StripeProductTierIDGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeProductTierIDGTE(*i.StripeProductTierIDGTE))
	}
	if i.StripeProductTierIDLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeProductTierIDLT(*i.StripeProductTierIDLT))
	}
	if i.StripeProductTierIDLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeProductTierIDLTE(*i.StripeProductTierIDLTE))
	}
	if i.StripeProductTierIDContains != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeProductTierIDContains(*i.StripeProductTierIDContains))
	}
	if i.StripeProductTierIDHasPrefix != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeProductTierIDHasPrefix(*i.StripeProductTierIDHasPrefix))
	}
	if i.StripeProductTierIDHasSuffix != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeProductTierIDHasSuffix(*i.StripeProductTierIDHasSuffix))
	}
	if i.StripeProductTierIDIsNil {
		predicates = append(predicates, orgsubscriptionhistory.StripeProductTierIDIsNil())
	}
	if i.StripeProductTierIDNotNil {
		predicates = append(predicates, orgsubscriptionhistory.StripeProductTierIDNotNil())
	}
	if i.StripeProductTierIDEqualFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeProductTierIDEqualFold(*i.StripeProductTierIDEqualFold))
	}
	if i.StripeProductTierIDContainsFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeProductTierIDContainsFold(*i.StripeProductTierIDContainsFold))
	}
	if i.StripeSubscriptionStatus != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionStatusEQ(*i.StripeSubscriptionStatus))
	}
	if i.StripeSubscriptionStatusNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionStatusNEQ(*i.StripeSubscriptionStatusNEQ))
	}
	if len(i.StripeSubscriptionStatusIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionStatusIn(i.StripeSubscriptionStatusIn...))
	}
	if len(i.StripeSubscriptionStatusNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionStatusNotIn(i.StripeSubscriptionStatusNotIn...))
	}
	if i.StripeSubscriptionStatusGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionStatusGT(*i.StripeSubscriptionStatusGT))
	}
	if i.StripeSubscriptionStatusGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionStatusGTE(*i.StripeSubscriptionStatusGTE))
	}
	if i.StripeSubscriptionStatusLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionStatusLT(*i.StripeSubscriptionStatusLT))
	}
	if i.StripeSubscriptionStatusLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionStatusLTE(*i.StripeSubscriptionStatusLTE))
	}
	if i.StripeSubscriptionStatusContains != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionStatusContains(*i.StripeSubscriptionStatusContains))
	}
	if i.StripeSubscriptionStatusHasPrefix != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionStatusHasPrefix(*i.StripeSubscriptionStatusHasPrefix))
	}
	if i.StripeSubscriptionStatusHasSuffix != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionStatusHasSuffix(*i.StripeSubscriptionStatusHasSuffix))
	}
	if i.StripeSubscriptionStatusIsNil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionStatusIsNil())
	}
	if i.StripeSubscriptionStatusNotNil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionStatusNotNil())
	}
	if i.StripeSubscriptionStatusEqualFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionStatusEqualFold(*i.StripeSubscriptionStatusEqualFold))
	}
	if i.StripeSubscriptionStatusContainsFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeSubscriptionStatusContainsFold(*i.StripeSubscriptionStatusContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, orgsubscriptionhistory.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.StripeCustomerID != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeCustomerIDEQ(*i.StripeCustomerID))
	}
	if i.StripeCustomerIDNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeCustomerIDNEQ(*i.StripeCustomerIDNEQ))
	}
	if len(i.StripeCustomerIDIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.StripeCustomerIDIn(i.StripeCustomerIDIn...))
	}
	if len(i.StripeCustomerIDNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.StripeCustomerIDNotIn(i.StripeCustomerIDNotIn...))
	}
	if i.StripeCustomerIDGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeCustomerIDGT(*i.StripeCustomerIDGT))
	}
	if i.StripeCustomerIDGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeCustomerIDGTE(*i.StripeCustomerIDGTE))
	}
	if i.StripeCustomerIDLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeCustomerIDLT(*i.StripeCustomerIDLT))
	}
	if i.StripeCustomerIDLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeCustomerIDLTE(*i.StripeCustomerIDLTE))
	}
	if i.StripeCustomerIDContains != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeCustomerIDContains(*i.StripeCustomerIDContains))
	}
	if i.StripeCustomerIDHasPrefix != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeCustomerIDHasPrefix(*i.StripeCustomerIDHasPrefix))
	}
	if i.StripeCustomerIDHasSuffix != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeCustomerIDHasSuffix(*i.StripeCustomerIDHasSuffix))
	}
	if i.StripeCustomerIDIsNil {
		predicates = append(predicates, orgsubscriptionhistory.StripeCustomerIDIsNil())
	}
	if i.StripeCustomerIDNotNil {
		predicates = append(predicates, orgsubscriptionhistory.StripeCustomerIDNotNil())
	}
	if i.StripeCustomerIDEqualFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeCustomerIDEqualFold(*i.StripeCustomerIDEqualFold))
	}
	if i.StripeCustomerIDContainsFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.StripeCustomerIDContainsFold(*i.StripeCustomerIDContainsFold))
	}
	if i.ExpiresAt != nil {
		predicates = append(predicates, orgsubscriptionhistory.ExpiresAtEQ(*i.ExpiresAt))
	}
	if i.ExpiresAtNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.ExpiresAtNEQ(*i.ExpiresAtNEQ))
	}
	if len(i.ExpiresAtIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.ExpiresAtIn(i.ExpiresAtIn...))
	}
	if len(i.ExpiresAtNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.ExpiresAtNotIn(i.ExpiresAtNotIn...))
	}
	if i.ExpiresAtGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.ExpiresAtGT(*i.ExpiresAtGT))
	}
	if i.ExpiresAtGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.ExpiresAtGTE(*i.ExpiresAtGTE))
	}
	if i.ExpiresAtLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.ExpiresAtLT(*i.ExpiresAtLT))
	}
	if i.ExpiresAtLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.ExpiresAtLTE(*i.ExpiresAtLTE))
	}
	if i.ExpiresAtIsNil {
		predicates = append(predicates, orgsubscriptionhistory.ExpiresAtIsNil())
	}
	if i.ExpiresAtNotNil {
		predicates = append(predicates, orgsubscriptionhistory.ExpiresAtNotNil())
	}
	if i.TrialExpiresAt != nil {
		predicates = append(predicates, orgsubscriptionhistory.TrialExpiresAtEQ(*i.TrialExpiresAt))
	}
	if i.TrialExpiresAtNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.TrialExpiresAtNEQ(*i.TrialExpiresAtNEQ))
	}
	if len(i.TrialExpiresAtIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.TrialExpiresAtIn(i.TrialExpiresAtIn...))
	}
	if len(i.TrialExpiresAtNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.TrialExpiresAtNotIn(i.TrialExpiresAtNotIn...))
	}
	if i.TrialExpiresAtGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.TrialExpiresAtGT(*i.TrialExpiresAtGT))
	}
	if i.TrialExpiresAtGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.TrialExpiresAtGTE(*i.TrialExpiresAtGTE))
	}
	if i.TrialExpiresAtLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.TrialExpiresAtLT(*i.TrialExpiresAtLT))
	}
	if i.TrialExpiresAtLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.TrialExpiresAtLTE(*i.TrialExpiresAtLTE))
	}
	if i.TrialExpiresAtIsNil {
		predicates = append(predicates, orgsubscriptionhistory.TrialExpiresAtIsNil())
	}
	if i.TrialExpiresAtNotNil {
		predicates = append(predicates, orgsubscriptionhistory.TrialExpiresAtNotNil())
	}
	if i.DaysUntilDue != nil {
		predicates = append(predicates, orgsubscriptionhistory.DaysUntilDueEQ(*i.DaysUntilDue))
	}
	if i.DaysUntilDueNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.DaysUntilDueNEQ(*i.DaysUntilDueNEQ))
	}
	if len(i.DaysUntilDueIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.DaysUntilDueIn(i.DaysUntilDueIn...))
	}
	if len(i.DaysUntilDueNotIn) > 0 {
		predicates = append(predicates, orgsubscriptionhistory.DaysUntilDueNotIn(i.DaysUntilDueNotIn...))
	}
	if i.DaysUntilDueGT != nil {
		predicates = append(predicates, orgsubscriptionhistory.DaysUntilDueGT(*i.DaysUntilDueGT))
	}
	if i.DaysUntilDueGTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.DaysUntilDueGTE(*i.DaysUntilDueGTE))
	}
	if i.DaysUntilDueLT != nil {
		predicates = append(predicates, orgsubscriptionhistory.DaysUntilDueLT(*i.DaysUntilDueLT))
	}
	if i.DaysUntilDueLTE != nil {
		predicates = append(predicates, orgsubscriptionhistory.DaysUntilDueLTE(*i.DaysUntilDueLTE))
	}
	if i.DaysUntilDueContains != nil {
		predicates = append(predicates, orgsubscriptionhistory.DaysUntilDueContains(*i.DaysUntilDueContains))
	}
	if i.DaysUntilDueHasPrefix != nil {
		predicates = append(predicates, orgsubscriptionhistory.DaysUntilDueHasPrefix(*i.DaysUntilDueHasPrefix))
	}
	if i.DaysUntilDueHasSuffix != nil {
		predicates = append(predicates, orgsubscriptionhistory.DaysUntilDueHasSuffix(*i.DaysUntilDueHasSuffix))
	}
	if i.DaysUntilDueIsNil {
		predicates = append(predicates, orgsubscriptionhistory.DaysUntilDueIsNil())
	}
	if i.DaysUntilDueNotNil {
		predicates = append(predicates, orgsubscriptionhistory.DaysUntilDueNotNil())
	}
	if i.DaysUntilDueEqualFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.DaysUntilDueEqualFold(*i.DaysUntilDueEqualFold))
	}
	if i.DaysUntilDueContainsFold != nil {
		predicates = append(predicates, orgsubscriptionhistory.DaysUntilDueContainsFold(*i.DaysUntilDueContainsFold))
	}
	if i.PaymentMethodAdded != nil {
		predicates = append(predicates, orgsubscriptionhistory.PaymentMethodAddedEQ(*i.PaymentMethodAdded))
	}
	if i.PaymentMethodAddedNEQ != nil {
		predicates = append(predicates, orgsubscriptionhistory.PaymentMethodAddedNEQ(*i.PaymentMethodAddedNEQ))
	}
	if i.PaymentMethodAddedIsNil {
		predicates = append(predicates, orgsubscriptionhistory.PaymentMethodAddedIsNil())
	}
	if i.PaymentMethodAddedNotNil {
		predicates = append(predicates, orgsubscriptionhistory.PaymentMethodAddedNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrgSubscriptionHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return orgsubscriptionhistory.And(predicates...), nil
	}
}

// OrganizationWhereInput represents a where input for filtering Organization queries.
type OrganizationWhereInput struct {
	Predicates []predicate.Organization  `json:"-"`
	Not        *OrganizationWhereInput   `json:"not,omitempty"`
	Or         []*OrganizationWhereInput `json:"or,omitempty"`
	And        []*OrganizationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "parent_organization_id" field predicates.
	ParentOrganizationID             *string  `json:"parentOrganizationID,omitempty"`
	ParentOrganizationIDNEQ          *string  `json:"parentOrganizationIDNEQ,omitempty"`
	ParentOrganizationIDIn           []string `json:"parentOrganizationIDIn,omitempty"`
	ParentOrganizationIDNotIn        []string `json:"parentOrganizationIDNotIn,omitempty"`
	ParentOrganizationIDGT           *string  `json:"parentOrganizationIDGT,omitempty"`
	ParentOrganizationIDGTE          *string  `json:"parentOrganizationIDGTE,omitempty"`
	ParentOrganizationIDLT           *string  `json:"parentOrganizationIDLT,omitempty"`
	ParentOrganizationIDLTE          *string  `json:"parentOrganizationIDLTE,omitempty"`
	ParentOrganizationIDContains     *string  `json:"parentOrganizationIDContains,omitempty"`
	ParentOrganizationIDHasPrefix    *string  `json:"parentOrganizationIDHasPrefix,omitempty"`
	ParentOrganizationIDHasSuffix    *string  `json:"parentOrganizationIDHasSuffix,omitempty"`
	ParentOrganizationIDIsNil        bool     `json:"parentOrganizationIDIsNil,omitempty"`
	ParentOrganizationIDNotNil       bool     `json:"parentOrganizationIDNotNil,omitempty"`
	ParentOrganizationIDEqualFold    *string  `json:"parentOrganizationIDEqualFold,omitempty"`
	ParentOrganizationIDContainsFold *string  `json:"parentOrganizationIDContainsFold,omitempty"`

	// "personal_org" field predicates.
	PersonalOrg       *bool `json:"personalOrg,omitempty"`
	PersonalOrgNEQ    *bool `json:"personalOrgNEQ,omitempty"`
	PersonalOrgIsNil  bool  `json:"personalOrgIsNil,omitempty"`
	PersonalOrgNotNil bool  `json:"personalOrgNotNil,omitempty"`

	// "avatar_remote_url" field predicates.
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNEQ          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGT           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGTE          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLT           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLTE          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        bool     `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       bool     `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`

	// "avatar_local_file_id" field predicates.
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIDNEQ          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIDGT           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIDGTE          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIDLT           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIDLTE          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        bool     `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       bool     `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`

	// "avatar_updated_at" field predicates.
	AvatarUpdatedAt       *time.Time  `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNEQ    *time.Time  `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGT     *time.Time  `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGTE    *time.Time  `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLT     *time.Time  `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLTE    *time.Time  `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil bool        `json:"avatarUpdatedAtNotNil,omitempty"`

	// "control_creators" edge predicates.
	HasControlCreators     *bool              `json:"hasControlCreators,omitempty"`
	HasControlCreatorsWith []*GroupWhereInput `json:"hasControlCreatorsWith,omitempty"`

	// "control_implementation_creators" edge predicates.
	HasControlImplementationCreators     *bool              `json:"hasControlImplementationCreators,omitempty"`
	HasControlImplementationCreatorsWith []*GroupWhereInput `json:"hasControlImplementationCreatorsWith,omitempty"`

	// "control_objective_creators" edge predicates.
	HasControlObjectiveCreators     *bool              `json:"hasControlObjectiveCreators,omitempty"`
	HasControlObjectiveCreatorsWith []*GroupWhereInput `json:"hasControlObjectiveCreatorsWith,omitempty"`

	// "evidence_creators" edge predicates.
	HasEvidenceCreators     *bool              `json:"hasEvidenceCreators,omitempty"`
	HasEvidenceCreatorsWith []*GroupWhereInput `json:"hasEvidenceCreatorsWith,omitempty"`

	// "group_creators" edge predicates.
	HasGroupCreators     *bool              `json:"hasGroupCreators,omitempty"`
	HasGroupCreatorsWith []*GroupWhereInput `json:"hasGroupCreatorsWith,omitempty"`

	// "internal_policy_creators" edge predicates.
	HasInternalPolicyCreators     *bool              `json:"hasInternalPolicyCreators,omitempty"`
	HasInternalPolicyCreatorsWith []*GroupWhereInput `json:"hasInternalPolicyCreatorsWith,omitempty"`

	// "mapped_control_creators" edge predicates.
	HasMappedControlCreators     *bool              `json:"hasMappedControlCreators,omitempty"`
	HasMappedControlCreatorsWith []*GroupWhereInput `json:"hasMappedControlCreatorsWith,omitempty"`

	// "narrative_creators" edge predicates.
	HasNarrativeCreators     *bool              `json:"hasNarrativeCreators,omitempty"`
	HasNarrativeCreatorsWith []*GroupWhereInput `json:"hasNarrativeCreatorsWith,omitempty"`

	// "procedure_creators" edge predicates.
	HasProcedureCreators     *bool              `json:"hasProcedureCreators,omitempty"`
	HasProcedureCreatorsWith []*GroupWhereInput `json:"hasProcedureCreatorsWith,omitempty"`

	// "program_creators" edge predicates.
	HasProgramCreators     *bool              `json:"hasProgramCreators,omitempty"`
	HasProgramCreatorsWith []*GroupWhereInput `json:"hasProgramCreatorsWith,omitempty"`

	// "risk_creators" edge predicates.
	HasRiskCreators     *bool              `json:"hasRiskCreators,omitempty"`
	HasRiskCreatorsWith []*GroupWhereInput `json:"hasRiskCreatorsWith,omitempty"`

	// "scheduled_job_creators" edge predicates.
	HasScheduledJobCreators     *bool              `json:"hasScheduledJobCreators,omitempty"`
	HasScheduledJobCreatorsWith []*GroupWhereInput `json:"hasScheduledJobCreatorsWith,omitempty"`

	// "standard_creators" edge predicates.
	HasStandardCreators     *bool              `json:"hasStandardCreators,omitempty"`
	HasStandardCreatorsWith []*GroupWhereInput `json:"hasStandardCreatorsWith,omitempty"`

	// "template_creators" edge predicates.
	HasTemplateCreators     *bool              `json:"hasTemplateCreators,omitempty"`
	HasTemplateCreatorsWith []*GroupWhereInput `json:"hasTemplateCreatorsWith,omitempty"`

	// "parent" edge predicates.
	HasParent     *bool                     `json:"hasParent,omitempty"`
	HasParentWith []*OrganizationWhereInput `json:"hasParentWith,omitempty"`

	// "children" edge predicates.
	HasChildren     *bool                     `json:"hasChildren,omitempty"`
	HasChildrenWith []*OrganizationWhereInput `json:"hasChildrenWith,omitempty"`

	// "setting" edge predicates.
	HasSetting     *bool                            `json:"hasSetting,omitempty"`
	HasSettingWith []*OrganizationSettingWhereInput `json:"hasSettingWith,omitempty"`

	// "personal_access_tokens" edge predicates.
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`

	// "api_tokens" edge predicates.
	HasAPITokens     *bool                 `json:"hasAPITokens,omitempty"`
	HasAPITokensWith []*APITokenWhereInput `json:"hasAPITokensWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`

	// "events" edge predicates.
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`

	// "secrets" edge predicates.
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`

	// "avatar_file" edge predicates.
	HasAvatarFile     *bool             `json:"hasAvatarFile,omitempty"`
	HasAvatarFileWith []*FileWhereInput `json:"hasAvatarFileWith,omitempty"`

	// "groups" edge predicates.
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`

	// "templates" edge predicates.
	HasTemplates     *bool                 `json:"hasTemplates,omitempty"`
	HasTemplatesWith []*TemplateWhereInput `json:"hasTemplatesWith,omitempty"`

	// "integrations" edge predicates.
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`

	// "documents" edge predicates.
	HasDocuments     *bool                     `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentDataWhereInput `json:"hasDocumentsWith,omitempty"`

	// "org_subscriptions" edge predicates.
	HasOrgSubscriptions     *bool                        `json:"hasOrgSubscriptions,omitempty"`
	HasOrgSubscriptionsWith []*OrgSubscriptionWhereInput `json:"hasOrgSubscriptionsWith,omitempty"`

	// "invites" edge predicates.
	HasInvites     *bool               `json:"hasInvites,omitempty"`
	HasInvitesWith []*InviteWhereInput `json:"hasInvitesWith,omitempty"`

	// "subscribers" edge predicates.
	HasSubscribers     *bool                   `json:"hasSubscribers,omitempty"`
	HasSubscribersWith []*SubscriberWhereInput `json:"hasSubscribersWith,omitempty"`

	// "entities" edge predicates.
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`

	// "entity_types" edge predicates.
	HasEntityTypes     *bool                   `json:"hasEntityTypes,omitempty"`
	HasEntityTypesWith []*EntityTypeWhereInput `json:"hasEntityTypesWith,omitempty"`

	// "contacts" edge predicates.
	HasContacts     *bool                `json:"hasContacts,omitempty"`
	HasContactsWith []*ContactWhereInput `json:"hasContactsWith,omitempty"`

	// "notes" edge predicates.
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`

	// "programs" edge predicates.
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`

	// "procedures" edge predicates.
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`

	// "internal_policies" edge predicates.
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`

	// "risks" edge predicates.
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`

	// "control_objectives" edge predicates.
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`

	// "narratives" edge predicates.
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`

	// "controls" edge predicates.
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`

	// "subcontrols" edge predicates.
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`

	// "control_implementations" edge predicates.
	HasControlImplementations     *bool                              `json:"hasControlImplementations,omitempty"`
	HasControlImplementationsWith []*ControlImplementationWhereInput `json:"hasControlImplementationsWith,omitempty"`

	// "mapped_controls" edge predicates.
	HasMappedControls     *bool                      `json:"hasMappedControls,omitempty"`
	HasMappedControlsWith []*MappedControlWhereInput `json:"hasMappedControlsWith,omitempty"`

	// "evidence" edge predicates.
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`

	// "standards" edge predicates.
	HasStandards     *bool                 `json:"hasStandards,omitempty"`
	HasStandardsWith []*StandardWhereInput `json:"hasStandardsWith,omitempty"`

	// "action_plans" edge predicates.
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`

	// "custom_domains" edge predicates.
	HasCustomDomains     *bool                     `json:"hasCustomDomains,omitempty"`
	HasCustomDomainsWith []*CustomDomainWhereInput `json:"hasCustomDomainsWith,omitempty"`

	// "job_runners" edge predicates.
	HasJobRunners     *bool                  `json:"hasJobRunners,omitempty"`
	HasJobRunnersWith []*JobRunnerWhereInput `json:"hasJobRunnersWith,omitempty"`

	// "job_runner_tokens" edge predicates.
	HasJobRunnerTokens     *bool                       `json:"hasJobRunnerTokens,omitempty"`
	HasJobRunnerTokensWith []*JobRunnerTokenWhereInput `json:"hasJobRunnerTokensWith,omitempty"`

	// "job_runner_registration_tokens" edge predicates.
	HasJobRunnerRegistrationTokens     *bool                                   `json:"hasJobRunnerRegistrationTokens,omitempty"`
	HasJobRunnerRegistrationTokensWith []*JobRunnerRegistrationTokenWhereInput `json:"hasJobRunnerRegistrationTokensWith,omitempty"`

	// "dns_verifications" edge predicates.
	HasDNSVerifications     *bool                        `json:"hasDNSVerifications,omitempty"`
	HasDNSVerificationsWith []*DNSVerificationWhereInput `json:"hasDNSVerificationsWith,omitempty"`

	// "jobs" edge predicates.
	HasJobs     *bool                     `json:"hasJobs,omitempty"`
	HasJobsWith []*ScheduledJobWhereInput `json:"hasJobsWith,omitempty"`

	// "scheduled_jobs" edge predicates.
	HasScheduledJobs     *bool                            `json:"hasScheduledJobs,omitempty"`
	HasScheduledJobsWith []*ControlScheduledJobWhereInput `json:"hasScheduledJobsWith,omitempty"`

	// "job_results" edge predicates.
	HasJobResults     *bool                  `json:"hasJobResults,omitempty"`
	HasJobResultsWith []*JobResultWhereInput `json:"hasJobResultsWith,omitempty"`

	// "scheduled_job_runs" edge predicates.
	HasScheduledJobRuns     *bool                        `json:"hasScheduledJobRuns,omitempty"`
	HasScheduledJobRunsWith []*ScheduledJobRunWhereInput `json:"hasScheduledJobRunsWith,omitempty"`

	// "members" edge predicates.
	HasMembers     *bool                      `json:"hasMembers,omitempty"`
	HasMembersWith []*OrgMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrganizationWhereInput) AddPredicates(predicates ...predicate.Organization) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrganizationWhereInput filter on the OrganizationQuery builder.
func (i *OrganizationWhereInput) Filter(q *OrganizationQuery) (*OrganizationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrganizationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrganizationWhereInput is returned in case the OrganizationWhereInput is empty.
var ErrEmptyOrganizationWhereInput = errors.New("generated: empty predicate OrganizationWhereInput")

// P returns a predicate for filtering organizations.
// An error is returned if the input is empty or invalid.
func (i *OrganizationWhereInput) P() (predicate.Organization, error) {
	var predicates []predicate.Organization
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, organization.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Organization, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, organization.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Organization, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, organization.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, organization.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, organization.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, organization.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, organization.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, organization.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, organization.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, organization.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, organization.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, organization.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, organization.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, organization.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, organization.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, organization.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, organization.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, organization.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, organization.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, organization.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, organization.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, organization.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, organization.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, organization.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, organization.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, organization.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, organization.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, organization.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, organization.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, organization.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, organization.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, organization.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, organization.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, organization.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, organization.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, organization.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, organization.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, organization.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, organization.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, organization.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, organization.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, organization.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, organization.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, organization.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, organization.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, organization.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, organization.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, organization.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, organization.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, organization.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, organization.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, organization.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, organization.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, organization.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, organization.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, organization.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, organization.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, organization.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, organization.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, organization.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, organization.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, organization.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, organization.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, organization.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, organization.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, organization.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, organization.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, organization.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, organization.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, organization.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, organization.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, organization.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, organization.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, organization.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, organization.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, organization.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.ParentOrganizationID != nil {
		predicates = append(predicates, organization.ParentOrganizationIDEQ(*i.ParentOrganizationID))
	}
	if i.ParentOrganizationIDNEQ != nil {
		predicates = append(predicates, organization.ParentOrganizationIDNEQ(*i.ParentOrganizationIDNEQ))
	}
	if len(i.ParentOrganizationIDIn) > 0 {
		predicates = append(predicates, organization.ParentOrganizationIDIn(i.ParentOrganizationIDIn...))
	}
	if len(i.ParentOrganizationIDNotIn) > 0 {
		predicates = append(predicates, organization.ParentOrganizationIDNotIn(i.ParentOrganizationIDNotIn...))
	}
	if i.ParentOrganizationIDGT != nil {
		predicates = append(predicates, organization.ParentOrganizationIDGT(*i.ParentOrganizationIDGT))
	}
	if i.ParentOrganizationIDGTE != nil {
		predicates = append(predicates, organization.ParentOrganizationIDGTE(*i.ParentOrganizationIDGTE))
	}
	if i.ParentOrganizationIDLT != nil {
		predicates = append(predicates, organization.ParentOrganizationIDLT(*i.ParentOrganizationIDLT))
	}
	if i.ParentOrganizationIDLTE != nil {
		predicates = append(predicates, organization.ParentOrganizationIDLTE(*i.ParentOrganizationIDLTE))
	}
	if i.ParentOrganizationIDContains != nil {
		predicates = append(predicates, organization.ParentOrganizationIDContains(*i.ParentOrganizationIDContains))
	}
	if i.ParentOrganizationIDHasPrefix != nil {
		predicates = append(predicates, organization.ParentOrganizationIDHasPrefix(*i.ParentOrganizationIDHasPrefix))
	}
	if i.ParentOrganizationIDHasSuffix != nil {
		predicates = append(predicates, organization.ParentOrganizationIDHasSuffix(*i.ParentOrganizationIDHasSuffix))
	}
	if i.ParentOrganizationIDIsNil {
		predicates = append(predicates, organization.ParentOrganizationIDIsNil())
	}
	if i.ParentOrganizationIDNotNil {
		predicates = append(predicates, organization.ParentOrganizationIDNotNil())
	}
	if i.ParentOrganizationIDEqualFold != nil {
		predicates = append(predicates, organization.ParentOrganizationIDEqualFold(*i.ParentOrganizationIDEqualFold))
	}
	if i.ParentOrganizationIDContainsFold != nil {
		predicates = append(predicates, organization.ParentOrganizationIDContainsFold(*i.ParentOrganizationIDContainsFold))
	}
	if i.PersonalOrg != nil {
		predicates = append(predicates, organization.PersonalOrgEQ(*i.PersonalOrg))
	}
	if i.PersonalOrgNEQ != nil {
		predicates = append(predicates, organization.PersonalOrgNEQ(*i.PersonalOrgNEQ))
	}
	if i.PersonalOrgIsNil {
		predicates = append(predicates, organization.PersonalOrgIsNil())
	}
	if i.PersonalOrgNotNil {
		predicates = append(predicates, organization.PersonalOrgNotNil())
	}
	if i.AvatarRemoteURL != nil {
		predicates = append(predicates, organization.AvatarRemoteURLEQ(*i.AvatarRemoteURL))
	}
	if i.AvatarRemoteURLNEQ != nil {
		predicates = append(predicates, organization.AvatarRemoteURLNEQ(*i.AvatarRemoteURLNEQ))
	}
	if len(i.AvatarRemoteURLIn) > 0 {
		predicates = append(predicates, organization.AvatarRemoteURLIn(i.AvatarRemoteURLIn...))
	}
	if len(i.AvatarRemoteURLNotIn) > 0 {
		predicates = append(predicates, organization.AvatarRemoteURLNotIn(i.AvatarRemoteURLNotIn...))
	}
	if i.AvatarRemoteURLGT != nil {
		predicates = append(predicates, organization.AvatarRemoteURLGT(*i.AvatarRemoteURLGT))
	}
	if i.AvatarRemoteURLGTE != nil {
		predicates = append(predicates, organization.AvatarRemoteURLGTE(*i.AvatarRemoteURLGTE))
	}
	if i.AvatarRemoteURLLT != nil {
		predicates = append(predicates, organization.AvatarRemoteURLLT(*i.AvatarRemoteURLLT))
	}
	if i.AvatarRemoteURLLTE != nil {
		predicates = append(predicates, organization.AvatarRemoteURLLTE(*i.AvatarRemoteURLLTE))
	}
	if i.AvatarRemoteURLContains != nil {
		predicates = append(predicates, organization.AvatarRemoteURLContains(*i.AvatarRemoteURLContains))
	}
	if i.AvatarRemoteURLHasPrefix != nil {
		predicates = append(predicates, organization.AvatarRemoteURLHasPrefix(*i.AvatarRemoteURLHasPrefix))
	}
	if i.AvatarRemoteURLHasSuffix != nil {
		predicates = append(predicates, organization.AvatarRemoteURLHasSuffix(*i.AvatarRemoteURLHasSuffix))
	}
	if i.AvatarRemoteURLIsNil {
		predicates = append(predicates, organization.AvatarRemoteURLIsNil())
	}
	if i.AvatarRemoteURLNotNil {
		predicates = append(predicates, organization.AvatarRemoteURLNotNil())
	}
	if i.AvatarRemoteURLEqualFold != nil {
		predicates = append(predicates, organization.AvatarRemoteURLEqualFold(*i.AvatarRemoteURLEqualFold))
	}
	if i.AvatarRemoteURLContainsFold != nil {
		predicates = append(predicates, organization.AvatarRemoteURLContainsFold(*i.AvatarRemoteURLContainsFold))
	}
	if i.AvatarLocalFileID != nil {
		predicates = append(predicates, organization.AvatarLocalFileIDEQ(*i.AvatarLocalFileID))
	}
	if i.AvatarLocalFileIDNEQ != nil {
		predicates = append(predicates, organization.AvatarLocalFileIDNEQ(*i.AvatarLocalFileIDNEQ))
	}
	if len(i.AvatarLocalFileIDIn) > 0 {
		predicates = append(predicates, organization.AvatarLocalFileIDIn(i.AvatarLocalFileIDIn...))
	}
	if len(i.AvatarLocalFileIDNotIn) > 0 {
		predicates = append(predicates, organization.AvatarLocalFileIDNotIn(i.AvatarLocalFileIDNotIn...))
	}
	if i.AvatarLocalFileIDGT != nil {
		predicates = append(predicates, organization.AvatarLocalFileIDGT(*i.AvatarLocalFileIDGT))
	}
	if i.AvatarLocalFileIDGTE != nil {
		predicates = append(predicates, organization.AvatarLocalFileIDGTE(*i.AvatarLocalFileIDGTE))
	}
	if i.AvatarLocalFileIDLT != nil {
		predicates = append(predicates, organization.AvatarLocalFileIDLT(*i.AvatarLocalFileIDLT))
	}
	if i.AvatarLocalFileIDLTE != nil {
		predicates = append(predicates, organization.AvatarLocalFileIDLTE(*i.AvatarLocalFileIDLTE))
	}
	if i.AvatarLocalFileIDContains != nil {
		predicates = append(predicates, organization.AvatarLocalFileIDContains(*i.AvatarLocalFileIDContains))
	}
	if i.AvatarLocalFileIDHasPrefix != nil {
		predicates = append(predicates, organization.AvatarLocalFileIDHasPrefix(*i.AvatarLocalFileIDHasPrefix))
	}
	if i.AvatarLocalFileIDHasSuffix != nil {
		predicates = append(predicates, organization.AvatarLocalFileIDHasSuffix(*i.AvatarLocalFileIDHasSuffix))
	}
	if i.AvatarLocalFileIDIsNil {
		predicates = append(predicates, organization.AvatarLocalFileIDIsNil())
	}
	if i.AvatarLocalFileIDNotNil {
		predicates = append(predicates, organization.AvatarLocalFileIDNotNil())
	}
	if i.AvatarLocalFileIDEqualFold != nil {
		predicates = append(predicates, organization.AvatarLocalFileIDEqualFold(*i.AvatarLocalFileIDEqualFold))
	}
	if i.AvatarLocalFileIDContainsFold != nil {
		predicates = append(predicates, organization.AvatarLocalFileIDContainsFold(*i.AvatarLocalFileIDContainsFold))
	}
	if i.AvatarUpdatedAt != nil {
		predicates = append(predicates, organization.AvatarUpdatedAtEQ(*i.AvatarUpdatedAt))
	}
	if i.AvatarUpdatedAtNEQ != nil {
		predicates = append(predicates, organization.AvatarUpdatedAtNEQ(*i.AvatarUpdatedAtNEQ))
	}
	if len(i.AvatarUpdatedAtIn) > 0 {
		predicates = append(predicates, organization.AvatarUpdatedAtIn(i.AvatarUpdatedAtIn...))
	}
	if len(i.AvatarUpdatedAtNotIn) > 0 {
		predicates = append(predicates, organization.AvatarUpdatedAtNotIn(i.AvatarUpdatedAtNotIn...))
	}
	if i.AvatarUpdatedAtGT != nil {
		predicates = append(predicates, organization.AvatarUpdatedAtGT(*i.AvatarUpdatedAtGT))
	}
	if i.AvatarUpdatedAtGTE != nil {
		predicates = append(predicates, organization.AvatarUpdatedAtGTE(*i.AvatarUpdatedAtGTE))
	}
	if i.AvatarUpdatedAtLT != nil {
		predicates = append(predicates, organization.AvatarUpdatedAtLT(*i.AvatarUpdatedAtLT))
	}
	if i.AvatarUpdatedAtLTE != nil {
		predicates = append(predicates, organization.AvatarUpdatedAtLTE(*i.AvatarUpdatedAtLTE))
	}
	if i.AvatarUpdatedAtIsNil {
		predicates = append(predicates, organization.AvatarUpdatedAtIsNil())
	}
	if i.AvatarUpdatedAtNotNil {
		predicates = append(predicates, organization.AvatarUpdatedAtNotNil())
	}

	if i.HasControlCreators != nil {
		p := organization.HasControlCreators()
		if !*i.HasControlCreators {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlCreatorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasControlCreatorsWith))
		for _, w := range i.HasControlCreatorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlCreatorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasControlCreatorsWith(with...))
	}
	if i.HasControlImplementationCreators != nil {
		p := organization.HasControlImplementationCreators()
		if !*i.HasControlImplementationCreators {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlImplementationCreatorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasControlImplementationCreatorsWith))
		for _, w := range i.HasControlImplementationCreatorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlImplementationCreatorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasControlImplementationCreatorsWith(with...))
	}
	if i.HasControlObjectiveCreators != nil {
		p := organization.HasControlObjectiveCreators()
		if !*i.HasControlObjectiveCreators {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlObjectiveCreatorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasControlObjectiveCreatorsWith))
		for _, w := range i.HasControlObjectiveCreatorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlObjectiveCreatorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasControlObjectiveCreatorsWith(with...))
	}
	if i.HasEvidenceCreators != nil {
		p := organization.HasEvidenceCreators()
		if !*i.HasEvidenceCreators {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEvidenceCreatorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasEvidenceCreatorsWith))
		for _, w := range i.HasEvidenceCreatorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEvidenceCreatorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasEvidenceCreatorsWith(with...))
	}
	if i.HasGroupCreators != nil {
		p := organization.HasGroupCreators()
		if !*i.HasGroupCreators {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupCreatorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasGroupCreatorsWith))
		for _, w := range i.HasGroupCreatorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGroupCreatorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasGroupCreatorsWith(with...))
	}
	if i.HasInternalPolicyCreators != nil {
		p := organization.HasInternalPolicyCreators()
		if !*i.HasInternalPolicyCreators {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInternalPolicyCreatorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasInternalPolicyCreatorsWith))
		for _, w := range i.HasInternalPolicyCreatorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInternalPolicyCreatorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasInternalPolicyCreatorsWith(with...))
	}
	if i.HasMappedControlCreators != nil {
		p := organization.HasMappedControlCreators()
		if !*i.HasMappedControlCreators {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMappedControlCreatorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasMappedControlCreatorsWith))
		for _, w := range i.HasMappedControlCreatorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMappedControlCreatorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasMappedControlCreatorsWith(with...))
	}
	if i.HasNarrativeCreators != nil {
		p := organization.HasNarrativeCreators()
		if !*i.HasNarrativeCreators {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNarrativeCreatorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasNarrativeCreatorsWith))
		for _, w := range i.HasNarrativeCreatorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNarrativeCreatorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasNarrativeCreatorsWith(with...))
	}
	if i.HasProcedureCreators != nil {
		p := organization.HasProcedureCreators()
		if !*i.HasProcedureCreators {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProcedureCreatorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasProcedureCreatorsWith))
		for _, w := range i.HasProcedureCreatorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProcedureCreatorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasProcedureCreatorsWith(with...))
	}
	if i.HasProgramCreators != nil {
		p := organization.HasProgramCreators()
		if !*i.HasProgramCreators {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramCreatorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasProgramCreatorsWith))
		for _, w := range i.HasProgramCreatorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramCreatorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasProgramCreatorsWith(with...))
	}
	if i.HasRiskCreators != nil {
		p := organization.HasRiskCreators()
		if !*i.HasRiskCreators {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRiskCreatorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasRiskCreatorsWith))
		for _, w := range i.HasRiskCreatorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRiskCreatorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasRiskCreatorsWith(with...))
	}
	if i.HasScheduledJobCreators != nil {
		p := organization.HasScheduledJobCreators()
		if !*i.HasScheduledJobCreators {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScheduledJobCreatorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasScheduledJobCreatorsWith))
		for _, w := range i.HasScheduledJobCreatorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasScheduledJobCreatorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasScheduledJobCreatorsWith(with...))
	}
	if i.HasStandardCreators != nil {
		p := organization.HasStandardCreators()
		if !*i.HasStandardCreators {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStandardCreatorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasStandardCreatorsWith))
		for _, w := range i.HasStandardCreatorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStandardCreatorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasStandardCreatorsWith(with...))
	}
	if i.HasTemplateCreators != nil {
		p := organization.HasTemplateCreators()
		if !*i.HasTemplateCreators {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTemplateCreatorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasTemplateCreatorsWith))
		for _, w := range i.HasTemplateCreatorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTemplateCreatorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasTemplateCreatorsWith(with...))
	}
	if i.HasParent != nil {
		p := organization.HasParent()
		if !*i.HasParent {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasParentWith))
		for _, w := range i.HasParentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasParentWith(with...))
	}
	if i.HasChildren != nil {
		p := organization.HasChildren()
		if !*i.HasChildren {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildrenWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasChildrenWith))
		for _, w := range i.HasChildrenWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildrenWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasChildrenWith(with...))
	}
	if i.HasSetting != nil {
		p := organization.HasSetting()
		if !*i.HasSetting {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSettingWith) > 0 {
		with := make([]predicate.OrganizationSetting, 0, len(i.HasSettingWith))
		for _, w := range i.HasSettingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSettingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasSettingWith(with...))
	}
	if i.HasPersonalAccessTokens != nil {
		p := organization.HasPersonalAccessTokens()
		if !*i.HasPersonalAccessTokens {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPersonalAccessTokensWith) > 0 {
		with := make([]predicate.PersonalAccessToken, 0, len(i.HasPersonalAccessTokensWith))
		for _, w := range i.HasPersonalAccessTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPersonalAccessTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasPersonalAccessTokensWith(with...))
	}
	if i.HasAPITokens != nil {
		p := organization.HasAPITokens()
		if !*i.HasAPITokens {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPITokensWith) > 0 {
		with := make([]predicate.APIToken, 0, len(i.HasAPITokensWith))
		for _, w := range i.HasAPITokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPITokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasAPITokensWith(with...))
	}
	if i.HasUsers != nil {
		p := organization.HasUsers()
		if !*i.HasUsers {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasUsersWith(with...))
	}
	if i.HasFiles != nil {
		p := organization.HasFiles()
		if !*i.HasFiles {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasFilesWith(with...))
	}
	if i.HasEvents != nil {
		p := organization.HasEvents()
		if !*i.HasEvents {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventsWith) > 0 {
		with := make([]predicate.Event, 0, len(i.HasEventsWith))
		for _, w := range i.HasEventsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasEventsWith(with...))
	}
	if i.HasSecrets != nil {
		p := organization.HasSecrets()
		if !*i.HasSecrets {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSecretsWith) > 0 {
		with := make([]predicate.Hush, 0, len(i.HasSecretsWith))
		for _, w := range i.HasSecretsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSecretsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasSecretsWith(with...))
	}
	if i.HasAvatarFile != nil {
		p := organization.HasAvatarFile()
		if !*i.HasAvatarFile {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAvatarFileWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasAvatarFileWith))
		for _, w := range i.HasAvatarFileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAvatarFileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasAvatarFileWith(with...))
	}
	if i.HasGroups != nil {
		p := organization.HasGroups()
		if !*i.HasGroups {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasGroupsWith))
		for _, w := range i.HasGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasGroupsWith(with...))
	}
	if i.HasTemplates != nil {
		p := organization.HasTemplates()
		if !*i.HasTemplates {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTemplatesWith) > 0 {
		with := make([]predicate.Template, 0, len(i.HasTemplatesWith))
		for _, w := range i.HasTemplatesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTemplatesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasTemplatesWith(with...))
	}
	if i.HasIntegrations != nil {
		p := organization.HasIntegrations()
		if !*i.HasIntegrations {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIntegrationsWith) > 0 {
		with := make([]predicate.Integration, 0, len(i.HasIntegrationsWith))
		for _, w := range i.HasIntegrationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasIntegrationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasIntegrationsWith(with...))
	}
	if i.HasDocuments != nil {
		p := organization.HasDocuments()
		if !*i.HasDocuments {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentsWith) > 0 {
		with := make([]predicate.DocumentData, 0, len(i.HasDocumentsWith))
		for _, w := range i.HasDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasDocumentsWith(with...))
	}
	if i.HasOrgSubscriptions != nil {
		p := organization.HasOrgSubscriptions()
		if !*i.HasOrgSubscriptions {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrgSubscriptionsWith) > 0 {
		with := make([]predicate.OrgSubscription, 0, len(i.HasOrgSubscriptionsWith))
		for _, w := range i.HasOrgSubscriptionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrgSubscriptionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasOrgSubscriptionsWith(with...))
	}
	if i.HasInvites != nil {
		p := organization.HasInvites()
		if !*i.HasInvites {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInvitesWith) > 0 {
		with := make([]predicate.Invite, 0, len(i.HasInvitesWith))
		for _, w := range i.HasInvitesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInvitesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasInvitesWith(with...))
	}
	if i.HasSubscribers != nil {
		p := organization.HasSubscribers()
		if !*i.HasSubscribers {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubscribersWith) > 0 {
		with := make([]predicate.Subscriber, 0, len(i.HasSubscribersWith))
		for _, w := range i.HasSubscribersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubscribersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasSubscribersWith(with...))
	}
	if i.HasEntities != nil {
		p := organization.HasEntities()
		if !*i.HasEntities {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEntitiesWith) > 0 {
		with := make([]predicate.Entity, 0, len(i.HasEntitiesWith))
		for _, w := range i.HasEntitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEntitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasEntitiesWith(with...))
	}
	if i.HasEntityTypes != nil {
		p := organization.HasEntityTypes()
		if !*i.HasEntityTypes {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEntityTypesWith) > 0 {
		with := make([]predicate.EntityType, 0, len(i.HasEntityTypesWith))
		for _, w := range i.HasEntityTypesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEntityTypesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasEntityTypesWith(with...))
	}
	if i.HasContacts != nil {
		p := organization.HasContacts()
		if !*i.HasContacts {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasContactsWith) > 0 {
		with := make([]predicate.Contact, 0, len(i.HasContactsWith))
		for _, w := range i.HasContactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasContactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasContactsWith(with...))
	}
	if i.HasNotes != nil {
		p := organization.HasNotes()
		if !*i.HasNotes {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNotesWith) > 0 {
		with := make([]predicate.Note, 0, len(i.HasNotesWith))
		for _, w := range i.HasNotesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNotesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasNotesWith(with...))
	}
	if i.HasTasks != nil {
		p := organization.HasTasks()
		if !*i.HasTasks {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasTasksWith(with...))
	}
	if i.HasPrograms != nil {
		p := organization.HasPrograms()
		if !*i.HasPrograms {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramsWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramsWith))
		for _, w := range i.HasProgramsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasProgramsWith(with...))
	}
	if i.HasProcedures != nil {
		p := organization.HasProcedures()
		if !*i.HasProcedures {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProceduresWith) > 0 {
		with := make([]predicate.Procedure, 0, len(i.HasProceduresWith))
		for _, w := range i.HasProceduresWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProceduresWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasProceduresWith(with...))
	}
	if i.HasInternalPolicies != nil {
		p := organization.HasInternalPolicies()
		if !*i.HasInternalPolicies {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInternalPoliciesWith) > 0 {
		with := make([]predicate.InternalPolicy, 0, len(i.HasInternalPoliciesWith))
		for _, w := range i.HasInternalPoliciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInternalPoliciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasInternalPoliciesWith(with...))
	}
	if i.HasRisks != nil {
		p := organization.HasRisks()
		if !*i.HasRisks {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRisksWith) > 0 {
		with := make([]predicate.Risk, 0, len(i.HasRisksWith))
		for _, w := range i.HasRisksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRisksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasRisksWith(with...))
	}
	if i.HasControlObjectives != nil {
		p := organization.HasControlObjectives()
		if !*i.HasControlObjectives {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlObjectivesWith) > 0 {
		with := make([]predicate.ControlObjective, 0, len(i.HasControlObjectivesWith))
		for _, w := range i.HasControlObjectivesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlObjectivesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasControlObjectivesWith(with...))
	}
	if i.HasNarratives != nil {
		p := organization.HasNarratives()
		if !*i.HasNarratives {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNarrativesWith) > 0 {
		with := make([]predicate.Narrative, 0, len(i.HasNarrativesWith))
		for _, w := range i.HasNarrativesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNarrativesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasNarrativesWith(with...))
	}
	if i.HasControls != nil {
		p := organization.HasControls()
		if !*i.HasControls {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasControlsWith))
		for _, w := range i.HasControlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasControlsWith(with...))
	}
	if i.HasSubcontrols != nil {
		p := organization.HasSubcontrols()
		if !*i.HasSubcontrols {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubcontrolsWith) > 0 {
		with := make([]predicate.Subcontrol, 0, len(i.HasSubcontrolsWith))
		for _, w := range i.HasSubcontrolsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubcontrolsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasSubcontrolsWith(with...))
	}
	if i.HasControlImplementations != nil {
		p := organization.HasControlImplementations()
		if !*i.HasControlImplementations {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlImplementationsWith) > 0 {
		with := make([]predicate.ControlImplementation, 0, len(i.HasControlImplementationsWith))
		for _, w := range i.HasControlImplementationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlImplementationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasControlImplementationsWith(with...))
	}
	if i.HasMappedControls != nil {
		p := organization.HasMappedControls()
		if !*i.HasMappedControls {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMappedControlsWith) > 0 {
		with := make([]predicate.MappedControl, 0, len(i.HasMappedControlsWith))
		for _, w := range i.HasMappedControlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMappedControlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasMappedControlsWith(with...))
	}
	if i.HasEvidence != nil {
		p := organization.HasEvidence()
		if !*i.HasEvidence {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEvidenceWith) > 0 {
		with := make([]predicate.Evidence, 0, len(i.HasEvidenceWith))
		for _, w := range i.HasEvidenceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEvidenceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasEvidenceWith(with...))
	}
	if i.HasStandards != nil {
		p := organization.HasStandards()
		if !*i.HasStandards {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStandardsWith) > 0 {
		with := make([]predicate.Standard, 0, len(i.HasStandardsWith))
		for _, w := range i.HasStandardsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStandardsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasStandardsWith(with...))
	}
	if i.HasActionPlans != nil {
		p := organization.HasActionPlans()
		if !*i.HasActionPlans {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionPlansWith) > 0 {
		with := make([]predicate.ActionPlan, 0, len(i.HasActionPlansWith))
		for _, w := range i.HasActionPlansWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionPlansWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasActionPlansWith(with...))
	}
	if i.HasCustomDomains != nil {
		p := organization.HasCustomDomains()
		if !*i.HasCustomDomains {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomDomainsWith) > 0 {
		with := make([]predicate.CustomDomain, 0, len(i.HasCustomDomainsWith))
		for _, w := range i.HasCustomDomainsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomDomainsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasCustomDomainsWith(with...))
	}
	if i.HasJobRunners != nil {
		p := organization.HasJobRunners()
		if !*i.HasJobRunners {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobRunnersWith) > 0 {
		with := make([]predicate.JobRunner, 0, len(i.HasJobRunnersWith))
		for _, w := range i.HasJobRunnersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobRunnersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasJobRunnersWith(with...))
	}
	if i.HasJobRunnerTokens != nil {
		p := organization.HasJobRunnerTokens()
		if !*i.HasJobRunnerTokens {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobRunnerTokensWith) > 0 {
		with := make([]predicate.JobRunnerToken, 0, len(i.HasJobRunnerTokensWith))
		for _, w := range i.HasJobRunnerTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobRunnerTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasJobRunnerTokensWith(with...))
	}
	if i.HasJobRunnerRegistrationTokens != nil {
		p := organization.HasJobRunnerRegistrationTokens()
		if !*i.HasJobRunnerRegistrationTokens {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobRunnerRegistrationTokensWith) > 0 {
		with := make([]predicate.JobRunnerRegistrationToken, 0, len(i.HasJobRunnerRegistrationTokensWith))
		for _, w := range i.HasJobRunnerRegistrationTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobRunnerRegistrationTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasJobRunnerRegistrationTokensWith(with...))
	}
	if i.HasDNSVerifications != nil {
		p := organization.HasDNSVerifications()
		if !*i.HasDNSVerifications {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDNSVerificationsWith) > 0 {
		with := make([]predicate.DNSVerification, 0, len(i.HasDNSVerificationsWith))
		for _, w := range i.HasDNSVerificationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDNSVerificationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasDNSVerificationsWith(with...))
	}
	if i.HasJobs != nil {
		p := organization.HasJobs()
		if !*i.HasJobs {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobsWith) > 0 {
		with := make([]predicate.ScheduledJob, 0, len(i.HasJobsWith))
		for _, w := range i.HasJobsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasJobsWith(with...))
	}
	if i.HasScheduledJobs != nil {
		p := organization.HasScheduledJobs()
		if !*i.HasScheduledJobs {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScheduledJobsWith) > 0 {
		with := make([]predicate.ControlScheduledJob, 0, len(i.HasScheduledJobsWith))
		for _, w := range i.HasScheduledJobsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasScheduledJobsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasScheduledJobsWith(with...))
	}
	if i.HasJobResults != nil {
		p := organization.HasJobResults()
		if !*i.HasJobResults {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobResultsWith) > 0 {
		with := make([]predicate.JobResult, 0, len(i.HasJobResultsWith))
		for _, w := range i.HasJobResultsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobResultsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasJobResultsWith(with...))
	}
	if i.HasScheduledJobRuns != nil {
		p := organization.HasScheduledJobRuns()
		if !*i.HasScheduledJobRuns {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScheduledJobRunsWith) > 0 {
		with := make([]predicate.ScheduledJobRun, 0, len(i.HasScheduledJobRunsWith))
		for _, w := range i.HasScheduledJobRunsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasScheduledJobRunsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasScheduledJobRunsWith(with...))
	}
	if i.HasMembers != nil {
		p := organization.HasMembers()
		if !*i.HasMembers {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMembersWith) > 0 {
		with := make([]predicate.OrgMembership, 0, len(i.HasMembersWith))
		for _, w := range i.HasMembersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMembersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasMembersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrganizationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return organization.And(predicates...), nil
	}
}

// OrganizationHistoryWhereInput represents a where input for filtering OrganizationHistory queries.
type OrganizationHistoryWhereInput struct {
	Predicates []predicate.OrganizationHistory  `json:"-"`
	Not        *OrganizationHistoryWhereInput   `json:"not,omitempty"`
	Or         []*OrganizationHistoryWhereInput `json:"or,omitempty"`
	And        []*OrganizationHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "parent_organization_id" field predicates.
	ParentOrganizationID             *string  `json:"parentOrganizationID,omitempty"`
	ParentOrganizationIDNEQ          *string  `json:"parentOrganizationIDNEQ,omitempty"`
	ParentOrganizationIDIn           []string `json:"parentOrganizationIDIn,omitempty"`
	ParentOrganizationIDNotIn        []string `json:"parentOrganizationIDNotIn,omitempty"`
	ParentOrganizationIDGT           *string  `json:"parentOrganizationIDGT,omitempty"`
	ParentOrganizationIDGTE          *string  `json:"parentOrganizationIDGTE,omitempty"`
	ParentOrganizationIDLT           *string  `json:"parentOrganizationIDLT,omitempty"`
	ParentOrganizationIDLTE          *string  `json:"parentOrganizationIDLTE,omitempty"`
	ParentOrganizationIDContains     *string  `json:"parentOrganizationIDContains,omitempty"`
	ParentOrganizationIDHasPrefix    *string  `json:"parentOrganizationIDHasPrefix,omitempty"`
	ParentOrganizationIDHasSuffix    *string  `json:"parentOrganizationIDHasSuffix,omitempty"`
	ParentOrganizationIDIsNil        bool     `json:"parentOrganizationIDIsNil,omitempty"`
	ParentOrganizationIDNotNil       bool     `json:"parentOrganizationIDNotNil,omitempty"`
	ParentOrganizationIDEqualFold    *string  `json:"parentOrganizationIDEqualFold,omitempty"`
	ParentOrganizationIDContainsFold *string  `json:"parentOrganizationIDContainsFold,omitempty"`

	// "personal_org" field predicates.
	PersonalOrg       *bool `json:"personalOrg,omitempty"`
	PersonalOrgNEQ    *bool `json:"personalOrgNEQ,omitempty"`
	PersonalOrgIsNil  bool  `json:"personalOrgIsNil,omitempty"`
	PersonalOrgNotNil bool  `json:"personalOrgNotNil,omitempty"`

	// "avatar_remote_url" field predicates.
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNEQ          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGT           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGTE          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLT           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLTE          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        bool     `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       bool     `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`

	// "avatar_local_file_id" field predicates.
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIDNEQ          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIDGT           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIDGTE          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIDLT           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIDLTE          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        bool     `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       bool     `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`

	// "avatar_updated_at" field predicates.
	AvatarUpdatedAt       *time.Time  `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNEQ    *time.Time  `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGT     *time.Time  `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGTE    *time.Time  `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLT     *time.Time  `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLTE    *time.Time  `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil bool        `json:"avatarUpdatedAtNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrganizationHistoryWhereInput) AddPredicates(predicates ...predicate.OrganizationHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrganizationHistoryWhereInput filter on the OrganizationHistoryQuery builder.
func (i *OrganizationHistoryWhereInput) Filter(q *OrganizationHistoryQuery) (*OrganizationHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrganizationHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrganizationHistoryWhereInput is returned in case the OrganizationHistoryWhereInput is empty.
var ErrEmptyOrganizationHistoryWhereInput = errors.New("generated: empty predicate OrganizationHistoryWhereInput")

// P returns a predicate for filtering organizationhistories.
// An error is returned if the input is empty or invalid.
func (i *OrganizationHistoryWhereInput) P() (predicate.OrganizationHistory, error) {
	var predicates []predicate.OrganizationHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, organizationhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrganizationHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, organizationhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrganizationHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, organizationhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, organizationhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, organizationhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, organizationhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, organizationhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, organizationhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, organizationhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, organizationhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, organizationhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, organizationhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, organizationhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, organizationhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, organizationhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, organizationhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, organizationhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, organizationhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, organizationhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, organizationhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, organizationhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, organizationhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, organizationhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, organizationhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, organizationhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, organizationhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, organizationhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, organizationhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, organizationhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, organizationhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, organizationhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, organizationhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, organizationhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, organizationhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, organizationhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, organizationhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, organizationhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, organizationhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, organizationhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, organizationhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, organizationhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, organizationhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, organizationhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, organizationhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, organizationhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, organizationhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, organizationhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, organizationhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, organizationhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, organizationhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, organizationhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, organizationhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, organizationhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, organizationhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, organizationhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, organizationhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, organizationhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, organizationhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, organizationhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, organizationhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, organizationhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, organizationhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, organizationhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, organizationhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, organizationhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, organizationhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, organizationhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, organizationhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, organizationhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, organizationhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, organizationhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, organizationhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, organizationhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, organizationhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, organizationhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, organizationhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, organizationhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, organizationhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, organizationhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, organizationhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, organizationhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, organizationhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, organizationhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, organizationhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, organizationhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, organizationhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, organizationhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, organizationhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, organizationhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, organizationhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, organizationhistory.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, organizationhistory.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, organizationhistory.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, organizationhistory.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, organizationhistory.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, organizationhistory.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, organizationhistory.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, organizationhistory.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, organizationhistory.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, organizationhistory.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, organizationhistory.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, organizationhistory.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, organizationhistory.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.ParentOrganizationID != nil {
		predicates = append(predicates, organizationhistory.ParentOrganizationIDEQ(*i.ParentOrganizationID))
	}
	if i.ParentOrganizationIDNEQ != nil {
		predicates = append(predicates, organizationhistory.ParentOrganizationIDNEQ(*i.ParentOrganizationIDNEQ))
	}
	if len(i.ParentOrganizationIDIn) > 0 {
		predicates = append(predicates, organizationhistory.ParentOrganizationIDIn(i.ParentOrganizationIDIn...))
	}
	if len(i.ParentOrganizationIDNotIn) > 0 {
		predicates = append(predicates, organizationhistory.ParentOrganizationIDNotIn(i.ParentOrganizationIDNotIn...))
	}
	if i.ParentOrganizationIDGT != nil {
		predicates = append(predicates, organizationhistory.ParentOrganizationIDGT(*i.ParentOrganizationIDGT))
	}
	if i.ParentOrganizationIDGTE != nil {
		predicates = append(predicates, organizationhistory.ParentOrganizationIDGTE(*i.ParentOrganizationIDGTE))
	}
	if i.ParentOrganizationIDLT != nil {
		predicates = append(predicates, organizationhistory.ParentOrganizationIDLT(*i.ParentOrganizationIDLT))
	}
	if i.ParentOrganizationIDLTE != nil {
		predicates = append(predicates, organizationhistory.ParentOrganizationIDLTE(*i.ParentOrganizationIDLTE))
	}
	if i.ParentOrganizationIDContains != nil {
		predicates = append(predicates, organizationhistory.ParentOrganizationIDContains(*i.ParentOrganizationIDContains))
	}
	if i.ParentOrganizationIDHasPrefix != nil {
		predicates = append(predicates, organizationhistory.ParentOrganizationIDHasPrefix(*i.ParentOrganizationIDHasPrefix))
	}
	if i.ParentOrganizationIDHasSuffix != nil {
		predicates = append(predicates, organizationhistory.ParentOrganizationIDHasSuffix(*i.ParentOrganizationIDHasSuffix))
	}
	if i.ParentOrganizationIDIsNil {
		predicates = append(predicates, organizationhistory.ParentOrganizationIDIsNil())
	}
	if i.ParentOrganizationIDNotNil {
		predicates = append(predicates, organizationhistory.ParentOrganizationIDNotNil())
	}
	if i.ParentOrganizationIDEqualFold != nil {
		predicates = append(predicates, organizationhistory.ParentOrganizationIDEqualFold(*i.ParentOrganizationIDEqualFold))
	}
	if i.ParentOrganizationIDContainsFold != nil {
		predicates = append(predicates, organizationhistory.ParentOrganizationIDContainsFold(*i.ParentOrganizationIDContainsFold))
	}
	if i.PersonalOrg != nil {
		predicates = append(predicates, organizationhistory.PersonalOrgEQ(*i.PersonalOrg))
	}
	if i.PersonalOrgNEQ != nil {
		predicates = append(predicates, organizationhistory.PersonalOrgNEQ(*i.PersonalOrgNEQ))
	}
	if i.PersonalOrgIsNil {
		predicates = append(predicates, organizationhistory.PersonalOrgIsNil())
	}
	if i.PersonalOrgNotNil {
		predicates = append(predicates, organizationhistory.PersonalOrgNotNil())
	}
	if i.AvatarRemoteURL != nil {
		predicates = append(predicates, organizationhistory.AvatarRemoteURLEQ(*i.AvatarRemoteURL))
	}
	if i.AvatarRemoteURLNEQ != nil {
		predicates = append(predicates, organizationhistory.AvatarRemoteURLNEQ(*i.AvatarRemoteURLNEQ))
	}
	if len(i.AvatarRemoteURLIn) > 0 {
		predicates = append(predicates, organizationhistory.AvatarRemoteURLIn(i.AvatarRemoteURLIn...))
	}
	if len(i.AvatarRemoteURLNotIn) > 0 {
		predicates = append(predicates, organizationhistory.AvatarRemoteURLNotIn(i.AvatarRemoteURLNotIn...))
	}
	if i.AvatarRemoteURLGT != nil {
		predicates = append(predicates, organizationhistory.AvatarRemoteURLGT(*i.AvatarRemoteURLGT))
	}
	if i.AvatarRemoteURLGTE != nil {
		predicates = append(predicates, organizationhistory.AvatarRemoteURLGTE(*i.AvatarRemoteURLGTE))
	}
	if i.AvatarRemoteURLLT != nil {
		predicates = append(predicates, organizationhistory.AvatarRemoteURLLT(*i.AvatarRemoteURLLT))
	}
	if i.AvatarRemoteURLLTE != nil {
		predicates = append(predicates, organizationhistory.AvatarRemoteURLLTE(*i.AvatarRemoteURLLTE))
	}
	if i.AvatarRemoteURLContains != nil {
		predicates = append(predicates, organizationhistory.AvatarRemoteURLContains(*i.AvatarRemoteURLContains))
	}
	if i.AvatarRemoteURLHasPrefix != nil {
		predicates = append(predicates, organizationhistory.AvatarRemoteURLHasPrefix(*i.AvatarRemoteURLHasPrefix))
	}
	if i.AvatarRemoteURLHasSuffix != nil {
		predicates = append(predicates, organizationhistory.AvatarRemoteURLHasSuffix(*i.AvatarRemoteURLHasSuffix))
	}
	if i.AvatarRemoteURLIsNil {
		predicates = append(predicates, organizationhistory.AvatarRemoteURLIsNil())
	}
	if i.AvatarRemoteURLNotNil {
		predicates = append(predicates, organizationhistory.AvatarRemoteURLNotNil())
	}
	if i.AvatarRemoteURLEqualFold != nil {
		predicates = append(predicates, organizationhistory.AvatarRemoteURLEqualFold(*i.AvatarRemoteURLEqualFold))
	}
	if i.AvatarRemoteURLContainsFold != nil {
		predicates = append(predicates, organizationhistory.AvatarRemoteURLContainsFold(*i.AvatarRemoteURLContainsFold))
	}
	if i.AvatarLocalFileID != nil {
		predicates = append(predicates, organizationhistory.AvatarLocalFileIDEQ(*i.AvatarLocalFileID))
	}
	if i.AvatarLocalFileIDNEQ != nil {
		predicates = append(predicates, organizationhistory.AvatarLocalFileIDNEQ(*i.AvatarLocalFileIDNEQ))
	}
	if len(i.AvatarLocalFileIDIn) > 0 {
		predicates = append(predicates, organizationhistory.AvatarLocalFileIDIn(i.AvatarLocalFileIDIn...))
	}
	if len(i.AvatarLocalFileIDNotIn) > 0 {
		predicates = append(predicates, organizationhistory.AvatarLocalFileIDNotIn(i.AvatarLocalFileIDNotIn...))
	}
	if i.AvatarLocalFileIDGT != nil {
		predicates = append(predicates, organizationhistory.AvatarLocalFileIDGT(*i.AvatarLocalFileIDGT))
	}
	if i.AvatarLocalFileIDGTE != nil {
		predicates = append(predicates, organizationhistory.AvatarLocalFileIDGTE(*i.AvatarLocalFileIDGTE))
	}
	if i.AvatarLocalFileIDLT != nil {
		predicates = append(predicates, organizationhistory.AvatarLocalFileIDLT(*i.AvatarLocalFileIDLT))
	}
	if i.AvatarLocalFileIDLTE != nil {
		predicates = append(predicates, organizationhistory.AvatarLocalFileIDLTE(*i.AvatarLocalFileIDLTE))
	}
	if i.AvatarLocalFileIDContains != nil {
		predicates = append(predicates, organizationhistory.AvatarLocalFileIDContains(*i.AvatarLocalFileIDContains))
	}
	if i.AvatarLocalFileIDHasPrefix != nil {
		predicates = append(predicates, organizationhistory.AvatarLocalFileIDHasPrefix(*i.AvatarLocalFileIDHasPrefix))
	}
	if i.AvatarLocalFileIDHasSuffix != nil {
		predicates = append(predicates, organizationhistory.AvatarLocalFileIDHasSuffix(*i.AvatarLocalFileIDHasSuffix))
	}
	if i.AvatarLocalFileIDIsNil {
		predicates = append(predicates, organizationhistory.AvatarLocalFileIDIsNil())
	}
	if i.AvatarLocalFileIDNotNil {
		predicates = append(predicates, organizationhistory.AvatarLocalFileIDNotNil())
	}
	if i.AvatarLocalFileIDEqualFold != nil {
		predicates = append(predicates, organizationhistory.AvatarLocalFileIDEqualFold(*i.AvatarLocalFileIDEqualFold))
	}
	if i.AvatarLocalFileIDContainsFold != nil {
		predicates = append(predicates, organizationhistory.AvatarLocalFileIDContainsFold(*i.AvatarLocalFileIDContainsFold))
	}
	if i.AvatarUpdatedAt != nil {
		predicates = append(predicates, organizationhistory.AvatarUpdatedAtEQ(*i.AvatarUpdatedAt))
	}
	if i.AvatarUpdatedAtNEQ != nil {
		predicates = append(predicates, organizationhistory.AvatarUpdatedAtNEQ(*i.AvatarUpdatedAtNEQ))
	}
	if len(i.AvatarUpdatedAtIn) > 0 {
		predicates = append(predicates, organizationhistory.AvatarUpdatedAtIn(i.AvatarUpdatedAtIn...))
	}
	if len(i.AvatarUpdatedAtNotIn) > 0 {
		predicates = append(predicates, organizationhistory.AvatarUpdatedAtNotIn(i.AvatarUpdatedAtNotIn...))
	}
	if i.AvatarUpdatedAtGT != nil {
		predicates = append(predicates, organizationhistory.AvatarUpdatedAtGT(*i.AvatarUpdatedAtGT))
	}
	if i.AvatarUpdatedAtGTE != nil {
		predicates = append(predicates, organizationhistory.AvatarUpdatedAtGTE(*i.AvatarUpdatedAtGTE))
	}
	if i.AvatarUpdatedAtLT != nil {
		predicates = append(predicates, organizationhistory.AvatarUpdatedAtLT(*i.AvatarUpdatedAtLT))
	}
	if i.AvatarUpdatedAtLTE != nil {
		predicates = append(predicates, organizationhistory.AvatarUpdatedAtLTE(*i.AvatarUpdatedAtLTE))
	}
	if i.AvatarUpdatedAtIsNil {
		predicates = append(predicates, organizationhistory.AvatarUpdatedAtIsNil())
	}
	if i.AvatarUpdatedAtNotNil {
		predicates = append(predicates, organizationhistory.AvatarUpdatedAtNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrganizationHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return organizationhistory.And(predicates...), nil
	}
}

// OrganizationSettingWhereInput represents a where input for filtering OrganizationSetting queries.
type OrganizationSettingWhereInput struct {
	Predicates []predicate.OrganizationSetting  `json:"-"`
	Not        *OrganizationSettingWhereInput   `json:"not,omitempty"`
	Or         []*OrganizationSettingWhereInput `json:"or,omitempty"`
	And        []*OrganizationSettingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "billing_contact" field predicates.
	BillingContact             *string  `json:"billingContact,omitempty"`
	BillingContactNEQ          *string  `json:"billingContactNEQ,omitempty"`
	BillingContactIn           []string `json:"billingContactIn,omitempty"`
	BillingContactNotIn        []string `json:"billingContactNotIn,omitempty"`
	BillingContactGT           *string  `json:"billingContactGT,omitempty"`
	BillingContactGTE          *string  `json:"billingContactGTE,omitempty"`
	BillingContactLT           *string  `json:"billingContactLT,omitempty"`
	BillingContactLTE          *string  `json:"billingContactLTE,omitempty"`
	BillingContactContains     *string  `json:"billingContactContains,omitempty"`
	BillingContactHasPrefix    *string  `json:"billingContactHasPrefix,omitempty"`
	BillingContactHasSuffix    *string  `json:"billingContactHasSuffix,omitempty"`
	BillingContactIsNil        bool     `json:"billingContactIsNil,omitempty"`
	BillingContactNotNil       bool     `json:"billingContactNotNil,omitempty"`
	BillingContactEqualFold    *string  `json:"billingContactEqualFold,omitempty"`
	BillingContactContainsFold *string  `json:"billingContactContainsFold,omitempty"`

	// "billing_email" field predicates.
	BillingEmail             *string  `json:"billingEmail,omitempty"`
	BillingEmailNEQ          *string  `json:"billingEmailNEQ,omitempty"`
	BillingEmailIn           []string `json:"billingEmailIn,omitempty"`
	BillingEmailNotIn        []string `json:"billingEmailNotIn,omitempty"`
	BillingEmailGT           *string  `json:"billingEmailGT,omitempty"`
	BillingEmailGTE          *string  `json:"billingEmailGTE,omitempty"`
	BillingEmailLT           *string  `json:"billingEmailLT,omitempty"`
	BillingEmailLTE          *string  `json:"billingEmailLTE,omitempty"`
	BillingEmailContains     *string  `json:"billingEmailContains,omitempty"`
	BillingEmailHasPrefix    *string  `json:"billingEmailHasPrefix,omitempty"`
	BillingEmailHasSuffix    *string  `json:"billingEmailHasSuffix,omitempty"`
	BillingEmailIsNil        bool     `json:"billingEmailIsNil,omitempty"`
	BillingEmailNotNil       bool     `json:"billingEmailNotNil,omitempty"`
	BillingEmailEqualFold    *string  `json:"billingEmailEqualFold,omitempty"`
	BillingEmailContainsFold *string  `json:"billingEmailContainsFold,omitempty"`

	// "billing_phone" field predicates.
	BillingPhone             *string  `json:"billingPhone,omitempty"`
	BillingPhoneNEQ          *string  `json:"billingPhoneNEQ,omitempty"`
	BillingPhoneIn           []string `json:"billingPhoneIn,omitempty"`
	BillingPhoneNotIn        []string `json:"billingPhoneNotIn,omitempty"`
	BillingPhoneGT           *string  `json:"billingPhoneGT,omitempty"`
	BillingPhoneGTE          *string  `json:"billingPhoneGTE,omitempty"`
	BillingPhoneLT           *string  `json:"billingPhoneLT,omitempty"`
	BillingPhoneLTE          *string  `json:"billingPhoneLTE,omitempty"`
	BillingPhoneContains     *string  `json:"billingPhoneContains,omitempty"`
	BillingPhoneHasPrefix    *string  `json:"billingPhoneHasPrefix,omitempty"`
	BillingPhoneHasSuffix    *string  `json:"billingPhoneHasSuffix,omitempty"`
	BillingPhoneIsNil        bool     `json:"billingPhoneIsNil,omitempty"`
	BillingPhoneNotNil       bool     `json:"billingPhoneNotNil,omitempty"`
	BillingPhoneEqualFold    *string  `json:"billingPhoneEqualFold,omitempty"`
	BillingPhoneContainsFold *string  `json:"billingPhoneContainsFold,omitempty"`

	// "tax_identifier" field predicates.
	TaxIdentifier             *string  `json:"taxIdentifier,omitempty"`
	TaxIdentifierNEQ          *string  `json:"taxIdentifierNEQ,omitempty"`
	TaxIdentifierIn           []string `json:"taxIdentifierIn,omitempty"`
	TaxIdentifierNotIn        []string `json:"taxIdentifierNotIn,omitempty"`
	TaxIdentifierGT           *string  `json:"taxIdentifierGT,omitempty"`
	TaxIdentifierGTE          *string  `json:"taxIdentifierGTE,omitempty"`
	TaxIdentifierLT           *string  `json:"taxIdentifierLT,omitempty"`
	TaxIdentifierLTE          *string  `json:"taxIdentifierLTE,omitempty"`
	TaxIdentifierContains     *string  `json:"taxIdentifierContains,omitempty"`
	TaxIdentifierHasPrefix    *string  `json:"taxIdentifierHasPrefix,omitempty"`
	TaxIdentifierHasSuffix    *string  `json:"taxIdentifierHasSuffix,omitempty"`
	TaxIdentifierIsNil        bool     `json:"taxIdentifierIsNil,omitempty"`
	TaxIdentifierNotNil       bool     `json:"taxIdentifierNotNil,omitempty"`
	TaxIdentifierEqualFold    *string  `json:"taxIdentifierEqualFold,omitempty"`
	TaxIdentifierContainsFold *string  `json:"taxIdentifierContainsFold,omitempty"`

	// "geo_location" field predicates.
	GeoLocation       *enums.Region  `json:"geoLocation,omitempty"`
	GeoLocationNEQ    *enums.Region  `json:"geoLocationNEQ,omitempty"`
	GeoLocationIn     []enums.Region `json:"geoLocationIn,omitempty"`
	GeoLocationNotIn  []enums.Region `json:"geoLocationNotIn,omitempty"`
	GeoLocationIsNil  bool           `json:"geoLocationIsNil,omitempty"`
	GeoLocationNotNil bool           `json:"geoLocationNotNil,omitempty"`

	// "organization_id" field predicates.
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIDNEQ          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIDGT           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIDGTE          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIDLT           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIDLTE          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        bool     `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       bool     `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`

	// "billing_notifications_enabled" field predicates.
	BillingNotificationsEnabled    *bool `json:"billingNotificationsEnabled,omitempty"`
	BillingNotificationsEnabledNEQ *bool `json:"billingNotificationsEnabledNEQ,omitempty"`

	// "organization" edge predicates.
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrganizationSettingWhereInput) AddPredicates(predicates ...predicate.OrganizationSetting) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrganizationSettingWhereInput filter on the OrganizationSettingQuery builder.
func (i *OrganizationSettingWhereInput) Filter(q *OrganizationSettingQuery) (*OrganizationSettingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrganizationSettingWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrganizationSettingWhereInput is returned in case the OrganizationSettingWhereInput is empty.
var ErrEmptyOrganizationSettingWhereInput = errors.New("generated: empty predicate OrganizationSettingWhereInput")

// P returns a predicate for filtering organizationsettings.
// An error is returned if the input is empty or invalid.
func (i *OrganizationSettingWhereInput) P() (predicate.OrganizationSetting, error) {
	var predicates []predicate.OrganizationSetting
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, organizationsetting.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrganizationSetting, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, organizationsetting.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrganizationSetting, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, organizationsetting.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, organizationsetting.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, organizationsetting.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, organizationsetting.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, organizationsetting.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, organizationsetting.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, organizationsetting.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, organizationsetting.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, organizationsetting.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, organizationsetting.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, organizationsetting.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, organizationsetting.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, organizationsetting.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, organizationsetting.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, organizationsetting.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, organizationsetting.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, organizationsetting.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, organizationsetting.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, organizationsetting.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, organizationsetting.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, organizationsetting.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, organizationsetting.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, organizationsetting.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, organizationsetting.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, organizationsetting.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, organizationsetting.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, organizationsetting.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, organizationsetting.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, organizationsetting.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, organizationsetting.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, organizationsetting.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, organizationsetting.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, organizationsetting.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, organizationsetting.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, organizationsetting.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, organizationsetting.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, organizationsetting.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, organizationsetting.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, organizationsetting.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, organizationsetting.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, organizationsetting.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, organizationsetting.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, organizationsetting.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, organizationsetting.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, organizationsetting.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, organizationsetting.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, organizationsetting.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, organizationsetting.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, organizationsetting.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, organizationsetting.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, organizationsetting.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, organizationsetting.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, organizationsetting.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, organizationsetting.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, organizationsetting.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, organizationsetting.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, organizationsetting.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, organizationsetting.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, organizationsetting.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, organizationsetting.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, organizationsetting.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.BillingContact != nil {
		predicates = append(predicates, organizationsetting.BillingContactEQ(*i.BillingContact))
	}
	if i.BillingContactNEQ != nil {
		predicates = append(predicates, organizationsetting.BillingContactNEQ(*i.BillingContactNEQ))
	}
	if len(i.BillingContactIn) > 0 {
		predicates = append(predicates, organizationsetting.BillingContactIn(i.BillingContactIn...))
	}
	if len(i.BillingContactNotIn) > 0 {
		predicates = append(predicates, organizationsetting.BillingContactNotIn(i.BillingContactNotIn...))
	}
	if i.BillingContactGT != nil {
		predicates = append(predicates, organizationsetting.BillingContactGT(*i.BillingContactGT))
	}
	if i.BillingContactGTE != nil {
		predicates = append(predicates, organizationsetting.BillingContactGTE(*i.BillingContactGTE))
	}
	if i.BillingContactLT != nil {
		predicates = append(predicates, organizationsetting.BillingContactLT(*i.BillingContactLT))
	}
	if i.BillingContactLTE != nil {
		predicates = append(predicates, organizationsetting.BillingContactLTE(*i.BillingContactLTE))
	}
	if i.BillingContactContains != nil {
		predicates = append(predicates, organizationsetting.BillingContactContains(*i.BillingContactContains))
	}
	if i.BillingContactHasPrefix != nil {
		predicates = append(predicates, organizationsetting.BillingContactHasPrefix(*i.BillingContactHasPrefix))
	}
	if i.BillingContactHasSuffix != nil {
		predicates = append(predicates, organizationsetting.BillingContactHasSuffix(*i.BillingContactHasSuffix))
	}
	if i.BillingContactIsNil {
		predicates = append(predicates, organizationsetting.BillingContactIsNil())
	}
	if i.BillingContactNotNil {
		predicates = append(predicates, organizationsetting.BillingContactNotNil())
	}
	if i.BillingContactEqualFold != nil {
		predicates = append(predicates, organizationsetting.BillingContactEqualFold(*i.BillingContactEqualFold))
	}
	if i.BillingContactContainsFold != nil {
		predicates = append(predicates, organizationsetting.BillingContactContainsFold(*i.BillingContactContainsFold))
	}
	if i.BillingEmail != nil {
		predicates = append(predicates, organizationsetting.BillingEmailEQ(*i.BillingEmail))
	}
	if i.BillingEmailNEQ != nil {
		predicates = append(predicates, organizationsetting.BillingEmailNEQ(*i.BillingEmailNEQ))
	}
	if len(i.BillingEmailIn) > 0 {
		predicates = append(predicates, organizationsetting.BillingEmailIn(i.BillingEmailIn...))
	}
	if len(i.BillingEmailNotIn) > 0 {
		predicates = append(predicates, organizationsetting.BillingEmailNotIn(i.BillingEmailNotIn...))
	}
	if i.BillingEmailGT != nil {
		predicates = append(predicates, organizationsetting.BillingEmailGT(*i.BillingEmailGT))
	}
	if i.BillingEmailGTE != nil {
		predicates = append(predicates, organizationsetting.BillingEmailGTE(*i.BillingEmailGTE))
	}
	if i.BillingEmailLT != nil {
		predicates = append(predicates, organizationsetting.BillingEmailLT(*i.BillingEmailLT))
	}
	if i.BillingEmailLTE != nil {
		predicates = append(predicates, organizationsetting.BillingEmailLTE(*i.BillingEmailLTE))
	}
	if i.BillingEmailContains != nil {
		predicates = append(predicates, organizationsetting.BillingEmailContains(*i.BillingEmailContains))
	}
	if i.BillingEmailHasPrefix != nil {
		predicates = append(predicates, organizationsetting.BillingEmailHasPrefix(*i.BillingEmailHasPrefix))
	}
	if i.BillingEmailHasSuffix != nil {
		predicates = append(predicates, organizationsetting.BillingEmailHasSuffix(*i.BillingEmailHasSuffix))
	}
	if i.BillingEmailIsNil {
		predicates = append(predicates, organizationsetting.BillingEmailIsNil())
	}
	if i.BillingEmailNotNil {
		predicates = append(predicates, organizationsetting.BillingEmailNotNil())
	}
	if i.BillingEmailEqualFold != nil {
		predicates = append(predicates, organizationsetting.BillingEmailEqualFold(*i.BillingEmailEqualFold))
	}
	if i.BillingEmailContainsFold != nil {
		predicates = append(predicates, organizationsetting.BillingEmailContainsFold(*i.BillingEmailContainsFold))
	}
	if i.BillingPhone != nil {
		predicates = append(predicates, organizationsetting.BillingPhoneEQ(*i.BillingPhone))
	}
	if i.BillingPhoneNEQ != nil {
		predicates = append(predicates, organizationsetting.BillingPhoneNEQ(*i.BillingPhoneNEQ))
	}
	if len(i.BillingPhoneIn) > 0 {
		predicates = append(predicates, organizationsetting.BillingPhoneIn(i.BillingPhoneIn...))
	}
	if len(i.BillingPhoneNotIn) > 0 {
		predicates = append(predicates, organizationsetting.BillingPhoneNotIn(i.BillingPhoneNotIn...))
	}
	if i.BillingPhoneGT != nil {
		predicates = append(predicates, organizationsetting.BillingPhoneGT(*i.BillingPhoneGT))
	}
	if i.BillingPhoneGTE != nil {
		predicates = append(predicates, organizationsetting.BillingPhoneGTE(*i.BillingPhoneGTE))
	}
	if i.BillingPhoneLT != nil {
		predicates = append(predicates, organizationsetting.BillingPhoneLT(*i.BillingPhoneLT))
	}
	if i.BillingPhoneLTE != nil {
		predicates = append(predicates, organizationsetting.BillingPhoneLTE(*i.BillingPhoneLTE))
	}
	if i.BillingPhoneContains != nil {
		predicates = append(predicates, organizationsetting.BillingPhoneContains(*i.BillingPhoneContains))
	}
	if i.BillingPhoneHasPrefix != nil {
		predicates = append(predicates, organizationsetting.BillingPhoneHasPrefix(*i.BillingPhoneHasPrefix))
	}
	if i.BillingPhoneHasSuffix != nil {
		predicates = append(predicates, organizationsetting.BillingPhoneHasSuffix(*i.BillingPhoneHasSuffix))
	}
	if i.BillingPhoneIsNil {
		predicates = append(predicates, organizationsetting.BillingPhoneIsNil())
	}
	if i.BillingPhoneNotNil {
		predicates = append(predicates, organizationsetting.BillingPhoneNotNil())
	}
	if i.BillingPhoneEqualFold != nil {
		predicates = append(predicates, organizationsetting.BillingPhoneEqualFold(*i.BillingPhoneEqualFold))
	}
	if i.BillingPhoneContainsFold != nil {
		predicates = append(predicates, organizationsetting.BillingPhoneContainsFold(*i.BillingPhoneContainsFold))
	}
	if i.TaxIdentifier != nil {
		predicates = append(predicates, organizationsetting.TaxIdentifierEQ(*i.TaxIdentifier))
	}
	if i.TaxIdentifierNEQ != nil {
		predicates = append(predicates, organizationsetting.TaxIdentifierNEQ(*i.TaxIdentifierNEQ))
	}
	if len(i.TaxIdentifierIn) > 0 {
		predicates = append(predicates, organizationsetting.TaxIdentifierIn(i.TaxIdentifierIn...))
	}
	if len(i.TaxIdentifierNotIn) > 0 {
		predicates = append(predicates, organizationsetting.TaxIdentifierNotIn(i.TaxIdentifierNotIn...))
	}
	if i.TaxIdentifierGT != nil {
		predicates = append(predicates, organizationsetting.TaxIdentifierGT(*i.TaxIdentifierGT))
	}
	if i.TaxIdentifierGTE != nil {
		predicates = append(predicates, organizationsetting.TaxIdentifierGTE(*i.TaxIdentifierGTE))
	}
	if i.TaxIdentifierLT != nil {
		predicates = append(predicates, organizationsetting.TaxIdentifierLT(*i.TaxIdentifierLT))
	}
	if i.TaxIdentifierLTE != nil {
		predicates = append(predicates, organizationsetting.TaxIdentifierLTE(*i.TaxIdentifierLTE))
	}
	if i.TaxIdentifierContains != nil {
		predicates = append(predicates, organizationsetting.TaxIdentifierContains(*i.TaxIdentifierContains))
	}
	if i.TaxIdentifierHasPrefix != nil {
		predicates = append(predicates, organizationsetting.TaxIdentifierHasPrefix(*i.TaxIdentifierHasPrefix))
	}
	if i.TaxIdentifierHasSuffix != nil {
		predicates = append(predicates, organizationsetting.TaxIdentifierHasSuffix(*i.TaxIdentifierHasSuffix))
	}
	if i.TaxIdentifierIsNil {
		predicates = append(predicates, organizationsetting.TaxIdentifierIsNil())
	}
	if i.TaxIdentifierNotNil {
		predicates = append(predicates, organizationsetting.TaxIdentifierNotNil())
	}
	if i.TaxIdentifierEqualFold != nil {
		predicates = append(predicates, organizationsetting.TaxIdentifierEqualFold(*i.TaxIdentifierEqualFold))
	}
	if i.TaxIdentifierContainsFold != nil {
		predicates = append(predicates, organizationsetting.TaxIdentifierContainsFold(*i.TaxIdentifierContainsFold))
	}
	if i.GeoLocation != nil {
		predicates = append(predicates, organizationsetting.GeoLocationEQ(*i.GeoLocation))
	}
	if i.GeoLocationNEQ != nil {
		predicates = append(predicates, organizationsetting.GeoLocationNEQ(*i.GeoLocationNEQ))
	}
	if len(i.GeoLocationIn) > 0 {
		predicates = append(predicates, organizationsetting.GeoLocationIn(i.GeoLocationIn...))
	}
	if len(i.GeoLocationNotIn) > 0 {
		predicates = append(predicates, organizationsetting.GeoLocationNotIn(i.GeoLocationNotIn...))
	}
	if i.GeoLocationIsNil {
		predicates = append(predicates, organizationsetting.GeoLocationIsNil())
	}
	if i.GeoLocationNotNil {
		predicates = append(predicates, organizationsetting.GeoLocationNotNil())
	}
	if i.OrganizationID != nil {
		predicates = append(predicates, organizationsetting.OrganizationIDEQ(*i.OrganizationID))
	}
	if i.OrganizationIDNEQ != nil {
		predicates = append(predicates, organizationsetting.OrganizationIDNEQ(*i.OrganizationIDNEQ))
	}
	if len(i.OrganizationIDIn) > 0 {
		predicates = append(predicates, organizationsetting.OrganizationIDIn(i.OrganizationIDIn...))
	}
	if len(i.OrganizationIDNotIn) > 0 {
		predicates = append(predicates, organizationsetting.OrganizationIDNotIn(i.OrganizationIDNotIn...))
	}
	if i.OrganizationIDGT != nil {
		predicates = append(predicates, organizationsetting.OrganizationIDGT(*i.OrganizationIDGT))
	}
	if i.OrganizationIDGTE != nil {
		predicates = append(predicates, organizationsetting.OrganizationIDGTE(*i.OrganizationIDGTE))
	}
	if i.OrganizationIDLT != nil {
		predicates = append(predicates, organizationsetting.OrganizationIDLT(*i.OrganizationIDLT))
	}
	if i.OrganizationIDLTE != nil {
		predicates = append(predicates, organizationsetting.OrganizationIDLTE(*i.OrganizationIDLTE))
	}
	if i.OrganizationIDContains != nil {
		predicates = append(predicates, organizationsetting.OrganizationIDContains(*i.OrganizationIDContains))
	}
	if i.OrganizationIDHasPrefix != nil {
		predicates = append(predicates, organizationsetting.OrganizationIDHasPrefix(*i.OrganizationIDHasPrefix))
	}
	if i.OrganizationIDHasSuffix != nil {
		predicates = append(predicates, organizationsetting.OrganizationIDHasSuffix(*i.OrganizationIDHasSuffix))
	}
	if i.OrganizationIDIsNil {
		predicates = append(predicates, organizationsetting.OrganizationIDIsNil())
	}
	if i.OrganizationIDNotNil {
		predicates = append(predicates, organizationsetting.OrganizationIDNotNil())
	}
	if i.OrganizationIDEqualFold != nil {
		predicates = append(predicates, organizationsetting.OrganizationIDEqualFold(*i.OrganizationIDEqualFold))
	}
	if i.OrganizationIDContainsFold != nil {
		predicates = append(predicates, organizationsetting.OrganizationIDContainsFold(*i.OrganizationIDContainsFold))
	}
	if i.BillingNotificationsEnabled != nil {
		predicates = append(predicates, organizationsetting.BillingNotificationsEnabledEQ(*i.BillingNotificationsEnabled))
	}
	if i.BillingNotificationsEnabledNEQ != nil {
		predicates = append(predicates, organizationsetting.BillingNotificationsEnabledNEQ(*i.BillingNotificationsEnabledNEQ))
	}

	if i.HasOrganization != nil {
		p := organizationsetting.HasOrganization()
		if !*i.HasOrganization {
			p = organizationsetting.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrganizationWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOrganizationWith))
		for _, w := range i.HasOrganizationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrganizationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organizationsetting.HasOrganizationWith(with...))
	}
	if i.HasFiles != nil {
		p := organizationsetting.HasFiles()
		if !*i.HasFiles {
			p = organizationsetting.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organizationsetting.HasFilesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrganizationSettingWhereInput
	case 1:
		return predicates[0], nil
	default:
		return organizationsetting.And(predicates...), nil
	}
}

// OrganizationSettingHistoryWhereInput represents a where input for filtering OrganizationSettingHistory queries.
type OrganizationSettingHistoryWhereInput struct {
	Predicates []predicate.OrganizationSettingHistory  `json:"-"`
	Not        *OrganizationSettingHistoryWhereInput   `json:"not,omitempty"`
	Or         []*OrganizationSettingHistoryWhereInput `json:"or,omitempty"`
	And        []*OrganizationSettingHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "billing_contact" field predicates.
	BillingContact             *string  `json:"billingContact,omitempty"`
	BillingContactNEQ          *string  `json:"billingContactNEQ,omitempty"`
	BillingContactIn           []string `json:"billingContactIn,omitempty"`
	BillingContactNotIn        []string `json:"billingContactNotIn,omitempty"`
	BillingContactGT           *string  `json:"billingContactGT,omitempty"`
	BillingContactGTE          *string  `json:"billingContactGTE,omitempty"`
	BillingContactLT           *string  `json:"billingContactLT,omitempty"`
	BillingContactLTE          *string  `json:"billingContactLTE,omitempty"`
	BillingContactContains     *string  `json:"billingContactContains,omitempty"`
	BillingContactHasPrefix    *string  `json:"billingContactHasPrefix,omitempty"`
	BillingContactHasSuffix    *string  `json:"billingContactHasSuffix,omitempty"`
	BillingContactIsNil        bool     `json:"billingContactIsNil,omitempty"`
	BillingContactNotNil       bool     `json:"billingContactNotNil,omitempty"`
	BillingContactEqualFold    *string  `json:"billingContactEqualFold,omitempty"`
	BillingContactContainsFold *string  `json:"billingContactContainsFold,omitempty"`

	// "billing_email" field predicates.
	BillingEmail             *string  `json:"billingEmail,omitempty"`
	BillingEmailNEQ          *string  `json:"billingEmailNEQ,omitempty"`
	BillingEmailIn           []string `json:"billingEmailIn,omitempty"`
	BillingEmailNotIn        []string `json:"billingEmailNotIn,omitempty"`
	BillingEmailGT           *string  `json:"billingEmailGT,omitempty"`
	BillingEmailGTE          *string  `json:"billingEmailGTE,omitempty"`
	BillingEmailLT           *string  `json:"billingEmailLT,omitempty"`
	BillingEmailLTE          *string  `json:"billingEmailLTE,omitempty"`
	BillingEmailContains     *string  `json:"billingEmailContains,omitempty"`
	BillingEmailHasPrefix    *string  `json:"billingEmailHasPrefix,omitempty"`
	BillingEmailHasSuffix    *string  `json:"billingEmailHasSuffix,omitempty"`
	BillingEmailIsNil        bool     `json:"billingEmailIsNil,omitempty"`
	BillingEmailNotNil       bool     `json:"billingEmailNotNil,omitempty"`
	BillingEmailEqualFold    *string  `json:"billingEmailEqualFold,omitempty"`
	BillingEmailContainsFold *string  `json:"billingEmailContainsFold,omitempty"`

	// "billing_phone" field predicates.
	BillingPhone             *string  `json:"billingPhone,omitempty"`
	BillingPhoneNEQ          *string  `json:"billingPhoneNEQ,omitempty"`
	BillingPhoneIn           []string `json:"billingPhoneIn,omitempty"`
	BillingPhoneNotIn        []string `json:"billingPhoneNotIn,omitempty"`
	BillingPhoneGT           *string  `json:"billingPhoneGT,omitempty"`
	BillingPhoneGTE          *string  `json:"billingPhoneGTE,omitempty"`
	BillingPhoneLT           *string  `json:"billingPhoneLT,omitempty"`
	BillingPhoneLTE          *string  `json:"billingPhoneLTE,omitempty"`
	BillingPhoneContains     *string  `json:"billingPhoneContains,omitempty"`
	BillingPhoneHasPrefix    *string  `json:"billingPhoneHasPrefix,omitempty"`
	BillingPhoneHasSuffix    *string  `json:"billingPhoneHasSuffix,omitempty"`
	BillingPhoneIsNil        bool     `json:"billingPhoneIsNil,omitempty"`
	BillingPhoneNotNil       bool     `json:"billingPhoneNotNil,omitempty"`
	BillingPhoneEqualFold    *string  `json:"billingPhoneEqualFold,omitempty"`
	BillingPhoneContainsFold *string  `json:"billingPhoneContainsFold,omitempty"`

	// "tax_identifier" field predicates.
	TaxIdentifier             *string  `json:"taxIdentifier,omitempty"`
	TaxIdentifierNEQ          *string  `json:"taxIdentifierNEQ,omitempty"`
	TaxIdentifierIn           []string `json:"taxIdentifierIn,omitempty"`
	TaxIdentifierNotIn        []string `json:"taxIdentifierNotIn,omitempty"`
	TaxIdentifierGT           *string  `json:"taxIdentifierGT,omitempty"`
	TaxIdentifierGTE          *string  `json:"taxIdentifierGTE,omitempty"`
	TaxIdentifierLT           *string  `json:"taxIdentifierLT,omitempty"`
	TaxIdentifierLTE          *string  `json:"taxIdentifierLTE,omitempty"`
	TaxIdentifierContains     *string  `json:"taxIdentifierContains,omitempty"`
	TaxIdentifierHasPrefix    *string  `json:"taxIdentifierHasPrefix,omitempty"`
	TaxIdentifierHasSuffix    *string  `json:"taxIdentifierHasSuffix,omitempty"`
	TaxIdentifierIsNil        bool     `json:"taxIdentifierIsNil,omitempty"`
	TaxIdentifierNotNil       bool     `json:"taxIdentifierNotNil,omitempty"`
	TaxIdentifierEqualFold    *string  `json:"taxIdentifierEqualFold,omitempty"`
	TaxIdentifierContainsFold *string  `json:"taxIdentifierContainsFold,omitempty"`

	// "geo_location" field predicates.
	GeoLocation       *enums.Region  `json:"geoLocation,omitempty"`
	GeoLocationNEQ    *enums.Region  `json:"geoLocationNEQ,omitempty"`
	GeoLocationIn     []enums.Region `json:"geoLocationIn,omitempty"`
	GeoLocationNotIn  []enums.Region `json:"geoLocationNotIn,omitempty"`
	GeoLocationIsNil  bool           `json:"geoLocationIsNil,omitempty"`
	GeoLocationNotNil bool           `json:"geoLocationNotNil,omitempty"`

	// "organization_id" field predicates.
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIDNEQ          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIDGT           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIDGTE          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIDLT           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIDLTE          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        bool     `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       bool     `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`

	// "billing_notifications_enabled" field predicates.
	BillingNotificationsEnabled    *bool `json:"billingNotificationsEnabled,omitempty"`
	BillingNotificationsEnabledNEQ *bool `json:"billingNotificationsEnabledNEQ,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrganizationSettingHistoryWhereInput) AddPredicates(predicates ...predicate.OrganizationSettingHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrganizationSettingHistoryWhereInput filter on the OrganizationSettingHistoryQuery builder.
func (i *OrganizationSettingHistoryWhereInput) Filter(q *OrganizationSettingHistoryQuery) (*OrganizationSettingHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrganizationSettingHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrganizationSettingHistoryWhereInput is returned in case the OrganizationSettingHistoryWhereInput is empty.
var ErrEmptyOrganizationSettingHistoryWhereInput = errors.New("generated: empty predicate OrganizationSettingHistoryWhereInput")

// P returns a predicate for filtering organizationsettinghistories.
// An error is returned if the input is empty or invalid.
func (i *OrganizationSettingHistoryWhereInput) P() (predicate.OrganizationSettingHistory, error) {
	var predicates []predicate.OrganizationSettingHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, organizationsettinghistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrganizationSettingHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, organizationsettinghistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrganizationSettingHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, organizationsettinghistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, organizationsettinghistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, organizationsettinghistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, organizationsettinghistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, organizationsettinghistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, organizationsettinghistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, organizationsettinghistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, organizationsettinghistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, organizationsettinghistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, organizationsettinghistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, organizationsettinghistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, organizationsettinghistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, organizationsettinghistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, organizationsettinghistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, organizationsettinghistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, organizationsettinghistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, organizationsettinghistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, organizationsettinghistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, organizationsettinghistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, organizationsettinghistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, organizationsettinghistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, organizationsettinghistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, organizationsettinghistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, organizationsettinghistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, organizationsettinghistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, organizationsettinghistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, organizationsettinghistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, organizationsettinghistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, organizationsettinghistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, organizationsettinghistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, organizationsettinghistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, organizationsettinghistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, organizationsettinghistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, organizationsettinghistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, organizationsettinghistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, organizationsettinghistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, organizationsettinghistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, organizationsettinghistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, organizationsettinghistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, organizationsettinghistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.BillingContact != nil {
		predicates = append(predicates, organizationsettinghistory.BillingContactEQ(*i.BillingContact))
	}
	if i.BillingContactNEQ != nil {
		predicates = append(predicates, organizationsettinghistory.BillingContactNEQ(*i.BillingContactNEQ))
	}
	if len(i.BillingContactIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.BillingContactIn(i.BillingContactIn...))
	}
	if len(i.BillingContactNotIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.BillingContactNotIn(i.BillingContactNotIn...))
	}
	if i.BillingContactGT != nil {
		predicates = append(predicates, organizationsettinghistory.BillingContactGT(*i.BillingContactGT))
	}
	if i.BillingContactGTE != nil {
		predicates = append(predicates, organizationsettinghistory.BillingContactGTE(*i.BillingContactGTE))
	}
	if i.BillingContactLT != nil {
		predicates = append(predicates, organizationsettinghistory.BillingContactLT(*i.BillingContactLT))
	}
	if i.BillingContactLTE != nil {
		predicates = append(predicates, organizationsettinghistory.BillingContactLTE(*i.BillingContactLTE))
	}
	if i.BillingContactContains != nil {
		predicates = append(predicates, organizationsettinghistory.BillingContactContains(*i.BillingContactContains))
	}
	if i.BillingContactHasPrefix != nil {
		predicates = append(predicates, organizationsettinghistory.BillingContactHasPrefix(*i.BillingContactHasPrefix))
	}
	if i.BillingContactHasSuffix != nil {
		predicates = append(predicates, organizationsettinghistory.BillingContactHasSuffix(*i.BillingContactHasSuffix))
	}
	if i.BillingContactIsNil {
		predicates = append(predicates, organizationsettinghistory.BillingContactIsNil())
	}
	if i.BillingContactNotNil {
		predicates = append(predicates, organizationsettinghistory.BillingContactNotNil())
	}
	if i.BillingContactEqualFold != nil {
		predicates = append(predicates, organizationsettinghistory.BillingContactEqualFold(*i.BillingContactEqualFold))
	}
	if i.BillingContactContainsFold != nil {
		predicates = append(predicates, organizationsettinghistory.BillingContactContainsFold(*i.BillingContactContainsFold))
	}
	if i.BillingEmail != nil {
		predicates = append(predicates, organizationsettinghistory.BillingEmailEQ(*i.BillingEmail))
	}
	if i.BillingEmailNEQ != nil {
		predicates = append(predicates, organizationsettinghistory.BillingEmailNEQ(*i.BillingEmailNEQ))
	}
	if len(i.BillingEmailIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.BillingEmailIn(i.BillingEmailIn...))
	}
	if len(i.BillingEmailNotIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.BillingEmailNotIn(i.BillingEmailNotIn...))
	}
	if i.BillingEmailGT != nil {
		predicates = append(predicates, organizationsettinghistory.BillingEmailGT(*i.BillingEmailGT))
	}
	if i.BillingEmailGTE != nil {
		predicates = append(predicates, organizationsettinghistory.BillingEmailGTE(*i.BillingEmailGTE))
	}
	if i.BillingEmailLT != nil {
		predicates = append(predicates, organizationsettinghistory.BillingEmailLT(*i.BillingEmailLT))
	}
	if i.BillingEmailLTE != nil {
		predicates = append(predicates, organizationsettinghistory.BillingEmailLTE(*i.BillingEmailLTE))
	}
	if i.BillingEmailContains != nil {
		predicates = append(predicates, organizationsettinghistory.BillingEmailContains(*i.BillingEmailContains))
	}
	if i.BillingEmailHasPrefix != nil {
		predicates = append(predicates, organizationsettinghistory.BillingEmailHasPrefix(*i.BillingEmailHasPrefix))
	}
	if i.BillingEmailHasSuffix != nil {
		predicates = append(predicates, organizationsettinghistory.BillingEmailHasSuffix(*i.BillingEmailHasSuffix))
	}
	if i.BillingEmailIsNil {
		predicates = append(predicates, organizationsettinghistory.BillingEmailIsNil())
	}
	if i.BillingEmailNotNil {
		predicates = append(predicates, organizationsettinghistory.BillingEmailNotNil())
	}
	if i.BillingEmailEqualFold != nil {
		predicates = append(predicates, organizationsettinghistory.BillingEmailEqualFold(*i.BillingEmailEqualFold))
	}
	if i.BillingEmailContainsFold != nil {
		predicates = append(predicates, organizationsettinghistory.BillingEmailContainsFold(*i.BillingEmailContainsFold))
	}
	if i.BillingPhone != nil {
		predicates = append(predicates, organizationsettinghistory.BillingPhoneEQ(*i.BillingPhone))
	}
	if i.BillingPhoneNEQ != nil {
		predicates = append(predicates, organizationsettinghistory.BillingPhoneNEQ(*i.BillingPhoneNEQ))
	}
	if len(i.BillingPhoneIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.BillingPhoneIn(i.BillingPhoneIn...))
	}
	if len(i.BillingPhoneNotIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.BillingPhoneNotIn(i.BillingPhoneNotIn...))
	}
	if i.BillingPhoneGT != nil {
		predicates = append(predicates, organizationsettinghistory.BillingPhoneGT(*i.BillingPhoneGT))
	}
	if i.BillingPhoneGTE != nil {
		predicates = append(predicates, organizationsettinghistory.BillingPhoneGTE(*i.BillingPhoneGTE))
	}
	if i.BillingPhoneLT != nil {
		predicates = append(predicates, organizationsettinghistory.BillingPhoneLT(*i.BillingPhoneLT))
	}
	if i.BillingPhoneLTE != nil {
		predicates = append(predicates, organizationsettinghistory.BillingPhoneLTE(*i.BillingPhoneLTE))
	}
	if i.BillingPhoneContains != nil {
		predicates = append(predicates, organizationsettinghistory.BillingPhoneContains(*i.BillingPhoneContains))
	}
	if i.BillingPhoneHasPrefix != nil {
		predicates = append(predicates, organizationsettinghistory.BillingPhoneHasPrefix(*i.BillingPhoneHasPrefix))
	}
	if i.BillingPhoneHasSuffix != nil {
		predicates = append(predicates, organizationsettinghistory.BillingPhoneHasSuffix(*i.BillingPhoneHasSuffix))
	}
	if i.BillingPhoneIsNil {
		predicates = append(predicates, organizationsettinghistory.BillingPhoneIsNil())
	}
	if i.BillingPhoneNotNil {
		predicates = append(predicates, organizationsettinghistory.BillingPhoneNotNil())
	}
	if i.BillingPhoneEqualFold != nil {
		predicates = append(predicates, organizationsettinghistory.BillingPhoneEqualFold(*i.BillingPhoneEqualFold))
	}
	if i.BillingPhoneContainsFold != nil {
		predicates = append(predicates, organizationsettinghistory.BillingPhoneContainsFold(*i.BillingPhoneContainsFold))
	}
	if i.TaxIdentifier != nil {
		predicates = append(predicates, organizationsettinghistory.TaxIdentifierEQ(*i.TaxIdentifier))
	}
	if i.TaxIdentifierNEQ != nil {
		predicates = append(predicates, organizationsettinghistory.TaxIdentifierNEQ(*i.TaxIdentifierNEQ))
	}
	if len(i.TaxIdentifierIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.TaxIdentifierIn(i.TaxIdentifierIn...))
	}
	if len(i.TaxIdentifierNotIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.TaxIdentifierNotIn(i.TaxIdentifierNotIn...))
	}
	if i.TaxIdentifierGT != nil {
		predicates = append(predicates, organizationsettinghistory.TaxIdentifierGT(*i.TaxIdentifierGT))
	}
	if i.TaxIdentifierGTE != nil {
		predicates = append(predicates, organizationsettinghistory.TaxIdentifierGTE(*i.TaxIdentifierGTE))
	}
	if i.TaxIdentifierLT != nil {
		predicates = append(predicates, organizationsettinghistory.TaxIdentifierLT(*i.TaxIdentifierLT))
	}
	if i.TaxIdentifierLTE != nil {
		predicates = append(predicates, organizationsettinghistory.TaxIdentifierLTE(*i.TaxIdentifierLTE))
	}
	if i.TaxIdentifierContains != nil {
		predicates = append(predicates, organizationsettinghistory.TaxIdentifierContains(*i.TaxIdentifierContains))
	}
	if i.TaxIdentifierHasPrefix != nil {
		predicates = append(predicates, organizationsettinghistory.TaxIdentifierHasPrefix(*i.TaxIdentifierHasPrefix))
	}
	if i.TaxIdentifierHasSuffix != nil {
		predicates = append(predicates, organizationsettinghistory.TaxIdentifierHasSuffix(*i.TaxIdentifierHasSuffix))
	}
	if i.TaxIdentifierIsNil {
		predicates = append(predicates, organizationsettinghistory.TaxIdentifierIsNil())
	}
	if i.TaxIdentifierNotNil {
		predicates = append(predicates, organizationsettinghistory.TaxIdentifierNotNil())
	}
	if i.TaxIdentifierEqualFold != nil {
		predicates = append(predicates, organizationsettinghistory.TaxIdentifierEqualFold(*i.TaxIdentifierEqualFold))
	}
	if i.TaxIdentifierContainsFold != nil {
		predicates = append(predicates, organizationsettinghistory.TaxIdentifierContainsFold(*i.TaxIdentifierContainsFold))
	}
	if i.GeoLocation != nil {
		predicates = append(predicates, organizationsettinghistory.GeoLocationEQ(*i.GeoLocation))
	}
	if i.GeoLocationNEQ != nil {
		predicates = append(predicates, organizationsettinghistory.GeoLocationNEQ(*i.GeoLocationNEQ))
	}
	if len(i.GeoLocationIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.GeoLocationIn(i.GeoLocationIn...))
	}
	if len(i.GeoLocationNotIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.GeoLocationNotIn(i.GeoLocationNotIn...))
	}
	if i.GeoLocationIsNil {
		predicates = append(predicates, organizationsettinghistory.GeoLocationIsNil())
	}
	if i.GeoLocationNotNil {
		predicates = append(predicates, organizationsettinghistory.GeoLocationNotNil())
	}
	if i.OrganizationID != nil {
		predicates = append(predicates, organizationsettinghistory.OrganizationIDEQ(*i.OrganizationID))
	}
	if i.OrganizationIDNEQ != nil {
		predicates = append(predicates, organizationsettinghistory.OrganizationIDNEQ(*i.OrganizationIDNEQ))
	}
	if len(i.OrganizationIDIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.OrganizationIDIn(i.OrganizationIDIn...))
	}
	if len(i.OrganizationIDNotIn) > 0 {
		predicates = append(predicates, organizationsettinghistory.OrganizationIDNotIn(i.OrganizationIDNotIn...))
	}
	if i.OrganizationIDGT != nil {
		predicates = append(predicates, organizationsettinghistory.OrganizationIDGT(*i.OrganizationIDGT))
	}
	if i.OrganizationIDGTE != nil {
		predicates = append(predicates, organizationsettinghistory.OrganizationIDGTE(*i.OrganizationIDGTE))
	}
	if i.OrganizationIDLT != nil {
		predicates = append(predicates, organizationsettinghistory.OrganizationIDLT(*i.OrganizationIDLT))
	}
	if i.OrganizationIDLTE != nil {
		predicates = append(predicates, organizationsettinghistory.OrganizationIDLTE(*i.OrganizationIDLTE))
	}
	if i.OrganizationIDContains != nil {
		predicates = append(predicates, organizationsettinghistory.OrganizationIDContains(*i.OrganizationIDContains))
	}
	if i.OrganizationIDHasPrefix != nil {
		predicates = append(predicates, organizationsettinghistory.OrganizationIDHasPrefix(*i.OrganizationIDHasPrefix))
	}
	if i.OrganizationIDHasSuffix != nil {
		predicates = append(predicates, organizationsettinghistory.OrganizationIDHasSuffix(*i.OrganizationIDHasSuffix))
	}
	if i.OrganizationIDIsNil {
		predicates = append(predicates, organizationsettinghistory.OrganizationIDIsNil())
	}
	if i.OrganizationIDNotNil {
		predicates = append(predicates, organizationsettinghistory.OrganizationIDNotNil())
	}
	if i.OrganizationIDEqualFold != nil {
		predicates = append(predicates, organizationsettinghistory.OrganizationIDEqualFold(*i.OrganizationIDEqualFold))
	}
	if i.OrganizationIDContainsFold != nil {
		predicates = append(predicates, organizationsettinghistory.OrganizationIDContainsFold(*i.OrganizationIDContainsFold))
	}
	if i.BillingNotificationsEnabled != nil {
		predicates = append(predicates, organizationsettinghistory.BillingNotificationsEnabledEQ(*i.BillingNotificationsEnabled))
	}
	if i.BillingNotificationsEnabledNEQ != nil {
		predicates = append(predicates, organizationsettinghistory.BillingNotificationsEnabledNEQ(*i.BillingNotificationsEnabledNEQ))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrganizationSettingHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return organizationsettinghistory.And(predicates...), nil
	}
}

// PersonalAccessTokenWhereInput represents a where input for filtering PersonalAccessToken queries.
type PersonalAccessTokenWhereInput struct {
	Predicates []predicate.PersonalAccessToken  `json:"-"`
	Not        *PersonalAccessTokenWhereInput   `json:"not,omitempty"`
	Or         []*PersonalAccessTokenWhereInput `json:"or,omitempty"`
	And        []*PersonalAccessTokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "expires_at" field predicates.
	ExpiresAt       *time.Time  `json:"expiresAt,omitempty"`
	ExpiresAtNEQ    *time.Time  `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGT     *time.Time  `json:"expiresAtGT,omitempty"`
	ExpiresAtGTE    *time.Time  `json:"expiresAtGTE,omitempty"`
	ExpiresAtLT     *time.Time  `json:"expiresAtLT,omitempty"`
	ExpiresAtLTE    *time.Time  `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil bool        `json:"expiresAtNotNil,omitempty"`

	// "last_used_at" field predicates.
	LastUsedAt       *time.Time  `json:"lastUsedAt,omitempty"`
	LastUsedAtNEQ    *time.Time  `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGT     *time.Time  `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGTE    *time.Time  `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLT     *time.Time  `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLTE    *time.Time  `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil bool        `json:"lastUsedAtNotNil,omitempty"`

	// "is_active" field predicates.
	IsActive       *bool `json:"isActive,omitempty"`
	IsActiveNEQ    *bool `json:"isActiveNEQ,omitempty"`
	IsActiveIsNil  bool  `json:"isActiveIsNil,omitempty"`
	IsActiveNotNil bool  `json:"isActiveNotNil,omitempty"`

	// "revoked_reason" field predicates.
	RevokedReason             *string  `json:"revokedReason,omitempty"`
	RevokedReasonNEQ          *string  `json:"revokedReasonNEQ,omitempty"`
	RevokedReasonIn           []string `json:"revokedReasonIn,omitempty"`
	RevokedReasonNotIn        []string `json:"revokedReasonNotIn,omitempty"`
	RevokedReasonGT           *string  `json:"revokedReasonGT,omitempty"`
	RevokedReasonGTE          *string  `json:"revokedReasonGTE,omitempty"`
	RevokedReasonLT           *string  `json:"revokedReasonLT,omitempty"`
	RevokedReasonLTE          *string  `json:"revokedReasonLTE,omitempty"`
	RevokedReasonContains     *string  `json:"revokedReasonContains,omitempty"`
	RevokedReasonHasPrefix    *string  `json:"revokedReasonHasPrefix,omitempty"`
	RevokedReasonHasSuffix    *string  `json:"revokedReasonHasSuffix,omitempty"`
	RevokedReasonIsNil        bool     `json:"revokedReasonIsNil,omitempty"`
	RevokedReasonNotNil       bool     `json:"revokedReasonNotNil,omitempty"`
	RevokedReasonEqualFold    *string  `json:"revokedReasonEqualFold,omitempty"`
	RevokedReasonContainsFold *string  `json:"revokedReasonContainsFold,omitempty"`

	// "revoked_by" field predicates.
	RevokedBy             *string  `json:"revokedBy,omitempty"`
	RevokedByNEQ          *string  `json:"revokedByNEQ,omitempty"`
	RevokedByIn           []string `json:"revokedByIn,omitempty"`
	RevokedByNotIn        []string `json:"revokedByNotIn,omitempty"`
	RevokedByGT           *string  `json:"revokedByGT,omitempty"`
	RevokedByGTE          *string  `json:"revokedByGTE,omitempty"`
	RevokedByLT           *string  `json:"revokedByLT,omitempty"`
	RevokedByLTE          *string  `json:"revokedByLTE,omitempty"`
	RevokedByContains     *string  `json:"revokedByContains,omitempty"`
	RevokedByHasPrefix    *string  `json:"revokedByHasPrefix,omitempty"`
	RevokedByHasSuffix    *string  `json:"revokedByHasSuffix,omitempty"`
	RevokedByIsNil        bool     `json:"revokedByIsNil,omitempty"`
	RevokedByNotNil       bool     `json:"revokedByNotNil,omitempty"`
	RevokedByEqualFold    *string  `json:"revokedByEqualFold,omitempty"`
	RevokedByContainsFold *string  `json:"revokedByContainsFold,omitempty"`

	// "revoked_at" field predicates.
	RevokedAt       *time.Time  `json:"revokedAt,omitempty"`
	RevokedAtNEQ    *time.Time  `json:"revokedAtNEQ,omitempty"`
	RevokedAtIn     []time.Time `json:"revokedAtIn,omitempty"`
	RevokedAtNotIn  []time.Time `json:"revokedAtNotIn,omitempty"`
	RevokedAtGT     *time.Time  `json:"revokedAtGT,omitempty"`
	RevokedAtGTE    *time.Time  `json:"revokedAtGTE,omitempty"`
	RevokedAtLT     *time.Time  `json:"revokedAtLT,omitempty"`
	RevokedAtLTE    *time.Time  `json:"revokedAtLTE,omitempty"`
	RevokedAtIsNil  bool        `json:"revokedAtIsNil,omitempty"`
	RevokedAtNotNil bool        `json:"revokedAtNotNil,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`

	// "organizations" edge predicates.
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`

	// "events" edge predicates.
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PersonalAccessTokenWhereInput) AddPredicates(predicates ...predicate.PersonalAccessToken) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PersonalAccessTokenWhereInput filter on the PersonalAccessTokenQuery builder.
func (i *PersonalAccessTokenWhereInput) Filter(q *PersonalAccessTokenQuery) (*PersonalAccessTokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPersonalAccessTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPersonalAccessTokenWhereInput is returned in case the PersonalAccessTokenWhereInput is empty.
var ErrEmptyPersonalAccessTokenWhereInput = errors.New("generated: empty predicate PersonalAccessTokenWhereInput")

// P returns a predicate for filtering personalaccesstokens.
// An error is returned if the input is empty or invalid.
func (i *PersonalAccessTokenWhereInput) P() (predicate.PersonalAccessToken, error) {
	var predicates []predicate.PersonalAccessToken
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, personalaccesstoken.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PersonalAccessToken, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, personalaccesstoken.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PersonalAccessToken, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, personalaccesstoken.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, personalaccesstoken.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, personalaccesstoken.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, personalaccesstoken.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, personalaccesstoken.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, personalaccesstoken.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, personalaccesstoken.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, personalaccesstoken.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, personalaccesstoken.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, personalaccesstoken.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, personalaccesstoken.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, personalaccesstoken.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, personalaccesstoken.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, personalaccesstoken.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, personalaccesstoken.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, personalaccesstoken.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, personalaccesstoken.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, personalaccesstoken.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, personalaccesstoken.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, personalaccesstoken.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, personalaccesstoken.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, personalaccesstoken.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, personalaccesstoken.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, personalaccesstoken.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, personalaccesstoken.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, personalaccesstoken.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, personalaccesstoken.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, personalaccesstoken.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, personalaccesstoken.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, personalaccesstoken.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, personalaccesstoken.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, personalaccesstoken.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, personalaccesstoken.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, personalaccesstoken.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, personalaccesstoken.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, personalaccesstoken.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, personalaccesstoken.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, personalaccesstoken.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, personalaccesstoken.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, personalaccesstoken.NameContainsFold(*i.NameContainsFold))
	}
	if i.ExpiresAt != nil {
		predicates = append(predicates, personalaccesstoken.ExpiresAtEQ(*i.ExpiresAt))
	}
	if i.ExpiresAtNEQ != nil {
		predicates = append(predicates, personalaccesstoken.ExpiresAtNEQ(*i.ExpiresAtNEQ))
	}
	if len(i.ExpiresAtIn) > 0 {
		predicates = append(predicates, personalaccesstoken.ExpiresAtIn(i.ExpiresAtIn...))
	}
	if len(i.ExpiresAtNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.ExpiresAtNotIn(i.ExpiresAtNotIn...))
	}
	if i.ExpiresAtGT != nil {
		predicates = append(predicates, personalaccesstoken.ExpiresAtGT(*i.ExpiresAtGT))
	}
	if i.ExpiresAtGTE != nil {
		predicates = append(predicates, personalaccesstoken.ExpiresAtGTE(*i.ExpiresAtGTE))
	}
	if i.ExpiresAtLT != nil {
		predicates = append(predicates, personalaccesstoken.ExpiresAtLT(*i.ExpiresAtLT))
	}
	if i.ExpiresAtLTE != nil {
		predicates = append(predicates, personalaccesstoken.ExpiresAtLTE(*i.ExpiresAtLTE))
	}
	if i.ExpiresAtIsNil {
		predicates = append(predicates, personalaccesstoken.ExpiresAtIsNil())
	}
	if i.ExpiresAtNotNil {
		predicates = append(predicates, personalaccesstoken.ExpiresAtNotNil())
	}
	if i.LastUsedAt != nil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtEQ(*i.LastUsedAt))
	}
	if i.LastUsedAtNEQ != nil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtNEQ(*i.LastUsedAtNEQ))
	}
	if len(i.LastUsedAtIn) > 0 {
		predicates = append(predicates, personalaccesstoken.LastUsedAtIn(i.LastUsedAtIn...))
	}
	if len(i.LastUsedAtNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.LastUsedAtNotIn(i.LastUsedAtNotIn...))
	}
	if i.LastUsedAtGT != nil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtGT(*i.LastUsedAtGT))
	}
	if i.LastUsedAtGTE != nil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtGTE(*i.LastUsedAtGTE))
	}
	if i.LastUsedAtLT != nil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtLT(*i.LastUsedAtLT))
	}
	if i.LastUsedAtLTE != nil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtLTE(*i.LastUsedAtLTE))
	}
	if i.LastUsedAtIsNil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtIsNil())
	}
	if i.LastUsedAtNotNil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtNotNil())
	}
	if i.IsActive != nil {
		predicates = append(predicates, personalaccesstoken.IsActiveEQ(*i.IsActive))
	}
	if i.IsActiveNEQ != nil {
		predicates = append(predicates, personalaccesstoken.IsActiveNEQ(*i.IsActiveNEQ))
	}
	if i.IsActiveIsNil {
		predicates = append(predicates, personalaccesstoken.IsActiveIsNil())
	}
	if i.IsActiveNotNil {
		predicates = append(predicates, personalaccesstoken.IsActiveNotNil())
	}
	if i.RevokedReason != nil {
		predicates = append(predicates, personalaccesstoken.RevokedReasonEQ(*i.RevokedReason))
	}
	if i.RevokedReasonNEQ != nil {
		predicates = append(predicates, personalaccesstoken.RevokedReasonNEQ(*i.RevokedReasonNEQ))
	}
	if len(i.RevokedReasonIn) > 0 {
		predicates = append(predicates, personalaccesstoken.RevokedReasonIn(i.RevokedReasonIn...))
	}
	if len(i.RevokedReasonNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.RevokedReasonNotIn(i.RevokedReasonNotIn...))
	}
	if i.RevokedReasonGT != nil {
		predicates = append(predicates, personalaccesstoken.RevokedReasonGT(*i.RevokedReasonGT))
	}
	if i.RevokedReasonGTE != nil {
		predicates = append(predicates, personalaccesstoken.RevokedReasonGTE(*i.RevokedReasonGTE))
	}
	if i.RevokedReasonLT != nil {
		predicates = append(predicates, personalaccesstoken.RevokedReasonLT(*i.RevokedReasonLT))
	}
	if i.RevokedReasonLTE != nil {
		predicates = append(predicates, personalaccesstoken.RevokedReasonLTE(*i.RevokedReasonLTE))
	}
	if i.RevokedReasonContains != nil {
		predicates = append(predicates, personalaccesstoken.RevokedReasonContains(*i.RevokedReasonContains))
	}
	if i.RevokedReasonHasPrefix != nil {
		predicates = append(predicates, personalaccesstoken.RevokedReasonHasPrefix(*i.RevokedReasonHasPrefix))
	}
	if i.RevokedReasonHasSuffix != nil {
		predicates = append(predicates, personalaccesstoken.RevokedReasonHasSuffix(*i.RevokedReasonHasSuffix))
	}
	if i.RevokedReasonIsNil {
		predicates = append(predicates, personalaccesstoken.RevokedReasonIsNil())
	}
	if i.RevokedReasonNotNil {
		predicates = append(predicates, personalaccesstoken.RevokedReasonNotNil())
	}
	if i.RevokedReasonEqualFold != nil {
		predicates = append(predicates, personalaccesstoken.RevokedReasonEqualFold(*i.RevokedReasonEqualFold))
	}
	if i.RevokedReasonContainsFold != nil {
		predicates = append(predicates, personalaccesstoken.RevokedReasonContainsFold(*i.RevokedReasonContainsFold))
	}
	if i.RevokedBy != nil {
		predicates = append(predicates, personalaccesstoken.RevokedByEQ(*i.RevokedBy))
	}
	if i.RevokedByNEQ != nil {
		predicates = append(predicates, personalaccesstoken.RevokedByNEQ(*i.RevokedByNEQ))
	}
	if len(i.RevokedByIn) > 0 {
		predicates = append(predicates, personalaccesstoken.RevokedByIn(i.RevokedByIn...))
	}
	if len(i.RevokedByNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.RevokedByNotIn(i.RevokedByNotIn...))
	}
	if i.RevokedByGT != nil {
		predicates = append(predicates, personalaccesstoken.RevokedByGT(*i.RevokedByGT))
	}
	if i.RevokedByGTE != nil {
		predicates = append(predicates, personalaccesstoken.RevokedByGTE(*i.RevokedByGTE))
	}
	if i.RevokedByLT != nil {
		predicates = append(predicates, personalaccesstoken.RevokedByLT(*i.RevokedByLT))
	}
	if i.RevokedByLTE != nil {
		predicates = append(predicates, personalaccesstoken.RevokedByLTE(*i.RevokedByLTE))
	}
	if i.RevokedByContains != nil {
		predicates = append(predicates, personalaccesstoken.RevokedByContains(*i.RevokedByContains))
	}
	if i.RevokedByHasPrefix != nil {
		predicates = append(predicates, personalaccesstoken.RevokedByHasPrefix(*i.RevokedByHasPrefix))
	}
	if i.RevokedByHasSuffix != nil {
		predicates = append(predicates, personalaccesstoken.RevokedByHasSuffix(*i.RevokedByHasSuffix))
	}
	if i.RevokedByIsNil {
		predicates = append(predicates, personalaccesstoken.RevokedByIsNil())
	}
	if i.RevokedByNotNil {
		predicates = append(predicates, personalaccesstoken.RevokedByNotNil())
	}
	if i.RevokedByEqualFold != nil {
		predicates = append(predicates, personalaccesstoken.RevokedByEqualFold(*i.RevokedByEqualFold))
	}
	if i.RevokedByContainsFold != nil {
		predicates = append(predicates, personalaccesstoken.RevokedByContainsFold(*i.RevokedByContainsFold))
	}
	if i.RevokedAt != nil {
		predicates = append(predicates, personalaccesstoken.RevokedAtEQ(*i.RevokedAt))
	}
	if i.RevokedAtNEQ != nil {
		predicates = append(predicates, personalaccesstoken.RevokedAtNEQ(*i.RevokedAtNEQ))
	}
	if len(i.RevokedAtIn) > 0 {
		predicates = append(predicates, personalaccesstoken.RevokedAtIn(i.RevokedAtIn...))
	}
	if len(i.RevokedAtNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.RevokedAtNotIn(i.RevokedAtNotIn...))
	}
	if i.RevokedAtGT != nil {
		predicates = append(predicates, personalaccesstoken.RevokedAtGT(*i.RevokedAtGT))
	}
	if i.RevokedAtGTE != nil {
		predicates = append(predicates, personalaccesstoken.RevokedAtGTE(*i.RevokedAtGTE))
	}
	if i.RevokedAtLT != nil {
		predicates = append(predicates, personalaccesstoken.RevokedAtLT(*i.RevokedAtLT))
	}
	if i.RevokedAtLTE != nil {
		predicates = append(predicates, personalaccesstoken.RevokedAtLTE(*i.RevokedAtLTE))
	}
	if i.RevokedAtIsNil {
		predicates = append(predicates, personalaccesstoken.RevokedAtIsNil())
	}
	if i.RevokedAtNotNil {
		predicates = append(predicates, personalaccesstoken.RevokedAtNotNil())
	}

	if i.HasOwner != nil {
		p := personalaccesstoken.HasOwner()
		if !*i.HasOwner {
			p = personalaccesstoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, personalaccesstoken.HasOwnerWith(with...))
	}
	if i.HasOrganizations != nil {
		p := personalaccesstoken.HasOrganizations()
		if !*i.HasOrganizations {
			p = personalaccesstoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrganizationsWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOrganizationsWith))
		for _, w := range i.HasOrganizationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrganizationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, personalaccesstoken.HasOrganizationsWith(with...))
	}
	if i.HasEvents != nil {
		p := personalaccesstoken.HasEvents()
		if !*i.HasEvents {
			p = personalaccesstoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventsWith) > 0 {
		with := make([]predicate.Event, 0, len(i.HasEventsWith))
		for _, w := range i.HasEventsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, personalaccesstoken.HasEventsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPersonalAccessTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return personalaccesstoken.And(predicates...), nil
	}
}

// ProcedureWhereInput represents a where input for filtering Procedure queries.
type ProcedureWhereInput struct {
	Predicates []predicate.Procedure  `json:"-"`
	Not        *ProcedureWhereInput   `json:"not,omitempty"`
	Or         []*ProcedureWhereInput `json:"or,omitempty"`
	And        []*ProcedureWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "revision" field predicates.
	Revision             *string  `json:"revision,omitempty"`
	RevisionNEQ          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGT           *string  `json:"revisionGT,omitempty"`
	RevisionGTE          *string  `json:"revisionGTE,omitempty"`
	RevisionLT           *string  `json:"revisionLT,omitempty"`
	RevisionLTE          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        bool     `json:"revisionIsNil,omitempty"`
	RevisionNotNil       bool     `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                   `json:"statusIsNil,omitempty"`
	StatusNotNil bool                   `json:"statusNotNil,omitempty"`

	// "procedure_type" field predicates.
	ProcedureType             *string  `json:"procedureType,omitempty"`
	ProcedureTypeNEQ          *string  `json:"procedureTypeNEQ,omitempty"`
	ProcedureTypeIn           []string `json:"procedureTypeIn,omitempty"`
	ProcedureTypeNotIn        []string `json:"procedureTypeNotIn,omitempty"`
	ProcedureTypeGT           *string  `json:"procedureTypeGT,omitempty"`
	ProcedureTypeGTE          *string  `json:"procedureTypeGTE,omitempty"`
	ProcedureTypeLT           *string  `json:"procedureTypeLT,omitempty"`
	ProcedureTypeLTE          *string  `json:"procedureTypeLTE,omitempty"`
	ProcedureTypeContains     *string  `json:"procedureTypeContains,omitempty"`
	ProcedureTypeHasPrefix    *string  `json:"procedureTypeHasPrefix,omitempty"`
	ProcedureTypeHasSuffix    *string  `json:"procedureTypeHasSuffix,omitempty"`
	ProcedureTypeIsNil        bool     `json:"procedureTypeIsNil,omitempty"`
	ProcedureTypeNotNil       bool     `json:"procedureTypeNotNil,omitempty"`
	ProcedureTypeEqualFold    *string  `json:"procedureTypeEqualFold,omitempty"`
	ProcedureTypeContainsFold *string  `json:"procedureTypeContainsFold,omitempty"`

	// "details" field predicates.
	Details             *string  `json:"details,omitempty"`
	DetailsNEQ          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGT           *string  `json:"detailsGT,omitempty"`
	DetailsGTE          *string  `json:"detailsGTE,omitempty"`
	DetailsLT           *string  `json:"detailsLT,omitempty"`
	DetailsLTE          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        bool     `json:"detailsIsNil,omitempty"`
	DetailsNotNil       bool     `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`

	// "approval_required" field predicates.
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNEQ    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  bool  `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil bool  `json:"approvalRequiredNotNil,omitempty"`

	// "review_due" field predicates.
	ReviewDue       *time.Time  `json:"reviewDue,omitempty"`
	ReviewDueNEQ    *time.Time  `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGT     *time.Time  `json:"reviewDueGT,omitempty"`
	ReviewDueGTE    *time.Time  `json:"reviewDueGTE,omitempty"`
	ReviewDueLT     *time.Time  `json:"reviewDueLT,omitempty"`
	ReviewDueLTE    *time.Time  `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil bool        `json:"reviewDueNotNil,omitempty"`

	// "review_frequency" field predicates.
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNEQ    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  bool              `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil bool              `json:"reviewFrequencyNotNil,omitempty"`

	// "approver_id" field predicates.
	ApproverID             *string  `json:"approverID,omitempty"`
	ApproverIDNEQ          *string  `json:"approverIDNEQ,omitempty"`
	ApproverIDIn           []string `json:"approverIDIn,omitempty"`
	ApproverIDNotIn        []string `json:"approverIDNotIn,omitempty"`
	ApproverIDGT           *string  `json:"approverIDGT,omitempty"`
	ApproverIDGTE          *string  `json:"approverIDGTE,omitempty"`
	ApproverIDLT           *string  `json:"approverIDLT,omitempty"`
	ApproverIDLTE          *string  `json:"approverIDLTE,omitempty"`
	ApproverIDContains     *string  `json:"approverIDContains,omitempty"`
	ApproverIDHasPrefix    *string  `json:"approverIDHasPrefix,omitempty"`
	ApproverIDHasSuffix    *string  `json:"approverIDHasSuffix,omitempty"`
	ApproverIDIsNil        bool     `json:"approverIDIsNil,omitempty"`
	ApproverIDNotNil       bool     `json:"approverIDNotNil,omitempty"`
	ApproverIDEqualFold    *string  `json:"approverIDEqualFold,omitempty"`
	ApproverIDContainsFold *string  `json:"approverIDContainsFold,omitempty"`

	// "delegate_id" field predicates.
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIDNEQ          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIDGT           *string  `json:"delegateIDGT,omitempty"`
	DelegateIDGTE          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIDLT           *string  `json:"delegateIDLT,omitempty"`
	DelegateIDLTE          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        bool     `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       bool     `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "blocked_groups" edge predicates.
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`

	// "editors" edge predicates.
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`

	// "approver" edge predicates.
	HasApprover     *bool              `json:"hasApprover,omitempty"`
	HasApproverWith []*GroupWhereInput `json:"hasApproverWith,omitempty"`

	// "delegate" edge predicates.
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`

	// "controls" edge predicates.
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`

	// "subcontrols" edge predicates.
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`

	// "internal_policies" edge predicates.
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`

	// "programs" edge predicates.
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`

	// "narratives" edge predicates.
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`

	// "risks" edge predicates.
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProcedureWhereInput) AddPredicates(predicates ...predicate.Procedure) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProcedureWhereInput filter on the ProcedureQuery builder.
func (i *ProcedureWhereInput) Filter(q *ProcedureQuery) (*ProcedureQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProcedureWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProcedureWhereInput is returned in case the ProcedureWhereInput is empty.
var ErrEmptyProcedureWhereInput = errors.New("generated: empty predicate ProcedureWhereInput")

// P returns a predicate for filtering procedures.
// An error is returned if the input is empty or invalid.
func (i *ProcedureWhereInput) P() (predicate.Procedure, error) {
	var predicates []predicate.Procedure
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, procedure.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Procedure, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, procedure.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Procedure, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, procedure.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, procedure.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, procedure.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, procedure.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, procedure.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, procedure.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, procedure.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, procedure.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, procedure.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, procedure.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, procedure.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, procedure.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, procedure.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, procedure.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, procedure.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, procedure.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, procedure.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, procedure.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, procedure.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, procedure.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, procedure.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, procedure.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, procedure.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, procedure.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, procedure.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, procedure.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, procedure.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, procedure.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, procedure.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, procedure.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, procedure.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, procedure.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, procedure.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, procedure.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, procedure.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, procedure.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, procedure.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, procedure.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, procedure.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, procedure.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, procedure.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, procedure.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, procedure.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, procedure.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, procedure.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, procedure.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, procedure.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, procedure.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, procedure.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, procedure.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, procedure.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, procedure.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, procedure.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, procedure.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, procedure.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, procedure.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, procedure.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, procedure.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, procedure.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, procedure.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, procedure.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, procedure.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, procedure.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, procedure.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, procedure.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, procedure.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, procedure.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, procedure.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, procedure.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, procedure.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, procedure.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, procedure.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, procedure.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, procedure.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.Revision != nil {
		predicates = append(predicates, procedure.RevisionEQ(*i.Revision))
	}
	if i.RevisionNEQ != nil {
		predicates = append(predicates, procedure.RevisionNEQ(*i.RevisionNEQ))
	}
	if len(i.RevisionIn) > 0 {
		predicates = append(predicates, procedure.RevisionIn(i.RevisionIn...))
	}
	if len(i.RevisionNotIn) > 0 {
		predicates = append(predicates, procedure.RevisionNotIn(i.RevisionNotIn...))
	}
	if i.RevisionGT != nil {
		predicates = append(predicates, procedure.RevisionGT(*i.RevisionGT))
	}
	if i.RevisionGTE != nil {
		predicates = append(predicates, procedure.RevisionGTE(*i.RevisionGTE))
	}
	if i.RevisionLT != nil {
		predicates = append(predicates, procedure.RevisionLT(*i.RevisionLT))
	}
	if i.RevisionLTE != nil {
		predicates = append(predicates, procedure.RevisionLTE(*i.RevisionLTE))
	}
	if i.RevisionContains != nil {
		predicates = append(predicates, procedure.RevisionContains(*i.RevisionContains))
	}
	if i.RevisionHasPrefix != nil {
		predicates = append(predicates, procedure.RevisionHasPrefix(*i.RevisionHasPrefix))
	}
	if i.RevisionHasSuffix != nil {
		predicates = append(predicates, procedure.RevisionHasSuffix(*i.RevisionHasSuffix))
	}
	if i.RevisionIsNil {
		predicates = append(predicates, procedure.RevisionIsNil())
	}
	if i.RevisionNotNil {
		predicates = append(predicates, procedure.RevisionNotNil())
	}
	if i.RevisionEqualFold != nil {
		predicates = append(predicates, procedure.RevisionEqualFold(*i.RevisionEqualFold))
	}
	if i.RevisionContainsFold != nil {
		predicates = append(predicates, procedure.RevisionContainsFold(*i.RevisionContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, procedure.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, procedure.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, procedure.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, procedure.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, procedure.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, procedure.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, procedure.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, procedure.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, procedure.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, procedure.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, procedure.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, procedure.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, procedure.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, procedure.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, procedure.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, procedure.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, procedure.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, procedure.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, procedure.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, procedure.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, procedure.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, procedure.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, procedure.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, procedure.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, procedure.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, procedure.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, procedure.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, procedure.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, procedure.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, procedure.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, procedure.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, procedure.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, procedure.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, procedure.StatusNotNil())
	}
	if i.ProcedureType != nil {
		predicates = append(predicates, procedure.ProcedureTypeEQ(*i.ProcedureType))
	}
	if i.ProcedureTypeNEQ != nil {
		predicates = append(predicates, procedure.ProcedureTypeNEQ(*i.ProcedureTypeNEQ))
	}
	if len(i.ProcedureTypeIn) > 0 {
		predicates = append(predicates, procedure.ProcedureTypeIn(i.ProcedureTypeIn...))
	}
	if len(i.ProcedureTypeNotIn) > 0 {
		predicates = append(predicates, procedure.ProcedureTypeNotIn(i.ProcedureTypeNotIn...))
	}
	if i.ProcedureTypeGT != nil {
		predicates = append(predicates, procedure.ProcedureTypeGT(*i.ProcedureTypeGT))
	}
	if i.ProcedureTypeGTE != nil {
		predicates = append(predicates, procedure.ProcedureTypeGTE(*i.ProcedureTypeGTE))
	}
	if i.ProcedureTypeLT != nil {
		predicates = append(predicates, procedure.ProcedureTypeLT(*i.ProcedureTypeLT))
	}
	if i.ProcedureTypeLTE != nil {
		predicates = append(predicates, procedure.ProcedureTypeLTE(*i.ProcedureTypeLTE))
	}
	if i.ProcedureTypeContains != nil {
		predicates = append(predicates, procedure.ProcedureTypeContains(*i.ProcedureTypeContains))
	}
	if i.ProcedureTypeHasPrefix != nil {
		predicates = append(predicates, procedure.ProcedureTypeHasPrefix(*i.ProcedureTypeHasPrefix))
	}
	if i.ProcedureTypeHasSuffix != nil {
		predicates = append(predicates, procedure.ProcedureTypeHasSuffix(*i.ProcedureTypeHasSuffix))
	}
	if i.ProcedureTypeIsNil {
		predicates = append(predicates, procedure.ProcedureTypeIsNil())
	}
	if i.ProcedureTypeNotNil {
		predicates = append(predicates, procedure.ProcedureTypeNotNil())
	}
	if i.ProcedureTypeEqualFold != nil {
		predicates = append(predicates, procedure.ProcedureTypeEqualFold(*i.ProcedureTypeEqualFold))
	}
	if i.ProcedureTypeContainsFold != nil {
		predicates = append(predicates, procedure.ProcedureTypeContainsFold(*i.ProcedureTypeContainsFold))
	}
	if i.Details != nil {
		predicates = append(predicates, procedure.DetailsEQ(*i.Details))
	}
	if i.DetailsNEQ != nil {
		predicates = append(predicates, procedure.DetailsNEQ(*i.DetailsNEQ))
	}
	if len(i.DetailsIn) > 0 {
		predicates = append(predicates, procedure.DetailsIn(i.DetailsIn...))
	}
	if len(i.DetailsNotIn) > 0 {
		predicates = append(predicates, procedure.DetailsNotIn(i.DetailsNotIn...))
	}
	if i.DetailsGT != nil {
		predicates = append(predicates, procedure.DetailsGT(*i.DetailsGT))
	}
	if i.DetailsGTE != nil {
		predicates = append(predicates, procedure.DetailsGTE(*i.DetailsGTE))
	}
	if i.DetailsLT != nil {
		predicates = append(predicates, procedure.DetailsLT(*i.DetailsLT))
	}
	if i.DetailsLTE != nil {
		predicates = append(predicates, procedure.DetailsLTE(*i.DetailsLTE))
	}
	if i.DetailsContains != nil {
		predicates = append(predicates, procedure.DetailsContains(*i.DetailsContains))
	}
	if i.DetailsHasPrefix != nil {
		predicates = append(predicates, procedure.DetailsHasPrefix(*i.DetailsHasPrefix))
	}
	if i.DetailsHasSuffix != nil {
		predicates = append(predicates, procedure.DetailsHasSuffix(*i.DetailsHasSuffix))
	}
	if i.DetailsIsNil {
		predicates = append(predicates, procedure.DetailsIsNil())
	}
	if i.DetailsNotNil {
		predicates = append(predicates, procedure.DetailsNotNil())
	}
	if i.DetailsEqualFold != nil {
		predicates = append(predicates, procedure.DetailsEqualFold(*i.DetailsEqualFold))
	}
	if i.DetailsContainsFold != nil {
		predicates = append(predicates, procedure.DetailsContainsFold(*i.DetailsContainsFold))
	}
	if i.ApprovalRequired != nil {
		predicates = append(predicates, procedure.ApprovalRequiredEQ(*i.ApprovalRequired))
	}
	if i.ApprovalRequiredNEQ != nil {
		predicates = append(predicates, procedure.ApprovalRequiredNEQ(*i.ApprovalRequiredNEQ))
	}
	if i.ApprovalRequiredIsNil {
		predicates = append(predicates, procedure.ApprovalRequiredIsNil())
	}
	if i.ApprovalRequiredNotNil {
		predicates = append(predicates, procedure.ApprovalRequiredNotNil())
	}
	if i.ReviewDue != nil {
		predicates = append(predicates, procedure.ReviewDueEQ(*i.ReviewDue))
	}
	if i.ReviewDueNEQ != nil {
		predicates = append(predicates, procedure.ReviewDueNEQ(*i.ReviewDueNEQ))
	}
	if len(i.ReviewDueIn) > 0 {
		predicates = append(predicates, procedure.ReviewDueIn(i.ReviewDueIn...))
	}
	if len(i.ReviewDueNotIn) > 0 {
		predicates = append(predicates, procedure.ReviewDueNotIn(i.ReviewDueNotIn...))
	}
	if i.ReviewDueGT != nil {
		predicates = append(predicates, procedure.ReviewDueGT(*i.ReviewDueGT))
	}
	if i.ReviewDueGTE != nil {
		predicates = append(predicates, procedure.ReviewDueGTE(*i.ReviewDueGTE))
	}
	if i.ReviewDueLT != nil {
		predicates = append(predicates, procedure.ReviewDueLT(*i.ReviewDueLT))
	}
	if i.ReviewDueLTE != nil {
		predicates = append(predicates, procedure.ReviewDueLTE(*i.ReviewDueLTE))
	}
	if i.ReviewDueIsNil {
		predicates = append(predicates, procedure.ReviewDueIsNil())
	}
	if i.ReviewDueNotNil {
		predicates = append(predicates, procedure.ReviewDueNotNil())
	}
	if i.ReviewFrequency != nil {
		predicates = append(predicates, procedure.ReviewFrequencyEQ(*i.ReviewFrequency))
	}
	if i.ReviewFrequencyNEQ != nil {
		predicates = append(predicates, procedure.ReviewFrequencyNEQ(*i.ReviewFrequencyNEQ))
	}
	if len(i.ReviewFrequencyIn) > 0 {
		predicates = append(predicates, procedure.ReviewFrequencyIn(i.ReviewFrequencyIn...))
	}
	if len(i.ReviewFrequencyNotIn) > 0 {
		predicates = append(predicates, procedure.ReviewFrequencyNotIn(i.ReviewFrequencyNotIn...))
	}
	if i.ReviewFrequencyIsNil {
		predicates = append(predicates, procedure.ReviewFrequencyIsNil())
	}
	if i.ReviewFrequencyNotNil {
		predicates = append(predicates, procedure.ReviewFrequencyNotNil())
	}
	if i.ApproverID != nil {
		predicates = append(predicates, procedure.ApproverIDEQ(*i.ApproverID))
	}
	if i.ApproverIDNEQ != nil {
		predicates = append(predicates, procedure.ApproverIDNEQ(*i.ApproverIDNEQ))
	}
	if len(i.ApproverIDIn) > 0 {
		predicates = append(predicates, procedure.ApproverIDIn(i.ApproverIDIn...))
	}
	if len(i.ApproverIDNotIn) > 0 {
		predicates = append(predicates, procedure.ApproverIDNotIn(i.ApproverIDNotIn...))
	}
	if i.ApproverIDGT != nil {
		predicates = append(predicates, procedure.ApproverIDGT(*i.ApproverIDGT))
	}
	if i.ApproverIDGTE != nil {
		predicates = append(predicates, procedure.ApproverIDGTE(*i.ApproverIDGTE))
	}
	if i.ApproverIDLT != nil {
		predicates = append(predicates, procedure.ApproverIDLT(*i.ApproverIDLT))
	}
	if i.ApproverIDLTE != nil {
		predicates = append(predicates, procedure.ApproverIDLTE(*i.ApproverIDLTE))
	}
	if i.ApproverIDContains != nil {
		predicates = append(predicates, procedure.ApproverIDContains(*i.ApproverIDContains))
	}
	if i.ApproverIDHasPrefix != nil {
		predicates = append(predicates, procedure.ApproverIDHasPrefix(*i.ApproverIDHasPrefix))
	}
	if i.ApproverIDHasSuffix != nil {
		predicates = append(predicates, procedure.ApproverIDHasSuffix(*i.ApproverIDHasSuffix))
	}
	if i.ApproverIDIsNil {
		predicates = append(predicates, procedure.ApproverIDIsNil())
	}
	if i.ApproverIDNotNil {
		predicates = append(predicates, procedure.ApproverIDNotNil())
	}
	if i.ApproverIDEqualFold != nil {
		predicates = append(predicates, procedure.ApproverIDEqualFold(*i.ApproverIDEqualFold))
	}
	if i.ApproverIDContainsFold != nil {
		predicates = append(predicates, procedure.ApproverIDContainsFold(*i.ApproverIDContainsFold))
	}
	if i.DelegateID != nil {
		predicates = append(predicates, procedure.DelegateIDEQ(*i.DelegateID))
	}
	if i.DelegateIDNEQ != nil {
		predicates = append(predicates, procedure.DelegateIDNEQ(*i.DelegateIDNEQ))
	}
	if len(i.DelegateIDIn) > 0 {
		predicates = append(predicates, procedure.DelegateIDIn(i.DelegateIDIn...))
	}
	if len(i.DelegateIDNotIn) > 0 {
		predicates = append(predicates, procedure.DelegateIDNotIn(i.DelegateIDNotIn...))
	}
	if i.DelegateIDGT != nil {
		predicates = append(predicates, procedure.DelegateIDGT(*i.DelegateIDGT))
	}
	if i.DelegateIDGTE != nil {
		predicates = append(predicates, procedure.DelegateIDGTE(*i.DelegateIDGTE))
	}
	if i.DelegateIDLT != nil {
		predicates = append(predicates, procedure.DelegateIDLT(*i.DelegateIDLT))
	}
	if i.DelegateIDLTE != nil {
		predicates = append(predicates, procedure.DelegateIDLTE(*i.DelegateIDLTE))
	}
	if i.DelegateIDContains != nil {
		predicates = append(predicates, procedure.DelegateIDContains(*i.DelegateIDContains))
	}
	if i.DelegateIDHasPrefix != nil {
		predicates = append(predicates, procedure.DelegateIDHasPrefix(*i.DelegateIDHasPrefix))
	}
	if i.DelegateIDHasSuffix != nil {
		predicates = append(predicates, procedure.DelegateIDHasSuffix(*i.DelegateIDHasSuffix))
	}
	if i.DelegateIDIsNil {
		predicates = append(predicates, procedure.DelegateIDIsNil())
	}
	if i.DelegateIDNotNil {
		predicates = append(predicates, procedure.DelegateIDNotNil())
	}
	if i.DelegateIDEqualFold != nil {
		predicates = append(predicates, procedure.DelegateIDEqualFold(*i.DelegateIDEqualFold))
	}
	if i.DelegateIDContainsFold != nil {
		predicates = append(predicates, procedure.DelegateIDContainsFold(*i.DelegateIDContainsFold))
	}

	if i.HasOwner != nil {
		p := procedure.HasOwner()
		if !*i.HasOwner {
			p = procedure.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procedure.HasOwnerWith(with...))
	}
	if i.HasBlockedGroups != nil {
		p := procedure.HasBlockedGroups()
		if !*i.HasBlockedGroups {
			p = procedure.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBlockedGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasBlockedGroupsWith))
		for _, w := range i.HasBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procedure.HasBlockedGroupsWith(with...))
	}
	if i.HasEditors != nil {
		p := procedure.HasEditors()
		if !*i.HasEditors {
			p = procedure.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEditorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasEditorsWith))
		for _, w := range i.HasEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procedure.HasEditorsWith(with...))
	}
	if i.HasApprover != nil {
		p := procedure.HasApprover()
		if !*i.HasApprover {
			p = procedure.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasApproverWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasApproverWith))
		for _, w := range i.HasApproverWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasApproverWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procedure.HasApproverWith(with...))
	}
	if i.HasDelegate != nil {
		p := procedure.HasDelegate()
		if !*i.HasDelegate {
			p = procedure.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDelegateWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasDelegateWith))
		for _, w := range i.HasDelegateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDelegateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procedure.HasDelegateWith(with...))
	}
	if i.HasControls != nil {
		p := procedure.HasControls()
		if !*i.HasControls {
			p = procedure.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasControlsWith))
		for _, w := range i.HasControlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procedure.HasControlsWith(with...))
	}
	if i.HasSubcontrols != nil {
		p := procedure.HasSubcontrols()
		if !*i.HasSubcontrols {
			p = procedure.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubcontrolsWith) > 0 {
		with := make([]predicate.Subcontrol, 0, len(i.HasSubcontrolsWith))
		for _, w := range i.HasSubcontrolsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubcontrolsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procedure.HasSubcontrolsWith(with...))
	}
	if i.HasInternalPolicies != nil {
		p := procedure.HasInternalPolicies()
		if !*i.HasInternalPolicies {
			p = procedure.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInternalPoliciesWith) > 0 {
		with := make([]predicate.InternalPolicy, 0, len(i.HasInternalPoliciesWith))
		for _, w := range i.HasInternalPoliciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInternalPoliciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procedure.HasInternalPoliciesWith(with...))
	}
	if i.HasPrograms != nil {
		p := procedure.HasPrograms()
		if !*i.HasPrograms {
			p = procedure.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramsWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramsWith))
		for _, w := range i.HasProgramsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procedure.HasProgramsWith(with...))
	}
	if i.HasNarratives != nil {
		p := procedure.HasNarratives()
		if !*i.HasNarratives {
			p = procedure.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNarrativesWith) > 0 {
		with := make([]predicate.Narrative, 0, len(i.HasNarrativesWith))
		for _, w := range i.HasNarrativesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNarrativesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procedure.HasNarrativesWith(with...))
	}
	if i.HasRisks != nil {
		p := procedure.HasRisks()
		if !*i.HasRisks {
			p = procedure.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRisksWith) > 0 {
		with := make([]predicate.Risk, 0, len(i.HasRisksWith))
		for _, w := range i.HasRisksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRisksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procedure.HasRisksWith(with...))
	}
	if i.HasTasks != nil {
		p := procedure.HasTasks()
		if !*i.HasTasks {
			p = procedure.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procedure.HasTasksWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProcedureWhereInput
	case 1:
		return predicates[0], nil
	default:
		return procedure.And(predicates...), nil
	}
}

// ProcedureHistoryWhereInput represents a where input for filtering ProcedureHistory queries.
type ProcedureHistoryWhereInput struct {
	Predicates []predicate.ProcedureHistory  `json:"-"`
	Not        *ProcedureHistoryWhereInput   `json:"not,omitempty"`
	Or         []*ProcedureHistoryWhereInput `json:"or,omitempty"`
	And        []*ProcedureHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "revision" field predicates.
	Revision             *string  `json:"revision,omitempty"`
	RevisionNEQ          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGT           *string  `json:"revisionGT,omitempty"`
	RevisionGTE          *string  `json:"revisionGTE,omitempty"`
	RevisionLT           *string  `json:"revisionLT,omitempty"`
	RevisionLTE          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        bool     `json:"revisionIsNil,omitempty"`
	RevisionNotNil       bool     `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                   `json:"statusIsNil,omitempty"`
	StatusNotNil bool                   `json:"statusNotNil,omitempty"`

	// "procedure_type" field predicates.
	ProcedureType             *string  `json:"procedureType,omitempty"`
	ProcedureTypeNEQ          *string  `json:"procedureTypeNEQ,omitempty"`
	ProcedureTypeIn           []string `json:"procedureTypeIn,omitempty"`
	ProcedureTypeNotIn        []string `json:"procedureTypeNotIn,omitempty"`
	ProcedureTypeGT           *string  `json:"procedureTypeGT,omitempty"`
	ProcedureTypeGTE          *string  `json:"procedureTypeGTE,omitempty"`
	ProcedureTypeLT           *string  `json:"procedureTypeLT,omitempty"`
	ProcedureTypeLTE          *string  `json:"procedureTypeLTE,omitempty"`
	ProcedureTypeContains     *string  `json:"procedureTypeContains,omitempty"`
	ProcedureTypeHasPrefix    *string  `json:"procedureTypeHasPrefix,omitempty"`
	ProcedureTypeHasSuffix    *string  `json:"procedureTypeHasSuffix,omitempty"`
	ProcedureTypeIsNil        bool     `json:"procedureTypeIsNil,omitempty"`
	ProcedureTypeNotNil       bool     `json:"procedureTypeNotNil,omitempty"`
	ProcedureTypeEqualFold    *string  `json:"procedureTypeEqualFold,omitempty"`
	ProcedureTypeContainsFold *string  `json:"procedureTypeContainsFold,omitempty"`

	// "details" field predicates.
	Details             *string  `json:"details,omitempty"`
	DetailsNEQ          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGT           *string  `json:"detailsGT,omitempty"`
	DetailsGTE          *string  `json:"detailsGTE,omitempty"`
	DetailsLT           *string  `json:"detailsLT,omitempty"`
	DetailsLTE          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        bool     `json:"detailsIsNil,omitempty"`
	DetailsNotNil       bool     `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`

	// "approval_required" field predicates.
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNEQ    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  bool  `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil bool  `json:"approvalRequiredNotNil,omitempty"`

	// "review_due" field predicates.
	ReviewDue       *time.Time  `json:"reviewDue,omitempty"`
	ReviewDueNEQ    *time.Time  `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGT     *time.Time  `json:"reviewDueGT,omitempty"`
	ReviewDueGTE    *time.Time  `json:"reviewDueGTE,omitempty"`
	ReviewDueLT     *time.Time  `json:"reviewDueLT,omitempty"`
	ReviewDueLTE    *time.Time  `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil bool        `json:"reviewDueNotNil,omitempty"`

	// "review_frequency" field predicates.
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNEQ    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  bool              `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil bool              `json:"reviewFrequencyNotNil,omitempty"`

	// "approver_id" field predicates.
	ApproverID             *string  `json:"approverID,omitempty"`
	ApproverIDNEQ          *string  `json:"approverIDNEQ,omitempty"`
	ApproverIDIn           []string `json:"approverIDIn,omitempty"`
	ApproverIDNotIn        []string `json:"approverIDNotIn,omitempty"`
	ApproverIDGT           *string  `json:"approverIDGT,omitempty"`
	ApproverIDGTE          *string  `json:"approverIDGTE,omitempty"`
	ApproverIDLT           *string  `json:"approverIDLT,omitempty"`
	ApproverIDLTE          *string  `json:"approverIDLTE,omitempty"`
	ApproverIDContains     *string  `json:"approverIDContains,omitempty"`
	ApproverIDHasPrefix    *string  `json:"approverIDHasPrefix,omitempty"`
	ApproverIDHasSuffix    *string  `json:"approverIDHasSuffix,omitempty"`
	ApproverIDIsNil        bool     `json:"approverIDIsNil,omitempty"`
	ApproverIDNotNil       bool     `json:"approverIDNotNil,omitempty"`
	ApproverIDEqualFold    *string  `json:"approverIDEqualFold,omitempty"`
	ApproverIDContainsFold *string  `json:"approverIDContainsFold,omitempty"`

	// "delegate_id" field predicates.
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIDNEQ          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIDGT           *string  `json:"delegateIDGT,omitempty"`
	DelegateIDGTE          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIDLT           *string  `json:"delegateIDLT,omitempty"`
	DelegateIDLTE          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        bool     `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       bool     `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProcedureHistoryWhereInput) AddPredicates(predicates ...predicate.ProcedureHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProcedureHistoryWhereInput filter on the ProcedureHistoryQuery builder.
func (i *ProcedureHistoryWhereInput) Filter(q *ProcedureHistoryQuery) (*ProcedureHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProcedureHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProcedureHistoryWhereInput is returned in case the ProcedureHistoryWhereInput is empty.
var ErrEmptyProcedureHistoryWhereInput = errors.New("generated: empty predicate ProcedureHistoryWhereInput")

// P returns a predicate for filtering procedurehistories.
// An error is returned if the input is empty or invalid.
func (i *ProcedureHistoryWhereInput) P() (predicate.ProcedureHistory, error) {
	var predicates []predicate.ProcedureHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, procedurehistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProcedureHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, procedurehistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProcedureHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, procedurehistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, procedurehistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, procedurehistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, procedurehistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, procedurehistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, procedurehistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, procedurehistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, procedurehistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, procedurehistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, procedurehistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, procedurehistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, procedurehistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, procedurehistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, procedurehistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, procedurehistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, procedurehistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, procedurehistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, procedurehistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, procedurehistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, procedurehistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, procedurehistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, procedurehistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, procedurehistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, procedurehistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, procedurehistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, procedurehistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, procedurehistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, procedurehistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, procedurehistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, procedurehistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, procedurehistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, procedurehistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, procedurehistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, procedurehistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, procedurehistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, procedurehistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, procedurehistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, procedurehistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, procedurehistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, procedurehistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, procedurehistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, procedurehistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, procedurehistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, procedurehistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, procedurehistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, procedurehistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, procedurehistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, procedurehistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, procedurehistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, procedurehistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, procedurehistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, procedurehistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, procedurehistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, procedurehistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, procedurehistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, procedurehistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, procedurehistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, procedurehistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, procedurehistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, procedurehistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, procedurehistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, procedurehistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, procedurehistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, procedurehistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, procedurehistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, procedurehistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, procedurehistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, procedurehistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, procedurehistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, procedurehistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, procedurehistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, procedurehistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, procedurehistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, procedurehistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, procedurehistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, procedurehistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, procedurehistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, procedurehistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, procedurehistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, procedurehistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, procedurehistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, procedurehistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, procedurehistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, procedurehistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, procedurehistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, procedurehistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, procedurehistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, procedurehistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, procedurehistory.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, procedurehistory.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, procedurehistory.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, procedurehistory.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, procedurehistory.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, procedurehistory.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, procedurehistory.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, procedurehistory.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, procedurehistory.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, procedurehistory.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, procedurehistory.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, procedurehistory.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, procedurehistory.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.Revision != nil {
		predicates = append(predicates, procedurehistory.RevisionEQ(*i.Revision))
	}
	if i.RevisionNEQ != nil {
		predicates = append(predicates, procedurehistory.RevisionNEQ(*i.RevisionNEQ))
	}
	if len(i.RevisionIn) > 0 {
		predicates = append(predicates, procedurehistory.RevisionIn(i.RevisionIn...))
	}
	if len(i.RevisionNotIn) > 0 {
		predicates = append(predicates, procedurehistory.RevisionNotIn(i.RevisionNotIn...))
	}
	if i.RevisionGT != nil {
		predicates = append(predicates, procedurehistory.RevisionGT(*i.RevisionGT))
	}
	if i.RevisionGTE != nil {
		predicates = append(predicates, procedurehistory.RevisionGTE(*i.RevisionGTE))
	}
	if i.RevisionLT != nil {
		predicates = append(predicates, procedurehistory.RevisionLT(*i.RevisionLT))
	}
	if i.RevisionLTE != nil {
		predicates = append(predicates, procedurehistory.RevisionLTE(*i.RevisionLTE))
	}
	if i.RevisionContains != nil {
		predicates = append(predicates, procedurehistory.RevisionContains(*i.RevisionContains))
	}
	if i.RevisionHasPrefix != nil {
		predicates = append(predicates, procedurehistory.RevisionHasPrefix(*i.RevisionHasPrefix))
	}
	if i.RevisionHasSuffix != nil {
		predicates = append(predicates, procedurehistory.RevisionHasSuffix(*i.RevisionHasSuffix))
	}
	if i.RevisionIsNil {
		predicates = append(predicates, procedurehistory.RevisionIsNil())
	}
	if i.RevisionNotNil {
		predicates = append(predicates, procedurehistory.RevisionNotNil())
	}
	if i.RevisionEqualFold != nil {
		predicates = append(predicates, procedurehistory.RevisionEqualFold(*i.RevisionEqualFold))
	}
	if i.RevisionContainsFold != nil {
		predicates = append(predicates, procedurehistory.RevisionContainsFold(*i.RevisionContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, procedurehistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, procedurehistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, procedurehistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, procedurehistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, procedurehistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, procedurehistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, procedurehistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, procedurehistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, procedurehistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, procedurehistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, procedurehistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, procedurehistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, procedurehistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, procedurehistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, procedurehistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, procedurehistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, procedurehistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, procedurehistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, procedurehistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, procedurehistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, procedurehistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, procedurehistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, procedurehistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, procedurehistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, procedurehistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, procedurehistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, procedurehistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, procedurehistory.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, procedurehistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, procedurehistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, procedurehistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, procedurehistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, procedurehistory.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, procedurehistory.StatusNotNil())
	}
	if i.ProcedureType != nil {
		predicates = append(predicates, procedurehistory.ProcedureTypeEQ(*i.ProcedureType))
	}
	if i.ProcedureTypeNEQ != nil {
		predicates = append(predicates, procedurehistory.ProcedureTypeNEQ(*i.ProcedureTypeNEQ))
	}
	if len(i.ProcedureTypeIn) > 0 {
		predicates = append(predicates, procedurehistory.ProcedureTypeIn(i.ProcedureTypeIn...))
	}
	if len(i.ProcedureTypeNotIn) > 0 {
		predicates = append(predicates, procedurehistory.ProcedureTypeNotIn(i.ProcedureTypeNotIn...))
	}
	if i.ProcedureTypeGT != nil {
		predicates = append(predicates, procedurehistory.ProcedureTypeGT(*i.ProcedureTypeGT))
	}
	if i.ProcedureTypeGTE != nil {
		predicates = append(predicates, procedurehistory.ProcedureTypeGTE(*i.ProcedureTypeGTE))
	}
	if i.ProcedureTypeLT != nil {
		predicates = append(predicates, procedurehistory.ProcedureTypeLT(*i.ProcedureTypeLT))
	}
	if i.ProcedureTypeLTE != nil {
		predicates = append(predicates, procedurehistory.ProcedureTypeLTE(*i.ProcedureTypeLTE))
	}
	if i.ProcedureTypeContains != nil {
		predicates = append(predicates, procedurehistory.ProcedureTypeContains(*i.ProcedureTypeContains))
	}
	if i.ProcedureTypeHasPrefix != nil {
		predicates = append(predicates, procedurehistory.ProcedureTypeHasPrefix(*i.ProcedureTypeHasPrefix))
	}
	if i.ProcedureTypeHasSuffix != nil {
		predicates = append(predicates, procedurehistory.ProcedureTypeHasSuffix(*i.ProcedureTypeHasSuffix))
	}
	if i.ProcedureTypeIsNil {
		predicates = append(predicates, procedurehistory.ProcedureTypeIsNil())
	}
	if i.ProcedureTypeNotNil {
		predicates = append(predicates, procedurehistory.ProcedureTypeNotNil())
	}
	if i.ProcedureTypeEqualFold != nil {
		predicates = append(predicates, procedurehistory.ProcedureTypeEqualFold(*i.ProcedureTypeEqualFold))
	}
	if i.ProcedureTypeContainsFold != nil {
		predicates = append(predicates, procedurehistory.ProcedureTypeContainsFold(*i.ProcedureTypeContainsFold))
	}
	if i.Details != nil {
		predicates = append(predicates, procedurehistory.DetailsEQ(*i.Details))
	}
	if i.DetailsNEQ != nil {
		predicates = append(predicates, procedurehistory.DetailsNEQ(*i.DetailsNEQ))
	}
	if len(i.DetailsIn) > 0 {
		predicates = append(predicates, procedurehistory.DetailsIn(i.DetailsIn...))
	}
	if len(i.DetailsNotIn) > 0 {
		predicates = append(predicates, procedurehistory.DetailsNotIn(i.DetailsNotIn...))
	}
	if i.DetailsGT != nil {
		predicates = append(predicates, procedurehistory.DetailsGT(*i.DetailsGT))
	}
	if i.DetailsGTE != nil {
		predicates = append(predicates, procedurehistory.DetailsGTE(*i.DetailsGTE))
	}
	if i.DetailsLT != nil {
		predicates = append(predicates, procedurehistory.DetailsLT(*i.DetailsLT))
	}
	if i.DetailsLTE != nil {
		predicates = append(predicates, procedurehistory.DetailsLTE(*i.DetailsLTE))
	}
	if i.DetailsContains != nil {
		predicates = append(predicates, procedurehistory.DetailsContains(*i.DetailsContains))
	}
	if i.DetailsHasPrefix != nil {
		predicates = append(predicates, procedurehistory.DetailsHasPrefix(*i.DetailsHasPrefix))
	}
	if i.DetailsHasSuffix != nil {
		predicates = append(predicates, procedurehistory.DetailsHasSuffix(*i.DetailsHasSuffix))
	}
	if i.DetailsIsNil {
		predicates = append(predicates, procedurehistory.DetailsIsNil())
	}
	if i.DetailsNotNil {
		predicates = append(predicates, procedurehistory.DetailsNotNil())
	}
	if i.DetailsEqualFold != nil {
		predicates = append(predicates, procedurehistory.DetailsEqualFold(*i.DetailsEqualFold))
	}
	if i.DetailsContainsFold != nil {
		predicates = append(predicates, procedurehistory.DetailsContainsFold(*i.DetailsContainsFold))
	}
	if i.ApprovalRequired != nil {
		predicates = append(predicates, procedurehistory.ApprovalRequiredEQ(*i.ApprovalRequired))
	}
	if i.ApprovalRequiredNEQ != nil {
		predicates = append(predicates, procedurehistory.ApprovalRequiredNEQ(*i.ApprovalRequiredNEQ))
	}
	if i.ApprovalRequiredIsNil {
		predicates = append(predicates, procedurehistory.ApprovalRequiredIsNil())
	}
	if i.ApprovalRequiredNotNil {
		predicates = append(predicates, procedurehistory.ApprovalRequiredNotNil())
	}
	if i.ReviewDue != nil {
		predicates = append(predicates, procedurehistory.ReviewDueEQ(*i.ReviewDue))
	}
	if i.ReviewDueNEQ != nil {
		predicates = append(predicates, procedurehistory.ReviewDueNEQ(*i.ReviewDueNEQ))
	}
	if len(i.ReviewDueIn) > 0 {
		predicates = append(predicates, procedurehistory.ReviewDueIn(i.ReviewDueIn...))
	}
	if len(i.ReviewDueNotIn) > 0 {
		predicates = append(predicates, procedurehistory.ReviewDueNotIn(i.ReviewDueNotIn...))
	}
	if i.ReviewDueGT != nil {
		predicates = append(predicates, procedurehistory.ReviewDueGT(*i.ReviewDueGT))
	}
	if i.ReviewDueGTE != nil {
		predicates = append(predicates, procedurehistory.ReviewDueGTE(*i.ReviewDueGTE))
	}
	if i.ReviewDueLT != nil {
		predicates = append(predicates, procedurehistory.ReviewDueLT(*i.ReviewDueLT))
	}
	if i.ReviewDueLTE != nil {
		predicates = append(predicates, procedurehistory.ReviewDueLTE(*i.ReviewDueLTE))
	}
	if i.ReviewDueIsNil {
		predicates = append(predicates, procedurehistory.ReviewDueIsNil())
	}
	if i.ReviewDueNotNil {
		predicates = append(predicates, procedurehistory.ReviewDueNotNil())
	}
	if i.ReviewFrequency != nil {
		predicates = append(predicates, procedurehistory.ReviewFrequencyEQ(*i.ReviewFrequency))
	}
	if i.ReviewFrequencyNEQ != nil {
		predicates = append(predicates, procedurehistory.ReviewFrequencyNEQ(*i.ReviewFrequencyNEQ))
	}
	if len(i.ReviewFrequencyIn) > 0 {
		predicates = append(predicates, procedurehistory.ReviewFrequencyIn(i.ReviewFrequencyIn...))
	}
	if len(i.ReviewFrequencyNotIn) > 0 {
		predicates = append(predicates, procedurehistory.ReviewFrequencyNotIn(i.ReviewFrequencyNotIn...))
	}
	if i.ReviewFrequencyIsNil {
		predicates = append(predicates, procedurehistory.ReviewFrequencyIsNil())
	}
	if i.ReviewFrequencyNotNil {
		predicates = append(predicates, procedurehistory.ReviewFrequencyNotNil())
	}
	if i.ApproverID != nil {
		predicates = append(predicates, procedurehistory.ApproverIDEQ(*i.ApproverID))
	}
	if i.ApproverIDNEQ != nil {
		predicates = append(predicates, procedurehistory.ApproverIDNEQ(*i.ApproverIDNEQ))
	}
	if len(i.ApproverIDIn) > 0 {
		predicates = append(predicates, procedurehistory.ApproverIDIn(i.ApproverIDIn...))
	}
	if len(i.ApproverIDNotIn) > 0 {
		predicates = append(predicates, procedurehistory.ApproverIDNotIn(i.ApproverIDNotIn...))
	}
	if i.ApproverIDGT != nil {
		predicates = append(predicates, procedurehistory.ApproverIDGT(*i.ApproverIDGT))
	}
	if i.ApproverIDGTE != nil {
		predicates = append(predicates, procedurehistory.ApproverIDGTE(*i.ApproverIDGTE))
	}
	if i.ApproverIDLT != nil {
		predicates = append(predicates, procedurehistory.ApproverIDLT(*i.ApproverIDLT))
	}
	if i.ApproverIDLTE != nil {
		predicates = append(predicates, procedurehistory.ApproverIDLTE(*i.ApproverIDLTE))
	}
	if i.ApproverIDContains != nil {
		predicates = append(predicates, procedurehistory.ApproverIDContains(*i.ApproverIDContains))
	}
	if i.ApproverIDHasPrefix != nil {
		predicates = append(predicates, procedurehistory.ApproverIDHasPrefix(*i.ApproverIDHasPrefix))
	}
	if i.ApproverIDHasSuffix != nil {
		predicates = append(predicates, procedurehistory.ApproverIDHasSuffix(*i.ApproverIDHasSuffix))
	}
	if i.ApproverIDIsNil {
		predicates = append(predicates, procedurehistory.ApproverIDIsNil())
	}
	if i.ApproverIDNotNil {
		predicates = append(predicates, procedurehistory.ApproverIDNotNil())
	}
	if i.ApproverIDEqualFold != nil {
		predicates = append(predicates, procedurehistory.ApproverIDEqualFold(*i.ApproverIDEqualFold))
	}
	if i.ApproverIDContainsFold != nil {
		predicates = append(predicates, procedurehistory.ApproverIDContainsFold(*i.ApproverIDContainsFold))
	}
	if i.DelegateID != nil {
		predicates = append(predicates, procedurehistory.DelegateIDEQ(*i.DelegateID))
	}
	if i.DelegateIDNEQ != nil {
		predicates = append(predicates, procedurehistory.DelegateIDNEQ(*i.DelegateIDNEQ))
	}
	if len(i.DelegateIDIn) > 0 {
		predicates = append(predicates, procedurehistory.DelegateIDIn(i.DelegateIDIn...))
	}
	if len(i.DelegateIDNotIn) > 0 {
		predicates = append(predicates, procedurehistory.DelegateIDNotIn(i.DelegateIDNotIn...))
	}
	if i.DelegateIDGT != nil {
		predicates = append(predicates, procedurehistory.DelegateIDGT(*i.DelegateIDGT))
	}
	if i.DelegateIDGTE != nil {
		predicates = append(predicates, procedurehistory.DelegateIDGTE(*i.DelegateIDGTE))
	}
	if i.DelegateIDLT != nil {
		predicates = append(predicates, procedurehistory.DelegateIDLT(*i.DelegateIDLT))
	}
	if i.DelegateIDLTE != nil {
		predicates = append(predicates, procedurehistory.DelegateIDLTE(*i.DelegateIDLTE))
	}
	if i.DelegateIDContains != nil {
		predicates = append(predicates, procedurehistory.DelegateIDContains(*i.DelegateIDContains))
	}
	if i.DelegateIDHasPrefix != nil {
		predicates = append(predicates, procedurehistory.DelegateIDHasPrefix(*i.DelegateIDHasPrefix))
	}
	if i.DelegateIDHasSuffix != nil {
		predicates = append(predicates, procedurehistory.DelegateIDHasSuffix(*i.DelegateIDHasSuffix))
	}
	if i.DelegateIDIsNil {
		predicates = append(predicates, procedurehistory.DelegateIDIsNil())
	}
	if i.DelegateIDNotNil {
		predicates = append(predicates, procedurehistory.DelegateIDNotNil())
	}
	if i.DelegateIDEqualFold != nil {
		predicates = append(predicates, procedurehistory.DelegateIDEqualFold(*i.DelegateIDEqualFold))
	}
	if i.DelegateIDContainsFold != nil {
		predicates = append(predicates, procedurehistory.DelegateIDContainsFold(*i.DelegateIDContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProcedureHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return procedurehistory.And(predicates...), nil
	}
}

// ProgramWhereInput represents a where input for filtering Program queries.
type ProgramWhereInput struct {
	Predicates []predicate.Program  `json:"-"`
	Not        *ProgramWhereInput   `json:"not,omitempty"`
	Or         []*ProgramWhereInput `json:"or,omitempty"`
	And        []*ProgramWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "status" field predicates.
	Status      *enums.ProgramStatus  `json:"status,omitempty"`
	StatusNEQ   *enums.ProgramStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ProgramStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ProgramStatus `json:"statusNotIn,omitempty"`

	// "program_type" field predicates.
	ProgramType      *enums.ProgramType  `json:"programType,omitempty"`
	ProgramTypeNEQ   *enums.ProgramType  `json:"programTypeNEQ,omitempty"`
	ProgramTypeIn    []enums.ProgramType `json:"programTypeIn,omitempty"`
	ProgramTypeNotIn []enums.ProgramType `json:"programTypeNotIn,omitempty"`

	// "framework_name" field predicates.
	FrameworkName             *string  `json:"frameworkName,omitempty"`
	FrameworkNameNEQ          *string  `json:"frameworkNameNEQ,omitempty"`
	FrameworkNameIn           []string `json:"frameworkNameIn,omitempty"`
	FrameworkNameNotIn        []string `json:"frameworkNameNotIn,omitempty"`
	FrameworkNameGT           *string  `json:"frameworkNameGT,omitempty"`
	FrameworkNameGTE          *string  `json:"frameworkNameGTE,omitempty"`
	FrameworkNameLT           *string  `json:"frameworkNameLT,omitempty"`
	FrameworkNameLTE          *string  `json:"frameworkNameLTE,omitempty"`
	FrameworkNameContains     *string  `json:"frameworkNameContains,omitempty"`
	FrameworkNameHasPrefix    *string  `json:"frameworkNameHasPrefix,omitempty"`
	FrameworkNameHasSuffix    *string  `json:"frameworkNameHasSuffix,omitempty"`
	FrameworkNameIsNil        bool     `json:"frameworkNameIsNil,omitempty"`
	FrameworkNameNotNil       bool     `json:"frameworkNameNotNil,omitempty"`
	FrameworkNameEqualFold    *string  `json:"frameworkNameEqualFold,omitempty"`
	FrameworkNameContainsFold *string  `json:"frameworkNameContainsFold,omitempty"`

	// "start_date" field predicates.
	StartDate       *time.Time  `json:"startDate,omitempty"`
	StartDateNEQ    *time.Time  `json:"startDateNEQ,omitempty"`
	StartDateIn     []time.Time `json:"startDateIn,omitempty"`
	StartDateNotIn  []time.Time `json:"startDateNotIn,omitempty"`
	StartDateGT     *time.Time  `json:"startDateGT,omitempty"`
	StartDateGTE    *time.Time  `json:"startDateGTE,omitempty"`
	StartDateLT     *time.Time  `json:"startDateLT,omitempty"`
	StartDateLTE    *time.Time  `json:"startDateLTE,omitempty"`
	StartDateIsNil  bool        `json:"startDateIsNil,omitempty"`
	StartDateNotNil bool        `json:"startDateNotNil,omitempty"`

	// "end_date" field predicates.
	EndDate       *time.Time  `json:"endDate,omitempty"`
	EndDateNEQ    *time.Time  `json:"endDateNEQ,omitempty"`
	EndDateIn     []time.Time `json:"endDateIn,omitempty"`
	EndDateNotIn  []time.Time `json:"endDateNotIn,omitempty"`
	EndDateGT     *time.Time  `json:"endDateGT,omitempty"`
	EndDateGTE    *time.Time  `json:"endDateGTE,omitempty"`
	EndDateLT     *time.Time  `json:"endDateLT,omitempty"`
	EndDateLTE    *time.Time  `json:"endDateLTE,omitempty"`
	EndDateIsNil  bool        `json:"endDateIsNil,omitempty"`
	EndDateNotNil bool        `json:"endDateNotNil,omitempty"`

	// "auditor_ready" field predicates.
	AuditorReady    *bool `json:"auditorReady,omitempty"`
	AuditorReadyNEQ *bool `json:"auditorReadyNEQ,omitempty"`

	// "auditor_write_comments" field predicates.
	AuditorWriteComments    *bool `json:"auditorWriteComments,omitempty"`
	AuditorWriteCommentsNEQ *bool `json:"auditorWriteCommentsNEQ,omitempty"`

	// "auditor_read_comments" field predicates.
	AuditorReadComments    *bool `json:"auditorReadComments,omitempty"`
	AuditorReadCommentsNEQ *bool `json:"auditorReadCommentsNEQ,omitempty"`

	// "audit_firm" field predicates.
	AuditFirm             *string  `json:"auditFirm,omitempty"`
	AuditFirmNEQ          *string  `json:"auditFirmNEQ,omitempty"`
	AuditFirmIn           []string `json:"auditFirmIn,omitempty"`
	AuditFirmNotIn        []string `json:"auditFirmNotIn,omitempty"`
	AuditFirmGT           *string  `json:"auditFirmGT,omitempty"`
	AuditFirmGTE          *string  `json:"auditFirmGTE,omitempty"`
	AuditFirmLT           *string  `json:"auditFirmLT,omitempty"`
	AuditFirmLTE          *string  `json:"auditFirmLTE,omitempty"`
	AuditFirmContains     *string  `json:"auditFirmContains,omitempty"`
	AuditFirmHasPrefix    *string  `json:"auditFirmHasPrefix,omitempty"`
	AuditFirmHasSuffix    *string  `json:"auditFirmHasSuffix,omitempty"`
	AuditFirmIsNil        bool     `json:"auditFirmIsNil,omitempty"`
	AuditFirmNotNil       bool     `json:"auditFirmNotNil,omitempty"`
	AuditFirmEqualFold    *string  `json:"auditFirmEqualFold,omitempty"`
	AuditFirmContainsFold *string  `json:"auditFirmContainsFold,omitempty"`

	// "auditor" field predicates.
	Auditor             *string  `json:"auditor,omitempty"`
	AuditorNEQ          *string  `json:"auditorNEQ,omitempty"`
	AuditorIn           []string `json:"auditorIn,omitempty"`
	AuditorNotIn        []string `json:"auditorNotIn,omitempty"`
	AuditorGT           *string  `json:"auditorGT,omitempty"`
	AuditorGTE          *string  `json:"auditorGTE,omitempty"`
	AuditorLT           *string  `json:"auditorLT,omitempty"`
	AuditorLTE          *string  `json:"auditorLTE,omitempty"`
	AuditorContains     *string  `json:"auditorContains,omitempty"`
	AuditorHasPrefix    *string  `json:"auditorHasPrefix,omitempty"`
	AuditorHasSuffix    *string  `json:"auditorHasSuffix,omitempty"`
	AuditorIsNil        bool     `json:"auditorIsNil,omitempty"`
	AuditorNotNil       bool     `json:"auditorNotNil,omitempty"`
	AuditorEqualFold    *string  `json:"auditorEqualFold,omitempty"`
	AuditorContainsFold *string  `json:"auditorContainsFold,omitempty"`

	// "auditor_email" field predicates.
	AuditorEmail             *string  `json:"auditorEmail,omitempty"`
	AuditorEmailNEQ          *string  `json:"auditorEmailNEQ,omitempty"`
	AuditorEmailIn           []string `json:"auditorEmailIn,omitempty"`
	AuditorEmailNotIn        []string `json:"auditorEmailNotIn,omitempty"`
	AuditorEmailGT           *string  `json:"auditorEmailGT,omitempty"`
	AuditorEmailGTE          *string  `json:"auditorEmailGTE,omitempty"`
	AuditorEmailLT           *string  `json:"auditorEmailLT,omitempty"`
	AuditorEmailLTE          *string  `json:"auditorEmailLTE,omitempty"`
	AuditorEmailContains     *string  `json:"auditorEmailContains,omitempty"`
	AuditorEmailHasPrefix    *string  `json:"auditorEmailHasPrefix,omitempty"`
	AuditorEmailHasSuffix    *string  `json:"auditorEmailHasSuffix,omitempty"`
	AuditorEmailIsNil        bool     `json:"auditorEmailIsNil,omitempty"`
	AuditorEmailNotNil       bool     `json:"auditorEmailNotNil,omitempty"`
	AuditorEmailEqualFold    *string  `json:"auditorEmailEqualFold,omitempty"`
	AuditorEmailContainsFold *string  `json:"auditorEmailContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "blocked_groups" edge predicates.
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`

	// "editors" edge predicates.
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`

	// "viewers" edge predicates.
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`

	// "controls" edge predicates.
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`

	// "subcontrols" edge predicates.
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`

	// "control_objectives" edge predicates.
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`

	// "internal_policies" edge predicates.
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`

	// "procedures" edge predicates.
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`

	// "risks" edge predicates.
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`

	// "notes" edge predicates.
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`

	// "evidence" edge predicates.
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`

	// "narratives" edge predicates.
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`

	// "action_plans" edge predicates.
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "members" edge predicates.
	HasMembers     *bool                          `json:"hasMembers,omitempty"`
	HasMembersWith []*ProgramMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProgramWhereInput) AddPredicates(predicates ...predicate.Program) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProgramWhereInput filter on the ProgramQuery builder.
func (i *ProgramWhereInput) Filter(q *ProgramQuery) (*ProgramQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProgramWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProgramWhereInput is returned in case the ProgramWhereInput is empty.
var ErrEmptyProgramWhereInput = errors.New("generated: empty predicate ProgramWhereInput")

// P returns a predicate for filtering programs.
// An error is returned if the input is empty or invalid.
func (i *ProgramWhereInput) P() (predicate.Program, error) {
	var predicates []predicate.Program
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, program.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Program, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, program.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Program, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, program.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, program.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, program.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, program.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, program.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, program.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, program.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, program.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, program.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, program.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, program.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, program.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, program.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, program.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, program.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, program.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, program.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, program.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, program.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, program.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, program.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, program.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, program.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, program.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, program.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, program.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, program.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, program.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, program.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, program.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, program.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, program.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, program.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, program.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, program.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, program.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, program.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, program.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, program.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, program.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, program.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, program.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, program.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, program.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, program.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, program.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, program.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, program.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, program.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, program.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, program.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, program.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, program.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, program.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, program.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, program.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, program.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, program.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, program.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, program.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, program.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, program.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, program.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, program.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, program.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, program.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, program.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, program.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, program.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, program.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, program.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, program.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, program.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, program.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, program.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, program.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, program.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, program.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, program.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, program.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, program.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, program.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, program.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, program.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, program.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, program.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, program.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, program.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, program.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, program.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, program.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, program.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, program.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, program.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, program.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, program.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, program.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, program.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, program.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, program.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, program.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, program.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, program.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, program.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, program.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, program.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, program.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, program.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, program.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, program.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, program.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, program.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, program.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, program.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, program.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, program.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, program.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, program.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, program.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, program.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, program.StatusNotIn(i.StatusNotIn...))
	}
	if i.ProgramType != nil {
		predicates = append(predicates, program.ProgramTypeEQ(*i.ProgramType))
	}
	if i.ProgramTypeNEQ != nil {
		predicates = append(predicates, program.ProgramTypeNEQ(*i.ProgramTypeNEQ))
	}
	if len(i.ProgramTypeIn) > 0 {
		predicates = append(predicates, program.ProgramTypeIn(i.ProgramTypeIn...))
	}
	if len(i.ProgramTypeNotIn) > 0 {
		predicates = append(predicates, program.ProgramTypeNotIn(i.ProgramTypeNotIn...))
	}
	if i.FrameworkName != nil {
		predicates = append(predicates, program.FrameworkNameEQ(*i.FrameworkName))
	}
	if i.FrameworkNameNEQ != nil {
		predicates = append(predicates, program.FrameworkNameNEQ(*i.FrameworkNameNEQ))
	}
	if len(i.FrameworkNameIn) > 0 {
		predicates = append(predicates, program.FrameworkNameIn(i.FrameworkNameIn...))
	}
	if len(i.FrameworkNameNotIn) > 0 {
		predicates = append(predicates, program.FrameworkNameNotIn(i.FrameworkNameNotIn...))
	}
	if i.FrameworkNameGT != nil {
		predicates = append(predicates, program.FrameworkNameGT(*i.FrameworkNameGT))
	}
	if i.FrameworkNameGTE != nil {
		predicates = append(predicates, program.FrameworkNameGTE(*i.FrameworkNameGTE))
	}
	if i.FrameworkNameLT != nil {
		predicates = append(predicates, program.FrameworkNameLT(*i.FrameworkNameLT))
	}
	if i.FrameworkNameLTE != nil {
		predicates = append(predicates, program.FrameworkNameLTE(*i.FrameworkNameLTE))
	}
	if i.FrameworkNameContains != nil {
		predicates = append(predicates, program.FrameworkNameContains(*i.FrameworkNameContains))
	}
	if i.FrameworkNameHasPrefix != nil {
		predicates = append(predicates, program.FrameworkNameHasPrefix(*i.FrameworkNameHasPrefix))
	}
	if i.FrameworkNameHasSuffix != nil {
		predicates = append(predicates, program.FrameworkNameHasSuffix(*i.FrameworkNameHasSuffix))
	}
	if i.FrameworkNameIsNil {
		predicates = append(predicates, program.FrameworkNameIsNil())
	}
	if i.FrameworkNameNotNil {
		predicates = append(predicates, program.FrameworkNameNotNil())
	}
	if i.FrameworkNameEqualFold != nil {
		predicates = append(predicates, program.FrameworkNameEqualFold(*i.FrameworkNameEqualFold))
	}
	if i.FrameworkNameContainsFold != nil {
		predicates = append(predicates, program.FrameworkNameContainsFold(*i.FrameworkNameContainsFold))
	}
	if i.StartDate != nil {
		predicates = append(predicates, program.StartDateEQ(*i.StartDate))
	}
	if i.StartDateNEQ != nil {
		predicates = append(predicates, program.StartDateNEQ(*i.StartDateNEQ))
	}
	if len(i.StartDateIn) > 0 {
		predicates = append(predicates, program.StartDateIn(i.StartDateIn...))
	}
	if len(i.StartDateNotIn) > 0 {
		predicates = append(predicates, program.StartDateNotIn(i.StartDateNotIn...))
	}
	if i.StartDateGT != nil {
		predicates = append(predicates, program.StartDateGT(*i.StartDateGT))
	}
	if i.StartDateGTE != nil {
		predicates = append(predicates, program.StartDateGTE(*i.StartDateGTE))
	}
	if i.StartDateLT != nil {
		predicates = append(predicates, program.StartDateLT(*i.StartDateLT))
	}
	if i.StartDateLTE != nil {
		predicates = append(predicates, program.StartDateLTE(*i.StartDateLTE))
	}
	if i.StartDateIsNil {
		predicates = append(predicates, program.StartDateIsNil())
	}
	if i.StartDateNotNil {
		predicates = append(predicates, program.StartDateNotNil())
	}
	if i.EndDate != nil {
		predicates = append(predicates, program.EndDateEQ(*i.EndDate))
	}
	if i.EndDateNEQ != nil {
		predicates = append(predicates, program.EndDateNEQ(*i.EndDateNEQ))
	}
	if len(i.EndDateIn) > 0 {
		predicates = append(predicates, program.EndDateIn(i.EndDateIn...))
	}
	if len(i.EndDateNotIn) > 0 {
		predicates = append(predicates, program.EndDateNotIn(i.EndDateNotIn...))
	}
	if i.EndDateGT != nil {
		predicates = append(predicates, program.EndDateGT(*i.EndDateGT))
	}
	if i.EndDateGTE != nil {
		predicates = append(predicates, program.EndDateGTE(*i.EndDateGTE))
	}
	if i.EndDateLT != nil {
		predicates = append(predicates, program.EndDateLT(*i.EndDateLT))
	}
	if i.EndDateLTE != nil {
		predicates = append(predicates, program.EndDateLTE(*i.EndDateLTE))
	}
	if i.EndDateIsNil {
		predicates = append(predicates, program.EndDateIsNil())
	}
	if i.EndDateNotNil {
		predicates = append(predicates, program.EndDateNotNil())
	}
	if i.AuditorReady != nil {
		predicates = append(predicates, program.AuditorReadyEQ(*i.AuditorReady))
	}
	if i.AuditorReadyNEQ != nil {
		predicates = append(predicates, program.AuditorReadyNEQ(*i.AuditorReadyNEQ))
	}
	if i.AuditorWriteComments != nil {
		predicates = append(predicates, program.AuditorWriteCommentsEQ(*i.AuditorWriteComments))
	}
	if i.AuditorWriteCommentsNEQ != nil {
		predicates = append(predicates, program.AuditorWriteCommentsNEQ(*i.AuditorWriteCommentsNEQ))
	}
	if i.AuditorReadComments != nil {
		predicates = append(predicates, program.AuditorReadCommentsEQ(*i.AuditorReadComments))
	}
	if i.AuditorReadCommentsNEQ != nil {
		predicates = append(predicates, program.AuditorReadCommentsNEQ(*i.AuditorReadCommentsNEQ))
	}
	if i.AuditFirm != nil {
		predicates = append(predicates, program.AuditFirmEQ(*i.AuditFirm))
	}
	if i.AuditFirmNEQ != nil {
		predicates = append(predicates, program.AuditFirmNEQ(*i.AuditFirmNEQ))
	}
	if len(i.AuditFirmIn) > 0 {
		predicates = append(predicates, program.AuditFirmIn(i.AuditFirmIn...))
	}
	if len(i.AuditFirmNotIn) > 0 {
		predicates = append(predicates, program.AuditFirmNotIn(i.AuditFirmNotIn...))
	}
	if i.AuditFirmGT != nil {
		predicates = append(predicates, program.AuditFirmGT(*i.AuditFirmGT))
	}
	if i.AuditFirmGTE != nil {
		predicates = append(predicates, program.AuditFirmGTE(*i.AuditFirmGTE))
	}
	if i.AuditFirmLT != nil {
		predicates = append(predicates, program.AuditFirmLT(*i.AuditFirmLT))
	}
	if i.AuditFirmLTE != nil {
		predicates = append(predicates, program.AuditFirmLTE(*i.AuditFirmLTE))
	}
	if i.AuditFirmContains != nil {
		predicates = append(predicates, program.AuditFirmContains(*i.AuditFirmContains))
	}
	if i.AuditFirmHasPrefix != nil {
		predicates = append(predicates, program.AuditFirmHasPrefix(*i.AuditFirmHasPrefix))
	}
	if i.AuditFirmHasSuffix != nil {
		predicates = append(predicates, program.AuditFirmHasSuffix(*i.AuditFirmHasSuffix))
	}
	if i.AuditFirmIsNil {
		predicates = append(predicates, program.AuditFirmIsNil())
	}
	if i.AuditFirmNotNil {
		predicates = append(predicates, program.AuditFirmNotNil())
	}
	if i.AuditFirmEqualFold != nil {
		predicates = append(predicates, program.AuditFirmEqualFold(*i.AuditFirmEqualFold))
	}
	if i.AuditFirmContainsFold != nil {
		predicates = append(predicates, program.AuditFirmContainsFold(*i.AuditFirmContainsFold))
	}
	if i.Auditor != nil {
		predicates = append(predicates, program.AuditorEQ(*i.Auditor))
	}
	if i.AuditorNEQ != nil {
		predicates = append(predicates, program.AuditorNEQ(*i.AuditorNEQ))
	}
	if len(i.AuditorIn) > 0 {
		predicates = append(predicates, program.AuditorIn(i.AuditorIn...))
	}
	if len(i.AuditorNotIn) > 0 {
		predicates = append(predicates, program.AuditorNotIn(i.AuditorNotIn...))
	}
	if i.AuditorGT != nil {
		predicates = append(predicates, program.AuditorGT(*i.AuditorGT))
	}
	if i.AuditorGTE != nil {
		predicates = append(predicates, program.AuditorGTE(*i.AuditorGTE))
	}
	if i.AuditorLT != nil {
		predicates = append(predicates, program.AuditorLT(*i.AuditorLT))
	}
	if i.AuditorLTE != nil {
		predicates = append(predicates, program.AuditorLTE(*i.AuditorLTE))
	}
	if i.AuditorContains != nil {
		predicates = append(predicates, program.AuditorContains(*i.AuditorContains))
	}
	if i.AuditorHasPrefix != nil {
		predicates = append(predicates, program.AuditorHasPrefix(*i.AuditorHasPrefix))
	}
	if i.AuditorHasSuffix != nil {
		predicates = append(predicates, program.AuditorHasSuffix(*i.AuditorHasSuffix))
	}
	if i.AuditorIsNil {
		predicates = append(predicates, program.AuditorIsNil())
	}
	if i.AuditorNotNil {
		predicates = append(predicates, program.AuditorNotNil())
	}
	if i.AuditorEqualFold != nil {
		predicates = append(predicates, program.AuditorEqualFold(*i.AuditorEqualFold))
	}
	if i.AuditorContainsFold != nil {
		predicates = append(predicates, program.AuditorContainsFold(*i.AuditorContainsFold))
	}
	if i.AuditorEmail != nil {
		predicates = append(predicates, program.AuditorEmailEQ(*i.AuditorEmail))
	}
	if i.AuditorEmailNEQ != nil {
		predicates = append(predicates, program.AuditorEmailNEQ(*i.AuditorEmailNEQ))
	}
	if len(i.AuditorEmailIn) > 0 {
		predicates = append(predicates, program.AuditorEmailIn(i.AuditorEmailIn...))
	}
	if len(i.AuditorEmailNotIn) > 0 {
		predicates = append(predicates, program.AuditorEmailNotIn(i.AuditorEmailNotIn...))
	}
	if i.AuditorEmailGT != nil {
		predicates = append(predicates, program.AuditorEmailGT(*i.AuditorEmailGT))
	}
	if i.AuditorEmailGTE != nil {
		predicates = append(predicates, program.AuditorEmailGTE(*i.AuditorEmailGTE))
	}
	if i.AuditorEmailLT != nil {
		predicates = append(predicates, program.AuditorEmailLT(*i.AuditorEmailLT))
	}
	if i.AuditorEmailLTE != nil {
		predicates = append(predicates, program.AuditorEmailLTE(*i.AuditorEmailLTE))
	}
	if i.AuditorEmailContains != nil {
		predicates = append(predicates, program.AuditorEmailContains(*i.AuditorEmailContains))
	}
	if i.AuditorEmailHasPrefix != nil {
		predicates = append(predicates, program.AuditorEmailHasPrefix(*i.AuditorEmailHasPrefix))
	}
	if i.AuditorEmailHasSuffix != nil {
		predicates = append(predicates, program.AuditorEmailHasSuffix(*i.AuditorEmailHasSuffix))
	}
	if i.AuditorEmailIsNil {
		predicates = append(predicates, program.AuditorEmailIsNil())
	}
	if i.AuditorEmailNotNil {
		predicates = append(predicates, program.AuditorEmailNotNil())
	}
	if i.AuditorEmailEqualFold != nil {
		predicates = append(predicates, program.AuditorEmailEqualFold(*i.AuditorEmailEqualFold))
	}
	if i.AuditorEmailContainsFold != nil {
		predicates = append(predicates, program.AuditorEmailContainsFold(*i.AuditorEmailContainsFold))
	}

	if i.HasOwner != nil {
		p := program.HasOwner()
		if !*i.HasOwner {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasOwnerWith(with...))
	}
	if i.HasBlockedGroups != nil {
		p := program.HasBlockedGroups()
		if !*i.HasBlockedGroups {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBlockedGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasBlockedGroupsWith))
		for _, w := range i.HasBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasBlockedGroupsWith(with...))
	}
	if i.HasEditors != nil {
		p := program.HasEditors()
		if !*i.HasEditors {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEditorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasEditorsWith))
		for _, w := range i.HasEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasEditorsWith(with...))
	}
	if i.HasViewers != nil {
		p := program.HasViewers()
		if !*i.HasViewers {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasViewersWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasViewersWith))
		for _, w := range i.HasViewersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasViewersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasViewersWith(with...))
	}
	if i.HasControls != nil {
		p := program.HasControls()
		if !*i.HasControls {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasControlsWith))
		for _, w := range i.HasControlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasControlsWith(with...))
	}
	if i.HasSubcontrols != nil {
		p := program.HasSubcontrols()
		if !*i.HasSubcontrols {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubcontrolsWith) > 0 {
		with := make([]predicate.Subcontrol, 0, len(i.HasSubcontrolsWith))
		for _, w := range i.HasSubcontrolsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubcontrolsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasSubcontrolsWith(with...))
	}
	if i.HasControlObjectives != nil {
		p := program.HasControlObjectives()
		if !*i.HasControlObjectives {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlObjectivesWith) > 0 {
		with := make([]predicate.ControlObjective, 0, len(i.HasControlObjectivesWith))
		for _, w := range i.HasControlObjectivesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlObjectivesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasControlObjectivesWith(with...))
	}
	if i.HasInternalPolicies != nil {
		p := program.HasInternalPolicies()
		if !*i.HasInternalPolicies {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInternalPoliciesWith) > 0 {
		with := make([]predicate.InternalPolicy, 0, len(i.HasInternalPoliciesWith))
		for _, w := range i.HasInternalPoliciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInternalPoliciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasInternalPoliciesWith(with...))
	}
	if i.HasProcedures != nil {
		p := program.HasProcedures()
		if !*i.HasProcedures {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProceduresWith) > 0 {
		with := make([]predicate.Procedure, 0, len(i.HasProceduresWith))
		for _, w := range i.HasProceduresWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProceduresWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasProceduresWith(with...))
	}
	if i.HasRisks != nil {
		p := program.HasRisks()
		if !*i.HasRisks {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRisksWith) > 0 {
		with := make([]predicate.Risk, 0, len(i.HasRisksWith))
		for _, w := range i.HasRisksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRisksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasRisksWith(with...))
	}
	if i.HasTasks != nil {
		p := program.HasTasks()
		if !*i.HasTasks {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasTasksWith(with...))
	}
	if i.HasNotes != nil {
		p := program.HasNotes()
		if !*i.HasNotes {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNotesWith) > 0 {
		with := make([]predicate.Note, 0, len(i.HasNotesWith))
		for _, w := range i.HasNotesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNotesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasNotesWith(with...))
	}
	if i.HasFiles != nil {
		p := program.HasFiles()
		if !*i.HasFiles {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasFilesWith(with...))
	}
	if i.HasEvidence != nil {
		p := program.HasEvidence()
		if !*i.HasEvidence {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEvidenceWith) > 0 {
		with := make([]predicate.Evidence, 0, len(i.HasEvidenceWith))
		for _, w := range i.HasEvidenceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEvidenceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasEvidenceWith(with...))
	}
	if i.HasNarratives != nil {
		p := program.HasNarratives()
		if !*i.HasNarratives {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNarrativesWith) > 0 {
		with := make([]predicate.Narrative, 0, len(i.HasNarrativesWith))
		for _, w := range i.HasNarrativesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNarrativesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasNarrativesWith(with...))
	}
	if i.HasActionPlans != nil {
		p := program.HasActionPlans()
		if !*i.HasActionPlans {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionPlansWith) > 0 {
		with := make([]predicate.ActionPlan, 0, len(i.HasActionPlansWith))
		for _, w := range i.HasActionPlansWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionPlansWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasActionPlansWith(with...))
	}
	if i.HasUsers != nil {
		p := program.HasUsers()
		if !*i.HasUsers {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasUsersWith(with...))
	}
	if i.HasMembers != nil {
		p := program.HasMembers()
		if !*i.HasMembers {
			p = program.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMembersWith) > 0 {
		with := make([]predicate.ProgramMembership, 0, len(i.HasMembersWith))
		for _, w := range i.HasMembersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMembersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, program.HasMembersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProgramWhereInput
	case 1:
		return predicates[0], nil
	default:
		return program.And(predicates...), nil
	}
}

// ProgramHistoryWhereInput represents a where input for filtering ProgramHistory queries.
type ProgramHistoryWhereInput struct {
	Predicates []predicate.ProgramHistory  `json:"-"`
	Not        *ProgramHistoryWhereInput   `json:"not,omitempty"`
	Or         []*ProgramHistoryWhereInput `json:"or,omitempty"`
	And        []*ProgramHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "status" field predicates.
	Status      *enums.ProgramStatus  `json:"status,omitempty"`
	StatusNEQ   *enums.ProgramStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ProgramStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ProgramStatus `json:"statusNotIn,omitempty"`

	// "program_type" field predicates.
	ProgramType      *enums.ProgramType  `json:"programType,omitempty"`
	ProgramTypeNEQ   *enums.ProgramType  `json:"programTypeNEQ,omitempty"`
	ProgramTypeIn    []enums.ProgramType `json:"programTypeIn,omitempty"`
	ProgramTypeNotIn []enums.ProgramType `json:"programTypeNotIn,omitempty"`

	// "framework_name" field predicates.
	FrameworkName             *string  `json:"frameworkName,omitempty"`
	FrameworkNameNEQ          *string  `json:"frameworkNameNEQ,omitempty"`
	FrameworkNameIn           []string `json:"frameworkNameIn,omitempty"`
	FrameworkNameNotIn        []string `json:"frameworkNameNotIn,omitempty"`
	FrameworkNameGT           *string  `json:"frameworkNameGT,omitempty"`
	FrameworkNameGTE          *string  `json:"frameworkNameGTE,omitempty"`
	FrameworkNameLT           *string  `json:"frameworkNameLT,omitempty"`
	FrameworkNameLTE          *string  `json:"frameworkNameLTE,omitempty"`
	FrameworkNameContains     *string  `json:"frameworkNameContains,omitempty"`
	FrameworkNameHasPrefix    *string  `json:"frameworkNameHasPrefix,omitempty"`
	FrameworkNameHasSuffix    *string  `json:"frameworkNameHasSuffix,omitempty"`
	FrameworkNameIsNil        bool     `json:"frameworkNameIsNil,omitempty"`
	FrameworkNameNotNil       bool     `json:"frameworkNameNotNil,omitempty"`
	FrameworkNameEqualFold    *string  `json:"frameworkNameEqualFold,omitempty"`
	FrameworkNameContainsFold *string  `json:"frameworkNameContainsFold,omitempty"`

	// "start_date" field predicates.
	StartDate       *time.Time  `json:"startDate,omitempty"`
	StartDateNEQ    *time.Time  `json:"startDateNEQ,omitempty"`
	StartDateIn     []time.Time `json:"startDateIn,omitempty"`
	StartDateNotIn  []time.Time `json:"startDateNotIn,omitempty"`
	StartDateGT     *time.Time  `json:"startDateGT,omitempty"`
	StartDateGTE    *time.Time  `json:"startDateGTE,omitempty"`
	StartDateLT     *time.Time  `json:"startDateLT,omitempty"`
	StartDateLTE    *time.Time  `json:"startDateLTE,omitempty"`
	StartDateIsNil  bool        `json:"startDateIsNil,omitempty"`
	StartDateNotNil bool        `json:"startDateNotNil,omitempty"`

	// "end_date" field predicates.
	EndDate       *time.Time  `json:"endDate,omitempty"`
	EndDateNEQ    *time.Time  `json:"endDateNEQ,omitempty"`
	EndDateIn     []time.Time `json:"endDateIn,omitempty"`
	EndDateNotIn  []time.Time `json:"endDateNotIn,omitempty"`
	EndDateGT     *time.Time  `json:"endDateGT,omitempty"`
	EndDateGTE    *time.Time  `json:"endDateGTE,omitempty"`
	EndDateLT     *time.Time  `json:"endDateLT,omitempty"`
	EndDateLTE    *time.Time  `json:"endDateLTE,omitempty"`
	EndDateIsNil  bool        `json:"endDateIsNil,omitempty"`
	EndDateNotNil bool        `json:"endDateNotNil,omitempty"`

	// "auditor_ready" field predicates.
	AuditorReady    *bool `json:"auditorReady,omitempty"`
	AuditorReadyNEQ *bool `json:"auditorReadyNEQ,omitempty"`

	// "auditor_write_comments" field predicates.
	AuditorWriteComments    *bool `json:"auditorWriteComments,omitempty"`
	AuditorWriteCommentsNEQ *bool `json:"auditorWriteCommentsNEQ,omitempty"`

	// "auditor_read_comments" field predicates.
	AuditorReadComments    *bool `json:"auditorReadComments,omitempty"`
	AuditorReadCommentsNEQ *bool `json:"auditorReadCommentsNEQ,omitempty"`

	// "audit_firm" field predicates.
	AuditFirm             *string  `json:"auditFirm,omitempty"`
	AuditFirmNEQ          *string  `json:"auditFirmNEQ,omitempty"`
	AuditFirmIn           []string `json:"auditFirmIn,omitempty"`
	AuditFirmNotIn        []string `json:"auditFirmNotIn,omitempty"`
	AuditFirmGT           *string  `json:"auditFirmGT,omitempty"`
	AuditFirmGTE          *string  `json:"auditFirmGTE,omitempty"`
	AuditFirmLT           *string  `json:"auditFirmLT,omitempty"`
	AuditFirmLTE          *string  `json:"auditFirmLTE,omitempty"`
	AuditFirmContains     *string  `json:"auditFirmContains,omitempty"`
	AuditFirmHasPrefix    *string  `json:"auditFirmHasPrefix,omitempty"`
	AuditFirmHasSuffix    *string  `json:"auditFirmHasSuffix,omitempty"`
	AuditFirmIsNil        bool     `json:"auditFirmIsNil,omitempty"`
	AuditFirmNotNil       bool     `json:"auditFirmNotNil,omitempty"`
	AuditFirmEqualFold    *string  `json:"auditFirmEqualFold,omitempty"`
	AuditFirmContainsFold *string  `json:"auditFirmContainsFold,omitempty"`

	// "auditor" field predicates.
	Auditor             *string  `json:"auditor,omitempty"`
	AuditorNEQ          *string  `json:"auditorNEQ,omitempty"`
	AuditorIn           []string `json:"auditorIn,omitempty"`
	AuditorNotIn        []string `json:"auditorNotIn,omitempty"`
	AuditorGT           *string  `json:"auditorGT,omitempty"`
	AuditorGTE          *string  `json:"auditorGTE,omitempty"`
	AuditorLT           *string  `json:"auditorLT,omitempty"`
	AuditorLTE          *string  `json:"auditorLTE,omitempty"`
	AuditorContains     *string  `json:"auditorContains,omitempty"`
	AuditorHasPrefix    *string  `json:"auditorHasPrefix,omitempty"`
	AuditorHasSuffix    *string  `json:"auditorHasSuffix,omitempty"`
	AuditorIsNil        bool     `json:"auditorIsNil,omitempty"`
	AuditorNotNil       bool     `json:"auditorNotNil,omitempty"`
	AuditorEqualFold    *string  `json:"auditorEqualFold,omitempty"`
	AuditorContainsFold *string  `json:"auditorContainsFold,omitempty"`

	// "auditor_email" field predicates.
	AuditorEmail             *string  `json:"auditorEmail,omitempty"`
	AuditorEmailNEQ          *string  `json:"auditorEmailNEQ,omitempty"`
	AuditorEmailIn           []string `json:"auditorEmailIn,omitempty"`
	AuditorEmailNotIn        []string `json:"auditorEmailNotIn,omitempty"`
	AuditorEmailGT           *string  `json:"auditorEmailGT,omitempty"`
	AuditorEmailGTE          *string  `json:"auditorEmailGTE,omitempty"`
	AuditorEmailLT           *string  `json:"auditorEmailLT,omitempty"`
	AuditorEmailLTE          *string  `json:"auditorEmailLTE,omitempty"`
	AuditorEmailContains     *string  `json:"auditorEmailContains,omitempty"`
	AuditorEmailHasPrefix    *string  `json:"auditorEmailHasPrefix,omitempty"`
	AuditorEmailHasSuffix    *string  `json:"auditorEmailHasSuffix,omitempty"`
	AuditorEmailIsNil        bool     `json:"auditorEmailIsNil,omitempty"`
	AuditorEmailNotNil       bool     `json:"auditorEmailNotNil,omitempty"`
	AuditorEmailEqualFold    *string  `json:"auditorEmailEqualFold,omitempty"`
	AuditorEmailContainsFold *string  `json:"auditorEmailContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProgramHistoryWhereInput) AddPredicates(predicates ...predicate.ProgramHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProgramHistoryWhereInput filter on the ProgramHistoryQuery builder.
func (i *ProgramHistoryWhereInput) Filter(q *ProgramHistoryQuery) (*ProgramHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProgramHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProgramHistoryWhereInput is returned in case the ProgramHistoryWhereInput is empty.
var ErrEmptyProgramHistoryWhereInput = errors.New("generated: empty predicate ProgramHistoryWhereInput")

// P returns a predicate for filtering programhistories.
// An error is returned if the input is empty or invalid.
func (i *ProgramHistoryWhereInput) P() (predicate.ProgramHistory, error) {
	var predicates []predicate.ProgramHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, programhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProgramHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, programhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProgramHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, programhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, programhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, programhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, programhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, programhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, programhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, programhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, programhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, programhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, programhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, programhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, programhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, programhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, programhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, programhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, programhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, programhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, programhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, programhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, programhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, programhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, programhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, programhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, programhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, programhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, programhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, programhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, programhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, programhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, programhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, programhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, programhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, programhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, programhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, programhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, programhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, programhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, programhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, programhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, programhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, programhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, programhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, programhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, programhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, programhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, programhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, programhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, programhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, programhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, programhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, programhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, programhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, programhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, programhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, programhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, programhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, programhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, programhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, programhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, programhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, programhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, programhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, programhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, programhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, programhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, programhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, programhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, programhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, programhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, programhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, programhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, programhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, programhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, programhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, programhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, programhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, programhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, programhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, programhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, programhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, programhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, programhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, programhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, programhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, programhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, programhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, programhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, programhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, programhistory.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, programhistory.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, programhistory.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, programhistory.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, programhistory.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, programhistory.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, programhistory.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, programhistory.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, programhistory.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, programhistory.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, programhistory.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, programhistory.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, programhistory.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, programhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, programhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, programhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, programhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, programhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, programhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, programhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, programhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, programhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, programhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, programhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, programhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, programhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, programhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, programhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, programhistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, programhistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, programhistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, programhistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, programhistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, programhistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, programhistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, programhistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, programhistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, programhistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, programhistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, programhistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, programhistory.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, programhistory.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, programhistory.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, programhistory.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, programhistory.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, programhistory.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, programhistory.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, programhistory.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, programhistory.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, programhistory.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, programhistory.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, programhistory.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, programhistory.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, programhistory.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, programhistory.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, programhistory.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, programhistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, programhistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, programhistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, programhistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.ProgramType != nil {
		predicates = append(predicates, programhistory.ProgramTypeEQ(*i.ProgramType))
	}
	if i.ProgramTypeNEQ != nil {
		predicates = append(predicates, programhistory.ProgramTypeNEQ(*i.ProgramTypeNEQ))
	}
	if len(i.ProgramTypeIn) > 0 {
		predicates = append(predicates, programhistory.ProgramTypeIn(i.ProgramTypeIn...))
	}
	if len(i.ProgramTypeNotIn) > 0 {
		predicates = append(predicates, programhistory.ProgramTypeNotIn(i.ProgramTypeNotIn...))
	}
	if i.FrameworkName != nil {
		predicates = append(predicates, programhistory.FrameworkNameEQ(*i.FrameworkName))
	}
	if i.FrameworkNameNEQ != nil {
		predicates = append(predicates, programhistory.FrameworkNameNEQ(*i.FrameworkNameNEQ))
	}
	if len(i.FrameworkNameIn) > 0 {
		predicates = append(predicates, programhistory.FrameworkNameIn(i.FrameworkNameIn...))
	}
	if len(i.FrameworkNameNotIn) > 0 {
		predicates = append(predicates, programhistory.FrameworkNameNotIn(i.FrameworkNameNotIn...))
	}
	if i.FrameworkNameGT != nil {
		predicates = append(predicates, programhistory.FrameworkNameGT(*i.FrameworkNameGT))
	}
	if i.FrameworkNameGTE != nil {
		predicates = append(predicates, programhistory.FrameworkNameGTE(*i.FrameworkNameGTE))
	}
	if i.FrameworkNameLT != nil {
		predicates = append(predicates, programhistory.FrameworkNameLT(*i.FrameworkNameLT))
	}
	if i.FrameworkNameLTE != nil {
		predicates = append(predicates, programhistory.FrameworkNameLTE(*i.FrameworkNameLTE))
	}
	if i.FrameworkNameContains != nil {
		predicates = append(predicates, programhistory.FrameworkNameContains(*i.FrameworkNameContains))
	}
	if i.FrameworkNameHasPrefix != nil {
		predicates = append(predicates, programhistory.FrameworkNameHasPrefix(*i.FrameworkNameHasPrefix))
	}
	if i.FrameworkNameHasSuffix != nil {
		predicates = append(predicates, programhistory.FrameworkNameHasSuffix(*i.FrameworkNameHasSuffix))
	}
	if i.FrameworkNameIsNil {
		predicates = append(predicates, programhistory.FrameworkNameIsNil())
	}
	if i.FrameworkNameNotNil {
		predicates = append(predicates, programhistory.FrameworkNameNotNil())
	}
	if i.FrameworkNameEqualFold != nil {
		predicates = append(predicates, programhistory.FrameworkNameEqualFold(*i.FrameworkNameEqualFold))
	}
	if i.FrameworkNameContainsFold != nil {
		predicates = append(predicates, programhistory.FrameworkNameContainsFold(*i.FrameworkNameContainsFold))
	}
	if i.StartDate != nil {
		predicates = append(predicates, programhistory.StartDateEQ(*i.StartDate))
	}
	if i.StartDateNEQ != nil {
		predicates = append(predicates, programhistory.StartDateNEQ(*i.StartDateNEQ))
	}
	if len(i.StartDateIn) > 0 {
		predicates = append(predicates, programhistory.StartDateIn(i.StartDateIn...))
	}
	if len(i.StartDateNotIn) > 0 {
		predicates = append(predicates, programhistory.StartDateNotIn(i.StartDateNotIn...))
	}
	if i.StartDateGT != nil {
		predicates = append(predicates, programhistory.StartDateGT(*i.StartDateGT))
	}
	if i.StartDateGTE != nil {
		predicates = append(predicates, programhistory.StartDateGTE(*i.StartDateGTE))
	}
	if i.StartDateLT != nil {
		predicates = append(predicates, programhistory.StartDateLT(*i.StartDateLT))
	}
	if i.StartDateLTE != nil {
		predicates = append(predicates, programhistory.StartDateLTE(*i.StartDateLTE))
	}
	if i.StartDateIsNil {
		predicates = append(predicates, programhistory.StartDateIsNil())
	}
	if i.StartDateNotNil {
		predicates = append(predicates, programhistory.StartDateNotNil())
	}
	if i.EndDate != nil {
		predicates = append(predicates, programhistory.EndDateEQ(*i.EndDate))
	}
	if i.EndDateNEQ != nil {
		predicates = append(predicates, programhistory.EndDateNEQ(*i.EndDateNEQ))
	}
	if len(i.EndDateIn) > 0 {
		predicates = append(predicates, programhistory.EndDateIn(i.EndDateIn...))
	}
	if len(i.EndDateNotIn) > 0 {
		predicates = append(predicates, programhistory.EndDateNotIn(i.EndDateNotIn...))
	}
	if i.EndDateGT != nil {
		predicates = append(predicates, programhistory.EndDateGT(*i.EndDateGT))
	}
	if i.EndDateGTE != nil {
		predicates = append(predicates, programhistory.EndDateGTE(*i.EndDateGTE))
	}
	if i.EndDateLT != nil {
		predicates = append(predicates, programhistory.EndDateLT(*i.EndDateLT))
	}
	if i.EndDateLTE != nil {
		predicates = append(predicates, programhistory.EndDateLTE(*i.EndDateLTE))
	}
	if i.EndDateIsNil {
		predicates = append(predicates, programhistory.EndDateIsNil())
	}
	if i.EndDateNotNil {
		predicates = append(predicates, programhistory.EndDateNotNil())
	}
	if i.AuditorReady != nil {
		predicates = append(predicates, programhistory.AuditorReadyEQ(*i.AuditorReady))
	}
	if i.AuditorReadyNEQ != nil {
		predicates = append(predicates, programhistory.AuditorReadyNEQ(*i.AuditorReadyNEQ))
	}
	if i.AuditorWriteComments != nil {
		predicates = append(predicates, programhistory.AuditorWriteCommentsEQ(*i.AuditorWriteComments))
	}
	if i.AuditorWriteCommentsNEQ != nil {
		predicates = append(predicates, programhistory.AuditorWriteCommentsNEQ(*i.AuditorWriteCommentsNEQ))
	}
	if i.AuditorReadComments != nil {
		predicates = append(predicates, programhistory.AuditorReadCommentsEQ(*i.AuditorReadComments))
	}
	if i.AuditorReadCommentsNEQ != nil {
		predicates = append(predicates, programhistory.AuditorReadCommentsNEQ(*i.AuditorReadCommentsNEQ))
	}
	if i.AuditFirm != nil {
		predicates = append(predicates, programhistory.AuditFirmEQ(*i.AuditFirm))
	}
	if i.AuditFirmNEQ != nil {
		predicates = append(predicates, programhistory.AuditFirmNEQ(*i.AuditFirmNEQ))
	}
	if len(i.AuditFirmIn) > 0 {
		predicates = append(predicates, programhistory.AuditFirmIn(i.AuditFirmIn...))
	}
	if len(i.AuditFirmNotIn) > 0 {
		predicates = append(predicates, programhistory.AuditFirmNotIn(i.AuditFirmNotIn...))
	}
	if i.AuditFirmGT != nil {
		predicates = append(predicates, programhistory.AuditFirmGT(*i.AuditFirmGT))
	}
	if i.AuditFirmGTE != nil {
		predicates = append(predicates, programhistory.AuditFirmGTE(*i.AuditFirmGTE))
	}
	if i.AuditFirmLT != nil {
		predicates = append(predicates, programhistory.AuditFirmLT(*i.AuditFirmLT))
	}
	if i.AuditFirmLTE != nil {
		predicates = append(predicates, programhistory.AuditFirmLTE(*i.AuditFirmLTE))
	}
	if i.AuditFirmContains != nil {
		predicates = append(predicates, programhistory.AuditFirmContains(*i.AuditFirmContains))
	}
	if i.AuditFirmHasPrefix != nil {
		predicates = append(predicates, programhistory.AuditFirmHasPrefix(*i.AuditFirmHasPrefix))
	}
	if i.AuditFirmHasSuffix != nil {
		predicates = append(predicates, programhistory.AuditFirmHasSuffix(*i.AuditFirmHasSuffix))
	}
	if i.AuditFirmIsNil {
		predicates = append(predicates, programhistory.AuditFirmIsNil())
	}
	if i.AuditFirmNotNil {
		predicates = append(predicates, programhistory.AuditFirmNotNil())
	}
	if i.AuditFirmEqualFold != nil {
		predicates = append(predicates, programhistory.AuditFirmEqualFold(*i.AuditFirmEqualFold))
	}
	if i.AuditFirmContainsFold != nil {
		predicates = append(predicates, programhistory.AuditFirmContainsFold(*i.AuditFirmContainsFold))
	}
	if i.Auditor != nil {
		predicates = append(predicates, programhistory.AuditorEQ(*i.Auditor))
	}
	if i.AuditorNEQ != nil {
		predicates = append(predicates, programhistory.AuditorNEQ(*i.AuditorNEQ))
	}
	if len(i.AuditorIn) > 0 {
		predicates = append(predicates, programhistory.AuditorIn(i.AuditorIn...))
	}
	if len(i.AuditorNotIn) > 0 {
		predicates = append(predicates, programhistory.AuditorNotIn(i.AuditorNotIn...))
	}
	if i.AuditorGT != nil {
		predicates = append(predicates, programhistory.AuditorGT(*i.AuditorGT))
	}
	if i.AuditorGTE != nil {
		predicates = append(predicates, programhistory.AuditorGTE(*i.AuditorGTE))
	}
	if i.AuditorLT != nil {
		predicates = append(predicates, programhistory.AuditorLT(*i.AuditorLT))
	}
	if i.AuditorLTE != nil {
		predicates = append(predicates, programhistory.AuditorLTE(*i.AuditorLTE))
	}
	if i.AuditorContains != nil {
		predicates = append(predicates, programhistory.AuditorContains(*i.AuditorContains))
	}
	if i.AuditorHasPrefix != nil {
		predicates = append(predicates, programhistory.AuditorHasPrefix(*i.AuditorHasPrefix))
	}
	if i.AuditorHasSuffix != nil {
		predicates = append(predicates, programhistory.AuditorHasSuffix(*i.AuditorHasSuffix))
	}
	if i.AuditorIsNil {
		predicates = append(predicates, programhistory.AuditorIsNil())
	}
	if i.AuditorNotNil {
		predicates = append(predicates, programhistory.AuditorNotNil())
	}
	if i.AuditorEqualFold != nil {
		predicates = append(predicates, programhistory.AuditorEqualFold(*i.AuditorEqualFold))
	}
	if i.AuditorContainsFold != nil {
		predicates = append(predicates, programhistory.AuditorContainsFold(*i.AuditorContainsFold))
	}
	if i.AuditorEmail != nil {
		predicates = append(predicates, programhistory.AuditorEmailEQ(*i.AuditorEmail))
	}
	if i.AuditorEmailNEQ != nil {
		predicates = append(predicates, programhistory.AuditorEmailNEQ(*i.AuditorEmailNEQ))
	}
	if len(i.AuditorEmailIn) > 0 {
		predicates = append(predicates, programhistory.AuditorEmailIn(i.AuditorEmailIn...))
	}
	if len(i.AuditorEmailNotIn) > 0 {
		predicates = append(predicates, programhistory.AuditorEmailNotIn(i.AuditorEmailNotIn...))
	}
	if i.AuditorEmailGT != nil {
		predicates = append(predicates, programhistory.AuditorEmailGT(*i.AuditorEmailGT))
	}
	if i.AuditorEmailGTE != nil {
		predicates = append(predicates, programhistory.AuditorEmailGTE(*i.AuditorEmailGTE))
	}
	if i.AuditorEmailLT != nil {
		predicates = append(predicates, programhistory.AuditorEmailLT(*i.AuditorEmailLT))
	}
	if i.AuditorEmailLTE != nil {
		predicates = append(predicates, programhistory.AuditorEmailLTE(*i.AuditorEmailLTE))
	}
	if i.AuditorEmailContains != nil {
		predicates = append(predicates, programhistory.AuditorEmailContains(*i.AuditorEmailContains))
	}
	if i.AuditorEmailHasPrefix != nil {
		predicates = append(predicates, programhistory.AuditorEmailHasPrefix(*i.AuditorEmailHasPrefix))
	}
	if i.AuditorEmailHasSuffix != nil {
		predicates = append(predicates, programhistory.AuditorEmailHasSuffix(*i.AuditorEmailHasSuffix))
	}
	if i.AuditorEmailIsNil {
		predicates = append(predicates, programhistory.AuditorEmailIsNil())
	}
	if i.AuditorEmailNotNil {
		predicates = append(predicates, programhistory.AuditorEmailNotNil())
	}
	if i.AuditorEmailEqualFold != nil {
		predicates = append(predicates, programhistory.AuditorEmailEqualFold(*i.AuditorEmailEqualFold))
	}
	if i.AuditorEmailContainsFold != nil {
		predicates = append(predicates, programhistory.AuditorEmailContainsFold(*i.AuditorEmailContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProgramHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return programhistory.And(predicates...), nil
	}
}

// ProgramMembershipWhereInput represents a where input for filtering ProgramMembership queries.
type ProgramMembershipWhereInput struct {
	Predicates []predicate.ProgramMembership  `json:"-"`
	Not        *ProgramMembershipWhereInput   `json:"not,omitempty"`
	Or         []*ProgramMembershipWhereInput `json:"or,omitempty"`
	And        []*ProgramMembershipWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "role" field predicates.
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNEQ   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`

	// "program_id" field predicates.
	ProgramID             *string  `json:"programID,omitempty"`
	ProgramIDNEQ          *string  `json:"programIDNEQ,omitempty"`
	ProgramIDIn           []string `json:"programIDIn,omitempty"`
	ProgramIDNotIn        []string `json:"programIDNotIn,omitempty"`
	ProgramIDGT           *string  `json:"programIDGT,omitempty"`
	ProgramIDGTE          *string  `json:"programIDGTE,omitempty"`
	ProgramIDLT           *string  `json:"programIDLT,omitempty"`
	ProgramIDLTE          *string  `json:"programIDLTE,omitempty"`
	ProgramIDContains     *string  `json:"programIDContains,omitempty"`
	ProgramIDHasPrefix    *string  `json:"programIDHasPrefix,omitempty"`
	ProgramIDHasSuffix    *string  `json:"programIDHasSuffix,omitempty"`
	ProgramIDEqualFold    *string  `json:"programIDEqualFold,omitempty"`
	ProgramIDContainsFold *string  `json:"programIDContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "program" edge predicates.
	HasProgram     *bool                `json:"hasProgram,omitempty"`
	HasProgramWith []*ProgramWhereInput `json:"hasProgramWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProgramMembershipWhereInput) AddPredicates(predicates ...predicate.ProgramMembership) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProgramMembershipWhereInput filter on the ProgramMembershipQuery builder.
func (i *ProgramMembershipWhereInput) Filter(q *ProgramMembershipQuery) (*ProgramMembershipQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProgramMembershipWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProgramMembershipWhereInput is returned in case the ProgramMembershipWhereInput is empty.
var ErrEmptyProgramMembershipWhereInput = errors.New("generated: empty predicate ProgramMembershipWhereInput")

// P returns a predicate for filtering programmemberships.
// An error is returned if the input is empty or invalid.
func (i *ProgramMembershipWhereInput) P() (predicate.ProgramMembership, error) {
	var predicates []predicate.ProgramMembership
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, programmembership.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProgramMembership, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, programmembership.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProgramMembership, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, programmembership.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, programmembership.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, programmembership.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, programmembership.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, programmembership.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, programmembership.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, programmembership.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, programmembership.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, programmembership.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, programmembership.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, programmembership.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, programmembership.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, programmembership.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, programmembership.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, programmembership.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, programmembership.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, programmembership.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, programmembership.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, programmembership.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, programmembership.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, programmembership.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, programmembership.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, programmembership.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, programmembership.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, programmembership.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, programmembership.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, programmembership.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, programmembership.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, programmembership.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, programmembership.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, programmembership.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, programmembership.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, programmembership.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, programmembership.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, programmembership.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, programmembership.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, programmembership.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, programmembership.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, programmembership.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, programmembership.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, programmembership.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, programmembership.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, programmembership.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, programmembership.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, programmembership.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, programmembership.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, programmembership.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, programmembership.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, programmembership.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, programmembership.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, programmembership.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, programmembership.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, programmembership.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, programmembership.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, programmembership.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, programmembership.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, programmembership.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, programmembership.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, programmembership.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, programmembership.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, programmembership.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Role != nil {
		predicates = append(predicates, programmembership.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, programmembership.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, programmembership.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, programmembership.RoleNotIn(i.RoleNotIn...))
	}
	if i.ProgramID != nil {
		predicates = append(predicates, programmembership.ProgramIDEQ(*i.ProgramID))
	}
	if i.ProgramIDNEQ != nil {
		predicates = append(predicates, programmembership.ProgramIDNEQ(*i.ProgramIDNEQ))
	}
	if len(i.ProgramIDIn) > 0 {
		predicates = append(predicates, programmembership.ProgramIDIn(i.ProgramIDIn...))
	}
	if len(i.ProgramIDNotIn) > 0 {
		predicates = append(predicates, programmembership.ProgramIDNotIn(i.ProgramIDNotIn...))
	}
	if i.ProgramIDGT != nil {
		predicates = append(predicates, programmembership.ProgramIDGT(*i.ProgramIDGT))
	}
	if i.ProgramIDGTE != nil {
		predicates = append(predicates, programmembership.ProgramIDGTE(*i.ProgramIDGTE))
	}
	if i.ProgramIDLT != nil {
		predicates = append(predicates, programmembership.ProgramIDLT(*i.ProgramIDLT))
	}
	if i.ProgramIDLTE != nil {
		predicates = append(predicates, programmembership.ProgramIDLTE(*i.ProgramIDLTE))
	}
	if i.ProgramIDContains != nil {
		predicates = append(predicates, programmembership.ProgramIDContains(*i.ProgramIDContains))
	}
	if i.ProgramIDHasPrefix != nil {
		predicates = append(predicates, programmembership.ProgramIDHasPrefix(*i.ProgramIDHasPrefix))
	}
	if i.ProgramIDHasSuffix != nil {
		predicates = append(predicates, programmembership.ProgramIDHasSuffix(*i.ProgramIDHasSuffix))
	}
	if i.ProgramIDEqualFold != nil {
		predicates = append(predicates, programmembership.ProgramIDEqualFold(*i.ProgramIDEqualFold))
	}
	if i.ProgramIDContainsFold != nil {
		predicates = append(predicates, programmembership.ProgramIDContainsFold(*i.ProgramIDContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, programmembership.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, programmembership.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, programmembership.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, programmembership.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, programmembership.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, programmembership.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, programmembership.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, programmembership.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, programmembership.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, programmembership.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, programmembership.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, programmembership.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, programmembership.UserIDContainsFold(*i.UserIDContainsFold))
	}

	if i.HasProgram != nil {
		p := programmembership.HasProgram()
		if !*i.HasProgram {
			p = programmembership.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramWith))
		for _, w := range i.HasProgramWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, programmembership.HasProgramWith(with...))
	}
	if i.HasUser != nil {
		p := programmembership.HasUser()
		if !*i.HasUser {
			p = programmembership.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, programmembership.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProgramMembershipWhereInput
	case 1:
		return predicates[0], nil
	default:
		return programmembership.And(predicates...), nil
	}
}

// ProgramMembershipHistoryWhereInput represents a where input for filtering ProgramMembershipHistory queries.
type ProgramMembershipHistoryWhereInput struct {
	Predicates []predicate.ProgramMembershipHistory  `json:"-"`
	Not        *ProgramMembershipHistoryWhereInput   `json:"not,omitempty"`
	Or         []*ProgramMembershipHistoryWhereInput `json:"or,omitempty"`
	And        []*ProgramMembershipHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "role" field predicates.
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNEQ   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`

	// "program_id" field predicates.
	ProgramID             *string  `json:"programID,omitempty"`
	ProgramIDNEQ          *string  `json:"programIDNEQ,omitempty"`
	ProgramIDIn           []string `json:"programIDIn,omitempty"`
	ProgramIDNotIn        []string `json:"programIDNotIn,omitempty"`
	ProgramIDGT           *string  `json:"programIDGT,omitempty"`
	ProgramIDGTE          *string  `json:"programIDGTE,omitempty"`
	ProgramIDLT           *string  `json:"programIDLT,omitempty"`
	ProgramIDLTE          *string  `json:"programIDLTE,omitempty"`
	ProgramIDContains     *string  `json:"programIDContains,omitempty"`
	ProgramIDHasPrefix    *string  `json:"programIDHasPrefix,omitempty"`
	ProgramIDHasSuffix    *string  `json:"programIDHasSuffix,omitempty"`
	ProgramIDEqualFold    *string  `json:"programIDEqualFold,omitempty"`
	ProgramIDContainsFold *string  `json:"programIDContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProgramMembershipHistoryWhereInput) AddPredicates(predicates ...predicate.ProgramMembershipHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProgramMembershipHistoryWhereInput filter on the ProgramMembershipHistoryQuery builder.
func (i *ProgramMembershipHistoryWhereInput) Filter(q *ProgramMembershipHistoryQuery) (*ProgramMembershipHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProgramMembershipHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProgramMembershipHistoryWhereInput is returned in case the ProgramMembershipHistoryWhereInput is empty.
var ErrEmptyProgramMembershipHistoryWhereInput = errors.New("generated: empty predicate ProgramMembershipHistoryWhereInput")

// P returns a predicate for filtering programmembershiphistories.
// An error is returned if the input is empty or invalid.
func (i *ProgramMembershipHistoryWhereInput) P() (predicate.ProgramMembershipHistory, error) {
	var predicates []predicate.ProgramMembershipHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, programmembershiphistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProgramMembershipHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, programmembershiphistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProgramMembershipHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, programmembershiphistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, programmembershiphistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, programmembershiphistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, programmembershiphistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, programmembershiphistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, programmembershiphistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, programmembershiphistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, programmembershiphistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, programmembershiphistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, programmembershiphistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, programmembershiphistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, programmembershiphistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, programmembershiphistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, programmembershiphistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, programmembershiphistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, programmembershiphistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, programmembershiphistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, programmembershiphistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, programmembershiphistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, programmembershiphistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, programmembershiphistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, programmembershiphistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, programmembershiphistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, programmembershiphistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, programmembershiphistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, programmembershiphistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, programmembershiphistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, programmembershiphistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, programmembershiphistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, programmembershiphistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, programmembershiphistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, programmembershiphistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, programmembershiphistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, programmembershiphistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, programmembershiphistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, programmembershiphistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, programmembershiphistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, programmembershiphistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, programmembershiphistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, programmembershiphistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, programmembershiphistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, programmembershiphistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, programmembershiphistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, programmembershiphistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, programmembershiphistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, programmembershiphistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, programmembershiphistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, programmembershiphistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, programmembershiphistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, programmembershiphistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, programmembershiphistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, programmembershiphistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, programmembershiphistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, programmembershiphistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, programmembershiphistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, programmembershiphistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, programmembershiphistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, programmembershiphistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, programmembershiphistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, programmembershiphistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, programmembershiphistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, programmembershiphistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, programmembershiphistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, programmembershiphistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, programmembershiphistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, programmembershiphistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, programmembershiphistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, programmembershiphistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, programmembershiphistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, programmembershiphistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, programmembershiphistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, programmembershiphistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Role != nil {
		predicates = append(predicates, programmembershiphistory.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, programmembershiphistory.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, programmembershiphistory.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, programmembershiphistory.RoleNotIn(i.RoleNotIn...))
	}
	if i.ProgramID != nil {
		predicates = append(predicates, programmembershiphistory.ProgramIDEQ(*i.ProgramID))
	}
	if i.ProgramIDNEQ != nil {
		predicates = append(predicates, programmembershiphistory.ProgramIDNEQ(*i.ProgramIDNEQ))
	}
	if len(i.ProgramIDIn) > 0 {
		predicates = append(predicates, programmembershiphistory.ProgramIDIn(i.ProgramIDIn...))
	}
	if len(i.ProgramIDNotIn) > 0 {
		predicates = append(predicates, programmembershiphistory.ProgramIDNotIn(i.ProgramIDNotIn...))
	}
	if i.ProgramIDGT != nil {
		predicates = append(predicates, programmembershiphistory.ProgramIDGT(*i.ProgramIDGT))
	}
	if i.ProgramIDGTE != nil {
		predicates = append(predicates, programmembershiphistory.ProgramIDGTE(*i.ProgramIDGTE))
	}
	if i.ProgramIDLT != nil {
		predicates = append(predicates, programmembershiphistory.ProgramIDLT(*i.ProgramIDLT))
	}
	if i.ProgramIDLTE != nil {
		predicates = append(predicates, programmembershiphistory.ProgramIDLTE(*i.ProgramIDLTE))
	}
	if i.ProgramIDContains != nil {
		predicates = append(predicates, programmembershiphistory.ProgramIDContains(*i.ProgramIDContains))
	}
	if i.ProgramIDHasPrefix != nil {
		predicates = append(predicates, programmembershiphistory.ProgramIDHasPrefix(*i.ProgramIDHasPrefix))
	}
	if i.ProgramIDHasSuffix != nil {
		predicates = append(predicates, programmembershiphistory.ProgramIDHasSuffix(*i.ProgramIDHasSuffix))
	}
	if i.ProgramIDEqualFold != nil {
		predicates = append(predicates, programmembershiphistory.ProgramIDEqualFold(*i.ProgramIDEqualFold))
	}
	if i.ProgramIDContainsFold != nil {
		predicates = append(predicates, programmembershiphistory.ProgramIDContainsFold(*i.ProgramIDContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, programmembershiphistory.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, programmembershiphistory.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, programmembershiphistory.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, programmembershiphistory.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, programmembershiphistory.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, programmembershiphistory.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, programmembershiphistory.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, programmembershiphistory.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, programmembershiphistory.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, programmembershiphistory.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, programmembershiphistory.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, programmembershiphistory.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, programmembershiphistory.UserIDContainsFold(*i.UserIDContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProgramMembershipHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return programmembershiphistory.And(predicates...), nil
	}
}

// RiskWhereInput represents a where input for filtering Risk queries.
type RiskWhereInput struct {
	Predicates []predicate.Risk  `json:"-"`
	Not        *RiskWhereInput   `json:"not,omitempty"`
	Or         []*RiskWhereInput `json:"or,omitempty"`
	And        []*RiskWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.RiskStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.RiskStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.RiskStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.RiskStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool               `json:"statusIsNil,omitempty"`
	StatusNotNil bool               `json:"statusNotNil,omitempty"`

	// "risk_type" field predicates.
	RiskType             *string  `json:"riskType,omitempty"`
	RiskTypeNEQ          *string  `json:"riskTypeNEQ,omitempty"`
	RiskTypeIn           []string `json:"riskTypeIn,omitempty"`
	RiskTypeNotIn        []string `json:"riskTypeNotIn,omitempty"`
	RiskTypeGT           *string  `json:"riskTypeGT,omitempty"`
	RiskTypeGTE          *string  `json:"riskTypeGTE,omitempty"`
	RiskTypeLT           *string  `json:"riskTypeLT,omitempty"`
	RiskTypeLTE          *string  `json:"riskTypeLTE,omitempty"`
	RiskTypeContains     *string  `json:"riskTypeContains,omitempty"`
	RiskTypeHasPrefix    *string  `json:"riskTypeHasPrefix,omitempty"`
	RiskTypeHasSuffix    *string  `json:"riskTypeHasSuffix,omitempty"`
	RiskTypeIsNil        bool     `json:"riskTypeIsNil,omitempty"`
	RiskTypeNotNil       bool     `json:"riskTypeNotNil,omitempty"`
	RiskTypeEqualFold    *string  `json:"riskTypeEqualFold,omitempty"`
	RiskTypeContainsFold *string  `json:"riskTypeContainsFold,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        bool     `json:"categoryIsNil,omitempty"`
	CategoryNotNil       bool     `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "impact" field predicates.
	Impact       *enums.RiskImpact  `json:"impact,omitempty"`
	ImpactNEQ    *enums.RiskImpact  `json:"impactNEQ,omitempty"`
	ImpactIn     []enums.RiskImpact `json:"impactIn,omitempty"`
	ImpactNotIn  []enums.RiskImpact `json:"impactNotIn,omitempty"`
	ImpactIsNil  bool               `json:"impactIsNil,omitempty"`
	ImpactNotNil bool               `json:"impactNotNil,omitempty"`

	// "likelihood" field predicates.
	Likelihood       *enums.RiskLikelihood  `json:"likelihood,omitempty"`
	LikelihoodNEQ    *enums.RiskLikelihood  `json:"likelihoodNEQ,omitempty"`
	LikelihoodIn     []enums.RiskLikelihood `json:"likelihoodIn,omitempty"`
	LikelihoodNotIn  []enums.RiskLikelihood `json:"likelihoodNotIn,omitempty"`
	LikelihoodIsNil  bool                   `json:"likelihoodIsNil,omitempty"`
	LikelihoodNotNil bool                   `json:"likelihoodNotNil,omitempty"`

	// "score" field predicates.
	Score       *int  `json:"score,omitempty"`
	ScoreNEQ    *int  `json:"scoreNEQ,omitempty"`
	ScoreIn     []int `json:"scoreIn,omitempty"`
	ScoreNotIn  []int `json:"scoreNotIn,omitempty"`
	ScoreGT     *int  `json:"scoreGT,omitempty"`
	ScoreGTE    *int  `json:"scoreGTE,omitempty"`
	ScoreLT     *int  `json:"scoreLT,omitempty"`
	ScoreLTE    *int  `json:"scoreLTE,omitempty"`
	ScoreIsNil  bool  `json:"scoreIsNil,omitempty"`
	ScoreNotNil bool  `json:"scoreNotNil,omitempty"`

	// "mitigation" field predicates.
	Mitigation             *string  `json:"mitigation,omitempty"`
	MitigationNEQ          *string  `json:"mitigationNEQ,omitempty"`
	MitigationIn           []string `json:"mitigationIn,omitempty"`
	MitigationNotIn        []string `json:"mitigationNotIn,omitempty"`
	MitigationGT           *string  `json:"mitigationGT,omitempty"`
	MitigationGTE          *string  `json:"mitigationGTE,omitempty"`
	MitigationLT           *string  `json:"mitigationLT,omitempty"`
	MitigationLTE          *string  `json:"mitigationLTE,omitempty"`
	MitigationContains     *string  `json:"mitigationContains,omitempty"`
	MitigationHasPrefix    *string  `json:"mitigationHasPrefix,omitempty"`
	MitigationHasSuffix    *string  `json:"mitigationHasSuffix,omitempty"`
	MitigationIsNil        bool     `json:"mitigationIsNil,omitempty"`
	MitigationNotNil       bool     `json:"mitigationNotNil,omitempty"`
	MitigationEqualFold    *string  `json:"mitigationEqualFold,omitempty"`
	MitigationContainsFold *string  `json:"mitigationContainsFold,omitempty"`

	// "details" field predicates.
	Details             *string  `json:"details,omitempty"`
	DetailsNEQ          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGT           *string  `json:"detailsGT,omitempty"`
	DetailsGTE          *string  `json:"detailsGTE,omitempty"`
	DetailsLT           *string  `json:"detailsLT,omitempty"`
	DetailsLTE          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        bool     `json:"detailsIsNil,omitempty"`
	DetailsNotNil       bool     `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`

	// "business_costs" field predicates.
	BusinessCosts             *string  `json:"businessCosts,omitempty"`
	BusinessCostsNEQ          *string  `json:"businessCostsNEQ,omitempty"`
	BusinessCostsIn           []string `json:"businessCostsIn,omitempty"`
	BusinessCostsNotIn        []string `json:"businessCostsNotIn,omitempty"`
	BusinessCostsGT           *string  `json:"businessCostsGT,omitempty"`
	BusinessCostsGTE          *string  `json:"businessCostsGTE,omitempty"`
	BusinessCostsLT           *string  `json:"businessCostsLT,omitempty"`
	BusinessCostsLTE          *string  `json:"businessCostsLTE,omitempty"`
	BusinessCostsContains     *string  `json:"businessCostsContains,omitempty"`
	BusinessCostsHasPrefix    *string  `json:"businessCostsHasPrefix,omitempty"`
	BusinessCostsHasSuffix    *string  `json:"businessCostsHasSuffix,omitempty"`
	BusinessCostsIsNil        bool     `json:"businessCostsIsNil,omitempty"`
	BusinessCostsNotNil       bool     `json:"businessCostsNotNil,omitempty"`
	BusinessCostsEqualFold    *string  `json:"businessCostsEqualFold,omitempty"`
	BusinessCostsContainsFold *string  `json:"businessCostsContainsFold,omitempty"`

	// "stakeholder_id" field predicates.
	StakeholderID             *string  `json:"stakeholderID,omitempty"`
	StakeholderIDNEQ          *string  `json:"stakeholderIDNEQ,omitempty"`
	StakeholderIDIn           []string `json:"stakeholderIDIn,omitempty"`
	StakeholderIDNotIn        []string `json:"stakeholderIDNotIn,omitempty"`
	StakeholderIDGT           *string  `json:"stakeholderIDGT,omitempty"`
	StakeholderIDGTE          *string  `json:"stakeholderIDGTE,omitempty"`
	StakeholderIDLT           *string  `json:"stakeholderIDLT,omitempty"`
	StakeholderIDLTE          *string  `json:"stakeholderIDLTE,omitempty"`
	StakeholderIDContains     *string  `json:"stakeholderIDContains,omitempty"`
	StakeholderIDHasPrefix    *string  `json:"stakeholderIDHasPrefix,omitempty"`
	StakeholderIDHasSuffix    *string  `json:"stakeholderIDHasSuffix,omitempty"`
	StakeholderIDIsNil        bool     `json:"stakeholderIDIsNil,omitempty"`
	StakeholderIDNotNil       bool     `json:"stakeholderIDNotNil,omitempty"`
	StakeholderIDEqualFold    *string  `json:"stakeholderIDEqualFold,omitempty"`
	StakeholderIDContainsFold *string  `json:"stakeholderIDContainsFold,omitempty"`

	// "delegate_id" field predicates.
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIDNEQ          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIDGT           *string  `json:"delegateIDGT,omitempty"`
	DelegateIDGTE          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIDLT           *string  `json:"delegateIDLT,omitempty"`
	DelegateIDLTE          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        bool     `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       bool     `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "blocked_groups" edge predicates.
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`

	// "editors" edge predicates.
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`

	// "viewers" edge predicates.
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`

	// "controls" edge predicates.
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`

	// "subcontrols" edge predicates.
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`

	// "procedures" edge predicates.
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`

	// "internal_policies" edge predicates.
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`

	// "programs" edge predicates.
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`

	// "action_plans" edge predicates.
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`

	// "stakeholder" edge predicates.
	HasStakeholder     *bool              `json:"hasStakeholder,omitempty"`
	HasStakeholderWith []*GroupWhereInput `json:"hasStakeholderWith,omitempty"`

	// "delegate" edge predicates.
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RiskWhereInput) AddPredicates(predicates ...predicate.Risk) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RiskWhereInput filter on the RiskQuery builder.
func (i *RiskWhereInput) Filter(q *RiskQuery) (*RiskQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRiskWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRiskWhereInput is returned in case the RiskWhereInput is empty.
var ErrEmptyRiskWhereInput = errors.New("generated: empty predicate RiskWhereInput")

// P returns a predicate for filtering risks.
// An error is returned if the input is empty or invalid.
func (i *RiskWhereInput) P() (predicate.Risk, error) {
	var predicates []predicate.Risk
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, risk.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Risk, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, risk.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Risk, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, risk.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, risk.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, risk.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, risk.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, risk.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, risk.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, risk.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, risk.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, risk.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, risk.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, risk.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, risk.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, risk.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, risk.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, risk.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, risk.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, risk.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, risk.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, risk.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, risk.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, risk.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, risk.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, risk.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, risk.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, risk.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, risk.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, risk.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, risk.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, risk.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, risk.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, risk.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, risk.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, risk.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, risk.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, risk.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, risk.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, risk.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, risk.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, risk.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, risk.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, risk.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, risk.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, risk.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, risk.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, risk.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, risk.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, risk.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, risk.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, risk.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, risk.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, risk.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, risk.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, risk.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, risk.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, risk.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, risk.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, risk.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, risk.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, risk.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, risk.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, risk.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, risk.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, risk.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, risk.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, risk.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, risk.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, risk.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, risk.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, risk.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, risk.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, risk.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, risk.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, risk.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, risk.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, risk.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, risk.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, risk.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, risk.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, risk.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, risk.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, risk.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, risk.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, risk.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, risk.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, risk.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, risk.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, risk.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, risk.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, risk.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, risk.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, risk.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, risk.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, risk.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, risk.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, risk.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, risk.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, risk.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, risk.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, risk.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, risk.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, risk.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, risk.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, risk.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, risk.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, risk.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, risk.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, risk.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, risk.StatusNotNil())
	}
	if i.RiskType != nil {
		predicates = append(predicates, risk.RiskTypeEQ(*i.RiskType))
	}
	if i.RiskTypeNEQ != nil {
		predicates = append(predicates, risk.RiskTypeNEQ(*i.RiskTypeNEQ))
	}
	if len(i.RiskTypeIn) > 0 {
		predicates = append(predicates, risk.RiskTypeIn(i.RiskTypeIn...))
	}
	if len(i.RiskTypeNotIn) > 0 {
		predicates = append(predicates, risk.RiskTypeNotIn(i.RiskTypeNotIn...))
	}
	if i.RiskTypeGT != nil {
		predicates = append(predicates, risk.RiskTypeGT(*i.RiskTypeGT))
	}
	if i.RiskTypeGTE != nil {
		predicates = append(predicates, risk.RiskTypeGTE(*i.RiskTypeGTE))
	}
	if i.RiskTypeLT != nil {
		predicates = append(predicates, risk.RiskTypeLT(*i.RiskTypeLT))
	}
	if i.RiskTypeLTE != nil {
		predicates = append(predicates, risk.RiskTypeLTE(*i.RiskTypeLTE))
	}
	if i.RiskTypeContains != nil {
		predicates = append(predicates, risk.RiskTypeContains(*i.RiskTypeContains))
	}
	if i.RiskTypeHasPrefix != nil {
		predicates = append(predicates, risk.RiskTypeHasPrefix(*i.RiskTypeHasPrefix))
	}
	if i.RiskTypeHasSuffix != nil {
		predicates = append(predicates, risk.RiskTypeHasSuffix(*i.RiskTypeHasSuffix))
	}
	if i.RiskTypeIsNil {
		predicates = append(predicates, risk.RiskTypeIsNil())
	}
	if i.RiskTypeNotNil {
		predicates = append(predicates, risk.RiskTypeNotNil())
	}
	if i.RiskTypeEqualFold != nil {
		predicates = append(predicates, risk.RiskTypeEqualFold(*i.RiskTypeEqualFold))
	}
	if i.RiskTypeContainsFold != nil {
		predicates = append(predicates, risk.RiskTypeContainsFold(*i.RiskTypeContainsFold))
	}
	if i.Category != nil {
		predicates = append(predicates, risk.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, risk.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, risk.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, risk.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, risk.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, risk.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, risk.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, risk.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, risk.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, risk.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, risk.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryIsNil {
		predicates = append(predicates, risk.CategoryIsNil())
	}
	if i.CategoryNotNil {
		predicates = append(predicates, risk.CategoryNotNil())
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, risk.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, risk.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.Impact != nil {
		predicates = append(predicates, risk.ImpactEQ(*i.Impact))
	}
	if i.ImpactNEQ != nil {
		predicates = append(predicates, risk.ImpactNEQ(*i.ImpactNEQ))
	}
	if len(i.ImpactIn) > 0 {
		predicates = append(predicates, risk.ImpactIn(i.ImpactIn...))
	}
	if len(i.ImpactNotIn) > 0 {
		predicates = append(predicates, risk.ImpactNotIn(i.ImpactNotIn...))
	}
	if i.ImpactIsNil {
		predicates = append(predicates, risk.ImpactIsNil())
	}
	if i.ImpactNotNil {
		predicates = append(predicates, risk.ImpactNotNil())
	}
	if i.Likelihood != nil {
		predicates = append(predicates, risk.LikelihoodEQ(*i.Likelihood))
	}
	if i.LikelihoodNEQ != nil {
		predicates = append(predicates, risk.LikelihoodNEQ(*i.LikelihoodNEQ))
	}
	if len(i.LikelihoodIn) > 0 {
		predicates = append(predicates, risk.LikelihoodIn(i.LikelihoodIn...))
	}
	if len(i.LikelihoodNotIn) > 0 {
		predicates = append(predicates, risk.LikelihoodNotIn(i.LikelihoodNotIn...))
	}
	if i.LikelihoodIsNil {
		predicates = append(predicates, risk.LikelihoodIsNil())
	}
	if i.LikelihoodNotNil {
		predicates = append(predicates, risk.LikelihoodNotNil())
	}
	if i.Score != nil {
		predicates = append(predicates, risk.ScoreEQ(*i.Score))
	}
	if i.ScoreNEQ != nil {
		predicates = append(predicates, risk.ScoreNEQ(*i.ScoreNEQ))
	}
	if len(i.ScoreIn) > 0 {
		predicates = append(predicates, risk.ScoreIn(i.ScoreIn...))
	}
	if len(i.ScoreNotIn) > 0 {
		predicates = append(predicates, risk.ScoreNotIn(i.ScoreNotIn...))
	}
	if i.ScoreGT != nil {
		predicates = append(predicates, risk.ScoreGT(*i.ScoreGT))
	}
	if i.ScoreGTE != nil {
		predicates = append(predicates, risk.ScoreGTE(*i.ScoreGTE))
	}
	if i.ScoreLT != nil {
		predicates = append(predicates, risk.ScoreLT(*i.ScoreLT))
	}
	if i.ScoreLTE != nil {
		predicates = append(predicates, risk.ScoreLTE(*i.ScoreLTE))
	}
	if i.ScoreIsNil {
		predicates = append(predicates, risk.ScoreIsNil())
	}
	if i.ScoreNotNil {
		predicates = append(predicates, risk.ScoreNotNil())
	}
	if i.Mitigation != nil {
		predicates = append(predicates, risk.MitigationEQ(*i.Mitigation))
	}
	if i.MitigationNEQ != nil {
		predicates = append(predicates, risk.MitigationNEQ(*i.MitigationNEQ))
	}
	if len(i.MitigationIn) > 0 {
		predicates = append(predicates, risk.MitigationIn(i.MitigationIn...))
	}
	if len(i.MitigationNotIn) > 0 {
		predicates = append(predicates, risk.MitigationNotIn(i.MitigationNotIn...))
	}
	if i.MitigationGT != nil {
		predicates = append(predicates, risk.MitigationGT(*i.MitigationGT))
	}
	if i.MitigationGTE != nil {
		predicates = append(predicates, risk.MitigationGTE(*i.MitigationGTE))
	}
	if i.MitigationLT != nil {
		predicates = append(predicates, risk.MitigationLT(*i.MitigationLT))
	}
	if i.MitigationLTE != nil {
		predicates = append(predicates, risk.MitigationLTE(*i.MitigationLTE))
	}
	if i.MitigationContains != nil {
		predicates = append(predicates, risk.MitigationContains(*i.MitigationContains))
	}
	if i.MitigationHasPrefix != nil {
		predicates = append(predicates, risk.MitigationHasPrefix(*i.MitigationHasPrefix))
	}
	if i.MitigationHasSuffix != nil {
		predicates = append(predicates, risk.MitigationHasSuffix(*i.MitigationHasSuffix))
	}
	if i.MitigationIsNil {
		predicates = append(predicates, risk.MitigationIsNil())
	}
	if i.MitigationNotNil {
		predicates = append(predicates, risk.MitigationNotNil())
	}
	if i.MitigationEqualFold != nil {
		predicates = append(predicates, risk.MitigationEqualFold(*i.MitigationEqualFold))
	}
	if i.MitigationContainsFold != nil {
		predicates = append(predicates, risk.MitigationContainsFold(*i.MitigationContainsFold))
	}
	if i.Details != nil {
		predicates = append(predicates, risk.DetailsEQ(*i.Details))
	}
	if i.DetailsNEQ != nil {
		predicates = append(predicates, risk.DetailsNEQ(*i.DetailsNEQ))
	}
	if len(i.DetailsIn) > 0 {
		predicates = append(predicates, risk.DetailsIn(i.DetailsIn...))
	}
	if len(i.DetailsNotIn) > 0 {
		predicates = append(predicates, risk.DetailsNotIn(i.DetailsNotIn...))
	}
	if i.DetailsGT != nil {
		predicates = append(predicates, risk.DetailsGT(*i.DetailsGT))
	}
	if i.DetailsGTE != nil {
		predicates = append(predicates, risk.DetailsGTE(*i.DetailsGTE))
	}
	if i.DetailsLT != nil {
		predicates = append(predicates, risk.DetailsLT(*i.DetailsLT))
	}
	if i.DetailsLTE != nil {
		predicates = append(predicates, risk.DetailsLTE(*i.DetailsLTE))
	}
	if i.DetailsContains != nil {
		predicates = append(predicates, risk.DetailsContains(*i.DetailsContains))
	}
	if i.DetailsHasPrefix != nil {
		predicates = append(predicates, risk.DetailsHasPrefix(*i.DetailsHasPrefix))
	}
	if i.DetailsHasSuffix != nil {
		predicates = append(predicates, risk.DetailsHasSuffix(*i.DetailsHasSuffix))
	}
	if i.DetailsIsNil {
		predicates = append(predicates, risk.DetailsIsNil())
	}
	if i.DetailsNotNil {
		predicates = append(predicates, risk.DetailsNotNil())
	}
	if i.DetailsEqualFold != nil {
		predicates = append(predicates, risk.DetailsEqualFold(*i.DetailsEqualFold))
	}
	if i.DetailsContainsFold != nil {
		predicates = append(predicates, risk.DetailsContainsFold(*i.DetailsContainsFold))
	}
	if i.BusinessCosts != nil {
		predicates = append(predicates, risk.BusinessCostsEQ(*i.BusinessCosts))
	}
	if i.BusinessCostsNEQ != nil {
		predicates = append(predicates, risk.BusinessCostsNEQ(*i.BusinessCostsNEQ))
	}
	if len(i.BusinessCostsIn) > 0 {
		predicates = append(predicates, risk.BusinessCostsIn(i.BusinessCostsIn...))
	}
	if len(i.BusinessCostsNotIn) > 0 {
		predicates = append(predicates, risk.BusinessCostsNotIn(i.BusinessCostsNotIn...))
	}
	if i.BusinessCostsGT != nil {
		predicates = append(predicates, risk.BusinessCostsGT(*i.BusinessCostsGT))
	}
	if i.BusinessCostsGTE != nil {
		predicates = append(predicates, risk.BusinessCostsGTE(*i.BusinessCostsGTE))
	}
	if i.BusinessCostsLT != nil {
		predicates = append(predicates, risk.BusinessCostsLT(*i.BusinessCostsLT))
	}
	if i.BusinessCostsLTE != nil {
		predicates = append(predicates, risk.BusinessCostsLTE(*i.BusinessCostsLTE))
	}
	if i.BusinessCostsContains != nil {
		predicates = append(predicates, risk.BusinessCostsContains(*i.BusinessCostsContains))
	}
	if i.BusinessCostsHasPrefix != nil {
		predicates = append(predicates, risk.BusinessCostsHasPrefix(*i.BusinessCostsHasPrefix))
	}
	if i.BusinessCostsHasSuffix != nil {
		predicates = append(predicates, risk.BusinessCostsHasSuffix(*i.BusinessCostsHasSuffix))
	}
	if i.BusinessCostsIsNil {
		predicates = append(predicates, risk.BusinessCostsIsNil())
	}
	if i.BusinessCostsNotNil {
		predicates = append(predicates, risk.BusinessCostsNotNil())
	}
	if i.BusinessCostsEqualFold != nil {
		predicates = append(predicates, risk.BusinessCostsEqualFold(*i.BusinessCostsEqualFold))
	}
	if i.BusinessCostsContainsFold != nil {
		predicates = append(predicates, risk.BusinessCostsContainsFold(*i.BusinessCostsContainsFold))
	}
	if i.StakeholderID != nil {
		predicates = append(predicates, risk.StakeholderIDEQ(*i.StakeholderID))
	}
	if i.StakeholderIDNEQ != nil {
		predicates = append(predicates, risk.StakeholderIDNEQ(*i.StakeholderIDNEQ))
	}
	if len(i.StakeholderIDIn) > 0 {
		predicates = append(predicates, risk.StakeholderIDIn(i.StakeholderIDIn...))
	}
	if len(i.StakeholderIDNotIn) > 0 {
		predicates = append(predicates, risk.StakeholderIDNotIn(i.StakeholderIDNotIn...))
	}
	if i.StakeholderIDGT != nil {
		predicates = append(predicates, risk.StakeholderIDGT(*i.StakeholderIDGT))
	}
	if i.StakeholderIDGTE != nil {
		predicates = append(predicates, risk.StakeholderIDGTE(*i.StakeholderIDGTE))
	}
	if i.StakeholderIDLT != nil {
		predicates = append(predicates, risk.StakeholderIDLT(*i.StakeholderIDLT))
	}
	if i.StakeholderIDLTE != nil {
		predicates = append(predicates, risk.StakeholderIDLTE(*i.StakeholderIDLTE))
	}
	if i.StakeholderIDContains != nil {
		predicates = append(predicates, risk.StakeholderIDContains(*i.StakeholderIDContains))
	}
	if i.StakeholderIDHasPrefix != nil {
		predicates = append(predicates, risk.StakeholderIDHasPrefix(*i.StakeholderIDHasPrefix))
	}
	if i.StakeholderIDHasSuffix != nil {
		predicates = append(predicates, risk.StakeholderIDHasSuffix(*i.StakeholderIDHasSuffix))
	}
	if i.StakeholderIDIsNil {
		predicates = append(predicates, risk.StakeholderIDIsNil())
	}
	if i.StakeholderIDNotNil {
		predicates = append(predicates, risk.StakeholderIDNotNil())
	}
	if i.StakeholderIDEqualFold != nil {
		predicates = append(predicates, risk.StakeholderIDEqualFold(*i.StakeholderIDEqualFold))
	}
	if i.StakeholderIDContainsFold != nil {
		predicates = append(predicates, risk.StakeholderIDContainsFold(*i.StakeholderIDContainsFold))
	}
	if i.DelegateID != nil {
		predicates = append(predicates, risk.DelegateIDEQ(*i.DelegateID))
	}
	if i.DelegateIDNEQ != nil {
		predicates = append(predicates, risk.DelegateIDNEQ(*i.DelegateIDNEQ))
	}
	if len(i.DelegateIDIn) > 0 {
		predicates = append(predicates, risk.DelegateIDIn(i.DelegateIDIn...))
	}
	if len(i.DelegateIDNotIn) > 0 {
		predicates = append(predicates, risk.DelegateIDNotIn(i.DelegateIDNotIn...))
	}
	if i.DelegateIDGT != nil {
		predicates = append(predicates, risk.DelegateIDGT(*i.DelegateIDGT))
	}
	if i.DelegateIDGTE != nil {
		predicates = append(predicates, risk.DelegateIDGTE(*i.DelegateIDGTE))
	}
	if i.DelegateIDLT != nil {
		predicates = append(predicates, risk.DelegateIDLT(*i.DelegateIDLT))
	}
	if i.DelegateIDLTE != nil {
		predicates = append(predicates, risk.DelegateIDLTE(*i.DelegateIDLTE))
	}
	if i.DelegateIDContains != nil {
		predicates = append(predicates, risk.DelegateIDContains(*i.DelegateIDContains))
	}
	if i.DelegateIDHasPrefix != nil {
		predicates = append(predicates, risk.DelegateIDHasPrefix(*i.DelegateIDHasPrefix))
	}
	if i.DelegateIDHasSuffix != nil {
		predicates = append(predicates, risk.DelegateIDHasSuffix(*i.DelegateIDHasSuffix))
	}
	if i.DelegateIDIsNil {
		predicates = append(predicates, risk.DelegateIDIsNil())
	}
	if i.DelegateIDNotNil {
		predicates = append(predicates, risk.DelegateIDNotNil())
	}
	if i.DelegateIDEqualFold != nil {
		predicates = append(predicates, risk.DelegateIDEqualFold(*i.DelegateIDEqualFold))
	}
	if i.DelegateIDContainsFold != nil {
		predicates = append(predicates, risk.DelegateIDContainsFold(*i.DelegateIDContainsFold))
	}

	if i.HasOwner != nil {
		p := risk.HasOwner()
		if !*i.HasOwner {
			p = risk.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, risk.HasOwnerWith(with...))
	}
	if i.HasBlockedGroups != nil {
		p := risk.HasBlockedGroups()
		if !*i.HasBlockedGroups {
			p = risk.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBlockedGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasBlockedGroupsWith))
		for _, w := range i.HasBlockedGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBlockedGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, risk.HasBlockedGroupsWith(with...))
	}
	if i.HasEditors != nil {
		p := risk.HasEditors()
		if !*i.HasEditors {
			p = risk.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEditorsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasEditorsWith))
		for _, w := range i.HasEditorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEditorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, risk.HasEditorsWith(with...))
	}
	if i.HasViewers != nil {
		p := risk.HasViewers()
		if !*i.HasViewers {
			p = risk.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasViewersWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasViewersWith))
		for _, w := range i.HasViewersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasViewersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, risk.HasViewersWith(with...))
	}
	if i.HasControls != nil {
		p := risk.HasControls()
		if !*i.HasControls {
			p = risk.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasControlsWith))
		for _, w := range i.HasControlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, risk.HasControlsWith(with...))
	}
	if i.HasSubcontrols != nil {
		p := risk.HasSubcontrols()
		if !*i.HasSubcontrols {
			p = risk.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubcontrolsWith) > 0 {
		with := make([]predicate.Subcontrol, 0, len(i.HasSubcontrolsWith))
		for _, w := range i.HasSubcontrolsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubcontrolsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, risk.HasSubcontrolsWith(with...))
	}
	if i.HasProcedures != nil {
		p := risk.HasProcedures()
		if !*i.HasProcedures {
			p = risk.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProceduresWith) > 0 {
		with := make([]predicate.Procedure, 0, len(i.HasProceduresWith))
		for _, w := range i.HasProceduresWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProceduresWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, risk.HasProceduresWith(with...))
	}
	if i.HasInternalPolicies != nil {
		p := risk.HasInternalPolicies()
		if !*i.HasInternalPolicies {
			p = risk.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInternalPoliciesWith) > 0 {
		with := make([]predicate.InternalPolicy, 0, len(i.HasInternalPoliciesWith))
		for _, w := range i.HasInternalPoliciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInternalPoliciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, risk.HasInternalPoliciesWith(with...))
	}
	if i.HasPrograms != nil {
		p := risk.HasPrograms()
		if !*i.HasPrograms {
			p = risk.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramsWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramsWith))
		for _, w := range i.HasProgramsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, risk.HasProgramsWith(with...))
	}
	if i.HasActionPlans != nil {
		p := risk.HasActionPlans()
		if !*i.HasActionPlans {
			p = risk.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionPlansWith) > 0 {
		with := make([]predicate.ActionPlan, 0, len(i.HasActionPlansWith))
		for _, w := range i.HasActionPlansWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionPlansWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, risk.HasActionPlansWith(with...))
	}
	if i.HasTasks != nil {
		p := risk.HasTasks()
		if !*i.HasTasks {
			p = risk.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, risk.HasTasksWith(with...))
	}
	if i.HasStakeholder != nil {
		p := risk.HasStakeholder()
		if !*i.HasStakeholder {
			p = risk.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStakeholderWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasStakeholderWith))
		for _, w := range i.HasStakeholderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStakeholderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, risk.HasStakeholderWith(with...))
	}
	if i.HasDelegate != nil {
		p := risk.HasDelegate()
		if !*i.HasDelegate {
			p = risk.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDelegateWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasDelegateWith))
		for _, w := range i.HasDelegateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDelegateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, risk.HasDelegateWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRiskWhereInput
	case 1:
		return predicates[0], nil
	default:
		return risk.And(predicates...), nil
	}
}

// RiskHistoryWhereInput represents a where input for filtering RiskHistory queries.
type RiskHistoryWhereInput struct {
	Predicates []predicate.RiskHistory  `json:"-"`
	Not        *RiskHistoryWhereInput   `json:"not,omitempty"`
	Or         []*RiskHistoryWhereInput `json:"or,omitempty"`
	And        []*RiskHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.RiskStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.RiskStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.RiskStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.RiskStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool               `json:"statusIsNil,omitempty"`
	StatusNotNil bool               `json:"statusNotNil,omitempty"`

	// "risk_type" field predicates.
	RiskType             *string  `json:"riskType,omitempty"`
	RiskTypeNEQ          *string  `json:"riskTypeNEQ,omitempty"`
	RiskTypeIn           []string `json:"riskTypeIn,omitempty"`
	RiskTypeNotIn        []string `json:"riskTypeNotIn,omitempty"`
	RiskTypeGT           *string  `json:"riskTypeGT,omitempty"`
	RiskTypeGTE          *string  `json:"riskTypeGTE,omitempty"`
	RiskTypeLT           *string  `json:"riskTypeLT,omitempty"`
	RiskTypeLTE          *string  `json:"riskTypeLTE,omitempty"`
	RiskTypeContains     *string  `json:"riskTypeContains,omitempty"`
	RiskTypeHasPrefix    *string  `json:"riskTypeHasPrefix,omitempty"`
	RiskTypeHasSuffix    *string  `json:"riskTypeHasSuffix,omitempty"`
	RiskTypeIsNil        bool     `json:"riskTypeIsNil,omitempty"`
	RiskTypeNotNil       bool     `json:"riskTypeNotNil,omitempty"`
	RiskTypeEqualFold    *string  `json:"riskTypeEqualFold,omitempty"`
	RiskTypeContainsFold *string  `json:"riskTypeContainsFold,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        bool     `json:"categoryIsNil,omitempty"`
	CategoryNotNil       bool     `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "impact" field predicates.
	Impact       *enums.RiskImpact  `json:"impact,omitempty"`
	ImpactNEQ    *enums.RiskImpact  `json:"impactNEQ,omitempty"`
	ImpactIn     []enums.RiskImpact `json:"impactIn,omitempty"`
	ImpactNotIn  []enums.RiskImpact `json:"impactNotIn,omitempty"`
	ImpactIsNil  bool               `json:"impactIsNil,omitempty"`
	ImpactNotNil bool               `json:"impactNotNil,omitempty"`

	// "likelihood" field predicates.
	Likelihood       *enums.RiskLikelihood  `json:"likelihood,omitempty"`
	LikelihoodNEQ    *enums.RiskLikelihood  `json:"likelihoodNEQ,omitempty"`
	LikelihoodIn     []enums.RiskLikelihood `json:"likelihoodIn,omitempty"`
	LikelihoodNotIn  []enums.RiskLikelihood `json:"likelihoodNotIn,omitempty"`
	LikelihoodIsNil  bool                   `json:"likelihoodIsNil,omitempty"`
	LikelihoodNotNil bool                   `json:"likelihoodNotNil,omitempty"`

	// "score" field predicates.
	Score       *int  `json:"score,omitempty"`
	ScoreNEQ    *int  `json:"scoreNEQ,omitempty"`
	ScoreIn     []int `json:"scoreIn,omitempty"`
	ScoreNotIn  []int `json:"scoreNotIn,omitempty"`
	ScoreGT     *int  `json:"scoreGT,omitempty"`
	ScoreGTE    *int  `json:"scoreGTE,omitempty"`
	ScoreLT     *int  `json:"scoreLT,omitempty"`
	ScoreLTE    *int  `json:"scoreLTE,omitempty"`
	ScoreIsNil  bool  `json:"scoreIsNil,omitempty"`
	ScoreNotNil bool  `json:"scoreNotNil,omitempty"`

	// "mitigation" field predicates.
	Mitigation             *string  `json:"mitigation,omitempty"`
	MitigationNEQ          *string  `json:"mitigationNEQ,omitempty"`
	MitigationIn           []string `json:"mitigationIn,omitempty"`
	MitigationNotIn        []string `json:"mitigationNotIn,omitempty"`
	MitigationGT           *string  `json:"mitigationGT,omitempty"`
	MitigationGTE          *string  `json:"mitigationGTE,omitempty"`
	MitigationLT           *string  `json:"mitigationLT,omitempty"`
	MitigationLTE          *string  `json:"mitigationLTE,omitempty"`
	MitigationContains     *string  `json:"mitigationContains,omitempty"`
	MitigationHasPrefix    *string  `json:"mitigationHasPrefix,omitempty"`
	MitigationHasSuffix    *string  `json:"mitigationHasSuffix,omitempty"`
	MitigationIsNil        bool     `json:"mitigationIsNil,omitempty"`
	MitigationNotNil       bool     `json:"mitigationNotNil,omitempty"`
	MitigationEqualFold    *string  `json:"mitigationEqualFold,omitempty"`
	MitigationContainsFold *string  `json:"mitigationContainsFold,omitempty"`

	// "details" field predicates.
	Details             *string  `json:"details,omitempty"`
	DetailsNEQ          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGT           *string  `json:"detailsGT,omitempty"`
	DetailsGTE          *string  `json:"detailsGTE,omitempty"`
	DetailsLT           *string  `json:"detailsLT,omitempty"`
	DetailsLTE          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        bool     `json:"detailsIsNil,omitempty"`
	DetailsNotNil       bool     `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`

	// "business_costs" field predicates.
	BusinessCosts             *string  `json:"businessCosts,omitempty"`
	BusinessCostsNEQ          *string  `json:"businessCostsNEQ,omitempty"`
	BusinessCostsIn           []string `json:"businessCostsIn,omitempty"`
	BusinessCostsNotIn        []string `json:"businessCostsNotIn,omitempty"`
	BusinessCostsGT           *string  `json:"businessCostsGT,omitempty"`
	BusinessCostsGTE          *string  `json:"businessCostsGTE,omitempty"`
	BusinessCostsLT           *string  `json:"businessCostsLT,omitempty"`
	BusinessCostsLTE          *string  `json:"businessCostsLTE,omitempty"`
	BusinessCostsContains     *string  `json:"businessCostsContains,omitempty"`
	BusinessCostsHasPrefix    *string  `json:"businessCostsHasPrefix,omitempty"`
	BusinessCostsHasSuffix    *string  `json:"businessCostsHasSuffix,omitempty"`
	BusinessCostsIsNil        bool     `json:"businessCostsIsNil,omitempty"`
	BusinessCostsNotNil       bool     `json:"businessCostsNotNil,omitempty"`
	BusinessCostsEqualFold    *string  `json:"businessCostsEqualFold,omitempty"`
	BusinessCostsContainsFold *string  `json:"businessCostsContainsFold,omitempty"`

	// "stakeholder_id" field predicates.
	StakeholderID             *string  `json:"stakeholderID,omitempty"`
	StakeholderIDNEQ          *string  `json:"stakeholderIDNEQ,omitempty"`
	StakeholderIDIn           []string `json:"stakeholderIDIn,omitempty"`
	StakeholderIDNotIn        []string `json:"stakeholderIDNotIn,omitempty"`
	StakeholderIDGT           *string  `json:"stakeholderIDGT,omitempty"`
	StakeholderIDGTE          *string  `json:"stakeholderIDGTE,omitempty"`
	StakeholderIDLT           *string  `json:"stakeholderIDLT,omitempty"`
	StakeholderIDLTE          *string  `json:"stakeholderIDLTE,omitempty"`
	StakeholderIDContains     *string  `json:"stakeholderIDContains,omitempty"`
	StakeholderIDHasPrefix    *string  `json:"stakeholderIDHasPrefix,omitempty"`
	StakeholderIDHasSuffix    *string  `json:"stakeholderIDHasSuffix,omitempty"`
	StakeholderIDIsNil        bool     `json:"stakeholderIDIsNil,omitempty"`
	StakeholderIDNotNil       bool     `json:"stakeholderIDNotNil,omitempty"`
	StakeholderIDEqualFold    *string  `json:"stakeholderIDEqualFold,omitempty"`
	StakeholderIDContainsFold *string  `json:"stakeholderIDContainsFold,omitempty"`

	// "delegate_id" field predicates.
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIDNEQ          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIDGT           *string  `json:"delegateIDGT,omitempty"`
	DelegateIDGTE          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIDLT           *string  `json:"delegateIDLT,omitempty"`
	DelegateIDLTE          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        bool     `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       bool     `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RiskHistoryWhereInput) AddPredicates(predicates ...predicate.RiskHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RiskHistoryWhereInput filter on the RiskHistoryQuery builder.
func (i *RiskHistoryWhereInput) Filter(q *RiskHistoryQuery) (*RiskHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRiskHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRiskHistoryWhereInput is returned in case the RiskHistoryWhereInput is empty.
var ErrEmptyRiskHistoryWhereInput = errors.New("generated: empty predicate RiskHistoryWhereInput")

// P returns a predicate for filtering riskhistories.
// An error is returned if the input is empty or invalid.
func (i *RiskHistoryWhereInput) P() (predicate.RiskHistory, error) {
	var predicates []predicate.RiskHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, riskhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.RiskHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, riskhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.RiskHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, riskhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, riskhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, riskhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, riskhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, riskhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, riskhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, riskhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, riskhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, riskhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, riskhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, riskhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, riskhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, riskhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, riskhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, riskhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, riskhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, riskhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, riskhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, riskhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, riskhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, riskhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, riskhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, riskhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, riskhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, riskhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, riskhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, riskhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, riskhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, riskhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, riskhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, riskhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, riskhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, riskhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, riskhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, riskhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, riskhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, riskhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, riskhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, riskhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, riskhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, riskhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, riskhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, riskhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, riskhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, riskhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, riskhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, riskhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, riskhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, riskhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, riskhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, riskhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, riskhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, riskhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, riskhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, riskhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, riskhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, riskhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, riskhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, riskhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, riskhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, riskhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, riskhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, riskhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, riskhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, riskhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, riskhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, riskhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, riskhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, riskhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, riskhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, riskhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, riskhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, riskhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, riskhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, riskhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, riskhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, riskhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, riskhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, riskhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, riskhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, riskhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, riskhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, riskhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, riskhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, riskhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, riskhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, riskhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, riskhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, riskhistory.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, riskhistory.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, riskhistory.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, riskhistory.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, riskhistory.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, riskhistory.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, riskhistory.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, riskhistory.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, riskhistory.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, riskhistory.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, riskhistory.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, riskhistory.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, riskhistory.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, riskhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, riskhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, riskhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, riskhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, riskhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, riskhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, riskhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, riskhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, riskhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, riskhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, riskhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, riskhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, riskhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, riskhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, riskhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, riskhistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, riskhistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, riskhistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, riskhistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, riskhistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, riskhistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, riskhistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, riskhistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, riskhistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, riskhistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, riskhistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, riskhistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, riskhistory.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, riskhistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, riskhistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, riskhistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, riskhistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, riskhistory.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, riskhistory.StatusNotNil())
	}
	if i.RiskType != nil {
		predicates = append(predicates, riskhistory.RiskTypeEQ(*i.RiskType))
	}
	if i.RiskTypeNEQ != nil {
		predicates = append(predicates, riskhistory.RiskTypeNEQ(*i.RiskTypeNEQ))
	}
	if len(i.RiskTypeIn) > 0 {
		predicates = append(predicates, riskhistory.RiskTypeIn(i.RiskTypeIn...))
	}
	if len(i.RiskTypeNotIn) > 0 {
		predicates = append(predicates, riskhistory.RiskTypeNotIn(i.RiskTypeNotIn...))
	}
	if i.RiskTypeGT != nil {
		predicates = append(predicates, riskhistory.RiskTypeGT(*i.RiskTypeGT))
	}
	if i.RiskTypeGTE != nil {
		predicates = append(predicates, riskhistory.RiskTypeGTE(*i.RiskTypeGTE))
	}
	if i.RiskTypeLT != nil {
		predicates = append(predicates, riskhistory.RiskTypeLT(*i.RiskTypeLT))
	}
	if i.RiskTypeLTE != nil {
		predicates = append(predicates, riskhistory.RiskTypeLTE(*i.RiskTypeLTE))
	}
	if i.RiskTypeContains != nil {
		predicates = append(predicates, riskhistory.RiskTypeContains(*i.RiskTypeContains))
	}
	if i.RiskTypeHasPrefix != nil {
		predicates = append(predicates, riskhistory.RiskTypeHasPrefix(*i.RiskTypeHasPrefix))
	}
	if i.RiskTypeHasSuffix != nil {
		predicates = append(predicates, riskhistory.RiskTypeHasSuffix(*i.RiskTypeHasSuffix))
	}
	if i.RiskTypeIsNil {
		predicates = append(predicates, riskhistory.RiskTypeIsNil())
	}
	if i.RiskTypeNotNil {
		predicates = append(predicates, riskhistory.RiskTypeNotNil())
	}
	if i.RiskTypeEqualFold != nil {
		predicates = append(predicates, riskhistory.RiskTypeEqualFold(*i.RiskTypeEqualFold))
	}
	if i.RiskTypeContainsFold != nil {
		predicates = append(predicates, riskhistory.RiskTypeContainsFold(*i.RiskTypeContainsFold))
	}
	if i.Category != nil {
		predicates = append(predicates, riskhistory.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, riskhistory.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, riskhistory.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, riskhistory.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, riskhistory.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, riskhistory.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, riskhistory.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, riskhistory.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, riskhistory.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, riskhistory.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, riskhistory.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryIsNil {
		predicates = append(predicates, riskhistory.CategoryIsNil())
	}
	if i.CategoryNotNil {
		predicates = append(predicates, riskhistory.CategoryNotNil())
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, riskhistory.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, riskhistory.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.Impact != nil {
		predicates = append(predicates, riskhistory.ImpactEQ(*i.Impact))
	}
	if i.ImpactNEQ != nil {
		predicates = append(predicates, riskhistory.ImpactNEQ(*i.ImpactNEQ))
	}
	if len(i.ImpactIn) > 0 {
		predicates = append(predicates, riskhistory.ImpactIn(i.ImpactIn...))
	}
	if len(i.ImpactNotIn) > 0 {
		predicates = append(predicates, riskhistory.ImpactNotIn(i.ImpactNotIn...))
	}
	if i.ImpactIsNil {
		predicates = append(predicates, riskhistory.ImpactIsNil())
	}
	if i.ImpactNotNil {
		predicates = append(predicates, riskhistory.ImpactNotNil())
	}
	if i.Likelihood != nil {
		predicates = append(predicates, riskhistory.LikelihoodEQ(*i.Likelihood))
	}
	if i.LikelihoodNEQ != nil {
		predicates = append(predicates, riskhistory.LikelihoodNEQ(*i.LikelihoodNEQ))
	}
	if len(i.LikelihoodIn) > 0 {
		predicates = append(predicates, riskhistory.LikelihoodIn(i.LikelihoodIn...))
	}
	if len(i.LikelihoodNotIn) > 0 {
		predicates = append(predicates, riskhistory.LikelihoodNotIn(i.LikelihoodNotIn...))
	}
	if i.LikelihoodIsNil {
		predicates = append(predicates, riskhistory.LikelihoodIsNil())
	}
	if i.LikelihoodNotNil {
		predicates = append(predicates, riskhistory.LikelihoodNotNil())
	}
	if i.Score != nil {
		predicates = append(predicates, riskhistory.ScoreEQ(*i.Score))
	}
	if i.ScoreNEQ != nil {
		predicates = append(predicates, riskhistory.ScoreNEQ(*i.ScoreNEQ))
	}
	if len(i.ScoreIn) > 0 {
		predicates = append(predicates, riskhistory.ScoreIn(i.ScoreIn...))
	}
	if len(i.ScoreNotIn) > 0 {
		predicates = append(predicates, riskhistory.ScoreNotIn(i.ScoreNotIn...))
	}
	if i.ScoreGT != nil {
		predicates = append(predicates, riskhistory.ScoreGT(*i.ScoreGT))
	}
	if i.ScoreGTE != nil {
		predicates = append(predicates, riskhistory.ScoreGTE(*i.ScoreGTE))
	}
	if i.ScoreLT != nil {
		predicates = append(predicates, riskhistory.ScoreLT(*i.ScoreLT))
	}
	if i.ScoreLTE != nil {
		predicates = append(predicates, riskhistory.ScoreLTE(*i.ScoreLTE))
	}
	if i.ScoreIsNil {
		predicates = append(predicates, riskhistory.ScoreIsNil())
	}
	if i.ScoreNotNil {
		predicates = append(predicates, riskhistory.ScoreNotNil())
	}
	if i.Mitigation != nil {
		predicates = append(predicates, riskhistory.MitigationEQ(*i.Mitigation))
	}
	if i.MitigationNEQ != nil {
		predicates = append(predicates, riskhistory.MitigationNEQ(*i.MitigationNEQ))
	}
	if len(i.MitigationIn) > 0 {
		predicates = append(predicates, riskhistory.MitigationIn(i.MitigationIn...))
	}
	if len(i.MitigationNotIn) > 0 {
		predicates = append(predicates, riskhistory.MitigationNotIn(i.MitigationNotIn...))
	}
	if i.MitigationGT != nil {
		predicates = append(predicates, riskhistory.MitigationGT(*i.MitigationGT))
	}
	if i.MitigationGTE != nil {
		predicates = append(predicates, riskhistory.MitigationGTE(*i.MitigationGTE))
	}
	if i.MitigationLT != nil {
		predicates = append(predicates, riskhistory.MitigationLT(*i.MitigationLT))
	}
	if i.MitigationLTE != nil {
		predicates = append(predicates, riskhistory.MitigationLTE(*i.MitigationLTE))
	}
	if i.MitigationContains != nil {
		predicates = append(predicates, riskhistory.MitigationContains(*i.MitigationContains))
	}
	if i.MitigationHasPrefix != nil {
		predicates = append(predicates, riskhistory.MitigationHasPrefix(*i.MitigationHasPrefix))
	}
	if i.MitigationHasSuffix != nil {
		predicates = append(predicates, riskhistory.MitigationHasSuffix(*i.MitigationHasSuffix))
	}
	if i.MitigationIsNil {
		predicates = append(predicates, riskhistory.MitigationIsNil())
	}
	if i.MitigationNotNil {
		predicates = append(predicates, riskhistory.MitigationNotNil())
	}
	if i.MitigationEqualFold != nil {
		predicates = append(predicates, riskhistory.MitigationEqualFold(*i.MitigationEqualFold))
	}
	if i.MitigationContainsFold != nil {
		predicates = append(predicates, riskhistory.MitigationContainsFold(*i.MitigationContainsFold))
	}
	if i.Details != nil {
		predicates = append(predicates, riskhistory.DetailsEQ(*i.Details))
	}
	if i.DetailsNEQ != nil {
		predicates = append(predicates, riskhistory.DetailsNEQ(*i.DetailsNEQ))
	}
	if len(i.DetailsIn) > 0 {
		predicates = append(predicates, riskhistory.DetailsIn(i.DetailsIn...))
	}
	if len(i.DetailsNotIn) > 0 {
		predicates = append(predicates, riskhistory.DetailsNotIn(i.DetailsNotIn...))
	}
	if i.DetailsGT != nil {
		predicates = append(predicates, riskhistory.DetailsGT(*i.DetailsGT))
	}
	if i.DetailsGTE != nil {
		predicates = append(predicates, riskhistory.DetailsGTE(*i.DetailsGTE))
	}
	if i.DetailsLT != nil {
		predicates = append(predicates, riskhistory.DetailsLT(*i.DetailsLT))
	}
	if i.DetailsLTE != nil {
		predicates = append(predicates, riskhistory.DetailsLTE(*i.DetailsLTE))
	}
	if i.DetailsContains != nil {
		predicates = append(predicates, riskhistory.DetailsContains(*i.DetailsContains))
	}
	if i.DetailsHasPrefix != nil {
		predicates = append(predicates, riskhistory.DetailsHasPrefix(*i.DetailsHasPrefix))
	}
	if i.DetailsHasSuffix != nil {
		predicates = append(predicates, riskhistory.DetailsHasSuffix(*i.DetailsHasSuffix))
	}
	if i.DetailsIsNil {
		predicates = append(predicates, riskhistory.DetailsIsNil())
	}
	if i.DetailsNotNil {
		predicates = append(predicates, riskhistory.DetailsNotNil())
	}
	if i.DetailsEqualFold != nil {
		predicates = append(predicates, riskhistory.DetailsEqualFold(*i.DetailsEqualFold))
	}
	if i.DetailsContainsFold != nil {
		predicates = append(predicates, riskhistory.DetailsContainsFold(*i.DetailsContainsFold))
	}
	if i.BusinessCosts != nil {
		predicates = append(predicates, riskhistory.BusinessCostsEQ(*i.BusinessCosts))
	}
	if i.BusinessCostsNEQ != nil {
		predicates = append(predicates, riskhistory.BusinessCostsNEQ(*i.BusinessCostsNEQ))
	}
	if len(i.BusinessCostsIn) > 0 {
		predicates = append(predicates, riskhistory.BusinessCostsIn(i.BusinessCostsIn...))
	}
	if len(i.BusinessCostsNotIn) > 0 {
		predicates = append(predicates, riskhistory.BusinessCostsNotIn(i.BusinessCostsNotIn...))
	}
	if i.BusinessCostsGT != nil {
		predicates = append(predicates, riskhistory.BusinessCostsGT(*i.BusinessCostsGT))
	}
	if i.BusinessCostsGTE != nil {
		predicates = append(predicates, riskhistory.BusinessCostsGTE(*i.BusinessCostsGTE))
	}
	if i.BusinessCostsLT != nil {
		predicates = append(predicates, riskhistory.BusinessCostsLT(*i.BusinessCostsLT))
	}
	if i.BusinessCostsLTE != nil {
		predicates = append(predicates, riskhistory.BusinessCostsLTE(*i.BusinessCostsLTE))
	}
	if i.BusinessCostsContains != nil {
		predicates = append(predicates, riskhistory.BusinessCostsContains(*i.BusinessCostsContains))
	}
	if i.BusinessCostsHasPrefix != nil {
		predicates = append(predicates, riskhistory.BusinessCostsHasPrefix(*i.BusinessCostsHasPrefix))
	}
	if i.BusinessCostsHasSuffix != nil {
		predicates = append(predicates, riskhistory.BusinessCostsHasSuffix(*i.BusinessCostsHasSuffix))
	}
	if i.BusinessCostsIsNil {
		predicates = append(predicates, riskhistory.BusinessCostsIsNil())
	}
	if i.BusinessCostsNotNil {
		predicates = append(predicates, riskhistory.BusinessCostsNotNil())
	}
	if i.BusinessCostsEqualFold != nil {
		predicates = append(predicates, riskhistory.BusinessCostsEqualFold(*i.BusinessCostsEqualFold))
	}
	if i.BusinessCostsContainsFold != nil {
		predicates = append(predicates, riskhistory.BusinessCostsContainsFold(*i.BusinessCostsContainsFold))
	}
	if i.StakeholderID != nil {
		predicates = append(predicates, riskhistory.StakeholderIDEQ(*i.StakeholderID))
	}
	if i.StakeholderIDNEQ != nil {
		predicates = append(predicates, riskhistory.StakeholderIDNEQ(*i.StakeholderIDNEQ))
	}
	if len(i.StakeholderIDIn) > 0 {
		predicates = append(predicates, riskhistory.StakeholderIDIn(i.StakeholderIDIn...))
	}
	if len(i.StakeholderIDNotIn) > 0 {
		predicates = append(predicates, riskhistory.StakeholderIDNotIn(i.StakeholderIDNotIn...))
	}
	if i.StakeholderIDGT != nil {
		predicates = append(predicates, riskhistory.StakeholderIDGT(*i.StakeholderIDGT))
	}
	if i.StakeholderIDGTE != nil {
		predicates = append(predicates, riskhistory.StakeholderIDGTE(*i.StakeholderIDGTE))
	}
	if i.StakeholderIDLT != nil {
		predicates = append(predicates, riskhistory.StakeholderIDLT(*i.StakeholderIDLT))
	}
	if i.StakeholderIDLTE != nil {
		predicates = append(predicates, riskhistory.StakeholderIDLTE(*i.StakeholderIDLTE))
	}
	if i.StakeholderIDContains != nil {
		predicates = append(predicates, riskhistory.StakeholderIDContains(*i.StakeholderIDContains))
	}
	if i.StakeholderIDHasPrefix != nil {
		predicates = append(predicates, riskhistory.StakeholderIDHasPrefix(*i.StakeholderIDHasPrefix))
	}
	if i.StakeholderIDHasSuffix != nil {
		predicates = append(predicates, riskhistory.StakeholderIDHasSuffix(*i.StakeholderIDHasSuffix))
	}
	if i.StakeholderIDIsNil {
		predicates = append(predicates, riskhistory.StakeholderIDIsNil())
	}
	if i.StakeholderIDNotNil {
		predicates = append(predicates, riskhistory.StakeholderIDNotNil())
	}
	if i.StakeholderIDEqualFold != nil {
		predicates = append(predicates, riskhistory.StakeholderIDEqualFold(*i.StakeholderIDEqualFold))
	}
	if i.StakeholderIDContainsFold != nil {
		predicates = append(predicates, riskhistory.StakeholderIDContainsFold(*i.StakeholderIDContainsFold))
	}
	if i.DelegateID != nil {
		predicates = append(predicates, riskhistory.DelegateIDEQ(*i.DelegateID))
	}
	if i.DelegateIDNEQ != nil {
		predicates = append(predicates, riskhistory.DelegateIDNEQ(*i.DelegateIDNEQ))
	}
	if len(i.DelegateIDIn) > 0 {
		predicates = append(predicates, riskhistory.DelegateIDIn(i.DelegateIDIn...))
	}
	if len(i.DelegateIDNotIn) > 0 {
		predicates = append(predicates, riskhistory.DelegateIDNotIn(i.DelegateIDNotIn...))
	}
	if i.DelegateIDGT != nil {
		predicates = append(predicates, riskhistory.DelegateIDGT(*i.DelegateIDGT))
	}
	if i.DelegateIDGTE != nil {
		predicates = append(predicates, riskhistory.DelegateIDGTE(*i.DelegateIDGTE))
	}
	if i.DelegateIDLT != nil {
		predicates = append(predicates, riskhistory.DelegateIDLT(*i.DelegateIDLT))
	}
	if i.DelegateIDLTE != nil {
		predicates = append(predicates, riskhistory.DelegateIDLTE(*i.DelegateIDLTE))
	}
	if i.DelegateIDContains != nil {
		predicates = append(predicates, riskhistory.DelegateIDContains(*i.DelegateIDContains))
	}
	if i.DelegateIDHasPrefix != nil {
		predicates = append(predicates, riskhistory.DelegateIDHasPrefix(*i.DelegateIDHasPrefix))
	}
	if i.DelegateIDHasSuffix != nil {
		predicates = append(predicates, riskhistory.DelegateIDHasSuffix(*i.DelegateIDHasSuffix))
	}
	if i.DelegateIDIsNil {
		predicates = append(predicates, riskhistory.DelegateIDIsNil())
	}
	if i.DelegateIDNotNil {
		predicates = append(predicates, riskhistory.DelegateIDNotNil())
	}
	if i.DelegateIDEqualFold != nil {
		predicates = append(predicates, riskhistory.DelegateIDEqualFold(*i.DelegateIDEqualFold))
	}
	if i.DelegateIDContainsFold != nil {
		predicates = append(predicates, riskhistory.DelegateIDContainsFold(*i.DelegateIDContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRiskHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return riskhistory.And(predicates...), nil
	}
}

// ScheduledJobWhereInput represents a where input for filtering ScheduledJob queries.
type ScheduledJobWhereInput struct {
	Predicates []predicate.ScheduledJob  `json:"-"`
	Not        *ScheduledJobWhereInput   `json:"not,omitempty"`
	Or         []*ScheduledJobWhereInput `json:"or,omitempty"`
	And        []*ScheduledJobWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "system_owned" field predicates.
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNEQ    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  bool  `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil bool  `json:"systemOwnedNotNil,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "job_type" field predicates.
	JobType      *enums.JobType  `json:"jobType,omitempty"`
	JobTypeNEQ   *enums.JobType  `json:"jobTypeNEQ,omitempty"`
	JobTypeIn    []enums.JobType `json:"jobTypeIn,omitempty"`
	JobTypeNotIn []enums.JobType `json:"jobTypeNotIn,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ScheduledJobWhereInput) AddPredicates(predicates ...predicate.ScheduledJob) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ScheduledJobWhereInput filter on the ScheduledJobQuery builder.
func (i *ScheduledJobWhereInput) Filter(q *ScheduledJobQuery) (*ScheduledJobQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyScheduledJobWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyScheduledJobWhereInput is returned in case the ScheduledJobWhereInput is empty.
var ErrEmptyScheduledJobWhereInput = errors.New("generated: empty predicate ScheduledJobWhereInput")

// P returns a predicate for filtering scheduledjobs.
// An error is returned if the input is empty or invalid.
func (i *ScheduledJobWhereInput) P() (predicate.ScheduledJob, error) {
	var predicates []predicate.ScheduledJob
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, scheduledjob.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ScheduledJob, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, scheduledjob.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ScheduledJob, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, scheduledjob.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, scheduledjob.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, scheduledjob.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, scheduledjob.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, scheduledjob.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, scheduledjob.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, scheduledjob.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, scheduledjob.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, scheduledjob.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, scheduledjob.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, scheduledjob.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, scheduledjob.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, scheduledjob.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, scheduledjob.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, scheduledjob.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, scheduledjob.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, scheduledjob.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, scheduledjob.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, scheduledjob.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, scheduledjob.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, scheduledjob.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, scheduledjob.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, scheduledjob.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, scheduledjob.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, scheduledjob.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, scheduledjob.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, scheduledjob.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, scheduledjob.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, scheduledjob.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, scheduledjob.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, scheduledjob.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, scheduledjob.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, scheduledjob.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, scheduledjob.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, scheduledjob.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, scheduledjob.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, scheduledjob.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, scheduledjob.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, scheduledjob.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, scheduledjob.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, scheduledjob.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, scheduledjob.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, scheduledjob.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, scheduledjob.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, scheduledjob.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, scheduledjob.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, scheduledjob.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, scheduledjob.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, scheduledjob.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, scheduledjob.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, scheduledjob.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, scheduledjob.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, scheduledjob.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, scheduledjob.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, scheduledjob.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, scheduledjob.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, scheduledjob.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, scheduledjob.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, scheduledjob.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, scheduledjob.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, scheduledjob.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, scheduledjob.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, scheduledjob.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, scheduledjob.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, scheduledjob.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, scheduledjob.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, scheduledjob.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, scheduledjob.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, scheduledjob.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, scheduledjob.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, scheduledjob.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, scheduledjob.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, scheduledjob.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, scheduledjob.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, scheduledjob.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, scheduledjob.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, scheduledjob.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, scheduledjob.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, scheduledjob.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, scheduledjob.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, scheduledjob.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, scheduledjob.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, scheduledjob.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, scheduledjob.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, scheduledjob.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, scheduledjob.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, scheduledjob.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, scheduledjob.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, scheduledjob.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.SystemOwned != nil {
		predicates = append(predicates, scheduledjob.SystemOwnedEQ(*i.SystemOwned))
	}
	if i.SystemOwnedNEQ != nil {
		predicates = append(predicates, scheduledjob.SystemOwnedNEQ(*i.SystemOwnedNEQ))
	}
	if i.SystemOwnedIsNil {
		predicates = append(predicates, scheduledjob.SystemOwnedIsNil())
	}
	if i.SystemOwnedNotNil {
		predicates = append(predicates, scheduledjob.SystemOwnedNotNil())
	}
	if i.Title != nil {
		predicates = append(predicates, scheduledjob.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, scheduledjob.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, scheduledjob.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, scheduledjob.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, scheduledjob.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, scheduledjob.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, scheduledjob.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, scheduledjob.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, scheduledjob.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, scheduledjob.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, scheduledjob.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, scheduledjob.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, scheduledjob.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, scheduledjob.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, scheduledjob.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, scheduledjob.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, scheduledjob.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, scheduledjob.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, scheduledjob.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, scheduledjob.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, scheduledjob.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, scheduledjob.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, scheduledjob.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, scheduledjob.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, scheduledjob.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, scheduledjob.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, scheduledjob.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, scheduledjob.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.JobType != nil {
		predicates = append(predicates, scheduledjob.JobTypeEQ(*i.JobType))
	}
	if i.JobTypeNEQ != nil {
		predicates = append(predicates, scheduledjob.JobTypeNEQ(*i.JobTypeNEQ))
	}
	if len(i.JobTypeIn) > 0 {
		predicates = append(predicates, scheduledjob.JobTypeIn(i.JobTypeIn...))
	}
	if len(i.JobTypeNotIn) > 0 {
		predicates = append(predicates, scheduledjob.JobTypeNotIn(i.JobTypeNotIn...))
	}

	if i.HasOwner != nil {
		p := scheduledjob.HasOwner()
		if !*i.HasOwner {
			p = scheduledjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, scheduledjob.HasOwnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyScheduledJobWhereInput
	case 1:
		return predicates[0], nil
	default:
		return scheduledjob.And(predicates...), nil
	}
}

// ScheduledJobHistoryWhereInput represents a where input for filtering ScheduledJobHistory queries.
type ScheduledJobHistoryWhereInput struct {
	Predicates []predicate.ScheduledJobHistory  `json:"-"`
	Not        *ScheduledJobHistoryWhereInput   `json:"not,omitempty"`
	Or         []*ScheduledJobHistoryWhereInput `json:"or,omitempty"`
	And        []*ScheduledJobHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "system_owned" field predicates.
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNEQ    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  bool  `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil bool  `json:"systemOwnedNotNil,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "job_type" field predicates.
	JobType      *enums.JobType  `json:"jobType,omitempty"`
	JobTypeNEQ   *enums.JobType  `json:"jobTypeNEQ,omitempty"`
	JobTypeIn    []enums.JobType `json:"jobTypeIn,omitempty"`
	JobTypeNotIn []enums.JobType `json:"jobTypeNotIn,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ScheduledJobHistoryWhereInput) AddPredicates(predicates ...predicate.ScheduledJobHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ScheduledJobHistoryWhereInput filter on the ScheduledJobHistoryQuery builder.
func (i *ScheduledJobHistoryWhereInput) Filter(q *ScheduledJobHistoryQuery) (*ScheduledJobHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyScheduledJobHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyScheduledJobHistoryWhereInput is returned in case the ScheduledJobHistoryWhereInput is empty.
var ErrEmptyScheduledJobHistoryWhereInput = errors.New("generated: empty predicate ScheduledJobHistoryWhereInput")

// P returns a predicate for filtering scheduledjobhistories.
// An error is returned if the input is empty or invalid.
func (i *ScheduledJobHistoryWhereInput) P() (predicate.ScheduledJobHistory, error) {
	var predicates []predicate.ScheduledJobHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, scheduledjobhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ScheduledJobHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, scheduledjobhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ScheduledJobHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, scheduledjobhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, scheduledjobhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, scheduledjobhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, scheduledjobhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, scheduledjobhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, scheduledjobhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, scheduledjobhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, scheduledjobhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, scheduledjobhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, scheduledjobhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, scheduledjobhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, scheduledjobhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, scheduledjobhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, scheduledjobhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, scheduledjobhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, scheduledjobhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, scheduledjobhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, scheduledjobhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, scheduledjobhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, scheduledjobhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, scheduledjobhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, scheduledjobhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, scheduledjobhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, scheduledjobhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, scheduledjobhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, scheduledjobhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, scheduledjobhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, scheduledjobhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, scheduledjobhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, scheduledjobhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, scheduledjobhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, scheduledjobhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, scheduledjobhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, scheduledjobhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, scheduledjobhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, scheduledjobhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, scheduledjobhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, scheduledjobhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, scheduledjobhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, scheduledjobhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, scheduledjobhistory.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, scheduledjobhistory.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, scheduledjobhistory.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, scheduledjobhistory.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, scheduledjobhistory.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, scheduledjobhistory.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, scheduledjobhistory.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, scheduledjobhistory.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, scheduledjobhistory.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, scheduledjobhistory.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, scheduledjobhistory.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, scheduledjobhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, scheduledjobhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, scheduledjobhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, scheduledjobhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, scheduledjobhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, scheduledjobhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, scheduledjobhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, scheduledjobhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, scheduledjobhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, scheduledjobhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, scheduledjobhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, scheduledjobhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, scheduledjobhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.SystemOwned != nil {
		predicates = append(predicates, scheduledjobhistory.SystemOwnedEQ(*i.SystemOwned))
	}
	if i.SystemOwnedNEQ != nil {
		predicates = append(predicates, scheduledjobhistory.SystemOwnedNEQ(*i.SystemOwnedNEQ))
	}
	if i.SystemOwnedIsNil {
		predicates = append(predicates, scheduledjobhistory.SystemOwnedIsNil())
	}
	if i.SystemOwnedNotNil {
		predicates = append(predicates, scheduledjobhistory.SystemOwnedNotNil())
	}
	if i.Title != nil {
		predicates = append(predicates, scheduledjobhistory.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, scheduledjobhistory.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, scheduledjobhistory.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, scheduledjobhistory.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, scheduledjobhistory.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, scheduledjobhistory.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, scheduledjobhistory.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, scheduledjobhistory.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, scheduledjobhistory.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, scheduledjobhistory.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, scheduledjobhistory.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, scheduledjobhistory.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, scheduledjobhistory.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, scheduledjobhistory.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, scheduledjobhistory.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, scheduledjobhistory.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, scheduledjobhistory.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, scheduledjobhistory.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, scheduledjobhistory.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, scheduledjobhistory.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, scheduledjobhistory.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, scheduledjobhistory.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, scheduledjobhistory.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, scheduledjobhistory.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.JobType != nil {
		predicates = append(predicates, scheduledjobhistory.JobTypeEQ(*i.JobType))
	}
	if i.JobTypeNEQ != nil {
		predicates = append(predicates, scheduledjobhistory.JobTypeNEQ(*i.JobTypeNEQ))
	}
	if len(i.JobTypeIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.JobTypeIn(i.JobTypeIn...))
	}
	if len(i.JobTypeNotIn) > 0 {
		predicates = append(predicates, scheduledjobhistory.JobTypeNotIn(i.JobTypeNotIn...))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyScheduledJobHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return scheduledjobhistory.And(predicates...), nil
	}
}

// ScheduledJobRunWhereInput represents a where input for filtering ScheduledJobRun queries.
type ScheduledJobRunWhereInput struct {
	Predicates []predicate.ScheduledJobRun  `json:"-"`
	Not        *ScheduledJobRunWhereInput   `json:"not,omitempty"`
	Or         []*ScheduledJobRunWhereInput `json:"or,omitempty"`
	And        []*ScheduledJobRunWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "job_runner_id" field predicates.
	JobRunnerID             *string  `json:"jobRunnerID,omitempty"`
	JobRunnerIDNEQ          *string  `json:"jobRunnerIDNEQ,omitempty"`
	JobRunnerIDIn           []string `json:"jobRunnerIDIn,omitempty"`
	JobRunnerIDNotIn        []string `json:"jobRunnerIDNotIn,omitempty"`
	JobRunnerIDGT           *string  `json:"jobRunnerIDGT,omitempty"`
	JobRunnerIDGTE          *string  `json:"jobRunnerIDGTE,omitempty"`
	JobRunnerIDLT           *string  `json:"jobRunnerIDLT,omitempty"`
	JobRunnerIDLTE          *string  `json:"jobRunnerIDLTE,omitempty"`
	JobRunnerIDContains     *string  `json:"jobRunnerIDContains,omitempty"`
	JobRunnerIDHasPrefix    *string  `json:"jobRunnerIDHasPrefix,omitempty"`
	JobRunnerIDHasSuffix    *string  `json:"jobRunnerIDHasSuffix,omitempty"`
	JobRunnerIDEqualFold    *string  `json:"jobRunnerIDEqualFold,omitempty"`
	JobRunnerIDContainsFold *string  `json:"jobRunnerIDContainsFold,omitempty"`

	// "status" field predicates.
	Status      *enums.ScheduledJobRunStatus  `json:"status,omitempty"`
	StatusNEQ   *enums.ScheduledJobRunStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ScheduledJobRunStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ScheduledJobRunStatus `json:"statusNotIn,omitempty"`

	// "scheduled_job_id" field predicates.
	ScheduledJobID             *string  `json:"scheduledJobID,omitempty"`
	ScheduledJobIDNEQ          *string  `json:"scheduledJobIDNEQ,omitempty"`
	ScheduledJobIDIn           []string `json:"scheduledJobIDIn,omitempty"`
	ScheduledJobIDNotIn        []string `json:"scheduledJobIDNotIn,omitempty"`
	ScheduledJobIDGT           *string  `json:"scheduledJobIDGT,omitempty"`
	ScheduledJobIDGTE          *string  `json:"scheduledJobIDGTE,omitempty"`
	ScheduledJobIDLT           *string  `json:"scheduledJobIDLT,omitempty"`
	ScheduledJobIDLTE          *string  `json:"scheduledJobIDLTE,omitempty"`
	ScheduledJobIDContains     *string  `json:"scheduledJobIDContains,omitempty"`
	ScheduledJobIDHasPrefix    *string  `json:"scheduledJobIDHasPrefix,omitempty"`
	ScheduledJobIDHasSuffix    *string  `json:"scheduledJobIDHasSuffix,omitempty"`
	ScheduledJobIDEqualFold    *string  `json:"scheduledJobIDEqualFold,omitempty"`
	ScheduledJobIDContainsFold *string  `json:"scheduledJobIDContainsFold,omitempty"`

	// "expected_execution_time" field predicates.
	ExpectedExecutionTime      *time.Time  `json:"expectedExecutionTime,omitempty"`
	ExpectedExecutionTimeNEQ   *time.Time  `json:"expectedExecutionTimeNEQ,omitempty"`
	ExpectedExecutionTimeIn    []time.Time `json:"expectedExecutionTimeIn,omitempty"`
	ExpectedExecutionTimeNotIn []time.Time `json:"expectedExecutionTimeNotIn,omitempty"`
	ExpectedExecutionTimeGT    *time.Time  `json:"expectedExecutionTimeGT,omitempty"`
	ExpectedExecutionTimeGTE   *time.Time  `json:"expectedExecutionTimeGTE,omitempty"`
	ExpectedExecutionTimeLT    *time.Time  `json:"expectedExecutionTimeLT,omitempty"`
	ExpectedExecutionTimeLTE   *time.Time  `json:"expectedExecutionTimeLTE,omitempty"`

	// "script" field predicates.
	Script             *string  `json:"script,omitempty"`
	ScriptNEQ          *string  `json:"scriptNEQ,omitempty"`
	ScriptIn           []string `json:"scriptIn,omitempty"`
	ScriptNotIn        []string `json:"scriptNotIn,omitempty"`
	ScriptGT           *string  `json:"scriptGT,omitempty"`
	ScriptGTE          *string  `json:"scriptGTE,omitempty"`
	ScriptLT           *string  `json:"scriptLT,omitempty"`
	ScriptLTE          *string  `json:"scriptLTE,omitempty"`
	ScriptContains     *string  `json:"scriptContains,omitempty"`
	ScriptHasPrefix    *string  `json:"scriptHasPrefix,omitempty"`
	ScriptHasSuffix    *string  `json:"scriptHasSuffix,omitempty"`
	ScriptEqualFold    *string  `json:"scriptEqualFold,omitempty"`
	ScriptContainsFold *string  `json:"scriptContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "scheduled_job" edge predicates.
	HasScheduledJob     *bool                            `json:"hasScheduledJob,omitempty"`
	HasScheduledJobWith []*ControlScheduledJobWhereInput `json:"hasScheduledJobWith,omitempty"`

	// "job_runner" edge predicates.
	HasJobRunner     *bool                  `json:"hasJobRunner,omitempty"`
	HasJobRunnerWith []*JobRunnerWhereInput `json:"hasJobRunnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ScheduledJobRunWhereInput) AddPredicates(predicates ...predicate.ScheduledJobRun) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ScheduledJobRunWhereInput filter on the ScheduledJobRunQuery builder.
func (i *ScheduledJobRunWhereInput) Filter(q *ScheduledJobRunQuery) (*ScheduledJobRunQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyScheduledJobRunWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyScheduledJobRunWhereInput is returned in case the ScheduledJobRunWhereInput is empty.
var ErrEmptyScheduledJobRunWhereInput = errors.New("generated: empty predicate ScheduledJobRunWhereInput")

// P returns a predicate for filtering scheduledjobruns.
// An error is returned if the input is empty or invalid.
func (i *ScheduledJobRunWhereInput) P() (predicate.ScheduledJobRun, error) {
	var predicates []predicate.ScheduledJobRun
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, scheduledjobrun.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ScheduledJobRun, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, scheduledjobrun.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ScheduledJobRun, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, scheduledjobrun.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, scheduledjobrun.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, scheduledjobrun.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, scheduledjobrun.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, scheduledjobrun.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, scheduledjobrun.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, scheduledjobrun.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, scheduledjobrun.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, scheduledjobrun.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, scheduledjobrun.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, scheduledjobrun.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, scheduledjobrun.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, scheduledjobrun.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, scheduledjobrun.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, scheduledjobrun.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, scheduledjobrun.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, scheduledjobrun.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, scheduledjobrun.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, scheduledjobrun.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, scheduledjobrun.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, scheduledjobrun.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, scheduledjobrun.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, scheduledjobrun.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, scheduledjobrun.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, scheduledjobrun.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, scheduledjobrun.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, scheduledjobrun.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, scheduledjobrun.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, scheduledjobrun.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, scheduledjobrun.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, scheduledjobrun.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, scheduledjobrun.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, scheduledjobrun.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, scheduledjobrun.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, scheduledjobrun.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, scheduledjobrun.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, scheduledjobrun.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, scheduledjobrun.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, scheduledjobrun.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, scheduledjobrun.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, scheduledjobrun.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, scheduledjobrun.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, scheduledjobrun.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, scheduledjobrun.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, scheduledjobrun.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, scheduledjobrun.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, scheduledjobrun.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, scheduledjobrun.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, scheduledjobrun.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, scheduledjobrun.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, scheduledjobrun.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, scheduledjobrun.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, scheduledjobrun.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, scheduledjobrun.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, scheduledjobrun.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, scheduledjobrun.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, scheduledjobrun.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, scheduledjobrun.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, scheduledjobrun.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, scheduledjobrun.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.JobRunnerID != nil {
		predicates = append(predicates, scheduledjobrun.JobRunnerIDEQ(*i.JobRunnerID))
	}
	if i.JobRunnerIDNEQ != nil {
		predicates = append(predicates, scheduledjobrun.JobRunnerIDNEQ(*i.JobRunnerIDNEQ))
	}
	if len(i.JobRunnerIDIn) > 0 {
		predicates = append(predicates, scheduledjobrun.JobRunnerIDIn(i.JobRunnerIDIn...))
	}
	if len(i.JobRunnerIDNotIn) > 0 {
		predicates = append(predicates, scheduledjobrun.JobRunnerIDNotIn(i.JobRunnerIDNotIn...))
	}
	if i.JobRunnerIDGT != nil {
		predicates = append(predicates, scheduledjobrun.JobRunnerIDGT(*i.JobRunnerIDGT))
	}
	if i.JobRunnerIDGTE != nil {
		predicates = append(predicates, scheduledjobrun.JobRunnerIDGTE(*i.JobRunnerIDGTE))
	}
	if i.JobRunnerIDLT != nil {
		predicates = append(predicates, scheduledjobrun.JobRunnerIDLT(*i.JobRunnerIDLT))
	}
	if i.JobRunnerIDLTE != nil {
		predicates = append(predicates, scheduledjobrun.JobRunnerIDLTE(*i.JobRunnerIDLTE))
	}
	if i.JobRunnerIDContains != nil {
		predicates = append(predicates, scheduledjobrun.JobRunnerIDContains(*i.JobRunnerIDContains))
	}
	if i.JobRunnerIDHasPrefix != nil {
		predicates = append(predicates, scheduledjobrun.JobRunnerIDHasPrefix(*i.JobRunnerIDHasPrefix))
	}
	if i.JobRunnerIDHasSuffix != nil {
		predicates = append(predicates, scheduledjobrun.JobRunnerIDHasSuffix(*i.JobRunnerIDHasSuffix))
	}
	if i.JobRunnerIDEqualFold != nil {
		predicates = append(predicates, scheduledjobrun.JobRunnerIDEqualFold(*i.JobRunnerIDEqualFold))
	}
	if i.JobRunnerIDContainsFold != nil {
		predicates = append(predicates, scheduledjobrun.JobRunnerIDContainsFold(*i.JobRunnerIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, scheduledjobrun.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, scheduledjobrun.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, scheduledjobrun.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, scheduledjobrun.StatusNotIn(i.StatusNotIn...))
	}
	if i.ScheduledJobID != nil {
		predicates = append(predicates, scheduledjobrun.ScheduledJobIDEQ(*i.ScheduledJobID))
	}
	if i.ScheduledJobIDNEQ != nil {
		predicates = append(predicates, scheduledjobrun.ScheduledJobIDNEQ(*i.ScheduledJobIDNEQ))
	}
	if len(i.ScheduledJobIDIn) > 0 {
		predicates = append(predicates, scheduledjobrun.ScheduledJobIDIn(i.ScheduledJobIDIn...))
	}
	if len(i.ScheduledJobIDNotIn) > 0 {
		predicates = append(predicates, scheduledjobrun.ScheduledJobIDNotIn(i.ScheduledJobIDNotIn...))
	}
	if i.ScheduledJobIDGT != nil {
		predicates = append(predicates, scheduledjobrun.ScheduledJobIDGT(*i.ScheduledJobIDGT))
	}
	if i.ScheduledJobIDGTE != nil {
		predicates = append(predicates, scheduledjobrun.ScheduledJobIDGTE(*i.ScheduledJobIDGTE))
	}
	if i.ScheduledJobIDLT != nil {
		predicates = append(predicates, scheduledjobrun.ScheduledJobIDLT(*i.ScheduledJobIDLT))
	}
	if i.ScheduledJobIDLTE != nil {
		predicates = append(predicates, scheduledjobrun.ScheduledJobIDLTE(*i.ScheduledJobIDLTE))
	}
	if i.ScheduledJobIDContains != nil {
		predicates = append(predicates, scheduledjobrun.ScheduledJobIDContains(*i.ScheduledJobIDContains))
	}
	if i.ScheduledJobIDHasPrefix != nil {
		predicates = append(predicates, scheduledjobrun.ScheduledJobIDHasPrefix(*i.ScheduledJobIDHasPrefix))
	}
	if i.ScheduledJobIDHasSuffix != nil {
		predicates = append(predicates, scheduledjobrun.ScheduledJobIDHasSuffix(*i.ScheduledJobIDHasSuffix))
	}
	if i.ScheduledJobIDEqualFold != nil {
		predicates = append(predicates, scheduledjobrun.ScheduledJobIDEqualFold(*i.ScheduledJobIDEqualFold))
	}
	if i.ScheduledJobIDContainsFold != nil {
		predicates = append(predicates, scheduledjobrun.ScheduledJobIDContainsFold(*i.ScheduledJobIDContainsFold))
	}
	if i.ExpectedExecutionTime != nil {
		predicates = append(predicates, scheduledjobrun.ExpectedExecutionTimeEQ(*i.ExpectedExecutionTime))
	}
	if i.ExpectedExecutionTimeNEQ != nil {
		predicates = append(predicates, scheduledjobrun.ExpectedExecutionTimeNEQ(*i.ExpectedExecutionTimeNEQ))
	}
	if len(i.ExpectedExecutionTimeIn) > 0 {
		predicates = append(predicates, scheduledjobrun.ExpectedExecutionTimeIn(i.ExpectedExecutionTimeIn...))
	}
	if len(i.ExpectedExecutionTimeNotIn) > 0 {
		predicates = append(predicates, scheduledjobrun.ExpectedExecutionTimeNotIn(i.ExpectedExecutionTimeNotIn...))
	}
	if i.ExpectedExecutionTimeGT != nil {
		predicates = append(predicates, scheduledjobrun.ExpectedExecutionTimeGT(*i.ExpectedExecutionTimeGT))
	}
	if i.ExpectedExecutionTimeGTE != nil {
		predicates = append(predicates, scheduledjobrun.ExpectedExecutionTimeGTE(*i.ExpectedExecutionTimeGTE))
	}
	if i.ExpectedExecutionTimeLT != nil {
		predicates = append(predicates, scheduledjobrun.ExpectedExecutionTimeLT(*i.ExpectedExecutionTimeLT))
	}
	if i.ExpectedExecutionTimeLTE != nil {
		predicates = append(predicates, scheduledjobrun.ExpectedExecutionTimeLTE(*i.ExpectedExecutionTimeLTE))
	}
	if i.Script != nil {
		predicates = append(predicates, scheduledjobrun.ScriptEQ(*i.Script))
	}
	if i.ScriptNEQ != nil {
		predicates = append(predicates, scheduledjobrun.ScriptNEQ(*i.ScriptNEQ))
	}
	if len(i.ScriptIn) > 0 {
		predicates = append(predicates, scheduledjobrun.ScriptIn(i.ScriptIn...))
	}
	if len(i.ScriptNotIn) > 0 {
		predicates = append(predicates, scheduledjobrun.ScriptNotIn(i.ScriptNotIn...))
	}
	if i.ScriptGT != nil {
		predicates = append(predicates, scheduledjobrun.ScriptGT(*i.ScriptGT))
	}
	if i.ScriptGTE != nil {
		predicates = append(predicates, scheduledjobrun.ScriptGTE(*i.ScriptGTE))
	}
	if i.ScriptLT != nil {
		predicates = append(predicates, scheduledjobrun.ScriptLT(*i.ScriptLT))
	}
	if i.ScriptLTE != nil {
		predicates = append(predicates, scheduledjobrun.ScriptLTE(*i.ScriptLTE))
	}
	if i.ScriptContains != nil {
		predicates = append(predicates, scheduledjobrun.ScriptContains(*i.ScriptContains))
	}
	if i.ScriptHasPrefix != nil {
		predicates = append(predicates, scheduledjobrun.ScriptHasPrefix(*i.ScriptHasPrefix))
	}
	if i.ScriptHasSuffix != nil {
		predicates = append(predicates, scheduledjobrun.ScriptHasSuffix(*i.ScriptHasSuffix))
	}
	if i.ScriptEqualFold != nil {
		predicates = append(predicates, scheduledjobrun.ScriptEqualFold(*i.ScriptEqualFold))
	}
	if i.ScriptContainsFold != nil {
		predicates = append(predicates, scheduledjobrun.ScriptContainsFold(*i.ScriptContainsFold))
	}

	if i.HasOwner != nil {
		p := scheduledjobrun.HasOwner()
		if !*i.HasOwner {
			p = scheduledjobrun.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, scheduledjobrun.HasOwnerWith(with...))
	}
	if i.HasScheduledJob != nil {
		p := scheduledjobrun.HasScheduledJob()
		if !*i.HasScheduledJob {
			p = scheduledjobrun.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScheduledJobWith) > 0 {
		with := make([]predicate.ControlScheduledJob, 0, len(i.HasScheduledJobWith))
		for _, w := range i.HasScheduledJobWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasScheduledJobWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, scheduledjobrun.HasScheduledJobWith(with...))
	}
	if i.HasJobRunner != nil {
		p := scheduledjobrun.HasJobRunner()
		if !*i.HasJobRunner {
			p = scheduledjobrun.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobRunnerWith) > 0 {
		with := make([]predicate.JobRunner, 0, len(i.HasJobRunnerWith))
		for _, w := range i.HasJobRunnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobRunnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, scheduledjobrun.HasJobRunnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyScheduledJobRunWhereInput
	case 1:
		return predicates[0], nil
	default:
		return scheduledjobrun.And(predicates...), nil
	}
}

// StandardWhereInput represents a where input for filtering Standard queries.
type StandardWhereInput struct {
	Predicates []predicate.Standard  `json:"-"`
	Not        *StandardWhereInput   `json:"not,omitempty"`
	Or         []*StandardWhereInput `json:"or,omitempty"`
	And        []*StandardWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "revision" field predicates.
	Revision             *string  `json:"revision,omitempty"`
	RevisionNEQ          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGT           *string  `json:"revisionGT,omitempty"`
	RevisionGTE          *string  `json:"revisionGTE,omitempty"`
	RevisionLT           *string  `json:"revisionLT,omitempty"`
	RevisionLTE          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        bool     `json:"revisionIsNil,omitempty"`
	RevisionNotNil       bool     `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "system_owned" field predicates.
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNEQ    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  bool  `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil bool  `json:"systemOwnedNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "short_name" field predicates.
	ShortName             *string  `json:"shortName,omitempty"`
	ShortNameNEQ          *string  `json:"shortNameNEQ,omitempty"`
	ShortNameIn           []string `json:"shortNameIn,omitempty"`
	ShortNameNotIn        []string `json:"shortNameNotIn,omitempty"`
	ShortNameGT           *string  `json:"shortNameGT,omitempty"`
	ShortNameGTE          *string  `json:"shortNameGTE,omitempty"`
	ShortNameLT           *string  `json:"shortNameLT,omitempty"`
	ShortNameLTE          *string  `json:"shortNameLTE,omitempty"`
	ShortNameContains     *string  `json:"shortNameContains,omitempty"`
	ShortNameHasPrefix    *string  `json:"shortNameHasPrefix,omitempty"`
	ShortNameHasSuffix    *string  `json:"shortNameHasSuffix,omitempty"`
	ShortNameIsNil        bool     `json:"shortNameIsNil,omitempty"`
	ShortNameNotNil       bool     `json:"shortNameNotNil,omitempty"`
	ShortNameEqualFold    *string  `json:"shortNameEqualFold,omitempty"`
	ShortNameContainsFold *string  `json:"shortNameContainsFold,omitempty"`

	// "framework" field predicates.
	Framework             *string  `json:"framework,omitempty"`
	FrameworkNEQ          *string  `json:"frameworkNEQ,omitempty"`
	FrameworkIn           []string `json:"frameworkIn,omitempty"`
	FrameworkNotIn        []string `json:"frameworkNotIn,omitempty"`
	FrameworkGT           *string  `json:"frameworkGT,omitempty"`
	FrameworkGTE          *string  `json:"frameworkGTE,omitempty"`
	FrameworkLT           *string  `json:"frameworkLT,omitempty"`
	FrameworkLTE          *string  `json:"frameworkLTE,omitempty"`
	FrameworkContains     *string  `json:"frameworkContains,omitempty"`
	FrameworkHasPrefix    *string  `json:"frameworkHasPrefix,omitempty"`
	FrameworkHasSuffix    *string  `json:"frameworkHasSuffix,omitempty"`
	FrameworkIsNil        bool     `json:"frameworkIsNil,omitempty"`
	FrameworkNotNil       bool     `json:"frameworkNotNil,omitempty"`
	FrameworkEqualFold    *string  `json:"frameworkEqualFold,omitempty"`
	FrameworkContainsFold *string  `json:"frameworkContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "governing_body_logo_url" field predicates.
	GoverningBodyLogoURL             *string  `json:"governingBodyLogoURL,omitempty"`
	GoverningBodyLogoURLNEQ          *string  `json:"governingBodyLogoURLNEQ,omitempty"`
	GoverningBodyLogoURLIn           []string `json:"governingBodyLogoURLIn,omitempty"`
	GoverningBodyLogoURLNotIn        []string `json:"governingBodyLogoURLNotIn,omitempty"`
	GoverningBodyLogoURLGT           *string  `json:"governingBodyLogoURLGT,omitempty"`
	GoverningBodyLogoURLGTE          *string  `json:"governingBodyLogoURLGTE,omitempty"`
	GoverningBodyLogoURLLT           *string  `json:"governingBodyLogoURLLT,omitempty"`
	GoverningBodyLogoURLLTE          *string  `json:"governingBodyLogoURLLTE,omitempty"`
	GoverningBodyLogoURLContains     *string  `json:"governingBodyLogoURLContains,omitempty"`
	GoverningBodyLogoURLHasPrefix    *string  `json:"governingBodyLogoURLHasPrefix,omitempty"`
	GoverningBodyLogoURLHasSuffix    *string  `json:"governingBodyLogoURLHasSuffix,omitempty"`
	GoverningBodyLogoURLIsNil        bool     `json:"governingBodyLogoURLIsNil,omitempty"`
	GoverningBodyLogoURLNotNil       bool     `json:"governingBodyLogoURLNotNil,omitempty"`
	GoverningBodyLogoURLEqualFold    *string  `json:"governingBodyLogoURLEqualFold,omitempty"`
	GoverningBodyLogoURLContainsFold *string  `json:"governingBodyLogoURLContainsFold,omitempty"`

	// "governing_body" field predicates.
	GoverningBody             *string  `json:"governingBody,omitempty"`
	GoverningBodyNEQ          *string  `json:"governingBodyNEQ,omitempty"`
	GoverningBodyIn           []string `json:"governingBodyIn,omitempty"`
	GoverningBodyNotIn        []string `json:"governingBodyNotIn,omitempty"`
	GoverningBodyGT           *string  `json:"governingBodyGT,omitempty"`
	GoverningBodyGTE          *string  `json:"governingBodyGTE,omitempty"`
	GoverningBodyLT           *string  `json:"governingBodyLT,omitempty"`
	GoverningBodyLTE          *string  `json:"governingBodyLTE,omitempty"`
	GoverningBodyContains     *string  `json:"governingBodyContains,omitempty"`
	GoverningBodyHasPrefix    *string  `json:"governingBodyHasPrefix,omitempty"`
	GoverningBodyHasSuffix    *string  `json:"governingBodyHasSuffix,omitempty"`
	GoverningBodyIsNil        bool     `json:"governingBodyIsNil,omitempty"`
	GoverningBodyNotNil       bool     `json:"governingBodyNotNil,omitempty"`
	GoverningBodyEqualFold    *string  `json:"governingBodyEqualFold,omitempty"`
	GoverningBodyContainsFold *string  `json:"governingBodyContainsFold,omitempty"`

	// "link" field predicates.
	Link             *string  `json:"link,omitempty"`
	LinkNEQ          *string  `json:"linkNEQ,omitempty"`
	LinkIn           []string `json:"linkIn,omitempty"`
	LinkNotIn        []string `json:"linkNotIn,omitempty"`
	LinkGT           *string  `json:"linkGT,omitempty"`
	LinkGTE          *string  `json:"linkGTE,omitempty"`
	LinkLT           *string  `json:"linkLT,omitempty"`
	LinkLTE          *string  `json:"linkLTE,omitempty"`
	LinkContains     *string  `json:"linkContains,omitempty"`
	LinkHasPrefix    *string  `json:"linkHasPrefix,omitempty"`
	LinkHasSuffix    *string  `json:"linkHasSuffix,omitempty"`
	LinkIsNil        bool     `json:"linkIsNil,omitempty"`
	LinkNotNil       bool     `json:"linkNotNil,omitempty"`
	LinkEqualFold    *string  `json:"linkEqualFold,omitempty"`
	LinkContainsFold *string  `json:"linkContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.StandardStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.StandardStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.StandardStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.StandardStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                   `json:"statusIsNil,omitempty"`
	StatusNotNil bool                   `json:"statusNotNil,omitempty"`

	// "is_public" field predicates.
	IsPublic       *bool `json:"isPublic,omitempty"`
	IsPublicNEQ    *bool `json:"isPublicNEQ,omitempty"`
	IsPublicIsNil  bool  `json:"isPublicIsNil,omitempty"`
	IsPublicNotNil bool  `json:"isPublicNotNil,omitempty"`

	// "free_to_use" field predicates.
	FreeToUse       *bool `json:"freeToUse,omitempty"`
	FreeToUseNEQ    *bool `json:"freeToUseNEQ,omitempty"`
	FreeToUseIsNil  bool  `json:"freeToUseIsNil,omitempty"`
	FreeToUseNotNil bool  `json:"freeToUseNotNil,omitempty"`

	// "standard_type" field predicates.
	StandardType             *string  `json:"standardType,omitempty"`
	StandardTypeNEQ          *string  `json:"standardTypeNEQ,omitempty"`
	StandardTypeIn           []string `json:"standardTypeIn,omitempty"`
	StandardTypeNotIn        []string `json:"standardTypeNotIn,omitempty"`
	StandardTypeGT           *string  `json:"standardTypeGT,omitempty"`
	StandardTypeGTE          *string  `json:"standardTypeGTE,omitempty"`
	StandardTypeLT           *string  `json:"standardTypeLT,omitempty"`
	StandardTypeLTE          *string  `json:"standardTypeLTE,omitempty"`
	StandardTypeContains     *string  `json:"standardTypeContains,omitempty"`
	StandardTypeHasPrefix    *string  `json:"standardTypeHasPrefix,omitempty"`
	StandardTypeHasSuffix    *string  `json:"standardTypeHasSuffix,omitempty"`
	StandardTypeIsNil        bool     `json:"standardTypeIsNil,omitempty"`
	StandardTypeNotNil       bool     `json:"standardTypeNotNil,omitempty"`
	StandardTypeEqualFold    *string  `json:"standardTypeEqualFold,omitempty"`
	StandardTypeContainsFold *string  `json:"standardTypeContainsFold,omitempty"`

	// "version" field predicates.
	Version             *string  `json:"version,omitempty"`
	VersionNEQ          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGT           *string  `json:"versionGT,omitempty"`
	VersionGTE          *string  `json:"versionGTE,omitempty"`
	VersionLT           *string  `json:"versionLT,omitempty"`
	VersionLTE          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        bool     `json:"versionIsNil,omitempty"`
	VersionNotNil       bool     `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "controls" edge predicates.
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *StandardWhereInput) AddPredicates(predicates ...predicate.Standard) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the StandardWhereInput filter on the StandardQuery builder.
func (i *StandardWhereInput) Filter(q *StandardQuery) (*StandardQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyStandardWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyStandardWhereInput is returned in case the StandardWhereInput is empty.
var ErrEmptyStandardWhereInput = errors.New("generated: empty predicate StandardWhereInput")

// P returns a predicate for filtering standards.
// An error is returned if the input is empty or invalid.
func (i *StandardWhereInput) P() (predicate.Standard, error) {
	var predicates []predicate.Standard
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, standard.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Standard, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, standard.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Standard, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, standard.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, standard.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, standard.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, standard.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, standard.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, standard.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, standard.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, standard.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, standard.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, standard.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, standard.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, standard.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, standard.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, standard.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, standard.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, standard.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, standard.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, standard.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, standard.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, standard.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, standard.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, standard.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, standard.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, standard.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, standard.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, standard.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, standard.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, standard.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, standard.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, standard.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, standard.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, standard.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, standard.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, standard.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, standard.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, standard.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, standard.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, standard.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, standard.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, standard.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, standard.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, standard.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, standard.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, standard.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, standard.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, standard.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, standard.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, standard.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, standard.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, standard.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, standard.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, standard.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, standard.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, standard.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, standard.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, standard.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, standard.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, standard.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, standard.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, standard.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, standard.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Revision != nil {
		predicates = append(predicates, standard.RevisionEQ(*i.Revision))
	}
	if i.RevisionNEQ != nil {
		predicates = append(predicates, standard.RevisionNEQ(*i.RevisionNEQ))
	}
	if len(i.RevisionIn) > 0 {
		predicates = append(predicates, standard.RevisionIn(i.RevisionIn...))
	}
	if len(i.RevisionNotIn) > 0 {
		predicates = append(predicates, standard.RevisionNotIn(i.RevisionNotIn...))
	}
	if i.RevisionGT != nil {
		predicates = append(predicates, standard.RevisionGT(*i.RevisionGT))
	}
	if i.RevisionGTE != nil {
		predicates = append(predicates, standard.RevisionGTE(*i.RevisionGTE))
	}
	if i.RevisionLT != nil {
		predicates = append(predicates, standard.RevisionLT(*i.RevisionLT))
	}
	if i.RevisionLTE != nil {
		predicates = append(predicates, standard.RevisionLTE(*i.RevisionLTE))
	}
	if i.RevisionContains != nil {
		predicates = append(predicates, standard.RevisionContains(*i.RevisionContains))
	}
	if i.RevisionHasPrefix != nil {
		predicates = append(predicates, standard.RevisionHasPrefix(*i.RevisionHasPrefix))
	}
	if i.RevisionHasSuffix != nil {
		predicates = append(predicates, standard.RevisionHasSuffix(*i.RevisionHasSuffix))
	}
	if i.RevisionIsNil {
		predicates = append(predicates, standard.RevisionIsNil())
	}
	if i.RevisionNotNil {
		predicates = append(predicates, standard.RevisionNotNil())
	}
	if i.RevisionEqualFold != nil {
		predicates = append(predicates, standard.RevisionEqualFold(*i.RevisionEqualFold))
	}
	if i.RevisionContainsFold != nil {
		predicates = append(predicates, standard.RevisionContainsFold(*i.RevisionContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, standard.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, standard.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, standard.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, standard.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, standard.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, standard.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, standard.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, standard.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, standard.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, standard.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, standard.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, standard.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, standard.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, standard.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, standard.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.SystemOwned != nil {
		predicates = append(predicates, standard.SystemOwnedEQ(*i.SystemOwned))
	}
	if i.SystemOwnedNEQ != nil {
		predicates = append(predicates, standard.SystemOwnedNEQ(*i.SystemOwnedNEQ))
	}
	if i.SystemOwnedIsNil {
		predicates = append(predicates, standard.SystemOwnedIsNil())
	}
	if i.SystemOwnedNotNil {
		predicates = append(predicates, standard.SystemOwnedNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, standard.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, standard.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, standard.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, standard.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, standard.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, standard.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, standard.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, standard.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, standard.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, standard.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, standard.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, standard.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, standard.NameContainsFold(*i.NameContainsFold))
	}
	if i.ShortName != nil {
		predicates = append(predicates, standard.ShortNameEQ(*i.ShortName))
	}
	if i.ShortNameNEQ != nil {
		predicates = append(predicates, standard.ShortNameNEQ(*i.ShortNameNEQ))
	}
	if len(i.ShortNameIn) > 0 {
		predicates = append(predicates, standard.ShortNameIn(i.ShortNameIn...))
	}
	if len(i.ShortNameNotIn) > 0 {
		predicates = append(predicates, standard.ShortNameNotIn(i.ShortNameNotIn...))
	}
	if i.ShortNameGT != nil {
		predicates = append(predicates, standard.ShortNameGT(*i.ShortNameGT))
	}
	if i.ShortNameGTE != nil {
		predicates = append(predicates, standard.ShortNameGTE(*i.ShortNameGTE))
	}
	if i.ShortNameLT != nil {
		predicates = append(predicates, standard.ShortNameLT(*i.ShortNameLT))
	}
	if i.ShortNameLTE != nil {
		predicates = append(predicates, standard.ShortNameLTE(*i.ShortNameLTE))
	}
	if i.ShortNameContains != nil {
		predicates = append(predicates, standard.ShortNameContains(*i.ShortNameContains))
	}
	if i.ShortNameHasPrefix != nil {
		predicates = append(predicates, standard.ShortNameHasPrefix(*i.ShortNameHasPrefix))
	}
	if i.ShortNameHasSuffix != nil {
		predicates = append(predicates, standard.ShortNameHasSuffix(*i.ShortNameHasSuffix))
	}
	if i.ShortNameIsNil {
		predicates = append(predicates, standard.ShortNameIsNil())
	}
	if i.ShortNameNotNil {
		predicates = append(predicates, standard.ShortNameNotNil())
	}
	if i.ShortNameEqualFold != nil {
		predicates = append(predicates, standard.ShortNameEqualFold(*i.ShortNameEqualFold))
	}
	if i.ShortNameContainsFold != nil {
		predicates = append(predicates, standard.ShortNameContainsFold(*i.ShortNameContainsFold))
	}
	if i.Framework != nil {
		predicates = append(predicates, standard.FrameworkEQ(*i.Framework))
	}
	if i.FrameworkNEQ != nil {
		predicates = append(predicates, standard.FrameworkNEQ(*i.FrameworkNEQ))
	}
	if len(i.FrameworkIn) > 0 {
		predicates = append(predicates, standard.FrameworkIn(i.FrameworkIn...))
	}
	if len(i.FrameworkNotIn) > 0 {
		predicates = append(predicates, standard.FrameworkNotIn(i.FrameworkNotIn...))
	}
	if i.FrameworkGT != nil {
		predicates = append(predicates, standard.FrameworkGT(*i.FrameworkGT))
	}
	if i.FrameworkGTE != nil {
		predicates = append(predicates, standard.FrameworkGTE(*i.FrameworkGTE))
	}
	if i.FrameworkLT != nil {
		predicates = append(predicates, standard.FrameworkLT(*i.FrameworkLT))
	}
	if i.FrameworkLTE != nil {
		predicates = append(predicates, standard.FrameworkLTE(*i.FrameworkLTE))
	}
	if i.FrameworkContains != nil {
		predicates = append(predicates, standard.FrameworkContains(*i.FrameworkContains))
	}
	if i.FrameworkHasPrefix != nil {
		predicates = append(predicates, standard.FrameworkHasPrefix(*i.FrameworkHasPrefix))
	}
	if i.FrameworkHasSuffix != nil {
		predicates = append(predicates, standard.FrameworkHasSuffix(*i.FrameworkHasSuffix))
	}
	if i.FrameworkIsNil {
		predicates = append(predicates, standard.FrameworkIsNil())
	}
	if i.FrameworkNotNil {
		predicates = append(predicates, standard.FrameworkNotNil())
	}
	if i.FrameworkEqualFold != nil {
		predicates = append(predicates, standard.FrameworkEqualFold(*i.FrameworkEqualFold))
	}
	if i.FrameworkContainsFold != nil {
		predicates = append(predicates, standard.FrameworkContainsFold(*i.FrameworkContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, standard.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, standard.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, standard.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, standard.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, standard.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, standard.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, standard.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, standard.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, standard.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, standard.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, standard.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, standard.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, standard.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, standard.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, standard.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.GoverningBodyLogoURL != nil {
		predicates = append(predicates, standard.GoverningBodyLogoURLEQ(*i.GoverningBodyLogoURL))
	}
	if i.GoverningBodyLogoURLNEQ != nil {
		predicates = append(predicates, standard.GoverningBodyLogoURLNEQ(*i.GoverningBodyLogoURLNEQ))
	}
	if len(i.GoverningBodyLogoURLIn) > 0 {
		predicates = append(predicates, standard.GoverningBodyLogoURLIn(i.GoverningBodyLogoURLIn...))
	}
	if len(i.GoverningBodyLogoURLNotIn) > 0 {
		predicates = append(predicates, standard.GoverningBodyLogoURLNotIn(i.GoverningBodyLogoURLNotIn...))
	}
	if i.GoverningBodyLogoURLGT != nil {
		predicates = append(predicates, standard.GoverningBodyLogoURLGT(*i.GoverningBodyLogoURLGT))
	}
	if i.GoverningBodyLogoURLGTE != nil {
		predicates = append(predicates, standard.GoverningBodyLogoURLGTE(*i.GoverningBodyLogoURLGTE))
	}
	if i.GoverningBodyLogoURLLT != nil {
		predicates = append(predicates, standard.GoverningBodyLogoURLLT(*i.GoverningBodyLogoURLLT))
	}
	if i.GoverningBodyLogoURLLTE != nil {
		predicates = append(predicates, standard.GoverningBodyLogoURLLTE(*i.GoverningBodyLogoURLLTE))
	}
	if i.GoverningBodyLogoURLContains != nil {
		predicates = append(predicates, standard.GoverningBodyLogoURLContains(*i.GoverningBodyLogoURLContains))
	}
	if i.GoverningBodyLogoURLHasPrefix != nil {
		predicates = append(predicates, standard.GoverningBodyLogoURLHasPrefix(*i.GoverningBodyLogoURLHasPrefix))
	}
	if i.GoverningBodyLogoURLHasSuffix != nil {
		predicates = append(predicates, standard.GoverningBodyLogoURLHasSuffix(*i.GoverningBodyLogoURLHasSuffix))
	}
	if i.GoverningBodyLogoURLIsNil {
		predicates = append(predicates, standard.GoverningBodyLogoURLIsNil())
	}
	if i.GoverningBodyLogoURLNotNil {
		predicates = append(predicates, standard.GoverningBodyLogoURLNotNil())
	}
	if i.GoverningBodyLogoURLEqualFold != nil {
		predicates = append(predicates, standard.GoverningBodyLogoURLEqualFold(*i.GoverningBodyLogoURLEqualFold))
	}
	if i.GoverningBodyLogoURLContainsFold != nil {
		predicates = append(predicates, standard.GoverningBodyLogoURLContainsFold(*i.GoverningBodyLogoURLContainsFold))
	}
	if i.GoverningBody != nil {
		predicates = append(predicates, standard.GoverningBodyEQ(*i.GoverningBody))
	}
	if i.GoverningBodyNEQ != nil {
		predicates = append(predicates, standard.GoverningBodyNEQ(*i.GoverningBodyNEQ))
	}
	if len(i.GoverningBodyIn) > 0 {
		predicates = append(predicates, standard.GoverningBodyIn(i.GoverningBodyIn...))
	}
	if len(i.GoverningBodyNotIn) > 0 {
		predicates = append(predicates, standard.GoverningBodyNotIn(i.GoverningBodyNotIn...))
	}
	if i.GoverningBodyGT != nil {
		predicates = append(predicates, standard.GoverningBodyGT(*i.GoverningBodyGT))
	}
	if i.GoverningBodyGTE != nil {
		predicates = append(predicates, standard.GoverningBodyGTE(*i.GoverningBodyGTE))
	}
	if i.GoverningBodyLT != nil {
		predicates = append(predicates, standard.GoverningBodyLT(*i.GoverningBodyLT))
	}
	if i.GoverningBodyLTE != nil {
		predicates = append(predicates, standard.GoverningBodyLTE(*i.GoverningBodyLTE))
	}
	if i.GoverningBodyContains != nil {
		predicates = append(predicates, standard.GoverningBodyContains(*i.GoverningBodyContains))
	}
	if i.GoverningBodyHasPrefix != nil {
		predicates = append(predicates, standard.GoverningBodyHasPrefix(*i.GoverningBodyHasPrefix))
	}
	if i.GoverningBodyHasSuffix != nil {
		predicates = append(predicates, standard.GoverningBodyHasSuffix(*i.GoverningBodyHasSuffix))
	}
	if i.GoverningBodyIsNil {
		predicates = append(predicates, standard.GoverningBodyIsNil())
	}
	if i.GoverningBodyNotNil {
		predicates = append(predicates, standard.GoverningBodyNotNil())
	}
	if i.GoverningBodyEqualFold != nil {
		predicates = append(predicates, standard.GoverningBodyEqualFold(*i.GoverningBodyEqualFold))
	}
	if i.GoverningBodyContainsFold != nil {
		predicates = append(predicates, standard.GoverningBodyContainsFold(*i.GoverningBodyContainsFold))
	}
	if i.Link != nil {
		predicates = append(predicates, standard.LinkEQ(*i.Link))
	}
	if i.LinkNEQ != nil {
		predicates = append(predicates, standard.LinkNEQ(*i.LinkNEQ))
	}
	if len(i.LinkIn) > 0 {
		predicates = append(predicates, standard.LinkIn(i.LinkIn...))
	}
	if len(i.LinkNotIn) > 0 {
		predicates = append(predicates, standard.LinkNotIn(i.LinkNotIn...))
	}
	if i.LinkGT != nil {
		predicates = append(predicates, standard.LinkGT(*i.LinkGT))
	}
	if i.LinkGTE != nil {
		predicates = append(predicates, standard.LinkGTE(*i.LinkGTE))
	}
	if i.LinkLT != nil {
		predicates = append(predicates, standard.LinkLT(*i.LinkLT))
	}
	if i.LinkLTE != nil {
		predicates = append(predicates, standard.LinkLTE(*i.LinkLTE))
	}
	if i.LinkContains != nil {
		predicates = append(predicates, standard.LinkContains(*i.LinkContains))
	}
	if i.LinkHasPrefix != nil {
		predicates = append(predicates, standard.LinkHasPrefix(*i.LinkHasPrefix))
	}
	if i.LinkHasSuffix != nil {
		predicates = append(predicates, standard.LinkHasSuffix(*i.LinkHasSuffix))
	}
	if i.LinkIsNil {
		predicates = append(predicates, standard.LinkIsNil())
	}
	if i.LinkNotNil {
		predicates = append(predicates, standard.LinkNotNil())
	}
	if i.LinkEqualFold != nil {
		predicates = append(predicates, standard.LinkEqualFold(*i.LinkEqualFold))
	}
	if i.LinkContainsFold != nil {
		predicates = append(predicates, standard.LinkContainsFold(*i.LinkContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, standard.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, standard.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, standard.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, standard.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, standard.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, standard.StatusNotNil())
	}
	if i.IsPublic != nil {
		predicates = append(predicates, standard.IsPublicEQ(*i.IsPublic))
	}
	if i.IsPublicNEQ != nil {
		predicates = append(predicates, standard.IsPublicNEQ(*i.IsPublicNEQ))
	}
	if i.IsPublicIsNil {
		predicates = append(predicates, standard.IsPublicIsNil())
	}
	if i.IsPublicNotNil {
		predicates = append(predicates, standard.IsPublicNotNil())
	}
	if i.FreeToUse != nil {
		predicates = append(predicates, standard.FreeToUseEQ(*i.FreeToUse))
	}
	if i.FreeToUseNEQ != nil {
		predicates = append(predicates, standard.FreeToUseNEQ(*i.FreeToUseNEQ))
	}
	if i.FreeToUseIsNil {
		predicates = append(predicates, standard.FreeToUseIsNil())
	}
	if i.FreeToUseNotNil {
		predicates = append(predicates, standard.FreeToUseNotNil())
	}
	if i.StandardType != nil {
		predicates = append(predicates, standard.StandardTypeEQ(*i.StandardType))
	}
	if i.StandardTypeNEQ != nil {
		predicates = append(predicates, standard.StandardTypeNEQ(*i.StandardTypeNEQ))
	}
	if len(i.StandardTypeIn) > 0 {
		predicates = append(predicates, standard.StandardTypeIn(i.StandardTypeIn...))
	}
	if len(i.StandardTypeNotIn) > 0 {
		predicates = append(predicates, standard.StandardTypeNotIn(i.StandardTypeNotIn...))
	}
	if i.StandardTypeGT != nil {
		predicates = append(predicates, standard.StandardTypeGT(*i.StandardTypeGT))
	}
	if i.StandardTypeGTE != nil {
		predicates = append(predicates, standard.StandardTypeGTE(*i.StandardTypeGTE))
	}
	if i.StandardTypeLT != nil {
		predicates = append(predicates, standard.StandardTypeLT(*i.StandardTypeLT))
	}
	if i.StandardTypeLTE != nil {
		predicates = append(predicates, standard.StandardTypeLTE(*i.StandardTypeLTE))
	}
	if i.StandardTypeContains != nil {
		predicates = append(predicates, standard.StandardTypeContains(*i.StandardTypeContains))
	}
	if i.StandardTypeHasPrefix != nil {
		predicates = append(predicates, standard.StandardTypeHasPrefix(*i.StandardTypeHasPrefix))
	}
	if i.StandardTypeHasSuffix != nil {
		predicates = append(predicates, standard.StandardTypeHasSuffix(*i.StandardTypeHasSuffix))
	}
	if i.StandardTypeIsNil {
		predicates = append(predicates, standard.StandardTypeIsNil())
	}
	if i.StandardTypeNotNil {
		predicates = append(predicates, standard.StandardTypeNotNil())
	}
	if i.StandardTypeEqualFold != nil {
		predicates = append(predicates, standard.StandardTypeEqualFold(*i.StandardTypeEqualFold))
	}
	if i.StandardTypeContainsFold != nil {
		predicates = append(predicates, standard.StandardTypeContainsFold(*i.StandardTypeContainsFold))
	}
	if i.Version != nil {
		predicates = append(predicates, standard.VersionEQ(*i.Version))
	}
	if i.VersionNEQ != nil {
		predicates = append(predicates, standard.VersionNEQ(*i.VersionNEQ))
	}
	if len(i.VersionIn) > 0 {
		predicates = append(predicates, standard.VersionIn(i.VersionIn...))
	}
	if len(i.VersionNotIn) > 0 {
		predicates = append(predicates, standard.VersionNotIn(i.VersionNotIn...))
	}
	if i.VersionGT != nil {
		predicates = append(predicates, standard.VersionGT(*i.VersionGT))
	}
	if i.VersionGTE != nil {
		predicates = append(predicates, standard.VersionGTE(*i.VersionGTE))
	}
	if i.VersionLT != nil {
		predicates = append(predicates, standard.VersionLT(*i.VersionLT))
	}
	if i.VersionLTE != nil {
		predicates = append(predicates, standard.VersionLTE(*i.VersionLTE))
	}
	if i.VersionContains != nil {
		predicates = append(predicates, standard.VersionContains(*i.VersionContains))
	}
	if i.VersionHasPrefix != nil {
		predicates = append(predicates, standard.VersionHasPrefix(*i.VersionHasPrefix))
	}
	if i.VersionHasSuffix != nil {
		predicates = append(predicates, standard.VersionHasSuffix(*i.VersionHasSuffix))
	}
	if i.VersionIsNil {
		predicates = append(predicates, standard.VersionIsNil())
	}
	if i.VersionNotNil {
		predicates = append(predicates, standard.VersionNotNil())
	}
	if i.VersionEqualFold != nil {
		predicates = append(predicates, standard.VersionEqualFold(*i.VersionEqualFold))
	}
	if i.VersionContainsFold != nil {
		predicates = append(predicates, standard.VersionContainsFold(*i.VersionContainsFold))
	}

	if i.HasOwner != nil {
		p := standard.HasOwner()
		if !*i.HasOwner {
			p = standard.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, standard.HasOwnerWith(with...))
	}
	if i.HasControls != nil {
		p := standard.HasControls()
		if !*i.HasControls {
			p = standard.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasControlsWith))
		for _, w := range i.HasControlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, standard.HasControlsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyStandardWhereInput
	case 1:
		return predicates[0], nil
	default:
		return standard.And(predicates...), nil
	}
}

// StandardHistoryWhereInput represents a where input for filtering StandardHistory queries.
type StandardHistoryWhereInput struct {
	Predicates []predicate.StandardHistory  `json:"-"`
	Not        *StandardHistoryWhereInput   `json:"not,omitempty"`
	Or         []*StandardHistoryWhereInput `json:"or,omitempty"`
	And        []*StandardHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "revision" field predicates.
	Revision             *string  `json:"revision,omitempty"`
	RevisionNEQ          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGT           *string  `json:"revisionGT,omitempty"`
	RevisionGTE          *string  `json:"revisionGTE,omitempty"`
	RevisionLT           *string  `json:"revisionLT,omitempty"`
	RevisionLTE          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        bool     `json:"revisionIsNil,omitempty"`
	RevisionNotNil       bool     `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "system_owned" field predicates.
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNEQ    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  bool  `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil bool  `json:"systemOwnedNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "short_name" field predicates.
	ShortName             *string  `json:"shortName,omitempty"`
	ShortNameNEQ          *string  `json:"shortNameNEQ,omitempty"`
	ShortNameIn           []string `json:"shortNameIn,omitempty"`
	ShortNameNotIn        []string `json:"shortNameNotIn,omitempty"`
	ShortNameGT           *string  `json:"shortNameGT,omitempty"`
	ShortNameGTE          *string  `json:"shortNameGTE,omitempty"`
	ShortNameLT           *string  `json:"shortNameLT,omitempty"`
	ShortNameLTE          *string  `json:"shortNameLTE,omitempty"`
	ShortNameContains     *string  `json:"shortNameContains,omitempty"`
	ShortNameHasPrefix    *string  `json:"shortNameHasPrefix,omitempty"`
	ShortNameHasSuffix    *string  `json:"shortNameHasSuffix,omitempty"`
	ShortNameIsNil        bool     `json:"shortNameIsNil,omitempty"`
	ShortNameNotNil       bool     `json:"shortNameNotNil,omitempty"`
	ShortNameEqualFold    *string  `json:"shortNameEqualFold,omitempty"`
	ShortNameContainsFold *string  `json:"shortNameContainsFold,omitempty"`

	// "framework" field predicates.
	Framework             *string  `json:"framework,omitempty"`
	FrameworkNEQ          *string  `json:"frameworkNEQ,omitempty"`
	FrameworkIn           []string `json:"frameworkIn,omitempty"`
	FrameworkNotIn        []string `json:"frameworkNotIn,omitempty"`
	FrameworkGT           *string  `json:"frameworkGT,omitempty"`
	FrameworkGTE          *string  `json:"frameworkGTE,omitempty"`
	FrameworkLT           *string  `json:"frameworkLT,omitempty"`
	FrameworkLTE          *string  `json:"frameworkLTE,omitempty"`
	FrameworkContains     *string  `json:"frameworkContains,omitempty"`
	FrameworkHasPrefix    *string  `json:"frameworkHasPrefix,omitempty"`
	FrameworkHasSuffix    *string  `json:"frameworkHasSuffix,omitempty"`
	FrameworkIsNil        bool     `json:"frameworkIsNil,omitempty"`
	FrameworkNotNil       bool     `json:"frameworkNotNil,omitempty"`
	FrameworkEqualFold    *string  `json:"frameworkEqualFold,omitempty"`
	FrameworkContainsFold *string  `json:"frameworkContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "governing_body_logo_url" field predicates.
	GoverningBodyLogoURL             *string  `json:"governingBodyLogoURL,omitempty"`
	GoverningBodyLogoURLNEQ          *string  `json:"governingBodyLogoURLNEQ,omitempty"`
	GoverningBodyLogoURLIn           []string `json:"governingBodyLogoURLIn,omitempty"`
	GoverningBodyLogoURLNotIn        []string `json:"governingBodyLogoURLNotIn,omitempty"`
	GoverningBodyLogoURLGT           *string  `json:"governingBodyLogoURLGT,omitempty"`
	GoverningBodyLogoURLGTE          *string  `json:"governingBodyLogoURLGTE,omitempty"`
	GoverningBodyLogoURLLT           *string  `json:"governingBodyLogoURLLT,omitempty"`
	GoverningBodyLogoURLLTE          *string  `json:"governingBodyLogoURLLTE,omitempty"`
	GoverningBodyLogoURLContains     *string  `json:"governingBodyLogoURLContains,omitempty"`
	GoverningBodyLogoURLHasPrefix    *string  `json:"governingBodyLogoURLHasPrefix,omitempty"`
	GoverningBodyLogoURLHasSuffix    *string  `json:"governingBodyLogoURLHasSuffix,omitempty"`
	GoverningBodyLogoURLIsNil        bool     `json:"governingBodyLogoURLIsNil,omitempty"`
	GoverningBodyLogoURLNotNil       bool     `json:"governingBodyLogoURLNotNil,omitempty"`
	GoverningBodyLogoURLEqualFold    *string  `json:"governingBodyLogoURLEqualFold,omitempty"`
	GoverningBodyLogoURLContainsFold *string  `json:"governingBodyLogoURLContainsFold,omitempty"`

	// "governing_body" field predicates.
	GoverningBody             *string  `json:"governingBody,omitempty"`
	GoverningBodyNEQ          *string  `json:"governingBodyNEQ,omitempty"`
	GoverningBodyIn           []string `json:"governingBodyIn,omitempty"`
	GoverningBodyNotIn        []string `json:"governingBodyNotIn,omitempty"`
	GoverningBodyGT           *string  `json:"governingBodyGT,omitempty"`
	GoverningBodyGTE          *string  `json:"governingBodyGTE,omitempty"`
	GoverningBodyLT           *string  `json:"governingBodyLT,omitempty"`
	GoverningBodyLTE          *string  `json:"governingBodyLTE,omitempty"`
	GoverningBodyContains     *string  `json:"governingBodyContains,omitempty"`
	GoverningBodyHasPrefix    *string  `json:"governingBodyHasPrefix,omitempty"`
	GoverningBodyHasSuffix    *string  `json:"governingBodyHasSuffix,omitempty"`
	GoverningBodyIsNil        bool     `json:"governingBodyIsNil,omitempty"`
	GoverningBodyNotNil       bool     `json:"governingBodyNotNil,omitempty"`
	GoverningBodyEqualFold    *string  `json:"governingBodyEqualFold,omitempty"`
	GoverningBodyContainsFold *string  `json:"governingBodyContainsFold,omitempty"`

	// "link" field predicates.
	Link             *string  `json:"link,omitempty"`
	LinkNEQ          *string  `json:"linkNEQ,omitempty"`
	LinkIn           []string `json:"linkIn,omitempty"`
	LinkNotIn        []string `json:"linkNotIn,omitempty"`
	LinkGT           *string  `json:"linkGT,omitempty"`
	LinkGTE          *string  `json:"linkGTE,omitempty"`
	LinkLT           *string  `json:"linkLT,omitempty"`
	LinkLTE          *string  `json:"linkLTE,omitempty"`
	LinkContains     *string  `json:"linkContains,omitempty"`
	LinkHasPrefix    *string  `json:"linkHasPrefix,omitempty"`
	LinkHasSuffix    *string  `json:"linkHasSuffix,omitempty"`
	LinkIsNil        bool     `json:"linkIsNil,omitempty"`
	LinkNotNil       bool     `json:"linkNotNil,omitempty"`
	LinkEqualFold    *string  `json:"linkEqualFold,omitempty"`
	LinkContainsFold *string  `json:"linkContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.StandardStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.StandardStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.StandardStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.StandardStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                   `json:"statusIsNil,omitempty"`
	StatusNotNil bool                   `json:"statusNotNil,omitempty"`

	// "is_public" field predicates.
	IsPublic       *bool `json:"isPublic,omitempty"`
	IsPublicNEQ    *bool `json:"isPublicNEQ,omitempty"`
	IsPublicIsNil  bool  `json:"isPublicIsNil,omitempty"`
	IsPublicNotNil bool  `json:"isPublicNotNil,omitempty"`

	// "free_to_use" field predicates.
	FreeToUse       *bool `json:"freeToUse,omitempty"`
	FreeToUseNEQ    *bool `json:"freeToUseNEQ,omitempty"`
	FreeToUseIsNil  bool  `json:"freeToUseIsNil,omitempty"`
	FreeToUseNotNil bool  `json:"freeToUseNotNil,omitempty"`

	// "standard_type" field predicates.
	StandardType             *string  `json:"standardType,omitempty"`
	StandardTypeNEQ          *string  `json:"standardTypeNEQ,omitempty"`
	StandardTypeIn           []string `json:"standardTypeIn,omitempty"`
	StandardTypeNotIn        []string `json:"standardTypeNotIn,omitempty"`
	StandardTypeGT           *string  `json:"standardTypeGT,omitempty"`
	StandardTypeGTE          *string  `json:"standardTypeGTE,omitempty"`
	StandardTypeLT           *string  `json:"standardTypeLT,omitempty"`
	StandardTypeLTE          *string  `json:"standardTypeLTE,omitempty"`
	StandardTypeContains     *string  `json:"standardTypeContains,omitempty"`
	StandardTypeHasPrefix    *string  `json:"standardTypeHasPrefix,omitempty"`
	StandardTypeHasSuffix    *string  `json:"standardTypeHasSuffix,omitempty"`
	StandardTypeIsNil        bool     `json:"standardTypeIsNil,omitempty"`
	StandardTypeNotNil       bool     `json:"standardTypeNotNil,omitempty"`
	StandardTypeEqualFold    *string  `json:"standardTypeEqualFold,omitempty"`
	StandardTypeContainsFold *string  `json:"standardTypeContainsFold,omitempty"`

	// "version" field predicates.
	Version             *string  `json:"version,omitempty"`
	VersionNEQ          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGT           *string  `json:"versionGT,omitempty"`
	VersionGTE          *string  `json:"versionGTE,omitempty"`
	VersionLT           *string  `json:"versionLT,omitempty"`
	VersionLTE          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        bool     `json:"versionIsNil,omitempty"`
	VersionNotNil       bool     `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *StandardHistoryWhereInput) AddPredicates(predicates ...predicate.StandardHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the StandardHistoryWhereInput filter on the StandardHistoryQuery builder.
func (i *StandardHistoryWhereInput) Filter(q *StandardHistoryQuery) (*StandardHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyStandardHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyStandardHistoryWhereInput is returned in case the StandardHistoryWhereInput is empty.
var ErrEmptyStandardHistoryWhereInput = errors.New("generated: empty predicate StandardHistoryWhereInput")

// P returns a predicate for filtering standardhistories.
// An error is returned if the input is empty or invalid.
func (i *StandardHistoryWhereInput) P() (predicate.StandardHistory, error) {
	var predicates []predicate.StandardHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, standardhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.StandardHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, standardhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.StandardHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, standardhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, standardhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, standardhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, standardhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, standardhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, standardhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, standardhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, standardhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, standardhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, standardhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, standardhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, standardhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, standardhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, standardhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, standardhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, standardhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, standardhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, standardhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, standardhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, standardhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, standardhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, standardhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, standardhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, standardhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, standardhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, standardhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, standardhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, standardhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, standardhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, standardhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, standardhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, standardhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, standardhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, standardhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, standardhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, standardhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, standardhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, standardhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, standardhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, standardhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, standardhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, standardhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, standardhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, standardhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, standardhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, standardhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, standardhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, standardhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, standardhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, standardhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, standardhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, standardhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, standardhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, standardhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, standardhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, standardhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, standardhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, standardhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, standardhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, standardhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, standardhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, standardhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, standardhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, standardhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, standardhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, standardhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, standardhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, standardhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, standardhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, standardhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, standardhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, standardhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, standardhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, standardhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, standardhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, standardhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, standardhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, standardhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, standardhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, standardhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, standardhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, standardhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, standardhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, standardhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, standardhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, standardhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, standardhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, standardhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Revision != nil {
		predicates = append(predicates, standardhistory.RevisionEQ(*i.Revision))
	}
	if i.RevisionNEQ != nil {
		predicates = append(predicates, standardhistory.RevisionNEQ(*i.RevisionNEQ))
	}
	if len(i.RevisionIn) > 0 {
		predicates = append(predicates, standardhistory.RevisionIn(i.RevisionIn...))
	}
	if len(i.RevisionNotIn) > 0 {
		predicates = append(predicates, standardhistory.RevisionNotIn(i.RevisionNotIn...))
	}
	if i.RevisionGT != nil {
		predicates = append(predicates, standardhistory.RevisionGT(*i.RevisionGT))
	}
	if i.RevisionGTE != nil {
		predicates = append(predicates, standardhistory.RevisionGTE(*i.RevisionGTE))
	}
	if i.RevisionLT != nil {
		predicates = append(predicates, standardhistory.RevisionLT(*i.RevisionLT))
	}
	if i.RevisionLTE != nil {
		predicates = append(predicates, standardhistory.RevisionLTE(*i.RevisionLTE))
	}
	if i.RevisionContains != nil {
		predicates = append(predicates, standardhistory.RevisionContains(*i.RevisionContains))
	}
	if i.RevisionHasPrefix != nil {
		predicates = append(predicates, standardhistory.RevisionHasPrefix(*i.RevisionHasPrefix))
	}
	if i.RevisionHasSuffix != nil {
		predicates = append(predicates, standardhistory.RevisionHasSuffix(*i.RevisionHasSuffix))
	}
	if i.RevisionIsNil {
		predicates = append(predicates, standardhistory.RevisionIsNil())
	}
	if i.RevisionNotNil {
		predicates = append(predicates, standardhistory.RevisionNotNil())
	}
	if i.RevisionEqualFold != nil {
		predicates = append(predicates, standardhistory.RevisionEqualFold(*i.RevisionEqualFold))
	}
	if i.RevisionContainsFold != nil {
		predicates = append(predicates, standardhistory.RevisionContainsFold(*i.RevisionContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, standardhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, standardhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, standardhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, standardhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, standardhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, standardhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, standardhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, standardhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, standardhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, standardhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, standardhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, standardhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, standardhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, standardhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, standardhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.SystemOwned != nil {
		predicates = append(predicates, standardhistory.SystemOwnedEQ(*i.SystemOwned))
	}
	if i.SystemOwnedNEQ != nil {
		predicates = append(predicates, standardhistory.SystemOwnedNEQ(*i.SystemOwnedNEQ))
	}
	if i.SystemOwnedIsNil {
		predicates = append(predicates, standardhistory.SystemOwnedIsNil())
	}
	if i.SystemOwnedNotNil {
		predicates = append(predicates, standardhistory.SystemOwnedNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, standardhistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, standardhistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, standardhistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, standardhistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, standardhistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, standardhistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, standardhistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, standardhistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, standardhistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, standardhistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, standardhistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, standardhistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, standardhistory.NameContainsFold(*i.NameContainsFold))
	}
	if i.ShortName != nil {
		predicates = append(predicates, standardhistory.ShortNameEQ(*i.ShortName))
	}
	if i.ShortNameNEQ != nil {
		predicates = append(predicates, standardhistory.ShortNameNEQ(*i.ShortNameNEQ))
	}
	if len(i.ShortNameIn) > 0 {
		predicates = append(predicates, standardhistory.ShortNameIn(i.ShortNameIn...))
	}
	if len(i.ShortNameNotIn) > 0 {
		predicates = append(predicates, standardhistory.ShortNameNotIn(i.ShortNameNotIn...))
	}
	if i.ShortNameGT != nil {
		predicates = append(predicates, standardhistory.ShortNameGT(*i.ShortNameGT))
	}
	if i.ShortNameGTE != nil {
		predicates = append(predicates, standardhistory.ShortNameGTE(*i.ShortNameGTE))
	}
	if i.ShortNameLT != nil {
		predicates = append(predicates, standardhistory.ShortNameLT(*i.ShortNameLT))
	}
	if i.ShortNameLTE != nil {
		predicates = append(predicates, standardhistory.ShortNameLTE(*i.ShortNameLTE))
	}
	if i.ShortNameContains != nil {
		predicates = append(predicates, standardhistory.ShortNameContains(*i.ShortNameContains))
	}
	if i.ShortNameHasPrefix != nil {
		predicates = append(predicates, standardhistory.ShortNameHasPrefix(*i.ShortNameHasPrefix))
	}
	if i.ShortNameHasSuffix != nil {
		predicates = append(predicates, standardhistory.ShortNameHasSuffix(*i.ShortNameHasSuffix))
	}
	if i.ShortNameIsNil {
		predicates = append(predicates, standardhistory.ShortNameIsNil())
	}
	if i.ShortNameNotNil {
		predicates = append(predicates, standardhistory.ShortNameNotNil())
	}
	if i.ShortNameEqualFold != nil {
		predicates = append(predicates, standardhistory.ShortNameEqualFold(*i.ShortNameEqualFold))
	}
	if i.ShortNameContainsFold != nil {
		predicates = append(predicates, standardhistory.ShortNameContainsFold(*i.ShortNameContainsFold))
	}
	if i.Framework != nil {
		predicates = append(predicates, standardhistory.FrameworkEQ(*i.Framework))
	}
	if i.FrameworkNEQ != nil {
		predicates = append(predicates, standardhistory.FrameworkNEQ(*i.FrameworkNEQ))
	}
	if len(i.FrameworkIn) > 0 {
		predicates = append(predicates, standardhistory.FrameworkIn(i.FrameworkIn...))
	}
	if len(i.FrameworkNotIn) > 0 {
		predicates = append(predicates, standardhistory.FrameworkNotIn(i.FrameworkNotIn...))
	}
	if i.FrameworkGT != nil {
		predicates = append(predicates, standardhistory.FrameworkGT(*i.FrameworkGT))
	}
	if i.FrameworkGTE != nil {
		predicates = append(predicates, standardhistory.FrameworkGTE(*i.FrameworkGTE))
	}
	if i.FrameworkLT != nil {
		predicates = append(predicates, standardhistory.FrameworkLT(*i.FrameworkLT))
	}
	if i.FrameworkLTE != nil {
		predicates = append(predicates, standardhistory.FrameworkLTE(*i.FrameworkLTE))
	}
	if i.FrameworkContains != nil {
		predicates = append(predicates, standardhistory.FrameworkContains(*i.FrameworkContains))
	}
	if i.FrameworkHasPrefix != nil {
		predicates = append(predicates, standardhistory.FrameworkHasPrefix(*i.FrameworkHasPrefix))
	}
	if i.FrameworkHasSuffix != nil {
		predicates = append(predicates, standardhistory.FrameworkHasSuffix(*i.FrameworkHasSuffix))
	}
	if i.FrameworkIsNil {
		predicates = append(predicates, standardhistory.FrameworkIsNil())
	}
	if i.FrameworkNotNil {
		predicates = append(predicates, standardhistory.FrameworkNotNil())
	}
	if i.FrameworkEqualFold != nil {
		predicates = append(predicates, standardhistory.FrameworkEqualFold(*i.FrameworkEqualFold))
	}
	if i.FrameworkContainsFold != nil {
		predicates = append(predicates, standardhistory.FrameworkContainsFold(*i.FrameworkContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, standardhistory.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, standardhistory.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, standardhistory.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, standardhistory.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, standardhistory.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, standardhistory.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, standardhistory.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, standardhistory.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, standardhistory.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, standardhistory.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, standardhistory.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, standardhistory.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, standardhistory.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, standardhistory.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, standardhistory.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.GoverningBodyLogoURL != nil {
		predicates = append(predicates, standardhistory.GoverningBodyLogoURLEQ(*i.GoverningBodyLogoURL))
	}
	if i.GoverningBodyLogoURLNEQ != nil {
		predicates = append(predicates, standardhistory.GoverningBodyLogoURLNEQ(*i.GoverningBodyLogoURLNEQ))
	}
	if len(i.GoverningBodyLogoURLIn) > 0 {
		predicates = append(predicates, standardhistory.GoverningBodyLogoURLIn(i.GoverningBodyLogoURLIn...))
	}
	if len(i.GoverningBodyLogoURLNotIn) > 0 {
		predicates = append(predicates, standardhistory.GoverningBodyLogoURLNotIn(i.GoverningBodyLogoURLNotIn...))
	}
	if i.GoverningBodyLogoURLGT != nil {
		predicates = append(predicates, standardhistory.GoverningBodyLogoURLGT(*i.GoverningBodyLogoURLGT))
	}
	if i.GoverningBodyLogoURLGTE != nil {
		predicates = append(predicates, standardhistory.GoverningBodyLogoURLGTE(*i.GoverningBodyLogoURLGTE))
	}
	if i.GoverningBodyLogoURLLT != nil {
		predicates = append(predicates, standardhistory.GoverningBodyLogoURLLT(*i.GoverningBodyLogoURLLT))
	}
	if i.GoverningBodyLogoURLLTE != nil {
		predicates = append(predicates, standardhistory.GoverningBodyLogoURLLTE(*i.GoverningBodyLogoURLLTE))
	}
	if i.GoverningBodyLogoURLContains != nil {
		predicates = append(predicates, standardhistory.GoverningBodyLogoURLContains(*i.GoverningBodyLogoURLContains))
	}
	if i.GoverningBodyLogoURLHasPrefix != nil {
		predicates = append(predicates, standardhistory.GoverningBodyLogoURLHasPrefix(*i.GoverningBodyLogoURLHasPrefix))
	}
	if i.GoverningBodyLogoURLHasSuffix != nil {
		predicates = append(predicates, standardhistory.GoverningBodyLogoURLHasSuffix(*i.GoverningBodyLogoURLHasSuffix))
	}
	if i.GoverningBodyLogoURLIsNil {
		predicates = append(predicates, standardhistory.GoverningBodyLogoURLIsNil())
	}
	if i.GoverningBodyLogoURLNotNil {
		predicates = append(predicates, standardhistory.GoverningBodyLogoURLNotNil())
	}
	if i.GoverningBodyLogoURLEqualFold != nil {
		predicates = append(predicates, standardhistory.GoverningBodyLogoURLEqualFold(*i.GoverningBodyLogoURLEqualFold))
	}
	if i.GoverningBodyLogoURLContainsFold != nil {
		predicates = append(predicates, standardhistory.GoverningBodyLogoURLContainsFold(*i.GoverningBodyLogoURLContainsFold))
	}
	if i.GoverningBody != nil {
		predicates = append(predicates, standardhistory.GoverningBodyEQ(*i.GoverningBody))
	}
	if i.GoverningBodyNEQ != nil {
		predicates = append(predicates, standardhistory.GoverningBodyNEQ(*i.GoverningBodyNEQ))
	}
	if len(i.GoverningBodyIn) > 0 {
		predicates = append(predicates, standardhistory.GoverningBodyIn(i.GoverningBodyIn...))
	}
	if len(i.GoverningBodyNotIn) > 0 {
		predicates = append(predicates, standardhistory.GoverningBodyNotIn(i.GoverningBodyNotIn...))
	}
	if i.GoverningBodyGT != nil {
		predicates = append(predicates, standardhistory.GoverningBodyGT(*i.GoverningBodyGT))
	}
	if i.GoverningBodyGTE != nil {
		predicates = append(predicates, standardhistory.GoverningBodyGTE(*i.GoverningBodyGTE))
	}
	if i.GoverningBodyLT != nil {
		predicates = append(predicates, standardhistory.GoverningBodyLT(*i.GoverningBodyLT))
	}
	if i.GoverningBodyLTE != nil {
		predicates = append(predicates, standardhistory.GoverningBodyLTE(*i.GoverningBodyLTE))
	}
	if i.GoverningBodyContains != nil {
		predicates = append(predicates, standardhistory.GoverningBodyContains(*i.GoverningBodyContains))
	}
	if i.GoverningBodyHasPrefix != nil {
		predicates = append(predicates, standardhistory.GoverningBodyHasPrefix(*i.GoverningBodyHasPrefix))
	}
	if i.GoverningBodyHasSuffix != nil {
		predicates = append(predicates, standardhistory.GoverningBodyHasSuffix(*i.GoverningBodyHasSuffix))
	}
	if i.GoverningBodyIsNil {
		predicates = append(predicates, standardhistory.GoverningBodyIsNil())
	}
	if i.GoverningBodyNotNil {
		predicates = append(predicates, standardhistory.GoverningBodyNotNil())
	}
	if i.GoverningBodyEqualFold != nil {
		predicates = append(predicates, standardhistory.GoverningBodyEqualFold(*i.GoverningBodyEqualFold))
	}
	if i.GoverningBodyContainsFold != nil {
		predicates = append(predicates, standardhistory.GoverningBodyContainsFold(*i.GoverningBodyContainsFold))
	}
	if i.Link != nil {
		predicates = append(predicates, standardhistory.LinkEQ(*i.Link))
	}
	if i.LinkNEQ != nil {
		predicates = append(predicates, standardhistory.LinkNEQ(*i.LinkNEQ))
	}
	if len(i.LinkIn) > 0 {
		predicates = append(predicates, standardhistory.LinkIn(i.LinkIn...))
	}
	if len(i.LinkNotIn) > 0 {
		predicates = append(predicates, standardhistory.LinkNotIn(i.LinkNotIn...))
	}
	if i.LinkGT != nil {
		predicates = append(predicates, standardhistory.LinkGT(*i.LinkGT))
	}
	if i.LinkGTE != nil {
		predicates = append(predicates, standardhistory.LinkGTE(*i.LinkGTE))
	}
	if i.LinkLT != nil {
		predicates = append(predicates, standardhistory.LinkLT(*i.LinkLT))
	}
	if i.LinkLTE != nil {
		predicates = append(predicates, standardhistory.LinkLTE(*i.LinkLTE))
	}
	if i.LinkContains != nil {
		predicates = append(predicates, standardhistory.LinkContains(*i.LinkContains))
	}
	if i.LinkHasPrefix != nil {
		predicates = append(predicates, standardhistory.LinkHasPrefix(*i.LinkHasPrefix))
	}
	if i.LinkHasSuffix != nil {
		predicates = append(predicates, standardhistory.LinkHasSuffix(*i.LinkHasSuffix))
	}
	if i.LinkIsNil {
		predicates = append(predicates, standardhistory.LinkIsNil())
	}
	if i.LinkNotNil {
		predicates = append(predicates, standardhistory.LinkNotNil())
	}
	if i.LinkEqualFold != nil {
		predicates = append(predicates, standardhistory.LinkEqualFold(*i.LinkEqualFold))
	}
	if i.LinkContainsFold != nil {
		predicates = append(predicates, standardhistory.LinkContainsFold(*i.LinkContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, standardhistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, standardhistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, standardhistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, standardhistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, standardhistory.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, standardhistory.StatusNotNil())
	}
	if i.IsPublic != nil {
		predicates = append(predicates, standardhistory.IsPublicEQ(*i.IsPublic))
	}
	if i.IsPublicNEQ != nil {
		predicates = append(predicates, standardhistory.IsPublicNEQ(*i.IsPublicNEQ))
	}
	if i.IsPublicIsNil {
		predicates = append(predicates, standardhistory.IsPublicIsNil())
	}
	if i.IsPublicNotNil {
		predicates = append(predicates, standardhistory.IsPublicNotNil())
	}
	if i.FreeToUse != nil {
		predicates = append(predicates, standardhistory.FreeToUseEQ(*i.FreeToUse))
	}
	if i.FreeToUseNEQ != nil {
		predicates = append(predicates, standardhistory.FreeToUseNEQ(*i.FreeToUseNEQ))
	}
	if i.FreeToUseIsNil {
		predicates = append(predicates, standardhistory.FreeToUseIsNil())
	}
	if i.FreeToUseNotNil {
		predicates = append(predicates, standardhistory.FreeToUseNotNil())
	}
	if i.StandardType != nil {
		predicates = append(predicates, standardhistory.StandardTypeEQ(*i.StandardType))
	}
	if i.StandardTypeNEQ != nil {
		predicates = append(predicates, standardhistory.StandardTypeNEQ(*i.StandardTypeNEQ))
	}
	if len(i.StandardTypeIn) > 0 {
		predicates = append(predicates, standardhistory.StandardTypeIn(i.StandardTypeIn...))
	}
	if len(i.StandardTypeNotIn) > 0 {
		predicates = append(predicates, standardhistory.StandardTypeNotIn(i.StandardTypeNotIn...))
	}
	if i.StandardTypeGT != nil {
		predicates = append(predicates, standardhistory.StandardTypeGT(*i.StandardTypeGT))
	}
	if i.StandardTypeGTE != nil {
		predicates = append(predicates, standardhistory.StandardTypeGTE(*i.StandardTypeGTE))
	}
	if i.StandardTypeLT != nil {
		predicates = append(predicates, standardhistory.StandardTypeLT(*i.StandardTypeLT))
	}
	if i.StandardTypeLTE != nil {
		predicates = append(predicates, standardhistory.StandardTypeLTE(*i.StandardTypeLTE))
	}
	if i.StandardTypeContains != nil {
		predicates = append(predicates, standardhistory.StandardTypeContains(*i.StandardTypeContains))
	}
	if i.StandardTypeHasPrefix != nil {
		predicates = append(predicates, standardhistory.StandardTypeHasPrefix(*i.StandardTypeHasPrefix))
	}
	if i.StandardTypeHasSuffix != nil {
		predicates = append(predicates, standardhistory.StandardTypeHasSuffix(*i.StandardTypeHasSuffix))
	}
	if i.StandardTypeIsNil {
		predicates = append(predicates, standardhistory.StandardTypeIsNil())
	}
	if i.StandardTypeNotNil {
		predicates = append(predicates, standardhistory.StandardTypeNotNil())
	}
	if i.StandardTypeEqualFold != nil {
		predicates = append(predicates, standardhistory.StandardTypeEqualFold(*i.StandardTypeEqualFold))
	}
	if i.StandardTypeContainsFold != nil {
		predicates = append(predicates, standardhistory.StandardTypeContainsFold(*i.StandardTypeContainsFold))
	}
	if i.Version != nil {
		predicates = append(predicates, standardhistory.VersionEQ(*i.Version))
	}
	if i.VersionNEQ != nil {
		predicates = append(predicates, standardhistory.VersionNEQ(*i.VersionNEQ))
	}
	if len(i.VersionIn) > 0 {
		predicates = append(predicates, standardhistory.VersionIn(i.VersionIn...))
	}
	if len(i.VersionNotIn) > 0 {
		predicates = append(predicates, standardhistory.VersionNotIn(i.VersionNotIn...))
	}
	if i.VersionGT != nil {
		predicates = append(predicates, standardhistory.VersionGT(*i.VersionGT))
	}
	if i.VersionGTE != nil {
		predicates = append(predicates, standardhistory.VersionGTE(*i.VersionGTE))
	}
	if i.VersionLT != nil {
		predicates = append(predicates, standardhistory.VersionLT(*i.VersionLT))
	}
	if i.VersionLTE != nil {
		predicates = append(predicates, standardhistory.VersionLTE(*i.VersionLTE))
	}
	if i.VersionContains != nil {
		predicates = append(predicates, standardhistory.VersionContains(*i.VersionContains))
	}
	if i.VersionHasPrefix != nil {
		predicates = append(predicates, standardhistory.VersionHasPrefix(*i.VersionHasPrefix))
	}
	if i.VersionHasSuffix != nil {
		predicates = append(predicates, standardhistory.VersionHasSuffix(*i.VersionHasSuffix))
	}
	if i.VersionIsNil {
		predicates = append(predicates, standardhistory.VersionIsNil())
	}
	if i.VersionNotNil {
		predicates = append(predicates, standardhistory.VersionNotNil())
	}
	if i.VersionEqualFold != nil {
		predicates = append(predicates, standardhistory.VersionEqualFold(*i.VersionEqualFold))
	}
	if i.VersionContainsFold != nil {
		predicates = append(predicates, standardhistory.VersionContainsFold(*i.VersionContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyStandardHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return standardhistory.And(predicates...), nil
	}
}

// SubcontrolWhereInput represents a where input for filtering Subcontrol queries.
type SubcontrolWhereInput struct {
	Predicates []predicate.Subcontrol  `json:"-"`
	Not        *SubcontrolWhereInput   `json:"not,omitempty"`
	Or         []*SubcontrolWhereInput `json:"or,omitempty"`
	And        []*SubcontrolWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "reference_id" field predicates.
	ReferenceID             *string  `json:"referenceID,omitempty"`
	ReferenceIDNEQ          *string  `json:"referenceIDNEQ,omitempty"`
	ReferenceIDIn           []string `json:"referenceIDIn,omitempty"`
	ReferenceIDNotIn        []string `json:"referenceIDNotIn,omitempty"`
	ReferenceIDGT           *string  `json:"referenceIDGT,omitempty"`
	ReferenceIDGTE          *string  `json:"referenceIDGTE,omitempty"`
	ReferenceIDLT           *string  `json:"referenceIDLT,omitempty"`
	ReferenceIDLTE          *string  `json:"referenceIDLTE,omitempty"`
	ReferenceIDContains     *string  `json:"referenceIDContains,omitempty"`
	ReferenceIDHasPrefix    *string  `json:"referenceIDHasPrefix,omitempty"`
	ReferenceIDHasSuffix    *string  `json:"referenceIDHasSuffix,omitempty"`
	ReferenceIDIsNil        bool     `json:"referenceIDIsNil,omitempty"`
	ReferenceIDNotNil       bool     `json:"referenceIDNotNil,omitempty"`
	ReferenceIDEqualFold    *string  `json:"referenceIDEqualFold,omitempty"`
	ReferenceIDContainsFold *string  `json:"referenceIDContainsFold,omitempty"`

	// "auditor_reference_id" field predicates.
	AuditorReferenceID             *string  `json:"auditorReferenceID,omitempty"`
	AuditorReferenceIDNEQ          *string  `json:"auditorReferenceIDNEQ,omitempty"`
	AuditorReferenceIDIn           []string `json:"auditorReferenceIDIn,omitempty"`
	AuditorReferenceIDNotIn        []string `json:"auditorReferenceIDNotIn,omitempty"`
	AuditorReferenceIDGT           *string  `json:"auditorReferenceIDGT,omitempty"`
	AuditorReferenceIDGTE          *string  `json:"auditorReferenceIDGTE,omitempty"`
	AuditorReferenceIDLT           *string  `json:"auditorReferenceIDLT,omitempty"`
	AuditorReferenceIDLTE          *string  `json:"auditorReferenceIDLTE,omitempty"`
	AuditorReferenceIDContains     *string  `json:"auditorReferenceIDContains,omitempty"`
	AuditorReferenceIDHasPrefix    *string  `json:"auditorReferenceIDHasPrefix,omitempty"`
	AuditorReferenceIDHasSuffix    *string  `json:"auditorReferenceIDHasSuffix,omitempty"`
	AuditorReferenceIDIsNil        bool     `json:"auditorReferenceIDIsNil,omitempty"`
	AuditorReferenceIDNotNil       bool     `json:"auditorReferenceIDNotNil,omitempty"`
	AuditorReferenceIDEqualFold    *string  `json:"auditorReferenceIDEqualFold,omitempty"`
	AuditorReferenceIDContainsFold *string  `json:"auditorReferenceIDContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.ControlStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.ControlStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.ControlStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.ControlStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil bool                  `json:"statusNotNil,omitempty"`

	// "source" field predicates.
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNEQ    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  bool                  `json:"sourceIsNil,omitempty"`
	SourceNotNil bool                  `json:"sourceNotNil,omitempty"`

	// "reference_framework" field predicates.
	ReferenceFramework             *string  `json:"referenceFramework,omitempty"`
	ReferenceFrameworkNEQ          *string  `json:"referenceFrameworkNEQ,omitempty"`
	ReferenceFrameworkIn           []string `json:"referenceFrameworkIn,omitempty"`
	ReferenceFrameworkNotIn        []string `json:"referenceFrameworkNotIn,omitempty"`
	ReferenceFrameworkGT           *string  `json:"referenceFrameworkGT,omitempty"`
	ReferenceFrameworkGTE          *string  `json:"referenceFrameworkGTE,omitempty"`
	ReferenceFrameworkLT           *string  `json:"referenceFrameworkLT,omitempty"`
	ReferenceFrameworkLTE          *string  `json:"referenceFrameworkLTE,omitempty"`
	ReferenceFrameworkContains     *string  `json:"referenceFrameworkContains,omitempty"`
	ReferenceFrameworkHasPrefix    *string  `json:"referenceFrameworkHasPrefix,omitempty"`
	ReferenceFrameworkHasSuffix    *string  `json:"referenceFrameworkHasSuffix,omitempty"`
	ReferenceFrameworkIsNil        bool     `json:"referenceFrameworkIsNil,omitempty"`
	ReferenceFrameworkNotNil       bool     `json:"referenceFrameworkNotNil,omitempty"`
	ReferenceFrameworkEqualFold    *string  `json:"referenceFrameworkEqualFold,omitempty"`
	ReferenceFrameworkContainsFold *string  `json:"referenceFrameworkContainsFold,omitempty"`

	// "control_type" field predicates.
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNEQ    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  bool                `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil bool                `json:"controlTypeNotNil,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        bool     `json:"categoryIsNil,omitempty"`
	CategoryNotNil       bool     `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "category_id" field predicates.
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIDNEQ          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIDGT           *string  `json:"categoryIDGT,omitempty"`
	CategoryIDGTE          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIDLT           *string  `json:"categoryIDLT,omitempty"`
	CategoryIDLTE          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        bool     `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       bool     `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`

	// "subcategory" field predicates.
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNEQ          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGT           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGTE          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLT           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLTE          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        bool     `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       bool     `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`

	// "control_owner_id" field predicates.
	ControlOwnerID             *string  `json:"controlOwnerID,omitempty"`
	ControlOwnerIDNEQ          *string  `json:"controlOwnerIDNEQ,omitempty"`
	ControlOwnerIDIn           []string `json:"controlOwnerIDIn,omitempty"`
	ControlOwnerIDNotIn        []string `json:"controlOwnerIDNotIn,omitempty"`
	ControlOwnerIDGT           *string  `json:"controlOwnerIDGT,omitempty"`
	ControlOwnerIDGTE          *string  `json:"controlOwnerIDGTE,omitempty"`
	ControlOwnerIDLT           *string  `json:"controlOwnerIDLT,omitempty"`
	ControlOwnerIDLTE          *string  `json:"controlOwnerIDLTE,omitempty"`
	ControlOwnerIDContains     *string  `json:"controlOwnerIDContains,omitempty"`
	ControlOwnerIDHasPrefix    *string  `json:"controlOwnerIDHasPrefix,omitempty"`
	ControlOwnerIDHasSuffix    *string  `json:"controlOwnerIDHasSuffix,omitempty"`
	ControlOwnerIDIsNil        bool     `json:"controlOwnerIDIsNil,omitempty"`
	ControlOwnerIDNotNil       bool     `json:"controlOwnerIDNotNil,omitempty"`
	ControlOwnerIDEqualFold    *string  `json:"controlOwnerIDEqualFold,omitempty"`
	ControlOwnerIDContainsFold *string  `json:"controlOwnerIDContainsFold,omitempty"`

	// "delegate_id" field predicates.
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIDNEQ          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIDGT           *string  `json:"delegateIDGT,omitempty"`
	DelegateIDGTE          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIDLT           *string  `json:"delegateIDLT,omitempty"`
	DelegateIDLTE          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        bool     `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       bool     `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "ref_code" field predicates.
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNEQ          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGT           *string  `json:"refCodeGT,omitempty"`
	RefCodeGTE          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLT           *string  `json:"refCodeLT,omitempty"`
	RefCodeLTE          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`

	// "control_id" field predicates.
	ControlID             *string  `json:"controlID,omitempty"`
	ControlIDNEQ          *string  `json:"controlIDNEQ,omitempty"`
	ControlIDIn           []string `json:"controlIDIn,omitempty"`
	ControlIDNotIn        []string `json:"controlIDNotIn,omitempty"`
	ControlIDGT           *string  `json:"controlIDGT,omitempty"`
	ControlIDGTE          *string  `json:"controlIDGTE,omitempty"`
	ControlIDLT           *string  `json:"controlIDLT,omitempty"`
	ControlIDLTE          *string  `json:"controlIDLTE,omitempty"`
	ControlIDContains     *string  `json:"controlIDContains,omitempty"`
	ControlIDHasPrefix    *string  `json:"controlIDHasPrefix,omitempty"`
	ControlIDHasSuffix    *string  `json:"controlIDHasSuffix,omitempty"`
	ControlIDEqualFold    *string  `json:"controlIDEqualFold,omitempty"`
	ControlIDContainsFold *string  `json:"controlIDContainsFold,omitempty"`

	// "evidence" edge predicates.
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`

	// "control_objectives" edge predicates.
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`

	// "narratives" edge predicates.
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`

	// "risks" edge predicates.
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`

	// "action_plans" edge predicates.
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`

	// "procedures" edge predicates.
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`

	// "internal_policies" edge predicates.
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`

	// "control_owner" edge predicates.
	HasControlOwner     *bool              `json:"hasControlOwner,omitempty"`
	HasControlOwnerWith []*GroupWhereInput `json:"hasControlOwnerWith,omitempty"`

	// "delegate" edge predicates.
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "control" edge predicates.
	HasControl     *bool                `json:"hasControl,omitempty"`
	HasControlWith []*ControlWhereInput `json:"hasControlWith,omitempty"`

	// "control_implementations" edge predicates.
	HasControlImplementations     *bool                              `json:"hasControlImplementations,omitempty"`
	HasControlImplementationsWith []*ControlImplementationWhereInput `json:"hasControlImplementationsWith,omitempty"`

	// "scheduled_jobs" edge predicates.
	HasScheduledJobs     *bool                            `json:"hasScheduledJobs,omitempty"`
	HasScheduledJobsWith []*ControlScheduledJobWhereInput `json:"hasScheduledJobsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SubcontrolWhereInput) AddPredicates(predicates ...predicate.Subcontrol) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SubcontrolWhereInput filter on the SubcontrolQuery builder.
func (i *SubcontrolWhereInput) Filter(q *SubcontrolQuery) (*SubcontrolQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySubcontrolWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySubcontrolWhereInput is returned in case the SubcontrolWhereInput is empty.
var ErrEmptySubcontrolWhereInput = errors.New("generated: empty predicate SubcontrolWhereInput")

// P returns a predicate for filtering subcontrols.
// An error is returned if the input is empty or invalid.
func (i *SubcontrolWhereInput) P() (predicate.Subcontrol, error) {
	var predicates []predicate.Subcontrol
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, subcontrol.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Subcontrol, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, subcontrol.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Subcontrol, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, subcontrol.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, subcontrol.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, subcontrol.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, subcontrol.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, subcontrol.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, subcontrol.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, subcontrol.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, subcontrol.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, subcontrol.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, subcontrol.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, subcontrol.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, subcontrol.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, subcontrol.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, subcontrol.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, subcontrol.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, subcontrol.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, subcontrol.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, subcontrol.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, subcontrol.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, subcontrol.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, subcontrol.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, subcontrol.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, subcontrol.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, subcontrol.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, subcontrol.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, subcontrol.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, subcontrol.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, subcontrol.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, subcontrol.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, subcontrol.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, subcontrol.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, subcontrol.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, subcontrol.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, subcontrol.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, subcontrol.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, subcontrol.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, subcontrol.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, subcontrol.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, subcontrol.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, subcontrol.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, subcontrol.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, subcontrol.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, subcontrol.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, subcontrol.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, subcontrol.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, subcontrol.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, subcontrol.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, subcontrol.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, subcontrol.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, subcontrol.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, subcontrol.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, subcontrol.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, subcontrol.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, subcontrol.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, subcontrol.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, subcontrol.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, subcontrol.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, subcontrol.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, subcontrol.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, subcontrol.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, subcontrol.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, subcontrol.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, subcontrol.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, subcontrol.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, subcontrol.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, subcontrol.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, subcontrol.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, subcontrol.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, subcontrol.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, subcontrol.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, subcontrol.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, subcontrol.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, subcontrol.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, subcontrol.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, subcontrol.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, subcontrol.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, subcontrol.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, subcontrol.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, subcontrol.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, subcontrol.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, subcontrol.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, subcontrol.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, subcontrol.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, subcontrol.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, subcontrol.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, subcontrol.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, subcontrol.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, subcontrol.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, subcontrol.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ReferenceID != nil {
		predicates = append(predicates, subcontrol.ReferenceIDEQ(*i.ReferenceID))
	}
	if i.ReferenceIDNEQ != nil {
		predicates = append(predicates, subcontrol.ReferenceIDNEQ(*i.ReferenceIDNEQ))
	}
	if len(i.ReferenceIDIn) > 0 {
		predicates = append(predicates, subcontrol.ReferenceIDIn(i.ReferenceIDIn...))
	}
	if len(i.ReferenceIDNotIn) > 0 {
		predicates = append(predicates, subcontrol.ReferenceIDNotIn(i.ReferenceIDNotIn...))
	}
	if i.ReferenceIDGT != nil {
		predicates = append(predicates, subcontrol.ReferenceIDGT(*i.ReferenceIDGT))
	}
	if i.ReferenceIDGTE != nil {
		predicates = append(predicates, subcontrol.ReferenceIDGTE(*i.ReferenceIDGTE))
	}
	if i.ReferenceIDLT != nil {
		predicates = append(predicates, subcontrol.ReferenceIDLT(*i.ReferenceIDLT))
	}
	if i.ReferenceIDLTE != nil {
		predicates = append(predicates, subcontrol.ReferenceIDLTE(*i.ReferenceIDLTE))
	}
	if i.ReferenceIDContains != nil {
		predicates = append(predicates, subcontrol.ReferenceIDContains(*i.ReferenceIDContains))
	}
	if i.ReferenceIDHasPrefix != nil {
		predicates = append(predicates, subcontrol.ReferenceIDHasPrefix(*i.ReferenceIDHasPrefix))
	}
	if i.ReferenceIDHasSuffix != nil {
		predicates = append(predicates, subcontrol.ReferenceIDHasSuffix(*i.ReferenceIDHasSuffix))
	}
	if i.ReferenceIDIsNil {
		predicates = append(predicates, subcontrol.ReferenceIDIsNil())
	}
	if i.ReferenceIDNotNil {
		predicates = append(predicates, subcontrol.ReferenceIDNotNil())
	}
	if i.ReferenceIDEqualFold != nil {
		predicates = append(predicates, subcontrol.ReferenceIDEqualFold(*i.ReferenceIDEqualFold))
	}
	if i.ReferenceIDContainsFold != nil {
		predicates = append(predicates, subcontrol.ReferenceIDContainsFold(*i.ReferenceIDContainsFold))
	}
	if i.AuditorReferenceID != nil {
		predicates = append(predicates, subcontrol.AuditorReferenceIDEQ(*i.AuditorReferenceID))
	}
	if i.AuditorReferenceIDNEQ != nil {
		predicates = append(predicates, subcontrol.AuditorReferenceIDNEQ(*i.AuditorReferenceIDNEQ))
	}
	if len(i.AuditorReferenceIDIn) > 0 {
		predicates = append(predicates, subcontrol.AuditorReferenceIDIn(i.AuditorReferenceIDIn...))
	}
	if len(i.AuditorReferenceIDNotIn) > 0 {
		predicates = append(predicates, subcontrol.AuditorReferenceIDNotIn(i.AuditorReferenceIDNotIn...))
	}
	if i.AuditorReferenceIDGT != nil {
		predicates = append(predicates, subcontrol.AuditorReferenceIDGT(*i.AuditorReferenceIDGT))
	}
	if i.AuditorReferenceIDGTE != nil {
		predicates = append(predicates, subcontrol.AuditorReferenceIDGTE(*i.AuditorReferenceIDGTE))
	}
	if i.AuditorReferenceIDLT != nil {
		predicates = append(predicates, subcontrol.AuditorReferenceIDLT(*i.AuditorReferenceIDLT))
	}
	if i.AuditorReferenceIDLTE != nil {
		predicates = append(predicates, subcontrol.AuditorReferenceIDLTE(*i.AuditorReferenceIDLTE))
	}
	if i.AuditorReferenceIDContains != nil {
		predicates = append(predicates, subcontrol.AuditorReferenceIDContains(*i.AuditorReferenceIDContains))
	}
	if i.AuditorReferenceIDHasPrefix != nil {
		predicates = append(predicates, subcontrol.AuditorReferenceIDHasPrefix(*i.AuditorReferenceIDHasPrefix))
	}
	if i.AuditorReferenceIDHasSuffix != nil {
		predicates = append(predicates, subcontrol.AuditorReferenceIDHasSuffix(*i.AuditorReferenceIDHasSuffix))
	}
	if i.AuditorReferenceIDIsNil {
		predicates = append(predicates, subcontrol.AuditorReferenceIDIsNil())
	}
	if i.AuditorReferenceIDNotNil {
		predicates = append(predicates, subcontrol.AuditorReferenceIDNotNil())
	}
	if i.AuditorReferenceIDEqualFold != nil {
		predicates = append(predicates, subcontrol.AuditorReferenceIDEqualFold(*i.AuditorReferenceIDEqualFold))
	}
	if i.AuditorReferenceIDContainsFold != nil {
		predicates = append(predicates, subcontrol.AuditorReferenceIDContainsFold(*i.AuditorReferenceIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, subcontrol.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, subcontrol.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, subcontrol.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, subcontrol.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, subcontrol.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, subcontrol.StatusNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, subcontrol.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, subcontrol.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, subcontrol.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, subcontrol.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceIsNil {
		predicates = append(predicates, subcontrol.SourceIsNil())
	}
	if i.SourceNotNil {
		predicates = append(predicates, subcontrol.SourceNotNil())
	}
	if i.ReferenceFramework != nil {
		predicates = append(predicates, subcontrol.ReferenceFrameworkEQ(*i.ReferenceFramework))
	}
	if i.ReferenceFrameworkNEQ != nil {
		predicates = append(predicates, subcontrol.ReferenceFrameworkNEQ(*i.ReferenceFrameworkNEQ))
	}
	if len(i.ReferenceFrameworkIn) > 0 {
		predicates = append(predicates, subcontrol.ReferenceFrameworkIn(i.ReferenceFrameworkIn...))
	}
	if len(i.ReferenceFrameworkNotIn) > 0 {
		predicates = append(predicates, subcontrol.ReferenceFrameworkNotIn(i.ReferenceFrameworkNotIn...))
	}
	if i.ReferenceFrameworkGT != nil {
		predicates = append(predicates, subcontrol.ReferenceFrameworkGT(*i.ReferenceFrameworkGT))
	}
	if i.ReferenceFrameworkGTE != nil {
		predicates = append(predicates, subcontrol.ReferenceFrameworkGTE(*i.ReferenceFrameworkGTE))
	}
	if i.ReferenceFrameworkLT != nil {
		predicates = append(predicates, subcontrol.ReferenceFrameworkLT(*i.ReferenceFrameworkLT))
	}
	if i.ReferenceFrameworkLTE != nil {
		predicates = append(predicates, subcontrol.ReferenceFrameworkLTE(*i.ReferenceFrameworkLTE))
	}
	if i.ReferenceFrameworkContains != nil {
		predicates = append(predicates, subcontrol.ReferenceFrameworkContains(*i.ReferenceFrameworkContains))
	}
	if i.ReferenceFrameworkHasPrefix != nil {
		predicates = append(predicates, subcontrol.ReferenceFrameworkHasPrefix(*i.ReferenceFrameworkHasPrefix))
	}
	if i.ReferenceFrameworkHasSuffix != nil {
		predicates = append(predicates, subcontrol.ReferenceFrameworkHasSuffix(*i.ReferenceFrameworkHasSuffix))
	}
	if i.ReferenceFrameworkIsNil {
		predicates = append(predicates, subcontrol.ReferenceFrameworkIsNil())
	}
	if i.ReferenceFrameworkNotNil {
		predicates = append(predicates, subcontrol.ReferenceFrameworkNotNil())
	}
	if i.ReferenceFrameworkEqualFold != nil {
		predicates = append(predicates, subcontrol.ReferenceFrameworkEqualFold(*i.ReferenceFrameworkEqualFold))
	}
	if i.ReferenceFrameworkContainsFold != nil {
		predicates = append(predicates, subcontrol.ReferenceFrameworkContainsFold(*i.ReferenceFrameworkContainsFold))
	}
	if i.ControlType != nil {
		predicates = append(predicates, subcontrol.ControlTypeEQ(*i.ControlType))
	}
	if i.ControlTypeNEQ != nil {
		predicates = append(predicates, subcontrol.ControlTypeNEQ(*i.ControlTypeNEQ))
	}
	if len(i.ControlTypeIn) > 0 {
		predicates = append(predicates, subcontrol.ControlTypeIn(i.ControlTypeIn...))
	}
	if len(i.ControlTypeNotIn) > 0 {
		predicates = append(predicates, subcontrol.ControlTypeNotIn(i.ControlTypeNotIn...))
	}
	if i.ControlTypeIsNil {
		predicates = append(predicates, subcontrol.ControlTypeIsNil())
	}
	if i.ControlTypeNotNil {
		predicates = append(predicates, subcontrol.ControlTypeNotNil())
	}
	if i.Category != nil {
		predicates = append(predicates, subcontrol.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, subcontrol.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, subcontrol.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, subcontrol.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, subcontrol.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, subcontrol.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, subcontrol.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, subcontrol.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, subcontrol.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, subcontrol.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, subcontrol.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryIsNil {
		predicates = append(predicates, subcontrol.CategoryIsNil())
	}
	if i.CategoryNotNil {
		predicates = append(predicates, subcontrol.CategoryNotNil())
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, subcontrol.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, subcontrol.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.CategoryID != nil {
		predicates = append(predicates, subcontrol.CategoryIDEQ(*i.CategoryID))
	}
	if i.CategoryIDNEQ != nil {
		predicates = append(predicates, subcontrol.CategoryIDNEQ(*i.CategoryIDNEQ))
	}
	if len(i.CategoryIDIn) > 0 {
		predicates = append(predicates, subcontrol.CategoryIDIn(i.CategoryIDIn...))
	}
	if len(i.CategoryIDNotIn) > 0 {
		predicates = append(predicates, subcontrol.CategoryIDNotIn(i.CategoryIDNotIn...))
	}
	if i.CategoryIDGT != nil {
		predicates = append(predicates, subcontrol.CategoryIDGT(*i.CategoryIDGT))
	}
	if i.CategoryIDGTE != nil {
		predicates = append(predicates, subcontrol.CategoryIDGTE(*i.CategoryIDGTE))
	}
	if i.CategoryIDLT != nil {
		predicates = append(predicates, subcontrol.CategoryIDLT(*i.CategoryIDLT))
	}
	if i.CategoryIDLTE != nil {
		predicates = append(predicates, subcontrol.CategoryIDLTE(*i.CategoryIDLTE))
	}
	if i.CategoryIDContains != nil {
		predicates = append(predicates, subcontrol.CategoryIDContains(*i.CategoryIDContains))
	}
	if i.CategoryIDHasPrefix != nil {
		predicates = append(predicates, subcontrol.CategoryIDHasPrefix(*i.CategoryIDHasPrefix))
	}
	if i.CategoryIDHasSuffix != nil {
		predicates = append(predicates, subcontrol.CategoryIDHasSuffix(*i.CategoryIDHasSuffix))
	}
	if i.CategoryIDIsNil {
		predicates = append(predicates, subcontrol.CategoryIDIsNil())
	}
	if i.CategoryIDNotNil {
		predicates = append(predicates, subcontrol.CategoryIDNotNil())
	}
	if i.CategoryIDEqualFold != nil {
		predicates = append(predicates, subcontrol.CategoryIDEqualFold(*i.CategoryIDEqualFold))
	}
	if i.CategoryIDContainsFold != nil {
		predicates = append(predicates, subcontrol.CategoryIDContainsFold(*i.CategoryIDContainsFold))
	}
	if i.Subcategory != nil {
		predicates = append(predicates, subcontrol.SubcategoryEQ(*i.Subcategory))
	}
	if i.SubcategoryNEQ != nil {
		predicates = append(predicates, subcontrol.SubcategoryNEQ(*i.SubcategoryNEQ))
	}
	if len(i.SubcategoryIn) > 0 {
		predicates = append(predicates, subcontrol.SubcategoryIn(i.SubcategoryIn...))
	}
	if len(i.SubcategoryNotIn) > 0 {
		predicates = append(predicates, subcontrol.SubcategoryNotIn(i.SubcategoryNotIn...))
	}
	if i.SubcategoryGT != nil {
		predicates = append(predicates, subcontrol.SubcategoryGT(*i.SubcategoryGT))
	}
	if i.SubcategoryGTE != nil {
		predicates = append(predicates, subcontrol.SubcategoryGTE(*i.SubcategoryGTE))
	}
	if i.SubcategoryLT != nil {
		predicates = append(predicates, subcontrol.SubcategoryLT(*i.SubcategoryLT))
	}
	if i.SubcategoryLTE != nil {
		predicates = append(predicates, subcontrol.SubcategoryLTE(*i.SubcategoryLTE))
	}
	if i.SubcategoryContains != nil {
		predicates = append(predicates, subcontrol.SubcategoryContains(*i.SubcategoryContains))
	}
	if i.SubcategoryHasPrefix != nil {
		predicates = append(predicates, subcontrol.SubcategoryHasPrefix(*i.SubcategoryHasPrefix))
	}
	if i.SubcategoryHasSuffix != nil {
		predicates = append(predicates, subcontrol.SubcategoryHasSuffix(*i.SubcategoryHasSuffix))
	}
	if i.SubcategoryIsNil {
		predicates = append(predicates, subcontrol.SubcategoryIsNil())
	}
	if i.SubcategoryNotNil {
		predicates = append(predicates, subcontrol.SubcategoryNotNil())
	}
	if i.SubcategoryEqualFold != nil {
		predicates = append(predicates, subcontrol.SubcategoryEqualFold(*i.SubcategoryEqualFold))
	}
	if i.SubcategoryContainsFold != nil {
		predicates = append(predicates, subcontrol.SubcategoryContainsFold(*i.SubcategoryContainsFold))
	}
	if i.ControlOwnerID != nil {
		predicates = append(predicates, subcontrol.ControlOwnerIDEQ(*i.ControlOwnerID))
	}
	if i.ControlOwnerIDNEQ != nil {
		predicates = append(predicates, subcontrol.ControlOwnerIDNEQ(*i.ControlOwnerIDNEQ))
	}
	if len(i.ControlOwnerIDIn) > 0 {
		predicates = append(predicates, subcontrol.ControlOwnerIDIn(i.ControlOwnerIDIn...))
	}
	if len(i.ControlOwnerIDNotIn) > 0 {
		predicates = append(predicates, subcontrol.ControlOwnerIDNotIn(i.ControlOwnerIDNotIn...))
	}
	if i.ControlOwnerIDGT != nil {
		predicates = append(predicates, subcontrol.ControlOwnerIDGT(*i.ControlOwnerIDGT))
	}
	if i.ControlOwnerIDGTE != nil {
		predicates = append(predicates, subcontrol.ControlOwnerIDGTE(*i.ControlOwnerIDGTE))
	}
	if i.ControlOwnerIDLT != nil {
		predicates = append(predicates, subcontrol.ControlOwnerIDLT(*i.ControlOwnerIDLT))
	}
	if i.ControlOwnerIDLTE != nil {
		predicates = append(predicates, subcontrol.ControlOwnerIDLTE(*i.ControlOwnerIDLTE))
	}
	if i.ControlOwnerIDContains != nil {
		predicates = append(predicates, subcontrol.ControlOwnerIDContains(*i.ControlOwnerIDContains))
	}
	if i.ControlOwnerIDHasPrefix != nil {
		predicates = append(predicates, subcontrol.ControlOwnerIDHasPrefix(*i.ControlOwnerIDHasPrefix))
	}
	if i.ControlOwnerIDHasSuffix != nil {
		predicates = append(predicates, subcontrol.ControlOwnerIDHasSuffix(*i.ControlOwnerIDHasSuffix))
	}
	if i.ControlOwnerIDIsNil {
		predicates = append(predicates, subcontrol.ControlOwnerIDIsNil())
	}
	if i.ControlOwnerIDNotNil {
		predicates = append(predicates, subcontrol.ControlOwnerIDNotNil())
	}
	if i.ControlOwnerIDEqualFold != nil {
		predicates = append(predicates, subcontrol.ControlOwnerIDEqualFold(*i.ControlOwnerIDEqualFold))
	}
	if i.ControlOwnerIDContainsFold != nil {
		predicates = append(predicates, subcontrol.ControlOwnerIDContainsFold(*i.ControlOwnerIDContainsFold))
	}
	if i.DelegateID != nil {
		predicates = append(predicates, subcontrol.DelegateIDEQ(*i.DelegateID))
	}
	if i.DelegateIDNEQ != nil {
		predicates = append(predicates, subcontrol.DelegateIDNEQ(*i.DelegateIDNEQ))
	}
	if len(i.DelegateIDIn) > 0 {
		predicates = append(predicates, subcontrol.DelegateIDIn(i.DelegateIDIn...))
	}
	if len(i.DelegateIDNotIn) > 0 {
		predicates = append(predicates, subcontrol.DelegateIDNotIn(i.DelegateIDNotIn...))
	}
	if i.DelegateIDGT != nil {
		predicates = append(predicates, subcontrol.DelegateIDGT(*i.DelegateIDGT))
	}
	if i.DelegateIDGTE != nil {
		predicates = append(predicates, subcontrol.DelegateIDGTE(*i.DelegateIDGTE))
	}
	if i.DelegateIDLT != nil {
		predicates = append(predicates, subcontrol.DelegateIDLT(*i.DelegateIDLT))
	}
	if i.DelegateIDLTE != nil {
		predicates = append(predicates, subcontrol.DelegateIDLTE(*i.DelegateIDLTE))
	}
	if i.DelegateIDContains != nil {
		predicates = append(predicates, subcontrol.DelegateIDContains(*i.DelegateIDContains))
	}
	if i.DelegateIDHasPrefix != nil {
		predicates = append(predicates, subcontrol.DelegateIDHasPrefix(*i.DelegateIDHasPrefix))
	}
	if i.DelegateIDHasSuffix != nil {
		predicates = append(predicates, subcontrol.DelegateIDHasSuffix(*i.DelegateIDHasSuffix))
	}
	if i.DelegateIDIsNil {
		predicates = append(predicates, subcontrol.DelegateIDIsNil())
	}
	if i.DelegateIDNotNil {
		predicates = append(predicates, subcontrol.DelegateIDNotNil())
	}
	if i.DelegateIDEqualFold != nil {
		predicates = append(predicates, subcontrol.DelegateIDEqualFold(*i.DelegateIDEqualFold))
	}
	if i.DelegateIDContainsFold != nil {
		predicates = append(predicates, subcontrol.DelegateIDContainsFold(*i.DelegateIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, subcontrol.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, subcontrol.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, subcontrol.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, subcontrol.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, subcontrol.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, subcontrol.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, subcontrol.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, subcontrol.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, subcontrol.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, subcontrol.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, subcontrol.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, subcontrol.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, subcontrol.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, subcontrol.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, subcontrol.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.RefCode != nil {
		predicates = append(predicates, subcontrol.RefCodeEQ(*i.RefCode))
	}
	if i.RefCodeNEQ != nil {
		predicates = append(predicates, subcontrol.RefCodeNEQ(*i.RefCodeNEQ))
	}
	if len(i.RefCodeIn) > 0 {
		predicates = append(predicates, subcontrol.RefCodeIn(i.RefCodeIn...))
	}
	if len(i.RefCodeNotIn) > 0 {
		predicates = append(predicates, subcontrol.RefCodeNotIn(i.RefCodeNotIn...))
	}
	if i.RefCodeGT != nil {
		predicates = append(predicates, subcontrol.RefCodeGT(*i.RefCodeGT))
	}
	if i.RefCodeGTE != nil {
		predicates = append(predicates, subcontrol.RefCodeGTE(*i.RefCodeGTE))
	}
	if i.RefCodeLT != nil {
		predicates = append(predicates, subcontrol.RefCodeLT(*i.RefCodeLT))
	}
	if i.RefCodeLTE != nil {
		predicates = append(predicates, subcontrol.RefCodeLTE(*i.RefCodeLTE))
	}
	if i.RefCodeContains != nil {
		predicates = append(predicates, subcontrol.RefCodeContains(*i.RefCodeContains))
	}
	if i.RefCodeHasPrefix != nil {
		predicates = append(predicates, subcontrol.RefCodeHasPrefix(*i.RefCodeHasPrefix))
	}
	if i.RefCodeHasSuffix != nil {
		predicates = append(predicates, subcontrol.RefCodeHasSuffix(*i.RefCodeHasSuffix))
	}
	if i.RefCodeEqualFold != nil {
		predicates = append(predicates, subcontrol.RefCodeEqualFold(*i.RefCodeEqualFold))
	}
	if i.RefCodeContainsFold != nil {
		predicates = append(predicates, subcontrol.RefCodeContainsFold(*i.RefCodeContainsFold))
	}
	if i.ControlID != nil {
		predicates = append(predicates, subcontrol.ControlIDEQ(*i.ControlID))
	}
	if i.ControlIDNEQ != nil {
		predicates = append(predicates, subcontrol.ControlIDNEQ(*i.ControlIDNEQ))
	}
	if len(i.ControlIDIn) > 0 {
		predicates = append(predicates, subcontrol.ControlIDIn(i.ControlIDIn...))
	}
	if len(i.ControlIDNotIn) > 0 {
		predicates = append(predicates, subcontrol.ControlIDNotIn(i.ControlIDNotIn...))
	}
	if i.ControlIDGT != nil {
		predicates = append(predicates, subcontrol.ControlIDGT(*i.ControlIDGT))
	}
	if i.ControlIDGTE != nil {
		predicates = append(predicates, subcontrol.ControlIDGTE(*i.ControlIDGTE))
	}
	if i.ControlIDLT != nil {
		predicates = append(predicates, subcontrol.ControlIDLT(*i.ControlIDLT))
	}
	if i.ControlIDLTE != nil {
		predicates = append(predicates, subcontrol.ControlIDLTE(*i.ControlIDLTE))
	}
	if i.ControlIDContains != nil {
		predicates = append(predicates, subcontrol.ControlIDContains(*i.ControlIDContains))
	}
	if i.ControlIDHasPrefix != nil {
		predicates = append(predicates, subcontrol.ControlIDHasPrefix(*i.ControlIDHasPrefix))
	}
	if i.ControlIDHasSuffix != nil {
		predicates = append(predicates, subcontrol.ControlIDHasSuffix(*i.ControlIDHasSuffix))
	}
	if i.ControlIDEqualFold != nil {
		predicates = append(predicates, subcontrol.ControlIDEqualFold(*i.ControlIDEqualFold))
	}
	if i.ControlIDContainsFold != nil {
		predicates = append(predicates, subcontrol.ControlIDContainsFold(*i.ControlIDContainsFold))
	}

	if i.HasEvidence != nil {
		p := subcontrol.HasEvidence()
		if !*i.HasEvidence {
			p = subcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEvidenceWith) > 0 {
		with := make([]predicate.Evidence, 0, len(i.HasEvidenceWith))
		for _, w := range i.HasEvidenceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEvidenceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subcontrol.HasEvidenceWith(with...))
	}
	if i.HasControlObjectives != nil {
		p := subcontrol.HasControlObjectives()
		if !*i.HasControlObjectives {
			p = subcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlObjectivesWith) > 0 {
		with := make([]predicate.ControlObjective, 0, len(i.HasControlObjectivesWith))
		for _, w := range i.HasControlObjectivesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlObjectivesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subcontrol.HasControlObjectivesWith(with...))
	}
	if i.HasTasks != nil {
		p := subcontrol.HasTasks()
		if !*i.HasTasks {
			p = subcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subcontrol.HasTasksWith(with...))
	}
	if i.HasNarratives != nil {
		p := subcontrol.HasNarratives()
		if !*i.HasNarratives {
			p = subcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNarrativesWith) > 0 {
		with := make([]predicate.Narrative, 0, len(i.HasNarrativesWith))
		for _, w := range i.HasNarrativesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNarrativesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subcontrol.HasNarrativesWith(with...))
	}
	if i.HasRisks != nil {
		p := subcontrol.HasRisks()
		if !*i.HasRisks {
			p = subcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRisksWith) > 0 {
		with := make([]predicate.Risk, 0, len(i.HasRisksWith))
		for _, w := range i.HasRisksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRisksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subcontrol.HasRisksWith(with...))
	}
	if i.HasActionPlans != nil {
		p := subcontrol.HasActionPlans()
		if !*i.HasActionPlans {
			p = subcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionPlansWith) > 0 {
		with := make([]predicate.ActionPlan, 0, len(i.HasActionPlansWith))
		for _, w := range i.HasActionPlansWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionPlansWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subcontrol.HasActionPlansWith(with...))
	}
	if i.HasProcedures != nil {
		p := subcontrol.HasProcedures()
		if !*i.HasProcedures {
			p = subcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProceduresWith) > 0 {
		with := make([]predicate.Procedure, 0, len(i.HasProceduresWith))
		for _, w := range i.HasProceduresWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProceduresWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subcontrol.HasProceduresWith(with...))
	}
	if i.HasInternalPolicies != nil {
		p := subcontrol.HasInternalPolicies()
		if !*i.HasInternalPolicies {
			p = subcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInternalPoliciesWith) > 0 {
		with := make([]predicate.InternalPolicy, 0, len(i.HasInternalPoliciesWith))
		for _, w := range i.HasInternalPoliciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInternalPoliciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subcontrol.HasInternalPoliciesWith(with...))
	}
	if i.HasControlOwner != nil {
		p := subcontrol.HasControlOwner()
		if !*i.HasControlOwner {
			p = subcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlOwnerWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasControlOwnerWith))
		for _, w := range i.HasControlOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subcontrol.HasControlOwnerWith(with...))
	}
	if i.HasDelegate != nil {
		p := subcontrol.HasDelegate()
		if !*i.HasDelegate {
			p = subcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDelegateWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasDelegateWith))
		for _, w := range i.HasDelegateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDelegateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subcontrol.HasDelegateWith(with...))
	}
	if i.HasOwner != nil {
		p := subcontrol.HasOwner()
		if !*i.HasOwner {
			p = subcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subcontrol.HasOwnerWith(with...))
	}
	if i.HasControl != nil {
		p := subcontrol.HasControl()
		if !*i.HasControl {
			p = subcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasControlWith))
		for _, w := range i.HasControlWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subcontrol.HasControlWith(with...))
	}
	if i.HasControlImplementations != nil {
		p := subcontrol.HasControlImplementations()
		if !*i.HasControlImplementations {
			p = subcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlImplementationsWith) > 0 {
		with := make([]predicate.ControlImplementation, 0, len(i.HasControlImplementationsWith))
		for _, w := range i.HasControlImplementationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlImplementationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subcontrol.HasControlImplementationsWith(with...))
	}
	if i.HasScheduledJobs != nil {
		p := subcontrol.HasScheduledJobs()
		if !*i.HasScheduledJobs {
			p = subcontrol.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScheduledJobsWith) > 0 {
		with := make([]predicate.ControlScheduledJob, 0, len(i.HasScheduledJobsWith))
		for _, w := range i.HasScheduledJobsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasScheduledJobsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subcontrol.HasScheduledJobsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySubcontrolWhereInput
	case 1:
		return predicates[0], nil
	default:
		return subcontrol.And(predicates...), nil
	}
}

// SubcontrolHistoryWhereInput represents a where input for filtering SubcontrolHistory queries.
type SubcontrolHistoryWhereInput struct {
	Predicates []predicate.SubcontrolHistory  `json:"-"`
	Not        *SubcontrolHistoryWhereInput   `json:"not,omitempty"`
	Or         []*SubcontrolHistoryWhereInput `json:"or,omitempty"`
	And        []*SubcontrolHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "reference_id" field predicates.
	ReferenceID             *string  `json:"referenceID,omitempty"`
	ReferenceIDNEQ          *string  `json:"referenceIDNEQ,omitempty"`
	ReferenceIDIn           []string `json:"referenceIDIn,omitempty"`
	ReferenceIDNotIn        []string `json:"referenceIDNotIn,omitempty"`
	ReferenceIDGT           *string  `json:"referenceIDGT,omitempty"`
	ReferenceIDGTE          *string  `json:"referenceIDGTE,omitempty"`
	ReferenceIDLT           *string  `json:"referenceIDLT,omitempty"`
	ReferenceIDLTE          *string  `json:"referenceIDLTE,omitempty"`
	ReferenceIDContains     *string  `json:"referenceIDContains,omitempty"`
	ReferenceIDHasPrefix    *string  `json:"referenceIDHasPrefix,omitempty"`
	ReferenceIDHasSuffix    *string  `json:"referenceIDHasSuffix,omitempty"`
	ReferenceIDIsNil        bool     `json:"referenceIDIsNil,omitempty"`
	ReferenceIDNotNil       bool     `json:"referenceIDNotNil,omitempty"`
	ReferenceIDEqualFold    *string  `json:"referenceIDEqualFold,omitempty"`
	ReferenceIDContainsFold *string  `json:"referenceIDContainsFold,omitempty"`

	// "auditor_reference_id" field predicates.
	AuditorReferenceID             *string  `json:"auditorReferenceID,omitempty"`
	AuditorReferenceIDNEQ          *string  `json:"auditorReferenceIDNEQ,omitempty"`
	AuditorReferenceIDIn           []string `json:"auditorReferenceIDIn,omitempty"`
	AuditorReferenceIDNotIn        []string `json:"auditorReferenceIDNotIn,omitempty"`
	AuditorReferenceIDGT           *string  `json:"auditorReferenceIDGT,omitempty"`
	AuditorReferenceIDGTE          *string  `json:"auditorReferenceIDGTE,omitempty"`
	AuditorReferenceIDLT           *string  `json:"auditorReferenceIDLT,omitempty"`
	AuditorReferenceIDLTE          *string  `json:"auditorReferenceIDLTE,omitempty"`
	AuditorReferenceIDContains     *string  `json:"auditorReferenceIDContains,omitempty"`
	AuditorReferenceIDHasPrefix    *string  `json:"auditorReferenceIDHasPrefix,omitempty"`
	AuditorReferenceIDHasSuffix    *string  `json:"auditorReferenceIDHasSuffix,omitempty"`
	AuditorReferenceIDIsNil        bool     `json:"auditorReferenceIDIsNil,omitempty"`
	AuditorReferenceIDNotNil       bool     `json:"auditorReferenceIDNotNil,omitempty"`
	AuditorReferenceIDEqualFold    *string  `json:"auditorReferenceIDEqualFold,omitempty"`
	AuditorReferenceIDContainsFold *string  `json:"auditorReferenceIDContainsFold,omitempty"`

	// "status" field predicates.
	Status       *enums.ControlStatus  `json:"status,omitempty"`
	StatusNEQ    *enums.ControlStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.ControlStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.ControlStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil bool                  `json:"statusNotNil,omitempty"`

	// "source" field predicates.
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNEQ    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  bool                  `json:"sourceIsNil,omitempty"`
	SourceNotNil bool                  `json:"sourceNotNil,omitempty"`

	// "reference_framework" field predicates.
	ReferenceFramework             *string  `json:"referenceFramework,omitempty"`
	ReferenceFrameworkNEQ          *string  `json:"referenceFrameworkNEQ,omitempty"`
	ReferenceFrameworkIn           []string `json:"referenceFrameworkIn,omitempty"`
	ReferenceFrameworkNotIn        []string `json:"referenceFrameworkNotIn,omitempty"`
	ReferenceFrameworkGT           *string  `json:"referenceFrameworkGT,omitempty"`
	ReferenceFrameworkGTE          *string  `json:"referenceFrameworkGTE,omitempty"`
	ReferenceFrameworkLT           *string  `json:"referenceFrameworkLT,omitempty"`
	ReferenceFrameworkLTE          *string  `json:"referenceFrameworkLTE,omitempty"`
	ReferenceFrameworkContains     *string  `json:"referenceFrameworkContains,omitempty"`
	ReferenceFrameworkHasPrefix    *string  `json:"referenceFrameworkHasPrefix,omitempty"`
	ReferenceFrameworkHasSuffix    *string  `json:"referenceFrameworkHasSuffix,omitempty"`
	ReferenceFrameworkIsNil        bool     `json:"referenceFrameworkIsNil,omitempty"`
	ReferenceFrameworkNotNil       bool     `json:"referenceFrameworkNotNil,omitempty"`
	ReferenceFrameworkEqualFold    *string  `json:"referenceFrameworkEqualFold,omitempty"`
	ReferenceFrameworkContainsFold *string  `json:"referenceFrameworkContainsFold,omitempty"`

	// "control_type" field predicates.
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNEQ    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  bool                `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil bool                `json:"controlTypeNotNil,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        bool     `json:"categoryIsNil,omitempty"`
	CategoryNotNil       bool     `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "category_id" field predicates.
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIDNEQ          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIDGT           *string  `json:"categoryIDGT,omitempty"`
	CategoryIDGTE          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIDLT           *string  `json:"categoryIDLT,omitempty"`
	CategoryIDLTE          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        bool     `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       bool     `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`

	// "subcategory" field predicates.
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNEQ          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGT           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGTE          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLT           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLTE          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        bool     `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       bool     `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`

	// "control_owner_id" field predicates.
	ControlOwnerID             *string  `json:"controlOwnerID,omitempty"`
	ControlOwnerIDNEQ          *string  `json:"controlOwnerIDNEQ,omitempty"`
	ControlOwnerIDIn           []string `json:"controlOwnerIDIn,omitempty"`
	ControlOwnerIDNotIn        []string `json:"controlOwnerIDNotIn,omitempty"`
	ControlOwnerIDGT           *string  `json:"controlOwnerIDGT,omitempty"`
	ControlOwnerIDGTE          *string  `json:"controlOwnerIDGTE,omitempty"`
	ControlOwnerIDLT           *string  `json:"controlOwnerIDLT,omitempty"`
	ControlOwnerIDLTE          *string  `json:"controlOwnerIDLTE,omitempty"`
	ControlOwnerIDContains     *string  `json:"controlOwnerIDContains,omitempty"`
	ControlOwnerIDHasPrefix    *string  `json:"controlOwnerIDHasPrefix,omitempty"`
	ControlOwnerIDHasSuffix    *string  `json:"controlOwnerIDHasSuffix,omitempty"`
	ControlOwnerIDIsNil        bool     `json:"controlOwnerIDIsNil,omitempty"`
	ControlOwnerIDNotNil       bool     `json:"controlOwnerIDNotNil,omitempty"`
	ControlOwnerIDEqualFold    *string  `json:"controlOwnerIDEqualFold,omitempty"`
	ControlOwnerIDContainsFold *string  `json:"controlOwnerIDContainsFold,omitempty"`

	// "delegate_id" field predicates.
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIDNEQ          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIDGT           *string  `json:"delegateIDGT,omitempty"`
	DelegateIDGTE          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIDLT           *string  `json:"delegateIDLT,omitempty"`
	DelegateIDLTE          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        bool     `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       bool     `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "ref_code" field predicates.
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNEQ          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGT           *string  `json:"refCodeGT,omitempty"`
	RefCodeGTE          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLT           *string  `json:"refCodeLT,omitempty"`
	RefCodeLTE          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`

	// "control_id" field predicates.
	ControlID             *string  `json:"controlID,omitempty"`
	ControlIDNEQ          *string  `json:"controlIDNEQ,omitempty"`
	ControlIDIn           []string `json:"controlIDIn,omitempty"`
	ControlIDNotIn        []string `json:"controlIDNotIn,omitempty"`
	ControlIDGT           *string  `json:"controlIDGT,omitempty"`
	ControlIDGTE          *string  `json:"controlIDGTE,omitempty"`
	ControlIDLT           *string  `json:"controlIDLT,omitempty"`
	ControlIDLTE          *string  `json:"controlIDLTE,omitempty"`
	ControlIDContains     *string  `json:"controlIDContains,omitempty"`
	ControlIDHasPrefix    *string  `json:"controlIDHasPrefix,omitempty"`
	ControlIDHasSuffix    *string  `json:"controlIDHasSuffix,omitempty"`
	ControlIDEqualFold    *string  `json:"controlIDEqualFold,omitempty"`
	ControlIDContainsFold *string  `json:"controlIDContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SubcontrolHistoryWhereInput) AddPredicates(predicates ...predicate.SubcontrolHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SubcontrolHistoryWhereInput filter on the SubcontrolHistoryQuery builder.
func (i *SubcontrolHistoryWhereInput) Filter(q *SubcontrolHistoryQuery) (*SubcontrolHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySubcontrolHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySubcontrolHistoryWhereInput is returned in case the SubcontrolHistoryWhereInput is empty.
var ErrEmptySubcontrolHistoryWhereInput = errors.New("generated: empty predicate SubcontrolHistoryWhereInput")

// P returns a predicate for filtering subcontrolhistories.
// An error is returned if the input is empty or invalid.
func (i *SubcontrolHistoryWhereInput) P() (predicate.SubcontrolHistory, error) {
	var predicates []predicate.SubcontrolHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, subcontrolhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SubcontrolHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, subcontrolhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SubcontrolHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, subcontrolhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, subcontrolhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, subcontrolhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, subcontrolhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, subcontrolhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, subcontrolhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, subcontrolhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, subcontrolhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, subcontrolhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, subcontrolhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, subcontrolhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, subcontrolhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, subcontrolhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, subcontrolhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, subcontrolhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, subcontrolhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, subcontrolhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, subcontrolhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, subcontrolhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, subcontrolhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, subcontrolhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, subcontrolhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, subcontrolhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, subcontrolhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, subcontrolhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, subcontrolhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, subcontrolhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, subcontrolhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, subcontrolhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, subcontrolhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, subcontrolhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, subcontrolhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, subcontrolhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, subcontrolhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, subcontrolhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, subcontrolhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, subcontrolhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, subcontrolhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, subcontrolhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, subcontrolhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, subcontrolhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, subcontrolhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, subcontrolhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, subcontrolhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, subcontrolhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, subcontrolhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, subcontrolhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, subcontrolhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, subcontrolhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, subcontrolhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, subcontrolhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, subcontrolhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, subcontrolhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, subcontrolhistory.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, subcontrolhistory.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, subcontrolhistory.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, subcontrolhistory.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, subcontrolhistory.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, subcontrolhistory.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, subcontrolhistory.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, subcontrolhistory.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, subcontrolhistory.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, subcontrolhistory.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, subcontrolhistory.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, subcontrolhistory.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, subcontrolhistory.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, subcontrolhistory.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, subcontrolhistory.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, subcontrolhistory.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, subcontrolhistory.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, subcontrolhistory.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ReferenceID != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceIDEQ(*i.ReferenceID))
	}
	if i.ReferenceIDNEQ != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceIDNEQ(*i.ReferenceIDNEQ))
	}
	if len(i.ReferenceIDIn) > 0 {
		predicates = append(predicates, subcontrolhistory.ReferenceIDIn(i.ReferenceIDIn...))
	}
	if len(i.ReferenceIDNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.ReferenceIDNotIn(i.ReferenceIDNotIn...))
	}
	if i.ReferenceIDGT != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceIDGT(*i.ReferenceIDGT))
	}
	if i.ReferenceIDGTE != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceIDGTE(*i.ReferenceIDGTE))
	}
	if i.ReferenceIDLT != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceIDLT(*i.ReferenceIDLT))
	}
	if i.ReferenceIDLTE != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceIDLTE(*i.ReferenceIDLTE))
	}
	if i.ReferenceIDContains != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceIDContains(*i.ReferenceIDContains))
	}
	if i.ReferenceIDHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceIDHasPrefix(*i.ReferenceIDHasPrefix))
	}
	if i.ReferenceIDHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceIDHasSuffix(*i.ReferenceIDHasSuffix))
	}
	if i.ReferenceIDIsNil {
		predicates = append(predicates, subcontrolhistory.ReferenceIDIsNil())
	}
	if i.ReferenceIDNotNil {
		predicates = append(predicates, subcontrolhistory.ReferenceIDNotNil())
	}
	if i.ReferenceIDEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceIDEqualFold(*i.ReferenceIDEqualFold))
	}
	if i.ReferenceIDContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceIDContainsFold(*i.ReferenceIDContainsFold))
	}
	if i.AuditorReferenceID != nil {
		predicates = append(predicates, subcontrolhistory.AuditorReferenceIDEQ(*i.AuditorReferenceID))
	}
	if i.AuditorReferenceIDNEQ != nil {
		predicates = append(predicates, subcontrolhistory.AuditorReferenceIDNEQ(*i.AuditorReferenceIDNEQ))
	}
	if len(i.AuditorReferenceIDIn) > 0 {
		predicates = append(predicates, subcontrolhistory.AuditorReferenceIDIn(i.AuditorReferenceIDIn...))
	}
	if len(i.AuditorReferenceIDNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.AuditorReferenceIDNotIn(i.AuditorReferenceIDNotIn...))
	}
	if i.AuditorReferenceIDGT != nil {
		predicates = append(predicates, subcontrolhistory.AuditorReferenceIDGT(*i.AuditorReferenceIDGT))
	}
	if i.AuditorReferenceIDGTE != nil {
		predicates = append(predicates, subcontrolhistory.AuditorReferenceIDGTE(*i.AuditorReferenceIDGTE))
	}
	if i.AuditorReferenceIDLT != nil {
		predicates = append(predicates, subcontrolhistory.AuditorReferenceIDLT(*i.AuditorReferenceIDLT))
	}
	if i.AuditorReferenceIDLTE != nil {
		predicates = append(predicates, subcontrolhistory.AuditorReferenceIDLTE(*i.AuditorReferenceIDLTE))
	}
	if i.AuditorReferenceIDContains != nil {
		predicates = append(predicates, subcontrolhistory.AuditorReferenceIDContains(*i.AuditorReferenceIDContains))
	}
	if i.AuditorReferenceIDHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.AuditorReferenceIDHasPrefix(*i.AuditorReferenceIDHasPrefix))
	}
	if i.AuditorReferenceIDHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.AuditorReferenceIDHasSuffix(*i.AuditorReferenceIDHasSuffix))
	}
	if i.AuditorReferenceIDIsNil {
		predicates = append(predicates, subcontrolhistory.AuditorReferenceIDIsNil())
	}
	if i.AuditorReferenceIDNotNil {
		predicates = append(predicates, subcontrolhistory.AuditorReferenceIDNotNil())
	}
	if i.AuditorReferenceIDEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.AuditorReferenceIDEqualFold(*i.AuditorReferenceIDEqualFold))
	}
	if i.AuditorReferenceIDContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.AuditorReferenceIDContainsFold(*i.AuditorReferenceIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, subcontrolhistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, subcontrolhistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, subcontrolhistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, subcontrolhistory.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, subcontrolhistory.StatusNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, subcontrolhistory.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, subcontrolhistory.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, subcontrolhistory.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceIsNil {
		predicates = append(predicates, subcontrolhistory.SourceIsNil())
	}
	if i.SourceNotNil {
		predicates = append(predicates, subcontrolhistory.SourceNotNil())
	}
	if i.ReferenceFramework != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceFrameworkEQ(*i.ReferenceFramework))
	}
	if i.ReferenceFrameworkNEQ != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceFrameworkNEQ(*i.ReferenceFrameworkNEQ))
	}
	if len(i.ReferenceFrameworkIn) > 0 {
		predicates = append(predicates, subcontrolhistory.ReferenceFrameworkIn(i.ReferenceFrameworkIn...))
	}
	if len(i.ReferenceFrameworkNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.ReferenceFrameworkNotIn(i.ReferenceFrameworkNotIn...))
	}
	if i.ReferenceFrameworkGT != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceFrameworkGT(*i.ReferenceFrameworkGT))
	}
	if i.ReferenceFrameworkGTE != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceFrameworkGTE(*i.ReferenceFrameworkGTE))
	}
	if i.ReferenceFrameworkLT != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceFrameworkLT(*i.ReferenceFrameworkLT))
	}
	if i.ReferenceFrameworkLTE != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceFrameworkLTE(*i.ReferenceFrameworkLTE))
	}
	if i.ReferenceFrameworkContains != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceFrameworkContains(*i.ReferenceFrameworkContains))
	}
	if i.ReferenceFrameworkHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceFrameworkHasPrefix(*i.ReferenceFrameworkHasPrefix))
	}
	if i.ReferenceFrameworkHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceFrameworkHasSuffix(*i.ReferenceFrameworkHasSuffix))
	}
	if i.ReferenceFrameworkIsNil {
		predicates = append(predicates, subcontrolhistory.ReferenceFrameworkIsNil())
	}
	if i.ReferenceFrameworkNotNil {
		predicates = append(predicates, subcontrolhistory.ReferenceFrameworkNotNil())
	}
	if i.ReferenceFrameworkEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceFrameworkEqualFold(*i.ReferenceFrameworkEqualFold))
	}
	if i.ReferenceFrameworkContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.ReferenceFrameworkContainsFold(*i.ReferenceFrameworkContainsFold))
	}
	if i.ControlType != nil {
		predicates = append(predicates, subcontrolhistory.ControlTypeEQ(*i.ControlType))
	}
	if i.ControlTypeNEQ != nil {
		predicates = append(predicates, subcontrolhistory.ControlTypeNEQ(*i.ControlTypeNEQ))
	}
	if len(i.ControlTypeIn) > 0 {
		predicates = append(predicates, subcontrolhistory.ControlTypeIn(i.ControlTypeIn...))
	}
	if len(i.ControlTypeNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.ControlTypeNotIn(i.ControlTypeNotIn...))
	}
	if i.ControlTypeIsNil {
		predicates = append(predicates, subcontrolhistory.ControlTypeIsNil())
	}
	if i.ControlTypeNotNil {
		predicates = append(predicates, subcontrolhistory.ControlTypeNotNil())
	}
	if i.Category != nil {
		predicates = append(predicates, subcontrolhistory.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, subcontrolhistory.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, subcontrolhistory.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, subcontrolhistory.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, subcontrolhistory.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, subcontrolhistory.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, subcontrolhistory.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, subcontrolhistory.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryIsNil {
		predicates = append(predicates, subcontrolhistory.CategoryIsNil())
	}
	if i.CategoryNotNil {
		predicates = append(predicates, subcontrolhistory.CategoryNotNil())
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.CategoryID != nil {
		predicates = append(predicates, subcontrolhistory.CategoryIDEQ(*i.CategoryID))
	}
	if i.CategoryIDNEQ != nil {
		predicates = append(predicates, subcontrolhistory.CategoryIDNEQ(*i.CategoryIDNEQ))
	}
	if len(i.CategoryIDIn) > 0 {
		predicates = append(predicates, subcontrolhistory.CategoryIDIn(i.CategoryIDIn...))
	}
	if len(i.CategoryIDNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.CategoryIDNotIn(i.CategoryIDNotIn...))
	}
	if i.CategoryIDGT != nil {
		predicates = append(predicates, subcontrolhistory.CategoryIDGT(*i.CategoryIDGT))
	}
	if i.CategoryIDGTE != nil {
		predicates = append(predicates, subcontrolhistory.CategoryIDGTE(*i.CategoryIDGTE))
	}
	if i.CategoryIDLT != nil {
		predicates = append(predicates, subcontrolhistory.CategoryIDLT(*i.CategoryIDLT))
	}
	if i.CategoryIDLTE != nil {
		predicates = append(predicates, subcontrolhistory.CategoryIDLTE(*i.CategoryIDLTE))
	}
	if i.CategoryIDContains != nil {
		predicates = append(predicates, subcontrolhistory.CategoryIDContains(*i.CategoryIDContains))
	}
	if i.CategoryIDHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.CategoryIDHasPrefix(*i.CategoryIDHasPrefix))
	}
	if i.CategoryIDHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.CategoryIDHasSuffix(*i.CategoryIDHasSuffix))
	}
	if i.CategoryIDIsNil {
		predicates = append(predicates, subcontrolhistory.CategoryIDIsNil())
	}
	if i.CategoryIDNotNil {
		predicates = append(predicates, subcontrolhistory.CategoryIDNotNil())
	}
	if i.CategoryIDEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.CategoryIDEqualFold(*i.CategoryIDEqualFold))
	}
	if i.CategoryIDContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.CategoryIDContainsFold(*i.CategoryIDContainsFold))
	}
	if i.Subcategory != nil {
		predicates = append(predicates, subcontrolhistory.SubcategoryEQ(*i.Subcategory))
	}
	if i.SubcategoryNEQ != nil {
		predicates = append(predicates, subcontrolhistory.SubcategoryNEQ(*i.SubcategoryNEQ))
	}
	if len(i.SubcategoryIn) > 0 {
		predicates = append(predicates, subcontrolhistory.SubcategoryIn(i.SubcategoryIn...))
	}
	if len(i.SubcategoryNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.SubcategoryNotIn(i.SubcategoryNotIn...))
	}
	if i.SubcategoryGT != nil {
		predicates = append(predicates, subcontrolhistory.SubcategoryGT(*i.SubcategoryGT))
	}
	if i.SubcategoryGTE != nil {
		predicates = append(predicates, subcontrolhistory.SubcategoryGTE(*i.SubcategoryGTE))
	}
	if i.SubcategoryLT != nil {
		predicates = append(predicates, subcontrolhistory.SubcategoryLT(*i.SubcategoryLT))
	}
	if i.SubcategoryLTE != nil {
		predicates = append(predicates, subcontrolhistory.SubcategoryLTE(*i.SubcategoryLTE))
	}
	if i.SubcategoryContains != nil {
		predicates = append(predicates, subcontrolhistory.SubcategoryContains(*i.SubcategoryContains))
	}
	if i.SubcategoryHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.SubcategoryHasPrefix(*i.SubcategoryHasPrefix))
	}
	if i.SubcategoryHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.SubcategoryHasSuffix(*i.SubcategoryHasSuffix))
	}
	if i.SubcategoryIsNil {
		predicates = append(predicates, subcontrolhistory.SubcategoryIsNil())
	}
	if i.SubcategoryNotNil {
		predicates = append(predicates, subcontrolhistory.SubcategoryNotNil())
	}
	if i.SubcategoryEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.SubcategoryEqualFold(*i.SubcategoryEqualFold))
	}
	if i.SubcategoryContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.SubcategoryContainsFold(*i.SubcategoryContainsFold))
	}
	if i.ControlOwnerID != nil {
		predicates = append(predicates, subcontrolhistory.ControlOwnerIDEQ(*i.ControlOwnerID))
	}
	if i.ControlOwnerIDNEQ != nil {
		predicates = append(predicates, subcontrolhistory.ControlOwnerIDNEQ(*i.ControlOwnerIDNEQ))
	}
	if len(i.ControlOwnerIDIn) > 0 {
		predicates = append(predicates, subcontrolhistory.ControlOwnerIDIn(i.ControlOwnerIDIn...))
	}
	if len(i.ControlOwnerIDNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.ControlOwnerIDNotIn(i.ControlOwnerIDNotIn...))
	}
	if i.ControlOwnerIDGT != nil {
		predicates = append(predicates, subcontrolhistory.ControlOwnerIDGT(*i.ControlOwnerIDGT))
	}
	if i.ControlOwnerIDGTE != nil {
		predicates = append(predicates, subcontrolhistory.ControlOwnerIDGTE(*i.ControlOwnerIDGTE))
	}
	if i.ControlOwnerIDLT != nil {
		predicates = append(predicates, subcontrolhistory.ControlOwnerIDLT(*i.ControlOwnerIDLT))
	}
	if i.ControlOwnerIDLTE != nil {
		predicates = append(predicates, subcontrolhistory.ControlOwnerIDLTE(*i.ControlOwnerIDLTE))
	}
	if i.ControlOwnerIDContains != nil {
		predicates = append(predicates, subcontrolhistory.ControlOwnerIDContains(*i.ControlOwnerIDContains))
	}
	if i.ControlOwnerIDHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.ControlOwnerIDHasPrefix(*i.ControlOwnerIDHasPrefix))
	}
	if i.ControlOwnerIDHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.ControlOwnerIDHasSuffix(*i.ControlOwnerIDHasSuffix))
	}
	if i.ControlOwnerIDIsNil {
		predicates = append(predicates, subcontrolhistory.ControlOwnerIDIsNil())
	}
	if i.ControlOwnerIDNotNil {
		predicates = append(predicates, subcontrolhistory.ControlOwnerIDNotNil())
	}
	if i.ControlOwnerIDEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.ControlOwnerIDEqualFold(*i.ControlOwnerIDEqualFold))
	}
	if i.ControlOwnerIDContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.ControlOwnerIDContainsFold(*i.ControlOwnerIDContainsFold))
	}
	if i.DelegateID != nil {
		predicates = append(predicates, subcontrolhistory.DelegateIDEQ(*i.DelegateID))
	}
	if i.DelegateIDNEQ != nil {
		predicates = append(predicates, subcontrolhistory.DelegateIDNEQ(*i.DelegateIDNEQ))
	}
	if len(i.DelegateIDIn) > 0 {
		predicates = append(predicates, subcontrolhistory.DelegateIDIn(i.DelegateIDIn...))
	}
	if len(i.DelegateIDNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.DelegateIDNotIn(i.DelegateIDNotIn...))
	}
	if i.DelegateIDGT != nil {
		predicates = append(predicates, subcontrolhistory.DelegateIDGT(*i.DelegateIDGT))
	}
	if i.DelegateIDGTE != nil {
		predicates = append(predicates, subcontrolhistory.DelegateIDGTE(*i.DelegateIDGTE))
	}
	if i.DelegateIDLT != nil {
		predicates = append(predicates, subcontrolhistory.DelegateIDLT(*i.DelegateIDLT))
	}
	if i.DelegateIDLTE != nil {
		predicates = append(predicates, subcontrolhistory.DelegateIDLTE(*i.DelegateIDLTE))
	}
	if i.DelegateIDContains != nil {
		predicates = append(predicates, subcontrolhistory.DelegateIDContains(*i.DelegateIDContains))
	}
	if i.DelegateIDHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.DelegateIDHasPrefix(*i.DelegateIDHasPrefix))
	}
	if i.DelegateIDHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.DelegateIDHasSuffix(*i.DelegateIDHasSuffix))
	}
	if i.DelegateIDIsNil {
		predicates = append(predicates, subcontrolhistory.DelegateIDIsNil())
	}
	if i.DelegateIDNotNil {
		predicates = append(predicates, subcontrolhistory.DelegateIDNotNil())
	}
	if i.DelegateIDEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.DelegateIDEqualFold(*i.DelegateIDEqualFold))
	}
	if i.DelegateIDContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.DelegateIDContainsFold(*i.DelegateIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, subcontrolhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, subcontrolhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, subcontrolhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, subcontrolhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, subcontrolhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, subcontrolhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, subcontrolhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, subcontrolhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, subcontrolhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, subcontrolhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.RefCode != nil {
		predicates = append(predicates, subcontrolhistory.RefCodeEQ(*i.RefCode))
	}
	if i.RefCodeNEQ != nil {
		predicates = append(predicates, subcontrolhistory.RefCodeNEQ(*i.RefCodeNEQ))
	}
	if len(i.RefCodeIn) > 0 {
		predicates = append(predicates, subcontrolhistory.RefCodeIn(i.RefCodeIn...))
	}
	if len(i.RefCodeNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.RefCodeNotIn(i.RefCodeNotIn...))
	}
	if i.RefCodeGT != nil {
		predicates = append(predicates, subcontrolhistory.RefCodeGT(*i.RefCodeGT))
	}
	if i.RefCodeGTE != nil {
		predicates = append(predicates, subcontrolhistory.RefCodeGTE(*i.RefCodeGTE))
	}
	if i.RefCodeLT != nil {
		predicates = append(predicates, subcontrolhistory.RefCodeLT(*i.RefCodeLT))
	}
	if i.RefCodeLTE != nil {
		predicates = append(predicates, subcontrolhistory.RefCodeLTE(*i.RefCodeLTE))
	}
	if i.RefCodeContains != nil {
		predicates = append(predicates, subcontrolhistory.RefCodeContains(*i.RefCodeContains))
	}
	if i.RefCodeHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.RefCodeHasPrefix(*i.RefCodeHasPrefix))
	}
	if i.RefCodeHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.RefCodeHasSuffix(*i.RefCodeHasSuffix))
	}
	if i.RefCodeEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.RefCodeEqualFold(*i.RefCodeEqualFold))
	}
	if i.RefCodeContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.RefCodeContainsFold(*i.RefCodeContainsFold))
	}
	if i.ControlID != nil {
		predicates = append(predicates, subcontrolhistory.ControlIDEQ(*i.ControlID))
	}
	if i.ControlIDNEQ != nil {
		predicates = append(predicates, subcontrolhistory.ControlIDNEQ(*i.ControlIDNEQ))
	}
	if len(i.ControlIDIn) > 0 {
		predicates = append(predicates, subcontrolhistory.ControlIDIn(i.ControlIDIn...))
	}
	if len(i.ControlIDNotIn) > 0 {
		predicates = append(predicates, subcontrolhistory.ControlIDNotIn(i.ControlIDNotIn...))
	}
	if i.ControlIDGT != nil {
		predicates = append(predicates, subcontrolhistory.ControlIDGT(*i.ControlIDGT))
	}
	if i.ControlIDGTE != nil {
		predicates = append(predicates, subcontrolhistory.ControlIDGTE(*i.ControlIDGTE))
	}
	if i.ControlIDLT != nil {
		predicates = append(predicates, subcontrolhistory.ControlIDLT(*i.ControlIDLT))
	}
	if i.ControlIDLTE != nil {
		predicates = append(predicates, subcontrolhistory.ControlIDLTE(*i.ControlIDLTE))
	}
	if i.ControlIDContains != nil {
		predicates = append(predicates, subcontrolhistory.ControlIDContains(*i.ControlIDContains))
	}
	if i.ControlIDHasPrefix != nil {
		predicates = append(predicates, subcontrolhistory.ControlIDHasPrefix(*i.ControlIDHasPrefix))
	}
	if i.ControlIDHasSuffix != nil {
		predicates = append(predicates, subcontrolhistory.ControlIDHasSuffix(*i.ControlIDHasSuffix))
	}
	if i.ControlIDEqualFold != nil {
		predicates = append(predicates, subcontrolhistory.ControlIDEqualFold(*i.ControlIDEqualFold))
	}
	if i.ControlIDContainsFold != nil {
		predicates = append(predicates, subcontrolhistory.ControlIDContainsFold(*i.ControlIDContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptySubcontrolHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return subcontrolhistory.And(predicates...), nil
	}
}

// SubscriberWhereInput represents a where input for filtering Subscriber queries.
type SubscriberWhereInput struct {
	Predicates []predicate.Subscriber  `json:"-"`
	Not        *SubscriberWhereInput   `json:"not,omitempty"`
	Or         []*SubscriberWhereInput `json:"or,omitempty"`
	And        []*SubscriberWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "phone_number" field predicates.
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNEQ          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGT           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGTE          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLT           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLTE          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        bool     `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       bool     `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`

	// "verified_email" field predicates.
	VerifiedEmail    *bool `json:"verifiedEmail,omitempty"`
	VerifiedEmailNEQ *bool `json:"verifiedEmailNEQ,omitempty"`

	// "verified_phone" field predicates.
	VerifiedPhone    *bool `json:"verifiedPhone,omitempty"`
	VerifiedPhoneNEQ *bool `json:"verifiedPhoneNEQ,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "unsubscribed" field predicates.
	Unsubscribed    *bool `json:"unsubscribed,omitempty"`
	UnsubscribedNEQ *bool `json:"unsubscribedNEQ,omitempty"`

	// "send_attempts" field predicates.
	SendAttempts      *int  `json:"sendAttempts,omitempty"`
	SendAttemptsNEQ   *int  `json:"sendAttemptsNEQ,omitempty"`
	SendAttemptsIn    []int `json:"sendAttemptsIn,omitempty"`
	SendAttemptsNotIn []int `json:"sendAttemptsNotIn,omitempty"`
	SendAttemptsGT    *int  `json:"sendAttemptsGT,omitempty"`
	SendAttemptsGTE   *int  `json:"sendAttemptsGTE,omitempty"`
	SendAttemptsLT    *int  `json:"sendAttemptsLT,omitempty"`
	SendAttemptsLTE   *int  `json:"sendAttemptsLTE,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "events" edge predicates.
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SubscriberWhereInput) AddPredicates(predicates ...predicate.Subscriber) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SubscriberWhereInput filter on the SubscriberQuery builder.
func (i *SubscriberWhereInput) Filter(q *SubscriberQuery) (*SubscriberQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySubscriberWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySubscriberWhereInput is returned in case the SubscriberWhereInput is empty.
var ErrEmptySubscriberWhereInput = errors.New("generated: empty predicate SubscriberWhereInput")

// P returns a predicate for filtering subscribers.
// An error is returned if the input is empty or invalid.
func (i *SubscriberWhereInput) P() (predicate.Subscriber, error) {
	var predicates []predicate.Subscriber
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, subscriber.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Subscriber, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, subscriber.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Subscriber, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, subscriber.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, subscriber.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, subscriber.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, subscriber.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, subscriber.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, subscriber.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, subscriber.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, subscriber.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, subscriber.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, subscriber.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, subscriber.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, subscriber.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, subscriber.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, subscriber.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, subscriber.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, subscriber.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, subscriber.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, subscriber.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, subscriber.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, subscriber.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, subscriber.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, subscriber.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, subscriber.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, subscriber.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, subscriber.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, subscriber.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, subscriber.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, subscriber.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, subscriber.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, subscriber.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, subscriber.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, subscriber.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, subscriber.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, subscriber.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, subscriber.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, subscriber.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, subscriber.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, subscriber.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, subscriber.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, subscriber.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, subscriber.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, subscriber.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, subscriber.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, subscriber.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, subscriber.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, subscriber.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, subscriber.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, subscriber.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, subscriber.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, subscriber.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, subscriber.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, subscriber.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, subscriber.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, subscriber.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, subscriber.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, subscriber.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, subscriber.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, subscriber.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, subscriber.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, subscriber.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, subscriber.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, subscriber.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, subscriber.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, subscriber.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, subscriber.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, subscriber.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, subscriber.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, subscriber.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, subscriber.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, subscriber.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, subscriber.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, subscriber.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, subscriber.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, subscriber.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, subscriber.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, subscriber.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, subscriber.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, subscriber.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, subscriber.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, subscriber.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, subscriber.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, subscriber.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, subscriber.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, subscriber.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, subscriber.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, subscriber.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, subscriber.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, subscriber.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, subscriber.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.PhoneNumber != nil {
		predicates = append(predicates, subscriber.PhoneNumberEQ(*i.PhoneNumber))
	}
	if i.PhoneNumberNEQ != nil {
		predicates = append(predicates, subscriber.PhoneNumberNEQ(*i.PhoneNumberNEQ))
	}
	if len(i.PhoneNumberIn) > 0 {
		predicates = append(predicates, subscriber.PhoneNumberIn(i.PhoneNumberIn...))
	}
	if len(i.PhoneNumberNotIn) > 0 {
		predicates = append(predicates, subscriber.PhoneNumberNotIn(i.PhoneNumberNotIn...))
	}
	if i.PhoneNumberGT != nil {
		predicates = append(predicates, subscriber.PhoneNumberGT(*i.PhoneNumberGT))
	}
	if i.PhoneNumberGTE != nil {
		predicates = append(predicates, subscriber.PhoneNumberGTE(*i.PhoneNumberGTE))
	}
	if i.PhoneNumberLT != nil {
		predicates = append(predicates, subscriber.PhoneNumberLT(*i.PhoneNumberLT))
	}
	if i.PhoneNumberLTE != nil {
		predicates = append(predicates, subscriber.PhoneNumberLTE(*i.PhoneNumberLTE))
	}
	if i.PhoneNumberContains != nil {
		predicates = append(predicates, subscriber.PhoneNumberContains(*i.PhoneNumberContains))
	}
	if i.PhoneNumberHasPrefix != nil {
		predicates = append(predicates, subscriber.PhoneNumberHasPrefix(*i.PhoneNumberHasPrefix))
	}
	if i.PhoneNumberHasSuffix != nil {
		predicates = append(predicates, subscriber.PhoneNumberHasSuffix(*i.PhoneNumberHasSuffix))
	}
	if i.PhoneNumberIsNil {
		predicates = append(predicates, subscriber.PhoneNumberIsNil())
	}
	if i.PhoneNumberNotNil {
		predicates = append(predicates, subscriber.PhoneNumberNotNil())
	}
	if i.PhoneNumberEqualFold != nil {
		predicates = append(predicates, subscriber.PhoneNumberEqualFold(*i.PhoneNumberEqualFold))
	}
	if i.PhoneNumberContainsFold != nil {
		predicates = append(predicates, subscriber.PhoneNumberContainsFold(*i.PhoneNumberContainsFold))
	}
	if i.VerifiedEmail != nil {
		predicates = append(predicates, subscriber.VerifiedEmailEQ(*i.VerifiedEmail))
	}
	if i.VerifiedEmailNEQ != nil {
		predicates = append(predicates, subscriber.VerifiedEmailNEQ(*i.VerifiedEmailNEQ))
	}
	if i.VerifiedPhone != nil {
		predicates = append(predicates, subscriber.VerifiedPhoneEQ(*i.VerifiedPhone))
	}
	if i.VerifiedPhoneNEQ != nil {
		predicates = append(predicates, subscriber.VerifiedPhoneNEQ(*i.VerifiedPhoneNEQ))
	}
	if i.Active != nil {
		predicates = append(predicates, subscriber.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, subscriber.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.Unsubscribed != nil {
		predicates = append(predicates, subscriber.UnsubscribedEQ(*i.Unsubscribed))
	}
	if i.UnsubscribedNEQ != nil {
		predicates = append(predicates, subscriber.UnsubscribedNEQ(*i.UnsubscribedNEQ))
	}
	if i.SendAttempts != nil {
		predicates = append(predicates, subscriber.SendAttemptsEQ(*i.SendAttempts))
	}
	if i.SendAttemptsNEQ != nil {
		predicates = append(predicates, subscriber.SendAttemptsNEQ(*i.SendAttemptsNEQ))
	}
	if len(i.SendAttemptsIn) > 0 {
		predicates = append(predicates, subscriber.SendAttemptsIn(i.SendAttemptsIn...))
	}
	if len(i.SendAttemptsNotIn) > 0 {
		predicates = append(predicates, subscriber.SendAttemptsNotIn(i.SendAttemptsNotIn...))
	}
	if i.SendAttemptsGT != nil {
		predicates = append(predicates, subscriber.SendAttemptsGT(*i.SendAttemptsGT))
	}
	if i.SendAttemptsGTE != nil {
		predicates = append(predicates, subscriber.SendAttemptsGTE(*i.SendAttemptsGTE))
	}
	if i.SendAttemptsLT != nil {
		predicates = append(predicates, subscriber.SendAttemptsLT(*i.SendAttemptsLT))
	}
	if i.SendAttemptsLTE != nil {
		predicates = append(predicates, subscriber.SendAttemptsLTE(*i.SendAttemptsLTE))
	}

	if i.HasOwner != nil {
		p := subscriber.HasOwner()
		if !*i.HasOwner {
			p = subscriber.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subscriber.HasOwnerWith(with...))
	}
	if i.HasEvents != nil {
		p := subscriber.HasEvents()
		if !*i.HasEvents {
			p = subscriber.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventsWith) > 0 {
		with := make([]predicate.Event, 0, len(i.HasEventsWith))
		for _, w := range i.HasEventsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subscriber.HasEventsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySubscriberWhereInput
	case 1:
		return predicates[0], nil
	default:
		return subscriber.And(predicates...), nil
	}
}

// TFASettingWhereInput represents a where input for filtering TFASetting queries.
type TFASettingWhereInput struct {
	Predicates []predicate.TFASetting  `json:"-"`
	Not        *TFASettingWhereInput   `json:"not,omitempty"`
	Or         []*TFASettingWhereInput `json:"or,omitempty"`
	And        []*TFASettingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "verified" field predicates.
	Verified    *bool `json:"verified,omitempty"`
	VerifiedNEQ *bool `json:"verifiedNEQ,omitempty"`

	// "totp_allowed" field predicates.
	TotpAllowed       *bool `json:"totpAllowed,omitempty"`
	TotpAllowedNEQ    *bool `json:"totpAllowedNEQ,omitempty"`
	TotpAllowedIsNil  bool  `json:"totpAllowedIsNil,omitempty"`
	TotpAllowedNotNil bool  `json:"totpAllowedNotNil,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TFASettingWhereInput) AddPredicates(predicates ...predicate.TFASetting) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TFASettingWhereInput filter on the TFASettingQuery builder.
func (i *TFASettingWhereInput) Filter(q *TFASettingQuery) (*TFASettingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTFASettingWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTFASettingWhereInput is returned in case the TFASettingWhereInput is empty.
var ErrEmptyTFASettingWhereInput = errors.New("generated: empty predicate TFASettingWhereInput")

// P returns a predicate for filtering tfasettings.
// An error is returned if the input is empty or invalid.
func (i *TFASettingWhereInput) P() (predicate.TFASetting, error) {
	var predicates []predicate.TFASetting
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, tfasetting.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TFASetting, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, tfasetting.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TFASetting, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, tfasetting.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, tfasetting.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tfasetting.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tfasetting.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tfasetting.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tfasetting.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tfasetting.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tfasetting.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tfasetting.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, tfasetting.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, tfasetting.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, tfasetting.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, tfasetting.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, tfasetting.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, tfasetting.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, tfasetting.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, tfasetting.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, tfasetting.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, tfasetting.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, tfasetting.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, tfasetting.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, tfasetting.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, tfasetting.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, tfasetting.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, tfasetting.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, tfasetting.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, tfasetting.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, tfasetting.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, tfasetting.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, tfasetting.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, tfasetting.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, tfasetting.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, tfasetting.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, tfasetting.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, tfasetting.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, tfasetting.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, tfasetting.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, tfasetting.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, tfasetting.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, tfasetting.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, tfasetting.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, tfasetting.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, tfasetting.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, tfasetting.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, tfasetting.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, tfasetting.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, tfasetting.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, tfasetting.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, tfasetting.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, tfasetting.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, tfasetting.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, tfasetting.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, tfasetting.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, tfasetting.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, tfasetting.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, tfasetting.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, tfasetting.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, tfasetting.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, tfasetting.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, tfasetting.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, tfasetting.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Verified != nil {
		predicates = append(predicates, tfasetting.VerifiedEQ(*i.Verified))
	}
	if i.VerifiedNEQ != nil {
		predicates = append(predicates, tfasetting.VerifiedNEQ(*i.VerifiedNEQ))
	}
	if i.TotpAllowed != nil {
		predicates = append(predicates, tfasetting.TotpAllowedEQ(*i.TotpAllowed))
	}
	if i.TotpAllowedNEQ != nil {
		predicates = append(predicates, tfasetting.TotpAllowedNEQ(*i.TotpAllowedNEQ))
	}
	if i.TotpAllowedIsNil {
		predicates = append(predicates, tfasetting.TotpAllowedIsNil())
	}
	if i.TotpAllowedNotNil {
		predicates = append(predicates, tfasetting.TotpAllowedNotNil())
	}

	if i.HasOwner != nil {
		p := tfasetting.HasOwner()
		if !*i.HasOwner {
			p = tfasetting.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tfasetting.HasOwnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTFASettingWhereInput
	case 1:
		return predicates[0], nil
	default:
		return tfasetting.And(predicates...), nil
	}
}

// TaskWhereInput represents a where input for filtering Task queries.
type TaskWhereInput struct {
	Predicates []predicate.Task  `json:"-"`
	Not        *TaskWhereInput   `json:"not,omitempty"`
	Or         []*TaskWhereInput `json:"or,omitempty"`
	And        []*TaskWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "details" field predicates.
	Details             *string  `json:"details,omitempty"`
	DetailsNEQ          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGT           *string  `json:"detailsGT,omitempty"`
	DetailsGTE          *string  `json:"detailsGTE,omitempty"`
	DetailsLT           *string  `json:"detailsLT,omitempty"`
	DetailsLTE          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        bool     `json:"detailsIsNil,omitempty"`
	DetailsNotNil       bool     `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`

	// "status" field predicates.
	Status      *enums.TaskStatus  `json:"status,omitempty"`
	StatusNEQ   *enums.TaskStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.TaskStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.TaskStatus `json:"statusNotIn,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        bool     `json:"categoryIsNil,omitempty"`
	CategoryNotNil       bool     `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "due" field predicates.
	Due       *models.DateTime  `json:"due,omitempty"`
	DueNEQ    *models.DateTime  `json:"dueNEQ,omitempty"`
	DueIn     []models.DateTime `json:"dueIn,omitempty"`
	DueNotIn  []models.DateTime `json:"dueNotIn,omitempty"`
	DueGT     *models.DateTime  `json:"dueGT,omitempty"`
	DueGTE    *models.DateTime  `json:"dueGTE,omitempty"`
	DueLT     *models.DateTime  `json:"dueLT,omitempty"`
	DueLTE    *models.DateTime  `json:"dueLTE,omitempty"`
	DueIsNil  bool              `json:"dueIsNil,omitempty"`
	DueNotNil bool              `json:"dueNotNil,omitempty"`

	// "completed" field predicates.
	Completed       *models.DateTime  `json:"completed,omitempty"`
	CompletedNEQ    *models.DateTime  `json:"completedNEQ,omitempty"`
	CompletedIn     []models.DateTime `json:"completedIn,omitempty"`
	CompletedNotIn  []models.DateTime `json:"completedNotIn,omitempty"`
	CompletedGT     *models.DateTime  `json:"completedGT,omitempty"`
	CompletedGTE    *models.DateTime  `json:"completedGTE,omitempty"`
	CompletedLT     *models.DateTime  `json:"completedLT,omitempty"`
	CompletedLTE    *models.DateTime  `json:"completedLTE,omitempty"`
	CompletedIsNil  bool              `json:"completedIsNil,omitempty"`
	CompletedNotNil bool              `json:"completedNotNil,omitempty"`

	// "assignee_id" field predicates.
	AssigneeID             *string  `json:"assigneeID,omitempty"`
	AssigneeIDNEQ          *string  `json:"assigneeIDNEQ,omitempty"`
	AssigneeIDIn           []string `json:"assigneeIDIn,omitempty"`
	AssigneeIDNotIn        []string `json:"assigneeIDNotIn,omitempty"`
	AssigneeIDGT           *string  `json:"assigneeIDGT,omitempty"`
	AssigneeIDGTE          *string  `json:"assigneeIDGTE,omitempty"`
	AssigneeIDLT           *string  `json:"assigneeIDLT,omitempty"`
	AssigneeIDLTE          *string  `json:"assigneeIDLTE,omitempty"`
	AssigneeIDContains     *string  `json:"assigneeIDContains,omitempty"`
	AssigneeIDHasPrefix    *string  `json:"assigneeIDHasPrefix,omitempty"`
	AssigneeIDHasSuffix    *string  `json:"assigneeIDHasSuffix,omitempty"`
	AssigneeIDIsNil        bool     `json:"assigneeIDIsNil,omitempty"`
	AssigneeIDNotNil       bool     `json:"assigneeIDNotNil,omitempty"`
	AssigneeIDEqualFold    *string  `json:"assigneeIDEqualFold,omitempty"`
	AssigneeIDContainsFold *string  `json:"assigneeIDContainsFold,omitempty"`

	// "assigner_id" field predicates.
	AssignerID             *string  `json:"assignerID,omitempty"`
	AssignerIDNEQ          *string  `json:"assignerIDNEQ,omitempty"`
	AssignerIDIn           []string `json:"assignerIDIn,omitempty"`
	AssignerIDNotIn        []string `json:"assignerIDNotIn,omitempty"`
	AssignerIDGT           *string  `json:"assignerIDGT,omitempty"`
	AssignerIDGTE          *string  `json:"assignerIDGTE,omitempty"`
	AssignerIDLT           *string  `json:"assignerIDLT,omitempty"`
	AssignerIDLTE          *string  `json:"assignerIDLTE,omitempty"`
	AssignerIDContains     *string  `json:"assignerIDContains,omitempty"`
	AssignerIDHasPrefix    *string  `json:"assignerIDHasPrefix,omitempty"`
	AssignerIDHasSuffix    *string  `json:"assignerIDHasSuffix,omitempty"`
	AssignerIDIsNil        bool     `json:"assignerIDIsNil,omitempty"`
	AssignerIDNotNil       bool     `json:"assignerIDNotNil,omitempty"`
	AssignerIDEqualFold    *string  `json:"assignerIDEqualFold,omitempty"`
	AssignerIDContainsFold *string  `json:"assignerIDContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "assigner" edge predicates.
	HasAssigner     *bool             `json:"hasAssigner,omitempty"`
	HasAssignerWith []*UserWhereInput `json:"hasAssignerWith,omitempty"`

	// "assignee" edge predicates.
	HasAssignee     *bool             `json:"hasAssignee,omitempty"`
	HasAssigneeWith []*UserWhereInput `json:"hasAssigneeWith,omitempty"`

	// "comments" edge predicates.
	HasComments     *bool             `json:"hasComments,omitempty"`
	HasCommentsWith []*NoteWhereInput `json:"hasCommentsWith,omitempty"`

	// "groups" edge predicates.
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`

	// "internal_policies" edge predicates.
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`

	// "procedures" edge predicates.
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`

	// "controls" edge predicates.
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`

	// "subcontrols" edge predicates.
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`

	// "control_objectives" edge predicates.
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`

	// "programs" edge predicates.
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`

	// "risks" edge predicates.
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`

	// "evidence" edge predicates.
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TaskWhereInput) AddPredicates(predicates ...predicate.Task) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TaskWhereInput filter on the TaskQuery builder.
func (i *TaskWhereInput) Filter(q *TaskQuery) (*TaskQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTaskWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTaskWhereInput is returned in case the TaskWhereInput is empty.
var ErrEmptyTaskWhereInput = errors.New("generated: empty predicate TaskWhereInput")

// P returns a predicate for filtering tasks.
// An error is returned if the input is empty or invalid.
func (i *TaskWhereInput) P() (predicate.Task, error) {
	var predicates []predicate.Task
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, task.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Task, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, task.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Task, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, task.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, task.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, task.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, task.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, task.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, task.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, task.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, task.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, task.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, task.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, task.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, task.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, task.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, task.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, task.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, task.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, task.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, task.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, task.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, task.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, task.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, task.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, task.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, task.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, task.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, task.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, task.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, task.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, task.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, task.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, task.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, task.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, task.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, task.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, task.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, task.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, task.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, task.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, task.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, task.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, task.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, task.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, task.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, task.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, task.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, task.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, task.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, task.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, task.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, task.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, task.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, task.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, task.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, task.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, task.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, task.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, task.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, task.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, task.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, task.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, task.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, task.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, task.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, task.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, task.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, task.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, task.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, task.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, task.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, task.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, task.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, task.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, task.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, task.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, task.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, task.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, task.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, task.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, task.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, task.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, task.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, task.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, task.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, task.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, task.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, task.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, task.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, task.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, task.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, task.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, task.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, task.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, task.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, task.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, task.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, task.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, task.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, task.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, task.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, task.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, task.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, task.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Details != nil {
		predicates = append(predicates, task.DetailsEQ(*i.Details))
	}
	if i.DetailsNEQ != nil {
		predicates = append(predicates, task.DetailsNEQ(*i.DetailsNEQ))
	}
	if len(i.DetailsIn) > 0 {
		predicates = append(predicates, task.DetailsIn(i.DetailsIn...))
	}
	if len(i.DetailsNotIn) > 0 {
		predicates = append(predicates, task.DetailsNotIn(i.DetailsNotIn...))
	}
	if i.DetailsGT != nil {
		predicates = append(predicates, task.DetailsGT(*i.DetailsGT))
	}
	if i.DetailsGTE != nil {
		predicates = append(predicates, task.DetailsGTE(*i.DetailsGTE))
	}
	if i.DetailsLT != nil {
		predicates = append(predicates, task.DetailsLT(*i.DetailsLT))
	}
	if i.DetailsLTE != nil {
		predicates = append(predicates, task.DetailsLTE(*i.DetailsLTE))
	}
	if i.DetailsContains != nil {
		predicates = append(predicates, task.DetailsContains(*i.DetailsContains))
	}
	if i.DetailsHasPrefix != nil {
		predicates = append(predicates, task.DetailsHasPrefix(*i.DetailsHasPrefix))
	}
	if i.DetailsHasSuffix != nil {
		predicates = append(predicates, task.DetailsHasSuffix(*i.DetailsHasSuffix))
	}
	if i.DetailsIsNil {
		predicates = append(predicates, task.DetailsIsNil())
	}
	if i.DetailsNotNil {
		predicates = append(predicates, task.DetailsNotNil())
	}
	if i.DetailsEqualFold != nil {
		predicates = append(predicates, task.DetailsEqualFold(*i.DetailsEqualFold))
	}
	if i.DetailsContainsFold != nil {
		predicates = append(predicates, task.DetailsContainsFold(*i.DetailsContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, task.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, task.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, task.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, task.StatusNotIn(i.StatusNotIn...))
	}
	if i.Category != nil {
		predicates = append(predicates, task.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, task.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, task.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, task.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, task.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, task.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, task.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, task.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, task.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, task.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, task.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryIsNil {
		predicates = append(predicates, task.CategoryIsNil())
	}
	if i.CategoryNotNil {
		predicates = append(predicates, task.CategoryNotNil())
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, task.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, task.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.Due != nil {
		predicates = append(predicates, task.DueEQ(*i.Due))
	}
	if i.DueNEQ != nil {
		predicates = append(predicates, task.DueNEQ(*i.DueNEQ))
	}
	if len(i.DueIn) > 0 {
		predicates = append(predicates, task.DueIn(i.DueIn...))
	}
	if len(i.DueNotIn) > 0 {
		predicates = append(predicates, task.DueNotIn(i.DueNotIn...))
	}
	if i.DueGT != nil {
		predicates = append(predicates, task.DueGT(*i.DueGT))
	}
	if i.DueGTE != nil {
		predicates = append(predicates, task.DueGTE(*i.DueGTE))
	}
	if i.DueLT != nil {
		predicates = append(predicates, task.DueLT(*i.DueLT))
	}
	if i.DueLTE != nil {
		predicates = append(predicates, task.DueLTE(*i.DueLTE))
	}
	if i.DueIsNil {
		predicates = append(predicates, task.DueIsNil())
	}
	if i.DueNotNil {
		predicates = append(predicates, task.DueNotNil())
	}
	if i.Completed != nil {
		predicates = append(predicates, task.CompletedEQ(*i.Completed))
	}
	if i.CompletedNEQ != nil {
		predicates = append(predicates, task.CompletedNEQ(*i.CompletedNEQ))
	}
	if len(i.CompletedIn) > 0 {
		predicates = append(predicates, task.CompletedIn(i.CompletedIn...))
	}
	if len(i.CompletedNotIn) > 0 {
		predicates = append(predicates, task.CompletedNotIn(i.CompletedNotIn...))
	}
	if i.CompletedGT != nil {
		predicates = append(predicates, task.CompletedGT(*i.CompletedGT))
	}
	if i.CompletedGTE != nil {
		predicates = append(predicates, task.CompletedGTE(*i.CompletedGTE))
	}
	if i.CompletedLT != nil {
		predicates = append(predicates, task.CompletedLT(*i.CompletedLT))
	}
	if i.CompletedLTE != nil {
		predicates = append(predicates, task.CompletedLTE(*i.CompletedLTE))
	}
	if i.CompletedIsNil {
		predicates = append(predicates, task.CompletedIsNil())
	}
	if i.CompletedNotNil {
		predicates = append(predicates, task.CompletedNotNil())
	}
	if i.AssigneeID != nil {
		predicates = append(predicates, task.AssigneeIDEQ(*i.AssigneeID))
	}
	if i.AssigneeIDNEQ != nil {
		predicates = append(predicates, task.AssigneeIDNEQ(*i.AssigneeIDNEQ))
	}
	if len(i.AssigneeIDIn) > 0 {
		predicates = append(predicates, task.AssigneeIDIn(i.AssigneeIDIn...))
	}
	if len(i.AssigneeIDNotIn) > 0 {
		predicates = append(predicates, task.AssigneeIDNotIn(i.AssigneeIDNotIn...))
	}
	if i.AssigneeIDGT != nil {
		predicates = append(predicates, task.AssigneeIDGT(*i.AssigneeIDGT))
	}
	if i.AssigneeIDGTE != nil {
		predicates = append(predicates, task.AssigneeIDGTE(*i.AssigneeIDGTE))
	}
	if i.AssigneeIDLT != nil {
		predicates = append(predicates, task.AssigneeIDLT(*i.AssigneeIDLT))
	}
	if i.AssigneeIDLTE != nil {
		predicates = append(predicates, task.AssigneeIDLTE(*i.AssigneeIDLTE))
	}
	if i.AssigneeIDContains != nil {
		predicates = append(predicates, task.AssigneeIDContains(*i.AssigneeIDContains))
	}
	if i.AssigneeIDHasPrefix != nil {
		predicates = append(predicates, task.AssigneeIDHasPrefix(*i.AssigneeIDHasPrefix))
	}
	if i.AssigneeIDHasSuffix != nil {
		predicates = append(predicates, task.AssigneeIDHasSuffix(*i.AssigneeIDHasSuffix))
	}
	if i.AssigneeIDIsNil {
		predicates = append(predicates, task.AssigneeIDIsNil())
	}
	if i.AssigneeIDNotNil {
		predicates = append(predicates, task.AssigneeIDNotNil())
	}
	if i.AssigneeIDEqualFold != nil {
		predicates = append(predicates, task.AssigneeIDEqualFold(*i.AssigneeIDEqualFold))
	}
	if i.AssigneeIDContainsFold != nil {
		predicates = append(predicates, task.AssigneeIDContainsFold(*i.AssigneeIDContainsFold))
	}
	if i.AssignerID != nil {
		predicates = append(predicates, task.AssignerIDEQ(*i.AssignerID))
	}
	if i.AssignerIDNEQ != nil {
		predicates = append(predicates, task.AssignerIDNEQ(*i.AssignerIDNEQ))
	}
	if len(i.AssignerIDIn) > 0 {
		predicates = append(predicates, task.AssignerIDIn(i.AssignerIDIn...))
	}
	if len(i.AssignerIDNotIn) > 0 {
		predicates = append(predicates, task.AssignerIDNotIn(i.AssignerIDNotIn...))
	}
	if i.AssignerIDGT != nil {
		predicates = append(predicates, task.AssignerIDGT(*i.AssignerIDGT))
	}
	if i.AssignerIDGTE != nil {
		predicates = append(predicates, task.AssignerIDGTE(*i.AssignerIDGTE))
	}
	if i.AssignerIDLT != nil {
		predicates = append(predicates, task.AssignerIDLT(*i.AssignerIDLT))
	}
	if i.AssignerIDLTE != nil {
		predicates = append(predicates, task.AssignerIDLTE(*i.AssignerIDLTE))
	}
	if i.AssignerIDContains != nil {
		predicates = append(predicates, task.AssignerIDContains(*i.AssignerIDContains))
	}
	if i.AssignerIDHasPrefix != nil {
		predicates = append(predicates, task.AssignerIDHasPrefix(*i.AssignerIDHasPrefix))
	}
	if i.AssignerIDHasSuffix != nil {
		predicates = append(predicates, task.AssignerIDHasSuffix(*i.AssignerIDHasSuffix))
	}
	if i.AssignerIDIsNil {
		predicates = append(predicates, task.AssignerIDIsNil())
	}
	if i.AssignerIDNotNil {
		predicates = append(predicates, task.AssignerIDNotNil())
	}
	if i.AssignerIDEqualFold != nil {
		predicates = append(predicates, task.AssignerIDEqualFold(*i.AssignerIDEqualFold))
	}
	if i.AssignerIDContainsFold != nil {
		predicates = append(predicates, task.AssignerIDContainsFold(*i.AssignerIDContainsFold))
	}

	if i.HasOwner != nil {
		p := task.HasOwner()
		if !*i.HasOwner {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasOwnerWith(with...))
	}
	if i.HasAssigner != nil {
		p := task.HasAssigner()
		if !*i.HasAssigner {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignerWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasAssignerWith))
		for _, w := range i.HasAssignerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssignerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasAssignerWith(with...))
	}
	if i.HasAssignee != nil {
		p := task.HasAssignee()
		if !*i.HasAssignee {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssigneeWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasAssigneeWith))
		for _, w := range i.HasAssigneeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssigneeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasAssigneeWith(with...))
	}
	if i.HasComments != nil {
		p := task.HasComments()
		if !*i.HasComments {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCommentsWith) > 0 {
		with := make([]predicate.Note, 0, len(i.HasCommentsWith))
		for _, w := range i.HasCommentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCommentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasCommentsWith(with...))
	}
	if i.HasGroups != nil {
		p := task.HasGroups()
		if !*i.HasGroups {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasGroupsWith))
		for _, w := range i.HasGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasGroupsWith(with...))
	}
	if i.HasInternalPolicies != nil {
		p := task.HasInternalPolicies()
		if !*i.HasInternalPolicies {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInternalPoliciesWith) > 0 {
		with := make([]predicate.InternalPolicy, 0, len(i.HasInternalPoliciesWith))
		for _, w := range i.HasInternalPoliciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInternalPoliciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasInternalPoliciesWith(with...))
	}
	if i.HasProcedures != nil {
		p := task.HasProcedures()
		if !*i.HasProcedures {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProceduresWith) > 0 {
		with := make([]predicate.Procedure, 0, len(i.HasProceduresWith))
		for _, w := range i.HasProceduresWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProceduresWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasProceduresWith(with...))
	}
	if i.HasControls != nil {
		p := task.HasControls()
		if !*i.HasControls {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlsWith) > 0 {
		with := make([]predicate.Control, 0, len(i.HasControlsWith))
		for _, w := range i.HasControlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasControlsWith(with...))
	}
	if i.HasSubcontrols != nil {
		p := task.HasSubcontrols()
		if !*i.HasSubcontrols {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubcontrolsWith) > 0 {
		with := make([]predicate.Subcontrol, 0, len(i.HasSubcontrolsWith))
		for _, w := range i.HasSubcontrolsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubcontrolsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasSubcontrolsWith(with...))
	}
	if i.HasControlObjectives != nil {
		p := task.HasControlObjectives()
		if !*i.HasControlObjectives {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasControlObjectivesWith) > 0 {
		with := make([]predicate.ControlObjective, 0, len(i.HasControlObjectivesWith))
		for _, w := range i.HasControlObjectivesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasControlObjectivesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasControlObjectivesWith(with...))
	}
	if i.HasPrograms != nil {
		p := task.HasPrograms()
		if !*i.HasPrograms {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramsWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramsWith))
		for _, w := range i.HasProgramsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasProgramsWith(with...))
	}
	if i.HasRisks != nil {
		p := task.HasRisks()
		if !*i.HasRisks {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRisksWith) > 0 {
		with := make([]predicate.Risk, 0, len(i.HasRisksWith))
		for _, w := range i.HasRisksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRisksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasRisksWith(with...))
	}
	if i.HasEvidence != nil {
		p := task.HasEvidence()
		if !*i.HasEvidence {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEvidenceWith) > 0 {
		with := make([]predicate.Evidence, 0, len(i.HasEvidenceWith))
		for _, w := range i.HasEvidenceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEvidenceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasEvidenceWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTaskWhereInput
	case 1:
		return predicates[0], nil
	default:
		return task.And(predicates...), nil
	}
}

// TaskHistoryWhereInput represents a where input for filtering TaskHistory queries.
type TaskHistoryWhereInput struct {
	Predicates []predicate.TaskHistory  `json:"-"`
	Not        *TaskHistoryWhereInput   `json:"not,omitempty"`
	Or         []*TaskHistoryWhereInput `json:"or,omitempty"`
	And        []*TaskHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "details" field predicates.
	Details             *string  `json:"details,omitempty"`
	DetailsNEQ          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGT           *string  `json:"detailsGT,omitempty"`
	DetailsGTE          *string  `json:"detailsGTE,omitempty"`
	DetailsLT           *string  `json:"detailsLT,omitempty"`
	DetailsLTE          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        bool     `json:"detailsIsNil,omitempty"`
	DetailsNotNil       bool     `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`

	// "status" field predicates.
	Status      *enums.TaskStatus  `json:"status,omitempty"`
	StatusNEQ   *enums.TaskStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.TaskStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.TaskStatus `json:"statusNotIn,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        bool     `json:"categoryIsNil,omitempty"`
	CategoryNotNil       bool     `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "due" field predicates.
	Due       *models.DateTime  `json:"due,omitempty"`
	DueNEQ    *models.DateTime  `json:"dueNEQ,omitempty"`
	DueIn     []models.DateTime `json:"dueIn,omitempty"`
	DueNotIn  []models.DateTime `json:"dueNotIn,omitempty"`
	DueGT     *models.DateTime  `json:"dueGT,omitempty"`
	DueGTE    *models.DateTime  `json:"dueGTE,omitempty"`
	DueLT     *models.DateTime  `json:"dueLT,omitempty"`
	DueLTE    *models.DateTime  `json:"dueLTE,omitempty"`
	DueIsNil  bool              `json:"dueIsNil,omitempty"`
	DueNotNil bool              `json:"dueNotNil,omitempty"`

	// "completed" field predicates.
	Completed       *models.DateTime  `json:"completed,omitempty"`
	CompletedNEQ    *models.DateTime  `json:"completedNEQ,omitempty"`
	CompletedIn     []models.DateTime `json:"completedIn,omitempty"`
	CompletedNotIn  []models.DateTime `json:"completedNotIn,omitempty"`
	CompletedGT     *models.DateTime  `json:"completedGT,omitempty"`
	CompletedGTE    *models.DateTime  `json:"completedGTE,omitempty"`
	CompletedLT     *models.DateTime  `json:"completedLT,omitempty"`
	CompletedLTE    *models.DateTime  `json:"completedLTE,omitempty"`
	CompletedIsNil  bool              `json:"completedIsNil,omitempty"`
	CompletedNotNil bool              `json:"completedNotNil,omitempty"`

	// "assignee_id" field predicates.
	AssigneeID             *string  `json:"assigneeID,omitempty"`
	AssigneeIDNEQ          *string  `json:"assigneeIDNEQ,omitempty"`
	AssigneeIDIn           []string `json:"assigneeIDIn,omitempty"`
	AssigneeIDNotIn        []string `json:"assigneeIDNotIn,omitempty"`
	AssigneeIDGT           *string  `json:"assigneeIDGT,omitempty"`
	AssigneeIDGTE          *string  `json:"assigneeIDGTE,omitempty"`
	AssigneeIDLT           *string  `json:"assigneeIDLT,omitempty"`
	AssigneeIDLTE          *string  `json:"assigneeIDLTE,omitempty"`
	AssigneeIDContains     *string  `json:"assigneeIDContains,omitempty"`
	AssigneeIDHasPrefix    *string  `json:"assigneeIDHasPrefix,omitempty"`
	AssigneeIDHasSuffix    *string  `json:"assigneeIDHasSuffix,omitempty"`
	AssigneeIDIsNil        bool     `json:"assigneeIDIsNil,omitempty"`
	AssigneeIDNotNil       bool     `json:"assigneeIDNotNil,omitempty"`
	AssigneeIDEqualFold    *string  `json:"assigneeIDEqualFold,omitempty"`
	AssigneeIDContainsFold *string  `json:"assigneeIDContainsFold,omitempty"`

	// "assigner_id" field predicates.
	AssignerID             *string  `json:"assignerID,omitempty"`
	AssignerIDNEQ          *string  `json:"assignerIDNEQ,omitempty"`
	AssignerIDIn           []string `json:"assignerIDIn,omitempty"`
	AssignerIDNotIn        []string `json:"assignerIDNotIn,omitempty"`
	AssignerIDGT           *string  `json:"assignerIDGT,omitempty"`
	AssignerIDGTE          *string  `json:"assignerIDGTE,omitempty"`
	AssignerIDLT           *string  `json:"assignerIDLT,omitempty"`
	AssignerIDLTE          *string  `json:"assignerIDLTE,omitempty"`
	AssignerIDContains     *string  `json:"assignerIDContains,omitempty"`
	AssignerIDHasPrefix    *string  `json:"assignerIDHasPrefix,omitempty"`
	AssignerIDHasSuffix    *string  `json:"assignerIDHasSuffix,omitempty"`
	AssignerIDIsNil        bool     `json:"assignerIDIsNil,omitempty"`
	AssignerIDNotNil       bool     `json:"assignerIDNotNil,omitempty"`
	AssignerIDEqualFold    *string  `json:"assignerIDEqualFold,omitempty"`
	AssignerIDContainsFold *string  `json:"assignerIDContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TaskHistoryWhereInput) AddPredicates(predicates ...predicate.TaskHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TaskHistoryWhereInput filter on the TaskHistoryQuery builder.
func (i *TaskHistoryWhereInput) Filter(q *TaskHistoryQuery) (*TaskHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTaskHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTaskHistoryWhereInput is returned in case the TaskHistoryWhereInput is empty.
var ErrEmptyTaskHistoryWhereInput = errors.New("generated: empty predicate TaskHistoryWhereInput")

// P returns a predicate for filtering taskhistories.
// An error is returned if the input is empty or invalid.
func (i *TaskHistoryWhereInput) P() (predicate.TaskHistory, error) {
	var predicates []predicate.TaskHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, taskhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TaskHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, taskhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TaskHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, taskhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, taskhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, taskhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, taskhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, taskhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, taskhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, taskhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, taskhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, taskhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, taskhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, taskhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, taskhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, taskhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, taskhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, taskhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, taskhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, taskhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, taskhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, taskhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, taskhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, taskhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, taskhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, taskhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, taskhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, taskhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, taskhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, taskhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, taskhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, taskhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, taskhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, taskhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, taskhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, taskhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, taskhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, taskhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, taskhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, taskhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, taskhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, taskhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, taskhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, taskhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, taskhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, taskhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, taskhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, taskhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, taskhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, taskhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, taskhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, taskhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, taskhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, taskhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, taskhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, taskhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, taskhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, taskhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, taskhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, taskhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, taskhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, taskhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, taskhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, taskhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, taskhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, taskhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, taskhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, taskhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, taskhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, taskhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, taskhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, taskhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, taskhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, taskhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, taskhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, taskhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, taskhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, taskhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, taskhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, taskhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, taskhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, taskhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, taskhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, taskhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, taskhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, taskhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, taskhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, taskhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, taskhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, taskhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, taskhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, taskhistory.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, taskhistory.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, taskhistory.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, taskhistory.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, taskhistory.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, taskhistory.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, taskhistory.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, taskhistory.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, taskhistory.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, taskhistory.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, taskhistory.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, taskhistory.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, taskhistory.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, taskhistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, taskhistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, taskhistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, taskhistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, taskhistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, taskhistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, taskhistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, taskhistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, taskhistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, taskhistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, taskhistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, taskhistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, taskhistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, taskhistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, taskhistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, taskhistory.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, taskhistory.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, taskhistory.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, taskhistory.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, taskhistory.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, taskhistory.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, taskhistory.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, taskhistory.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, taskhistory.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, taskhistory.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, taskhistory.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, taskhistory.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, taskhistory.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Details != nil {
		predicates = append(predicates, taskhistory.DetailsEQ(*i.Details))
	}
	if i.DetailsNEQ != nil {
		predicates = append(predicates, taskhistory.DetailsNEQ(*i.DetailsNEQ))
	}
	if len(i.DetailsIn) > 0 {
		predicates = append(predicates, taskhistory.DetailsIn(i.DetailsIn...))
	}
	if len(i.DetailsNotIn) > 0 {
		predicates = append(predicates, taskhistory.DetailsNotIn(i.DetailsNotIn...))
	}
	if i.DetailsGT != nil {
		predicates = append(predicates, taskhistory.DetailsGT(*i.DetailsGT))
	}
	if i.DetailsGTE != nil {
		predicates = append(predicates, taskhistory.DetailsGTE(*i.DetailsGTE))
	}
	if i.DetailsLT != nil {
		predicates = append(predicates, taskhistory.DetailsLT(*i.DetailsLT))
	}
	if i.DetailsLTE != nil {
		predicates = append(predicates, taskhistory.DetailsLTE(*i.DetailsLTE))
	}
	if i.DetailsContains != nil {
		predicates = append(predicates, taskhistory.DetailsContains(*i.DetailsContains))
	}
	if i.DetailsHasPrefix != nil {
		predicates = append(predicates, taskhistory.DetailsHasPrefix(*i.DetailsHasPrefix))
	}
	if i.DetailsHasSuffix != nil {
		predicates = append(predicates, taskhistory.DetailsHasSuffix(*i.DetailsHasSuffix))
	}
	if i.DetailsIsNil {
		predicates = append(predicates, taskhistory.DetailsIsNil())
	}
	if i.DetailsNotNil {
		predicates = append(predicates, taskhistory.DetailsNotNil())
	}
	if i.DetailsEqualFold != nil {
		predicates = append(predicates, taskhistory.DetailsEqualFold(*i.DetailsEqualFold))
	}
	if i.DetailsContainsFold != nil {
		predicates = append(predicates, taskhistory.DetailsContainsFold(*i.DetailsContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, taskhistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, taskhistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, taskhistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, taskhistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.Category != nil {
		predicates = append(predicates, taskhistory.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, taskhistory.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, taskhistory.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, taskhistory.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, taskhistory.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, taskhistory.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, taskhistory.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, taskhistory.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, taskhistory.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, taskhistory.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, taskhistory.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryIsNil {
		predicates = append(predicates, taskhistory.CategoryIsNil())
	}
	if i.CategoryNotNil {
		predicates = append(predicates, taskhistory.CategoryNotNil())
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, taskhistory.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, taskhistory.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.Due != nil {
		predicates = append(predicates, taskhistory.DueEQ(*i.Due))
	}
	if i.DueNEQ != nil {
		predicates = append(predicates, taskhistory.DueNEQ(*i.DueNEQ))
	}
	if len(i.DueIn) > 0 {
		predicates = append(predicates, taskhistory.DueIn(i.DueIn...))
	}
	if len(i.DueNotIn) > 0 {
		predicates = append(predicates, taskhistory.DueNotIn(i.DueNotIn...))
	}
	if i.DueGT != nil {
		predicates = append(predicates, taskhistory.DueGT(*i.DueGT))
	}
	if i.DueGTE != nil {
		predicates = append(predicates, taskhistory.DueGTE(*i.DueGTE))
	}
	if i.DueLT != nil {
		predicates = append(predicates, taskhistory.DueLT(*i.DueLT))
	}
	if i.DueLTE != nil {
		predicates = append(predicates, taskhistory.DueLTE(*i.DueLTE))
	}
	if i.DueIsNil {
		predicates = append(predicates, taskhistory.DueIsNil())
	}
	if i.DueNotNil {
		predicates = append(predicates, taskhistory.DueNotNil())
	}
	if i.Completed != nil {
		predicates = append(predicates, taskhistory.CompletedEQ(*i.Completed))
	}
	if i.CompletedNEQ != nil {
		predicates = append(predicates, taskhistory.CompletedNEQ(*i.CompletedNEQ))
	}
	if len(i.CompletedIn) > 0 {
		predicates = append(predicates, taskhistory.CompletedIn(i.CompletedIn...))
	}
	if len(i.CompletedNotIn) > 0 {
		predicates = append(predicates, taskhistory.CompletedNotIn(i.CompletedNotIn...))
	}
	if i.CompletedGT != nil {
		predicates = append(predicates, taskhistory.CompletedGT(*i.CompletedGT))
	}
	if i.CompletedGTE != nil {
		predicates = append(predicates, taskhistory.CompletedGTE(*i.CompletedGTE))
	}
	if i.CompletedLT != nil {
		predicates = append(predicates, taskhistory.CompletedLT(*i.CompletedLT))
	}
	if i.CompletedLTE != nil {
		predicates = append(predicates, taskhistory.CompletedLTE(*i.CompletedLTE))
	}
	if i.CompletedIsNil {
		predicates = append(predicates, taskhistory.CompletedIsNil())
	}
	if i.CompletedNotNil {
		predicates = append(predicates, taskhistory.CompletedNotNil())
	}
	if i.AssigneeID != nil {
		predicates = append(predicates, taskhistory.AssigneeIDEQ(*i.AssigneeID))
	}
	if i.AssigneeIDNEQ != nil {
		predicates = append(predicates, taskhistory.AssigneeIDNEQ(*i.AssigneeIDNEQ))
	}
	if len(i.AssigneeIDIn) > 0 {
		predicates = append(predicates, taskhistory.AssigneeIDIn(i.AssigneeIDIn...))
	}
	if len(i.AssigneeIDNotIn) > 0 {
		predicates = append(predicates, taskhistory.AssigneeIDNotIn(i.AssigneeIDNotIn...))
	}
	if i.AssigneeIDGT != nil {
		predicates = append(predicates, taskhistory.AssigneeIDGT(*i.AssigneeIDGT))
	}
	if i.AssigneeIDGTE != nil {
		predicates = append(predicates, taskhistory.AssigneeIDGTE(*i.AssigneeIDGTE))
	}
	if i.AssigneeIDLT != nil {
		predicates = append(predicates, taskhistory.AssigneeIDLT(*i.AssigneeIDLT))
	}
	if i.AssigneeIDLTE != nil {
		predicates = append(predicates, taskhistory.AssigneeIDLTE(*i.AssigneeIDLTE))
	}
	if i.AssigneeIDContains != nil {
		predicates = append(predicates, taskhistory.AssigneeIDContains(*i.AssigneeIDContains))
	}
	if i.AssigneeIDHasPrefix != nil {
		predicates = append(predicates, taskhistory.AssigneeIDHasPrefix(*i.AssigneeIDHasPrefix))
	}
	if i.AssigneeIDHasSuffix != nil {
		predicates = append(predicates, taskhistory.AssigneeIDHasSuffix(*i.AssigneeIDHasSuffix))
	}
	if i.AssigneeIDIsNil {
		predicates = append(predicates, taskhistory.AssigneeIDIsNil())
	}
	if i.AssigneeIDNotNil {
		predicates = append(predicates, taskhistory.AssigneeIDNotNil())
	}
	if i.AssigneeIDEqualFold != nil {
		predicates = append(predicates, taskhistory.AssigneeIDEqualFold(*i.AssigneeIDEqualFold))
	}
	if i.AssigneeIDContainsFold != nil {
		predicates = append(predicates, taskhistory.AssigneeIDContainsFold(*i.AssigneeIDContainsFold))
	}
	if i.AssignerID != nil {
		predicates = append(predicates, taskhistory.AssignerIDEQ(*i.AssignerID))
	}
	if i.AssignerIDNEQ != nil {
		predicates = append(predicates, taskhistory.AssignerIDNEQ(*i.AssignerIDNEQ))
	}
	if len(i.AssignerIDIn) > 0 {
		predicates = append(predicates, taskhistory.AssignerIDIn(i.AssignerIDIn...))
	}
	if len(i.AssignerIDNotIn) > 0 {
		predicates = append(predicates, taskhistory.AssignerIDNotIn(i.AssignerIDNotIn...))
	}
	if i.AssignerIDGT != nil {
		predicates = append(predicates, taskhistory.AssignerIDGT(*i.AssignerIDGT))
	}
	if i.AssignerIDGTE != nil {
		predicates = append(predicates, taskhistory.AssignerIDGTE(*i.AssignerIDGTE))
	}
	if i.AssignerIDLT != nil {
		predicates = append(predicates, taskhistory.AssignerIDLT(*i.AssignerIDLT))
	}
	if i.AssignerIDLTE != nil {
		predicates = append(predicates, taskhistory.AssignerIDLTE(*i.AssignerIDLTE))
	}
	if i.AssignerIDContains != nil {
		predicates = append(predicates, taskhistory.AssignerIDContains(*i.AssignerIDContains))
	}
	if i.AssignerIDHasPrefix != nil {
		predicates = append(predicates, taskhistory.AssignerIDHasPrefix(*i.AssignerIDHasPrefix))
	}
	if i.AssignerIDHasSuffix != nil {
		predicates = append(predicates, taskhistory.AssignerIDHasSuffix(*i.AssignerIDHasSuffix))
	}
	if i.AssignerIDIsNil {
		predicates = append(predicates, taskhistory.AssignerIDIsNil())
	}
	if i.AssignerIDNotNil {
		predicates = append(predicates, taskhistory.AssignerIDNotNil())
	}
	if i.AssignerIDEqualFold != nil {
		predicates = append(predicates, taskhistory.AssignerIDEqualFold(*i.AssignerIDEqualFold))
	}
	if i.AssignerIDContainsFold != nil {
		predicates = append(predicates, taskhistory.AssignerIDContainsFold(*i.AssignerIDContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTaskHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return taskhistory.And(predicates...), nil
	}
}

// TemplateWhereInput represents a where input for filtering Template queries.
type TemplateWhereInput struct {
	Predicates []predicate.Template  `json:"-"`
	Not        *TemplateWhereInput   `json:"not,omitempty"`
	Or         []*TemplateWhereInput `json:"or,omitempty"`
	And        []*TemplateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "template_type" field predicates.
	TemplateType      *enums.DocumentType  `json:"templateType,omitempty"`
	TemplateTypeNEQ   *enums.DocumentType  `json:"templateTypeNEQ,omitempty"`
	TemplateTypeIn    []enums.DocumentType `json:"templateTypeIn,omitempty"`
	TemplateTypeNotIn []enums.DocumentType `json:"templateTypeNotIn,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "documents" edge predicates.
	HasDocuments     *bool                     `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentDataWhereInput `json:"hasDocumentsWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TemplateWhereInput) AddPredicates(predicates ...predicate.Template) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TemplateWhereInput filter on the TemplateQuery builder.
func (i *TemplateWhereInput) Filter(q *TemplateQuery) (*TemplateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTemplateWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTemplateWhereInput is returned in case the TemplateWhereInput is empty.
var ErrEmptyTemplateWhereInput = errors.New("generated: empty predicate TemplateWhereInput")

// P returns a predicate for filtering templates.
// An error is returned if the input is empty or invalid.
func (i *TemplateWhereInput) P() (predicate.Template, error) {
	var predicates []predicate.Template
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, template.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Template, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, template.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Template, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, template.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, template.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, template.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, template.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, template.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, template.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, template.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, template.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, template.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, template.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, template.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, template.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, template.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, template.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, template.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, template.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, template.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, template.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, template.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, template.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, template.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, template.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, template.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, template.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, template.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, template.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, template.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, template.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, template.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, template.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, template.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, template.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, template.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, template.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, template.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, template.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, template.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, template.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, template.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, template.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, template.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, template.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, template.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, template.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, template.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, template.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, template.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, template.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, template.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, template.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, template.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, template.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, template.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, template.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, template.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, template.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, template.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, template.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, template.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, template.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, template.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, template.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, template.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, template.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, template.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, template.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, template.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, template.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, template.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, template.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, template.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, template.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, template.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, template.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, template.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, template.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, template.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, template.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, template.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, template.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, template.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, template.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, template.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, template.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, template.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, template.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, template.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, template.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, template.NameContainsFold(*i.NameContainsFold))
	}
	if i.TemplateType != nil {
		predicates = append(predicates, template.TemplateTypeEQ(*i.TemplateType))
	}
	if i.TemplateTypeNEQ != nil {
		predicates = append(predicates, template.TemplateTypeNEQ(*i.TemplateTypeNEQ))
	}
	if len(i.TemplateTypeIn) > 0 {
		predicates = append(predicates, template.TemplateTypeIn(i.TemplateTypeIn...))
	}
	if len(i.TemplateTypeNotIn) > 0 {
		predicates = append(predicates, template.TemplateTypeNotIn(i.TemplateTypeNotIn...))
	}
	if i.Description != nil {
		predicates = append(predicates, template.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, template.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, template.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, template.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, template.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, template.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, template.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, template.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, template.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, template.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, template.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, template.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, template.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, template.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, template.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasOwner != nil {
		p := template.HasOwner()
		if !*i.HasOwner {
			p = template.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, template.HasOwnerWith(with...))
	}
	if i.HasDocuments != nil {
		p := template.HasDocuments()
		if !*i.HasDocuments {
			p = template.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentsWith) > 0 {
		with := make([]predicate.DocumentData, 0, len(i.HasDocumentsWith))
		for _, w := range i.HasDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, template.HasDocumentsWith(with...))
	}
	if i.HasFiles != nil {
		p := template.HasFiles()
		if !*i.HasFiles {
			p = template.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, template.HasFilesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTemplateWhereInput
	case 1:
		return predicates[0], nil
	default:
		return template.And(predicates...), nil
	}
}

// TemplateHistoryWhereInput represents a where input for filtering TemplateHistory queries.
type TemplateHistoryWhereInput struct {
	Predicates []predicate.TemplateHistory  `json:"-"`
	Not        *TemplateHistoryWhereInput   `json:"not,omitempty"`
	Or         []*TemplateHistoryWhereInput `json:"or,omitempty"`
	And        []*TemplateHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        bool     `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       bool     `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "template_type" field predicates.
	TemplateType      *enums.DocumentType  `json:"templateType,omitempty"`
	TemplateTypeNEQ   *enums.DocumentType  `json:"templateTypeNEQ,omitempty"`
	TemplateTypeIn    []enums.DocumentType `json:"templateTypeIn,omitempty"`
	TemplateTypeNotIn []enums.DocumentType `json:"templateTypeNotIn,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TemplateHistoryWhereInput) AddPredicates(predicates ...predicate.TemplateHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TemplateHistoryWhereInput filter on the TemplateHistoryQuery builder.
func (i *TemplateHistoryWhereInput) Filter(q *TemplateHistoryQuery) (*TemplateHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTemplateHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTemplateHistoryWhereInput is returned in case the TemplateHistoryWhereInput is empty.
var ErrEmptyTemplateHistoryWhereInput = errors.New("generated: empty predicate TemplateHistoryWhereInput")

// P returns a predicate for filtering templatehistories.
// An error is returned if the input is empty or invalid.
func (i *TemplateHistoryWhereInput) P() (predicate.TemplateHistory, error) {
	var predicates []predicate.TemplateHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, templatehistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TemplateHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, templatehistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TemplateHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, templatehistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, templatehistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, templatehistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, templatehistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, templatehistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, templatehistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, templatehistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, templatehistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, templatehistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, templatehistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, templatehistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, templatehistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, templatehistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, templatehistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, templatehistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, templatehistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, templatehistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, templatehistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, templatehistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, templatehistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, templatehistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, templatehistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, templatehistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, templatehistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, templatehistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, templatehistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, templatehistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, templatehistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, templatehistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, templatehistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, templatehistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, templatehistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, templatehistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, templatehistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, templatehistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, templatehistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, templatehistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, templatehistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, templatehistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, templatehistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, templatehistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, templatehistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, templatehistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, templatehistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, templatehistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, templatehistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, templatehistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, templatehistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, templatehistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, templatehistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, templatehistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, templatehistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, templatehistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, templatehistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, templatehistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, templatehistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, templatehistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, templatehistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, templatehistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, templatehistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, templatehistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, templatehistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, templatehistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, templatehistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, templatehistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, templatehistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, templatehistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, templatehistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, templatehistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, templatehistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, templatehistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, templatehistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, templatehistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, templatehistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, templatehistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, templatehistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, templatehistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, templatehistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, templatehistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, templatehistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, templatehistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, templatehistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, templatehistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, templatehistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, templatehistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, templatehistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, templatehistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, templatehistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, templatehistory.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, templatehistory.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, templatehistory.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, templatehistory.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, templatehistory.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, templatehistory.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, templatehistory.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, templatehistory.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, templatehistory.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, templatehistory.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, templatehistory.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, templatehistory.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, templatehistory.OwnerIDNotNil())
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, templatehistory.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, templatehistory.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, templatehistory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, templatehistory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, templatehistory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, templatehistory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, templatehistory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, templatehistory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, templatehistory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, templatehistory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, templatehistory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, templatehistory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, templatehistory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, templatehistory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, templatehistory.NameContainsFold(*i.NameContainsFold))
	}
	if i.TemplateType != nil {
		predicates = append(predicates, templatehistory.TemplateTypeEQ(*i.TemplateType))
	}
	if i.TemplateTypeNEQ != nil {
		predicates = append(predicates, templatehistory.TemplateTypeNEQ(*i.TemplateTypeNEQ))
	}
	if len(i.TemplateTypeIn) > 0 {
		predicates = append(predicates, templatehistory.TemplateTypeIn(i.TemplateTypeIn...))
	}
	if len(i.TemplateTypeNotIn) > 0 {
		predicates = append(predicates, templatehistory.TemplateTypeNotIn(i.TemplateTypeNotIn...))
	}
	if i.Description != nil {
		predicates = append(predicates, templatehistory.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, templatehistory.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, templatehistory.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, templatehistory.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, templatehistory.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, templatehistory.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, templatehistory.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, templatehistory.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, templatehistory.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, templatehistory.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, templatehistory.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, templatehistory.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, templatehistory.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, templatehistory.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, templatehistory.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTemplateHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return templatehistory.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        bool     `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       bool     `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        bool     `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       bool     `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "avatar_remote_url" field predicates.
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNEQ          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGT           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGTE          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLT           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLTE          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        bool     `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       bool     `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`

	// "avatar_local_file_id" field predicates.
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIDNEQ          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIDGT           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIDGTE          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIDLT           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIDLTE          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        bool     `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       bool     `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`

	// "avatar_updated_at" field predicates.
	AvatarUpdatedAt       *time.Time  `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNEQ    *time.Time  `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGT     *time.Time  `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGTE    *time.Time  `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLT     *time.Time  `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLTE    *time.Time  `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil bool        `json:"avatarUpdatedAtNotNil,omitempty"`

	// "last_seen" field predicates.
	LastSeen       *time.Time  `json:"lastSeen,omitempty"`
	LastSeenNEQ    *time.Time  `json:"lastSeenNEQ,omitempty"`
	LastSeenIn     []time.Time `json:"lastSeenIn,omitempty"`
	LastSeenNotIn  []time.Time `json:"lastSeenNotIn,omitempty"`
	LastSeenGT     *time.Time  `json:"lastSeenGT,omitempty"`
	LastSeenGTE    *time.Time  `json:"lastSeenGTE,omitempty"`
	LastSeenLT     *time.Time  `json:"lastSeenLT,omitempty"`
	LastSeenLTE    *time.Time  `json:"lastSeenLTE,omitempty"`
	LastSeenIsNil  bool        `json:"lastSeenIsNil,omitempty"`
	LastSeenNotNil bool        `json:"lastSeenNotNil,omitempty"`

	// "last_login_provider" field predicates.
	LastLoginProvider       *enums.AuthProvider  `json:"lastLoginProvider,omitempty"`
	LastLoginProviderNEQ    *enums.AuthProvider  `json:"lastLoginProviderNEQ,omitempty"`
	LastLoginProviderIn     []enums.AuthProvider `json:"lastLoginProviderIn,omitempty"`
	LastLoginProviderNotIn  []enums.AuthProvider `json:"lastLoginProviderNotIn,omitempty"`
	LastLoginProviderIsNil  bool                 `json:"lastLoginProviderIsNil,omitempty"`
	LastLoginProviderNotNil bool                 `json:"lastLoginProviderNotNil,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordIsNil        bool     `json:"passwordIsNil,omitempty"`
	PasswordNotNil       bool     `json:"passwordNotNil,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "sub" field predicates.
	Sub             *string  `json:"sub,omitempty"`
	SubNEQ          *string  `json:"subNEQ,omitempty"`
	SubIn           []string `json:"subIn,omitempty"`
	SubNotIn        []string `json:"subNotIn,omitempty"`
	SubGT           *string  `json:"subGT,omitempty"`
	SubGTE          *string  `json:"subGTE,omitempty"`
	SubLT           *string  `json:"subLT,omitempty"`
	SubLTE          *string  `json:"subLTE,omitempty"`
	SubContains     *string  `json:"subContains,omitempty"`
	SubHasPrefix    *string  `json:"subHasPrefix,omitempty"`
	SubHasSuffix    *string  `json:"subHasSuffix,omitempty"`
	SubIsNil        bool     `json:"subIsNil,omitempty"`
	SubNotNil       bool     `json:"subNotNil,omitempty"`
	SubEqualFold    *string  `json:"subEqualFold,omitempty"`
	SubContainsFold *string  `json:"subContainsFold,omitempty"`

	// "auth_provider" field predicates.
	AuthProvider      *enums.AuthProvider  `json:"authProvider,omitempty"`
	AuthProviderNEQ   *enums.AuthProvider  `json:"authProviderNEQ,omitempty"`
	AuthProviderIn    []enums.AuthProvider `json:"authProviderIn,omitempty"`
	AuthProviderNotIn []enums.AuthProvider `json:"authProviderNotIn,omitempty"`

	// "role" field predicates.
	Role       *enums.Role  `json:"role,omitempty"`
	RoleNEQ    *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn     []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn  []enums.Role `json:"roleNotIn,omitempty"`
	RoleIsNil  bool         `json:"roleIsNil,omitempty"`
	RoleNotNil bool         `json:"roleNotNil,omitempty"`

	// "personal_access_tokens" edge predicates.
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`

	// "tfa_settings" edge predicates.
	HasTfaSettings     *bool                   `json:"hasTfaSettings,omitempty"`
	HasTfaSettingsWith []*TFASettingWhereInput `json:"hasTfaSettingsWith,omitempty"`

	// "setting" edge predicates.
	HasSetting     *bool                    `json:"hasSetting,omitempty"`
	HasSettingWith []*UserSettingWhereInput `json:"hasSettingWith,omitempty"`

	// "groups" edge predicates.
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`

	// "organizations" edge predicates.
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`

	// "webauthns" edge predicates.
	HasWebauthns     *bool                 `json:"hasWebauthns,omitempty"`
	HasWebauthnsWith []*WebauthnWhereInput `json:"hasWebauthnsWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`

	// "avatar_file" edge predicates.
	HasAvatarFile     *bool             `json:"hasAvatarFile,omitempty"`
	HasAvatarFileWith []*FileWhereInput `json:"hasAvatarFileWith,omitempty"`

	// "events" edge predicates.
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`

	// "action_plans" edge predicates.
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`

	// "subcontrols" edge predicates.
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`

	// "assigner_tasks" edge predicates.
	HasAssignerTasks     *bool             `json:"hasAssignerTasks,omitempty"`
	HasAssignerTasksWith []*TaskWhereInput `json:"hasAssignerTasksWith,omitempty"`

	// "assignee_tasks" edge predicates.
	HasAssigneeTasks     *bool             `json:"hasAssigneeTasks,omitempty"`
	HasAssigneeTasksWith []*TaskWhereInput `json:"hasAssigneeTasksWith,omitempty"`

	// "programs" edge predicates.
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`

	// "group_memberships" edge predicates.
	HasGroupMemberships     *bool                        `json:"hasGroupMemberships,omitempty"`
	HasGroupMembershipsWith []*GroupMembershipWhereInput `json:"hasGroupMembershipsWith,omitempty"`

	// "org_memberships" edge predicates.
	HasOrgMemberships     *bool                      `json:"hasOrgMemberships,omitempty"`
	HasOrgMembershipsWith []*OrgMembershipWhereInput `json:"hasOrgMembershipsWith,omitempty"`

	// "program_memberships" edge predicates.
	HasProgramMemberships     *bool                          `json:"hasProgramMemberships,omitempty"`
	HasProgramMembershipsWith []*ProgramMembershipWhereInput `json:"hasProgramMembershipsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("generated: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, user.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, user.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, user.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, user.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, user.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, user.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, user.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, user.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, user.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, user.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, user.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, user.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, user.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, user.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, user.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, user.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, user.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, user.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, user.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, user.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, user.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, user.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, user.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, user.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, user.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, user.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, user.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, user.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, user.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, user.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, user.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, user.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, user.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, user.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, user.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, user.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, user.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, user.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, user.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, user.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, user.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, user.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, user.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, user.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, user.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, user.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, user.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, user.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, user.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.FirstName != nil {
		predicates = append(predicates, user.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, user.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, user.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, user.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, user.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, user.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, user.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, user.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, user.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, user.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, user.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameIsNil {
		predicates = append(predicates, user.FirstNameIsNil())
	}
	if i.FirstNameNotNil {
		predicates = append(predicates, user.FirstNameNotNil())
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, user.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, user.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, user.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, user.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, user.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, user.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, user.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, user.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, user.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, user.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, user.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, user.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, user.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameIsNil {
		predicates = append(predicates, user.LastNameIsNil())
	}
	if i.LastNameNotNil {
		predicates = append(predicates, user.LastNameNotNil())
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, user.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, user.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, user.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, user.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, user.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, user.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, user.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, user.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, user.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, user.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, user.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, user.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, user.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, user.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, user.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.AvatarRemoteURL != nil {
		predicates = append(predicates, user.AvatarRemoteURLEQ(*i.AvatarRemoteURL))
	}
	if i.AvatarRemoteURLNEQ != nil {
		predicates = append(predicates, user.AvatarRemoteURLNEQ(*i.AvatarRemoteURLNEQ))
	}
	if len(i.AvatarRemoteURLIn) > 0 {
		predicates = append(predicates, user.AvatarRemoteURLIn(i.AvatarRemoteURLIn...))
	}
	if len(i.AvatarRemoteURLNotIn) > 0 {
		predicates = append(predicates, user.AvatarRemoteURLNotIn(i.AvatarRemoteURLNotIn...))
	}
	if i.AvatarRemoteURLGT != nil {
		predicates = append(predicates, user.AvatarRemoteURLGT(*i.AvatarRemoteURLGT))
	}
	if i.AvatarRemoteURLGTE != nil {
		predicates = append(predicates, user.AvatarRemoteURLGTE(*i.AvatarRemoteURLGTE))
	}
	if i.AvatarRemoteURLLT != nil {
		predicates = append(predicates, user.AvatarRemoteURLLT(*i.AvatarRemoteURLLT))
	}
	if i.AvatarRemoteURLLTE != nil {
		predicates = append(predicates, user.AvatarRemoteURLLTE(*i.AvatarRemoteURLLTE))
	}
	if i.AvatarRemoteURLContains != nil {
		predicates = append(predicates, user.AvatarRemoteURLContains(*i.AvatarRemoteURLContains))
	}
	if i.AvatarRemoteURLHasPrefix != nil {
		predicates = append(predicates, user.AvatarRemoteURLHasPrefix(*i.AvatarRemoteURLHasPrefix))
	}
	if i.AvatarRemoteURLHasSuffix != nil {
		predicates = append(predicates, user.AvatarRemoteURLHasSuffix(*i.AvatarRemoteURLHasSuffix))
	}
	if i.AvatarRemoteURLIsNil {
		predicates = append(predicates, user.AvatarRemoteURLIsNil())
	}
	if i.AvatarRemoteURLNotNil {
		predicates = append(predicates, user.AvatarRemoteURLNotNil())
	}
	if i.AvatarRemoteURLEqualFold != nil {
		predicates = append(predicates, user.AvatarRemoteURLEqualFold(*i.AvatarRemoteURLEqualFold))
	}
	if i.AvatarRemoteURLContainsFold != nil {
		predicates = append(predicates, user.AvatarRemoteURLContainsFold(*i.AvatarRemoteURLContainsFold))
	}
	if i.AvatarLocalFileID != nil {
		predicates = append(predicates, user.AvatarLocalFileIDEQ(*i.AvatarLocalFileID))
	}
	if i.AvatarLocalFileIDNEQ != nil {
		predicates = append(predicates, user.AvatarLocalFileIDNEQ(*i.AvatarLocalFileIDNEQ))
	}
	if len(i.AvatarLocalFileIDIn) > 0 {
		predicates = append(predicates, user.AvatarLocalFileIDIn(i.AvatarLocalFileIDIn...))
	}
	if len(i.AvatarLocalFileIDNotIn) > 0 {
		predicates = append(predicates, user.AvatarLocalFileIDNotIn(i.AvatarLocalFileIDNotIn...))
	}
	if i.AvatarLocalFileIDGT != nil {
		predicates = append(predicates, user.AvatarLocalFileIDGT(*i.AvatarLocalFileIDGT))
	}
	if i.AvatarLocalFileIDGTE != nil {
		predicates = append(predicates, user.AvatarLocalFileIDGTE(*i.AvatarLocalFileIDGTE))
	}
	if i.AvatarLocalFileIDLT != nil {
		predicates = append(predicates, user.AvatarLocalFileIDLT(*i.AvatarLocalFileIDLT))
	}
	if i.AvatarLocalFileIDLTE != nil {
		predicates = append(predicates, user.AvatarLocalFileIDLTE(*i.AvatarLocalFileIDLTE))
	}
	if i.AvatarLocalFileIDContains != nil {
		predicates = append(predicates, user.AvatarLocalFileIDContains(*i.AvatarLocalFileIDContains))
	}
	if i.AvatarLocalFileIDHasPrefix != nil {
		predicates = append(predicates, user.AvatarLocalFileIDHasPrefix(*i.AvatarLocalFileIDHasPrefix))
	}
	if i.AvatarLocalFileIDHasSuffix != nil {
		predicates = append(predicates, user.AvatarLocalFileIDHasSuffix(*i.AvatarLocalFileIDHasSuffix))
	}
	if i.AvatarLocalFileIDIsNil {
		predicates = append(predicates, user.AvatarLocalFileIDIsNil())
	}
	if i.AvatarLocalFileIDNotNil {
		predicates = append(predicates, user.AvatarLocalFileIDNotNil())
	}
	if i.AvatarLocalFileIDEqualFold != nil {
		predicates = append(predicates, user.AvatarLocalFileIDEqualFold(*i.AvatarLocalFileIDEqualFold))
	}
	if i.AvatarLocalFileIDContainsFold != nil {
		predicates = append(predicates, user.AvatarLocalFileIDContainsFold(*i.AvatarLocalFileIDContainsFold))
	}
	if i.AvatarUpdatedAt != nil {
		predicates = append(predicates, user.AvatarUpdatedAtEQ(*i.AvatarUpdatedAt))
	}
	if i.AvatarUpdatedAtNEQ != nil {
		predicates = append(predicates, user.AvatarUpdatedAtNEQ(*i.AvatarUpdatedAtNEQ))
	}
	if len(i.AvatarUpdatedAtIn) > 0 {
		predicates = append(predicates, user.AvatarUpdatedAtIn(i.AvatarUpdatedAtIn...))
	}
	if len(i.AvatarUpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.AvatarUpdatedAtNotIn(i.AvatarUpdatedAtNotIn...))
	}
	if i.AvatarUpdatedAtGT != nil {
		predicates = append(predicates, user.AvatarUpdatedAtGT(*i.AvatarUpdatedAtGT))
	}
	if i.AvatarUpdatedAtGTE != nil {
		predicates = append(predicates, user.AvatarUpdatedAtGTE(*i.AvatarUpdatedAtGTE))
	}
	if i.AvatarUpdatedAtLT != nil {
		predicates = append(predicates, user.AvatarUpdatedAtLT(*i.AvatarUpdatedAtLT))
	}
	if i.AvatarUpdatedAtLTE != nil {
		predicates = append(predicates, user.AvatarUpdatedAtLTE(*i.AvatarUpdatedAtLTE))
	}
	if i.AvatarUpdatedAtIsNil {
		predicates = append(predicates, user.AvatarUpdatedAtIsNil())
	}
	if i.AvatarUpdatedAtNotNil {
		predicates = append(predicates, user.AvatarUpdatedAtNotNil())
	}
	if i.LastSeen != nil {
		predicates = append(predicates, user.LastSeenEQ(*i.LastSeen))
	}
	if i.LastSeenNEQ != nil {
		predicates = append(predicates, user.LastSeenNEQ(*i.LastSeenNEQ))
	}
	if len(i.LastSeenIn) > 0 {
		predicates = append(predicates, user.LastSeenIn(i.LastSeenIn...))
	}
	if len(i.LastSeenNotIn) > 0 {
		predicates = append(predicates, user.LastSeenNotIn(i.LastSeenNotIn...))
	}
	if i.LastSeenGT != nil {
		predicates = append(predicates, user.LastSeenGT(*i.LastSeenGT))
	}
	if i.LastSeenGTE != nil {
		predicates = append(predicates, user.LastSeenGTE(*i.LastSeenGTE))
	}
	if i.LastSeenLT != nil {
		predicates = append(predicates, user.LastSeenLT(*i.LastSeenLT))
	}
	if i.LastSeenLTE != nil {
		predicates = append(predicates, user.LastSeenLTE(*i.LastSeenLTE))
	}
	if i.LastSeenIsNil {
		predicates = append(predicates, user.LastSeenIsNil())
	}
	if i.LastSeenNotNil {
		predicates = append(predicates, user.LastSeenNotNil())
	}
	if i.LastLoginProvider != nil {
		predicates = append(predicates, user.LastLoginProviderEQ(*i.LastLoginProvider))
	}
	if i.LastLoginProviderNEQ != nil {
		predicates = append(predicates, user.LastLoginProviderNEQ(*i.LastLoginProviderNEQ))
	}
	if len(i.LastLoginProviderIn) > 0 {
		predicates = append(predicates, user.LastLoginProviderIn(i.LastLoginProviderIn...))
	}
	if len(i.LastLoginProviderNotIn) > 0 {
		predicates = append(predicates, user.LastLoginProviderNotIn(i.LastLoginProviderNotIn...))
	}
	if i.LastLoginProviderIsNil {
		predicates = append(predicates, user.LastLoginProviderIsNil())
	}
	if i.LastLoginProviderNotNil {
		predicates = append(predicates, user.LastLoginProviderNotNil())
	}
	if i.Password != nil {
		predicates = append(predicates, user.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, user.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, user.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, user.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, user.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, user.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, user.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, user.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, user.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, user.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, user.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordIsNil {
		predicates = append(predicates, user.PasswordIsNil())
	}
	if i.PasswordNotNil {
		predicates = append(predicates, user.PasswordNotNil())
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, user.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, user.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.Sub != nil {
		predicates = append(predicates, user.SubEQ(*i.Sub))
	}
	if i.SubNEQ != nil {
		predicates = append(predicates, user.SubNEQ(*i.SubNEQ))
	}
	if len(i.SubIn) > 0 {
		predicates = append(predicates, user.SubIn(i.SubIn...))
	}
	if len(i.SubNotIn) > 0 {
		predicates = append(predicates, user.SubNotIn(i.SubNotIn...))
	}
	if i.SubGT != nil {
		predicates = append(predicates, user.SubGT(*i.SubGT))
	}
	if i.SubGTE != nil {
		predicates = append(predicates, user.SubGTE(*i.SubGTE))
	}
	if i.SubLT != nil {
		predicates = append(predicates, user.SubLT(*i.SubLT))
	}
	if i.SubLTE != nil {
		predicates = append(predicates, user.SubLTE(*i.SubLTE))
	}
	if i.SubContains != nil {
		predicates = append(predicates, user.SubContains(*i.SubContains))
	}
	if i.SubHasPrefix != nil {
		predicates = append(predicates, user.SubHasPrefix(*i.SubHasPrefix))
	}
	if i.SubHasSuffix != nil {
		predicates = append(predicates, user.SubHasSuffix(*i.SubHasSuffix))
	}
	if i.SubIsNil {
		predicates = append(predicates, user.SubIsNil())
	}
	if i.SubNotNil {
		predicates = append(predicates, user.SubNotNil())
	}
	if i.SubEqualFold != nil {
		predicates = append(predicates, user.SubEqualFold(*i.SubEqualFold))
	}
	if i.SubContainsFold != nil {
		predicates = append(predicates, user.SubContainsFold(*i.SubContainsFold))
	}
	if i.AuthProvider != nil {
		predicates = append(predicates, user.AuthProviderEQ(*i.AuthProvider))
	}
	if i.AuthProviderNEQ != nil {
		predicates = append(predicates, user.AuthProviderNEQ(*i.AuthProviderNEQ))
	}
	if len(i.AuthProviderIn) > 0 {
		predicates = append(predicates, user.AuthProviderIn(i.AuthProviderIn...))
	}
	if len(i.AuthProviderNotIn) > 0 {
		predicates = append(predicates, user.AuthProviderNotIn(i.AuthProviderNotIn...))
	}
	if i.Role != nil {
		predicates = append(predicates, user.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, user.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, user.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, user.RoleNotIn(i.RoleNotIn...))
	}
	if i.RoleIsNil {
		predicates = append(predicates, user.RoleIsNil())
	}
	if i.RoleNotNil {
		predicates = append(predicates, user.RoleNotNil())
	}

	if i.HasPersonalAccessTokens != nil {
		p := user.HasPersonalAccessTokens()
		if !*i.HasPersonalAccessTokens {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPersonalAccessTokensWith) > 0 {
		with := make([]predicate.PersonalAccessToken, 0, len(i.HasPersonalAccessTokensWith))
		for _, w := range i.HasPersonalAccessTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPersonalAccessTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasPersonalAccessTokensWith(with...))
	}
	if i.HasTfaSettings != nil {
		p := user.HasTfaSettings()
		if !*i.HasTfaSettings {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTfaSettingsWith) > 0 {
		with := make([]predicate.TFASetting, 0, len(i.HasTfaSettingsWith))
		for _, w := range i.HasTfaSettingsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTfaSettingsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasTfaSettingsWith(with...))
	}
	if i.HasSetting != nil {
		p := user.HasSetting()
		if !*i.HasSetting {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSettingWith) > 0 {
		with := make([]predicate.UserSetting, 0, len(i.HasSettingWith))
		for _, w := range i.HasSettingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSettingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSettingWith(with...))
	}
	if i.HasGroups != nil {
		p := user.HasGroups()
		if !*i.HasGroups {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasGroupsWith))
		for _, w := range i.HasGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasGroupsWith(with...))
	}
	if i.HasOrganizations != nil {
		p := user.HasOrganizations()
		if !*i.HasOrganizations {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrganizationsWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOrganizationsWith))
		for _, w := range i.HasOrganizationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrganizationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasOrganizationsWith(with...))
	}
	if i.HasWebauthns != nil {
		p := user.HasWebauthns()
		if !*i.HasWebauthns {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWebauthnsWith) > 0 {
		with := make([]predicate.Webauthn, 0, len(i.HasWebauthnsWith))
		for _, w := range i.HasWebauthnsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWebauthnsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasWebauthnsWith(with...))
	}
	if i.HasFiles != nil {
		p := user.HasFiles()
		if !*i.HasFiles {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasFilesWith(with...))
	}
	if i.HasAvatarFile != nil {
		p := user.HasAvatarFile()
		if !*i.HasAvatarFile {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAvatarFileWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasAvatarFileWith))
		for _, w := range i.HasAvatarFileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAvatarFileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAvatarFileWith(with...))
	}
	if i.HasEvents != nil {
		p := user.HasEvents()
		if !*i.HasEvents {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventsWith) > 0 {
		with := make([]predicate.Event, 0, len(i.HasEventsWith))
		for _, w := range i.HasEventsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasEventsWith(with...))
	}
	if i.HasActionPlans != nil {
		p := user.HasActionPlans()
		if !*i.HasActionPlans {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionPlansWith) > 0 {
		with := make([]predicate.ActionPlan, 0, len(i.HasActionPlansWith))
		for _, w := range i.HasActionPlansWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionPlansWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasActionPlansWith(with...))
	}
	if i.HasSubcontrols != nil {
		p := user.HasSubcontrols()
		if !*i.HasSubcontrols {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubcontrolsWith) > 0 {
		with := make([]predicate.Subcontrol, 0, len(i.HasSubcontrolsWith))
		for _, w := range i.HasSubcontrolsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubcontrolsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSubcontrolsWith(with...))
	}
	if i.HasAssignerTasks != nil {
		p := user.HasAssignerTasks()
		if !*i.HasAssignerTasks {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignerTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasAssignerTasksWith))
		for _, w := range i.HasAssignerTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssignerTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAssignerTasksWith(with...))
	}
	if i.HasAssigneeTasks != nil {
		p := user.HasAssigneeTasks()
		if !*i.HasAssigneeTasks {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssigneeTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasAssigneeTasksWith))
		for _, w := range i.HasAssigneeTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssigneeTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAssigneeTasksWith(with...))
	}
	if i.HasPrograms != nil {
		p := user.HasPrograms()
		if !*i.HasPrograms {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramsWith) > 0 {
		with := make([]predicate.Program, 0, len(i.HasProgramsWith))
		for _, w := range i.HasProgramsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasProgramsWith(with...))
	}
	if i.HasGroupMemberships != nil {
		p := user.HasGroupMemberships()
		if !*i.HasGroupMemberships {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupMembershipsWith) > 0 {
		with := make([]predicate.GroupMembership, 0, len(i.HasGroupMembershipsWith))
		for _, w := range i.HasGroupMembershipsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGroupMembershipsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasGroupMembershipsWith(with...))
	}
	if i.HasOrgMemberships != nil {
		p := user.HasOrgMemberships()
		if !*i.HasOrgMemberships {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrgMembershipsWith) > 0 {
		with := make([]predicate.OrgMembership, 0, len(i.HasOrgMembershipsWith))
		for _, w := range i.HasOrgMembershipsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrgMembershipsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasOrgMembershipsWith(with...))
	}
	if i.HasProgramMemberships != nil {
		p := user.HasProgramMemberships()
		if !*i.HasProgramMemberships {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgramMembershipsWith) > 0 {
		with := make([]predicate.ProgramMembership, 0, len(i.HasProgramMembershipsWith))
		for _, w := range i.HasProgramMembershipsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgramMembershipsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasProgramMembershipsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// UserHistoryWhereInput represents a where input for filtering UserHistory queries.
type UserHistoryWhereInput struct {
	Predicates []predicate.UserHistory  `json:"-"`
	Not        *UserHistoryWhereInput   `json:"not,omitempty"`
	Or         []*UserHistoryWhereInput `json:"or,omitempty"`
	And        []*UserHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_id" field predicates.
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIDNEQ          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIDGT           *string  `json:"displayIDGT,omitempty"`
	DisplayIDGTE          *string  `json:"displayIDGTE,omitempty"`
	DisplayIDLT           *string  `json:"displayIDLT,omitempty"`
	DisplayIDLTE          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        bool     `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       bool     `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        bool     `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       bool     `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "avatar_remote_url" field predicates.
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNEQ          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGT           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGTE          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLT           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLTE          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        bool     `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       bool     `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`

	// "avatar_local_file_id" field predicates.
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIDNEQ          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIDGT           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIDGTE          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIDLT           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIDLTE          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        bool     `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       bool     `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`

	// "avatar_updated_at" field predicates.
	AvatarUpdatedAt       *time.Time  `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNEQ    *time.Time  `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGT     *time.Time  `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGTE    *time.Time  `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLT     *time.Time  `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLTE    *time.Time  `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil bool        `json:"avatarUpdatedAtNotNil,omitempty"`

	// "last_seen" field predicates.
	LastSeen       *time.Time  `json:"lastSeen,omitempty"`
	LastSeenNEQ    *time.Time  `json:"lastSeenNEQ,omitempty"`
	LastSeenIn     []time.Time `json:"lastSeenIn,omitempty"`
	LastSeenNotIn  []time.Time `json:"lastSeenNotIn,omitempty"`
	LastSeenGT     *time.Time  `json:"lastSeenGT,omitempty"`
	LastSeenGTE    *time.Time  `json:"lastSeenGTE,omitempty"`
	LastSeenLT     *time.Time  `json:"lastSeenLT,omitempty"`
	LastSeenLTE    *time.Time  `json:"lastSeenLTE,omitempty"`
	LastSeenIsNil  bool        `json:"lastSeenIsNil,omitempty"`
	LastSeenNotNil bool        `json:"lastSeenNotNil,omitempty"`

	// "last_login_provider" field predicates.
	LastLoginProvider       *enums.AuthProvider  `json:"lastLoginProvider,omitempty"`
	LastLoginProviderNEQ    *enums.AuthProvider  `json:"lastLoginProviderNEQ,omitempty"`
	LastLoginProviderIn     []enums.AuthProvider `json:"lastLoginProviderIn,omitempty"`
	LastLoginProviderNotIn  []enums.AuthProvider `json:"lastLoginProviderNotIn,omitempty"`
	LastLoginProviderIsNil  bool                 `json:"lastLoginProviderIsNil,omitempty"`
	LastLoginProviderNotNil bool                 `json:"lastLoginProviderNotNil,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordIsNil        bool     `json:"passwordIsNil,omitempty"`
	PasswordNotNil       bool     `json:"passwordNotNil,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "sub" field predicates.
	Sub             *string  `json:"sub,omitempty"`
	SubNEQ          *string  `json:"subNEQ,omitempty"`
	SubIn           []string `json:"subIn,omitempty"`
	SubNotIn        []string `json:"subNotIn,omitempty"`
	SubGT           *string  `json:"subGT,omitempty"`
	SubGTE          *string  `json:"subGTE,omitempty"`
	SubLT           *string  `json:"subLT,omitempty"`
	SubLTE          *string  `json:"subLTE,omitempty"`
	SubContains     *string  `json:"subContains,omitempty"`
	SubHasPrefix    *string  `json:"subHasPrefix,omitempty"`
	SubHasSuffix    *string  `json:"subHasSuffix,omitempty"`
	SubIsNil        bool     `json:"subIsNil,omitempty"`
	SubNotNil       bool     `json:"subNotNil,omitempty"`
	SubEqualFold    *string  `json:"subEqualFold,omitempty"`
	SubContainsFold *string  `json:"subContainsFold,omitempty"`

	// "auth_provider" field predicates.
	AuthProvider      *enums.AuthProvider  `json:"authProvider,omitempty"`
	AuthProviderNEQ   *enums.AuthProvider  `json:"authProviderNEQ,omitempty"`
	AuthProviderIn    []enums.AuthProvider `json:"authProviderIn,omitempty"`
	AuthProviderNotIn []enums.AuthProvider `json:"authProviderNotIn,omitempty"`

	// "role" field predicates.
	Role       *enums.Role  `json:"role,omitempty"`
	RoleNEQ    *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn     []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn  []enums.Role `json:"roleNotIn,omitempty"`
	RoleIsNil  bool         `json:"roleIsNil,omitempty"`
	RoleNotNil bool         `json:"roleNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserHistoryWhereInput) AddPredicates(predicates ...predicate.UserHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserHistoryWhereInput filter on the UserHistoryQuery builder.
func (i *UserHistoryWhereInput) Filter(q *UserHistoryQuery) (*UserHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserHistoryWhereInput is returned in case the UserHistoryWhereInput is empty.
var ErrEmptyUserHistoryWhereInput = errors.New("generated: empty predicate UserHistoryWhereInput")

// P returns a predicate for filtering userhistories.
// An error is returned if the input is empty or invalid.
func (i *UserHistoryWhereInput) P() (predicate.UserHistory, error) {
	var predicates []predicate.UserHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userhistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, userhistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, userhistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, userhistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, userhistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, userhistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, userhistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, userhistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, userhistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, userhistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, userhistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, userhistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, userhistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, userhistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, userhistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, userhistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, userhistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, userhistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, userhistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, userhistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, userhistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, userhistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, userhistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, userhistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, userhistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, userhistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, userhistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, userhistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, userhistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, userhistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, userhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, userhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, userhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, userhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, userhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, userhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, userhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, userhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, userhistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, userhistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, userhistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, userhistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, userhistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, userhistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, userhistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, userhistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, userhistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, userhistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, userhistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, userhistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, userhistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, userhistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, userhistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, userhistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, userhistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, userhistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, userhistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, userhistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, userhistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, userhistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, userhistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, userhistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, userhistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, userhistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, userhistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, userhistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, userhistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, userhistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, userhistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, userhistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, userhistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, userhistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, userhistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, userhistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, userhistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, userhistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, userhistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, userhistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, userhistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, userhistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayID != nil {
		predicates = append(predicates, userhistory.DisplayIDEQ(*i.DisplayID))
	}
	if i.DisplayIDNEQ != nil {
		predicates = append(predicates, userhistory.DisplayIDNEQ(*i.DisplayIDNEQ))
	}
	if len(i.DisplayIDIn) > 0 {
		predicates = append(predicates, userhistory.DisplayIDIn(i.DisplayIDIn...))
	}
	if len(i.DisplayIDNotIn) > 0 {
		predicates = append(predicates, userhistory.DisplayIDNotIn(i.DisplayIDNotIn...))
	}
	if i.DisplayIDGT != nil {
		predicates = append(predicates, userhistory.DisplayIDGT(*i.DisplayIDGT))
	}
	if i.DisplayIDGTE != nil {
		predicates = append(predicates, userhistory.DisplayIDGTE(*i.DisplayIDGTE))
	}
	if i.DisplayIDLT != nil {
		predicates = append(predicates, userhistory.DisplayIDLT(*i.DisplayIDLT))
	}
	if i.DisplayIDLTE != nil {
		predicates = append(predicates, userhistory.DisplayIDLTE(*i.DisplayIDLTE))
	}
	if i.DisplayIDContains != nil {
		predicates = append(predicates, userhistory.DisplayIDContains(*i.DisplayIDContains))
	}
	if i.DisplayIDHasPrefix != nil {
		predicates = append(predicates, userhistory.DisplayIDHasPrefix(*i.DisplayIDHasPrefix))
	}
	if i.DisplayIDHasSuffix != nil {
		predicates = append(predicates, userhistory.DisplayIDHasSuffix(*i.DisplayIDHasSuffix))
	}
	if i.DisplayIDEqualFold != nil {
		predicates = append(predicates, userhistory.DisplayIDEqualFold(*i.DisplayIDEqualFold))
	}
	if i.DisplayIDContainsFold != nil {
		predicates = append(predicates, userhistory.DisplayIDContainsFold(*i.DisplayIDContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, userhistory.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, userhistory.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, userhistory.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, userhistory.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, userhistory.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, userhistory.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, userhistory.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, userhistory.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, userhistory.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, userhistory.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, userhistory.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, userhistory.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, userhistory.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.FirstName != nil {
		predicates = append(predicates, userhistory.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, userhistory.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, userhistory.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, userhistory.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, userhistory.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, userhistory.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, userhistory.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, userhistory.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, userhistory.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, userhistory.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, userhistory.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameIsNil {
		predicates = append(predicates, userhistory.FirstNameIsNil())
	}
	if i.FirstNameNotNil {
		predicates = append(predicates, userhistory.FirstNameNotNil())
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, userhistory.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, userhistory.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, userhistory.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, userhistory.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, userhistory.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, userhistory.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, userhistory.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, userhistory.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, userhistory.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, userhistory.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, userhistory.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, userhistory.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, userhistory.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameIsNil {
		predicates = append(predicates, userhistory.LastNameIsNil())
	}
	if i.LastNameNotNil {
		predicates = append(predicates, userhistory.LastNameNotNil())
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, userhistory.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, userhistory.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, userhistory.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, userhistory.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, userhistory.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, userhistory.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, userhistory.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, userhistory.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, userhistory.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, userhistory.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, userhistory.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, userhistory.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, userhistory.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, userhistory.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, userhistory.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.AvatarRemoteURL != nil {
		predicates = append(predicates, userhistory.AvatarRemoteURLEQ(*i.AvatarRemoteURL))
	}
	if i.AvatarRemoteURLNEQ != nil {
		predicates = append(predicates, userhistory.AvatarRemoteURLNEQ(*i.AvatarRemoteURLNEQ))
	}
	if len(i.AvatarRemoteURLIn) > 0 {
		predicates = append(predicates, userhistory.AvatarRemoteURLIn(i.AvatarRemoteURLIn...))
	}
	if len(i.AvatarRemoteURLNotIn) > 0 {
		predicates = append(predicates, userhistory.AvatarRemoteURLNotIn(i.AvatarRemoteURLNotIn...))
	}
	if i.AvatarRemoteURLGT != nil {
		predicates = append(predicates, userhistory.AvatarRemoteURLGT(*i.AvatarRemoteURLGT))
	}
	if i.AvatarRemoteURLGTE != nil {
		predicates = append(predicates, userhistory.AvatarRemoteURLGTE(*i.AvatarRemoteURLGTE))
	}
	if i.AvatarRemoteURLLT != nil {
		predicates = append(predicates, userhistory.AvatarRemoteURLLT(*i.AvatarRemoteURLLT))
	}
	if i.AvatarRemoteURLLTE != nil {
		predicates = append(predicates, userhistory.AvatarRemoteURLLTE(*i.AvatarRemoteURLLTE))
	}
	if i.AvatarRemoteURLContains != nil {
		predicates = append(predicates, userhistory.AvatarRemoteURLContains(*i.AvatarRemoteURLContains))
	}
	if i.AvatarRemoteURLHasPrefix != nil {
		predicates = append(predicates, userhistory.AvatarRemoteURLHasPrefix(*i.AvatarRemoteURLHasPrefix))
	}
	if i.AvatarRemoteURLHasSuffix != nil {
		predicates = append(predicates, userhistory.AvatarRemoteURLHasSuffix(*i.AvatarRemoteURLHasSuffix))
	}
	if i.AvatarRemoteURLIsNil {
		predicates = append(predicates, userhistory.AvatarRemoteURLIsNil())
	}
	if i.AvatarRemoteURLNotNil {
		predicates = append(predicates, userhistory.AvatarRemoteURLNotNil())
	}
	if i.AvatarRemoteURLEqualFold != nil {
		predicates = append(predicates, userhistory.AvatarRemoteURLEqualFold(*i.AvatarRemoteURLEqualFold))
	}
	if i.AvatarRemoteURLContainsFold != nil {
		predicates = append(predicates, userhistory.AvatarRemoteURLContainsFold(*i.AvatarRemoteURLContainsFold))
	}
	if i.AvatarLocalFileID != nil {
		predicates = append(predicates, userhistory.AvatarLocalFileIDEQ(*i.AvatarLocalFileID))
	}
	if i.AvatarLocalFileIDNEQ != nil {
		predicates = append(predicates, userhistory.AvatarLocalFileIDNEQ(*i.AvatarLocalFileIDNEQ))
	}
	if len(i.AvatarLocalFileIDIn) > 0 {
		predicates = append(predicates, userhistory.AvatarLocalFileIDIn(i.AvatarLocalFileIDIn...))
	}
	if len(i.AvatarLocalFileIDNotIn) > 0 {
		predicates = append(predicates, userhistory.AvatarLocalFileIDNotIn(i.AvatarLocalFileIDNotIn...))
	}
	if i.AvatarLocalFileIDGT != nil {
		predicates = append(predicates, userhistory.AvatarLocalFileIDGT(*i.AvatarLocalFileIDGT))
	}
	if i.AvatarLocalFileIDGTE != nil {
		predicates = append(predicates, userhistory.AvatarLocalFileIDGTE(*i.AvatarLocalFileIDGTE))
	}
	if i.AvatarLocalFileIDLT != nil {
		predicates = append(predicates, userhistory.AvatarLocalFileIDLT(*i.AvatarLocalFileIDLT))
	}
	if i.AvatarLocalFileIDLTE != nil {
		predicates = append(predicates, userhistory.AvatarLocalFileIDLTE(*i.AvatarLocalFileIDLTE))
	}
	if i.AvatarLocalFileIDContains != nil {
		predicates = append(predicates, userhistory.AvatarLocalFileIDContains(*i.AvatarLocalFileIDContains))
	}
	if i.AvatarLocalFileIDHasPrefix != nil {
		predicates = append(predicates, userhistory.AvatarLocalFileIDHasPrefix(*i.AvatarLocalFileIDHasPrefix))
	}
	if i.AvatarLocalFileIDHasSuffix != nil {
		predicates = append(predicates, userhistory.AvatarLocalFileIDHasSuffix(*i.AvatarLocalFileIDHasSuffix))
	}
	if i.AvatarLocalFileIDIsNil {
		predicates = append(predicates, userhistory.AvatarLocalFileIDIsNil())
	}
	if i.AvatarLocalFileIDNotNil {
		predicates = append(predicates, userhistory.AvatarLocalFileIDNotNil())
	}
	if i.AvatarLocalFileIDEqualFold != nil {
		predicates = append(predicates, userhistory.AvatarLocalFileIDEqualFold(*i.AvatarLocalFileIDEqualFold))
	}
	if i.AvatarLocalFileIDContainsFold != nil {
		predicates = append(predicates, userhistory.AvatarLocalFileIDContainsFold(*i.AvatarLocalFileIDContainsFold))
	}
	if i.AvatarUpdatedAt != nil {
		predicates = append(predicates, userhistory.AvatarUpdatedAtEQ(*i.AvatarUpdatedAt))
	}
	if i.AvatarUpdatedAtNEQ != nil {
		predicates = append(predicates, userhistory.AvatarUpdatedAtNEQ(*i.AvatarUpdatedAtNEQ))
	}
	if len(i.AvatarUpdatedAtIn) > 0 {
		predicates = append(predicates, userhistory.AvatarUpdatedAtIn(i.AvatarUpdatedAtIn...))
	}
	if len(i.AvatarUpdatedAtNotIn) > 0 {
		predicates = append(predicates, userhistory.AvatarUpdatedAtNotIn(i.AvatarUpdatedAtNotIn...))
	}
	if i.AvatarUpdatedAtGT != nil {
		predicates = append(predicates, userhistory.AvatarUpdatedAtGT(*i.AvatarUpdatedAtGT))
	}
	if i.AvatarUpdatedAtGTE != nil {
		predicates = append(predicates, userhistory.AvatarUpdatedAtGTE(*i.AvatarUpdatedAtGTE))
	}
	if i.AvatarUpdatedAtLT != nil {
		predicates = append(predicates, userhistory.AvatarUpdatedAtLT(*i.AvatarUpdatedAtLT))
	}
	if i.AvatarUpdatedAtLTE != nil {
		predicates = append(predicates, userhistory.AvatarUpdatedAtLTE(*i.AvatarUpdatedAtLTE))
	}
	if i.AvatarUpdatedAtIsNil {
		predicates = append(predicates, userhistory.AvatarUpdatedAtIsNil())
	}
	if i.AvatarUpdatedAtNotNil {
		predicates = append(predicates, userhistory.AvatarUpdatedAtNotNil())
	}
	if i.LastSeen != nil {
		predicates = append(predicates, userhistory.LastSeenEQ(*i.LastSeen))
	}
	if i.LastSeenNEQ != nil {
		predicates = append(predicates, userhistory.LastSeenNEQ(*i.LastSeenNEQ))
	}
	if len(i.LastSeenIn) > 0 {
		predicates = append(predicates, userhistory.LastSeenIn(i.LastSeenIn...))
	}
	if len(i.LastSeenNotIn) > 0 {
		predicates = append(predicates, userhistory.LastSeenNotIn(i.LastSeenNotIn...))
	}
	if i.LastSeenGT != nil {
		predicates = append(predicates, userhistory.LastSeenGT(*i.LastSeenGT))
	}
	if i.LastSeenGTE != nil {
		predicates = append(predicates, userhistory.LastSeenGTE(*i.LastSeenGTE))
	}
	if i.LastSeenLT != nil {
		predicates = append(predicates, userhistory.LastSeenLT(*i.LastSeenLT))
	}
	if i.LastSeenLTE != nil {
		predicates = append(predicates, userhistory.LastSeenLTE(*i.LastSeenLTE))
	}
	if i.LastSeenIsNil {
		predicates = append(predicates, userhistory.LastSeenIsNil())
	}
	if i.LastSeenNotNil {
		predicates = append(predicates, userhistory.LastSeenNotNil())
	}
	if i.LastLoginProvider != nil {
		predicates = append(predicates, userhistory.LastLoginProviderEQ(*i.LastLoginProvider))
	}
	if i.LastLoginProviderNEQ != nil {
		predicates = append(predicates, userhistory.LastLoginProviderNEQ(*i.LastLoginProviderNEQ))
	}
	if len(i.LastLoginProviderIn) > 0 {
		predicates = append(predicates, userhistory.LastLoginProviderIn(i.LastLoginProviderIn...))
	}
	if len(i.LastLoginProviderNotIn) > 0 {
		predicates = append(predicates, userhistory.LastLoginProviderNotIn(i.LastLoginProviderNotIn...))
	}
	if i.LastLoginProviderIsNil {
		predicates = append(predicates, userhistory.LastLoginProviderIsNil())
	}
	if i.LastLoginProviderNotNil {
		predicates = append(predicates, userhistory.LastLoginProviderNotNil())
	}
	if i.Password != nil {
		predicates = append(predicates, userhistory.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, userhistory.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, userhistory.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, userhistory.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, userhistory.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, userhistory.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, userhistory.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, userhistory.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, userhistory.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, userhistory.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, userhistory.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordIsNil {
		predicates = append(predicates, userhistory.PasswordIsNil())
	}
	if i.PasswordNotNil {
		predicates = append(predicates, userhistory.PasswordNotNil())
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, userhistory.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, userhistory.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.Sub != nil {
		predicates = append(predicates, userhistory.SubEQ(*i.Sub))
	}
	if i.SubNEQ != nil {
		predicates = append(predicates, userhistory.SubNEQ(*i.SubNEQ))
	}
	if len(i.SubIn) > 0 {
		predicates = append(predicates, userhistory.SubIn(i.SubIn...))
	}
	if len(i.SubNotIn) > 0 {
		predicates = append(predicates, userhistory.SubNotIn(i.SubNotIn...))
	}
	if i.SubGT != nil {
		predicates = append(predicates, userhistory.SubGT(*i.SubGT))
	}
	if i.SubGTE != nil {
		predicates = append(predicates, userhistory.SubGTE(*i.SubGTE))
	}
	if i.SubLT != nil {
		predicates = append(predicates, userhistory.SubLT(*i.SubLT))
	}
	if i.SubLTE != nil {
		predicates = append(predicates, userhistory.SubLTE(*i.SubLTE))
	}
	if i.SubContains != nil {
		predicates = append(predicates, userhistory.SubContains(*i.SubContains))
	}
	if i.SubHasPrefix != nil {
		predicates = append(predicates, userhistory.SubHasPrefix(*i.SubHasPrefix))
	}
	if i.SubHasSuffix != nil {
		predicates = append(predicates, userhistory.SubHasSuffix(*i.SubHasSuffix))
	}
	if i.SubIsNil {
		predicates = append(predicates, userhistory.SubIsNil())
	}
	if i.SubNotNil {
		predicates = append(predicates, userhistory.SubNotNil())
	}
	if i.SubEqualFold != nil {
		predicates = append(predicates, userhistory.SubEqualFold(*i.SubEqualFold))
	}
	if i.SubContainsFold != nil {
		predicates = append(predicates, userhistory.SubContainsFold(*i.SubContainsFold))
	}
	if i.AuthProvider != nil {
		predicates = append(predicates, userhistory.AuthProviderEQ(*i.AuthProvider))
	}
	if i.AuthProviderNEQ != nil {
		predicates = append(predicates, userhistory.AuthProviderNEQ(*i.AuthProviderNEQ))
	}
	if len(i.AuthProviderIn) > 0 {
		predicates = append(predicates, userhistory.AuthProviderIn(i.AuthProviderIn...))
	}
	if len(i.AuthProviderNotIn) > 0 {
		predicates = append(predicates, userhistory.AuthProviderNotIn(i.AuthProviderNotIn...))
	}
	if i.Role != nil {
		predicates = append(predicates, userhistory.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, userhistory.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, userhistory.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, userhistory.RoleNotIn(i.RoleNotIn...))
	}
	if i.RoleIsNil {
		predicates = append(predicates, userhistory.RoleIsNil())
	}
	if i.RoleNotNil {
		predicates = append(predicates, userhistory.RoleNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userhistory.And(predicates...), nil
	}
}

// UserSettingWhereInput represents a where input for filtering UserSetting queries.
type UserSettingWhereInput struct {
	Predicates []predicate.UserSetting  `json:"-"`
	Not        *UserSettingWhereInput   `json:"not,omitempty"`
	Or         []*UserSettingWhereInput `json:"or,omitempty"`
	And        []*UserSettingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        bool     `json:"userIDIsNil,omitempty"`
	UserIDNotNil       bool     `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "locked" field predicates.
	Locked    *bool `json:"locked,omitempty"`
	LockedNEQ *bool `json:"lockedNEQ,omitempty"`

	// "silenced_at" field predicates.
	SilencedAt       *time.Time  `json:"silencedAt,omitempty"`
	SilencedAtNEQ    *time.Time  `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGT     *time.Time  `json:"silencedAtGT,omitempty"`
	SilencedAtGTE    *time.Time  `json:"silencedAtGTE,omitempty"`
	SilencedAtLT     *time.Time  `json:"silencedAtLT,omitempty"`
	SilencedAtLTE    *time.Time  `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil bool        `json:"silencedAtNotNil,omitempty"`

	// "suspended_at" field predicates.
	SuspendedAt       *time.Time  `json:"suspendedAt,omitempty"`
	SuspendedAtNEQ    *time.Time  `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGT     *time.Time  `json:"suspendedAtGT,omitempty"`
	SuspendedAtGTE    *time.Time  `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLT     *time.Time  `json:"suspendedAtLT,omitempty"`
	SuspendedAtLTE    *time.Time  `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil bool        `json:"suspendedAtNotNil,omitempty"`

	// "status" field predicates.
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNEQ   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`

	// "email_confirmed" field predicates.
	EmailConfirmed    *bool `json:"emailConfirmed,omitempty"`
	EmailConfirmedNEQ *bool `json:"emailConfirmedNEQ,omitempty"`

	// "is_tfa_enabled" field predicates.
	IsTfaEnabled       *bool `json:"isTfaEnabled,omitempty"`
	IsTfaEnabledNEQ    *bool `json:"isTfaEnabledNEQ,omitempty"`
	IsTfaEnabledIsNil  bool  `json:"isTfaEnabledIsNil,omitempty"`
	IsTfaEnabledNotNil bool  `json:"isTfaEnabledNotNil,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "default_org" edge predicates.
	HasDefaultOrg     *bool                     `json:"hasDefaultOrg,omitempty"`
	HasDefaultOrgWith []*OrganizationWhereInput `json:"hasDefaultOrgWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserSettingWhereInput) AddPredicates(predicates ...predicate.UserSetting) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserSettingWhereInput filter on the UserSettingQuery builder.
func (i *UserSettingWhereInput) Filter(q *UserSettingQuery) (*UserSettingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserSettingWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserSettingWhereInput is returned in case the UserSettingWhereInput is empty.
var ErrEmptyUserSettingWhereInput = errors.New("generated: empty predicate UserSettingWhereInput")

// P returns a predicate for filtering usersettings.
// An error is returned if the input is empty or invalid.
func (i *UserSettingWhereInput) P() (predicate.UserSetting, error) {
	var predicates []predicate.UserSetting
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, usersetting.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserSetting, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, usersetting.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserSetting, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, usersetting.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, usersetting.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, usersetting.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, usersetting.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, usersetting.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, usersetting.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, usersetting.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, usersetting.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, usersetting.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, usersetting.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, usersetting.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, usersetting.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, usersetting.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, usersetting.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, usersetting.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, usersetting.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, usersetting.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, usersetting.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, usersetting.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, usersetting.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, usersetting.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, usersetting.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, usersetting.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, usersetting.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, usersetting.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, usersetting.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, usersetting.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, usersetting.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, usersetting.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, usersetting.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, usersetting.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, usersetting.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, usersetting.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, usersetting.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, usersetting.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, usersetting.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, usersetting.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, usersetting.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, usersetting.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, usersetting.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, usersetting.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, usersetting.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, usersetting.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, usersetting.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, usersetting.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, usersetting.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, usersetting.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, usersetting.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, usersetting.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, usersetting.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, usersetting.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, usersetting.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, usersetting.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, usersetting.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, usersetting.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, usersetting.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, usersetting.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, usersetting.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, usersetting.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, usersetting.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, usersetting.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, usersetting.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, usersetting.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, usersetting.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, usersetting.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, usersetting.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, usersetting.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, usersetting.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, usersetting.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, usersetting.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, usersetting.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, usersetting.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, usersetting.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, usersetting.UserIDNotNil())
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, usersetting.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, usersetting.UserIDContainsFold(*i.UserIDContainsFold))
	}
	if i.Locked != nil {
		predicates = append(predicates, usersetting.LockedEQ(*i.Locked))
	}
	if i.LockedNEQ != nil {
		predicates = append(predicates, usersetting.LockedNEQ(*i.LockedNEQ))
	}
	if i.SilencedAt != nil {
		predicates = append(predicates, usersetting.SilencedAtEQ(*i.SilencedAt))
	}
	if i.SilencedAtNEQ != nil {
		predicates = append(predicates, usersetting.SilencedAtNEQ(*i.SilencedAtNEQ))
	}
	if len(i.SilencedAtIn) > 0 {
		predicates = append(predicates, usersetting.SilencedAtIn(i.SilencedAtIn...))
	}
	if len(i.SilencedAtNotIn) > 0 {
		predicates = append(predicates, usersetting.SilencedAtNotIn(i.SilencedAtNotIn...))
	}
	if i.SilencedAtGT != nil {
		predicates = append(predicates, usersetting.SilencedAtGT(*i.SilencedAtGT))
	}
	if i.SilencedAtGTE != nil {
		predicates = append(predicates, usersetting.SilencedAtGTE(*i.SilencedAtGTE))
	}
	if i.SilencedAtLT != nil {
		predicates = append(predicates, usersetting.SilencedAtLT(*i.SilencedAtLT))
	}
	if i.SilencedAtLTE != nil {
		predicates = append(predicates, usersetting.SilencedAtLTE(*i.SilencedAtLTE))
	}
	if i.SilencedAtIsNil {
		predicates = append(predicates, usersetting.SilencedAtIsNil())
	}
	if i.SilencedAtNotNil {
		predicates = append(predicates, usersetting.SilencedAtNotNil())
	}
	if i.SuspendedAt != nil {
		predicates = append(predicates, usersetting.SuspendedAtEQ(*i.SuspendedAt))
	}
	if i.SuspendedAtNEQ != nil {
		predicates = append(predicates, usersetting.SuspendedAtNEQ(*i.SuspendedAtNEQ))
	}
	if len(i.SuspendedAtIn) > 0 {
		predicates = append(predicates, usersetting.SuspendedAtIn(i.SuspendedAtIn...))
	}
	if len(i.SuspendedAtNotIn) > 0 {
		predicates = append(predicates, usersetting.SuspendedAtNotIn(i.SuspendedAtNotIn...))
	}
	if i.SuspendedAtGT != nil {
		predicates = append(predicates, usersetting.SuspendedAtGT(*i.SuspendedAtGT))
	}
	if i.SuspendedAtGTE != nil {
		predicates = append(predicates, usersetting.SuspendedAtGTE(*i.SuspendedAtGTE))
	}
	if i.SuspendedAtLT != nil {
		predicates = append(predicates, usersetting.SuspendedAtLT(*i.SuspendedAtLT))
	}
	if i.SuspendedAtLTE != nil {
		predicates = append(predicates, usersetting.SuspendedAtLTE(*i.SuspendedAtLTE))
	}
	if i.SuspendedAtIsNil {
		predicates = append(predicates, usersetting.SuspendedAtIsNil())
	}
	if i.SuspendedAtNotNil {
		predicates = append(predicates, usersetting.SuspendedAtNotNil())
	}
	if i.Status != nil {
		predicates = append(predicates, usersetting.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, usersetting.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, usersetting.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, usersetting.StatusNotIn(i.StatusNotIn...))
	}
	if i.EmailConfirmed != nil {
		predicates = append(predicates, usersetting.EmailConfirmedEQ(*i.EmailConfirmed))
	}
	if i.EmailConfirmedNEQ != nil {
		predicates = append(predicates, usersetting.EmailConfirmedNEQ(*i.EmailConfirmedNEQ))
	}
	if i.IsTfaEnabled != nil {
		predicates = append(predicates, usersetting.IsTfaEnabledEQ(*i.IsTfaEnabled))
	}
	if i.IsTfaEnabledNEQ != nil {
		predicates = append(predicates, usersetting.IsTfaEnabledNEQ(*i.IsTfaEnabledNEQ))
	}
	if i.IsTfaEnabledIsNil {
		predicates = append(predicates, usersetting.IsTfaEnabledIsNil())
	}
	if i.IsTfaEnabledNotNil {
		predicates = append(predicates, usersetting.IsTfaEnabledNotNil())
	}

	if i.HasUser != nil {
		p := usersetting.HasUser()
		if !*i.HasUser {
			p = usersetting.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usersetting.HasUserWith(with...))
	}
	if i.HasDefaultOrg != nil {
		p := usersetting.HasDefaultOrg()
		if !*i.HasDefaultOrg {
			p = usersetting.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDefaultOrgWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasDefaultOrgWith))
		for _, w := range i.HasDefaultOrgWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDefaultOrgWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usersetting.HasDefaultOrgWith(with...))
	}
	if i.HasFiles != nil {
		p := usersetting.HasFiles()
		if !*i.HasFiles {
			p = usersetting.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usersetting.HasFilesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserSettingWhereInput
	case 1:
		return predicates[0], nil
	default:
		return usersetting.And(predicates...), nil
	}
}

// UserSettingHistoryWhereInput represents a where input for filtering UserSettingHistory queries.
type UserSettingHistoryWhereInput struct {
	Predicates []predicate.UserSettingHistory  `json:"-"`
	Not        *UserSettingHistoryWhereInput   `json:"not,omitempty"`
	Or         []*UserSettingHistoryWhereInput `json:"or,omitempty"`
	And        []*UserSettingHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "history_time" field predicates.
	HistoryTime      *time.Time  `json:"historyTime,omitempty"`
	HistoryTimeNEQ   *time.Time  `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGT    *time.Time  `json:"historyTimeGT,omitempty"`
	HistoryTimeGTE   *time.Time  `json:"historyTimeGTE,omitempty"`
	HistoryTimeLT    *time.Time  `json:"historyTimeLT,omitempty"`
	HistoryTimeLTE   *time.Time  `json:"historyTimeLTE,omitempty"`

	// "ref" field predicates.
	Ref             *string  `json:"ref,omitempty"`
	RefNEQ          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGT           *string  `json:"refGT,omitempty"`
	RefGTE          *string  `json:"refGTE,omitempty"`
	RefLT           *string  `json:"refLT,omitempty"`
	RefLTE          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        bool     `json:"refIsNil,omitempty"`
	RefNotNil       bool     `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`

	// "operation" field predicates.
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNEQ   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        bool     `json:"userIDIsNil,omitempty"`
	UserIDNotNil       bool     `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "locked" field predicates.
	Locked    *bool `json:"locked,omitempty"`
	LockedNEQ *bool `json:"lockedNEQ,omitempty"`

	// "silenced_at" field predicates.
	SilencedAt       *time.Time  `json:"silencedAt,omitempty"`
	SilencedAtNEQ    *time.Time  `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGT     *time.Time  `json:"silencedAtGT,omitempty"`
	SilencedAtGTE    *time.Time  `json:"silencedAtGTE,omitempty"`
	SilencedAtLT     *time.Time  `json:"silencedAtLT,omitempty"`
	SilencedAtLTE    *time.Time  `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil bool        `json:"silencedAtNotNil,omitempty"`

	// "suspended_at" field predicates.
	SuspendedAt       *time.Time  `json:"suspendedAt,omitempty"`
	SuspendedAtNEQ    *time.Time  `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGT     *time.Time  `json:"suspendedAtGT,omitempty"`
	SuspendedAtGTE    *time.Time  `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLT     *time.Time  `json:"suspendedAtLT,omitempty"`
	SuspendedAtLTE    *time.Time  `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil bool        `json:"suspendedAtNotNil,omitempty"`

	// "status" field predicates.
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNEQ   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`

	// "email_confirmed" field predicates.
	EmailConfirmed    *bool `json:"emailConfirmed,omitempty"`
	EmailConfirmedNEQ *bool `json:"emailConfirmedNEQ,omitempty"`

	// "is_tfa_enabled" field predicates.
	IsTfaEnabled       *bool `json:"isTfaEnabled,omitempty"`
	IsTfaEnabledNEQ    *bool `json:"isTfaEnabledNEQ,omitempty"`
	IsTfaEnabledIsNil  bool  `json:"isTfaEnabledIsNil,omitempty"`
	IsTfaEnabledNotNil bool  `json:"isTfaEnabledNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserSettingHistoryWhereInput) AddPredicates(predicates ...predicate.UserSettingHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserSettingHistoryWhereInput filter on the UserSettingHistoryQuery builder.
func (i *UserSettingHistoryWhereInput) Filter(q *UserSettingHistoryQuery) (*UserSettingHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserSettingHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserSettingHistoryWhereInput is returned in case the UserSettingHistoryWhereInput is empty.
var ErrEmptyUserSettingHistoryWhereInput = errors.New("generated: empty predicate UserSettingHistoryWhereInput")

// P returns a predicate for filtering usersettinghistories.
// An error is returned if the input is empty or invalid.
func (i *UserSettingHistoryWhereInput) P() (predicate.UserSettingHistory, error) {
	var predicates []predicate.UserSettingHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, usersettinghistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserSettingHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, usersettinghistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserSettingHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, usersettinghistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, usersettinghistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, usersettinghistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, usersettinghistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, usersettinghistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, usersettinghistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, usersettinghistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, usersettinghistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, usersettinghistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, usersettinghistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, usersettinghistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.HistoryTime != nil {
		predicates = append(predicates, usersettinghistory.HistoryTimeEQ(*i.HistoryTime))
	}
	if i.HistoryTimeNEQ != nil {
		predicates = append(predicates, usersettinghistory.HistoryTimeNEQ(*i.HistoryTimeNEQ))
	}
	if len(i.HistoryTimeIn) > 0 {
		predicates = append(predicates, usersettinghistory.HistoryTimeIn(i.HistoryTimeIn...))
	}
	if len(i.HistoryTimeNotIn) > 0 {
		predicates = append(predicates, usersettinghistory.HistoryTimeNotIn(i.HistoryTimeNotIn...))
	}
	if i.HistoryTimeGT != nil {
		predicates = append(predicates, usersettinghistory.HistoryTimeGT(*i.HistoryTimeGT))
	}
	if i.HistoryTimeGTE != nil {
		predicates = append(predicates, usersettinghistory.HistoryTimeGTE(*i.HistoryTimeGTE))
	}
	if i.HistoryTimeLT != nil {
		predicates = append(predicates, usersettinghistory.HistoryTimeLT(*i.HistoryTimeLT))
	}
	if i.HistoryTimeLTE != nil {
		predicates = append(predicates, usersettinghistory.HistoryTimeLTE(*i.HistoryTimeLTE))
	}
	if i.Ref != nil {
		predicates = append(predicates, usersettinghistory.RefEQ(*i.Ref))
	}
	if i.RefNEQ != nil {
		predicates = append(predicates, usersettinghistory.RefNEQ(*i.RefNEQ))
	}
	if len(i.RefIn) > 0 {
		predicates = append(predicates, usersettinghistory.RefIn(i.RefIn...))
	}
	if len(i.RefNotIn) > 0 {
		predicates = append(predicates, usersettinghistory.RefNotIn(i.RefNotIn...))
	}
	if i.RefGT != nil {
		predicates = append(predicates, usersettinghistory.RefGT(*i.RefGT))
	}
	if i.RefGTE != nil {
		predicates = append(predicates, usersettinghistory.RefGTE(*i.RefGTE))
	}
	if i.RefLT != nil {
		predicates = append(predicates, usersettinghistory.RefLT(*i.RefLT))
	}
	if i.RefLTE != nil {
		predicates = append(predicates, usersettinghistory.RefLTE(*i.RefLTE))
	}
	if i.RefContains != nil {
		predicates = append(predicates, usersettinghistory.RefContains(*i.RefContains))
	}
	if i.RefHasPrefix != nil {
		predicates = append(predicates, usersettinghistory.RefHasPrefix(*i.RefHasPrefix))
	}
	if i.RefHasSuffix != nil {
		predicates = append(predicates, usersettinghistory.RefHasSuffix(*i.RefHasSuffix))
	}
	if i.RefIsNil {
		predicates = append(predicates, usersettinghistory.RefIsNil())
	}
	if i.RefNotNil {
		predicates = append(predicates, usersettinghistory.RefNotNil())
	}
	if i.RefEqualFold != nil {
		predicates = append(predicates, usersettinghistory.RefEqualFold(*i.RefEqualFold))
	}
	if i.RefContainsFold != nil {
		predicates = append(predicates, usersettinghistory.RefContainsFold(*i.RefContainsFold))
	}
	if i.Operation != nil {
		predicates = append(predicates, usersettinghistory.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, usersettinghistory.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, usersettinghistory.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, usersettinghistory.OperationNotIn(i.OperationNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, usersettinghistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, usersettinghistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, usersettinghistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, usersettinghistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, usersettinghistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, usersettinghistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, usersettinghistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, usersettinghistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, usersettinghistory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, usersettinghistory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, usersettinghistory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, usersettinghistory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, usersettinghistory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, usersettinghistory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, usersettinghistory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, usersettinghistory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, usersettinghistory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, usersettinghistory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, usersettinghistory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, usersettinghistory.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, usersettinghistory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, usersettinghistory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, usersettinghistory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, usersettinghistory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, usersettinghistory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, usersettinghistory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, usersettinghistory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, usersettinghistory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, usersettinghistory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, usersettinghistory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, usersettinghistory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, usersettinghistory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, usersettinghistory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, usersettinghistory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, usersettinghistory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, usersettinghistory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, usersettinghistory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, usersettinghistory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, usersettinghistory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, usersettinghistory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, usersettinghistory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, usersettinghistory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, usersettinghistory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, usersettinghistory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, usersettinghistory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, usersettinghistory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, usersettinghistory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, usersettinghistory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, usersettinghistory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, usersettinghistory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, usersettinghistory.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, usersettinghistory.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, usersettinghistory.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, usersettinghistory.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, usersettinghistory.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, usersettinghistory.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, usersettinghistory.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, usersettinghistory.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, usersettinghistory.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, usersettinghistory.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, usersettinghistory.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, usersettinghistory.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, usersettinghistory.UserIDNotNil())
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, usersettinghistory.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, usersettinghistory.UserIDContainsFold(*i.UserIDContainsFold))
	}
	if i.Locked != nil {
		predicates = append(predicates, usersettinghistory.LockedEQ(*i.Locked))
	}
	if i.LockedNEQ != nil {
		predicates = append(predicates, usersettinghistory.LockedNEQ(*i.LockedNEQ))
	}
	if i.SilencedAt != nil {
		predicates = append(predicates, usersettinghistory.SilencedAtEQ(*i.SilencedAt))
	}
	if i.SilencedAtNEQ != nil {
		predicates = append(predicates, usersettinghistory.SilencedAtNEQ(*i.SilencedAtNEQ))
	}
	if len(i.SilencedAtIn) > 0 {
		predicates = append(predicates, usersettinghistory.SilencedAtIn(i.SilencedAtIn...))
	}
	if len(i.SilencedAtNotIn) > 0 {
		predicates = append(predicates, usersettinghistory.SilencedAtNotIn(i.SilencedAtNotIn...))
	}
	if i.SilencedAtGT != nil {
		predicates = append(predicates, usersettinghistory.SilencedAtGT(*i.SilencedAtGT))
	}
	if i.SilencedAtGTE != nil {
		predicates = append(predicates, usersettinghistory.SilencedAtGTE(*i.SilencedAtGTE))
	}
	if i.SilencedAtLT != nil {
		predicates = append(predicates, usersettinghistory.SilencedAtLT(*i.SilencedAtLT))
	}
	if i.SilencedAtLTE != nil {
		predicates = append(predicates, usersettinghistory.SilencedAtLTE(*i.SilencedAtLTE))
	}
	if i.SilencedAtIsNil {
		predicates = append(predicates, usersettinghistory.SilencedAtIsNil())
	}
	if i.SilencedAtNotNil {
		predicates = append(predicates, usersettinghistory.SilencedAtNotNil())
	}
	if i.SuspendedAt != nil {
		predicates = append(predicates, usersettinghistory.SuspendedAtEQ(*i.SuspendedAt))
	}
	if i.SuspendedAtNEQ != nil {
		predicates = append(predicates, usersettinghistory.SuspendedAtNEQ(*i.SuspendedAtNEQ))
	}
	if len(i.SuspendedAtIn) > 0 {
		predicates = append(predicates, usersettinghistory.SuspendedAtIn(i.SuspendedAtIn...))
	}
	if len(i.SuspendedAtNotIn) > 0 {
		predicates = append(predicates, usersettinghistory.SuspendedAtNotIn(i.SuspendedAtNotIn...))
	}
	if i.SuspendedAtGT != nil {
		predicates = append(predicates, usersettinghistory.SuspendedAtGT(*i.SuspendedAtGT))
	}
	if i.SuspendedAtGTE != nil {
		predicates = append(predicates, usersettinghistory.SuspendedAtGTE(*i.SuspendedAtGTE))
	}
	if i.SuspendedAtLT != nil {
		predicates = append(predicates, usersettinghistory.SuspendedAtLT(*i.SuspendedAtLT))
	}
	if i.SuspendedAtLTE != nil {
		predicates = append(predicates, usersettinghistory.SuspendedAtLTE(*i.SuspendedAtLTE))
	}
	if i.SuspendedAtIsNil {
		predicates = append(predicates, usersettinghistory.SuspendedAtIsNil())
	}
	if i.SuspendedAtNotNil {
		predicates = append(predicates, usersettinghistory.SuspendedAtNotNil())
	}
	if i.Status != nil {
		predicates = append(predicates, usersettinghistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, usersettinghistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, usersettinghistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, usersettinghistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.EmailConfirmed != nil {
		predicates = append(predicates, usersettinghistory.EmailConfirmedEQ(*i.EmailConfirmed))
	}
	if i.EmailConfirmedNEQ != nil {
		predicates = append(predicates, usersettinghistory.EmailConfirmedNEQ(*i.EmailConfirmedNEQ))
	}
	if i.IsTfaEnabled != nil {
		predicates = append(predicates, usersettinghistory.IsTfaEnabledEQ(*i.IsTfaEnabled))
	}
	if i.IsTfaEnabledNEQ != nil {
		predicates = append(predicates, usersettinghistory.IsTfaEnabledNEQ(*i.IsTfaEnabledNEQ))
	}
	if i.IsTfaEnabledIsNil {
		predicates = append(predicates, usersettinghistory.IsTfaEnabledIsNil())
	}
	if i.IsTfaEnabledNotNil {
		predicates = append(predicates, usersettinghistory.IsTfaEnabledNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserSettingHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return usersettinghistory.And(predicates...), nil
	}
}

// WebauthnWhereInput represents a where input for filtering Webauthn queries.
type WebauthnWhereInput struct {
	Predicates []predicate.Webauthn  `json:"-"`
	Not        *WebauthnWhereInput   `json:"not,omitempty"`
	Or         []*WebauthnWhereInput `json:"or,omitempty"`
	And        []*WebauthnWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WebauthnWhereInput) AddPredicates(predicates ...predicate.Webauthn) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WebauthnWhereInput filter on the WebauthnQuery builder.
func (i *WebauthnWhereInput) Filter(q *WebauthnQuery) (*WebauthnQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWebauthnWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWebauthnWhereInput is returned in case the WebauthnWhereInput is empty.
var ErrEmptyWebauthnWhereInput = errors.New("generated: empty predicate WebauthnWhereInput")

// P returns a predicate for filtering webauthns.
// An error is returned if the input is empty or invalid.
func (i *WebauthnWhereInput) P() (predicate.Webauthn, error) {
	var predicates []predicate.Webauthn
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, webauthn.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Webauthn, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, webauthn.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Webauthn, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, webauthn.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, webauthn.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, webauthn.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, webauthn.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, webauthn.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, webauthn.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, webauthn.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, webauthn.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, webauthn.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, webauthn.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, webauthn.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, webauthn.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, webauthn.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, webauthn.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, webauthn.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, webauthn.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, webauthn.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, webauthn.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, webauthn.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, webauthn.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, webauthn.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, webauthn.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, webauthn.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, webauthn.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, webauthn.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, webauthn.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, webauthn.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, webauthn.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, webauthn.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, webauthn.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, webauthn.UpdatedAtNotNil())
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, webauthn.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, webauthn.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, webauthn.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, webauthn.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, webauthn.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, webauthn.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, webauthn.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, webauthn.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, webauthn.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, webauthn.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, webauthn.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, webauthn.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, webauthn.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, webauthn.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, webauthn.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, webauthn.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, webauthn.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, webauthn.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, webauthn.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, webauthn.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, webauthn.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, webauthn.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, webauthn.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, webauthn.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, webauthn.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, webauthn.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, webauthn.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, webauthn.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, webauthn.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, webauthn.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}

	if i.HasOwner != nil {
		p := webauthn.HasOwner()
		if !*i.HasOwner {
			p = webauthn.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, webauthn.HasOwnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWebauthnWhereInput
	case 1:
		return predicates[0], nil
	default:
		return webauthn.And(predicates...), nil
	}
}
