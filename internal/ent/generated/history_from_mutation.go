// Code generated by entx.history, DO NOT EDIT.

// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent"
	"github.com/theopenlane/entx"
	"github.com/theopenlane/entx/history"
)

var (
	idNotFoundError = errors.New("could not get id from mutation")
)

func EntOpToHistoryOp(op ent.Op) history.OpType {
	switch op {
	case ent.OpDelete, ent.OpDeleteOne:
		return history.OpTypeDelete
	case ent.OpUpdate, ent.OpUpdateOne:
		return history.OpTypeUpdate
	default:
		return history.OpTypeInsert
	}
}

func (m *ActionPlanMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ActionPlanHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if dueDate, exists := m.DueDate(); exists {
		create = create.SetDueDate(dueDate)
	}

	if priority, exists := m.Priority(); exists {
		create = create.SetPriority(priority)
	}

	if source, exists := m.Source(); exists {
		create = create.SetSource(source)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ActionPlanMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		actionplan, err := client.ActionPlan.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ActionPlanHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(actionplan.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(actionplan.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(actionplan.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(actionplan.UpdatedByID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(actionplan.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(actionplan.DeletedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(actionplan.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(actionplan.Tags)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(actionplan.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(actionplan.Description)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(actionplan.Status)
		}

		if dueDate, exists := m.DueDate(); exists {
			create = create.SetDueDate(dueDate)
		} else {
			create = create.SetDueDate(actionplan.DueDate)
		}

		if priority, exists := m.Priority(); exists {
			create = create.SetPriority(priority)
		} else {
			create = create.SetPriority(actionplan.Priority)
		}

		if source, exists := m.Source(); exists {
			create = create.SetSource(source)
		} else {
			create = create.SetSource(actionplan.Source)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(actionplan.Details)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ActionPlanMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		actionplan, err := client.ActionPlan.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ActionPlanHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(actionplan.CreatedAt).
			SetUpdatedAt(actionplan.UpdatedAt).
			SetCreatedByID(actionplan.CreatedByID).
			SetUpdatedByID(actionplan.UpdatedByID).
			SetDeletedAt(actionplan.DeletedAt).
			SetDeletedByID(actionplan.DeletedByID).
			SetMappingID(actionplan.MappingID).
			SetTags(actionplan.Tags).
			SetName(actionplan.Name).
			SetDescription(actionplan.Description).
			SetStatus(actionplan.Status).
			SetDueDate(actionplan.DueDate).
			SetPriority(actionplan.Priority).
			SetSource(actionplan.Source).
			SetDetails(actionplan.Details).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ContactMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ContactHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if fullName, exists := m.FullName(); exists {
		create = create.SetFullName(fullName)
	}

	if title, exists := m.Title(); exists {
		create = create.SetTitle(title)
	}

	if company, exists := m.Company(); exists {
		create = create.SetCompany(company)
	}

	if email, exists := m.Email(); exists {
		create = create.SetEmail(email)
	}

	if phoneNumber, exists := m.PhoneNumber(); exists {
		create = create.SetPhoneNumber(phoneNumber)
	}

	if address, exists := m.Address(); exists {
		create = create.SetAddress(address)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ContactMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		contact, err := client.Contact.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ContactHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(contact.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(contact.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(contact.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(contact.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(contact.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(contact.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(contact.DeletedByID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(contact.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(contact.OwnerID)
		}

		if fullName, exists := m.FullName(); exists {
			create = create.SetFullName(fullName)
		} else {
			create = create.SetFullName(contact.FullName)
		}

		if title, exists := m.Title(); exists {
			create = create.SetTitle(title)
		} else {
			create = create.SetTitle(contact.Title)
		}

		if company, exists := m.Company(); exists {
			create = create.SetCompany(company)
		} else {
			create = create.SetCompany(contact.Company)
		}

		if email, exists := m.Email(); exists {
			create = create.SetEmail(email)
		} else {
			create = create.SetEmail(contact.Email)
		}

		if phoneNumber, exists := m.PhoneNumber(); exists {
			create = create.SetPhoneNumber(phoneNumber)
		} else {
			create = create.SetPhoneNumber(contact.PhoneNumber)
		}

		if address, exists := m.Address(); exists {
			create = create.SetAddress(address)
		} else {
			create = create.SetAddress(contact.Address)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(contact.Status)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ContactMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		contact, err := client.Contact.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ContactHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(contact.CreatedAt).
			SetUpdatedAt(contact.UpdatedAt).
			SetCreatedByID(contact.CreatedByID).
			SetUpdatedByID(contact.UpdatedByID).
			SetMappingID(contact.MappingID).
			SetDeletedAt(contact.DeletedAt).
			SetDeletedByID(contact.DeletedByID).
			SetTags(contact.Tags).
			SetOwnerID(contact.OwnerID).
			SetFullName(contact.FullName).
			SetTitle(contact.Title).
			SetCompany(contact.Company).
			SetEmail(contact.Email).
			SetPhoneNumber(contact.PhoneNumber).
			SetAddress(contact.Address).
			SetStatus(contact.Status).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ControlMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ControlHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if controlType, exists := m.ControlType(); exists {
		create = create.SetControlType(controlType)
	}

	if version, exists := m.Version(); exists {
		create = create.SetVersion(version)
	}

	if controlNumber, exists := m.ControlNumber(); exists {
		create = create.SetControlNumber(controlNumber)
	}

	if family, exists := m.Family(); exists {
		create = create.SetFamily(family)
	}

	if class, exists := m.Class(); exists {
		create = create.SetClass(class)
	}

	if source, exists := m.Source(); exists {
		create = create.SetSource(source)
	}

	if satisfies, exists := m.Satisfies(); exists {
		create = create.SetSatisfies(satisfies)
	}

	if mappedFrameworks, exists := m.MappedFrameworks(); exists {
		create = create.SetMappedFrameworks(mappedFrameworks)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ControlMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		control, err := client.Control.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ControlHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(control.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(control.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(control.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(control.UpdatedByID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(control.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(control.DeletedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(control.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(control.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(control.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(control.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(control.Description)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(control.Status)
		}

		if controlType, exists := m.ControlType(); exists {
			create = create.SetControlType(controlType)
		} else {
			create = create.SetControlType(control.ControlType)
		}

		if version, exists := m.Version(); exists {
			create = create.SetVersion(version)
		} else {
			create = create.SetVersion(control.Version)
		}

		if controlNumber, exists := m.ControlNumber(); exists {
			create = create.SetControlNumber(controlNumber)
		} else {
			create = create.SetControlNumber(control.ControlNumber)
		}

		if family, exists := m.Family(); exists {
			create = create.SetFamily(family)
		} else {
			create = create.SetFamily(control.Family)
		}

		if class, exists := m.Class(); exists {
			create = create.SetClass(class)
		} else {
			create = create.SetClass(control.Class)
		}

		if source, exists := m.Source(); exists {
			create = create.SetSource(source)
		} else {
			create = create.SetSource(control.Source)
		}

		if satisfies, exists := m.Satisfies(); exists {
			create = create.SetSatisfies(satisfies)
		} else {
			create = create.SetSatisfies(control.Satisfies)
		}

		if mappedFrameworks, exists := m.MappedFrameworks(); exists {
			create = create.SetMappedFrameworks(mappedFrameworks)
		} else {
			create = create.SetMappedFrameworks(control.MappedFrameworks)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(control.Details)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ControlMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		control, err := client.Control.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ControlHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(control.CreatedAt).
			SetUpdatedAt(control.UpdatedAt).
			SetCreatedByID(control.CreatedByID).
			SetUpdatedByID(control.UpdatedByID).
			SetDeletedAt(control.DeletedAt).
			SetDeletedByID(control.DeletedByID).
			SetMappingID(control.MappingID).
			SetTags(control.Tags).
			SetOwnerID(control.OwnerID).
			SetName(control.Name).
			SetDescription(control.Description).
			SetStatus(control.Status).
			SetControlType(control.ControlType).
			SetVersion(control.Version).
			SetControlNumber(control.ControlNumber).
			SetFamily(control.Family).
			SetClass(control.Class).
			SetSource(control.Source).
			SetSatisfies(control.Satisfies).
			SetMappedFrameworks(control.MappedFrameworks).
			SetDetails(control.Details).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ControlObjectiveMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ControlObjectiveHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if controlObjectiveType, exists := m.ControlObjectiveType(); exists {
		create = create.SetControlObjectiveType(controlObjectiveType)
	}

	if version, exists := m.Version(); exists {
		create = create.SetVersion(version)
	}

	if controlNumber, exists := m.ControlNumber(); exists {
		create = create.SetControlNumber(controlNumber)
	}

	if family, exists := m.Family(); exists {
		create = create.SetFamily(family)
	}

	if class, exists := m.Class(); exists {
		create = create.SetClass(class)
	}

	if source, exists := m.Source(); exists {
		create = create.SetSource(source)
	}

	if mappedFrameworks, exists := m.MappedFrameworks(); exists {
		create = create.SetMappedFrameworks(mappedFrameworks)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ControlObjectiveMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		controlobjective, err := client.ControlObjective.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ControlObjectiveHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(controlobjective.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(controlobjective.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(controlobjective.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(controlobjective.UpdatedByID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(controlobjective.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(controlobjective.DeletedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(controlobjective.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(controlobjective.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(controlobjective.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(controlobjective.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(controlobjective.Description)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(controlobjective.Status)
		}

		if controlObjectiveType, exists := m.ControlObjectiveType(); exists {
			create = create.SetControlObjectiveType(controlObjectiveType)
		} else {
			create = create.SetControlObjectiveType(controlobjective.ControlObjectiveType)
		}

		if version, exists := m.Version(); exists {
			create = create.SetVersion(version)
		} else {
			create = create.SetVersion(controlobjective.Version)
		}

		if controlNumber, exists := m.ControlNumber(); exists {
			create = create.SetControlNumber(controlNumber)
		} else {
			create = create.SetControlNumber(controlobjective.ControlNumber)
		}

		if family, exists := m.Family(); exists {
			create = create.SetFamily(family)
		} else {
			create = create.SetFamily(controlobjective.Family)
		}

		if class, exists := m.Class(); exists {
			create = create.SetClass(class)
		} else {
			create = create.SetClass(controlobjective.Class)
		}

		if source, exists := m.Source(); exists {
			create = create.SetSource(source)
		} else {
			create = create.SetSource(controlobjective.Source)
		}

		if mappedFrameworks, exists := m.MappedFrameworks(); exists {
			create = create.SetMappedFrameworks(mappedFrameworks)
		} else {
			create = create.SetMappedFrameworks(controlobjective.MappedFrameworks)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(controlobjective.Details)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ControlObjectiveMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		controlobjective, err := client.ControlObjective.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ControlObjectiveHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(controlobjective.CreatedAt).
			SetUpdatedAt(controlobjective.UpdatedAt).
			SetCreatedByID(controlobjective.CreatedByID).
			SetUpdatedByID(controlobjective.UpdatedByID).
			SetDeletedAt(controlobjective.DeletedAt).
			SetDeletedByID(controlobjective.DeletedByID).
			SetMappingID(controlobjective.MappingID).
			SetTags(controlobjective.Tags).
			SetOwnerID(controlobjective.OwnerID).
			SetName(controlobjective.Name).
			SetDescription(controlobjective.Description).
			SetStatus(controlobjective.Status).
			SetControlObjectiveType(controlobjective.ControlObjectiveType).
			SetVersion(controlobjective.Version).
			SetControlNumber(controlobjective.ControlNumber).
			SetFamily(controlobjective.Family).
			SetClass(controlobjective.Class).
			SetSource(controlobjective.Source).
			SetMappedFrameworks(controlobjective.MappedFrameworks).
			SetDetails(controlobjective.Details).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *DocumentDataMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.DocumentDataHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if templateID, exists := m.TemplateID(); exists {
		create = create.SetTemplateID(templateID)
	}

	if data, exists := m.Data(); exists {
		create = create.SetData(data)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *DocumentDataMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		documentdata, err := client.DocumentData.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.DocumentDataHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(documentdata.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(documentdata.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(documentdata.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(documentdata.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(documentdata.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(documentdata.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(documentdata.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(documentdata.DeletedByID)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(documentdata.OwnerID)
		}

		if templateID, exists := m.TemplateID(); exists {
			create = create.SetTemplateID(templateID)
		} else {
			create = create.SetTemplateID(documentdata.TemplateID)
		}

		if data, exists := m.Data(); exists {
			create = create.SetData(data)
		} else {
			create = create.SetData(documentdata.Data)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *DocumentDataMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		documentdata, err := client.DocumentData.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.DocumentDataHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(documentdata.CreatedAt).
			SetUpdatedAt(documentdata.UpdatedAt).
			SetCreatedByID(documentdata.CreatedByID).
			SetUpdatedByID(documentdata.UpdatedByID).
			SetMappingID(documentdata.MappingID).
			SetTags(documentdata.Tags).
			SetDeletedAt(documentdata.DeletedAt).
			SetDeletedByID(documentdata.DeletedByID).
			SetOwnerID(documentdata.OwnerID).
			SetTemplateID(documentdata.TemplateID).
			SetData(documentdata.Data).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *EntityMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.EntityHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if domains, exists := m.Domains(); exists {
		create = create.SetDomains(domains)
	}

	if entityTypeID, exists := m.EntityTypeID(); exists {
		create = create.SetEntityTypeID(entityTypeID)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *EntityMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entity, err := client.Entity.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntityHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(entity.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(entity.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(entity.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(entity.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(entity.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(entity.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(entity.DeletedByID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(entity.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(entity.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(entity.Name)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(entity.DisplayName)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(entity.Description)
		}

		if domains, exists := m.Domains(); exists {
			create = create.SetDomains(domains)
		} else {
			create = create.SetDomains(entity.Domains)
		}

		if entityTypeID, exists := m.EntityTypeID(); exists {
			create = create.SetEntityTypeID(entityTypeID)
		} else {
			create = create.SetEntityTypeID(entity.EntityTypeID)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(entity.Status)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *EntityMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entity, err := client.Entity.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntityHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(entity.CreatedAt).
			SetUpdatedAt(entity.UpdatedAt).
			SetCreatedByID(entity.CreatedByID).
			SetUpdatedByID(entity.UpdatedByID).
			SetMappingID(entity.MappingID).
			SetDeletedAt(entity.DeletedAt).
			SetDeletedByID(entity.DeletedByID).
			SetTags(entity.Tags).
			SetOwnerID(entity.OwnerID).
			SetName(entity.Name).
			SetDisplayName(entity.DisplayName).
			SetDescription(entity.Description).
			SetDomains(entity.Domains).
			SetEntityTypeID(entity.EntityTypeID).
			SetStatus(entity.Status).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *EntityTypeMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.EntityTypeHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *EntityTypeMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entitytype, err := client.EntityType.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntityTypeHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(entitytype.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(entitytype.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(entitytype.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(entitytype.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(entitytype.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(entitytype.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(entitytype.DeletedByID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(entitytype.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(entitytype.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(entitytype.Name)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *EntityTypeMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entitytype, err := client.EntityType.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntityTypeHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(entitytype.CreatedAt).
			SetUpdatedAt(entitytype.UpdatedAt).
			SetCreatedByID(entitytype.CreatedByID).
			SetUpdatedByID(entitytype.UpdatedByID).
			SetMappingID(entitytype.MappingID).
			SetDeletedAt(entitytype.DeletedAt).
			SetDeletedByID(entitytype.DeletedByID).
			SetTags(entitytype.Tags).
			SetOwnerID(entitytype.OwnerID).
			SetName(entitytype.Name).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *EventMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.EventHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if eventID, exists := m.EventID(); exists {
		create = create.SetEventID(eventID)
	}

	if correlationID, exists := m.CorrelationID(); exists {
		create = create.SetCorrelationID(correlationID)
	}

	if eventType, exists := m.EventType(); exists {
		create = create.SetEventType(eventType)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *EventMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		event, err := client.Event.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EventHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(event.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(event.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(event.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(event.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(event.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(event.Tags)
		}

		if eventID, exists := m.EventID(); exists {
			create = create.SetEventID(eventID)
		} else {
			create = create.SetEventID(event.EventID)
		}

		if correlationID, exists := m.CorrelationID(); exists {
			create = create.SetCorrelationID(correlationID)
		} else {
			create = create.SetCorrelationID(event.CorrelationID)
		}

		if eventType, exists := m.EventType(); exists {
			create = create.SetEventType(eventType)
		} else {
			create = create.SetEventType(event.EventType)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(event.Metadata)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *EventMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		event, err := client.Event.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EventHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(event.CreatedAt).
			SetUpdatedAt(event.UpdatedAt).
			SetCreatedByID(event.CreatedByID).
			SetUpdatedByID(event.UpdatedByID).
			SetMappingID(event.MappingID).
			SetTags(event.Tags).
			SetEventID(event.EventID).
			SetCorrelationID(event.CorrelationID).
			SetEventType(event.EventType).
			SetMetadata(event.Metadata).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *FileMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.FileHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if providedFileName, exists := m.ProvidedFileName(); exists {
		create = create.SetProvidedFileName(providedFileName)
	}

	if providedFileExtension, exists := m.ProvidedFileExtension(); exists {
		create = create.SetProvidedFileExtension(providedFileExtension)
	}

	if providedFileSize, exists := m.ProvidedFileSize(); exists {
		create = create.SetProvidedFileSize(providedFileSize)
	}

	if persistedFileSize, exists := m.PersistedFileSize(); exists {
		create = create.SetPersistedFileSize(persistedFileSize)
	}

	if detectedMimeType, exists := m.DetectedMimeType(); exists {
		create = create.SetDetectedMimeType(detectedMimeType)
	}

	if md5Hash, exists := m.Md5Hash(); exists {
		create = create.SetMd5Hash(md5Hash)
	}

	if detectedContentType, exists := m.DetectedContentType(); exists {
		create = create.SetDetectedContentType(detectedContentType)
	}

	if storeKey, exists := m.StoreKey(); exists {
		create = create.SetStoreKey(storeKey)
	}

	if categoryType, exists := m.CategoryType(); exists {
		create = create.SetCategoryType(categoryType)
	}

	if uri, exists := m.URI(); exists {
		create = create.SetURI(uri)
	}

	if storageScheme, exists := m.StorageScheme(); exists {
		create = create.SetStorageScheme(storageScheme)
	}

	if storageVolume, exists := m.StorageVolume(); exists {
		create = create.SetStorageVolume(storageVolume)
	}

	if storagePath, exists := m.StoragePath(); exists {
		create = create.SetStoragePath(storagePath)
	}

	if fileContents, exists := m.FileContents(); exists {
		create = create.SetFileContents(fileContents)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *FileMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		file, err := client.File.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.FileHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(file.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(file.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(file.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(file.UpdatedByID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(file.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(file.DeletedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(file.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(file.Tags)
		}

		if providedFileName, exists := m.ProvidedFileName(); exists {
			create = create.SetProvidedFileName(providedFileName)
		} else {
			create = create.SetProvidedFileName(file.ProvidedFileName)
		}

		if providedFileExtension, exists := m.ProvidedFileExtension(); exists {
			create = create.SetProvidedFileExtension(providedFileExtension)
		} else {
			create = create.SetProvidedFileExtension(file.ProvidedFileExtension)
		}

		if providedFileSize, exists := m.ProvidedFileSize(); exists {
			create = create.SetProvidedFileSize(providedFileSize)
		} else {
			create = create.SetProvidedFileSize(file.ProvidedFileSize)
		}

		if persistedFileSize, exists := m.PersistedFileSize(); exists {
			create = create.SetPersistedFileSize(persistedFileSize)
		} else {
			create = create.SetPersistedFileSize(file.PersistedFileSize)
		}

		if detectedMimeType, exists := m.DetectedMimeType(); exists {
			create = create.SetDetectedMimeType(detectedMimeType)
		} else {
			create = create.SetDetectedMimeType(file.DetectedMimeType)
		}

		if md5Hash, exists := m.Md5Hash(); exists {
			create = create.SetMd5Hash(md5Hash)
		} else {
			create = create.SetMd5Hash(file.Md5Hash)
		}

		if detectedContentType, exists := m.DetectedContentType(); exists {
			create = create.SetDetectedContentType(detectedContentType)
		} else {
			create = create.SetDetectedContentType(file.DetectedContentType)
		}

		if storeKey, exists := m.StoreKey(); exists {
			create = create.SetStoreKey(storeKey)
		} else {
			create = create.SetStoreKey(file.StoreKey)
		}

		if categoryType, exists := m.CategoryType(); exists {
			create = create.SetCategoryType(categoryType)
		} else {
			create = create.SetCategoryType(file.CategoryType)
		}

		if uri, exists := m.URI(); exists {
			create = create.SetURI(uri)
		} else {
			create = create.SetURI(file.URI)
		}

		if storageScheme, exists := m.StorageScheme(); exists {
			create = create.SetStorageScheme(storageScheme)
		} else {
			create = create.SetStorageScheme(file.StorageScheme)
		}

		if storageVolume, exists := m.StorageVolume(); exists {
			create = create.SetStorageVolume(storageVolume)
		} else {
			create = create.SetStorageVolume(file.StorageVolume)
		}

		if storagePath, exists := m.StoragePath(); exists {
			create = create.SetStoragePath(storagePath)
		} else {
			create = create.SetStoragePath(file.StoragePath)
		}

		if fileContents, exists := m.FileContents(); exists {
			create = create.SetFileContents(fileContents)
		} else {
			create = create.SetFileContents(file.FileContents)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *FileMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		file, err := client.File.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.FileHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(file.CreatedAt).
			SetUpdatedAt(file.UpdatedAt).
			SetCreatedByID(file.CreatedByID).
			SetUpdatedByID(file.UpdatedByID).
			SetDeletedAt(file.DeletedAt).
			SetDeletedByID(file.DeletedByID).
			SetMappingID(file.MappingID).
			SetTags(file.Tags).
			SetProvidedFileName(file.ProvidedFileName).
			SetProvidedFileExtension(file.ProvidedFileExtension).
			SetProvidedFileSize(file.ProvidedFileSize).
			SetPersistedFileSize(file.PersistedFileSize).
			SetDetectedMimeType(file.DetectedMimeType).
			SetMd5Hash(file.Md5Hash).
			SetDetectedContentType(file.DetectedContentType).
			SetStoreKey(file.StoreKey).
			SetCategoryType(file.CategoryType).
			SetURI(file.URI).
			SetStorageScheme(file.StorageScheme).
			SetStorageVolume(file.StorageVolume).
			SetStoragePath(file.StoragePath).
			SetFileContents(file.FileContents).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.GroupHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if gravatarLogoURL, exists := m.GravatarLogoURL(); exists {
		create = create.SetGravatarLogoURL(gravatarLogoURL)
	}

	if logoURL, exists := m.LogoURL(); exists {
		create = create.SetLogoURL(logoURL)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *GroupMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		group, err := client.Group.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(group.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(group.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(group.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(group.UpdatedByID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(group.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(group.DeletedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(group.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(group.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(group.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(group.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(group.Description)
		}

		if gravatarLogoURL, exists := m.GravatarLogoURL(); exists {
			create = create.SetGravatarLogoURL(gravatarLogoURL)
		} else {
			create = create.SetGravatarLogoURL(group.GravatarLogoURL)
		}

		if logoURL, exists := m.LogoURL(); exists {
			create = create.SetLogoURL(logoURL)
		} else {
			create = create.SetLogoURL(group.LogoURL)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(group.DisplayName)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		group, err := client.Group.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(group.CreatedAt).
			SetUpdatedAt(group.UpdatedAt).
			SetCreatedByID(group.CreatedByID).
			SetUpdatedByID(group.UpdatedByID).
			SetDeletedAt(group.DeletedAt).
			SetDeletedByID(group.DeletedByID).
			SetMappingID(group.MappingID).
			SetTags(group.Tags).
			SetOwnerID(group.OwnerID).
			SetName(group.Name).
			SetDescription(group.Description).
			SetGravatarLogoURL(group.GravatarLogoURL).
			SetLogoURL(group.LogoURL).
			SetDisplayName(group.DisplayName).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupMembershipMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.GroupMembershipHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	}

	if groupID, exists := m.GroupID(); exists {
		create = create.SetGroupID(groupID)
	}

	if userID, exists := m.UserID(); exists {
		create = create.SetUserID(userID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *GroupMembershipMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		groupmembership, err := client.GroupMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupMembershipHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(groupmembership.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(groupmembership.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(groupmembership.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(groupmembership.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(groupmembership.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(groupmembership.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(groupmembership.DeletedByID)
		}

		if role, exists := m.Role(); exists {
			create = create.SetRole(role)
		} else {
			create = create.SetRole(groupmembership.Role)
		}

		if groupID, exists := m.GroupID(); exists {
			create = create.SetGroupID(groupID)
		} else {
			create = create.SetGroupID(groupmembership.GroupID)
		}

		if userID, exists := m.UserID(); exists {
			create = create.SetUserID(userID)
		} else {
			create = create.SetUserID(groupmembership.UserID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupMembershipMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		groupmembership, err := client.GroupMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupMembershipHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(groupmembership.CreatedAt).
			SetUpdatedAt(groupmembership.UpdatedAt).
			SetCreatedByID(groupmembership.CreatedByID).
			SetUpdatedByID(groupmembership.UpdatedByID).
			SetMappingID(groupmembership.MappingID).
			SetDeletedAt(groupmembership.DeletedAt).
			SetDeletedByID(groupmembership.DeletedByID).
			SetRole(groupmembership.Role).
			SetGroupID(groupmembership.GroupID).
			SetUserID(groupmembership.UserID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupSettingMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.GroupSettingHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if visibility, exists := m.Visibility(); exists {
		create = create.SetVisibility(visibility)
	}

	if joinPolicy, exists := m.JoinPolicy(); exists {
		create = create.SetJoinPolicy(joinPolicy)
	}

	if syncToSlack, exists := m.SyncToSlack(); exists {
		create = create.SetSyncToSlack(syncToSlack)
	}

	if syncToGithub, exists := m.SyncToGithub(); exists {
		create = create.SetSyncToGithub(syncToGithub)
	}

	if groupID, exists := m.GroupID(); exists {
		create = create.SetGroupID(groupID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *GroupSettingMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		groupsetting, err := client.GroupSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupSettingHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(groupsetting.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(groupsetting.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(groupsetting.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(groupsetting.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(groupsetting.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(groupsetting.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(groupsetting.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(groupsetting.DeletedByID)
		}

		if visibility, exists := m.Visibility(); exists {
			create = create.SetVisibility(visibility)
		} else {
			create = create.SetVisibility(groupsetting.Visibility)
		}

		if joinPolicy, exists := m.JoinPolicy(); exists {
			create = create.SetJoinPolicy(joinPolicy)
		} else {
			create = create.SetJoinPolicy(groupsetting.JoinPolicy)
		}

		if syncToSlack, exists := m.SyncToSlack(); exists {
			create = create.SetSyncToSlack(syncToSlack)
		} else {
			create = create.SetSyncToSlack(groupsetting.SyncToSlack)
		}

		if syncToGithub, exists := m.SyncToGithub(); exists {
			create = create.SetSyncToGithub(syncToGithub)
		} else {
			create = create.SetSyncToGithub(groupsetting.SyncToGithub)
		}

		if groupID, exists := m.GroupID(); exists {
			create = create.SetGroupID(groupID)
		} else {
			create = create.SetGroupID(groupsetting.GroupID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupSettingMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		groupsetting, err := client.GroupSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupSettingHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(groupsetting.CreatedAt).
			SetUpdatedAt(groupsetting.UpdatedAt).
			SetCreatedByID(groupsetting.CreatedByID).
			SetUpdatedByID(groupsetting.UpdatedByID).
			SetMappingID(groupsetting.MappingID).
			SetTags(groupsetting.Tags).
			SetDeletedAt(groupsetting.DeletedAt).
			SetDeletedByID(groupsetting.DeletedByID).
			SetVisibility(groupsetting.Visibility).
			SetJoinPolicy(groupsetting.JoinPolicy).
			SetSyncToSlack(groupsetting.SyncToSlack).
			SetSyncToGithub(groupsetting.SyncToGithub).
			SetGroupID(groupsetting.GroupID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *HushMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.HushHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if kind, exists := m.Kind(); exists {
		create = create.SetKind(kind)
	}

	if secretName, exists := m.SecretName(); exists {
		create = create.SetSecretName(secretName)
	}

	if secretValue, exists := m.SecretValue(); exists {
		create = create.SetSecretValue(secretValue)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *HushMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		hush, err := client.Hush.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.HushHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(hush.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(hush.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(hush.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(hush.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(hush.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(hush.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(hush.DeletedByID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(hush.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(hush.Description)
		}

		if kind, exists := m.Kind(); exists {
			create = create.SetKind(kind)
		} else {
			create = create.SetKind(hush.Kind)
		}

		if secretName, exists := m.SecretName(); exists {
			create = create.SetSecretName(secretName)
		} else {
			create = create.SetSecretName(hush.SecretName)
		}

		if secretValue, exists := m.SecretValue(); exists {
			create = create.SetSecretValue(secretValue)
		} else {
			create = create.SetSecretValue(hush.SecretValue)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *HushMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		hush, err := client.Hush.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.HushHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(hush.CreatedAt).
			SetUpdatedAt(hush.UpdatedAt).
			SetCreatedByID(hush.CreatedByID).
			SetUpdatedByID(hush.UpdatedByID).
			SetMappingID(hush.MappingID).
			SetDeletedAt(hush.DeletedAt).
			SetDeletedByID(hush.DeletedByID).
			SetName(hush.Name).
			SetDescription(hush.Description).
			SetKind(hush.Kind).
			SetSecretName(hush.SecretName).
			SetSecretValue(hush.SecretValue).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *IntegrationMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.IntegrationHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if kind, exists := m.Kind(); exists {
		create = create.SetKind(kind)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *IntegrationMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		integration, err := client.Integration.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.IntegrationHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(integration.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(integration.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(integration.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(integration.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(integration.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(integration.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(integration.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(integration.DeletedByID)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(integration.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(integration.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(integration.Description)
		}

		if kind, exists := m.Kind(); exists {
			create = create.SetKind(kind)
		} else {
			create = create.SetKind(integration.Kind)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *IntegrationMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		integration, err := client.Integration.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.IntegrationHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(integration.CreatedAt).
			SetUpdatedAt(integration.UpdatedAt).
			SetCreatedByID(integration.CreatedByID).
			SetUpdatedByID(integration.UpdatedByID).
			SetMappingID(integration.MappingID).
			SetTags(integration.Tags).
			SetDeletedAt(integration.DeletedAt).
			SetDeletedByID(integration.DeletedByID).
			SetOwnerID(integration.OwnerID).
			SetName(integration.Name).
			SetDescription(integration.Description).
			SetKind(integration.Kind).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *InternalPolicyMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.InternalPolicyHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if policyType, exists := m.PolicyType(); exists {
		create = create.SetPolicyType(policyType)
	}

	if version, exists := m.Version(); exists {
		create = create.SetVersion(version)
	}

	if purposeAndScope, exists := m.PurposeAndScope(); exists {
		create = create.SetPurposeAndScope(purposeAndScope)
	}

	if background, exists := m.Background(); exists {
		create = create.SetBackground(background)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *InternalPolicyMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		internalpolicy, err := client.InternalPolicy.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.InternalPolicyHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(internalpolicy.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(internalpolicy.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(internalpolicy.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(internalpolicy.UpdatedByID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(internalpolicy.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(internalpolicy.DeletedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(internalpolicy.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(internalpolicy.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(internalpolicy.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(internalpolicy.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(internalpolicy.Description)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(internalpolicy.Status)
		}

		if policyType, exists := m.PolicyType(); exists {
			create = create.SetPolicyType(policyType)
		} else {
			create = create.SetPolicyType(internalpolicy.PolicyType)
		}

		if version, exists := m.Version(); exists {
			create = create.SetVersion(version)
		} else {
			create = create.SetVersion(internalpolicy.Version)
		}

		if purposeAndScope, exists := m.PurposeAndScope(); exists {
			create = create.SetPurposeAndScope(purposeAndScope)
		} else {
			create = create.SetPurposeAndScope(internalpolicy.PurposeAndScope)
		}

		if background, exists := m.Background(); exists {
			create = create.SetBackground(background)
		} else {
			create = create.SetBackground(internalpolicy.Background)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(internalpolicy.Details)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *InternalPolicyMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		internalpolicy, err := client.InternalPolicy.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.InternalPolicyHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(internalpolicy.CreatedAt).
			SetUpdatedAt(internalpolicy.UpdatedAt).
			SetCreatedByID(internalpolicy.CreatedByID).
			SetUpdatedByID(internalpolicy.UpdatedByID).
			SetDeletedAt(internalpolicy.DeletedAt).
			SetDeletedByID(internalpolicy.DeletedByID).
			SetMappingID(internalpolicy.MappingID).
			SetTags(internalpolicy.Tags).
			SetOwnerID(internalpolicy.OwnerID).
			SetName(internalpolicy.Name).
			SetDescription(internalpolicy.Description).
			SetStatus(internalpolicy.Status).
			SetPolicyType(internalpolicy.PolicyType).
			SetVersion(internalpolicy.Version).
			SetPurposeAndScope(internalpolicy.PurposeAndScope).
			SetBackground(internalpolicy.Background).
			SetDetails(internalpolicy.Details).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *NarrativeMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.NarrativeHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if satisfies, exists := m.Satisfies(); exists {
		create = create.SetSatisfies(satisfies)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *NarrativeMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		narrative, err := client.Narrative.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.NarrativeHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(narrative.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(narrative.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(narrative.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(narrative.UpdatedByID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(narrative.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(narrative.DeletedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(narrative.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(narrative.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(narrative.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(narrative.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(narrative.Description)
		}

		if satisfies, exists := m.Satisfies(); exists {
			create = create.SetSatisfies(satisfies)
		} else {
			create = create.SetSatisfies(narrative.Satisfies)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(narrative.Details)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *NarrativeMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		narrative, err := client.Narrative.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.NarrativeHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(narrative.CreatedAt).
			SetUpdatedAt(narrative.UpdatedAt).
			SetCreatedByID(narrative.CreatedByID).
			SetUpdatedByID(narrative.UpdatedByID).
			SetDeletedAt(narrative.DeletedAt).
			SetDeletedByID(narrative.DeletedByID).
			SetMappingID(narrative.MappingID).
			SetTags(narrative.Tags).
			SetOwnerID(narrative.OwnerID).
			SetName(narrative.Name).
			SetDescription(narrative.Description).
			SetSatisfies(narrative.Satisfies).
			SetDetails(narrative.Details).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *NoteMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.NoteHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if text, exists := m.Text(); exists {
		create = create.SetText(text)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *NoteMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		note, err := client.Note.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.NoteHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(note.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(note.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(note.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(note.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(note.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(note.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(note.DeletedByID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(note.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(note.OwnerID)
		}

		if text, exists := m.Text(); exists {
			create = create.SetText(text)
		} else {
			create = create.SetText(note.Text)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *NoteMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		note, err := client.Note.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.NoteHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(note.CreatedAt).
			SetUpdatedAt(note.UpdatedAt).
			SetCreatedByID(note.CreatedByID).
			SetUpdatedByID(note.UpdatedByID).
			SetMappingID(note.MappingID).
			SetDeletedAt(note.DeletedAt).
			SetDeletedByID(note.DeletedByID).
			SetTags(note.Tags).
			SetOwnerID(note.OwnerID).
			SetText(note.Text).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *OrgMembershipMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.OrgMembershipHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	}

	if organizationID, exists := m.OrganizationID(); exists {
		create = create.SetOrganizationID(organizationID)
	}

	if userID, exists := m.UserID(); exists {
		create = create.SetUserID(userID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *OrgMembershipMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		orgmembership, err := client.OrgMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrgMembershipHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(orgmembership.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(orgmembership.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(orgmembership.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(orgmembership.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(orgmembership.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(orgmembership.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(orgmembership.DeletedByID)
		}

		if role, exists := m.Role(); exists {
			create = create.SetRole(role)
		} else {
			create = create.SetRole(orgmembership.Role)
		}

		if organizationID, exists := m.OrganizationID(); exists {
			create = create.SetOrganizationID(organizationID)
		} else {
			create = create.SetOrganizationID(orgmembership.OrganizationID)
		}

		if userID, exists := m.UserID(); exists {
			create = create.SetUserID(userID)
		} else {
			create = create.SetUserID(orgmembership.UserID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *OrgMembershipMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		orgmembership, err := client.OrgMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrgMembershipHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(orgmembership.CreatedAt).
			SetUpdatedAt(orgmembership.UpdatedAt).
			SetCreatedByID(orgmembership.CreatedByID).
			SetUpdatedByID(orgmembership.UpdatedByID).
			SetMappingID(orgmembership.MappingID).
			SetDeletedAt(orgmembership.DeletedAt).
			SetDeletedByID(orgmembership.DeletedByID).
			SetRole(orgmembership.Role).
			SetOrganizationID(orgmembership.OrganizationID).
			SetUserID(orgmembership.UserID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *OrgSubscriptionMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.OrgSubscriptionHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if stripeSubscriptionID, exists := m.StripeSubscriptionID(); exists {
		create = create.SetStripeSubscriptionID(stripeSubscriptionID)
	}

	if productTier, exists := m.ProductTier(); exists {
		create = create.SetProductTier(productTier)
	}

	if stripeProductTierID, exists := m.StripeProductTierID(); exists {
		create = create.SetStripeProductTierID(stripeProductTierID)
	}

	if stripeSubscriptionStatus, exists := m.StripeSubscriptionStatus(); exists {
		create = create.SetStripeSubscriptionStatus(stripeSubscriptionStatus)
	}

	if active, exists := m.Active(); exists {
		create = create.SetActive(active)
	}

	if stripeCustomerID, exists := m.StripeCustomerID(); exists {
		create = create.SetStripeCustomerID(stripeCustomerID)
	}

	if expiresAt, exists := m.ExpiresAt(); exists {
		create = create.SetNillableExpiresAt(&expiresAt)
	}

	if features, exists := m.Features(); exists {
		create = create.SetFeatures(features)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *OrgSubscriptionMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		orgsubscription, err := client.OrgSubscription.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrgSubscriptionHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(orgsubscription.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(orgsubscription.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(orgsubscription.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(orgsubscription.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(orgsubscription.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(orgsubscription.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(orgsubscription.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(orgsubscription.DeletedByID)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(orgsubscription.OwnerID)
		}

		if stripeSubscriptionID, exists := m.StripeSubscriptionID(); exists {
			create = create.SetStripeSubscriptionID(stripeSubscriptionID)
		} else {
			create = create.SetStripeSubscriptionID(orgsubscription.StripeSubscriptionID)
		}

		if productTier, exists := m.ProductTier(); exists {
			create = create.SetProductTier(productTier)
		} else {
			create = create.SetProductTier(orgsubscription.ProductTier)
		}

		if stripeProductTierID, exists := m.StripeProductTierID(); exists {
			create = create.SetStripeProductTierID(stripeProductTierID)
		} else {
			create = create.SetStripeProductTierID(orgsubscription.StripeProductTierID)
		}

		if stripeSubscriptionStatus, exists := m.StripeSubscriptionStatus(); exists {
			create = create.SetStripeSubscriptionStatus(stripeSubscriptionStatus)
		} else {
			create = create.SetStripeSubscriptionStatus(orgsubscription.StripeSubscriptionStatus)
		}

		if active, exists := m.Active(); exists {
			create = create.SetActive(active)
		} else {
			create = create.SetActive(orgsubscription.Active)
		}

		if stripeCustomerID, exists := m.StripeCustomerID(); exists {
			create = create.SetStripeCustomerID(stripeCustomerID)
		} else {
			create = create.SetStripeCustomerID(orgsubscription.StripeCustomerID)
		}

		if expiresAt, exists := m.ExpiresAt(); exists {
			create = create.SetNillableExpiresAt(&expiresAt)
		} else {
			create = create.SetNillableExpiresAt(orgsubscription.ExpiresAt)
		}

		if features, exists := m.Features(); exists {
			create = create.SetFeatures(features)
		} else {
			create = create.SetFeatures(orgsubscription.Features)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *OrgSubscriptionMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		orgsubscription, err := client.OrgSubscription.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrgSubscriptionHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(orgsubscription.CreatedAt).
			SetUpdatedAt(orgsubscription.UpdatedAt).
			SetCreatedByID(orgsubscription.CreatedByID).
			SetUpdatedByID(orgsubscription.UpdatedByID).
			SetMappingID(orgsubscription.MappingID).
			SetTags(orgsubscription.Tags).
			SetDeletedAt(orgsubscription.DeletedAt).
			SetDeletedByID(orgsubscription.DeletedByID).
			SetOwnerID(orgsubscription.OwnerID).
			SetStripeSubscriptionID(orgsubscription.StripeSubscriptionID).
			SetProductTier(orgsubscription.ProductTier).
			SetStripeProductTierID(orgsubscription.StripeProductTierID).
			SetStripeSubscriptionStatus(orgsubscription.StripeSubscriptionStatus).
			SetActive(orgsubscription.Active).
			SetStripeCustomerID(orgsubscription.StripeCustomerID).
			SetNillableExpiresAt(orgsubscription.ExpiresAt).
			SetFeatures(orgsubscription.Features).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *OrganizationMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.OrganizationHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if parentOrganizationID, exists := m.ParentOrganizationID(); exists {
		create = create.SetParentOrganizationID(parentOrganizationID)
	}

	if personalOrg, exists := m.PersonalOrg(); exists {
		create = create.SetPersonalOrg(personalOrg)
	}

	if avatarRemoteURL, exists := m.AvatarRemoteURL(); exists {
		create = create.SetNillableAvatarRemoteURL(&avatarRemoteURL)
	}

	if dedicatedDb, exists := m.DedicatedDb(); exists {
		create = create.SetDedicatedDb(dedicatedDb)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *OrganizationMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		organization, err := client.Organization.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrganizationHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(organization.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(organization.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(organization.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(organization.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(organization.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(organization.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(organization.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(organization.DeletedByID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(organization.Name)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(organization.DisplayName)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(organization.Description)
		}

		if parentOrganizationID, exists := m.ParentOrganizationID(); exists {
			create = create.SetParentOrganizationID(parentOrganizationID)
		} else {
			create = create.SetParentOrganizationID(organization.ParentOrganizationID)
		}

		if personalOrg, exists := m.PersonalOrg(); exists {
			create = create.SetPersonalOrg(personalOrg)
		} else {
			create = create.SetPersonalOrg(organization.PersonalOrg)
		}

		if avatarRemoteURL, exists := m.AvatarRemoteURL(); exists {
			create = create.SetNillableAvatarRemoteURL(&avatarRemoteURL)
		} else {
			create = create.SetNillableAvatarRemoteURL(organization.AvatarRemoteURL)
		}

		if dedicatedDb, exists := m.DedicatedDb(); exists {
			create = create.SetDedicatedDb(dedicatedDb)
		} else {
			create = create.SetDedicatedDb(organization.DedicatedDb)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *OrganizationMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		organization, err := client.Organization.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrganizationHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(organization.CreatedAt).
			SetUpdatedAt(organization.UpdatedAt).
			SetCreatedByID(organization.CreatedByID).
			SetUpdatedByID(organization.UpdatedByID).
			SetMappingID(organization.MappingID).
			SetTags(organization.Tags).
			SetDeletedAt(organization.DeletedAt).
			SetDeletedByID(organization.DeletedByID).
			SetName(organization.Name).
			SetDisplayName(organization.DisplayName).
			SetDescription(organization.Description).
			SetParentOrganizationID(organization.ParentOrganizationID).
			SetPersonalOrg(organization.PersonalOrg).
			SetNillableAvatarRemoteURL(organization.AvatarRemoteURL).
			SetDedicatedDb(organization.DedicatedDb).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *OrganizationSettingMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.OrganizationSettingHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if domains, exists := m.Domains(); exists {
		create = create.SetDomains(domains)
	}

	if billingContact, exists := m.BillingContact(); exists {
		create = create.SetBillingContact(billingContact)
	}

	if billingEmail, exists := m.BillingEmail(); exists {
		create = create.SetBillingEmail(billingEmail)
	}

	if billingPhone, exists := m.BillingPhone(); exists {
		create = create.SetBillingPhone(billingPhone)
	}

	if billingAddress, exists := m.BillingAddress(); exists {
		create = create.SetBillingAddress(billingAddress)
	}

	if taxIdentifier, exists := m.TaxIdentifier(); exists {
		create = create.SetTaxIdentifier(taxIdentifier)
	}

	if geoLocation, exists := m.GeoLocation(); exists {
		create = create.SetGeoLocation(geoLocation)
	}

	if organizationID, exists := m.OrganizationID(); exists {
		create = create.SetOrganizationID(organizationID)
	}

	if stripeID, exists := m.StripeID(); exists {
		create = create.SetStripeID(stripeID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *OrganizationSettingMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		organizationsetting, err := client.OrganizationSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrganizationSettingHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(organizationsetting.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(organizationsetting.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(organizationsetting.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(organizationsetting.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(organizationsetting.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(organizationsetting.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(organizationsetting.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(organizationsetting.DeletedByID)
		}

		if domains, exists := m.Domains(); exists {
			create = create.SetDomains(domains)
		} else {
			create = create.SetDomains(organizationsetting.Domains)
		}

		if billingContact, exists := m.BillingContact(); exists {
			create = create.SetBillingContact(billingContact)
		} else {
			create = create.SetBillingContact(organizationsetting.BillingContact)
		}

		if billingEmail, exists := m.BillingEmail(); exists {
			create = create.SetBillingEmail(billingEmail)
		} else {
			create = create.SetBillingEmail(organizationsetting.BillingEmail)
		}

		if billingPhone, exists := m.BillingPhone(); exists {
			create = create.SetBillingPhone(billingPhone)
		} else {
			create = create.SetBillingPhone(organizationsetting.BillingPhone)
		}

		if billingAddress, exists := m.BillingAddress(); exists {
			create = create.SetBillingAddress(billingAddress)
		} else {
			create = create.SetBillingAddress(organizationsetting.BillingAddress)
		}

		if taxIdentifier, exists := m.TaxIdentifier(); exists {
			create = create.SetTaxIdentifier(taxIdentifier)
		} else {
			create = create.SetTaxIdentifier(organizationsetting.TaxIdentifier)
		}

		if geoLocation, exists := m.GeoLocation(); exists {
			create = create.SetGeoLocation(geoLocation)
		} else {
			create = create.SetGeoLocation(organizationsetting.GeoLocation)
		}

		if organizationID, exists := m.OrganizationID(); exists {
			create = create.SetOrganizationID(organizationID)
		} else {
			create = create.SetOrganizationID(organizationsetting.OrganizationID)
		}

		if stripeID, exists := m.StripeID(); exists {
			create = create.SetStripeID(stripeID)
		} else {
			create = create.SetStripeID(organizationsetting.StripeID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *OrganizationSettingMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		organizationsetting, err := client.OrganizationSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrganizationSettingHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(organizationsetting.CreatedAt).
			SetUpdatedAt(organizationsetting.UpdatedAt).
			SetCreatedByID(organizationsetting.CreatedByID).
			SetUpdatedByID(organizationsetting.UpdatedByID).
			SetMappingID(organizationsetting.MappingID).
			SetTags(organizationsetting.Tags).
			SetDeletedAt(organizationsetting.DeletedAt).
			SetDeletedByID(organizationsetting.DeletedByID).
			SetDomains(organizationsetting.Domains).
			SetBillingContact(organizationsetting.BillingContact).
			SetBillingEmail(organizationsetting.BillingEmail).
			SetBillingPhone(organizationsetting.BillingPhone).
			SetBillingAddress(organizationsetting.BillingAddress).
			SetTaxIdentifier(organizationsetting.TaxIdentifier).
			SetGeoLocation(organizationsetting.GeoLocation).
			SetOrganizationID(organizationsetting.OrganizationID).
			SetStripeID(organizationsetting.StripeID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ProcedureMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ProcedureHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if procedureType, exists := m.ProcedureType(); exists {
		create = create.SetProcedureType(procedureType)
	}

	if version, exists := m.Version(); exists {
		create = create.SetVersion(version)
	}

	if purposeAndScope, exists := m.PurposeAndScope(); exists {
		create = create.SetPurposeAndScope(purposeAndScope)
	}

	if background, exists := m.Background(); exists {
		create = create.SetBackground(background)
	}

	if satisfies, exists := m.Satisfies(); exists {
		create = create.SetSatisfies(satisfies)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ProcedureMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		procedure, err := client.Procedure.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ProcedureHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(procedure.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(procedure.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(procedure.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(procedure.UpdatedByID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(procedure.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(procedure.DeletedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(procedure.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(procedure.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(procedure.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(procedure.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(procedure.Description)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(procedure.Status)
		}

		if procedureType, exists := m.ProcedureType(); exists {
			create = create.SetProcedureType(procedureType)
		} else {
			create = create.SetProcedureType(procedure.ProcedureType)
		}

		if version, exists := m.Version(); exists {
			create = create.SetVersion(version)
		} else {
			create = create.SetVersion(procedure.Version)
		}

		if purposeAndScope, exists := m.PurposeAndScope(); exists {
			create = create.SetPurposeAndScope(purposeAndScope)
		} else {
			create = create.SetPurposeAndScope(procedure.PurposeAndScope)
		}

		if background, exists := m.Background(); exists {
			create = create.SetBackground(background)
		} else {
			create = create.SetBackground(procedure.Background)
		}

		if satisfies, exists := m.Satisfies(); exists {
			create = create.SetSatisfies(satisfies)
		} else {
			create = create.SetSatisfies(procedure.Satisfies)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(procedure.Details)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ProcedureMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		procedure, err := client.Procedure.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ProcedureHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(procedure.CreatedAt).
			SetUpdatedAt(procedure.UpdatedAt).
			SetCreatedByID(procedure.CreatedByID).
			SetUpdatedByID(procedure.UpdatedByID).
			SetDeletedAt(procedure.DeletedAt).
			SetDeletedByID(procedure.DeletedByID).
			SetMappingID(procedure.MappingID).
			SetTags(procedure.Tags).
			SetOwnerID(procedure.OwnerID).
			SetName(procedure.Name).
			SetDescription(procedure.Description).
			SetStatus(procedure.Status).
			SetProcedureType(procedure.ProcedureType).
			SetVersion(procedure.Version).
			SetPurposeAndScope(procedure.PurposeAndScope).
			SetBackground(procedure.Background).
			SetSatisfies(procedure.Satisfies).
			SetDetails(procedure.Details).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ProgramMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ProgramHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if startDate, exists := m.StartDate(); exists {
		create = create.SetStartDate(startDate)
	}

	if endDate, exists := m.EndDate(); exists {
		create = create.SetEndDate(endDate)
	}

	if auditorReady, exists := m.AuditorReady(); exists {
		create = create.SetAuditorReady(auditorReady)
	}

	if auditorWriteComments, exists := m.AuditorWriteComments(); exists {
		create = create.SetAuditorWriteComments(auditorWriteComments)
	}

	if auditorReadComments, exists := m.AuditorReadComments(); exists {
		create = create.SetAuditorReadComments(auditorReadComments)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ProgramMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		program, err := client.Program.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ProgramHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(program.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(program.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(program.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(program.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(program.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(program.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(program.DeletedByID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(program.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(program.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(program.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(program.Description)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(program.Status)
		}

		if startDate, exists := m.StartDate(); exists {
			create = create.SetStartDate(startDate)
		} else {
			create = create.SetStartDate(program.StartDate)
		}

		if endDate, exists := m.EndDate(); exists {
			create = create.SetEndDate(endDate)
		} else {
			create = create.SetEndDate(program.EndDate)
		}

		if auditorReady, exists := m.AuditorReady(); exists {
			create = create.SetAuditorReady(auditorReady)
		} else {
			create = create.SetAuditorReady(program.AuditorReady)
		}

		if auditorWriteComments, exists := m.AuditorWriteComments(); exists {
			create = create.SetAuditorWriteComments(auditorWriteComments)
		} else {
			create = create.SetAuditorWriteComments(program.AuditorWriteComments)
		}

		if auditorReadComments, exists := m.AuditorReadComments(); exists {
			create = create.SetAuditorReadComments(auditorReadComments)
		} else {
			create = create.SetAuditorReadComments(program.AuditorReadComments)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ProgramMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		program, err := client.Program.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ProgramHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(program.CreatedAt).
			SetUpdatedAt(program.UpdatedAt).
			SetCreatedByID(program.CreatedByID).
			SetUpdatedByID(program.UpdatedByID).
			SetMappingID(program.MappingID).
			SetDeletedAt(program.DeletedAt).
			SetDeletedByID(program.DeletedByID).
			SetTags(program.Tags).
			SetOwnerID(program.OwnerID).
			SetName(program.Name).
			SetDescription(program.Description).
			SetStatus(program.Status).
			SetStartDate(program.StartDate).
			SetEndDate(program.EndDate).
			SetAuditorReady(program.AuditorReady).
			SetAuditorWriteComments(program.AuditorWriteComments).
			SetAuditorReadComments(program.AuditorReadComments).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ProgramMembershipMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ProgramMembershipHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	}

	if programID, exists := m.ProgramID(); exists {
		create = create.SetProgramID(programID)
	}

	if userID, exists := m.UserID(); exists {
		create = create.SetUserID(userID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ProgramMembershipMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		programmembership, err := client.ProgramMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ProgramMembershipHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(programmembership.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(programmembership.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(programmembership.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(programmembership.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(programmembership.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(programmembership.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(programmembership.DeletedByID)
		}

		if role, exists := m.Role(); exists {
			create = create.SetRole(role)
		} else {
			create = create.SetRole(programmembership.Role)
		}

		if programID, exists := m.ProgramID(); exists {
			create = create.SetProgramID(programID)
		} else {
			create = create.SetProgramID(programmembership.ProgramID)
		}

		if userID, exists := m.UserID(); exists {
			create = create.SetUserID(userID)
		} else {
			create = create.SetUserID(programmembership.UserID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ProgramMembershipMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		programmembership, err := client.ProgramMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ProgramMembershipHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(programmembership.CreatedAt).
			SetUpdatedAt(programmembership.UpdatedAt).
			SetCreatedByID(programmembership.CreatedByID).
			SetUpdatedByID(programmembership.UpdatedByID).
			SetMappingID(programmembership.MappingID).
			SetDeletedAt(programmembership.DeletedAt).
			SetDeletedByID(programmembership.DeletedByID).
			SetRole(programmembership.Role).
			SetProgramID(programmembership.ProgramID).
			SetUserID(programmembership.UserID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *RiskMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.RiskHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if riskType, exists := m.RiskType(); exists {
		create = create.SetRiskType(riskType)
	}

	if businessCosts, exists := m.BusinessCosts(); exists {
		create = create.SetBusinessCosts(businessCosts)
	}

	if impact, exists := m.Impact(); exists {
		create = create.SetImpact(impact)
	}

	if likelihood, exists := m.Likelihood(); exists {
		create = create.SetLikelihood(likelihood)
	}

	if mitigation, exists := m.Mitigation(); exists {
		create = create.SetMitigation(mitigation)
	}

	if satisfies, exists := m.Satisfies(); exists {
		create = create.SetSatisfies(satisfies)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *RiskMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		risk, err := client.Risk.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.RiskHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(risk.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(risk.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(risk.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(risk.UpdatedByID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(risk.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(risk.DeletedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(risk.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(risk.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(risk.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(risk.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(risk.Description)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(risk.Status)
		}

		if riskType, exists := m.RiskType(); exists {
			create = create.SetRiskType(riskType)
		} else {
			create = create.SetRiskType(risk.RiskType)
		}

		if businessCosts, exists := m.BusinessCosts(); exists {
			create = create.SetBusinessCosts(businessCosts)
		} else {
			create = create.SetBusinessCosts(risk.BusinessCosts)
		}

		if impact, exists := m.Impact(); exists {
			create = create.SetImpact(impact)
		} else {
			create = create.SetImpact(risk.Impact)
		}

		if likelihood, exists := m.Likelihood(); exists {
			create = create.SetLikelihood(likelihood)
		} else {
			create = create.SetLikelihood(risk.Likelihood)
		}

		if mitigation, exists := m.Mitigation(); exists {
			create = create.SetMitigation(mitigation)
		} else {
			create = create.SetMitigation(risk.Mitigation)
		}

		if satisfies, exists := m.Satisfies(); exists {
			create = create.SetSatisfies(satisfies)
		} else {
			create = create.SetSatisfies(risk.Satisfies)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(risk.Details)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *RiskMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		risk, err := client.Risk.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.RiskHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(risk.CreatedAt).
			SetUpdatedAt(risk.UpdatedAt).
			SetCreatedByID(risk.CreatedByID).
			SetUpdatedByID(risk.UpdatedByID).
			SetDeletedAt(risk.DeletedAt).
			SetDeletedByID(risk.DeletedByID).
			SetMappingID(risk.MappingID).
			SetTags(risk.Tags).
			SetOwnerID(risk.OwnerID).
			SetName(risk.Name).
			SetDescription(risk.Description).
			SetStatus(risk.Status).
			SetRiskType(risk.RiskType).
			SetBusinessCosts(risk.BusinessCosts).
			SetImpact(risk.Impact).
			SetLikelihood(risk.Likelihood).
			SetMitigation(risk.Mitigation).
			SetSatisfies(risk.Satisfies).
			SetDetails(risk.Details).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *StandardMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.StandardHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if family, exists := m.Family(); exists {
		create = create.SetFamily(family)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if standardType, exists := m.StandardType(); exists {
		create = create.SetStandardType(standardType)
	}

	if version, exists := m.Version(); exists {
		create = create.SetVersion(version)
	}

	if purposeAndScope, exists := m.PurposeAndScope(); exists {
		create = create.SetPurposeAndScope(purposeAndScope)
	}

	if background, exists := m.Background(); exists {
		create = create.SetBackground(background)
	}

	if satisfies, exists := m.Satisfies(); exists {
		create = create.SetSatisfies(satisfies)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *StandardMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		standard, err := client.Standard.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.StandardHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(standard.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(standard.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(standard.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(standard.UpdatedByID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(standard.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(standard.DeletedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(standard.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(standard.Tags)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(standard.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(standard.Description)
		}

		if family, exists := m.Family(); exists {
			create = create.SetFamily(family)
		} else {
			create = create.SetFamily(standard.Family)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(standard.Status)
		}

		if standardType, exists := m.StandardType(); exists {
			create = create.SetStandardType(standardType)
		} else {
			create = create.SetStandardType(standard.StandardType)
		}

		if version, exists := m.Version(); exists {
			create = create.SetVersion(version)
		} else {
			create = create.SetVersion(standard.Version)
		}

		if purposeAndScope, exists := m.PurposeAndScope(); exists {
			create = create.SetPurposeAndScope(purposeAndScope)
		} else {
			create = create.SetPurposeAndScope(standard.PurposeAndScope)
		}

		if background, exists := m.Background(); exists {
			create = create.SetBackground(background)
		} else {
			create = create.SetBackground(standard.Background)
		}

		if satisfies, exists := m.Satisfies(); exists {
			create = create.SetSatisfies(satisfies)
		} else {
			create = create.SetSatisfies(standard.Satisfies)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(standard.Details)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *StandardMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		standard, err := client.Standard.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.StandardHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(standard.CreatedAt).
			SetUpdatedAt(standard.UpdatedAt).
			SetCreatedByID(standard.CreatedByID).
			SetUpdatedByID(standard.UpdatedByID).
			SetDeletedAt(standard.DeletedAt).
			SetDeletedByID(standard.DeletedByID).
			SetMappingID(standard.MappingID).
			SetTags(standard.Tags).
			SetName(standard.Name).
			SetDescription(standard.Description).
			SetFamily(standard.Family).
			SetStatus(standard.Status).
			SetStandardType(standard.StandardType).
			SetVersion(standard.Version).
			SetPurposeAndScope(standard.PurposeAndScope).
			SetBackground(standard.Background).
			SetSatisfies(standard.Satisfies).
			SetDetails(standard.Details).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *SubcontrolMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.SubcontrolHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if subcontrolType, exists := m.SubcontrolType(); exists {
		create = create.SetSubcontrolType(subcontrolType)
	}

	if version, exists := m.Version(); exists {
		create = create.SetVersion(version)
	}

	if subcontrolNumber, exists := m.SubcontrolNumber(); exists {
		create = create.SetSubcontrolNumber(subcontrolNumber)
	}

	if family, exists := m.Family(); exists {
		create = create.SetFamily(family)
	}

	if class, exists := m.Class(); exists {
		create = create.SetClass(class)
	}

	if source, exists := m.Source(); exists {
		create = create.SetSource(source)
	}

	if mappedFrameworks, exists := m.MappedFrameworks(); exists {
		create = create.SetMappedFrameworks(mappedFrameworks)
	}

	if implementationEvidence, exists := m.ImplementationEvidence(); exists {
		create = create.SetImplementationEvidence(implementationEvidence)
	}

	if implementationStatus, exists := m.ImplementationStatus(); exists {
		create = create.SetImplementationStatus(implementationStatus)
	}

	if implementationDate, exists := m.ImplementationDate(); exists {
		create = create.SetImplementationDate(implementationDate)
	}

	if implementationVerification, exists := m.ImplementationVerification(); exists {
		create = create.SetImplementationVerification(implementationVerification)
	}

	if implementationVerificationDate, exists := m.ImplementationVerificationDate(); exists {
		create = create.SetImplementationVerificationDate(implementationVerificationDate)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *SubcontrolMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		subcontrol, err := client.Subcontrol.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.SubcontrolHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(subcontrol.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(subcontrol.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(subcontrol.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(subcontrol.UpdatedByID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(subcontrol.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(subcontrol.DeletedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(subcontrol.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(subcontrol.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(subcontrol.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(subcontrol.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(subcontrol.Description)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(subcontrol.Status)
		}

		if subcontrolType, exists := m.SubcontrolType(); exists {
			create = create.SetSubcontrolType(subcontrolType)
		} else {
			create = create.SetSubcontrolType(subcontrol.SubcontrolType)
		}

		if version, exists := m.Version(); exists {
			create = create.SetVersion(version)
		} else {
			create = create.SetVersion(subcontrol.Version)
		}

		if subcontrolNumber, exists := m.SubcontrolNumber(); exists {
			create = create.SetSubcontrolNumber(subcontrolNumber)
		} else {
			create = create.SetSubcontrolNumber(subcontrol.SubcontrolNumber)
		}

		if family, exists := m.Family(); exists {
			create = create.SetFamily(family)
		} else {
			create = create.SetFamily(subcontrol.Family)
		}

		if class, exists := m.Class(); exists {
			create = create.SetClass(class)
		} else {
			create = create.SetClass(subcontrol.Class)
		}

		if source, exists := m.Source(); exists {
			create = create.SetSource(source)
		} else {
			create = create.SetSource(subcontrol.Source)
		}

		if mappedFrameworks, exists := m.MappedFrameworks(); exists {
			create = create.SetMappedFrameworks(mappedFrameworks)
		} else {
			create = create.SetMappedFrameworks(subcontrol.MappedFrameworks)
		}

		if implementationEvidence, exists := m.ImplementationEvidence(); exists {
			create = create.SetImplementationEvidence(implementationEvidence)
		} else {
			create = create.SetImplementationEvidence(subcontrol.ImplementationEvidence)
		}

		if implementationStatus, exists := m.ImplementationStatus(); exists {
			create = create.SetImplementationStatus(implementationStatus)
		} else {
			create = create.SetImplementationStatus(subcontrol.ImplementationStatus)
		}

		if implementationDate, exists := m.ImplementationDate(); exists {
			create = create.SetImplementationDate(implementationDate)
		} else {
			create = create.SetImplementationDate(subcontrol.ImplementationDate)
		}

		if implementationVerification, exists := m.ImplementationVerification(); exists {
			create = create.SetImplementationVerification(implementationVerification)
		} else {
			create = create.SetImplementationVerification(subcontrol.ImplementationVerification)
		}

		if implementationVerificationDate, exists := m.ImplementationVerificationDate(); exists {
			create = create.SetImplementationVerificationDate(implementationVerificationDate)
		} else {
			create = create.SetImplementationVerificationDate(subcontrol.ImplementationVerificationDate)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(subcontrol.Details)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *SubcontrolMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		subcontrol, err := client.Subcontrol.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.SubcontrolHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(subcontrol.CreatedAt).
			SetUpdatedAt(subcontrol.UpdatedAt).
			SetCreatedByID(subcontrol.CreatedByID).
			SetUpdatedByID(subcontrol.UpdatedByID).
			SetDeletedAt(subcontrol.DeletedAt).
			SetDeletedByID(subcontrol.DeletedByID).
			SetMappingID(subcontrol.MappingID).
			SetTags(subcontrol.Tags).
			SetOwnerID(subcontrol.OwnerID).
			SetName(subcontrol.Name).
			SetDescription(subcontrol.Description).
			SetStatus(subcontrol.Status).
			SetSubcontrolType(subcontrol.SubcontrolType).
			SetVersion(subcontrol.Version).
			SetSubcontrolNumber(subcontrol.SubcontrolNumber).
			SetFamily(subcontrol.Family).
			SetClass(subcontrol.Class).
			SetSource(subcontrol.Source).
			SetMappedFrameworks(subcontrol.MappedFrameworks).
			SetImplementationEvidence(subcontrol.ImplementationEvidence).
			SetImplementationStatus(subcontrol.ImplementationStatus).
			SetImplementationDate(subcontrol.ImplementationDate).
			SetImplementationVerification(subcontrol.ImplementationVerification).
			SetImplementationVerificationDate(subcontrol.ImplementationVerificationDate).
			SetDetails(subcontrol.Details).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *TaskMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.TaskHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if title, exists := m.Title(); exists {
		create = create.SetTitle(title)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if due, exists := m.Due(); exists {
		create = create.SetDue(due)
	}

	if completed, exists := m.Completed(); exists {
		create = create.SetCompleted(completed)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *TaskMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		task, err := client.Task.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TaskHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(task.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(task.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(task.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(task.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(task.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(task.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(task.DeletedByID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(task.Tags)
		}

		if title, exists := m.Title(); exists {
			create = create.SetTitle(title)
		} else {
			create = create.SetTitle(task.Title)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(task.Description)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(task.Details)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(task.Status)
		}

		if due, exists := m.Due(); exists {
			create = create.SetDue(due)
		} else {
			create = create.SetDue(task.Due)
		}

		if completed, exists := m.Completed(); exists {
			create = create.SetCompleted(completed)
		} else {
			create = create.SetCompleted(task.Completed)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *TaskMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		task, err := client.Task.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TaskHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(task.CreatedAt).
			SetUpdatedAt(task.UpdatedAt).
			SetCreatedByID(task.CreatedByID).
			SetUpdatedByID(task.UpdatedByID).
			SetMappingID(task.MappingID).
			SetDeletedAt(task.DeletedAt).
			SetDeletedByID(task.DeletedByID).
			SetTags(task.Tags).
			SetTitle(task.Title).
			SetDescription(task.Description).
			SetDetails(task.Details).
			SetStatus(task.Status).
			SetDue(task.Due).
			SetCompleted(task.Completed).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *TemplateMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.TemplateHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if templateType, exists := m.TemplateType(); exists {
		create = create.SetTemplateType(templateType)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if jsonconfig, exists := m.Jsonconfig(); exists {
		create = create.SetJsonconfig(jsonconfig)
	}

	if uischema, exists := m.Uischema(); exists {
		create = create.SetUischema(uischema)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *TemplateMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		template, err := client.Template.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TemplateHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(template.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(template.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(template.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(template.UpdatedByID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(template.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(template.DeletedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(template.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(template.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(template.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(template.Name)
		}

		if templateType, exists := m.TemplateType(); exists {
			create = create.SetTemplateType(templateType)
		} else {
			create = create.SetTemplateType(template.TemplateType)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(template.Description)
		}

		if jsonconfig, exists := m.Jsonconfig(); exists {
			create = create.SetJsonconfig(jsonconfig)
		} else {
			create = create.SetJsonconfig(template.Jsonconfig)
		}

		if uischema, exists := m.Uischema(); exists {
			create = create.SetUischema(uischema)
		} else {
			create = create.SetUischema(template.Uischema)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *TemplateMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		template, err := client.Template.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TemplateHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(template.CreatedAt).
			SetUpdatedAt(template.UpdatedAt).
			SetCreatedByID(template.CreatedByID).
			SetUpdatedByID(template.UpdatedByID).
			SetDeletedAt(template.DeletedAt).
			SetDeletedByID(template.DeletedByID).
			SetMappingID(template.MappingID).
			SetTags(template.Tags).
			SetOwnerID(template.OwnerID).
			SetName(template.Name).
			SetTemplateType(template.TemplateType).
			SetDescription(template.Description).
			SetJsonconfig(template.Jsonconfig).
			SetUischema(template.Uischema).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *UserMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.UserHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if email, exists := m.Email(); exists {
		create = create.SetEmail(email)
	}

	if firstName, exists := m.FirstName(); exists {
		create = create.SetFirstName(firstName)
	}

	if lastName, exists := m.LastName(); exists {
		create = create.SetLastName(lastName)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if avatarRemoteURL, exists := m.AvatarRemoteURL(); exists {
		create = create.SetNillableAvatarRemoteURL(&avatarRemoteURL)
	}

	if avatarLocalFile, exists := m.AvatarLocalFile(); exists {
		create = create.SetNillableAvatarLocalFile(&avatarLocalFile)
	}

	if avatarLocalFileID, exists := m.AvatarLocalFileID(); exists {
		create = create.SetNillableAvatarLocalFileID(&avatarLocalFileID)
	}

	if avatarUpdatedAt, exists := m.AvatarUpdatedAt(); exists {
		create = create.SetNillableAvatarUpdatedAt(&avatarUpdatedAt)
	}

	if lastSeen, exists := m.LastSeen(); exists {
		create = create.SetNillableLastSeen(&lastSeen)
	}

	if password, exists := m.Password(); exists {
		create = create.SetNillablePassword(&password)
	}

	if sub, exists := m.Sub(); exists {
		create = create.SetSub(sub)
	}

	if authProvider, exists := m.AuthProvider(); exists {
		create = create.SetAuthProvider(authProvider)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *UserMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		user, err := client.User.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.UserHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(user.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(user.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(user.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(user.UpdatedByID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(user.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(user.DeletedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(user.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(user.Tags)
		}

		if email, exists := m.Email(); exists {
			create = create.SetEmail(email)
		} else {
			create = create.SetEmail(user.Email)
		}

		if firstName, exists := m.FirstName(); exists {
			create = create.SetFirstName(firstName)
		} else {
			create = create.SetFirstName(user.FirstName)
		}

		if lastName, exists := m.LastName(); exists {
			create = create.SetLastName(lastName)
		} else {
			create = create.SetLastName(user.LastName)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(user.DisplayName)
		}

		if avatarRemoteURL, exists := m.AvatarRemoteURL(); exists {
			create = create.SetNillableAvatarRemoteURL(&avatarRemoteURL)
		} else {
			create = create.SetNillableAvatarRemoteURL(user.AvatarRemoteURL)
		}

		if avatarLocalFile, exists := m.AvatarLocalFile(); exists {
			create = create.SetNillableAvatarLocalFile(&avatarLocalFile)
		} else {
			create = create.SetNillableAvatarLocalFile(user.AvatarLocalFile)
		}

		if avatarLocalFileID, exists := m.AvatarLocalFileID(); exists {
			create = create.SetNillableAvatarLocalFileID(&avatarLocalFileID)
		} else {
			create = create.SetNillableAvatarLocalFileID(user.AvatarLocalFileID)
		}

		if avatarUpdatedAt, exists := m.AvatarUpdatedAt(); exists {
			create = create.SetNillableAvatarUpdatedAt(&avatarUpdatedAt)
		} else {
			create = create.SetNillableAvatarUpdatedAt(user.AvatarUpdatedAt)
		}

		if lastSeen, exists := m.LastSeen(); exists {
			create = create.SetNillableLastSeen(&lastSeen)
		} else {
			create = create.SetNillableLastSeen(user.LastSeen)
		}

		if password, exists := m.Password(); exists {
			create = create.SetNillablePassword(&password)
		} else {
			create = create.SetNillablePassword(user.Password)
		}

		if sub, exists := m.Sub(); exists {
			create = create.SetSub(sub)
		} else {
			create = create.SetSub(user.Sub)
		}

		if authProvider, exists := m.AuthProvider(); exists {
			create = create.SetAuthProvider(authProvider)
		} else {
			create = create.SetAuthProvider(user.AuthProvider)
		}

		if role, exists := m.Role(); exists {
			create = create.SetRole(role)
		} else {
			create = create.SetRole(user.Role)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *UserMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		user, err := client.User.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.UserHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(user.CreatedAt).
			SetUpdatedAt(user.UpdatedAt).
			SetCreatedByID(user.CreatedByID).
			SetUpdatedByID(user.UpdatedByID).
			SetDeletedAt(user.DeletedAt).
			SetDeletedByID(user.DeletedByID).
			SetMappingID(user.MappingID).
			SetTags(user.Tags).
			SetEmail(user.Email).
			SetFirstName(user.FirstName).
			SetLastName(user.LastName).
			SetDisplayName(user.DisplayName).
			SetNillableAvatarRemoteURL(user.AvatarRemoteURL).
			SetNillableAvatarLocalFile(user.AvatarLocalFile).
			SetNillableAvatarLocalFileID(user.AvatarLocalFileID).
			SetNillableAvatarUpdatedAt(user.AvatarUpdatedAt).
			SetNillableLastSeen(user.LastSeen).
			SetNillablePassword(user.Password).
			SetSub(user.Sub).
			SetAuthProvider(user.AuthProvider).
			SetRole(user.Role).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *UserSettingMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.UserSettingHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdByID, exists := m.CreatedByID(); exists {
		create = create.SetCreatedByID(createdByID)
	}

	if updatedByID, exists := m.UpdatedByID(); exists {
		create = create.SetUpdatedByID(updatedByID)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedByID, exists := m.DeletedByID(); exists {
		create = create.SetDeletedByID(deletedByID)
	}

	if userID, exists := m.UserID(); exists {
		create = create.SetUserID(userID)
	}

	if locked, exists := m.Locked(); exists {
		create = create.SetLocked(locked)
	}

	if silencedAt, exists := m.SilencedAt(); exists {
		create = create.SetNillableSilencedAt(&silencedAt)
	}

	if suspendedAt, exists := m.SuspendedAt(); exists {
		create = create.SetNillableSuspendedAt(&suspendedAt)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if emailConfirmed, exists := m.EmailConfirmed(); exists {
		create = create.SetEmailConfirmed(emailConfirmed)
	}

	if isWebauthnAllowed, exists := m.IsWebauthnAllowed(); exists {
		create = create.SetIsWebauthnAllowed(isWebauthnAllowed)
	}

	if isTfaEnabled, exists := m.IsTfaEnabled(); exists {
		create = create.SetIsTfaEnabled(isTfaEnabled)
	}

	if phoneNumber, exists := m.PhoneNumber(); exists {
		create = create.SetNillablePhoneNumber(&phoneNumber)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *UserSettingMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		usersetting, err := client.UserSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.UserSettingHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(usersetting.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(usersetting.UpdatedAt)
		}

		if createdByID, exists := m.CreatedByID(); exists {
			create = create.SetCreatedByID(createdByID)
		} else {
			create = create.SetCreatedByID(usersetting.CreatedByID)
		}

		if updatedByID, exists := m.UpdatedByID(); exists {
			create = create.SetUpdatedByID(updatedByID)
		} else {
			create = create.SetUpdatedByID(usersetting.UpdatedByID)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(usersetting.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(usersetting.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(usersetting.DeletedAt)
		}

		if deletedByID, exists := m.DeletedByID(); exists {
			create = create.SetDeletedByID(deletedByID)
		} else {
			create = create.SetDeletedByID(usersetting.DeletedByID)
		}

		if userID, exists := m.UserID(); exists {
			create = create.SetUserID(userID)
		} else {
			create = create.SetUserID(usersetting.UserID)
		}

		if locked, exists := m.Locked(); exists {
			create = create.SetLocked(locked)
		} else {
			create = create.SetLocked(usersetting.Locked)
		}

		if silencedAt, exists := m.SilencedAt(); exists {
			create = create.SetNillableSilencedAt(&silencedAt)
		} else {
			create = create.SetNillableSilencedAt(usersetting.SilencedAt)
		}

		if suspendedAt, exists := m.SuspendedAt(); exists {
			create = create.SetNillableSuspendedAt(&suspendedAt)
		} else {
			create = create.SetNillableSuspendedAt(usersetting.SuspendedAt)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(usersetting.Status)
		}

		if emailConfirmed, exists := m.EmailConfirmed(); exists {
			create = create.SetEmailConfirmed(emailConfirmed)
		} else {
			create = create.SetEmailConfirmed(usersetting.EmailConfirmed)
		}

		if isWebauthnAllowed, exists := m.IsWebauthnAllowed(); exists {
			create = create.SetIsWebauthnAllowed(isWebauthnAllowed)
		} else {
			create = create.SetIsWebauthnAllowed(usersetting.IsWebauthnAllowed)
		}

		if isTfaEnabled, exists := m.IsTfaEnabled(); exists {
			create = create.SetIsTfaEnabled(isTfaEnabled)
		} else {
			create = create.SetIsTfaEnabled(usersetting.IsTfaEnabled)
		}

		if phoneNumber, exists := m.PhoneNumber(); exists {
			create = create.SetNillablePhoneNumber(&phoneNumber)
		} else {
			create = create.SetNillablePhoneNumber(usersetting.PhoneNumber)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *UserSettingMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	updatedBy, _ := ctx.Value("updated_by_id").(string)

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		usersetting, err := client.UserSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.UserSettingHistory.Create()
		if updatedBy != "" {
			create = create.SetUpdatedBy(updatedBy)
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(usersetting.CreatedAt).
			SetUpdatedAt(usersetting.UpdatedAt).
			SetCreatedByID(usersetting.CreatedByID).
			SetUpdatedByID(usersetting.UpdatedByID).
			SetMappingID(usersetting.MappingID).
			SetTags(usersetting.Tags).
			SetDeletedAt(usersetting.DeletedAt).
			SetDeletedByID(usersetting.DeletedByID).
			SetUserID(usersetting.UserID).
			SetLocked(usersetting.Locked).
			SetNillableSilencedAt(usersetting.SilencedAt).
			SetNillableSuspendedAt(usersetting.SuspendedAt).
			SetStatus(usersetting.Status).
			SetEmailConfirmed(usersetting.EmailConfirmed).
			SetIsWebauthnAllowed(usersetting.IsWebauthnAllowed).
			SetIsTfaEnabled(usersetting.IsTfaEnabled).
			SetNillablePhoneNumber(usersetting.PhoneNumber).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}
